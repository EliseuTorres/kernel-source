From 0c3833d1f46e1979aaf892d05dcfd8c9839891d8 Mon Sep 17 00:00:00 2001
From: Alex Elder <elder@inktank.com>
Date: Wed, 13 Mar 2013 20:50:01 -0500
Subject: [PATCH 749/938] libceph: clean up ceph_osd_new_request()
References: fate#312983
Git-commit: d18d1e2807f38a94839be1f83682e17011f53322
Patch-mainline: v3.10

All callers of ceph_osd_new_request() pass either CEPH_OSD_OP_READ
or CEPH_OSD_OP_WRITE as the opcode value.  The function assumes it
by filling in the extent fields in the ops array it builds.  So just
assert that is the case, and don't bother calling op_has_extent()
before filling in the first osd operation in the array.

Define some local variables to gather the information to fill into
the first op, and then fill in the op array all in one place.

Signed-off-by: Alex Elder <elder@inktank.com>
Reviewed-by: Josh Durgin <josh.durgin@inktank.com>
Acked-by: Danny Al-Gaaf <dalgaaf@suse.de>

---
 net/ceph/osd_client.c | 50 ++++++++++++++++++++++----------------------------
 1 file changed, 22 insertions(+), 28 deletions(-)

diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index 0eb417b..7136060 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -32,12 +32,6 @@ static void __unregister_linger_request(struct ceph_osd_client *osdc,
 static void __send_request(struct ceph_osd_client *osdc,
 			   struct ceph_osd_request *req);
 
-static int op_has_extent(int op)
-{
-	return (op == CEPH_OSD_OP_READ ||
-		op == CEPH_OSD_OP_WRITE);
-}
-
 /*
  * Implement client access to distributed object storage cluster.
  *
@@ -554,22 +548,15 @@ struct ceph_osd_request *ceph_osdc_new_request(struct ceph_osd_client *osdc,
 {
 	struct ceph_osd_req_op ops[2];
 	struct ceph_osd_request *req;
-	unsigned int num_op = 1;
+	unsigned int num_op = do_sync ? 2 : 1;
 	u64 objnum = 0;
 	u64 objoff = 0;
 	u64 objlen = 0;
+	u32 object_size;
+	u64 object_base;
 	int r;
 
-	memset(&ops, 0, sizeof ops);
-
-	ops[0].op = opcode;
-	ops[0].extent.truncate_seq = truncate_seq;
-	ops[0].extent.truncate_size = truncate_size;
-
-	if (do_sync) {
-		ops[1].op = CEPH_OSD_OP_STARTSYNC;
-		num_op++;
-	}
+	BUG_ON(opcode != CEPH_OSD_OP_READ && opcode != CEPH_OSD_OP_WRITE);
 
 	req = ceph_osdc_alloc_request(osdc, snapc, num_op, use_mempool,
 					GFP_NOFS);
@@ -584,21 +571,28 @@ struct ceph_osd_request *ceph_osdc_new_request(struct ceph_osd_client *osdc,
 		return ERR_PTR(r);
 	}
 
-	if (op_has_extent(ops[0].op)) {
-		u32 osize = le32_to_cpu(layout->fl_object_size);
-		ops[0].extent.offset = objoff;
-		ops[0].extent.length = objlen;
-		if (ops[0].extent.truncate_size <= off - objoff) {
-			ops[0].extent.truncate_size = 0;
-		} else {
-			ops[0].extent.truncate_size -= off - objoff;
-			if (ops[0].extent.truncate_size > osize)
-				ops[0].extent.truncate_size = osize;
-		}
+	object_size = le32_to_cpu(layout->fl_object_size);
+	object_base = off - objoff;
+	if (truncate_size <= object_base) {
+		truncate_size = 0;
+	} else {
+		truncate_size -= object_base;
+		if (truncate_size > object_size)
+			truncate_size = object_size;
 	}
+
+	memset(&ops, 0, sizeof ops);
+	ops[0].op = opcode;
+	ops[0].extent.offset = objoff;
+	ops[0].extent.length = objlen;
+	ops[0].extent.truncate_size = truncate_size;
+	ops[0].extent.truncate_seq = truncate_seq;
 	if (ops[0].op == CEPH_OSD_OP_WRITE)
 		ops[0].payload_len = *plen;
 
+	if (do_sync)
+		ops[1].op = CEPH_OSD_OP_STARTSYNC;
+
 	req->r_file_layout = *layout;  /* keep a copy */
 
 	snprintf(req->r_oid, sizeof(req->r_oid), "%llx.%08llx",
-- 
1.8.3

