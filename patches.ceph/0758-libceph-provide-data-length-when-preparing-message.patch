From 2454f6c1897e75745aac8867a45f7d9d2009c344 Mon Sep 17 00:00:00 2001
From: Alex Elder <elder@inktank.com>
Date: Tue, 2 Apr 2013 12:09:50 -0500
Subject: [PATCH 758/938] libceph: provide data length when preparing message
References: fate#312983
Git-commit: 98fa5dd883aadbb0020b68d0f9367ba152dfe511
Patch-mainline: v3.10

In prepare_message_data(), the length used to initialize the cursor
is taken from the header of the message provided.  I'm working
toward not using the header data length field to determine length in
outbound messages, and this is a step in that direction.  For
inbound messages this will be set to be the actual number of bytes
that are arriving (which may be less than the total size of the data
buffer available).

This resolves:
    http://tracker.ceph.com/issues/4589

Signed-off-by: Alex Elder <elder@inktank.com>
Reviewed-by: Josh Durgin <josh.durgin@inktank.com>
Acked-by: Danny Al-Gaaf <dalgaaf@suse.de>

---
 net/ceph/messenger.c | 19 ++++++++-----------
 1 file changed, 8 insertions(+), 11 deletions(-)

diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c
index 4d6d977..79a2565 100644
--- a/net/ceph/messenger.c
+++ b/net/ceph/messenger.c
@@ -1075,18 +1075,14 @@ static bool ceph_msg_data_advance(struct ceph_msg_data *data, size_t bytes)
 	return new_piece;
 }
 
-static void prepare_message_data(struct ceph_msg *msg)
+static void prepare_message_data(struct ceph_msg *msg, u32 data_len)
 {
-	size_t data_len;
-
 	BUG_ON(!msg);
-
-	data_len = le32_to_cpu(msg->hdr.data_len);
 	BUG_ON(!data_len);
 
 	/* Initialize data cursor */
 
-	ceph_msg_data_cursor_init(msg->data, data_len);
+	ceph_msg_data_cursor_init(msg->data, (size_t)data_len);
 }
 
 /*
@@ -1149,11 +1145,12 @@ static void prepare_write_message(struct ceph_connection *con)
 		m->hdr.seq = cpu_to_le64(++con->out_seq);
 		m->needs_out_seq = false;
 	}
+	WARN_ON(m->data_length != le32_to_cpu(m->hdr.data_len));
 
-	dout("prepare_write_message %p seq %lld type %d len %d+%d+%d\n",
+	dout("prepare_write_message %p seq %lld type %d len %d+%d+%zd\n",
 	     m, con->out_seq, le16_to_cpu(m->hdr.type),
 	     le32_to_cpu(m->hdr.front_len), le32_to_cpu(m->hdr.middle_len),
-	     le32_to_cpu(m->hdr.data_len));
+	     m->data_length);
 	BUG_ON(le32_to_cpu(m->hdr.front_len) != m->front.iov_len);
 
 	/* tag + hdr + front + middle */
@@ -1184,8 +1181,8 @@ static void prepare_write_message(struct ceph_connection *con)
 
 	/* is there a data payload? */
 	con->out_msg->footer.data_crc = 0;
-	if (m->hdr.data_len) {
-		prepare_message_data(con->out_msg);
+	if (m->data_length) {
+		prepare_message_data(con->out_msg, m->data_length);
 		con->out_more = 1;  /* data + footer will follow */
 	} else {
 		/* no, queue up footer too and be done */
@@ -2230,7 +2227,7 @@ static int read_partial_message(struct ceph_connection *con)
 		/* prepare for data payload, if any */
 
 		if (data_len)
-			prepare_message_data(con->in_msg);
+			prepare_message_data(con->in_msg, data_len);
 	}
 
 	/* front */
-- 
1.8.3

