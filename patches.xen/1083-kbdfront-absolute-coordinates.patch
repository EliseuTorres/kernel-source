From: http://xenbits.xen.org/hg/linux-2.6.18-xen.hg/rev/211849d9d511
# HG changeset patch
# User Olaf Hering <olaf@aepfle.de>
# Date 1305877896 -3600
# Node ID 211849d9d51115c7b4ed6e3010e10111b5d5db1d
# Parent  b43e88a985e01d1647ee83411d0b791783c96f84
Subject: xen-kbdfront - advertise either absolute or relative coordinates
References: bnc#670465
Patch-mainline: n/a

Mainline commit 8c3c283e6bf463ab498d6e7823aff6c4762314b6
Mainline commit c36b58e8a9112017c2bcc322cc98e71241814303

    A virtualized display device is usually viewed with the vncviewer
    application, either by 'xm vnc domU' or with vncviewer
    localhost:port.  vncviewer and the RFB protocol provides absolute
    coordinates to the virtual display. These coordinates are either
    passed through to a PV guest or converted to relative coordinates
    for a HVM guest.

    A PV guest receives these coordinates and passes them to the
    kernels evdev driver. There it can be picked up by applications
    such as the xorg-input drivers. Using absolute coordinates avoids
    issues such as guest mouse pointer not tracking host mouse pointer
    due to wrong mouse acceleration settings in the guests X display.

    Advertise either absolute or relative coordinates to the input
    system and the evdev driver, depending on what dom0 provides. The
    xorg-input driver prefers relative coordinates even if a devices
    provides both.

    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

Acked-by: jbeulich@novell.com

--- sle11sp1-2011-05-20.orig/drivers/xen/fbfront/xenkbd.c	2011-05-20 12:34:30.000000000 +0200
+++ sle11sp1-2011-05-20/drivers/xen/fbfront/xenkbd.c	2011-05-20 13:45:19.000000000 +0200
@@ -104,7 +104,7 @@ static irqreturn_t input_handler(int rq,
 int __devinit xenkbd_probe(struct xenbus_device *dev,
 			   const struct xenbus_device_id *id)
 {
-	int ret, i;
+	int ret, i, abs;
 	struct xenkbd_info *info;
 	struct input_dev *kbd, *ptr;
 
@@ -123,6 +123,11 @@ int __devinit xenkbd_probe(struct xenbus
 	info->page->in_cons = info->page->in_prod = 0;
 	info->page->out_cons = info->page->out_prod = 0;
 
+	if (xenbus_scanf(XBT_NIL, dev->otherend, "feature-abs-pointer", "%d", &abs) < 0)
+		abs = 0;
+	if (abs)
+		xenbus_printf(XBT_NIL, dev->nodename, "request-abs-pointer", "1");
+
 	/* keyboard */
 	kbd = input_allocate_device();
 	if (!kbd)
@@ -155,12 +160,20 @@ int __devinit xenkbd_probe(struct xenbus
 	ptr->id.bustype = BUS_PCI;
 	ptr->id.vendor = 0x5853;
 	ptr->id.product = 0xfffe;
-	ptr->evbit[0] = BIT(EV_KEY) | BIT(EV_REL) | BIT(EV_ABS);
+
+	if (abs) {
+		__set_bit(EV_ABS, ptr->evbit);
+		input_set_abs_params(ptr, ABS_X, 0, XENFB_WIDTH, 0, 0);
+		input_set_abs_params(ptr, ABS_Y, 0, XENFB_HEIGHT, 0, 0);
+	} else {
+		__set_bit(REL_X, ptr->relbit);
+		__set_bit(REL_Y, ptr->relbit);
+	}
+	__set_bit(REL_WHEEL, ptr->relbit);
+
+	__set_bit(EV_KEY, ptr->evbit);
 	for (i = BTN_LEFT; i <= BTN_TASK; i++)
-		set_bit(i, ptr->keybit);
-	ptr->relbit[0] = BIT(REL_X) | BIT(REL_Y) | BIT(REL_WHEEL);
-	input_set_abs_params(ptr, ABS_X, 0, XENFB_WIDTH, 0, 0);
-	input_set_abs_params(ptr, ABS_Y, 0, XENFB_HEIGHT, 0, 0);
+		__set_bit(i, ptr->keybit);
 
 	ret = input_register_device(ptr);
 	if (ret) {
