From: Chen Gong <gong.chen@linux.intel.com>
Subject: APEI infrastructure support
References: fate#311701,fate#311703,fate#311704,fate#311771,fate#311706,fate#311772,bnc#697859
Patch-Mainline: yes

Signed-off-by: Thomas Renninger <trenn@suse.de>

APEI provides an interface for Platform Error Interface via ACPI.
Hardware errors can be looked up in firmware tables in order to
gain more information about the error source. This brings our
APEI support up to upstream levels.

Signed-off-by: Chen Gong <gong.chen@linux.intel.com>
Automatically created from "patches.drivers/001-apei_infrastructure.patch" by xen-port-patches.py

--- sle11sp2-2011-07-15.orig/arch/x86/include/mach-xen/asm/mach_traps.h	2007-06-12 13:14:02.000000000 +0200
+++ sle11sp2-2011-07-15/arch/x86/include/mach-xen/asm/mach_traps.h	2011-02-07 12:21:00.000000000 +0100
@@ -9,7 +9,11 @@
 #include <linux/bitops.h>
 #include <xen/interface/nmi.h>
 
-static inline void clear_mem_error(unsigned char reason) {}
+#define NMI_REASON_SERR		0x80
+#define NMI_REASON_IOCHK	0x40
+#define NMI_REASON_MASK		(NMI_REASON_SERR | NMI_REASON_IOCHK)
+
+static inline void clear_serr_error(unsigned char reason) {}
 static inline void clear_io_check_error(unsigned char reason) {}
 
 static inline unsigned char get_nmi_reason(void)
@@ -21,9 +25,9 @@ static inline unsigned char get_nmi_reas
 	 * port 0x61.
 	 */
 	if (test_bit(_XEN_NMIREASON_io_error, &s->arch.nmi_reason))
-		reason |= 0x40;
+		reason |= NMI_REASON_IOCHK;
 	if (test_bit(_XEN_NMIREASON_parity_error, &s->arch.nmi_reason))
-		reason |= 0x80;
+		reason |= NMI_REASON_SERR;
 
         return reason;
 }
--- sle11sp2-2011-07-15.orig/arch/x86/kernel/traps-xen.c	2011-07-15 14:08:55.000000000 +0200
+++ sle11sp2-2011-07-15/arch/x86/kernel/traps-xen.c	2011-07-15 14:22:50.000000000 +0200
@@ -313,15 +313,15 @@ gp_in_kernel:
 }
 
 static notrace __kprobes void
-mem_parity_error(unsigned char reason, struct pt_regs *regs)
+pci_serr_error(unsigned char reason, struct pt_regs *regs)
 {
-	printk(KERN_EMERG
-		"Uhhuh. NMI received for unknown reason %02x on CPU %d.\n",
-			reason, smp_processor_id());
-
-	printk(KERN_EMERG
-		"You have some hardware problem, likely on the PCI bus.\n");
+	pr_emerg("NMI: PCI system error (SERR) for reason %02x on CPU %d.\n",
+		reason, smp_processor_id());
 
+	/*
+	 * On some machines, PCI SERR line is used to report memory
+	 * errors. EDAC makes use of it.
+	 */
 #if defined(CONFIG_EDAC)
 	if (edac_handler_set()) {
 		edac_atomic_assert_error();
@@ -332,16 +332,18 @@ mem_parity_error(unsigned char reason, s
 	if (panic_on_unrecovered_nmi)
 		panic("NMI: Not continuing");
 
-	printk(KERN_EMERG "Dazed and confused, but trying to continue\n");
+	pr_emerg("Dazed and confused, but trying to continue\n");
 
-	/* Clear and disable the memory parity error line. */
-	clear_mem_error(reason);
+	/* Clear and disable the PCI SERR error line. */
+	clear_serr_error(reason);
 }
 
 static notrace __kprobes void
 io_check_error(unsigned char reason, struct pt_regs *regs)
 {
-	printk(KERN_EMERG "NMI: IOCK error (debug interrupt?)\n");
+	pr_emerg(
+	"NMI: IOCK error (debug interrupt?) for reason %02x on CPU %d.\n",
+		reason, smp_processor_id());
 	show_registers(regs);
 
 	if (panic_on_io_nmi)
@@ -367,15 +369,14 @@ unknown_nmi_error(unsigned char reason, 
 		return;
 	}
 #endif
-	printk(KERN_EMERG
-		"Uhhuh. NMI received for unknown reason %02x on CPU %d.\n",
-			reason, smp_processor_id());
+	pr_emerg("Uhhuh. NMI received for unknown reason %02x on CPU %d.\n",
+		reason, smp_processor_id());
 
-	printk(KERN_EMERG "Do you have a strange power saving mode enabled?\n");
+	pr_emerg("Do you have a strange power saving mode enabled?\n");
 	if (panic_on_unrecovered_nmi)
 		panic("NMI: Not continuing");
 
-	printk(KERN_EMERG "Dazed and confused, but trying to continue\n");
+	pr_emerg("Dazed and confused, but trying to continue\n");
 }
 
 static notrace __kprobes void default_do_nmi(struct pt_regs *regs)
@@ -383,16 +384,16 @@ static notrace __kprobes void default_do
 	unsigned char reason = 0;
 	int cpu;
 
+	if (notify_die(DIE_NMI, "nmi", regs, reason, 2, SIGINT) == NOTIFY_STOP)
+		return;
+
 	cpu = smp_processor_id();
 
 	/* Only the BSP gets external NMIs from the system. */
 	if (!cpu)
 		reason = get_nmi_reason();
 
-	if (!(reason & 0xc0)) {
-		if (notify_die(DIE_NMI_IPI, "nmi_ipi", regs, reason, 2, SIGINT)
-								== NOTIFY_STOP)
-			return;
+	if (!(reason & NMI_REASON_MASK)) {
 #ifdef CONFIG_X86_LOCAL_APIC
 		/*
 		 * Ok, so this is none of the documented NMI sources,
@@ -408,13 +409,11 @@ static notrace __kprobes void default_do
 
 		return;
 	}
-	if (notify_die(DIE_NMI, "nmi", regs, reason, 2, SIGINT) == NOTIFY_STOP)
-		return;
 
 	/* AK: following checks seem to be broken on modern chipsets. FIXME */
-	if (reason & 0x80)
-		mem_parity_error(reason, regs);
-	if (reason & 0x40)
+	if (reason & NMI_REASON_SERR)
+		pci_serr_error(reason, regs);
+	if (reason & NMI_REASON_IOCHK)
 		io_check_error(reason, regs);
 #if defined(CONFIG_X86_32) && !defined(CONFIG_XEN)
 	/*
--- sle11sp2-2011-07-15.orig/arch/x86/mm/ioremap-xen.c	2011-06-20 11:07:40.000000000 +0200
+++ sle11sp2-2011-07-15/arch/x86/mm/ioremap-xen.c	2011-07-01 10:16:43.000000000 +0200
@@ -197,6 +197,16 @@ int page_is_ram(unsigned long pagenr)
 	return 0;
 }
 
+#ifdef CONFIG_MODULES
+/*
+ * Force the implementation of ioremap_page_range() to be pulled in from
+ * lib/lib.a even if there is no other reference from the core kernel to it
+ * (native uses it in __ioremap_caller()), so that it gets exported.
+ */
+static void *const __section(.discard.ioremap) __used
+_ioremap_page_range = ioremap_page_range;
+#endif
+
 /*
  * Fix up the linear direct mapping of the kernel to avoid cache attribute
  * conflicts.
