From: Hannes Reinecke <hare@suse.de>
Date:Thu May 26 13:57:47 2011 +0200
Subject: sfc: Port to new kfifo API
Patch-Mainline: No
References: FATE#311054

Compile-tested only, need to be checked with updated driver.

Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/net/sfc/sfc_resource/ci/efrm/private.h b/drivers/net/sfc/sfc_resource/ci/efrm/private.h
index d1e09c7..a7527e0 100644
--- a/drivers/net/sfc/sfc_resource/ci/efrm/private.h
+++ b/drivers/net/sfc/sfc_resource/ci/efrm/private.h
@@ -71,23 +71,19 @@ efrm_create_vi_resource_manager(struct efrm_resource_manager **out,
 
 /*! Allocate instance pool. Use kfifo_vfree to destroy it. */
 static inline int
-efrm_kfifo_id_ctor(struct kfifo **ids_out,
+efrm_kfifo_id_ctor(struct kfifo *ids,
 		   unsigned int base, unsigned int limit, spinlock_t *lock)
 {
 	unsigned int i;
-	struct kfifo *ids;
 	unsigned char *buffer;
 	unsigned int size = roundup_pow_of_two((limit - base) * sizeof(int));
 	EFRM_ASSERT(base <= limit);
 	buffer = vmalloc(size);
-	ids = kfifo_init(buffer, size, GFP_KERNEL, lock);
-	if (IS_ERR(ids))
-		return PTR_ERR(ids);
+	kfifo_init(ids, buffer, size);
 	for (i = base; i < limit; i++)
-		EFRM_VERIFY_EQ(__kfifo_put(ids, (unsigned char *)&i,
-					   sizeof(i)), sizeof(i));
+		EFRM_VERIFY_EQ(kfifo_in(ids, (unsigned char *)&i,
+					sizeof(i)), sizeof(i));
 
-	*ids_out = ids;
 	return 0;
 }
 
diff --git a/drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_manager.h b/drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_manager.h
index 97840b3..ded1b3d 100644
--- a/drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_manager.h
+++ b/drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_manager.h
@@ -62,10 +62,10 @@ enum {
 struct vi_resource_manager {
 	struct efrm_resource_manager rm;
 
-	struct kfifo *instances_with_timer;
+	struct kfifo instances_with_timer;
 	int with_timer_base;
 	int with_timer_limit;
-	struct kfifo *instances_with_interrupt;
+	struct kfifo instances_with_interrupt;
 	int with_interrupt_base;
 	int with_interrupt_limit;
 
diff --git a/drivers/net/sfc/sfc_resource/filter_resource.c b/drivers/net/sfc/sfc_resource/filter_resource.c
index d2813b8..bdc94bd 100644
--- a/drivers/net/sfc/sfc_resource/filter_resource.c
+++ b/drivers/net/sfc/sfc_resource/filter_resource.c
@@ -48,7 +48,7 @@
 
 struct filter_resource_manager {
 	struct efrm_resource_manager rm;
-	struct kfifo *free_ids;
+	struct kfifo free_ids;
 };
 
 static struct filter_resource_manager *efrm_filter_manager;
@@ -70,7 +70,7 @@ void efrm_filter_resource_free(struct filter_resource *frs)
 
 	/* Free this filter. */
 	id = EFRM_RESOURCE_INSTANCE(frs->rs.rs_handle);
-	EFRM_VERIFY_EQ(kfifo_put(efrm_filter_manager->free_ids,
+	EFRM_VERIFY_EQ(kfifo_out(&efrm_filter_manager->free_ids,
 				 (unsigned char *)&id, sizeof(id)),
 		       sizeof(id));
 
@@ -96,7 +96,7 @@ static void filter_rm_dtor(struct efrm_resource_manager *rm)
 	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_filter_manager->rm);
 	EFRM_ASSERT(&efrm_filter_manager->rm == rm);
 
-	kfifo_vfree(efrm_filter_manager->free_ids);
+	kfifo_vfree(&efrm_filter_manager->free_ids);
 	EFRM_TRACE("%s: done", __func__);
 }
 
@@ -130,7 +130,7 @@ int efrm_create_filter_resource_manager(struct efrm_resource_manager **rm_out)
 
 	*rm_out = &efrm_filter_manager->rm;
 	EFRM_TRACE("%s: filter resources created - %d IDs",
-		   __func__, kfifo_len(efrm_filter_manager->free_ids));
+		   __func__, kfifo_len(&efrm_filter_manager->free_ids));
 	return 0;
 
 fail2:
@@ -195,7 +195,7 @@ efrm_filter_resource_alloc(struct vi_resource *vi_parent,
 		return -ENOMEM;
 
 	/* Allocate an instance. */
-	rc = kfifo_get(efrm_filter_manager->free_ids,
+	rc = kfifo_out(&efrm_filter_manager->free_ids,
 		       (unsigned char *)&instance, sizeof(instance));
 	if (rc != sizeof(instance)) {
 		EFRM_TRACE("%s: out of instances", __func__);
diff --git a/drivers/net/sfc/sfc_resource/iobufset_resource.c b/drivers/net/sfc/sfc_resource/iobufset_resource.c
index 71d926f..1a2b779 100644
--- a/drivers/net/sfc/sfc_resource/iobufset_resource.c
+++ b/drivers/net/sfc/sfc_resource/iobufset_resource.c
@@ -50,7 +50,7 @@
 
 struct iobufset_resource_manager {
 	struct efrm_resource_manager rm;
-	struct kfifo *free_ids;
+	struct kfifo free_ids;
 };
 
 struct iobufset_resource_manager *efrm_iobufset_manager;
@@ -97,8 +97,8 @@ void efrm_iobufset_resource_free(struct iobufset_resource *rs)
 
 	/* free the instance number */
 	id = EFRM_RESOURCE_INSTANCE(rs->rs.rs_handle);
-	EFRM_VERIFY_EQ(kfifo_put(efrm_iobufset_manager->free_ids,
-				 (unsigned char *)&id, sizeof(id)), sizeof(id));
+	EFRM_VERIFY_EQ(kfifo_in(&efrm_iobufset_manager->free_ids,
+				(unsigned char *)&id, sizeof(id)), sizeof(id));
 
 	efrm_vi_resource_release(rs->evq);
 	if (rs->linked)
@@ -181,7 +181,7 @@ efrm_iobufset_resource_alloc(int32_t n_pages,
 	}
 
 	/* Allocate an instance number. */
-	rc = kfifo_get(efrm_iobufset_manager->free_ids,
+	rc = kfifo_out(&efrm_iobufset_manager->free_ids,
 		       (unsigned char *)&instance, sizeof(instance));
 	if (rc != sizeof(instance)) {
 		EFRM_WARN("%s: out of instances", __func__);
@@ -338,7 +338,7 @@ EXPORT_SYMBOL(efrm_iobufset_resource_alloc);
 static void iobufset_rm_dtor(struct efrm_resource_manager *rm)
 {
 	EFRM_ASSERT(&efrm_iobufset_manager->rm == rm);
-	kfifo_vfree(efrm_iobufset_manager->free_ids);
+	kfifo_vfree(&efrm_iobufset_manager->free_ids);
 }
 
 int
@@ -394,7 +394,7 @@ efrm_create_iobufset_resource_manager(struct efrm_resource_manager **rm_out)
 	return 0;
 
 fail2:
-	kfifo_vfree(efrm_iobufset_manager->free_ids);
+	kfifo_vfree(&efrm_iobufset_manager->free_ids);
 fail1:
 	EFRM_DO_DEBUG(memset(efrm_iobufset_manager, 0,
 			     sizeof(*efrm_iobufset_manager)));
diff --git a/drivers/net/sfc/sfc_resource/vi_resource_alloc.c b/drivers/net/sfc/sfc_resource/vi_resource_alloc.c
index 5d139df..a7cc140 100644
--- a/drivers/net/sfc/sfc_resource/vi_resource_alloc.c
+++ b/drivers/net/sfc/sfc_resource/vi_resource_alloc.c
@@ -118,8 +118,8 @@ static inline int efrm_vi_rm_alloc_id(uint16_t vi_flags, int32_t evq_capacity)
 	}
 
 	if (vi_flags & EFHW_VI_RM_WITH_INTERRUPT) {
-		rc = __kfifo_get(efrm_vi_manager->instances_with_interrupt,
-				 (unsigned char *)&instance, sizeof(instance));
+		rc = kfifo_out(&efrm_vi_manager->instances_with_interrupt,
+			       (unsigned char *)&instance, sizeof(instance));
 		if (rc != sizeof(instance)) {
 			EFRM_ASSERT(rc == 0);
 			instance = -1;
@@ -128,8 +128,8 @@ static inline int efrm_vi_rm_alloc_id(uint16_t vi_flags, int32_t evq_capacity)
 	}
 
 	/* Otherwise a normal run-of-the-mill VI. */
-	rc = __kfifo_get(efrm_vi_manager->instances_with_timer,
-			 (unsigned char *)&instance, sizeof(instance));
+	rc = kfifo_out(&efrm_vi_manager->instances_with_timer,
+		       (unsigned char *)&instance, sizeof(instance));
 	if (rc != sizeof(instance)) {
 		EFRM_ASSERT(rc == 0);
 		instance = -1;
@@ -159,16 +159,16 @@ static void efrm_vi_rm_free_id(int instance)
 	} else {
 		if (instance >= efrm_vi_manager->with_timer_base &&
 		    instance < efrm_vi_manager->with_timer_limit) {
-			instances = efrm_vi_manager->instances_with_timer;
+			instances = &efrm_vi_manager->instances_with_timer;
 		} else {
 			EFRM_ASSERT(instance >=
 				    efrm_vi_manager->with_interrupt_base);
 			EFRM_ASSERT(instance <
 				    efrm_vi_manager->with_interrupt_limit);
-			instances = efrm_vi_manager->instances_with_interrupt;
+			instances = &efrm_vi_manager->instances_with_interrupt;
 		}
 
-		EFRM_VERIFY_EQ(kfifo_put(instances, (unsigned char *)&instance,
+		EFRM_VERIFY_EQ(kfifo_out(instances, (unsigned char *)&instance,
 					 sizeof(instance)), sizeof(instance));
 	}
 }
diff --git a/drivers/net/sfc/sfc_resource/vi_resource_manager.c b/drivers/net/sfc/sfc_resource/vi_resource_manager.c
index ca41b1c..21a32da 100644
--- a/drivers/net/sfc/sfc_resource/vi_resource_manager.c
+++ b/drivers/net/sfc/sfc_resource/vi_resource_manager.c
@@ -198,10 +198,10 @@ fail_rm_ctor:
 	destroy_workqueue(efrm_vi_manager->workqueue);
 fail_create_workqueue:
 	EFRM_ASSERT(list_empty(&efrm_vi_manager->close_pending));
-	kfifo_vfree(efrm_vi_manager->instances_with_interrupt);
+	kfifo_vfree(&efrm_vi_manager->instances_with_interrupt);
 fail_with_int_id_pool:
 
-	kfifo_vfree(efrm_vi_manager->instances_with_timer);
+	kfifo_vfree(&efrm_vi_manager->instances_with_timer);
 fail_with_timer_id_pool:
 
 	if (destroy)
