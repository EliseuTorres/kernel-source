From: Mel Gorman <mgorman@suse.de>
Date: Fri, 13 Dec 2013 15:49:50 +0000
Subject: [PATCH] x86: mm: Eliminate redundant page table walk during TLB range
 flushing

References: VM Performance
Patch-mainline: No (expected v3.14)

When choosing between doing an address space or ranged flush, the x86
implementation of flush_tlb_mm_range takes into account whether there are
any large pages in the range. A per-page flush typically requires fewer
entries than would covered by a single large page and the check is redundant.

There is one potential exception. THP migration flushes single THP entries
and it conceivably would benefit from flushing a single entry instead
of the mm.  However, this flush is after a THP allocation, copy and page
table update potentially with any other threads serialised behind it. In
comparison to that, the flush is noise. It makes more sense to optimise
balancing to require fewer flushes than to optimise the flush itself.

This patch deletes the huge page check.

Signed-off-by: Mel Gorman <mgorman@suse.de>
Automatically created from "patches.suse/x86-mm-Eliminate-redundant-page-table-walk-during-TLB-range-flushing.patch" by xen-port-patches.py

--- sle12.orig/arch/x86/mm/tlb-xen.c	2014-01-09 12:09:36.000000000 +0100
+++ sle12/arch/x86/mm/tlb-xen.c	2014-01-09 12:11:35.000000000 +0100
@@ -9,32 +9,6 @@
 #include <asm/cache.h>
 #include <linux/debugfs.h>
 
-/*
- * It can find out the THP large page, or
- * HUGETLB page in tlb_flush when THP disabled
- */
-static inline unsigned long has_large_page(struct mm_struct *mm,
-				 unsigned long start, unsigned long end)
-{
-	pgd_t *pgd;
-	pud_t *pud;
-	pmd_t *pmd;
-	unsigned long addr = ALIGN(start, HPAGE_SIZE);
-	for (; addr < end; addr += HPAGE_SIZE) {
-		pgd = pgd_offset(mm, addr);
-		if (likely(!pgd_none(*pgd))) {
-			pud = pud_offset(pgd, addr);
-			if (likely(!pud_none(*pud))) {
-				pmd = pmd_offset(pud, addr);
-				if (likely(!pmd_none(*pmd)))
-					if (pmd_large(*pmd))
-						return addr;
-			}
-		}
-	}
-	return 0;
-}
-
 void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
 				unsigned long end, unsigned long vmflag)
 {
@@ -73,7 +47,7 @@ void flush_tlb_mm_range(struct mm_struct
 	nr_base_pages = (end - start) >> PAGE_SHIFT;
 
 	/* tlb_flushall_shift is on balance point, details in commit log */
-	if (nr_base_pages <= act_entries && !has_large_page(mm, start, end)) {
+	if (nr_base_pages <= act_entries) {
 		/* flush range by one by one 'invlpg' */
 		for (addr = start; addr < end; addr += PAGE_SIZE) {
 			count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);
