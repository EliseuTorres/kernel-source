From: Youquan Song <youquan.song@intel.com>
Subject: [PATCH] Enable SMEP
Patch-mainline: v3.0-rc1
References: FATE#311999

Add support for newly feature SMEP (Supervisor Mode Execution Protection).

SMEP prevents the CPU in kernel-mode to jump to an executable page
that has the user flag set in the PTE.  This prevents the kernel from
executing user-space code accidentally or maliciously, so it for
example prevents kernel exploits from jumping to specially prepared
user-mode shell code.

[-js: d0281a257 moved to a separate patch due to conflicts. The same for
bdc802dcc which was not even mentioned here. All-in-one patches SUCK!]

Signed-off-by: Youquan Song <youquan.song@intel.com>
Acked-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Automatically created from "patches.arch/x86-enable-smep.patch" by xen-port-patches.py

--- sle11sp2-2011-06-28.orig/arch/x86/kernel/cpu/common-xen.c	2011-06-28 13:13:21.000000000 +0200
+++ sle11sp2-2011-06-28/arch/x86/kernel/cpu/common-xen.c	2011-06-28 13:14:31.000000000 +0200
@@ -259,6 +259,25 @@ static inline void squash_the_stupid_ser
 }
 #endif
 
+static int disable_smep __cpuinitdata;
+static __init int setup_disable_smep(char *arg)
+{
+	disable_smep = 1;
+	return 1;
+}
+__setup("nosmep", setup_disable_smep);
+
+static __cpuinit void setup_smep(struct cpuinfo_x86 *c)
+{
+	if (cpu_has(c, X86_FEATURE_SMEP)) {
+		if (unlikely(disable_smep)) {
+			setup_clear_cpu_cap(X86_FEATURE_SMEP);
+			clear_in_cr4(X86_CR4_SMEP);
+		} else
+			set_in_cr4(X86_CR4_SMEP);
+	}
+}
+
 /*
  * Some CPU features depend on higher CPUID levels, which may not always
  * be available due to CPUID level capping or broken virtualization
@@ -694,6 +713,8 @@ static void __init early_identify_cpu(st
 	c->cpu_index = boot_cpu_id;
 #endif
 	filter_cpuid_features(c, false);
+
+	setup_smep(c);
 }
 
 void __init early_cpu_init(void)
@@ -769,6 +790,8 @@ static void __cpuinit generic_identify(s
 	}
 #endif
 
+	setup_smep(c);
+
 	get_model_name(c); /* Default name */
 
 	detect_nopl(c);
