From: jbeulich@novell.com
Subject: Go into polling mode early if lock owner is not running
Patch-mainline: n/a

This could be merged into the original ticket spinlock code once
validated, if there wasn't the dependency on smp-processor-id.h, which
only gets introduced in the 2.6.32 merge.

--- sle11sp2.orig/arch/x86/include/mach-xen/asm/spinlock.h	2012-04-05 12:11:59.000000000 +0200
+++ sle11sp2/arch/x86/include/mach-xen/asm/spinlock.h	2012-04-05 12:23:14.000000000 +0200
@@ -45,6 +45,7 @@
 #ifdef TICKET_SHIFT
 
 #include <asm/irqflags.h>
+#include <asm/smp-processor-id.h>
 
 int xen_spinlock_init(unsigned int cpu);
 void xen_spinlock_cleanup(unsigned int cpu);
@@ -54,8 +55,8 @@ unsigned int xen_spin_adjust(const arch_
 #define xen_spin_adjust(lock, token) (token)
 #define xen_spin_wait(l, t, f) xen_spin_wait(l, t)
 #endif
-bool xen_spin_wait(arch_spinlock_t *, unsigned int *token,
-		   unsigned int flags);
+unsigned int xen_spin_wait(arch_spinlock_t *, unsigned int *token,
+			   unsigned int flags);
 void xen_spin_kick(arch_spinlock_t *, unsigned int token);
 
 /*
@@ -87,15 +88,22 @@ void xen_spin_kick(arch_spinlock_t *, un
 	asm("1:\t" \
 	    "cmpb %h0, %b0\n\t" \
 	    "je 2f\n\t" \
+	    "cmpl %3, %4\n\t" \
+	    "jne 4f\n\t" \
 	    "decl %1\n\t" \
-	    "jz 2f\n\t" \
+	    "jz 2f\n" \
+	    "3:\t" \
 	    "rep ; nop\n\t" \
 	    "movb %2, %b0\n\t" \
 	    /* don't need lfence here, because loads are in-order */ \
 	    "jmp 1b\n" \
+	    "4:\t" \
+	    "shrl $1, %1\n\t" \
+	    "jnz 3b\n" \
 	    "2:" \
 	    : "+Q" (token), "+g" (count) \
-	    : "m" (lock->slock) \
+	    : "m" (lock->slock), "i" (RUNSTATE_running), \
+	      "m" (per_cpu(runstate.state, lock->owner)) \
 	    : "memory", "cc")
 #define __ticket_spin_unlock_body \
 	asm(UNLOCK_LOCK_PREFIX "incb %2\n\t" \
@@ -122,6 +130,9 @@ static __always_inline int __ticket_spin
 	    :
 	    : "memory", "cc");
 
+	if (tmp)
+		lock->owner = raw_smp_processor_id();
+
 	return tmp;
 }
 #elif TICKET_SHIFT == 16
@@ -144,15 +155,22 @@ static __always_inline int __ticket_spin
 		    "1:\t" \
 		    "cmpw %w2, %w0\n\t" \
 		    "je 2f\n\t" \
+		    "cmpl %4, %5\n\t" \
+		    "jne 4f\n\t" \
 		    "decl %1\n\t" \
-		    "jz 2f\n\t" \
+		    "jz 2f\n" \
+		    "3:\t" \
 		    "rep ; nop\n\t" \
 		    "movw %3, %w0\n\t" \
 		    /* don't need lfence here, because loads are in-order */ \
 		    "jmp 1b\n" \
+		    "4:\t" \
+		    "shrl $1, %1\n\t" \
+		    "jnz 3b\n" \
 		    "2:" \
 		    : "+r" (token), "+g" (count), "=&g" (tmp) \
-		    : "m" (lock->slock) \
+		    : "m" (lock->slock), "i" (RUNSTATE_running), \
+		      "m" (per_cpu(runstate.state, lock->owner)) \
 		    : "memory", "cc"); \
 	} while (0)
 #define __ticket_spin_unlock_body \
@@ -188,6 +206,9 @@ static __always_inline int __ticket_spin
 	    :
 	    : "memory", "cc");
 
+	if (tmp)
+		lock->owner = raw_smp_processor_id();
+
 	return tmp;
 }
 #endif
@@ -214,16 +235,18 @@ static __always_inline void __ticket_spi
 	bool free;
 
 	__ticket_spin_lock_preamble;
-	if (likely(free)) {
+	if (likely(free))
+		arch_local_irq_restore(flags);
+	else {
+		token = xen_spin_adjust(lock, token);
 		arch_local_irq_restore(flags);
-		return;
-	}
-	token = xen_spin_adjust(lock, token);
-	arch_local_irq_restore(flags);
-	do {
 		count = 1 << 12;
-		__ticket_spin_lock_body;
-	} while (unlikely(!count) && !xen_spin_wait(lock, &token, flags));
+		do {
+			__ticket_spin_lock_body;
+		} while (unlikely(!count)
+			 && (count = xen_spin_wait(lock, &token, flags)));
+	}
+	lock->owner = raw_smp_processor_id();
 }
 #else
 #define __ticket_spin_lock(lock) __ticket_spin_lock_flags(lock, -1)
@@ -236,13 +259,15 @@ static __always_inline void __ticket_spi
 	bool free;
 
 	__ticket_spin_lock_preamble;
-	if (likely(free))
-		return;
-	token = xen_spin_adjust(lock, token);
-	do {
+	if (unlikely(!free)) {
+		token = xen_spin_adjust(lock, token);
 		count = 1 << 12;
-		__ticket_spin_lock_body;
-	} while (unlikely(!count) && !xen_spin_wait(lock, &token, flags));
+		do {
+			__ticket_spin_lock_body;
+		} while (unlikely(!count)
+			 && (count = xen_spin_wait(lock, &token, flags)));
+	}
+	lock->owner = raw_smp_processor_id();
 }
 
 static __always_inline void __ticket_spin_unlock(arch_spinlock_t *lock)
--- sle11sp2.orig/arch/x86/include/mach-xen/asm/spinlock_types.h	2012-01-10 12:17:02.000000000 +0100
+++ sle11sp2/arch/x86/include/mach-xen/asm/spinlock_types.h	2012-01-10 12:27:36.000000000 +0100
@@ -25,6 +25,11 @@ typedef union {
 # define TICKET_SHIFT 16
 		u16 cur, seq;
 #endif
+#if CONFIG_NR_CPUS <= 256
+		u8 owner;
+#else
+		u16 owner;
+#endif
 #else
 /*
  * This differs from the pre-2.6.24 spinlock by always using xchgb
--- sle11sp2.orig/drivers/xen/core/spinlock.c	2012-04-05 12:12:57.000000000 +0200
+++ sle11sp2/drivers/xen/core/spinlock.c	2012-04-05 12:23:08.000000000 +0200
@@ -39,6 +39,8 @@ int __cpuinit xen_spinlock_init(unsigned
 	struct evtchn_bind_ipi bind_ipi;
 	int rc;
 
+	setup_runstate_area(cpu);
+
  	WARN_ON(per_cpu(poll_evtchn, cpu));
 	bind_ipi.vcpu = cpu;
 	rc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_ipi, &bind_ipi);
@@ -122,19 +124,18 @@ unsigned int xen_spin_adjust(const arch_
 }
 #endif
 
-bool xen_spin_wait(arch_spinlock_t *lock, unsigned int *ptok,
-		   unsigned int flags)
+unsigned int xen_spin_wait(arch_spinlock_t *lock, unsigned int *ptok,
+			   unsigned int flags)
 {
+	unsigned int rm_idx, cpu = raw_smp_processor_id();
 	bool rc;
 	typeof(vcpu_info(0)->evtchn_upcall_mask) upcall_mask
 		= arch_local_save_flags();
-	unsigned int rm_idx;
 	struct spinning spinning, *other;
 
 	/* If kicker interrupt not initialized yet, just spin. */
-	if (unlikely(!cpu_online(raw_smp_processor_id()))
-	    || unlikely(!percpu_read(poll_evtchn)))
-		return false;
+	if (unlikely(!cpu_online(cpu)) || unlikely(!percpu_read(poll_evtchn)))
+		return UINT_MAX;
 
 	/* announce we're spinning */
 	spinning.ticket = *ptok >> TICKET_SHIFT;
@@ -155,6 +156,7 @@ bool xen_spin_wait(arch_spinlock_t *lock
 		 * we weren't looking.
 		 */
 		if (lock->cur == spinning.ticket) {
+			lock->owner = cpu;
 			/*
 			 * If we interrupted another spinlock while it was
 			 * blocking, make sure it doesn't block (again)
@@ -188,6 +190,7 @@ bool xen_spin_wait(arch_spinlock_t *lock
 					unsigned int token;
 					bool kick, free;
 
+					lock->owner = cpu;
 					other->ticket = -1;
 					__ticket_spin_unlock_body;
 					if (!kick)
@@ -248,6 +251,8 @@ bool xen_spin_wait(arch_spinlock_t *lock
 			if (!free)
 				token = spin_adjust(other->prev, lock, token);
 			other->ticket = token >> TICKET_SHIFT;
+			if (lock->cur == other->ticket)
+				lock->owner = cpu;
 		} while ((other = other->prev) != NULL);
 		lock = spinning.lock;
 	}
@@ -259,7 +264,7 @@ bool xen_spin_wait(arch_spinlock_t *lock
 	arch_local_irq_restore(upcall_mask);
 	*ptok = lock->cur | (spinning.ticket << TICKET_SHIFT);
 
-	return rc;
+	return rc ? 0 : 1 << 10;
 }
 
 void xen_spin_kick(arch_spinlock_t *lock, unsigned int token)
