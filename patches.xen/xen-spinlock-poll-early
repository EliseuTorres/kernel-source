From: jbeulich@novell.com
Subject: Go into polling mode early if lock owner is not running
Patch-mainline: n/a

This could be merged into the original ticket spinlock code once
validated, if there wasn't the dependency on smp-processor-id.h, which
only gets introduced in the 2.6.32 merge.

--- sle11sp2-2011-07-15.orig/arch/x86/include/mach-xen/asm/spinlock.h	2011-07-15 12:43:54.000000000 +0200
+++ sle11sp2-2011-07-15/arch/x86/include/mach-xen/asm/spinlock.h	2011-07-15 14:25:54.000000000 +0200
@@ -45,11 +45,12 @@
 #ifdef TICKET_SHIFT
 
 #include <asm/irqflags.h>
+#include <asm/smp-processor-id.h>
 
 int xen_spinlock_init(unsigned int cpu);
 void xen_spinlock_cleanup(unsigned int cpu);
-bool xen_spin_wait(raw_spinlock_t *, unsigned int *token,
-		   unsigned int flags);
+unsigned int xen_spin_wait(raw_spinlock_t *, unsigned int *token,
+			   unsigned int flags);
 unsigned int xen_spin_adjust(const raw_spinlock_t *, unsigned int token);
 void xen_spin_kick(raw_spinlock_t *, unsigned int token);
 
@@ -117,6 +118,9 @@ static __always_inline int __ticket_spin
 	    :
 	    : "memory", "cc");
 
+	if (tmp)
+		lock->owner = raw_smp_processor_id();
+
 	return tmp;
 }
 #elif TICKET_SHIFT == 16
@@ -183,10 +187,15 @@ static __always_inline int __ticket_spin
 	    :
 	    : "memory", "cc");
 
+	if (tmp)
+		lock->owner = raw_smp_processor_id();
+
 	return tmp;
 }
 #endif
 
+#define __ticket_spin_count(lock) (vcpu_running((lock)->owner) ? 1 << 10 : 1)
+
 static inline int __ticket_spin_is_locked(raw_spinlock_t *lock)
 {
 	int tmp = ACCESS_ONCE(lock->slock);
@@ -208,16 +217,18 @@ static __always_inline void __ticket_spi
 	bool free;
 
 	__ticket_spin_lock_preamble;
-	if (likely(free)) {
+	if (likely(free))
 		raw_local_irq_restore(flags);
-		return;
+	else {
+		token = xen_spin_adjust(lock, token);
+		raw_local_irq_restore(flags);
+		count = __ticket_spin_count(lock);
+		do {
+			__ticket_spin_lock_body;
+		} while (unlikely(!count)
+			 && (count = xen_spin_wait(lock, &token, flags)));
 	}
-	token = xen_spin_adjust(lock, token);
-	raw_local_irq_restore(flags);
-	do {
-		count = 1 << 10;
-		__ticket_spin_lock_body;
-	} while (unlikely(!count) && !xen_spin_wait(lock, &token, flags));
+	lock->owner = raw_smp_processor_id();
 }
 
 static __always_inline void __ticket_spin_lock_flags(raw_spinlock_t *lock,
@@ -227,13 +238,15 @@ static __always_inline void __ticket_spi
 	bool free;
 
 	__ticket_spin_lock_preamble;
-	if (likely(free))
-		return;
-	token = xen_spin_adjust(lock, token);
-	do {
-		count = 1 << 10;
-		__ticket_spin_lock_body;
-	} while (unlikely(!count) && !xen_spin_wait(lock, &token, flags));
+	if (unlikely(!free)) {
+		token = xen_spin_adjust(lock, token);
+		count = __ticket_spin_count(lock);
+		do {
+			__ticket_spin_lock_body;
+		} while (unlikely(!count)
+			 && (count = xen_spin_wait(lock, &token, flags)));
+	}
+	lock->owner = raw_smp_processor_id();
 }
 
 static __always_inline void __ticket_spin_unlock(raw_spinlock_t *lock)
@@ -250,6 +263,7 @@ static __always_inline void __ticket_spi
 #undef __ticket_spin_lock_preamble
 #undef __ticket_spin_lock_body
 #undef __ticket_spin_unlock_body
+#undef __ticket_spin_count
 #endif
 
 #define __raw_spin(n) __ticket_spin_##n
--- sle11sp2-2011-07-15.orig/arch/x86/include/mach-xen/asm/spinlock_types.h	2010-08-17 12:02:27.000000000 +0200
+++ sle11sp2-2011-07-15/arch/x86/include/mach-xen/asm/spinlock_types.h	2010-08-17 14:33:26.000000000 +0200
@@ -26,6 +26,11 @@ typedef union {
 # define TICKET_SHIFT 16
 		u16 cur, seq;
 #endif
+#if CONFIG_NR_CPUS <= 256
+		u8 owner;
+#else
+		u16 owner;
+#endif
 #else
 /*
  * This differs from the pre-2.6.24 spinlock by always using xchgb
--- sle11sp2-2011-07-15.orig/drivers/xen/core/spinlock.c	2011-05-05 16:50:27.000000000 +0200
+++ sle11sp2-2011-07-15/drivers/xen/core/spinlock.c	2011-05-06 08:57:36.000000000 +0200
@@ -38,6 +38,8 @@ int __cpuinit xen_spinlock_init(unsigned
 	struct evtchn_bind_ipi bind_ipi;
 	int rc;
 
+	setup_runstate_area(cpu);
+
  	WARN_ON(per_cpu(poll_evtchn, cpu));
 	bind_ipi.vcpu = cpu;
 	rc = HYPERVISOR_event_channel_op(EVTCHNOP_bind_ipi, &bind_ipi);
@@ -123,18 +125,17 @@ unsigned int xen_spin_adjust(const raw_s
 	return spin_adjust(percpu_read(spinning), lock, token);
 }
 
-bool xen_spin_wait(raw_spinlock_t *lock, unsigned int *ptok,
-		   unsigned int flags)
+unsigned int xen_spin_wait(raw_spinlock_t *lock, unsigned int *ptok,
+			   unsigned int flags)
 {
+	unsigned int rm_idx, cpu = raw_smp_processor_id();
 	bool rc;
 	typeof(vcpu_info(0)->evtchn_upcall_mask) upcall_mask;
-	unsigned int rm_idx;
 	struct spinning spinning, *other;
 
 	/* If kicker interrupt not initialized yet, just spin. */
-	if (unlikely(!cpu_online(raw_smp_processor_id()))
-	    || unlikely(!percpu_read(poll_evtchn)))
-		return false;
+	if (unlikely(!cpu_online(cpu)) || unlikely(!percpu_read(poll_evtchn)))
+		return UINT_MAX;
 
 	/* announce we're spinning */
 	spinning.ticket = *ptok >> TICKET_SHIFT;
@@ -154,6 +155,7 @@ bool xen_spin_wait(raw_spinlock_t *lock,
 		 * we weren't looking.
 		 */
 		if (lock->cur == spinning.ticket) {
+			lock->owner = cpu;
 			/*
 			 * If we interrupted another spinlock while it was
 			 * blocking, make sure it doesn't block (again)
@@ -250,6 +252,8 @@ bool xen_spin_wait(raw_spinlock_t *lock,
 			if (!free)
 				token = spin_adjust(other->prev, lock, token);
 			other->ticket = token >> TICKET_SHIFT;
+			if (lock->cur == other->ticket)
+				lock->owner = cpu;
 		} while ((other = other->prev) != NULL);
 		lock = spinning.lock;
 	}
@@ -260,7 +264,7 @@ bool xen_spin_wait(raw_spinlock_t *lock,
 	raw_local_irq_restore(upcall_mask);
 	*ptok = lock->cur | (spinning.ticket << TICKET_SHIFT);
 
-	return rc;
+	return rc ? 0 : __ticket_spin_count(lock);
 }
 
 void xen_spin_kick(raw_spinlock_t *lock, unsigned int token)
