From http://xenbits.xen.org/hg/linux-2.6.18-xen.hg/rev/93fcadedde48
From: xen-devel@lists.xen.org
Patch-mainline: n/a
Subject: pciback: notify hypervisor about devices intended to be assigned to guests

For MSI-X capable devices the hypervisor wants to write protect the
MSI-X table and PBA, yet it can't assume that resources have been
assigned to their final values at device enumeration time. Thus have
pciback do that notification, as having the device controlled by it is
a prerequisite to assigning the device to guests anyway.

Signed-off-by: Jan Beulich <jbeulich@suse.com>

--- sle11sp2.orig/drivers/xen/pciback/pci_stub.c	2012-10-02 14:26:41.000000000 +0200
+++ sle11sp2/drivers/xen/pciback/pci_stub.c	2013-03-20 12:25:07.000000000 +0100
@@ -14,6 +14,7 @@
 #include <linux/wait.h>
 #include <asm/atomic.h>
 #include <xen/evtchn.h>
+#include <xen/interface/physdev.h>
 #include "pciback.h"
 #include "conf_space.h"
 #include "conf_space_quirks.h"
@@ -82,19 +83,35 @@ static struct pcistub_device *pcistub_de
 static void pcistub_device_release(struct kref *kref)
 {
 	struct pcistub_device *psdev;
+	struct pci_dev *dev;
 
 	psdev = container_of(kref, struct pcistub_device, kref);
+	dev = psdev->dev;
 
-	dev_dbg(&psdev->dev->dev, "pcistub_device_release\n");
+	dev_dbg(&dev->dev, "pcistub_device_release\n");
+
+	if (pci_find_capability(dev, PCI_CAP_ID_MSIX)) {
+		struct physdev_pci_device ppdev = {
+			.seg = pci_domain_nr(dev->bus),
+			.bus = dev->bus->number,
+			.devfn = dev->devfn
+		};
+		int err = HYPERVISOR_physdev_op(PHYSDEVOP_release_msix,
+						&ppdev);
+
+		if (err)
+			dev_warn(&dev->dev, "MSI-X release failed (%d)\n",
+				 err);
+	}
 
 	/* Clean-up the device */
-	pciback_reset_device(psdev->dev);
-	pciback_config_free_dyn_fields(psdev->dev);
-	pciback_config_free_dev(psdev->dev);
-	kfree(pci_get_drvdata(psdev->dev));
-	pci_set_drvdata(psdev->dev, NULL);
+	pciback_reset_device(dev);
+	pciback_config_free_dyn_fields(dev);
+	pciback_config_free_dev(dev);
+	kfree(pci_get_drvdata(dev));
+	pci_set_drvdata(dev, NULL);
 
-	pci_dev_put(psdev->dev);
+	pci_dev_put(dev);
 
 	kfree(psdev);
 }
@@ -311,6 +328,19 @@ static int __devinit pcistub_init_device
 	if (err)
 		goto config_release;
 
+	if (pci_find_capability(dev, PCI_CAP_ID_MSIX)) {
+		struct physdev_pci_device ppdev = {
+			.seg = pci_domain_nr(dev->bus),
+			.bus = dev->bus->number,
+			.devfn = dev->devfn
+		};
+
+		err = HYPERVISOR_physdev_op(PHYSDEVOP_prepare_msix, &ppdev);
+		if (err)
+			dev_err(&dev->dev, "MSI-X preparation failed (%d)\n",
+				err);
+	}
+
 	/* Now disable the device (this also ensures some private device
 	 * data is setup before we export)
 	 */
--- sle11sp2.orig/include/xen/interface/physdev.h	2011-10-04 15:15:07.000000000 +0200
+++ sle11sp2/include/xen/interface/physdev.h	2013-03-20 12:25:07.000000000 +0100
@@ -291,6 +291,12 @@ DEFINE_XEN_GUEST_HANDLE(physdev_pci_devi
 
 #define PHYSDEVOP_pci_device_remove     26
 #define PHYSDEVOP_restore_msi_ext       27
+/*
+ * Dom0 should use these two to announce MMIO resources assigned to
+ * MSI-X capable devices won't (prepare) or may (release) change.
+ */
+#define PHYSDEVOP_prepare_msix          30
+#define PHYSDEVOP_release_msix          31
 struct physdev_pci_device {
     /* IN */
     uint16_t seg;
