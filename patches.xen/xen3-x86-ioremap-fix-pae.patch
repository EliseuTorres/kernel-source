From: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Subject: x86, ioremap: Fix incorrect physical address handling in PAE mode
Patch-Mainline: 2.6.36-rc1
References: FATE#310031
    
Current x86 ioremap() doesn't handle physical address higher than
32-bit properly in X86_32 PAE mode. When physical address higher than
32-bit is passed to ioremap(), higher 32-bits in physical address is
cleared wrongly. Due to this bug, ioremap() can map wrong address to
linear address space.
    
In my case, 64-bit MMIO region was assigned to a PCI device (ioat
device) on my system. Because of the ioremap()'s bug, wrong physical
address (instead of MMIO region) was mapped to linear address space.
Because of this, loading ioatdma driver caused unexpected behavior
(kernel panic, kernel hangup, ...).
    
Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
LKML-Reference: <4C1AE680.7090408@jp.fujitsu.com>
Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
Acked-by: Petr Tesarik <ptesarik@suse.cz>

Automatically created from "patches.arch/x86-ioremap-fix-pae.patch" by xen-port-patches.py

--- sle11sp2-2011-06-20.orig/arch/x86/mm/ioremap-xen.c	2011-05-05 15:32:55.000000000 +0200
+++ sle11sp2-2011-06-20/arch/x86/mm/ioremap-xen.c	2011-06-20 10:48:05.000000000 +0200
@@ -255,7 +255,7 @@ static void __iomem *__ioremap_caller(re
 		unsigned long size, unsigned long prot_val, void *caller)
 {
 	unsigned long offset, vaddr;
-	phys_addr_t mfn, last_addr;
+	phys_addr_t mfn, last_mfn, last_addr;
 	const resource_size_t unaligned_phys_addr = phys_addr;
 	const unsigned long unaligned_size = size;
 	struct vm_struct *area;
@@ -293,7 +293,8 @@ static void __iomem *__ioremap_caller(re
 	/*
 	 * Don't allow anybody to remap normal RAM that we're using..
 	 */
-	for (mfn = PFN_DOWN(phys_addr); mfn < PFN_UP(last_addr); mfn++) {
+	last_mfn = PFN_DOWN(last_addr);
+	for (mfn = PFN_DOWN(phys_addr); mfn <= last_mfn; mfn++) {
 		unsigned long pfn = mfn_to_local_pfn(mfn);
 
 		if (pfn_valid(pfn)) {
@@ -308,7 +309,7 @@ static void __iomem *__ioremap_caller(re
 	 * Mappings have to be page-aligned
 	 */
 	offset = phys_addr & ~PAGE_MASK;
-	phys_addr &= PAGE_MASK;
+	phys_addr &= PHYSICAL_PAGE_MASK;
 	size = PAGE_ALIGN(last_addr+1) - phys_addr;
 
 	retval = reserve_memtype(phys_addr, (u64)phys_addr + size,
