From: jbeulich@novell.com
Subject: x86: Use PCI method for enabling AMD extended config space before MSR method
Patch-mainline: 2.6.38 (commit 24d9b70b8c679264756a6980e668b96b3f964826)

While both methods should work equivalently well for the native
case, the Xen Dom0 case can't reliably work with the MSR one,
since there's no guarantee that the virtual CPUs it has
available fully cover all necessary physical ones.

As per the suggestion of Robert Richter the patch only adds the
PCI method, but leaves the MSR one as a fallback to cover new
systems the PCI IDs of which may not have got added to the code
base yet.

The only change in v2 is the breaking out of the new CPI
initialization method into a separate function, as requested by
Ingo.

Signed-off-by: Jan Beulich <jbeulich@novell.com>
Acked-by: Robert Richter <robert.richter@amd.com>
Cc: Andreas Herrmann3 <Andreas.Herrmann3@amd.com>
Cc: Joerg Roedel <joerg.roedel@amd.com>
Cc: Jeremy Fitzhardinge <jeremy@goop.org>
LKML-Reference: <4D2B3FD7020000780002B67D@vpn.id2.novell.com>
Signed-off-by: Ingo Molnar <mingo@elte.hu>

jb: Modified to be less intrusive and more consistent in naming.
    Extended k8_nb_ids[] for the Xen case (which doesn't care about
    the presence of a GART for use as IOMMU).

Should logically be merged into patches.xen/xen3-patch-2.6.27.

---
 arch/x86/include/asm/k8.h     |    7 +++++++
 arch/x86/kernel/aperture_64.c |   20 +++++---------------
 arch/x86/kernel/k8.c          |    7 +++++++
 arch/x86/pci/amd_bus.c        |   35 ++++++++++++++++++++++++++++++++++-
 4 files changed, 53 insertions(+), 16 deletions(-)

Index: linux-2.6.32-SLE11-SP2/arch/x86/include/asm/k8.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/include/asm/k8.h
+++ linux-2.6.32-SLE11-SP2/arch/x86/include/asm/k8.h
@@ -3,7 +3,14 @@
 
 #include <linux/pci.h>
 
+struct k8_bus_dev_range {
+	u8 bus;
+	u8 dev_base;
+	u8 dev_limit;
+};
+
 extern struct pci_device_id k8_nb_ids[];
+extern const struct k8_bus_dev_range k8_bus_dev_ranges[];
 struct bootnode;
 
 extern int early_is_k8_nb(u32 value);
Index: linux-2.6.32-SLE11-SP2/arch/x86/kernel/aperture_64.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kernel/aperture_64.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kernel/aperture_64.c
@@ -38,17 +38,7 @@ int fallback_aper_force __initdata;
 
 int fix_aperture __initdata = 1;
 
-struct bus_dev_range {
-	int bus;
-	int dev_base;
-	int dev_limit;
-};
-
-static struct bus_dev_range bus_dev_ranges[] __initdata = {
-	{ 0x00, 0x18, 0x20},
-	{ 0xff, 0x00, 0x20},
-	{ 0xfe, 0x00, 0x20}
-};
+#define bus_dev_ranges k8_bus_dev_ranges
 
 static struct resource gart_resource = {
 	.name	= "GART",
@@ -290,7 +280,7 @@ void __init early_gart_iommu_check(void)
 
 	/* This is mostly duplicate of iommu_hole_init */
 	fix = 0;
-	for (i = 0; i < ARRAY_SIZE(bus_dev_ranges); i++) {
+	for (i = 0; bus_dev_ranges[i].dev_limit; i++) {
 		int bus;
 		int dev_base, dev_limit;
 
@@ -345,7 +335,7 @@ void __init early_gart_iommu_check(void)
 		return;
 
 	/* different nodes have different setting, disable them all at first*/
-	for (i = 0; i < ARRAY_SIZE(bus_dev_ranges); i++) {
+	for (i = 0; i < bus_dev_ranges[i].dev_limit; i++) {
 		int bus;
 		int dev_base, dev_limit;
 
@@ -386,7 +376,7 @@ void __init gart_iommu_hole_init(void)
 
 	fix = 0;
 	node = 0;
-	for (i = 0; i < ARRAY_SIZE(bus_dev_ranges); i++) {
+	for (i = 0; i < bus_dev_ranges[i].dev_limit; i++) {
 		int bus;
 		int dev_base, dev_limit;
 		u32 ctl;
@@ -501,7 +491,7 @@ out:
 	}
 
 	/* Fix up the north bridges */
-	for (i = 0; i < ARRAY_SIZE(bus_dev_ranges); i++) {
+	for (i = 0; i < bus_dev_ranges[i].dev_limit; i++) {
 		int bus;
 		int dev_base, dev_limit;
 
Index: linux-2.6.32-SLE11-SP2/arch/x86/kernel/k8.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kernel/k8.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kernel/k8.c
@@ -27,6 +27,13 @@ struct pci_device_id k8_nb_ids[] = {
 };
 EXPORT_SYMBOL(k8_nb_ids);
 
+const struct k8_bus_dev_range k8_bus_dev_ranges[] __initconst = {
+	{ 0x00, 0x18, 0x20 },
+	{ 0xff, 0x00, 0x20 },
+	{ 0xfe, 0x00, 0x20 },
+	{ }
+};
+
 struct pci_dev **k8_northbridges;
 EXPORT_SYMBOL(k8_northbridges);
 
Index: linux-2.6.32-SLE11-SP2/arch/x86/pci/amd_bus.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/pci/amd_bus.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/pci/amd_bus.c
@@ -2,10 +2,11 @@
 #include <linux/pci.h>
 #include <linux/topology.h>
 #include <linux/cpu.h>
+#include <asm/k8.h>
+#include <asm/pci-direct.h>
 #include <asm/pci_x86.h>
 
 #ifdef CONFIG_X86_64
-#include <asm/pci-direct.h>
 #include <asm/mpspec.h>
 #include <linux/cpumask.h>
 #endif
@@ -544,6 +545,34 @@ static struct notifier_block __cpuinitda
 };
 #endif /* CONFIG_XEN */
 
+static void __init pci_enable_pci_io_ecs(void)
+{
+#if defined(CONFIG_K8_NB) && defined(CONFIG_XEN)/* native could use this too */
+	unsigned int i, n;
+
+	for (n = i = 0; !n && k8_bus_dev_ranges[i].dev_limit; ++i) {
+		u8 bus = k8_bus_dev_ranges[i].bus;
+		u8 slot = k8_bus_dev_ranges[i].dev_base;
+		u8 limit = k8_bus_dev_ranges[i].dev_limit;
+
+		for (; slot < limit; ++slot) {
+			u32 val = read_pci_config(bus, slot, 3, 0);
+
+			if (!early_is_k8_nb(val))
+				continue;
+
+			val = read_pci_config(bus, slot, 3, 0x8c);
+			if (!(val & (ENABLE_CF8_EXT_CFG >> 32))) {
+				val |= ENABLE_CF8_EXT_CFG >> 32;
+				write_pci_config(bus, slot, 3, 0x8c, val);
+			}
+			++n;
+		}
+	}
+	pr_info("Extended Config Space enabled on %u nodes\n", n);
+#endif
+}
+
 static int __init pci_io_ecs_init(void)
 {
 	int cpu;
@@ -552,6 +581,10 @@ static int __init pci_io_ecs_init(void)
         if (boot_cpu_data.x86 < 0x10)
 		return 0;
 
+	/* Try the PCI method first. */
+	if (early_pci_allowed())
+		pci_enable_pci_io_ecs();
+
 #ifndef CONFIG_XEN
 	register_cpu_notifier(&amd_cpu_notifier);
 	for_each_online_cpu(cpu)
