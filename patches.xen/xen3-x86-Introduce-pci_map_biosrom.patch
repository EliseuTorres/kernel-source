From: Dan Williams <dan.j.williams@intel.com>
Date: Tue, 8 Mar 2011 10:36:19 -0800
Subject: [PATCH] x86: Introduce pci_map_biosrom()
References: FATE#311808
Patch-Mainline: 3.0.0

The isci driver needs to retrieve its preboot OROM image which contains
necessary runtime parameters like platform specific sas addresses and
phy configuration.  There is no ROM BAR associated with this area,
instead we will need to scan legacy expansion ROM space.

1/ Promote the probe_roms_32 implementation to x86-64
2/ Add a facility to find and map an adapter rom by pci device (according to
   PCI Firmware Specification Revision 3.0)

Signed-off-by: Dave Jiang <dave.jiang@intel.com>
LKML-Reference: <20110308183226.6246.90354.stgit@localhost6.localdomain6>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
Automatically created from "patches.arch/x86-Introduce-pci_map_biosrom.patch" by xen-port-patches.py

--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ sle11sp2-2011-08-08/arch/x86/include/mach-xen/asm/probe_roms.h	2011-06-29 09:15:21.000000000 +0200
@@ -0,0 +1,10 @@
+#if !defined(CONFIG_XEN_UNPRIVILEGED_GUEST)
+# include_next <asm/probe_roms.h>
+#elif !defined(_PROBE_ROMS_H_)
+# define _PROBE_ROMS_H_
+struct pci_dev;
+
+static inline void __iomem *pci_map_biosrom(struct pci_dev *pdev) { return NULL; }
+static inline void pci_unmap_biosrom(void __iomem *rom) { }
+static inline size_t pci_biosrom_size(struct pci_dev *pdev) { return 0; }
+#endif
--- sle11sp2-2011-08-08.orig/arch/x86/kernel/Makefile	2010-11-04 13:15:11.000000000 +0100
+++ sle11sp2-2011-08-08/arch/x86/kernel/Makefile	2011-06-20 10:51:24.000000000 +0200
@@ -139,4 +139,4 @@ endif
 disabled-obj-$(CONFIG_XEN) := %_uv.o crash.o early-quirks.o hpet.o i8253.o \
 	i8259.o irqinit.o pci-swiotlb.o reboot.o smpboot.o tsc.o tsc_sync.o \
 	uv_%.o vsmp_64.o
-disabled-obj-$(CONFIG_XEN_UNPRIVILEGED_GUEST) += probe_roms_32.o
+disabled-obj-$(CONFIG_XEN_UNPRIVILEGED_GUEST) += probe_roms.o
--- sle11sp2-2011-08-08.orig/arch/x86/kernel/head-xen.c	2011-08-08 13:54:34.000000000 +0200
+++ sle11sp2-2011-08-08/arch/x86/kernel/head-xen.c	2011-08-08 14:13:18.000000000 +0200
@@ -156,7 +156,8 @@ void __init xen_start_kernel(void)
 	if (is_initial_xendomain()) {
 		x86_platform.get_wallclock = mach_get_cmos_time;
 		x86_platform.set_wallclock = mach_set_rtc_mmss;
-	}
+	} else
+		x86_init.resources.probe_roms = x86_init_noop;
 }
 
 void __init xen_arch_setup(void)
--- sle11sp2-2011-08-08.orig/arch/x86/kernel/head32-xen.c	2011-05-06 15:10:15.000000000 +0200
+++ sle11sp2-2011-08-08/arch/x86/kernel/head32-xen.c	2011-06-20 10:50:51.000000000 +0200
@@ -20,8 +20,6 @@
 static void __init i386_default_early_setup(void)
 {
 	/* Initialize 32bit specific setup functions */
-	if (is_initial_xendomain())
-		x86_init.resources.probe_roms = probe_roms;
 	x86_init.resources.reserve_resources = i386_reserve_resources;
 #ifndef CONFIG_XEN
 	x86_init.mpparse.setup_ioapic_ids = setup_ioapic_ids_from_mpc;
--- sle11sp2-2011-08-08.orig/arch/x86/kernel/probe_roms.c	2011-06-20 10:09:36.000000000 +0200
+++ sle11sp2-2011-08-08/arch/x86/kernel/probe_roms.c	2011-06-20 10:59:24.000000000 +0200
@@ -114,6 +114,11 @@ static struct resource *find_oprom(struc
 	struct resource *oprom = NULL;
 	int i;
 
+#ifdef CONFIG_XEN
+	if (!is_initial_xendomain())
+		return NULL;
+#endif
+
 	for (i = 0; i < ARRAY_SIZE(adapter_rom_resources); i++) {
 		struct resource *res = &adapter_rom_resources[i];
 		unsigned short offset, vendor, device, list, rev;
--- sle11sp2-2011-08-08.orig/arch/x86/kernel/x86_init-xen.c	2011-07-15 13:58:33.000000000 +0200
+++ sle11sp2-2011-08-08/arch/x86/kernel/x86_init-xen.c	2011-06-20 10:51:56.000000000 +0200
@@ -26,7 +26,11 @@ void __init x86_init_pgd_noop(pgd_t *unu
 struct x86_init_ops x86_init __initdata = {
 
 	.resources = {
+#ifdef CONFIG_XEN_PRIVILEGED_GUEST
+		.probe_roms		= probe_roms,
+#else
 		.probe_roms		= x86_init_noop,
+#endif
 		.reserve_resources	= reserve_standard_io_resources,
 		.memory_setup		= default_machine_specific_memory_setup,
 	},
