From: Hannes Reinecke <hare@suse.de>
Subject: Fixup Xen drivers after FLUSH/FUA conversion
References: FATE#311692
Patch-Mainline: n/a

This patch fixes up the missing Xen drivers for the FLUSH/FUA
conversion.

Should be merged with the Xen patches.

Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/xen/blkback/blkback.c b/drivers/xen/blkback/blkback.c
index ac3bf47..bb588e2 100644
--- a/drivers/xen/blkback/blkback.c
+++ b/drivers/xen/blkback/blkback.c
@@ -418,7 +418,7 @@ static void dispatch_rw_block_io(blkif_t *blkif,
 		operation = WRITE;
 		break;
 	case BLKIF_OP_WRITE_BARRIER:
-		operation = WRITE_BARRIER;
+		operation = WRITE_FLUSH_FUA;
 		break;
 	default:
 		operation = 0; /* make gcc happy */
@@ -427,7 +427,7 @@ static void dispatch_rw_block_io(blkif_t *blkif,
 
 	/* Check that number of segments is sane. */
 	nseg = req->nr_segments;
-	if (unlikely(nseg == 0 && operation != WRITE_BARRIER) || 
+	if (unlikely(nseg == 0 && !(operation & (REQ_FLUSH|REQ_FUA))) ||
 	    unlikely(nseg > BLKIF_MAX_SEGMENTS_PER_REQUEST)) {
 		DPRINTK("Bad number of segments in request (%d)\n", nseg);
 		goto fail_response;
@@ -535,7 +535,7 @@ static void dispatch_rw_block_io(blkif_t *blkif,
 	}
 
 	if (!bio) {
-		BUG_ON(operation != WRITE_BARRIER);
+		BUG_ON(!(operation & (REQ_FLUSH|REQ_FUA)));
 		bio = bio_alloc(GFP_KERNEL, 0);
 		if (unlikely(bio == NULL))
 			goto fail_put_bio;
@@ -550,7 +550,7 @@ static void dispatch_rw_block_io(blkif_t *blkif,
 
 	if (operation == READ)
 		blkif->st_rd_sect += preq.nr_sects;
-	else if (operation == WRITE || operation == WRITE_BARRIER)
+	else
 		blkif->st_wr_sect += preq.nr_sects;
 
 	return;
diff --git a/drivers/xen/blkfront/blkfront.c b/drivers/xen/blkfront/blkfront.c
index 54f6d7c..283b74f 100644
--- a/drivers/xen/blkfront/blkfront.c
+++ b/drivers/xen/blkfront/blkfront.c
@@ -691,9 +691,9 @@ static int blkif_queue_request(struct request *req)
 
 	ring_req->operation = rq_data_dir(req) ?
 		BLKIF_OP_WRITE : BLKIF_OP_READ;
-	if (blk_barrier_rq(req))
+	if (req->cmd_flags & (REQ_FLUSH|REQ_FUA))
 		ring_req->operation = BLKIF_OP_WRITE_BARRIER;
-	if (blk_pc_request(req))
+	if (req->cmd_type == REQ_TYPE_BLOCK_PC)
 		ring_req->operation = BLKIF_OP_PACKET;
 
 	ring_req->nr_segments = blk_rq_map_sg(req->q, req, info->sg);
@@ -752,7 +752,8 @@ void do_blkif_request(struct request_queue *rq)
 
 		blk_start_request(req);
 
-		if (!blk_fs_request(req) && !blk_pc_request(req)) {
+		if ((req->cmd_type != REQ_TYPE_FS) &&
+		    (req->cmd_type != REQ_TYPE_BLOCK_PC)) {
 			__blk_end_request_all(req, -EIO);
 			continue;
 		}
diff --git a/drivers/xen/blkfront/vbd.c b/drivers/xen/blkfront/vbd.c
index d5bfae9..d4e4719 100644
--- a/drivers/xen/blkfront/vbd.c
+++ b/drivers/xen/blkfront/vbd.c
@@ -474,12 +474,9 @@ xlvbd_del(struct blkfront_info *info)
 int
 xlvbd_barrier(struct blkfront_info *info)
 {
-	int err;
+	if (info->feature_barrier)
+		blk_queue_flush(info->rq, REQ_FLUSH);
 
-	err = blk_queue_ordered(info->rq,
-		info->feature_barrier ? QUEUE_ORDERED_DRAIN : QUEUE_ORDERED_NONE, NULL);
-	if (err)
-		return err;
 	pr_info("blkfront: %s: barriers %s\n",
 		info->gd->disk_name,
 		info->feature_barrier ? "enabled" : "disabled");
diff --git a/drivers/xen/blktap2-new/device.c b/drivers/xen/blktap2-new/device.c
index e365048..fd00473 100644
--- a/drivers/xen/blktap2-new/device.c
+++ b/drivers/xen/blktap2-new/device.c
@@ -189,7 +189,7 @@ blktap_device_make_request(struct blktap *tap, struct request *rq)
 
 	request->rq = rq;
 	request->operation = write ? BLKIF_OP_WRITE : BLKIF_OP_READ;
-	if (unlikely(blk_pc_request(rq)))
+	if (unlikely(rq->cmd_type == REQ_TYPE_BLOCK_PC))
 		request->operation = BLKIF_OP_PACKET;
 
 	err = blktap_request_get_pages(tap, request, nsegs);
@@ -244,7 +244,7 @@ blktap_device_run_queue(struct blktap *tap)
 		if (!rq)
 			break;
 
-		if (!blk_fs_request(rq)) {
+		if (rq->cmd_type != REQ_TYPE_FS) {
 			__blktap_end_queued_rq(rq, -EOPNOTSUPP);
 			continue;
 		}
@@ -306,9 +306,6 @@ blktap_device_configure(struct blktap *tap,
 	/* Make sure buffer addresses are sector-aligned. */
 	blk_queue_dma_alignment(rq, 511);
 
-	/* We are reordering, but cacheless. */
-	blk_queue_ordered(rq, QUEUE_ORDERED_DRAIN, NULL);
-
 	spin_unlock_irq(&dev->lock);
 }
 
diff --git a/drivers/xen/blktap2/device.c b/drivers/xen/blktap2/device.c
index 4152948..96fcf91 100644
--- a/drivers/xen/blktap2/device.c
+++ b/drivers/xen/blktap2/device.c
@@ -646,7 +646,7 @@ blktap_device_process_request(struct blktap *tap,
 	blkif_req.handle = 0;
 	blkif_req.operation = rq_data_dir(req) ?
 		BLKIF_OP_WRITE : BLKIF_OP_READ;
-	if (unlikely(blk_pc_request(req)))
+	if (unlikely(req->cmd_type == REQ_TYPE_BLOCK_PC))
 		blkif_req.operation = BLKIF_OP_PACKET;
 
 	request->id        = (unsigned long)req;
@@ -713,7 +713,7 @@ blktap_device_process_request(struct blktap *tap,
 	wmb(); /* blktap_poll() reads req_prod_pvt asynchronously */
 	ring->ring.req_prod_pvt++;
 
-	if (unlikely(blk_pc_request(req)))
+	if (unlikely(req->cmd_type == REQ_TYPE_BLOCK_PC))
 		tap->stats.st_pk_req++;
 	else if (rq_data_dir(req)) {
 		tap->stats.st_wr_sect += nr_sects;
@@ -844,18 +844,12 @@ blktap_device_run_queue(struct blktap *tap)
 	BTDBG("running queue for %d\n", tap->minor);
 
 	while ((req = blk_peek_request(rq)) != NULL) {
-		if (!blk_fs_request(req)) {
+		if (req->cmd_type != REQ_TYPE_FS) {
 			blk_start_request(req);
 			__blk_end_request_all(req, -EIO);
 			continue;
 		}
 
-		if (blk_barrier_rq(req)) {
-			blk_start_request(req);
-			__blk_end_request_all(req, -EOPNOTSUPP);
-			continue;
-		}
-
 #ifdef ENABLE_PASSTHROUGH
 		if (test_bit(BLKTAP_PASSTHROUGH, &tap->dev_inuse)) {
 			blk_start_request(req);
diff --git a/drivers/xen/scsiback/scsiback.c b/drivers/xen/scsiback/scsiback.c
index caa3199..13ec29c 100644
--- a/drivers/xen/scsiback/scsiback.c
+++ b/drivers/xen/scsiback/scsiback.c
@@ -388,7 +388,7 @@ static struct bio *request_map_sg(pending_req_t *pending_req)
 			if (bio->bi_vcnt >= nr_vecs) {
 				bio->bi_flags &= ~(1 << BIO_SEG_VALID);
 				if (pending_req->sc_data_direction == WRITE)
-					bio->bi_rw |= (1 << BIO_RW);
+					bio->bi_rw |= REQ_WRITE;
 				bio = NULL;
 			}
 
