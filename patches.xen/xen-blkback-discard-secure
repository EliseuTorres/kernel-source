From: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Subject: blkback: Enhance discard support with secure erasing support
References: fate#309305
Patch-mainline: n/a
    
Part of the blkdev_issue_discard(xx) operation is that it can also
issue a secure discard operation that will permanantly remove the
sectors in question. We advertise that we can support that via the
'discard-secure' attribute and on the request, if the 'secure' bit
is set, we will attempt to pass in REQ_DISCARD | REQ_SECURE.
    
CC: Li Dongyang <lidongyang@novell.com>
[v1: Used 'flag' instead of 'secure:1' bit]
[v2: Use 'reserved 'uint8_t' as a flag]
Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Acked-by: jbeulich@suse.com

--- sle11sp3.orig/drivers/xen/blkback/blkback.c	2013-01-18 12:23:20.000000000 +0100
+++ sle11sp3/drivers/xen/blkback/blkback.c	2013-02-05 16:51:33.000000000 +0100
@@ -362,11 +362,16 @@ static void dispatch_discard(blkif_t *bl
 
 	plug_queue(blkif, preq.bdev);
 
-	if (blkif->blk_backend_type == BLKIF_BACKEND_PHY)
+	if (blkif->blk_backend_type == BLKIF_BACKEND_PHY) {
 		/* just forward the discard request */
+		unsigned long secure = (blkif->vbd.discard_secure &&
+			(req->flag & BLKIF_DISCARD_SECURE)) ?
+			BLKDEV_DISCARD_SECURE : 0;
+
 		err = blkdev_issue_discard(preq.bdev, preq.sector_number,
-					   preq.nr_sects, GFP_KERNEL, 0);
-	else if (blkif->blk_backend_type == BLKIF_BACKEND_FILE) {
+					   preq.nr_sects, GFP_KERNEL,
+					   secure);
+	} else if (blkif->blk_backend_type == BLKIF_BACKEND_FILE) {
 		/* punch a hole in the backing file */
 		struct loop_device *lo = preq.bdev->bd_disk->private_data;
 		struct file *file = lo->lo_backing_file;
--- sle11sp3.orig/drivers/xen/blkback/common.h	2012-10-19 15:13:23.000000000 +0200
+++ sle11sp3/drivers/xen/blkback/common.h	2012-10-19 15:14:06.000000000 +0200
@@ -54,6 +54,7 @@ struct vbd {
 	fmode_t        mode;        /* FMODE_xxx */
 	unsigned char  type;        /* VDISK_xxx */
 	bool           flush_support;
+	bool           discard_secure;
 	u32            pdevice;     /* phys device that this vbd maps to */
 	struct block_device *bdev;
 	sector_t       size;        /* Cached size parameter */
--- sle11sp3.orig/drivers/xen/blkback/vbd.c	2012-02-24 15:15:19.000000000 +0100
+++ sle11sp3/drivers/xen/blkback/vbd.c	2012-02-27 13:39:18.000000000 +0100
@@ -92,6 +92,9 @@ int vbd_create(blkif_t *blkif, blkif_vde
 	if (q && q->flush_flags)
 		vbd->flush_support = true;
 
+	if (q && blk_queue_secdiscard(q))
+		vbd->discard_secure = true;
+
 	DPRINTK("Successful creation of handle=%04x (dom=%u)\n",
 		handle, blkif->domid);
 	return 0;
--- sle11sp3.orig/drivers/xen/blkback/xenbus.c	2013-01-08 17:22:37.000000000 +0100
+++ sle11sp3/drivers/xen/blkback/xenbus.c	2013-01-08 17:22:45.000000000 +0100
@@ -263,6 +263,15 @@ static void blkback_discard(struct xenbu
 			}
 		}
 		kfree(type);
+		/* Optional. */
+		if (state) {
+			err = xenbus_printf(xbt, dev->nodename,
+					    "discard-secure", "%d",
+					    blkif->vbd.discard_secure);
+			if (err)
+				xenbus_dev_error(dev, err,
+						 "writing discard-secure");
+		}
 	} else
 		xenbus_dev_error(dev, PTR_ERR(type),
 				 "reading type for discard");
