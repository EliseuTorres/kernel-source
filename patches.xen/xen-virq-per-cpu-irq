From: jbeulich@novell.com
Subject: fold per-CPU VIRQs onto a single IRQ each
Patch-mainline: n/a

--- sle11sp2-2011-05-04.orig/arch/x86/kernel/time-xen.c	2011-05-05 16:50:13.000000000 +0200
+++ sle11sp2-2011-05-04/arch/x86/kernel/time-xen.c	2011-05-06 08:35:36.000000000 +0200
@@ -685,19 +685,17 @@ int xen_update_persistent_clock(void)
 }
 
 /* Dynamically-mapped IRQ. */
-DEFINE_PER_CPU(int, timer_irq);
+static int __read_mostly timer_irq = -1;
+static struct irqaction timer_action = {
+	.handler = timer_interrupt,
+	.flags   = IRQF_DISABLED|IRQF_TIMER,
+	.name    = "timer"
+};
 
 static void setup_cpu0_timer_irq(void)
 {
-	per_cpu(timer_irq, 0) =
-		bind_virq_to_irqhandler(
-			VIRQ_TIMER,
-			0,
-			timer_interrupt,
-			IRQF_DISABLED|IRQF_TIMER|IRQF_NOBALANCING,
-			"timer0",
-			NULL);
-	BUG_ON(per_cpu(timer_irq, 0) < 0);
+	timer_irq = bind_virq_to_irqaction(VIRQ_TIMER, 0, &timer_action);
+	BUG_ON(timer_irq < 0);
 }
 
 void __init time_init(void)
@@ -838,8 +836,6 @@ void xen_halt(void)
 }
 
 #ifdef CONFIG_SMP
-static char timer_name[NR_CPUS][15];
-
 int __cpuinit local_setup_timer(unsigned int cpu)
 {
 	int seq, irq;
@@ -865,16 +861,10 @@ int __cpuinit local_setup_timer(unsigned
 		init_missing_ticks_accounting(cpu);
 	} while (read_seqretry(&xtime_lock, seq));
 
-	sprintf(timer_name[cpu], "timer%u", cpu);
-	irq = bind_virq_to_irqhandler(VIRQ_TIMER,
-				      cpu,
-				      timer_interrupt,
-				      IRQF_DISABLED|IRQF_TIMER|IRQF_NOBALANCING,
-				      timer_name[cpu],
-				      NULL);
+	irq = bind_virq_to_irqaction(VIRQ_TIMER, cpu, &timer_action);
 	if (irq < 0)
 		return irq;
-	per_cpu(timer_irq, cpu) = irq;
+	BUG_ON(timer_irq != irq);
 
 	return 0;
 }
@@ -882,7 +872,7 @@ int __cpuinit local_setup_timer(unsigned
 void __cpuinit local_teardown_timer(unsigned int cpu)
 {
 	BUG_ON(cpu == 0);
-	unbind_from_irqhandler(per_cpu(timer_irq, cpu), NULL);
+	unbind_from_per_cpu_irq(timer_irq, cpu, &timer_action);
 }
 #endif
 
--- sle11sp2-2011-05-04.orig/drivers/xen/core/evtchn.c	2011-05-05 17:29:16.000000000 +0200
+++ sle11sp2-2011-05-04/drivers/xen/core/evtchn.c	2011-05-06 08:35:21.000000000 +0200
@@ -57,6 +57,23 @@ static DEFINE_SPINLOCK(irq_mapping_updat
 static int evtchn_to_irq[NR_EVENT_CHANNELS] = {
 	[0 ...  NR_EVENT_CHANNELS-1] = -1 };
 
+#if defined(CONFIG_SMP) && defined(CONFIG_X86)
+static struct percpu_irqaction {
+	struct irqaction action; /* must be first */
+	struct percpu_irqaction *next;
+	cpumask_var_t cpus;
+} *virq_actions[NR_VIRQS];
+/* IRQ <-> VIRQ mapping. */
+static DECLARE_BITMAP(virq_per_cpu, NR_VIRQS) __read_mostly;
+static DEFINE_PER_CPU(int[NR_VIRQS], virq_to_evtchn);
+#define BUG_IF_VIRQ_PER_CPU(irq) \
+	BUG_ON(type_from_irq(irq) == IRQT_VIRQ \
+	       && test_bit(index_from_irq(irq), virq_per_cpu))
+#else
+#define BUG_IF_VIRQ_PER_CPU(irq) ((void)(irq))
+#define PER_CPU_VIRQ_IRQ
+#endif
+
 /* IRQ <-> IPI mapping. */
 #if defined(CONFIG_SMP) && defined(CONFIG_X86)
 static int __read_mostly ipi_irq = -1;
@@ -131,15 +148,6 @@ static inline u32 mk_irq_info(u32 type, 
  * Accessors for packed IRQ information.
  */
 
-#ifdef PER_CPU_IPI_IRQ
-static inline unsigned int evtchn_from_irq(int irq)
-{
-	const struct irq_cfg *cfg = irq_cfg(irq);
-
-	return cfg ? cfg->info & ((1U << _EVTCHN_BITS) - 1) : 0;
-}
-#endif
-
 static inline unsigned int index_from_irq(int irq)
 {
 	const struct irq_cfg *cfg = irq_cfg(irq);
@@ -155,24 +163,39 @@ static inline unsigned int type_from_irq
 	return cfg ? cfg->info >> (32 - _IRQT_BITS) : IRQT_UNBOUND;
 }
 
-#ifndef PER_CPU_IPI_IRQ
 static inline unsigned int evtchn_from_per_cpu_irq(unsigned int irq,
 						    unsigned int cpu)
 {
-	BUG_ON(type_from_irq(irq) != IRQT_IPI);
-	return per_cpu(ipi_evtchn, cpu);
+	switch (type_from_irq(irq)) {
+#ifndef PER_CPU_VIRQ_IRQ
+	case IRQT_VIRQ:
+		return per_cpu(virq_to_evtchn, cpu)[index_from_irq(irq)];
+#endif
+#ifndef PER_CPU_IPI_IRQ
+	case IRQT_IPI:
+		return per_cpu(ipi_evtchn, cpu);
+#endif
+	}
+	BUG();
+	return 0;
 }
 
 static inline unsigned int evtchn_from_irq(unsigned int irq)
 {
-	if (type_from_irq(irq) != IRQT_IPI) {
-		const struct irq_cfg *cfg = irq_cfg(irq);
+	const struct irq_cfg *cfg;
 
-		return cfg ? cfg->info & ((1U << _EVTCHN_BITS) - 1) : 0;
+	switch (type_from_irq(irq)) {
+#ifndef PER_CPU_VIRQ_IRQ
+	case IRQT_VIRQ:
+#endif
+#ifndef PER_CPU_IPI_IRQ
+	case IRQT_IPI:
+#endif
+		return evtchn_from_per_cpu_irq(irq, smp_processor_id());
 	}
-	return evtchn_from_per_cpu_irq(irq, smp_processor_id());
+	cfg = irq_cfg(irq);
+	return cfg ? cfg->info & ((1U << _EVTCHN_BITS) - 1) : 0;
 }
-#endif
 
 unsigned int irq_from_evtchn(unsigned int port)
 {
@@ -339,13 +362,22 @@ asmlinkage void __irq_entry evtchn_do_up
 		 * hardirq handlers see an up-to-date system time even if we
 		 * have just woken from a long idle period.
 		 */
+#ifdef PER_CPU_VIRQ_IRQ
 		if ((irq = percpu_read(virq_to_irq[VIRQ_TIMER])) != -1) {
 			port = evtchn_from_irq(irq);
+#else
+		port = percpu_read(virq_to_evtchn[VIRQ_TIMER]);
+		if (VALID_EVTCHN(port)) {
+#endif
 			l1i = port / BITS_PER_LONG;
 			l2i = port % BITS_PER_LONG;
 			if (active_evtchns(l1i) & (1ul<<l2i)) {
 				mask_evtchn(port);
 				clear_evtchn(port);
+#ifndef PER_CPU_VIRQ_IRQ
+				irq = evtchn_to_irq[port];
+				BUG_ON(irq == -1);
+#endif
 				if (!handle_irq(irq, regs))
 					BUG();
 			}
@@ -570,6 +602,14 @@ static int bind_virq_to_irq(unsigned int
 		evtchn = bind_virq.port;
 
 		evtchn_to_irq[evtchn] = irq;
+#ifndef PER_CPU_VIRQ_IRQ
+		{
+			unsigned int cpu;
+
+			for_each_possible_cpu(cpu)
+				per_cpu(virq_to_evtchn, cpu)[virq] = evtchn;
+		}
+#endif
 		irq_cfg(irq)->info = mk_irq_info(IRQT_VIRQ, virq, evtchn);
 
 		per_cpu(virq_to_irq, cpu)[virq] = irq;
@@ -624,7 +664,9 @@ static void unbind_from_irq(unsigned int
 	unsigned int cpu;
 	int evtchn = evtchn_from_irq(irq);
 
+	BUG_IF_VIRQ_PER_CPU(irq);
 	BUG_IF_IPI(irq);
+
 	spin_lock(&irq_mapping_update_lock);
 
 	if (!--irq_cfg(irq)->bindcount && VALID_EVTCHN(evtchn)) {
@@ -636,6 +678,11 @@ static void unbind_from_irq(unsigned int
 		case IRQT_VIRQ:
 			per_cpu(virq_to_irq, cpu_from_evtchn(evtchn))
 				[index_from_irq(irq)] = -1;
+#ifndef PER_CPU_VIRQ_IRQ
+			for_each_possible_cpu(cpu)
+				per_cpu(virq_to_evtchn, cpu)
+					[index_from_irq(irq)] = 0;
+#endif
 			break;
 #if defined(CONFIG_SMP) && defined(PER_CPU_IPI_IRQ)
 		case IRQT_IPI:
@@ -665,11 +712,32 @@ static void unbind_from_irq(unsigned int
 	spin_unlock(&irq_mapping_update_lock);
 }
 
-#ifndef PER_CPU_IPI_IRQ
-void unbind_from_per_cpu_irq(unsigned int irq, unsigned int cpu)
+#if !defined(PER_CPU_IPI_IRQ) || !defined(PER_CPU_VIRQ_IRQ)
+static inline struct percpu_irqaction *alloc_percpu_irqaction(gfp_t gfp)
+{
+	struct percpu_irqaction *new = kzalloc(sizeof(*new), GFP_ATOMIC);
+
+	if (new && !zalloc_cpumask_var(&new->cpus, gfp)) {
+		kfree(new);
+		new = NULL;
+	}
+	return new;
+}
+
+static inline void free_percpu_irqaction(struct percpu_irqaction *action)
+{
+	if (!action)
+		return;
+	free_cpumask_var(action->cpus);
+	kfree(action);
+}
+
+void unbind_from_per_cpu_irq(unsigned int irq, unsigned int cpu,
+			     struct irqaction *action)
 {
 	struct evtchn_close close;
 	int evtchn = evtchn_from_per_cpu_irq(irq, cpu);
+	struct percpu_irqaction *free_action = NULL;
 
 	spin_lock(&irq_mapping_update_lock);
 
@@ -680,6 +748,34 @@ void unbind_from_per_cpu_irq(unsigned in
 
 		BUG_ON(irq_cfg(irq)->bindcount <= 1);
 		irq_cfg(irq)->bindcount--;
+
+#ifndef PER_CPU_VIRQ_IRQ
+		if (type_from_irq(irq) == IRQT_VIRQ) {
+			unsigned int virq = index_from_irq(irq);
+			struct percpu_irqaction *cur, *prev = NULL;
+
+			cur = virq_actions[virq];
+			while (cur) {
+				if (cur->action.dev_id == action) {
+					cpumask_clear_cpu(cpu, cur->cpus);
+					if (cpumask_empty(cur->cpus)) {
+						WARN_ON(free_action);
+						if (prev)
+							prev->next = cur->next;
+						else
+							virq_actions[virq]
+								= cur->next;
+						free_action = cur;
+					}
+				} else if (cpumask_test_cpu(cpu, cur->cpus))
+					evtchn = 0;
+				cur = (prev = cur)->next;
+			}
+			if (!VALID_EVTCHN(evtchn))
+				goto done;
+		}
+#endif
+
 		cpumask_clear_cpu(cpu, desc->affinity);
 
 		close.port = evtchn;
@@ -687,9 +783,16 @@ void unbind_from_per_cpu_irq(unsigned in
 			BUG();
 
 		switch (type_from_irq(irq)) {
+#ifndef PER_CPU_VIRQ_IRQ
+		case IRQT_VIRQ:
+			per_cpu(virq_to_evtchn, cpu)[index_from_irq(irq)] = 0;
+			break;
+#endif
+#ifndef PER_CPU_IPI_IRQ
 		case IRQT_IPI:
 			per_cpu(ipi_evtchn, cpu) = 0;
 			break;
+#endif
 		default:
 			BUG();
 			break;
@@ -701,9 +804,18 @@ void unbind_from_per_cpu_irq(unsigned in
 		evtchn_to_irq[evtchn] = -1;
 	}
 
+#ifndef PER_CPU_VIRQ_IRQ
+done:
+#endif
 	spin_unlock(&irq_mapping_update_lock);
+
+	if (free_action) {
+		free_irq(irq, free_action->action.dev_id);
+		free_percpu_irqaction(free_action);
+	}
 }
-#endif /* !PER_CPU_IPI_IRQ */
+EXPORT_SYMBOL_GPL(unbind_from_per_cpu_irq);
+#endif /* !PER_CPU_IPI_IRQ || !PER_CPU_VIRQ_IRQ */
 
 int bind_caller_port_to_irqhandler(
 	unsigned int caller_port,
@@ -785,6 +897,10 @@ int bind_virq_to_irqhandler(
 {
 	int irq, retval;
 
+#ifndef PER_CPU_VIRQ_IRQ
+	BUG_ON(test_bit(virq, virq_per_cpu));
+#endif
+
 	irq = bind_virq_to_irq(virq, cpu);
 	if (irq < 0)
 		return irq;
@@ -800,6 +916,107 @@ int bind_virq_to_irqhandler(
 EXPORT_SYMBOL_GPL(bind_virq_to_irqhandler);
 
 #ifdef CONFIG_SMP
+#ifndef PER_CPU_VIRQ_IRQ
+int bind_virq_to_irqaction(
+	unsigned int virq,
+	unsigned int cpu,
+	struct irqaction *action)
+{
+	struct evtchn_bind_virq bind_virq;
+	int evtchn, irq, retval = 0;
+	struct percpu_irqaction *cur = NULL, *new;
+
+	BUG_ON(!test_bit(virq, virq_per_cpu));
+
+	if (action->dev_id)
+		return -EINVAL;
+
+	new = alloc_percpu_irqaction(GFP_ATOMIC);
+	if (new) {
+		new->action = *action;
+		new->action.dev_id = action;
+	}
+
+	spin_lock(&irq_mapping_update_lock);
+
+	for (cur = virq_actions[virq]; cur; cur = cur->next)
+		if (cur->action.dev_id == action)
+			break;
+	if (!cur) {
+		if (!new) {
+			spin_unlock(&irq_mapping_update_lock);
+			return -ENOMEM;
+		}
+		new->next = virq_actions[virq];
+		virq_actions[virq] = cur = new;
+		new = NULL;
+		retval = 1;
+	}
+	cpumask_set_cpu(cpu, cur->cpus);
+	action = &cur->action;
+
+	if ((irq = per_cpu(virq_to_irq, cpu)[virq]) == -1) {
+		unsigned int nr;
+
+		BUG_ON(!retval);
+
+		if ((irq = find_unbound_irq(cpu_to_node(cpu), &dynirq_chip,
+					    true)) < 0) {
+			virq_actions[virq] = cur->next;
+			spin_unlock(&irq_mapping_update_lock);
+			free_percpu_irqaction(new);
+			return irq;
+		}
+
+		/* Extra reference so count will never drop to zero. */
+		irq_cfg(irq)->bindcount++;
+
+		for_each_possible_cpu(nr)
+			per_cpu(virq_to_irq, nr)[virq] = irq;
+		irq_cfg(irq)->info = mk_irq_info(IRQT_VIRQ, virq, 0);
+	}
+
+	evtchn = per_cpu(virq_to_evtchn, cpu)[virq];
+	if (!VALID_EVTCHN(evtchn)) {
+		bind_virq.virq = virq;
+		bind_virq.vcpu = cpu;
+		if (HYPERVISOR_event_channel_op(EVTCHNOP_bind_virq,
+						&bind_virq) != 0)
+			BUG();
+		evtchn = bind_virq.port;
+		evtchn_to_irq[evtchn] = irq;
+		per_cpu(virq_to_evtchn, cpu)[virq] = evtchn;
+
+		bind_evtchn_to_cpu(evtchn, cpu);
+	}
+
+	irq_cfg(irq)->bindcount++;
+
+	spin_unlock(&irq_mapping_update_lock);
+
+	free_percpu_irqaction(new);
+
+	if (retval == 0) {
+		unsigned long flags;
+
+		local_irq_save(flags);
+		unmask_evtchn(evtchn);
+		local_irq_restore(flags);
+	} else {
+		action->flags |= IRQF_PERCPU;
+		retval = setup_irq(irq, action);
+		if (retval) {
+			unbind_from_per_cpu_irq(irq, cpu, action);
+			BUG_ON(retval > 0);
+			irq = retval;
+		}
+	}
+
+	return irq;
+}
+EXPORT_SYMBOL_GPL(bind_virq_to_irqaction);
+#endif
+
 #ifdef PER_CPU_IPI_IRQ
 int bind_ipi_to_irqhandler(
 	unsigned int ipi,
@@ -877,7 +1094,7 @@ int __cpuinit bind_ipi_to_irqaction(
 		action->flags |= IRQF_PERCPU | IRQF_NO_SUSPEND;
 		retval = setup_irq(ipi_irq, action);
 		if (retval) {
-			unbind_from_per_cpu_irq(ipi_irq, cpu);
+			unbind_from_per_cpu_irq(ipi_irq, cpu, NULL);
 			BUG_ON(retval > 0);
 			ipi_irq = retval;
 		}
@@ -912,7 +1129,9 @@ static void rebind_irq_to_cpu(unsigned i
 {
 	int evtchn = evtchn_from_irq(irq);
 
+	BUG_IF_VIRQ_PER_CPU(irq);
 	BUG_IF_IPI(irq);
+
 	if (VALID_EVTCHN(evtchn))
 		rebind_evtchn_to_cpu(evtchn, tcpu);
 }
@@ -1199,7 +1418,9 @@ void notify_remote_via_irq(int irq)
 {
 	int evtchn = evtchn_from_irq(irq);
 
+	BUG_ON(type_from_irq(irq) == IRQT_VIRQ);
 	BUG_IF_IPI(irq);
+
 	if (VALID_EVTCHN(evtchn))
 		notify_remote_via_evtchn(evtchn);
 }
@@ -1207,6 +1428,7 @@ EXPORT_SYMBOL_GPL(notify_remote_via_irq)
 
 int irq_to_evtchn_port(int irq)
 {
+	BUG_IF_VIRQ_PER_CPU(irq);
 	BUG_IF_IPI(irq);
 	return evtchn_from_irq(irq);
 }
@@ -1274,6 +1496,12 @@ static void restore_cpu_virqs(unsigned i
 		if ((irq = per_cpu(virq_to_irq, cpu)[virq]) == -1)
 			continue;
 
+#ifndef PER_CPU_VIRQ_IRQ
+		if (test_bit(virq, virq_per_cpu)
+		    && !VALID_EVTCHN(per_cpu(virq_to_evtchn, cpu)[virq]))
+			continue;
+#endif
+
 		BUG_ON(irq_cfg(irq)->info != mk_irq_info(IRQT_VIRQ, virq, 0));
 
 		/* Get a new binding from Xen. */
@@ -1286,7 +1514,20 @@ static void restore_cpu_virqs(unsigned i
 
 		/* Record the new mapping. */
 		evtchn_to_irq[evtchn] = irq;
+#ifdef PER_CPU_VIRQ_IRQ
 		irq_cfg(irq)->info = mk_irq_info(IRQT_VIRQ, virq, evtchn);
+#else
+		if (test_bit(virq, virq_per_cpu))
+			per_cpu(virq_to_evtchn, cpu)[virq] = evtchn;
+		else {
+			unsigned int cpu;
+
+			irq_cfg(irq)->info = mk_irq_info(IRQT_VIRQ, virq,
+							 evtchn);
+			for_each_possible_cpu(cpu)
+				per_cpu(virq_to_evtchn, cpu)[virq] = evtchn;
+		}
+#endif
 		bind_evtchn_to_cpu(evtchn, cpu);
 
 		/* Ready for use. */
@@ -1350,7 +1591,11 @@ static int evtchn_resume(struct sys_devi
 
 	/* Avoid doing anything in the 'suspend cancelled' case. */
 	status.dom = DOMID_SELF;
+#ifdef PER_CPU_VIRQ_IRQ
 	status.port = evtchn_from_irq(percpu_read(virq_to_irq[VIRQ_TIMER]));
+#else
+	status.port = percpu_read(virq_to_evtchn[VIRQ_TIMER]);
+#endif
 	if (HYPERVISOR_event_channel_op(EVTCHNOP_status, &status))
 		BUG();
 	if (status.status == EVTCHNSTAT_virq
@@ -1618,6 +1863,15 @@ void __init xen_init_IRQ(void)
 	unsigned int i;
 	struct physdev_pirq_eoi_gmfn eoi_gmfn;
 
+#ifndef PER_CPU_VIRQ_IRQ
+	__set_bit(VIRQ_TIMER, virq_per_cpu);
+	__set_bit(VIRQ_DEBUG, virq_per_cpu);
+	__set_bit(VIRQ_XENOPROF, virq_per_cpu);
+#ifdef CONFIG_IA64
+	__set_bit(VIRQ_ITC, virq_per_cpu);
+#endif
+#endif
+
 	init_evtchn_cpu_bindings();
 
 #ifdef CONFIG_SPARSE_IRQ
--- sle11sp2-2011-05-04.orig/drivers/xen/core/smpboot.c	2011-05-05 17:29:27.000000000 +0200
+++ sle11sp2-2011-05-04/drivers/xen/core/smpboot.c	2011-05-06 08:35:54.000000000 +0200
@@ -125,7 +125,7 @@ static int __cpuinit xen_smp_intr_init(u
  fail:
 	xen_spinlock_cleanup(cpu);
  unbind_ipi:
-	unbind_from_per_cpu_irq(ipi_irq, cpu);
+	unbind_from_per_cpu_irq(ipi_irq, cpu, NULL);
 	return rc;
 }
 
@@ -135,7 +135,7 @@ static void __cpuinit xen_smp_intr_exit(
 	if (cpu != 0)
 		local_teardown_timer(cpu);
 
-	unbind_from_per_cpu_irq(ipi_irq, cpu);
+	unbind_from_per_cpu_irq(ipi_irq, cpu, NULL);
 	xen_spinlock_cleanup(cpu);
 }
 #endif
--- sle11sp2-2011-05-04.orig/drivers/xen/netback/netback.c	2011-05-05 15:35:44.000000000 +0200
+++ sle11sp2-2011-05-04/drivers/xen/netback/netback.c	2011-05-06 08:35:58.000000000 +0200
@@ -1632,6 +1632,12 @@ static irqreturn_t netif_be_dbg(int irq,
 
 	return IRQ_HANDLED;
 }
+
+static struct irqaction netif_be_dbg_action = {
+	.handler = netif_be_dbg,
+	.flags   = IRQF_SHARED,
+	.name    = "net-be-dbg"
+};
 #endif
 
 static int __init netback_init(void)
@@ -1691,12 +1697,9 @@ static int __init netback_init(void)
 	netif_xenbus_init();
 
 #ifdef NETBE_DEBUG_INTERRUPT
-	(void)bind_virq_to_irqhandler(VIRQ_DEBUG,
-				      0,
-				      netif_be_dbg,
-				      IRQF_SHARED,
-				      "net-be-dbg",
-				      &netif_be_dbg);
+	(void)bind_virq_to_irqaction(VIRQ_DEBUG,
+				     0,
+				     &netif_be_dbg_action);
 #endif
 
 	return 0;
--- sle11sp2-2011-05-04.orig/drivers/xen/xenoprof/xenoprofile.c	2010-09-15 11:11:48.000000000 +0200
+++ sle11sp2-2011-05-04/drivers/xen/xenoprof/xenoprofile.c	2010-09-15 11:25:13.000000000 +0200
@@ -209,6 +209,11 @@ static irqreturn_t xenoprof_ovf_interrup
 	return IRQ_HANDLED;
 }
 
+static struct irqaction ovf_action = {
+	.handler = xenoprof_ovf_interrupt,
+	.flags   = IRQF_DISABLED,
+	.name    = "xenoprof"
+};
 
 static void unbind_virq(void)
 {
@@ -216,7 +221,7 @@ static void unbind_virq(void)
 
 	for_each_online_cpu(i) {
 		if (ovf_irq[i] >= 0) {
-			unbind_from_irqhandler(ovf_irq[i], NULL);
+			unbind_from_per_cpu_irq(ovf_irq[i], i, &ovf_action);
 			ovf_irq[i] = -1;
 		}
 	}
@@ -229,12 +234,7 @@ static int bind_virq(void)
 	int result;
 
 	for_each_online_cpu(i) {
-		result = bind_virq_to_irqhandler(VIRQ_XENOPROF,
-						 i,
-						 xenoprof_ovf_interrupt,
-						 IRQF_DISABLED|IRQF_NOBALANCING,
-						 "xenoprof",
-						 NULL);
+		result = bind_virq_to_irqaction(VIRQ_XENOPROF, i, &ovf_action);
 
 		if (result < 0) {
 			unbind_virq();
--- sle11sp2-2011-05-04.orig/include/xen/evtchn.h	2011-05-05 17:29:31.000000000 +0200
+++ sle11sp2-2011-05-04/include/xen/evtchn.h	2011-05-06 08:35:31.000000000 +0200
@@ -93,6 +93,17 @@ int bind_virq_to_irqhandler(
 	unsigned long irqflags,
 	const char *devname,
 	void *dev_id);
+#if defined(CONFIG_SMP) && defined(CONFIG_XEN) && defined(CONFIG_X86)
+int bind_virq_to_irqaction(
+	unsigned int virq,
+	unsigned int cpu,
+	struct irqaction *action);
+#else
+#define bind_virq_to_irqaction(virq, cpu, action) \
+	bind_virq_to_irqhandler(virq, cpu, (action)->handler, \
+			 	(action)->flags | IRQF_NOBALANCING, \
+				(action)->name, action)
+#endif
 #if defined(CONFIG_SMP) && !defined(MODULE)
 #ifndef CONFIG_X86
 int bind_ipi_to_irqhandler(
@@ -117,9 +128,13 @@ DECLARE_PER_CPU(DECLARE_BITMAP(, NR_IPIS
  */
 void unbind_from_irqhandler(unsigned int irq, void *dev_id);
 
-#if defined(CONFIG_SMP) && !defined(MODULE) && defined(CONFIG_X86)
+#if defined(CONFIG_SMP) && defined(CONFIG_XEN) && defined(CONFIG_X86)
 /* Specialized unbind function for per-CPU IRQs. */
-void unbind_from_per_cpu_irq(unsigned int irq, unsigned int cpu);
+void unbind_from_per_cpu_irq(unsigned int irq, unsigned int cpu,
+			     struct irqaction *);
+#else
+#define unbind_from_per_cpu_irq(irq, cpu, action) \
+	unbind_from_irqhandler(irq, action)
 #endif
 
 #ifndef CONFIG_XEN
