From: http://xenbits.xen.org/hg/linux-2.6.18-xen.hg/rev/0bee20f8e418
# HG changeset patch
# User Jan Beulich <jbeulich@novell.com>
# Date 1301756069 -3600
# Node ID 0bee20f8e418d32ab5828eb57c7542ca27ce425d
# Parent  8fe973d8fb987640dff885169bc64c7e7be3a772
Subject: xenbus: fix type inconsistency with xenbus_conn()
Patch-mainline: n/a

Its (bogus) declaration in xenbus_dev.c was inconsistent with the
actual implementation, leaving room for stack corruption on 64-bit
systems. Thus move the declaration to a header included by both
parties, and use proper types for the parameters.

Additionally, the function is needed on privileged kernels only, and
hence neither the potentially forward-incompatible HAVE_UNLOCKED_IOCTL
conditionals in xenbus_dev.c are needed, nor does the function (and
its helper) need to be compiled in unprivileged builds.

Signed-off-by: Jan Beulich <jbeulich@novell.com>

--- sle11sp1-2011-04-05.orig/drivers/xen/xenbus/xenbus_comms.h	2009-12-04 10:44:50.000000000 +0100
+++ sle11sp1-2011-04-05/drivers/xen/xenbus/xenbus_comms.h	2011-04-05 13:23:50.000000000 +0200
@@ -59,4 +59,11 @@ static inline int is_xenstored_ready(voi
 	return s == XENBUS_XSD_FOREIGN_READY || s == XENBUS_XSD_LOCAL_READY;
 }
 
+#if defined(CONFIG_XEN_XENBUS_DEV) && defined(CONFIG_XEN_PRIVILEGED_GUEST)
+#include <xen/interface/event_channel.h>
+#include <xen/interface/grant_table.h>
+
+int xenbus_conn(domid_t, grant_ref_t *, evtchn_port_t *);
+#endif
+
 #endif /* _XENBUS_COMMS_H */
--- sle11sp1-2011-04-05.orig/drivers/xen/xenbus/xenbus_dev.c	2011-01-04 14:23:03.000000000 +0100
+++ sle11sp1-2011-04-05/drivers/xen/xenbus/xenbus_dev.c	2011-04-05 13:23:50.000000000 +0200
@@ -392,12 +392,10 @@ static unsigned int xenbus_dev_poll(stru
 	return 0;
 }
 
-#ifdef HAVE_UNLOCKED_IOCTL
+#ifdef CONFIG_XEN_PRIVILEGED_GUEST
 static long xenbus_dev_ioctl(struct file *file,
                              unsigned int cmd, unsigned long data)
 {
-	extern int xenbus_conn(domid_t remote_dom, int *grant_ref,
-	                       evtchn_port_t *local_port);
 	void __user *udata = (void __user *) data;
 	int ret = -ENOTTY;
 	
@@ -450,7 +448,7 @@ static const struct file_operations xenb
 	.open = xenbus_dev_open,
 	.release = xenbus_dev_release,
 	.poll = xenbus_dev_poll,
-#ifdef HAVE_UNLOCKED_IOCTL
+#ifdef CONFIG_XEN_PRIVILEGED_GUEST
 	.unlocked_ioctl = xenbus_dev_ioctl
 #endif
 };
--- sle11sp1-2011-04-05.orig/drivers/xen/xenbus/xenbus_probe.c	2010-01-07 09:53:42.000000000 +0100
+++ sle11sp1-2011-04-05/drivers/xen/xenbus/xenbus_probe.c	2011-04-05 13:23:50.000000000 +0200
@@ -870,7 +870,8 @@ void xenbus_probe(void *unused)
 }
 
 
-#if defined(CONFIG_PROC_FS) && defined(CONFIG_XEN_PRIVILEGED_GUEST)
+#ifdef CONFIG_XEN_PRIVILEGED_GUEST
+#ifdef CONFIG_PROC_FS
 static struct file_operations xsd_kva_fops;
 static struct proc_dir_entry *xsd_kva_intf;
 static struct proc_dir_entry *xsd_port_intf;
@@ -932,6 +933,7 @@ static int xsd_port_read(char *page, cha
 }
 #endif
 
+#ifdef CONFIG_XEN_XENBUS_DEV
 static int xb_free_port(evtchn_port_t port)
 {
 	struct evtchn_close close;
@@ -939,7 +941,8 @@ static int xb_free_port(evtchn_port_t po
 	return HYPERVISOR_event_channel_op(EVTCHNOP_close, &close);
 }
 
-int xenbus_conn(domid_t remote_dom, unsigned long *grant_ref, evtchn_port_t *local_port)
+int xenbus_conn(domid_t remote_dom, grant_ref_t *grant_ref,
+		evtchn_port_t *local_port)
 {
 	struct evtchn_alloc_unbound alloc_unbound;
 	int rc, rc2;
@@ -947,10 +950,8 @@ int xenbus_conn(domid_t remote_dom, unsi
 	BUG_ON(atomic_read(&xenbus_xsd_state) != XENBUS_XSD_FOREIGN_INIT);
 	BUG_ON(!is_initial_xendomain());
 
-#if defined(CONFIG_PROC_FS) && defined(CONFIG_XEN_PRIVILEGED_GUEST)
 	remove_xen_proc_entry("xsd_kva");
 	remove_xen_proc_entry("xsd_port");
-#endif
 
 	rc = xb_free_port(xen_store_evtchn);
 	if (rc != 0)
@@ -987,6 +988,8 @@ fail0:
 	xen_store_evtchn = -1;
 	return rc;
 }
+#endif
+#endif /* CONFIG_XEN_PRIVILEGED_GUEST */
 
 static int xenbus_probe_init(void)
 {
