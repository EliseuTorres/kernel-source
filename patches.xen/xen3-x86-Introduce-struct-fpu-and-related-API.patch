From: Avi Kivity <avi@redhat.com>
Subject: [PATCH] x86: Introduce 'struct fpu' and related API
Patch-mainline: v2.6.35-rc1
References: FATE#311768

Currently all fpu state access is through tsk->thread.xstate.  Since we wish
to generalize fpu access to non-task contexts, wrap the state in a new
'struct fpu' and convert existing access to use an fpu API.

Signal frame handlers are not converted to the API since they will remain
task context only things.

Signed-off-by: Avi Kivity <avi@redhat.com>
Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
LKML-Reference: <1273135546-29690-3-git-send-email-avi@redhat.com>
Signed-off-by: H. Peter Anvin <hpa@zytor.com>
Acked-by: Bruce Rogers <brogers@suse.com>
Automatically created from "patches.arch/x86-Introduce-struct-fpu-and-related-API.patch" by xen-port-patches.py

--- sle11sp2-2011-06-28.orig/arch/x86/include/mach-xen/asm/processor.h	2011-05-05 15:54:44.000000000 +0200
+++ sle11sp2-2011-06-28/arch/x86/include/mach-xen/asm/processor.h	2011-06-28 13:12:59.000000000 +0200
@@ -395,6 +395,10 @@ union thread_xstate {
 	struct xsave_struct		xsave;
 };
 
+struct fpu {
+	union thread_xstate *state;
+};
+
 #ifdef CONFIG_X86_64
 #ifndef CONFIG_X86_NO_TSS
 DECLARE_PER_CPU(struct orig_ist, orig_ist);
@@ -472,7 +476,7 @@ struct thread_struct {
 	unsigned long		trap_no;
 	unsigned long		error_code;
 	/* floating point and extended processor state */
-	union thread_xstate	*xstate;
+	struct fpu		fpu;
 #ifdef CONFIG_X86_32
 	/* Virtual 86 mode info */
 	struct vm86_struct __user *vm86_info;
--- sle11sp2-2011-06-28.orig/arch/x86/kernel/process-xen.c	2011-05-05 15:59:38.000000000 +0200
+++ sle11sp2-2011-06-28/arch/x86/kernel/process-xen.c	2011-06-28 13:12:38.000000000 +0200
@@ -28,25 +28,22 @@ struct kmem_cache *task_xstate_cachep;
 
 int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
 {
+	int ret;
+
 	*dst = *src;
-	if (src->thread.xstate) {
-		dst->thread.xstate = kmem_cache_alloc(task_xstate_cachep,
-						      GFP_KERNEL);
-		if (!dst->thread.xstate)
-			return -ENOMEM;
-		WARN_ON((unsigned long)dst->thread.xstate & 15);
-		memcpy(dst->thread.xstate, src->thread.xstate, xstate_size);
+	if (fpu_allocated(&src->thread.fpu)) {
+		memset(&dst->thread.fpu, 0, sizeof(dst->thread.fpu));
+		ret = fpu_alloc(&dst->thread.fpu);
+		if (ret)
+			return ret;
+		fpu_copy(&dst->thread.fpu, &src->thread.fpu);
 	}
 	return 0;
 }
 
 void free_thread_xstate(struct task_struct *tsk)
 {
-	if (tsk->thread.xstate) {
-		kmem_cache_free(task_xstate_cachep, tsk->thread.xstate);
-		tsk->thread.xstate = NULL;
-	}
-
+	fpu_free(&tsk->thread.fpu);
 	WARN(tsk->thread.ds_ctx, "leaking DS context\n");
 }
 
--- sle11sp2-2011-06-28.orig/arch/x86/kernel/process_32-xen.c	2011-06-28 13:11:25.000000000 +0200
+++ sle11sp2-2011-06-28/arch/x86/kernel/process_32-xen.c	2011-06-28 13:12:40.000000000 +0200
@@ -464,7 +464,7 @@ __switch_to(struct task_struct *prev_p, 
 
 	/* we're going to use this soon, after a few expensive things */
 	if (preload_fpu)
-		prefetch(next->xstate);
+		prefetch(next->fpu.state);
 
 	/*
 	 * Now maybe handle debug registers
--- sle11sp2-2011-06-28.orig/arch/x86/kernel/process_64-xen.c	2011-06-28 13:11:25.000000000 +0200
+++ sle11sp2-2011-06-28/arch/x86/kernel/process_64-xen.c	2011-06-28 13:12:42.000000000 +0200
@@ -410,7 +410,7 @@ __switch_to(struct task_struct *prev_p, 
 
 	/* we're going to use this soon, after a few expensive things */
 	if (preload_fpu)
-		prefetch(next->xstate);
+		prefetch(next->fpu.state);
 
 	/*
 	 * This is basically '__unlazy_fpu', except that we queue a
