From: Jean Delvare <khali@linux-fr.org>
Date: Wed, 28 Sep 2011 08:11:00 -0700
Subject: [PATCH] hwmon: (coretemp) Fixup platform device ID change
References: bnc#698797, FATE#311941
Patch-mainline: 3.1
Git-commit: 0eb9782ad9b1bd496ba61cd5ea27ccb8db21e885

With recent change "hwmon: (coretemp) don't use kernel assigned CPU
number as platform device ID", the microcode check is now running on
random CPU. Fix that by checking the microcode before creating the
platform device rather than at probe time.

Also avoid calling TO_PHYS_ID(cpu) twice in the same function, it's
expensive.

Signed-off-by: Jean Delvare <khali@linux-fr.org>
Cc: Jan Beulich <jbeulich@suse.com>
Cc: Guenter Roeck <guenter.roeck@ericsson.com>
Signed-off-by: Guenter Roeck <guenter.roeck@ericsson.com>
Acked-by: Jean Delvare <jdelvare@suse.de>

Automatically created from "patches.drivers/hwmon-coretemp-09-fixup-platform-device-id-change.patch" by xen-port-patches.py

--- sle11sp2-2011-10-17.orig/drivers/hwmon/coretemp-xen.c	2011-10-17 12:44:27.000000000 +0200
+++ sle11sp2-2011-10-17/drivers/hwmon/coretemp-xen.c	2011-10-17 12:50:49.000000000 +0200
@@ -97,7 +97,6 @@ struct platform_data {
 	struct device *hwmon_dev;
 	u16 phys_proc_id;
 	u8 x86_model, x86_mask;
-	u32 ucode_rev;
 	struct temp_data *core_data[MAX_CORE_DATA];
 	struct device_attribute name_attr;
 };
@@ -374,10 +373,8 @@ exit_free:
 }
 
 
-static int chk_ucode_version(struct platform_device *pdev)
+static int chk_ucode_version(unsigned int cpu, const struct cpu_info *c)
 {
-	struct platform_data *c = platform_get_drvdata(pdev);
-
 	/*
 	 * Check if we have problem with errata AE18 of Core processors:
 	 * Readings might stop update when processor visited too deep sleep,
@@ -386,14 +383,12 @@ static int chk_ucode_version(struct plat
 	if (c->x86_model == 0xe && c->x86_mask < 0xc) {
 		/* check for microcode update */
 		if (!(c->ucode_rev + 1)) {
-			dev_err(&pdev->dev,
-				"Cannot determine microcode revision of "
-				"PKG#%u!\n", pdev->id);
+			pr_err("Cannot determine microcode revision of "
+			       "CPU#%u!\n", cpu);
 			return -ENODEV;
 		} else if (c->ucode_rev < 0x39) {
-			dev_err(&pdev->dev,
-				"Errata AE18 not fixed, update BIOS or "
-				"microcode of the CPU!\n");
+			pr_err("Errata AE18 not fixed, update BIOS or "
+			       "microcode of the CPU!\n");
 			return -ENODEV;
 		}
 	}
@@ -538,11 +533,6 @@ static int coretemp_probe(struct platfor
 	struct platform_data *pdata = platform_get_drvdata(pdev);
 	int err;
 
-	/* Check the microcode version of the CPU */
-	err = chk_ucode_version(pdev);
-	if (err)
-		return err;
-
 	/* Initialize the per-package data structures */
 	err = create_name_attr(pdata, &pdev->dev);
 	if (err)
@@ -611,7 +601,6 @@ static int coretemp_device_add(unsigned 
 	pdata->phys_proc_id = c->phys_proc_id;
 	pdata->x86_model = c->x86_model;
 	pdata->x86_mask = c->x86_mask;
-	pdata->ucode_rev = c->ucode_rev;
 	platform_set_drvdata(pdev, pdata);
 
 	pdev_entry = kzalloc(sizeof(struct pdev_entry), GFP_KERNEL);
@@ -732,6 +721,10 @@ static void get_core_online(unsigned int
 		return;
 
 	if (!pdev) {
+		/* Check the microcode version of the CPU */
+		if (chk_ucode_version(cpu, &info))
+			return;
+
 		/*
 		 * Alright, we have DTS support.
 		 * We are bringing the _first_ core in this pkg
