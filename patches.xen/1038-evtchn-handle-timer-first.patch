From: http://xenbits.xensource.com/linux-2.6.18-xen.hg?rev/a66a7c64b1d0
# HG changeset patch
# User Keir Fraser <keir.fraser@citrix.com>
# Date 1285147542 -3600
# Node ID a66a7c64b1d039fe4012a26164bbbbdc14727d61
# Parent  2146cf82c90c48ddc191728f3136a1db098b6c71
Subject: xen/evtchn: Handle VIRQ_TIMER before any other hardirq in event loop.
Patch-mainline: n/a

This avoids any other hardirq handler seeing a very stale jiffies
value immediately after wakeup from a long idle period. The one
observable symptom of this was a USB keyboard, with software keyboard
repeat, which would always repeat a key immediately that it was
pressed. This is due to the key press waking the guest, the key
handler immediately runs, sees an old jiffies value, and then that
jiffies value significantly updated, before the key is unpressed.

Signed-off-by: Keir Fraser <keir.fraser@citrix.com>
Acked-by: Jan Beulich <jbeulich@novell.com>

--- sle11sp1-2010-09-22.orig/drivers/xen/core/evtchn.c	2010-02-09 16:29:59.000000000 +0100
+++ sle11sp1-2010-09-22/drivers/xen/core/evtchn.c	2010-09-22 14:20:02.000000000 +0200
@@ -259,6 +259,20 @@ asmlinkage void evtchn_do_upcall(struct 
 		/* Clear master flag /before/ clearing selector flag. */
 		wmb();
 #endif
+
+		/*
+		 * Handle timer interrupts before all others, so that all
+		 * hardirq handlers see an up-to-date system time even if we
+		 * have just woken from a long idle period.
+		 */
+		if ((irq = __get_cpu_var(virq_to_irq)[VIRQ_TIMER]) != -1) {
+			port = evtchn_from_irq(irq);
+			l1i = port / BITS_PER_LONG;
+			l2i = port % BITS_PER_LONG;
+			if (active_evtchns(cpu, s, l1i) & (1ul<<l2i))
+				do_IRQ(irq, regs);
+		}
+
 		l1 = xchg(&vcpu_info->evtchn_pending_sel, 0);
 
 		start_l1i = l1i = per_cpu(current_l1i, cpu);
