From: Jean Delvare <khali@linux-fr.org>
Date: Fri, 16 Sep 2011 21:21:43 +0200
Subject: [PATCH] hwmon: (coretemp) Drop duplicate function get_pkg_tjmax
References: bnc#698797, FATE#311941
Patch-mainline: 3.1

Function get_pkg_tjmax is a simplified copy of get_tjmax. Drop it and
always use get_tjmax, result is the same and this avoids code
duplication.

Also make get_tjmax less verbose: don't warn about MSR read failure
when failure was expected, and don't report TjMax in the logs unless
debugging is enabled.

Signed-off-by: Jean Delvare <khali@linux-fr.org>
Cc: Fenghua Yu <fenghua.yu@intel.com>
Cc: Guenter Roeck <guenter.roeck@ericsson.com>
Cc: Durgadoss R <durgadoss.r@intel.com>
Acked-by: Fenghua Yu <fenghua.yu@intel.com>
Signed-off-by: Guenter Roeck <guenter.roeck@ericsson.com>
Acked-by: Jean Delvare <jdelvare@suse.de>

Automatically created from "patches.drivers/hwmon-coretemp-03-drop-duplicate-function-get_pkg_tjmax.patch" by xen-port-patches.py

--- sle11sp2-2011-10-17.orig/drivers/hwmon/coretemp-xen.c	2011-10-17 12:31:52.000000000 +0200
+++ sle11sp2-2011-10-17/drivers/hwmon/coretemp-xen.c	2011-10-17 12:35:58.000000000 +0200
@@ -389,7 +389,6 @@ static int adjust_tjmax(struct platform_
 
 static int get_tjmax(struct platform_data *c, u32 id, struct device *dev)
 {
-	/* The 100C is default for both mobile and non mobile CPUs */
 	int err;
 	u32 eax, edx;
 	u32 val;
@@ -400,7 +399,8 @@ static int get_tjmax(struct platform_dat
 	 */
 	err = rdmsr_safe_on_pcpu(id, MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);
 	if (err < 0) {
-		dev_warn(dev, "Unable to read TjMax from CPU.\n");
+		if (c->x86_model > 0xe && c->x86_model != 0x1c)
+			dev_warn(dev, "Unable to read TjMax from CPU %u\n", id);
 	} else {
 		val = (eax >> 16) & 0xff;
 		/*
@@ -408,7 +408,7 @@ static int get_tjmax(struct platform_dat
 		 * will be used
 		 */
 		if (val) {
-			dev_info(dev, "TjMax is %d C.\n", val);
+			dev_dbg(dev, "TjMax is %d degrees C\n", val);
 			return val * 1000;
 		}
 	}
@@ -420,21 +420,6 @@ static int get_tjmax(struct platform_dat
 	return adjust_tjmax(c, id, dev);
 }
 
-static int get_pkg_tjmax(unsigned int cpu, struct device *dev)
-{
-	int err;
-	u32 eax, edx, val;
-
-	err = rdmsr_safe_on_pcpu(cpu, MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);
-	if (err >= 0) {
-		val = (eax >> 16) & 0xff;
-		if (val)
-			return val * 1000;
-	}
-	dev_warn(dev, "Unable to read Pkg-TjMax from CPU:%u\n", cpu);
-	return 100000; /* Default TjMax: 100 degree celsius */
-}
-
 static int create_name_attr(struct platform_data *pdata, struct device *dev)
 {
 	sysfs_attr_init(&pdata->name_attr.attr);
@@ -592,10 +577,7 @@ static int create_core_data(struct platf
 		goto exit_free;
 
 	/* We can access status register. Get Critical Temperature */
-	if (pkg_flag)
-		tdata->tjmax = get_pkg_tjmax(cpu, &pdev->dev);
-	else
-		tdata->tjmax = get_tjmax(pdata, cpu, &pdev->dev);
+	tdata->tjmax = get_tjmax(pdata, cpu, &pdev->dev);
 
 	/*
 	 * Test if we can access the intrpt register. If so, increase the
