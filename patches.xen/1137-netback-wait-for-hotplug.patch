From: xen-devel@lists.xen.org
Patch-mainline: n/a
From http://xenbits.xen.org/hg/linux-2.6.18-xen.hg/rev/bd6298cb67d3
Subject: netback: wait for hotplug scripts to complete before signalling connected to frontend

Avoid the situation where the frontend is sending packets but the
domain 0 bridging (or whatever) is not yet configured (because the
hotplug scripts are too slow) and so packets get dropped.

Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
Cc: Steven.Smith@citrix.com

Acked-by: jbeulich@suse.com

--- sle11sp2-2012-01-03.orig/drivers/xen/netback/common.h	2012-01-03 11:46:15.000000000 +0100
+++ sle11sp2-2012-01-03/drivers/xen/netback/common.h	2012-01-03 00:00:00.000000000 +0100
@@ -141,6 +141,8 @@ struct backend_info {
 	struct xenbus_device *dev;
 	netif_t *netif;
 	enum xenbus_state frontend_state;
+	struct xenbus_watch hotplug_status_watch;
+	int have_hotplug_status_watch:1;
 
 	/* State relating to the netback accelerator */
 	void *netback_accel_priv;
--- sle11sp2-2012-01-03.orig/drivers/xen/netback/xenbus.c	2012-01-03 11:46:15.000000000 +0100
+++ sle11sp2-2012-01-03/drivers/xen/netback/xenbus.c	2012-01-03 00:00:00.000000000 +0100
@@ -32,6 +32,7 @@
 static int connect_rings(struct backend_info *);
 static void connect(struct backend_info *);
 static void backend_create_netif(struct backend_info *be);
+static void unregister_hotplug_status_watch(struct backend_info *be);
 static void netback_disconnect(struct device *);
 
 static int netback_remove(struct xenbus_device *dev)
@@ -50,8 +51,10 @@ static void netback_disconnect(struct de
 {
 	struct backend_info *be = xbdev_dev->driver_data;
 
+	unregister_hotplug_status_watch(be);
 	if (be->netif) {
 		kobject_uevent(&xbdev_dev->kobj, KOBJ_OFFLINE);
+		xenbus_rm(XBT_NIL, be->dev->nodename, "hotplug-status");
 		netif_disconnect(be);
 		be->netif = NULL;
 	}
@@ -329,6 +332,36 @@ static int xen_net_read_mac(struct xenbu
 	return 0;
 }
 
+static void unregister_hotplug_status_watch(struct backend_info *be)
+{
+	if (be->have_hotplug_status_watch) {
+		unregister_xenbus_watch(&be->hotplug_status_watch);
+		kfree(be->hotplug_status_watch.node);
+	}
+	be->have_hotplug_status_watch = 0;
+}
+
+static void hotplug_status_changed(struct xenbus_watch *watch,
+				   const char **vec,
+				   unsigned int vec_size)
+{
+	struct backend_info *be = container_of(watch,
+					       struct backend_info,
+					       hotplug_status_watch);
+	char *str;
+	unsigned int len;
+
+	str = xenbus_read(XBT_NIL, be->dev->nodename, "hotplug-status", &len);
+	if (IS_ERR(str))
+		return;
+	if (len == sizeof("connected")-1 && !memcmp(str, "connected", len)) {
+		xenbus_switch_state(be->dev, XenbusStateConnected);
+		/* Not interested in this watch anymore. */
+		unregister_hotplug_status_watch(be);
+	}
+	kfree(str);
+}
+
 static void connect(struct backend_info *be)
 {
 	int err;
@@ -348,7 +381,16 @@ static void connect(struct backend_info 
 			  &be->netif->credit_usec);
 	be->netif->remaining_credit = be->netif->credit_bytes;
 
-	xenbus_switch_state(dev, XenbusStateConnected);
+	unregister_hotplug_status_watch(be);
+	err = xenbus_watch_path2(dev, dev->nodename, "hotplug-status",
+				 &be->hotplug_status_watch,
+				 hotplug_status_changed);
+	if (err) {
+		/* Switch now, since we can't do a watch. */
+		xenbus_switch_state(dev, XenbusStateConnected);
+	} else {
+		be->have_hotplug_status_watch = 1;
+	}
 
 	netif_wake_queue(be->netif->dev);
 }
