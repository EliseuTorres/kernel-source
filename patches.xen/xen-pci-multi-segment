Subject: pass PCI segment information to Xen
From: jbeulich@novell.com
Patch-mainline: n/a

--- head-2011-08-09.orig/drivers/pci/msi-xen.c	2011-02-01 15:03:03.000000000 +0100
+++ head-2011-08-09/drivers/pci/msi-xen.c	2011-08-09 13:41:53.000000000 +0200
@@ -26,6 +26,11 @@
 #include "msi.h"
 
 static int pci_msi_enable = 1;
+#if CONFIG_XEN_COMPAT < 0x040200
+static bool pci_seg_supported = true;
+#else
+#define pci_seg_supported true
+#endif
 
 static LIST_HEAD(msi_dev_head);
 DEFINE_SPINLOCK(msi_dev_lock);
@@ -232,21 +237,34 @@ static u64 find_table_base(struct pci_de
 static int msi_map_vector(struct pci_dev *dev, int entry_nr, u64 table_base)
 {
 	struct physdev_map_pirq map_irq;
-	int rc;
+	int rc = -EINVAL;
 	domid_t domid = DOMID_SELF;
 
 	domid = msi_get_dev_owner(dev);
 
 	map_irq.domid = domid;
-	map_irq.type = MAP_PIRQ_TYPE_MSI;
+	map_irq.type = MAP_PIRQ_TYPE_MSI_SEG;
 	map_irq.index = -1;
 	map_irq.pirq = -1;
-	map_irq.bus = dev->bus->number;
+	map_irq.bus = dev->bus->number | (pci_domain_nr(dev->bus) << 16);
 	map_irq.devfn = dev->devfn;
 	map_irq.entry_nr = entry_nr;
 	map_irq.table_base = table_base;
 
-	if ((rc = HYPERVISOR_physdev_op(PHYSDEVOP_map_pirq, &map_irq)))
+	if (pci_seg_supported)
+		rc = HYPERVISOR_physdev_op(PHYSDEVOP_map_pirq, &map_irq);
+#if CONFIG_XEN_COMPAT < 0x040200
+	if (rc == -EINVAL && !pci_domain_nr(dev->bus)) {
+		map_irq.type = MAP_PIRQ_TYPE_MSI;
+		map_irq.index = -1;
+		map_irq.pirq = -1;
+		map_irq.bus = dev->bus->number;
+		rc = HYPERVISOR_physdev_op(PHYSDEVOP_map_pirq, &map_irq);
+		if (rc != -EINVAL)
+			pci_seg_supported = false;
+	}
+#endif
+	if (rc)
 		dev_warn(&dev->dev, "map irq failed\n");
 
 	if (rc < 0)
@@ -282,8 +300,7 @@ static void pci_intx_for_msi(struct pci_
 
 void pci_restore_msi_state(struct pci_dev *dev)
 {
-	int rc;
-	struct physdev_restore_msi restore;
+	int rc = -ENOSYS;
 
 	if (!dev->msi_enabled && !dev->msix_enabled)
 		return;
@@ -297,9 +314,27 @@ void pci_restore_msi_state(struct pci_de
 	if (dev->msix_enabled)
 		msix_set_enable(dev, 0);
 
-	restore.bus = dev->bus->number;
-	restore.devfn = dev->devfn;
-	rc = HYPERVISOR_physdev_op(PHYSDEVOP_restore_msi, &restore);
+	if (pci_seg_supported) {
+		struct physdev_pci_device restore = {
+			.seg = pci_domain_nr(dev->bus),
+			.bus = dev->bus->number,
+			.devfn = dev->devfn
+		};
+
+		rc = HYPERVISOR_physdev_op(PHYSDEVOP_restore_msi_ext,
+					   &restore);
+	}
+#if CONFIG_XEN_COMPAT < 0x040200
+	if (rc == -ENOSYS && !pci_domain_nr(dev->bus)) {
+		struct physdev_restore_msi restore = {
+			.bus = dev->bus->number,
+			.devfn = dev->devfn
+		};
+
+		pci_seg_supported = false;
+		rc = HYPERVISOR_physdev_op(PHYSDEVOP_restore_msi, &restore);
+	}
+#endif
 	WARN(rc && rc != -ENOSYS, "restore_msi -> %d\n", rc);
 }
 EXPORT_SYMBOL_GPL(pci_restore_msi_state);
--- head-2011-08-09.orig/drivers/xen/pci.c	2011-08-18 11:21:53.000000000 +0200
+++ head-2011-08-09/drivers/xen/pci.c	2011-08-18 11:42:23.000000000 +0200
@@ -18,11 +18,13 @@
  */
 
 #include <linux/pci.h>
+#include <linux/acpi.h>
 #include <xen/xen.h>
 #include <xen/interface/physdev.h>
 #include <xen/interface/xen.h>
 
 #ifdef CONFIG_PARAVIRT_XEN
+#define CONFIG_XEN_COMPAT 0x040000
 #include <asm/xen/hypervisor.h>
 #include <asm/xen/hypercall.h>
 #else
@@ -30,26 +32,91 @@
 #endif
 #include "../pci/pci.h"
 
+#if CONFIG_XEN_COMPAT < 0x040200
+static bool __read_mostly pci_seg_supported = true;
+#else
+#define pci_seg_supported true
+#endif
+
 static int xen_add_device(struct device *dev)
 {
 	int r;
 	struct pci_dev *pci_dev = to_pci_dev(dev);
+#ifdef CONFIG_PCI_IOV
+	struct pci_dev *physfn = pci_dev->physfn;
+#endif
+
+	if (pci_seg_supported) {
+		struct physdev_pci_device_add add = {
+			.seg = pci_domain_nr(pci_dev->bus),
+			.bus = pci_dev->bus->number,
+			.devfn = pci_dev->devfn
+		};
+#ifdef CONFIG_ACPI
+		acpi_handle handle;
+#endif
+
+#ifdef CONFIG_PCI_IOV
+		if (pci_dev->is_virtfn) {
+			add.flags = XEN_PCI_DEV_VIRTFN;
+			add.physfn.bus = physfn->bus->number;
+			add.physfn.devfn = physfn->devfn;
+		} else
+#endif
+		if (pci_ari_enabled(pci_dev->bus) && PCI_SLOT(pci_dev->devfn))
+			add.flags = XEN_PCI_DEV_EXTFN;
 
+#ifdef CONFIG_ACPI
+		handle = DEVICE_ACPI_HANDLE(&pci_dev->dev);
+		if (!handle)
+			handle = DEVICE_ACPI_HANDLE(pci_dev->bus->bridge);
 #ifdef CONFIG_PCI_IOV
-	if (pci_dev->is_virtfn) {
+		if (!handle && pci_dev->is_virtfn)
+			handle = DEVICE_ACPI_HANDLE(physfn->bus->bridge);
+#endif
+		if (handle) {
+			acpi_status status;
+
+			do {
+				unsigned long long pxm;
+
+				status = acpi_evaluate_integer(handle, "_PXM",
+							       NULL, &pxm);
+				if (ACPI_SUCCESS(status)) {
+					add.optarr[0] = pxm;
+					add.flags |= XEN_PCI_DEV_PXM;
+					break;
+				}
+				status = acpi_get_parent(handle, &handle);
+			} while (ACPI_SUCCESS(status));
+		}
+#endif /* CONFIG_ACPI */
+
+		r = HYPERVISOR_physdev_op(PHYSDEVOP_pci_device_add, &add);
+		if (r != -ENOSYS)
+			return r;
+#if CONFIG_XEN_COMPAT < 0x040200
+		pci_seg_supported = false;
+#endif
+	}
+
+	if (pci_domain_nr(pci_dev->bus))
+		r = -ENOSYS;
+#ifdef CONFIG_PCI_IOV
+	else if (pci_dev->is_virtfn) {
 		struct physdev_manage_pci_ext manage_pci_ext = {
 			.bus		= pci_dev->bus->number,
 			.devfn		= pci_dev->devfn,
 			.is_virtfn 	= 1,
-			.physfn.bus	= pci_dev->physfn->bus->number,
-			.physfn.devfn	= pci_dev->physfn->devfn,
+			.physfn.bus	= physfn->bus->number,
+			.physfn.devfn	= physfn->devfn,
 		};
 
 		r = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_add_ext,
 			&manage_pci_ext);
-	} else
+	}
 #endif
-	if (pci_ari_enabled(pci_dev->bus) && PCI_SLOT(pci_dev->devfn)) {
+	else if (pci_ari_enabled(pci_dev->bus) && PCI_SLOT(pci_dev->devfn)) {
 		struct physdev_manage_pci_ext manage_pci_ext = {
 			.bus		= pci_dev->bus->number,
 			.devfn		= pci_dev->devfn,
@@ -75,13 +142,27 @@ static int xen_remove_device(struct devi
 {
 	int r;
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct physdev_manage_pci manage_pci;
 
-	manage_pci.bus = pci_dev->bus->number;
-	manage_pci.devfn = pci_dev->devfn;
+	if (pci_seg_supported) {
+		struct physdev_pci_device device = {
+			.seg = pci_domain_nr(pci_dev->bus),
+			.bus = pci_dev->bus->number,
+			.devfn = pci_dev->devfn
+		};
 
-	r = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_remove,
-		&manage_pci);
+		r = HYPERVISOR_physdev_op(PHYSDEVOP_pci_device_remove,
+					  &device);
+	} else if (pci_domain_nr(pci_dev->bus))
+		r = -ENOSYS;
+	else {
+		struct physdev_manage_pci manage_pci = {
+			.bus = pci_dev->bus->number,
+			.devfn = pci_dev->devfn
+		};
+
+		r = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_remove,
+					  &manage_pci);
+	}
 
 	return r;
 }
--- head-2011-08-09.orig/include/xen/interface/physdev.h	2011-07-05 17:23:43.000000000 +0200
+++ head-2011-08-09/include/xen/interface/physdev.h	2011-08-10 08:21:19.000000000 +0200
@@ -142,6 +142,7 @@ DEFINE_XEN_GUEST_HANDLE(physdev_irq_t);
 #define MAP_PIRQ_TYPE_MSI		0x0
 #define MAP_PIRQ_TYPE_GSI		0x1
 #define MAP_PIRQ_TYPE_UNKNOWN		0x2
+#define MAP_PIRQ_TYPE_MSI_SEG		0x3
 
 #define PHYSDEVOP_map_pirq		13
 struct physdev_map_pirq {
@@ -152,7 +153,7 @@ struct physdev_map_pirq {
     int index;
     /* IN or OUT */
     int pirq;
-    /* IN */
+    /* IN - high 16 bits hold segment for MAP_PIRQ_TYPE_MSI_SEG */
     int bus;
     /* IN */
     int devfn;
@@ -264,6 +265,41 @@ struct physdev_pci_mmcfg_reserved {
 typedef struct physdev_pci_mmcfg_reserved physdev_pci_mmcfg_reserved_t;
 DEFINE_XEN_GUEST_HANDLE(physdev_pci_mmcfg_reserved_t);
 
+#define XEN_PCI_DEV_EXTFN              0x1
+#define XEN_PCI_DEV_VIRTFN             0x2
+#define XEN_PCI_DEV_PXM                0x4
+
+#define PHYSDEVOP_pci_device_add        25
+struct physdev_pci_device_add {
+    /* IN */
+    uint16_t seg;
+    uint8_t bus;
+    uint8_t devfn;
+    uint32_t flags;
+    struct {
+        uint8_t bus;
+        uint8_t devfn;
+    } physfn;
+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+    uint32_t optarr[];
+#elif defined(__GNUC__)
+    uint32_t optarr[0];
+#endif
+};
+typedef struct physdev_pci_device_add physdev_pci_device_add_t;
+DEFINE_XEN_GUEST_HANDLE(physdev_pci_device_add_t);
+
+#define PHYSDEVOP_pci_device_remove     26
+#define PHYSDEVOP_restore_msi_ext       27
+struct physdev_pci_device {
+    /* IN */
+    uint16_t seg;
+    uint8_t bus;
+    uint8_t devfn;
+};
+typedef struct physdev_pci_device physdev_pci_device_t;
+DEFINE_XEN_GUEST_HANDLE(physdev_pci_device_t);
+
 /*
  * Notify that some PIRQ-bound event channels have been unmasked.
  * ** This command is obsolete since interface version 0x00030202 and is **
