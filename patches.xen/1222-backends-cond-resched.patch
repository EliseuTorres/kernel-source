From http://xenbits.xen.org/hg/linux-2.6.18-xen.hg/rev/d732224ce60e
From: xen-devel@lists.xen.org
Patch-mainline: n/a
Subject: scsiback/usbback: move cond_resched() invocations to proper place

The call to cond_resched() must be inside the loop, in order to not
expose the host to guest induced soft lockups (due to a close to
unbounded loop).

Also rate limit printk()-s in those loops as well as in blktap's.

Signed-off-by: Jan Beulich <jbeulich@suse.com>

--- sle11sp2.orig/drivers/xen/blktap/common.h	2013-01-28 15:45:03.000000000 +0100
+++ sle11sp2/drivers/xen/blktap/common.h	2013-01-28 08:54:23.000000000 +0100
@@ -40,7 +40,9 @@
 #define DPRINTK(_f, _a...) pr_debug("(file=%s, line=%d) " _f, \
                                     __FILE__ , __LINE__ , ## _a )
 
-#define WPRINTK(fmt, args...) printk(KERN_WARNING "blk_tap: " fmt, ##args)
+#define WPRINTK(fmt, args...) \
+	((void)(printk_ratelimit() && \
+		printk(KERN_WARNING "blk_tap: " fmt, ##args)))
 
 struct backend_info;
 
--- sle11sp2.orig/drivers/xen/scsiback/scsiback.c	2013-01-28 15:45:05.000000000 +0100
+++ sle11sp2/drivers/xen/scsiback/scsiback.c	2013-01-28 08:44:38.000000000 +0100
@@ -615,40 +615,36 @@ static int scsiback_do_cmd_fn(struct vsc
 
 		err = prepare_pending_reqs(info, ring_req,
 						pending_req);
-		if (err == -EINVAL) {
-			scsiback_do_resp_with_sense(NULL, (DRIVER_ERROR << 24),
-				0, pending_req);
-			continue;
-		} else if (err == -ENODEV) {
-			scsiback_do_resp_with_sense(NULL, (DID_NO_CONNECT << 16),
-				0, pending_req);
-			continue;
-		}
-
-		if (pending_req->act == VSCSIIF_ACT_SCSI_CDB) {
-
+		switch (err ?: pending_req->act) {
+		case VSCSIIF_ACT_SCSI_CDB:
 			/* The Host mode is through as for Emulation. */
 			if (info->feature == VSCSI_TYPE_HOST)
 				scsiback_cmd_exec(pending_req);
 			else
 				scsiback_req_emulation_or_cmdexec(pending_req);
-
-		} else if (pending_req->act == VSCSIIF_ACT_SCSI_RESET) {
+			break;
+		case VSCSIIF_ACT_SCSI_RESET:
 			scsiback_device_reset_exec(pending_req);
-		} else {
-			printk(KERN_ERR "scsiback: invalid parameter for request\n");
-			scsiback_do_resp_with_sense(NULL, (DRIVER_ERROR << 24),
-				0, pending_req);
-			continue;
+			break;
+		default:
+			if(!err && printk_ratelimit())
+				printk(KERN_ERR "scsiback: invalid request\n");
+			scsiback_do_resp_with_sense(NULL, DRIVER_ERROR << 24,
+						    0, pending_req);
+			break;
+		case -ENODEV:
+			scsiback_do_resp_with_sense(NULL, DID_NO_CONNECT << 16,
+						    0, pending_req);
+			break;
 		}
+
+		/* Yield point for this unbounded loop. */
+		cond_resched();
 	}
 
 	if (RING_HAS_UNCONSUMED_REQUESTS(ring))
 		more_to_do = 1;
 
-	/* Yield point for this unbounded loop. */
-	cond_resched();
-
 	return more_to_do;
 }
 
--- sle11sp2.orig/drivers/xen/usbback/usbback.c	2013-01-28 15:45:05.000000000 +0100
+++ sle11sp2/drivers/xen/usbback/usbback.c	2013-01-28 08:48:50.000000000 +0100
@@ -981,7 +981,9 @@ static int usbbk_start_submit_urb(usbif_
 
 	while (rc != rp) {
 		if (RING_REQUEST_CONS_OVERFLOW(urb_ring, rc)) {
-			printk(KERN_WARNING "RING_REQUEST_CONS_OVERFLOW\n");
+			if(printk_ratelimit())
+				printk(KERN_WARNING "usbback: "
+				       "RING_REQUEST_CONS_OVERFLOW\n");
 			break;
 		}
 
@@ -996,12 +996,12 @@ static int usbbk_start_submit_urb(usbif_
 
 		dispatch_request_to_pending_reqs(usbif, req,
 							pending_req);
+
+		cond_resched();
 	}
 
 	RING_FINAL_CHECK_FOR_REQUESTS(&usbif->urb_ring, more_to_do);
 
-	cond_resched();
-
 	return more_to_do;
 }
 
