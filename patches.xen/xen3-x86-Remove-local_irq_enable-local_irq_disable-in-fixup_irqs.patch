From: Suresh Siddha <suresh.b.siddha@intel.com>
Subject: x86: Remove local_irq_enable()/local_irq_disable() in fixup_irqs()
References: bnc#558247
Patch-mainline: 2.6.33-rc1
Git-commit: 5231a68614b94f60e8f6c56bc6e3d75955b9e75e

Commit 5231a68614b94f60e8f6c56bc6e3d75955b9e75e upstream.
    
To ensure that we handle all the pending interrupts (destined
for this cpu that is going down) in the interrupt subsystem
before the cpu goes offline, fixup_irqs() does:

	local_irq_enable();
	mdelay(1);
	local_irq_disable();

Enabling interrupts is not a good thing as this cpu is already
offline. So this patch replaces that logic with,

	mdelay(1);
	check APIC_IRR bits
	Retrigger the irq at the new destination if any interrupt has arrived
	via IPI.

For IO-APIC level triggered interrupts, this retrigger IPI will
appear as an edge interrupt. ack_apic_level() will detect this
condition and IO-APIC RTE's remoteIRR is cleared using directed
EOI(using IO-APIC EOI register) on Intel platforms and for
others it uses the existing mask+edge logic followed by
unmask+level.
    
We can also remove mdelay() and then send spuriuous interrupts
to new cpu targets for all the irqs that were handled previously
by this cpu that is going offline. While it works, I have seen
spurious interrupt messages (nothing wrong but still annoying
messages during cpu offline, which can be seen during
suspend/resume etc)
    
Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
Acked-by: Gary Hade <garyhade@us.ibm.com>
Signed-off-by: Ingo Molnar <mingo@elte.hu>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
Automatically created from "patches.arch/x86-Remove-local_irq_enable-local_irq_disable-in-fixup_irqs.patch" by xen-port-patches.py

--- sle11sp1-2010-11-04.orig/arch/x86/kernel/irq-xen.c	2010-08-17 13:34:34.000000000 +0200
+++ sle11sp1-2010-11-04/arch/x86/kernel/irq-xen.c	2010-08-17 13:34:39.000000000 +0200
@@ -295,12 +295,14 @@ void smp_generic_interrupt(struct pt_reg
 #endif
 
 #ifdef CONFIG_HOTPLUG_CPU
+#include <xen/evtchn.h>
 /* A cpu has been removed from cpu_online_mask.  Reset irq affinities. */
 void fixup_irqs(void)
 {
 	unsigned int irq;
 	static int warned;
 	struct irq_desc *desc;
+	static DECLARE_BITMAP(irqs_used, NR_IRQS);
 
 	for_each_irq_desc(irq, desc) {
 		int break_affinity = 0;
@@ -322,6 +324,9 @@ void fixup_irqs(void)
 			continue;
 		}
 
+		if (cpumask_test_cpu(smp_processor_id(), affinity))
+			__set_bit(irq, irqs_used);
+
 		if (cpumask_any_and(affinity, cpu_online_mask) >= nr_cpu_ids) {
 			break_affinity = 1;
 			affinity = cpu_all_mask;
@@ -346,9 +351,27 @@ void fixup_irqs(void)
 			printk("Cannot set affinity for irq %i\n", irq);
 	}
 
-	/* That doesn't seem sufficient.  Give it 1ms. */
-	local_irq_enable();
+	/*
+	 * We can remove mdelay() and then send spuriuous interrupts to
+	 * new cpu targets for all the irqs that were handled previously by
+	 * this cpu. While it works, I have seen spurious interrupt messages
+	 * (nothing wrong but still...).
+	 *
+	 * So for now, retain mdelay(1) and check the IRR and then send those
+	 * interrupts to new targets as this cpu is already offlined...
+	 */
 	mdelay(1);
-	local_irq_disable();
+
+	for_each_irq_desc(irq, desc) {
+		if (!__test_and_clear_bit(irq, irqs_used))
+			continue;
+
+		if (xen_test_irq_pending(irq)) {
+			spin_lock(&desc->lock);
+			if (desc->chip->retrigger)
+				desc->chip->retrigger(irq);
+			spin_unlock(&desc->lock);
+		}
+	}
 }
 #endif
--- sle11sp1-2010-11-04.orig/drivers/xen/core/evtchn.c	2010-09-22 16:15:52.000000000 +0200
+++ sle11sp1-2010-11-04/drivers/xen/core/evtchn.c	2010-11-15 17:21:56.000000000 +0100
@@ -1030,6 +1030,14 @@ void disable_all_local_evtchn(void)
 			synch_set_bit(i, &s->evtchn_mask[0]);
 }
 
+/* Test an irq's pending state. */
+int xen_test_irq_pending(int irq)
+{
+	int evtchn = evtchn_from_irq(irq);
+
+	return VALID_EVTCHN(evtchn) && test_evtchn(evtchn);
+}
+
 #ifdef CONFIG_PM_SLEEP
 static void restore_cpu_virqs(unsigned int cpu)
 {
--- sle11sp1-2010-11-04.orig/include/xen/evtchn.h	2010-08-17 12:26:21.000000000 +0200
+++ sle11sp1-2010-11-04/include/xen/evtchn.h	2010-08-17 15:56:28.000000000 +0200
@@ -168,6 +168,9 @@ static inline int close_evtchn(int port)
 	return HYPERVISOR_event_channel_op(EVTCHNOP_close, &close);
 }
 
+/* Test an irq's pending state. */
+int xen_test_irq_pending(int irq);
+
 /*
  * Use these to access the event channel underlying the IRQ handle returned
  * by bind_*_to_irqhandler().
