From: Petr Tesarik <ptesarik@suse.cz>
Subject: /dev/mem: handle out-of-bounds read/write
Patch-Mainline: Submitted to linux-kernel, 30 Jan 2014
References: FATE#310031

The loff_t type may be wider than phys_addr_t (e.g. on 32-bit systems).
Consequently, the file offset may be truncated in the assignment.
Currently, /dev/mem wraps around, which may cause applications to read
or write incorrect regions of memory by accident.

Let's follow POSIX file semantics here and return 0 when reading from
and -EFBIG when writing to an offset that cannot be represented by a
phys_addr_t.

Note that the conditional is optimized out by the compiler if loff_t
has the same size as phys_addr_t.

Signed-off-by: Petr Tesarik <ptesarik@suse.cz>
Automatically created from "patches.fixes/dev_mem-read-write-beyond-EOF.patch" by xen-port-patches.py

--- sle12.orig/drivers/xen/char/mem.c	2013-08-12 13:00:59.000000000 +0200
+++ sle12/drivers/xen/char/mem.c	2014-02-06 15:16:49.000000000 +0100
@@ -67,6 +67,9 @@ static ssize_t read_mem(struct file *fil
 	ssize_t read = 0, sz;
 	void __iomem *v;
 
+	if (p != *ppos)
+		return 0;
+
 	while (count > 0) {
 		unsigned long remaining;
 
@@ -113,6 +116,9 @@ static ssize_t write_mem(struct file *fi
 	ssize_t written = 0, sz, ignored;
 	void __iomem *v;
 
+	if (p != *ppos)
+		return -EFBIG;
+
 	while (count > 0) {
 		sz = size_inside_page(p, count);
 
