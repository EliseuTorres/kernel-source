From: Jeff Garzik <jeff@garzik.org>
Date: Tue, 16 Nov 2010 02:10:29 -0500
Subject: [PATCH] SCSI host lock push-down
References: FATE#311826
Patch-Mainline: 2.6.38

Move the mid-layer's ->queuecommand() invocation from being locked
with the host lock to being unlocked to facilitate speeding up the
critical path for drivers who don't need this lock taken anyway.

The patch below presents a simple SCSI host lock push-down as an
equivalent transformation.  No locking or other behavior should change
with this patch.  All existing bugs and locking orders are preserved.

Additionally, add one parameter to queuecommand,
	struct Scsi_Host *
and remove one parameter from queuecommand,
	void (*done)(struct scsi_cmnd *)

Scsi_Host* is a convenient pointer that most host drivers need anyway,
and 'done' is redundant to struct scsi_cmnd->scsi_done.

Minimal code disturbance was attempted with this change.  Most drivers
needed only two one-line modifications for their host lock push-down.

Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
Acked-by: James Bottomley <James.Bottomley@suse.de>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Hannes Reinecke <hare@suse.de>
Automatically created from "patches.suse/scsi-host-lock-push-down.patch" by xen-port-patches.py

--- sle11sp2-2011-06-20.orig/drivers/xen/scsifront/scsifront.c	2011-05-05 11:01:48.000000000 +0200
+++ sle11sp2-2011-06-20/drivers/xen/scsifront/scsifront.c	2011-06-20 12:46:08.000000000 +0200
@@ -315,11 +315,12 @@ big_to_sg:
 	return ref_cnt;
 }
 
-static int scsifront_queuecommand(struct scsi_cmnd *sc,
-				  void (*done)(struct scsi_cmnd *))
+static int scsifront_queuecommand(struct Scsi_Host *shost,
+				  struct scsi_cmnd *sc)
 {
-	struct vscsifrnt_info *info = shost_priv(sc->device->host);
+	struct vscsifrnt_info *info = shost_priv(shost);
 	vscsiif_request_t *ring_req;
+	unsigned long flags;
 	int ref_cnt;
 	uint16_t rqid;
 
@@ -328,11 +329,12 @@ static int scsifront_queuecommand(struct
 		sc->cmnd[0],sc->cmnd[1],sc->cmnd[2],sc->cmnd[3],sc->cmnd[4],
 		sc->cmnd[5],sc->cmnd[6],sc->cmnd[7],sc->cmnd[8],sc->cmnd[9]);
 */
+	spin_lock_irqsave(shost->host_lock, flags);
 	if (RING_FULL(&info->ring)) {
-		goto out_host_busy;
+		spin_unlock_irqrestore(shost->host_lock, flags);
+		return SCSI_MLQUEUE_HOST_BUSY;
 	}
 
-	sc->scsi_done = done;
 	sc->result    = 0;
 
 	ring_req          = scsifront_pre_request(info);
@@ -361,27 +363,21 @@ static int scsifront_queuecommand(struct
 	ref_cnt = map_data_for_request(info, sc, ring_req, rqid);
 	if (ref_cnt < 0) {
 		add_id_to_freelist(info, rqid);
+		spin_unlock_irqrestore(shost->host_lock, flags);
 		if (ref_cnt == (-ENOMEM))
-			goto out_host_busy;
-		else {
-			sc->result = (DID_ERROR << 16);
-			goto out_fail_command;
-		}
+			return SCSI_MLQUEUE_HOST_BUSY;
+		sc->result = (DID_ERROR << 16);
+		sc->scsi_done(sc);
+		return 0;
 	}
 
 	ring_req->nr_segments          = (uint8_t)ref_cnt;
 	info->shadow[rqid].nr_segments = ref_cnt;
 
 	scsifront_do_request(info);
+	spin_unlock_irqrestore(shost->host_lock, flags);
 
 	return 0;
-
-out_host_busy:
-	return SCSI_MLQUEUE_HOST_BUSY;
-
-out_fail_command:
-	done(sc);
-	return 0;
 }
 
 
