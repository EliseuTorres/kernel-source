From: Jiri Slaby <jslaby@suse.cz>
Subject: Linux 3.12.37
Patch-mainline: 3.12.37

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Automatically created from "patches.kernel.org/patch-3.12.36-37" by xen-port-patches.py

--- sle12.orig/arch/x86/Kconfig	2014-09-01 16:15:44.000000000 +0200
+++ sle12/arch/x86/Kconfig	2015-01-30 14:55:07.000000000 +0100
@@ -908,6 +908,7 @@ config X86_UP_APIC
 
 config X86_UP_APIC_MSI
 	def_bool y
+	depends on !XEN_UNPRIVILEGED_GUEST
 	select X86_UP_APIC if X86_32 && !SMP && !X86_32_NON_STANDARD && PCI_MSI
 
 config X86_UP_IOAPIC
--- sle12.orig/arch/x86/include/mach-xen/asm/desc.h	2013-08-12 13:00:59.000000000 +0200
+++ sle12/arch/x86/include/mach-xen/asm/desc.h	2015-01-30 14:54:25.000000000 +0100
@@ -275,7 +275,8 @@ static inline void xen_load_tls(struct t
 }
 #endif
 
-#define _LDT_empty(info)				\
+/* This intentionally ignores lm, since 32-bit apps don't have that field. */
+#define LDT_empty(info)					\
 	((info)->base_addr		== 0	&&	\
 	 (info)->limit			== 0	&&	\
 	 (info)->contents		== 0	&&	\
@@ -285,11 +286,18 @@ static inline void xen_load_tls(struct t
 	 (info)->seg_not_present	== 1	&&	\
 	 (info)->useable		== 0)
 
-#ifdef CONFIG_X86_64
-#define LDT_empty(info) (_LDT_empty(info) && ((info)->lm == 0))
-#else
-#define LDT_empty(info) (_LDT_empty(info))
-#endif
+/* Lots of programs expect an all-zero user_desc to mean "no segment at all". */
+static inline bool LDT_zero(const struct user_desc *info)
+{
+	return (info->base_addr		== 0 &&
+		info->limit		== 0 &&
+		info->contents		== 0 &&
+		info->read_exec_only	== 0 &&
+		info->seg_32bit		== 0 &&
+		info->limit_in_pages	== 0 &&
+		info->seg_not_present	== 0 &&
+		info->useable		== 0);
+}
 
 static inline void clear_LDT(void)
 {
--- sle12.orig/arch/x86/kernel/traps-xen.c	2014-11-27 16:33:02.000000000 +0100
+++ sle12/arch/x86/kernel/traps-xen.c	2015-01-30 14:54:25.000000000 +0100
@@ -375,7 +375,7 @@ exit:
  * for scheduling or signal handling. The actual stack switch is done in
  * entry.S
  */
-asmlinkage __kprobes struct pt_regs *sync_regs(struct pt_regs *eregs)
+asmlinkage notrace __kprobes struct pt_regs *sync_regs(struct pt_regs *eregs)
 {
 	struct pt_regs *regs = eregs;
 	/* Did already sync */
@@ -400,7 +400,7 @@ struct bad_iret_stack {
 	struct pt_regs regs;
 };
 
-asmlinkage __visible
+asmlinkage __visible notrace __kprobes
 struct bad_iret_stack *fixup_bad_iret(struct bad_iret_stack *s)
 {
 	/*
