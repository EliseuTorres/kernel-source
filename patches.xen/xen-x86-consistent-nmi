From: jbeulich@novell.com
Subject: make i386 and x86-64 NMI code consistent, disable all APIC-related stuff
Patch-mainline: obsolete
References: 191115

--- sle11sp2-2011-05-31.orig/arch/x86/include/asm/irq.h	2011-05-31 09:29:10.000000000 +0200
+++ sle11sp2-2011-05-31/arch/x86/include/asm/irq.h	2009-10-13 17:07:27.000000000 +0200
@@ -15,7 +15,7 @@ static inline int irq_canonicalize(int i
 	return ((irq == 2) ? 9 : irq);
 }
 
-#ifdef CONFIG_X86_LOCAL_APIC
+#if defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_XEN)
 # define ARCH_HAS_NMI_WATCHDOG
 #endif
 
--- sle11sp2-2011-05-31.orig/arch/x86/include/asm/nmi.h	2011-05-05 15:31:18.000000000 +0200
+++ sle11sp2-2011-05-31/arch/x86/include/asm/nmi.h	2011-05-06 12:02:34.000000000 +0200
@@ -5,8 +5,6 @@
 #include <asm/irq.h>
 #include <asm/io.h>
 
-#ifdef ARCH_HAS_NMI_WATCHDOG
-
 /**
  * do_nmi_callback
  *
@@ -16,6 +14,9 @@
 int do_nmi_callback(struct pt_regs *regs, int cpu);
 
 extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
+
+#ifdef ARCH_HAS_NMI_WATCHDOG
+
 extern int check_nmi_watchdog(void);
 extern int nmi_watchdog_enabled;
 extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);
@@ -29,7 +30,6 @@ extern void setup_apic_nmi_watchdog(void
 extern void stop_apic_nmi_watchdog(void *);
 extern void disable_timer_nmi_watchdog(void);
 extern void enable_timer_nmi_watchdog(void);
-extern int nmi_watchdog_tick(struct pt_regs *regs, unsigned reason);
 extern void cpu_nmi_set_wd_enabled(void);
 
 extern atomic_t nmi_active;
@@ -42,13 +42,19 @@ extern unsigned int nmi_watchdog;
 struct ctl_table;
 extern int proc_nmi_enabled(struct ctl_table *, int ,
 			void __user *, size_t *, loff_t *);
-extern int unknown_nmi_panic;
 #endif
 
-#if (defined(CONFIG_X86_LOCAL_APIC) && !defined(CONFIG_XEN)) || \
+extern int nmi_watchdog_tick(struct pt_regs *regs, unsigned reason);
+
+extern int unknown_nmi_panic;
+
+#if defined(ARCH_HAS_NMI_WATCHDOG) || \
     (defined(CONFIG_XEN_SMPBOOT) && CONFIG_XEN_COMPAT >= 0x030200)
 void arch_trigger_all_cpu_backtrace(void);
 #define arch_trigger_all_cpu_backtrace arch_trigger_all_cpu_backtrace
+#endif
+
+#ifdef ARCH_HAS_NMI_WATCHDOG
 
 static inline void localise_nmi_watchdog(void)
 {
@@ -68,7 +74,6 @@ static inline int nmi_watchdog_active(vo
 	 */
 	return nmi_watchdog & (NMI_LOCAL_APIC | NMI_IO_APIC);
 }
-#endif
 
 void lapic_watchdog_stop(void);
 int lapic_watchdog_init(unsigned nmi_hz);
@@ -76,6 +81,9 @@ int lapic_wd_event(unsigned nmi_hz);
 unsigned lapic_adjust_nmi_hz(unsigned hz);
 void disable_lapic_nmi_watchdog(void);
 void enable_lapic_nmi_watchdog(void);
+
+#endif
+
 void stop_nmi(void);
 void restart_nmi(void);
 
--- sle11sp2-2011-05-31.orig/arch/x86/kernel/apic/Makefile	2009-11-06 10:52:02.000000000 +0100
+++ sle11sp2-2011-05-31/arch/x86/kernel/apic/Makefile	2011-05-06 12:04:17.000000000 +0200
@@ -18,7 +18,7 @@ obj-$(CONFIG_X86_NUMAQ)		+= numaq_32.o
 obj-$(CONFIG_X86_ES7000)	+= es7000_32.o
 obj-$(CONFIG_X86_SUMMIT)	+= summit_32.o
 
-obj-$(CONFIG_XEN)		+= nmi.o
+obj-$(CONFIG_XEN_SMPBOOT)	+= nmi.o
 
 probe_64-$(CONFIG_XEN)		:= probe_32.o
 
--- sle11sp2-2011-05-31.orig/arch/x86/kernel/apic/nmi.c	2011-05-05 15:32:02.000000000 +0200
+++ sle11sp2-2011-05-31/arch/x86/kernel/apic/nmi.c	2011-05-06 14:29:38.000000000 +0200
@@ -31,6 +31,7 @@
 #include <asm/i8259.h>
 #else
 #include <asm/ipi.h>
+#include <asm/nmi.h>
 #endif
 #include <asm/io_apic.h>
 #include <asm/proto.h>
@@ -41,10 +42,13 @@
 #include <asm/mach_traps.h>
 
 int unknown_nmi_panic;
-int nmi_watchdog_enabled;
 
 static cpumask_t backtrace_mask __read_mostly;
 
+#ifdef ARCH_HAS_NMI_WATCHDOG
+
+int nmi_watchdog_enabled;
+
 /* nmi_active:
  * >0: the lapic NMI watchdog is active, but can be disabled
  * <0: the lapic NMI watchdog has not been set up, and cannot
@@ -178,13 +182,11 @@ int __init check_nmi_watchdog(void)
 	kfree(prev_nmi_count);
 	return 0;
 error:
-#ifndef CONFIG_XEN
 	if (nmi_watchdog == NMI_IO_APIC) {
 		if (!timer_through_8259)
 			disable_8259A_irq(0);
 		on_each_cpu(__acpi_nmi_disable, NULL, 1);
 	}
-#endif
 
 #ifdef CONFIG_X86_32
 	timer_ack = 0;
@@ -392,6 +394,8 @@ void touch_nmi_watchdog(void)
 }
 EXPORT_SYMBOL(touch_nmi_watchdog);
 
+#endif /* ARCH_HAS_NMI_WATCHDOG */
+
 notrace __kprobes int
 nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 {
@@ -412,12 +416,17 @@ nmi_watchdog_tick(struct pt_regs *regs, 
 		touched = 1;
 	}
 
+#ifdef ARCH_HAS_NMI_WATCHDOG
 	sum = get_timer_irqs(cpu);
 
 	if (__get_cpu_var(nmi_touch)) {
 		__get_cpu_var(nmi_touch) = 0;
 		touched = 1;
 	}
+#else
+	sum = 0;
+	(void)(sum + touched);
+#endif
 
 	/* We can be called before check_nmi_watchdog, hence NULL check. */
 	if (cpumask_test_cpu(cpu, &backtrace_mask)) {
@@ -433,6 +442,7 @@ nmi_watchdog_tick(struct pt_regs *regs, 
 		rc = 1;
 	}
 
+#ifdef ARCH_HAS_NMI_WATCHDOG
 	/* Could check oops_in_progress here too, but it's safer not to */
 	if (mce_in_progress())
 		touched = 1;
@@ -471,11 +481,13 @@ nmi_watchdog_tick(struct pt_regs *regs, 
 		rc = 1;
 		break;
 	}
+#endif /* ARCH_HAS_NMI_WATCHDOG */
 	return rc;
 }
 
 #ifdef CONFIG_SYSCTL
 
+#ifdef ARCH_HAS_NMI_WATCHDOG
 static void enable_ioapic_nmi_watchdog_single(void *unused)
 {
 	__get_cpu_var(wd_enabled) = 1;
@@ -493,6 +505,7 @@ static void disable_ioapic_nmi_watchdog(
 {
 	on_each_cpu(stop_apic_nmi_watchdog, NULL, 1);
 }
+#endif
 
 static int __init setup_unknown_nmi_panic(char *str)
 {
@@ -511,6 +524,7 @@ static int unknown_nmi_panic_callback(st
 	return 0;
 }
 
+#ifdef ARCH_HAS_NMI_WATCHDOG
 /*
  * proc handler for /proc/sys/kernel/nmi
  */
@@ -548,6 +562,7 @@ int proc_nmi_enabled(struct ctl_table *t
 	}
 	return 0;
 }
+#endif
 
 #endif /* CONFIG_SYSCTL */
 
--- sle11sp2-2011-05-31.orig/arch/x86/kernel/traps-xen.c	2011-02-16 13:56:25.000000000 +0100
+++ sle11sp2-2011-05-31/arch/x86/kernel/traps-xen.c	2011-05-06 12:09:14.000000000 +0200
@@ -51,6 +51,7 @@
 #include <asm/atomic.h>
 #include <asm/system.h>
 #include <asm/traps.h>
+#include <asm/nmi.h>
 #include <asm/desc.h>
 #include <asm/i387.h>
 #include <asm/mce.h>
@@ -393,7 +394,7 @@ static notrace __kprobes void default_do
 		if (notify_die(DIE_NMI_IPI, "nmi_ipi", regs, reason, 2, SIGINT)
 								== NOTIFY_STOP)
 			return;
-#ifdef CONFIG_X86_LOCAL_APIC
+#ifdef CONFIG_SMP
 		/*
 		 * Ok, so this is none of the documented NMI sources,
 		 * so it must be the NMI watchdog.
--- sle11sp2-2011-05-31.orig/kernel/sysctl.c	2011-05-31 10:34:34.000000000 +0200
+++ sle11sp2-2011-05-31/kernel/sysctl.c	2011-05-31 11:24:16.000000000 +0200
@@ -803,6 +803,7 @@ static struct ctl_table kern_table[] = {
 		.mode           = 0644,
 		.proc_handler   = &proc_dointvec,
 	},
+#ifdef ARCH_HAS_NMI_WATCHDOG
 	{
 		.procname       = "nmi_watchdog",
 		.data           = &nmi_watchdog_enabled,
@@ -811,6 +812,7 @@ static struct ctl_table kern_table[] = {
 		.proc_handler   = &proc_nmi_enabled,
 	},
 #endif
+#endif
 #if defined(CONFIG_X86)
 	{
 		.ctl_name	= KERN_PANIC_ON_NMI,
