From: Christoph Hellwig <hch@infradead.org>
Subject: xfs: cleanup data end I/O handlers
Git-commit: 5ec4fabb02fcb5b4a4154a27e4299af5aa0f87ac
References: bnc#622597
    
Patch-mainline: v2.6.33-rc1

Currently we have different end I/O handlers for read vs the different
types of write I/O.  But they are all very similar so we could just
use one with a few conditionals and reduce code size a lot.

Signed-off-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Alex Elder <aelder@sgi.com>
Signed-off-by: Alex Elder <aelder@sgi.com>
Acked-by: Jan Kara <jack@suse.cz>

Modified-by: Ben Myers <bpm@sgi.com>
Index: linux-2.6.32/fs/xfs/linux-2.6/xfs_aops.c
===================================================================
 fs/xfs/linux-2.6/xfs_aops.c |  116 +++++++++-----------------------------------
 1 file changed, 24 insertions(+), 92 deletions(-)

--- linux-2.6.32.orig/fs/xfs/linux-2.6/xfs_aops.c
+++ linux-2.6.32/fs/xfs/linux-2.6/xfs_aops.c
@@ -262,113 +262,53 @@ xfs_finish_ioend(
 }
 
 /*
- * Buffered IO write completion for delayed allocate extents.
+ * IO write completion.
  */
 STATIC void
-xfs_end_bio_delalloc(
+xfs_end_io(
 	struct work_struct	*work)
 {
 	xfs_ioend_t		*ioend =
 		container_of(work, xfs_ioend_t, io_work);
-	int			error;
-
+	struct xfs_inode	*ip = XFS_I(ioend->io_inode);
+	int			error = 0;
 	/*
-	 * If we didn't complete processing of the ioend, requeue it to the
-	 * tail of the workqueue for another attempt later. Otherwise destroy
-	 * it.
+	 * For unwritten extents we need to issue transactions to convert a
+	 * range to normal written extents after the data I/O has finished.
 	 */
-	error = xfs_setfilesize(ioend);
-	if (error == EAGAIN) {
-		atomic_inc(&ioend->io_remaining);
-		xfs_finish_ioend(ioend, 0);
-		/* ensure we don't spin on blocked ioends */
-		delay(1);
-	} else {
-		ASSERT(!error);
-		xfs_destroy_ioend(ioend);
+	if (ioend->io_type == IOMAP_UNWRITTEN &&
+	    likely(!ioend->io_error && !XFS_FORCED_SHUTDOWN(ip->i_mount))) {
+
+		error = xfs_iomap_write_unwritten(ip, ioend->io_offset,
+						 ioend->io_size);
+		if (error)
+			ioend->io_error = error;
 	}
-}
 
-/*
- * Buffered IO write completion for regular, written extents.
- */
-STATIC void
-xfs_end_bio_written(
-	struct work_struct	*work)
-{
-	xfs_ioend_t		*ioend =
-		container_of(work, xfs_ioend_t, io_work);
-	int			error;
+	/*
+	 * We might have to update the on-disk file size after extending
+	 * writes.
+	 */
+	if (ioend->io_type != IOMAP_READ) {
+		error = xfs_setfilesize(ioend);
+		ASSERT(!error || error == EAGAIN);
+	}
 
 	/*
 	 * If we didn't complete processing of the ioend, requeue it to the
 	 * tail of the workqueue for another attempt later. Otherwise destroy
 	 * it.
 	 */
-	error = xfs_setfilesize(ioend);
 	if (error == EAGAIN) {
 		atomic_inc(&ioend->io_remaining);
 		xfs_finish_ioend(ioend, 0);
 		/* ensure we don't spin on blocked ioends */
 		delay(1);
-	} else {
-		ASSERT(!error);
+	} else
 		xfs_destroy_ioend(ioend);
-	}
-}
-
-/*
- * IO write completion for unwritten extents.
- *
- * Issue transactions to convert a buffer range from unwritten
- * to written extents.
- */
-STATIC void
-xfs_end_bio_unwritten(
-	struct work_struct	*work)
-{
-	xfs_ioend_t		*ioend =
-		container_of(work, xfs_ioend_t, io_work);
-	struct xfs_inode	*ip = XFS_I(ioend->io_inode);
-	xfs_off_t		offset = ioend->io_offset;
-	size_t			size = ioend->io_size;
-
-	if (likely(!ioend->io_error)) {
-		int	error;
-		if (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {
-			error = xfs_iomap_write_unwritten(ip, offset, size);
-			if (error)
-				ioend->io_error = error;
-		}
-		/*
-		 * If we didn't complete processing of the ioend, requeue it to the
-		 * tail of the workqueue for another attempt later. Otherwise destroy
-		 * it.
-		 */
-		error = xfs_setfilesize(ioend);
-		if (error == EAGAIN) {
-			atomic_inc(&ioend->io_remaining);
-			xfs_finish_ioend(ioend, 0);
-			/* ensure we don't spin on blocked ioends */
-			delay(1);
-			return;
-		}
-	}
-	xfs_destroy_ioend(ioend);
 }
 
-/*
- * IO read completion for regular, written extents.
- */
-STATIC void
-xfs_end_bio_read(
-	struct work_struct	*work)
-{
-	xfs_ioend_t		*ioend =
-		container_of(work, xfs_ioend_t, io_work);
 
-	xfs_destroy_ioend(ioend);
-}
 
 /*
  * Allocate and initialise an IO completion structure.
@@ -401,15 +341,7 @@ xfs_alloc_ioend(
 	ioend->io_offset = 0;
 	ioend->io_size = 0;
 
-	if (type == IOMAP_UNWRITTEN)
-		INIT_WORK(&ioend->io_work, xfs_end_bio_unwritten);
-	else if (type == IOMAP_DELAY)
-		INIT_WORK(&ioend->io_work, xfs_end_bio_delalloc);
-	else if (type == IOMAP_READ)
-		INIT_WORK(&ioend->io_work, xfs_end_bio_read);
-	else
-		INIT_WORK(&ioend->io_work, xfs_end_bio_written);
-
+	INIT_WORK(&ioend->io_work, xfs_end_io);
 	return ioend;
 }
 
@@ -1571,7 +1503,7 @@ xfs_end_io_direct(
 		 * didn't map an unwritten extent so switch it's completion
 		 * handler.
 		 */
-		INIT_WORK(&ioend->io_work, xfs_end_bio_written);
+		ioend->io_type = IOMAP_NEW;
 		xfs_finish_ioend(ioend, 0);
 	}
 
