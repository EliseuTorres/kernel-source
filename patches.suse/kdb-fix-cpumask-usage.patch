From: Jiri Kosina <jkosina@suse.cz>
Subject: KDB: Fix cpumask usage
References: bnc#662360
Patch-mainline: never

The cpumask saving in kdb_cpu_callback() CPU hotplug notifier chain
function doesn't work properly for CPUMASK_OFFSTACK cases (i.e. x86_64).

Allocate cpumask properly so that it doesn't get corrupted randomly during
KDB initialization.


In addition to that, kdb() is called from the notifier even if KDB has
been turned off globally. That causes 'init' migration across CPUs, even
though the kdb() callback turns out to be nop in !kdb_on cases.

This seems to open race window though -- once init is restricted to
particular CPU (which is exactly what kdb_cpu_callback() does), any
threads spawned during the short window when kdb() is executing (the function
is disabling preemption for part of its execution time, but the window
is still there) will inherit the crippled cpus_allowed mask (think for
example about kernel threads).

Let the kdb() be called only in cases kdb has been explicitly enabled by
the administrator of the system.

That fixes the behavior for default systems, as it doesn't play games
with cpus_allowed mask of init task.

Still, more proper fix should be done to KDB in the longer term -- this might
affect other processess in situations when KDB is manually invoked any time later
after the system has been booted (but it will likely not fiddle with mask of
init task, but some other randomly picked one).

Signed-off-by: Jiri Kosina <jkosina@suse.cz>

Index: linux-2.6.32-nvidia-debug/kdb/kdbmain.c
===================================================================
--- linux-2.6.32-nvidia-debug.orig/kdb/kdbmain.c
+++ linux-2.6.32-nvidia-debug/kdb/kdbmain.c
@@ -4250,12 +4250,20 @@ static ctl_table kdb_root_table[] = {
 static int
 kdb_cpu_callback(struct notifier_block *nfb, unsigned long action, void *hcpu)
 {
-	if (action == CPU_ONLINE) {
-		int cpu =(unsigned long)hcpu;
-		cpumask_t save_cpus_allowed = current->cpus_allowed;
-		set_cpus_allowed_ptr(current, &cpumask_of_cpu(cpu));
+	if (action == CPU_ONLINE && kdb_on) {
+		int cpu = (unsigned long)hcpu;
+		int ret;
+
+		cpumask_var_t save_cpus_allowed;
+
+	        if (!zalloc_cpumask_var(&save_cpus_allowed, GFP_KERNEL))
+	                return NOTIFY_BAD;
+
+		cpumask_copy(save_cpus_allowed, &current->cpus_allowed);
+		set_cpus_allowed_ptr(current, cpumask_of(cpu));
 		kdb(KDB_REASON_CPU_UP, 0, NULL); /* do kdb setup on this cpu */
-		set_cpus_allowed_ptr(current, &save_cpus_allowed);
+		set_cpus_allowed_ptr(current, save_cpus_allowed);
+		free_cpumask_var(save_cpus_allowed);
 	}
 	return NOTIFY_OK;
 }
