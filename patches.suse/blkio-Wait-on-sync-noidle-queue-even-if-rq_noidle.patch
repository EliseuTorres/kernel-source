From: Vivek Goyal <vgoyal@redhat.com>
Date: Thu, 3 Dec 2009 12:59:56 -0500
Subject: [PATCH] blkio: Wait on sync-noidle queue even if rq_noidle = 1
X-Git: c04645e592d4dd60c58def40c913699d4c806727
References: FATE#311054
Patch-Mainline: 2.6.33

o rq_noidle() is supposed to tell cfq that do not expect a request after this
  one, hence don't idle. But this does not seem to work very well. For example
  for direct random readers, rq_noidle = 1 but there is next request coming
  after this. Not idling, leads to a group not getting its share even if
  group_isolation=1.

o The right solution for this issue is to scan the higher layers and set
  right flag (WRITE_SYNC or WRITE_ODIRECT). For the time being, this single
  line fix helps. This should not have any significant impact when we are
  not using cgroups. I will later figure out IO paths in higher layer and
  fix it.

Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
Signed-off-by: Jens Axboe <jens.axboe@oracle.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 block/cfq-iosched.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c
index ddff0f3..17da7ab 100644
--- a/block/cfq-iosched.c
+++ b/block/cfq-iosched.c
@@ -3316,7 +3316,8 @@ static void cfq_completed_request(struct request_queue *q, struct request *rq)
 			 * only if we processed at least one !rq_noidle request
 			 */
 			if (cfqd->serving_type == SYNC_WORKLOAD
-			    || cfqd->noidle_tree_requires_idle)
+			    || cfqd->noidle_tree_requires_idle
+			    || cfqq->cfqg->nr_cfqq == 1)
 				cfq_arm_slice_timer(cfqd);
 		}
 	}
-- 
1.6.0.2

