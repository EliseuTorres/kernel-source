From: Venkateswararao Jujjuri (JV) <jvrao@linux.vnet.ibm.com>
Subject: [PATCH 111/111] [net/9p] Small non-IO PDUs for zero-copy supporting transports.
Git-commit: f735195d51e10b2550097f7b0ac12219060e962b
Patch-Mainline: 2.6.39
References: FATE#311639

    If a transport prefers payload to be sent separate from the PDU
    (P9_TRANS_PREF_PAYLOAD_SEP), there is no need to allocate msize
    PDU buffers(struct p9_fcall).

    This patch allocates only upto 4k buffers for this kind of transports
    and there won't be any change to the legacy transports.

    Hence, this patch on top of zero copy changes allows user to
    specify higher msizes through the mount option
    without hogging the kernel heap.

	upstream commit f735195d51e10b2550097f7b0ac12219060e962b

    Signed-off-by: Venkateswararao Jujjuri <jvrao@linux.vnet.ibm.com>
    Signed-off-by: Eric Van Hensbergen <ericvh@gmail.com>
Signed-off-by: Harsh Prateek Bora <harsh@linux.vnet.ibm.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 include/net/9p/9p.h |    2 +-
 net/9p/client.c     |   23 +++++++++++++++++------
 2 files changed, 18 insertions(+), 7 deletions(-)

diff --git a/include/net/9p/9p.h b/include/net/9p/9p.h
index b9dc34d..3d837bf 100644
--- a/include/net/9p/9p.h
+++ b/include/net/9p/9p.h
@@ -684,7 +684,7 @@ struct p9_rwstat {
  * @id: protocol operating identifier of type &p9_msg_t
  * @tag: transaction id of the request
  * @offset: used by marshalling routines to track currentposition in buffer
- * @capacity: used by marshalling routines to track total capacity
+ * @capacity: used by marshalling routines to track total malloc'd capacity
  * @pubuf: Payload user buffer given by the caller
  * @pubuf: Payload kernel buffer given by the caller
  * @pbuf_size: pubuf/pkbuf(only one will be !NULL) size to be read/write.
diff --git a/net/9p/client.c b/net/9p/client.c
index 022e254..b38ee09 100644
--- a/net/9p/client.c
+++ b/net/9p/client.c
@@ -228,10 +228,23 @@ static struct p9_req_t *p9_tag_alloc(struct p9_client *c, u16 tag)
 			return ERR_PTR(-ENOMEM);
 		}
 		init_waitqueue_head(req->wq);
-		req->tc = kmalloc(sizeof(struct p9_fcall)+c->msize,
-								GFP_KERNEL);
-		req->rc = kmalloc(sizeof(struct p9_fcall)+c->msize,
-								GFP_KERNEL);
+		if ((c->trans_mod->pref & P9_TRANS_PREF_PAYLOAD_MASK) ==
+				P9_TRANS_PREF_PAYLOAD_SEP) {
+			int alloc_msize = min(c->msize, 4096);
+			req->tc = kmalloc(sizeof(struct p9_fcall)+alloc_msize,
+					GFP_KERNEL);
+			req->tc->capacity = alloc_msize;
+			req->rc = kmalloc(sizeof(struct p9_fcall)+alloc_msize,
+					GFP_KERNEL);
+			req->rc->capacity = alloc_msize;
+		} else {
+			req->tc = kmalloc(sizeof(struct p9_fcall)+c->msize,
+					GFP_KERNEL);
+			req->tc->capacity = c->msize;
+			req->rc = kmalloc(sizeof(struct p9_fcall)+c->msize,
+					GFP_KERNEL);
+			req->rc->capacity = c->msize;
+		}
 		if ((!req->tc) || (!req->rc)) {
 			printk(KERN_ERR "Couldn't grow tag array\n");
 			kfree(req->tc);
@@ -242,9 +255,7 @@ static struct p9_req_t *p9_tag_alloc(struct p9_client *c, u16 tag)
 			return ERR_PTR(-ENOMEM);
 		}
 		req->tc->sdata = (char *) req->tc + sizeof(struct p9_fcall);
-		req->tc->capacity = c->msize;
 		req->rc->sdata = (char *) req->rc + sizeof(struct p9_fcall);
-		req->rc->capacity = c->msize;
 	}
 
 	p9pdu_reset(req->tc);
-- 
1.7.1.1

