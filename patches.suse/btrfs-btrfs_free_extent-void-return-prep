From: Jeff Mahoney <jeffm@suse.com>
Date: Mon, 3 Oct 2011 23:23:27 -0400
Subject: btrfs: btrfs_free_extent void return prep
Patch-mainline: Submitted 24 Oct 2011

btrfs_free_extent has no error conditions, but is used via process_func
in __btrfs_mod_ref which requires it to return an int.

This patch cleans up the callers to eliminate error handling that will
never be used. The next patch makes both btrfs_free_extent and the other
function used via process_func, btrfs_inc_extent_ref, return void.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/btrfs/extent-tree.c |    5 ++---
 fs/btrfs/file.c        |    9 +++------
 fs/btrfs/inode.c       |    3 +--
 fs/btrfs/relocation.c  |    9 +++------
 4 files changed, 9 insertions(+), 17 deletions(-)

--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -5082,7 +5082,6 @@ int btrfs_free_extent(struct btrfs_trans
 		      u64 bytenr, u64 num_bytes, u64 parent, u64 root_objectid,
 		      u64 owner, u64 offset, int for_cow)
 {
-	int ret;
 	struct btrfs_fs_info *fs_info = root->fs_info;
 
 	/*
@@ -5090,6 +5089,7 @@ int btrfs_free_extent(struct btrfs_trans
 	 * tree, just update pinning info and exit early.
 	 */
 	if (root_objectid == BTRFS_TREE_LOG_OBJECTID) {
+		int ret;
 		WARN_ON(owner >= BTRFS_FIRST_FREE_OBJECTID);
 		/* unlocks the pinned mutex */
 		ret = btrfs_pin_extent(root, bytenr, num_bytes, 1);
@@ -6452,9 +6452,8 @@ skip:
 			parent = 0;
 		}
 
-		ret = btrfs_free_extent(trans, root, bytenr, blocksize, parent,
+		btrfs_free_extent(trans, root, bytenr, blocksize, parent,
 				root->root_key.objectid, level - 1, 0, 0);
-		BUG_ON(ret);
 	}
 	btrfs_tree_unlock(next);
 	free_extent_buffer(next);
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@ -743,12 +743,11 @@ next_slot:
 				extent_end = ALIGN(extent_end,
 						   root->sectorsize);
 			} else if (disk_bytenr > 0) {
-				ret = btrfs_free_extent(trans, root,
+				btrfs_free_extent(trans, root,
 						disk_bytenr, num_bytes, 0,
 						root->root_key.objectid,
 						key.objectid, key.offset -
 						extent_offset, 0);
-				BUG_ON(ret);
 				inode_sub_bytes(inode,
 						extent_end - key.offset);
 				*hint_byte = disk_bytenr;
@@ -980,10 +979,9 @@ again:
 		extent_end = other_end;
 		del_slot = path->slots[0] + 1;
 		del_nr++;
-		ret = btrfs_free_extent(trans, root, bytenr, num_bytes,
+		btrfs_free_extent(trans, root, bytenr, num_bytes,
 					0, root->root_key.objectid,
 					ino, orig_offset, 0);
-		BUG_ON(ret);
 	}
 	other_start = 0;
 	other_end = start;
@@ -997,10 +995,9 @@ again:
 		key.offset = other_start;
 		del_slot = path->slots[0];
 		del_nr++;
-		ret = btrfs_free_extent(trans, root, bytenr, num_bytes,
+		btrfs_free_extent(trans, root, bytenr, num_bytes,
 					0, root->root_key.objectid,
 					ino, orig_offset, 0);
-		BUG_ON(ret);
 	}
 	if (del_nr == 0) {
 		fi = btrfs_item_ptr(leaf, path->slots[0],
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -3132,11 +3132,10 @@ static int btrfs_release_and_test_data_e
 		orig_nbytes = btrfs_file_extent_disk_num_bytes(leaf, fi);
 		extent_offset = offset - btrfs_file_extent_offset(leaf, fi);
 		btrfs_set_path_blocking(path);
-		ret = btrfs_free_extent(trans, root, extent_start,
+		btrfs_free_extent(trans, root, extent_start,
 					orig_nbytes, 0,
 					btrfs_header_owner(leaf),
 					ino, extent_offset, 0);
-		BUG_ON(ret);
 		btrfs_clear_path_blocking(path, NULL, 0);
 
 		ret = 1;
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -1632,10 +1632,9 @@ int replace_file_extents(struct btrfs_tr
 					   btrfs_header_owner(leaf),
 					   key.objectid, key.offset, 1);
 
-		ret = btrfs_free_extent(trans, root, bytenr, num_bytes,
+		btrfs_free_extent(trans, root, bytenr, num_bytes,
 					parent, btrfs_header_owner(leaf),
 					key.objectid, key.offset, 1);
-		BUG_ON(ret);
 	}
 	if (dirty)
 		btrfs_mark_buffer_dirty(leaf);
@@ -1809,16 +1808,14 @@ again:
 					0, dest->root_key.objectid, level - 1,
 					0, 1);
 
-		ret = btrfs_free_extent(trans, src, new_bytenr, blocksize,
+		btrfs_free_extent(trans, src, new_bytenr, blocksize,
 					path->nodes[level]->start,
 					src->root_key.objectid, level - 1, 0,
 					1);
-		BUG_ON(ret);
 
-		ret = btrfs_free_extent(trans, dest, old_bytenr, blocksize,
+		btrfs_free_extent(trans, dest, old_bytenr, blocksize,
 					0, dest->root_key.objectid, level - 1,
 					0, 1);
-		BUG_ON(ret);
 
 		btrfs_unlock_up_safe(path, 0);
 
