From: Mel Gorman <mgorman@suse.de>
Date: Wed, 7 Mar 2012 10:15:44 +0000
Subject: [PATCH] mm: Ensure that GFP_NOFS direct reclaimers do not block

References: Swap over NFS (fate#304949, bnc#747944)
Patch-mainline: no

If a process is starting a transaction and gets throttled in direct
reclaim, it is possible that kswapd cannot make any forward progress if
it tries to writeback a page and they effectively deadlock.

This patch puts __GFP_NOFS into interruptible sleep with a timeout
instead of a killable sleep with no timeout.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/vmscan.c |   23 +++++++++++++++++++----
 1 file changed, 19 insertions(+), 4 deletions(-)

diff --git a/mm/vmscan.c b/mm/vmscan.c
index 9d91108..a7c0f91 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -2362,7 +2362,7 @@ static void throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,
 {
 	struct zone *zone;
 	int high_zoneidx = gfp_zone(gfp_mask);
-	DEFINE_WAIT(wait);
+	pg_data_t *pgdat;
 
 	/* Kernel threads such as kjournald should never stall */
 	if (current->flags & PF_KTHREAD)
@@ -2370,12 +2370,27 @@ static void throttle_direct_reclaim(gfp_t gfp_mask, struct zonelist *zonelist,
 
 	/* Check if the pfmemalloc reserves are ok */
 	first_zones_zonelist(zonelist, high_zoneidx, NULL, &zone);
-	if (pfmemalloc_watermark_ok(zone->zone_pgdat, high_zoneidx))
+	pgdat = zone->zone_pgdat;
+
+	if (pfmemalloc_watermark_ok(pgdat, high_zoneidx))
 		return;
 
-	/* Throttle */
+	/*
+	 * If the caller cannot enter the filesystem, it's possible that it
+	 * is processing a journal transaction. In this case, it is not safe
+	 * to block on pfmemalloc_wait as kswapd could also be blocked waiting
+	 * to start a transaction. Instead, throttle for up to a second before
+	 * the reclaim must continue.
+	 */
+	if (!(gfp_mask & __GFP_FS)) {
+		wait_event_interruptible_timeout(pgdat->pfmemalloc_wait,
+			pfmemalloc_watermark_ok(pgdat, high_zoneidx), HZ);
+		return;
+	}
+
+	/* Throttle until kswapd wakes the process */
 	wait_event_killable(zone->zone_pgdat->pfmemalloc_wait,
-		pfmemalloc_watermark_ok(zone->zone_pgdat, high_zoneidx));
+		pfmemalloc_watermark_ok(pgdat, high_zoneidx));
 }
 
 unsigned long try_to_free_pages(struct zonelist *zonelist, int order,
