From 4e54dede38b45052a941bcf709f7d29f2e18174d Mon Sep 17 00:00:00 2001
From: Michal Hocko <mhocko@suse.cz>
Date: Fri, 27 Feb 2015 15:51:46 -0800
Subject: [PATCH] memcg: fix low limit calculation
Git-commit: 4e54dede38b45052a941bcf709f7d29f2e18174d
Patch-mainline: 4.0-rc2
References: fate#312101

mhocko@suse.cz:
we do not have 241994ed8649 which has introduced that but
patches.suse/memcg-introduce-low-limit.patch which introduces the limit
suffers from the same issue.

A memcg is considered low limited even when the current usage is equal to
the low limit.  This leads to interesting side effects e.g.
groups/hierarchies with no memory accounted are considered protected and
so the reclaim will emit MEMCG_LOW event when encountering them.

Another and much bigger issue was reported by Joonsoo Kim.  He has hit a
NULL ptr dereference with the legacy cgroup API which even doesn't have
low limit exposed.  The limit is 0 by default but the initial check fails
for memcg with 0 consumption and parent_mem_cgroup() would return NULL if
use_hierarchy is 0 and so page_counter_read would try to dereference NULL.

I suppose that the current implementation is just an overlook because the
documentation in Documentation/cgroups/unified-hierarchy.txt says:

  "The memory.low boundary on the other hand is a top-down allocated
  reserve.  A cgroup enjoys reclaim protection when it and all its
  ancestors are below their low boundaries"

Fix the usage and the low limit comparision in mem_cgroup_low accordingly.

Fixes: 241994ed8649 (mm: memcontrol: default hierarchy interface for memory)
Reported-by: Joonsoo Kim <js1304@gmail.com>
Signed-off-by: Michal Hocko <mhocko@suse.cz>
Acked-by: Johannes Weiner <hannes@cmpxchg.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

---
 mm/memcontrol.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -6207,7 +6207,7 @@ bool mem_cgroup_low(struct mem_cgroup *r
 	if (memcg == root_mem_cgroup)
 		return false;
 
-	if (page_counter_read(&memcg->memory) > memcg->low_limit)
+	if (page_counter_read(&memcg->memory) >= memcg->low_limit)
 		return false;
 
 	while (memcg != root) {
@@ -6216,7 +6216,7 @@ bool mem_cgroup_low(struct mem_cgroup *r
 		if (memcg == root_mem_cgroup)
 			break;
 
-		if (page_counter_read(&memcg->memory) > memcg->low_limit)
+		if (page_counter_read(&memcg->memory) >= memcg->low_limit)
 			return false;
 	}
 	return true;
