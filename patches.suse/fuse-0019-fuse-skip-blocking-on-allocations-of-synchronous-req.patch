From: Maxim Patlasov <mpatlasov@parallels.com>
Date: Thu, 21 Mar 2013 18:02:28 +0400
Subject: fuse: skip blocking on allocations of synchronous requests
Git-commit: 0aada88476a33690c9569b094191ce92a38e6541
Patch-mainline: v3.10-rc1
References: FATE#317677

A task may have at most one synchronous request allocated. So these
requests need not be otherwise limited.

The patch re-works fuse_get_req() to follow this idea.

Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
---
 fs/fuse/cuse.c  |    1 -
 fs/fuse/dev.c   |   30 ++++++++++++++++++++----------
 fs/fuse/inode.c |    3 +--
 3 files changed, 21 insertions(+), 13 deletions(-)

--- a/fs/fuse/cuse.c
+++ b/fs/fuse/cuse.c
@@ -495,7 +495,6 @@ static int cuse_channel_open(struct inod
 	cc->fc.release = cuse_fc_release;
 
 	cc->fc.connected = 1;
-	cc->fc.blocked = 0;
 	cc->fc.initialized = 1;
 	rc = cuse_send_init(cc);
 	if (rc) {
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -130,21 +130,30 @@ static void fuse_req_init_context(struct
 	req->in.h.pid = current->pid;
 }
 
+static bool fuse_block_alloc(struct fuse_conn *fc, bool for_background)
+{
+	return !fc->initialized || (for_background && fc->blocked);
+}
+
 static struct fuse_req *__fuse_get_req(struct fuse_conn *fc, unsigned npages,
 				       bool for_background)
 {
 	struct fuse_req *req;
-	sigset_t oldset;
-	int intr;
 	int err;
-
 	atomic_inc(&fc->num_waiting);
-	block_sigs(&oldset);
-	intr = wait_event_interruptible(fc->blocked_waitq, !fc->blocked);
-	restore_sigs(&oldset);
-	err = -EINTR;
-	if (intr)
-		goto out;
+
+	if (fuse_block_alloc(fc, for_background)) {
+		sigset_t oldset;
+		int intr;
+
+		block_sigs(&oldset);
+		intr = wait_event_interruptible(fc->blocked_waitq,
+				!fuse_block_alloc(fc, for_background));
+		restore_sigs(&oldset);
+		err = -EINTR;
+		if (intr)
+			goto out;
+	}
 
 	err = -ENOTCONN;
 	if (!fc->connected)
@@ -240,7 +249,7 @@ struct fuse_req *fuse_get_req_nofail_nop
 	struct fuse_req *req;
 
 	atomic_inc(&fc->num_waiting);
-	wait_event(fc->blocked_waitq, !fc->blocked);
+	wait_event(fc->blocked_waitq, fc->initialized);
 	req = fuse_request_alloc(0);
 	if (!req)
 		req = get_reserved_req(fc, file);
@@ -2031,6 +2040,7 @@ int fuse_dev_release(struct inode *inode
 		spin_lock(&fc->lock);
 		fc->connected = 0;
 		fc->blocked = 0;
+		fc->initialized = 1;
 		end_queued_requests(fc);
 		end_polls(fc);
 		wake_up_all(&fc->blocked_waitq);
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -556,7 +556,7 @@ void fuse_conn_init(struct fuse_conn *fc
 	fc->khctr = 0;
 	fc->polled_files = RB_ROOT;
 	fc->reqctr = 0;
-	fc->blocked = 1;
+	fc->blocked = 0;
 	fc->initialized = 0;
 	fc->attr_version = 1;
 	get_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));
@@ -849,7 +849,6 @@ static void process_init_reply(struct fu
 		fc->max_write = max_t(unsigned, 4096, fc->max_write);
 		fc->conn_init = 1;
 	}
-	fc->blocked = 0;
 	fc->initialized = 1;
 	wake_up_all(&fc->blocked_waitq);
 }
