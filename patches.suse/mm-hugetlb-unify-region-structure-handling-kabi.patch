From eedb85c26546375d90ee2943719d1fa8a98d74c4 Mon Sep 17 00:00:00 2001
From: Mel Gorman <mgorman@suse.de>
Date: Wed, 16 Jul 2014 16:50:22 +0100
Subject: [PATCH] mm, hugetlb: unify region structure handling kabi

References: Hugetlb Fault Scalability (fate#317271)
Patch-mainline: No, never due to KABI

mm, hugetlb: unify region structure handling uses an old field name in
the address_space. It's an opaque type so it should be safe to cast and
preserve KABI.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 fs/hugetlbfs/inode.c | 4 ++--
 mm/hugetlb.c         | 8 ++++----
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c
index 0b2e185..b915011 100644
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@ -369,7 +369,7 @@ static void hugetlbfs_evict_inode(struct inode *inode)
 	struct resv_map *resv_map;
 
 	truncate_hugepages(inode, 0);
-	resv_map = (struct resv_map *)inode->i_mapping->private_data;
+	resv_map = (struct resv_map *)inode->i_mapping->assoc_mapping;
 	/* root inode doesn't have the resv_map, so we should check it */
 	if (resv_map)
 		resv_map_release(&resv_map->refs);
@@ -466,7 +466,7 @@ static struct inode *hugetlbfs_get_inode(struct super_block *sb, uid_t uid,
 		inode->i_mapping->a_ops = &hugetlbfs_aops;
 		inode->i_mapping->backing_dev_info =&hugetlbfs_backing_dev_info;
 		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
-		inode->i_mapping->private_data = resv_map;
+		inode->i_mapping->assoc_mapping = (struct address_space *)resv_map;
 		info = HUGETLBFS_I(inode);
 		/*
 		 * The policy is initialized here even if we are creating a
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index 87e8805..5f5a9bb 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -1094,7 +1094,7 @@ static long vma_needs_reservation(struct hstate *h,
 
 	if (vma->vm_flags & VM_MAYSHARE) {
 		pgoff_t idx = vma_hugecache_offset(h, vma, addr);
-		struct resv_map *resv = inode->i_mapping->private_data;
+		struct resv_map *resv = (struct resv_map *)inode->i_mapping->assoc_mapping;
 
 		return region_chg(&resv->regions, idx, idx + 1);
 
@@ -1120,7 +1120,7 @@ static void vma_commit_reservation(struct hstate *h,
 
 	if (vma->vm_flags & VM_MAYSHARE) {
 		pgoff_t idx = vma_hugecache_offset(h, vma, addr);
-		struct resv_map *resv = inode->i_mapping->private_data;
+		struct resv_map *resv = (struct resv_map *)inode->i_mapping->assoc_mapping;
 
 		region_add(&resv->regions, idx, idx + 1);
 
@@ -3055,7 +3055,7 @@ int hugetlb_reserve_pages(struct inode *inode,
 	 * called to make the mapping read-write. Assume !vma is a shm mapping
 	 */
 	if (!vma || vma->vm_flags & VM_MAYSHARE) {
-		resv_map = inode->i_mapping->private_data;
+		resv_map = (struct resv_map *)inode->i_mapping->assoc_mapping;
 
 		chg = region_chg(&resv_map->regions, from, to);
 
@@ -3114,7 +3114,7 @@ out_err:
 void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)
 {
 	struct hstate *h = hstate_inode(inode);
-	struct resv_map *resv_map = inode->i_mapping->private_data;
+	struct resv_map *resv_map = (struct resv_map *)inode->i_mapping->assoc_mapping;
 	long chg = 0;
 	struct hugepage_subpool *spool = subpool_inode(inode);
 
