From 48c715a202e774bb39d7d2b76cc90acfb666eb92 Mon Sep 17 00:00:00 2001
From: Waiman Long <Waiman.Long@hp.com>
Date: Wed, 14 May 2014 15:48:01 -0400
Subject: [PATCH 17/17] vfs: make sure we don't have a stale root path if unlazy_walk() fails
References: FATE#317271
Git-commit: d0d272771035a36a7839bb70ab6ebae3f4f4960b
Patch-mainline: v3.12-rc1

When I moved the RCU walk termination into unlazy_walk(), I didn't copy
quite all of it: for the successful RCU termination we properly add the
necessary reference counts to our temporary copy of the root path, but
for the failure case we need to make sure that any temporary root path
information is cleared out (since it does _not_ have the proper
reference counts from the RCU lookup).

We could clean up this mess by just always dropping the temporary root
information, but Al points out that that would mean that a single lookup
through symlinks could see multiple different root entries if it races
with another thread doing chroot.  Not that I think we should really
care (we had that before too, back before we had a copy of the root path
in the nameidata).

Al says he has a cunning plan.  In the meantime, this is the minimal fix
for the problem, even if it's not all that pretty.

This patch is a backport of the upstream commit:

  d0d272771035a36a7839bb70ab6ebae3f4f4960b

Reported-by: Mace Moneta <moneta.mace@gmail.com>
Acked-by: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/namei.c |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/fs/namei.c b/fs/namei.c
index c27392d..68bf9d8 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -491,9 +491,12 @@ unlock_and_drop_dentry:
 drop_dentry:
 	rcu_read_unlock();
 	dput(dentry);
-	return -ECHILD;
+	goto drop_root_mnt;
 out:
 	rcu_read_unlock();
+drop_root_mnt:
+	if (!(nd->flags & LOOKUP_ROOT))
+		nd->root.mnt = NULL;
 	return -ECHILD;
 }
 
-- 
1.7.1

