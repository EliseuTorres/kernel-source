From: Maxim Patlasov <mpatlasov@parallels.com>
Date: Thu, 21 Mar 2013 18:02:15 +0400
Subject: fuse: add flag fc->initialized
Git-commit: 796523fb24028639c007f71e02ca21730f7c0af6
Patch-mainline: v3.10-rc1
References: FATE#317677

Existing flag fc->blocked is used to suspend request allocation both in case
of many background request submitted and period of time before init_reply
arrives from userspace. Next patch will skip blocking allocations of
synchronous request (disregarding fc->blocked). This is mostly OK, but
we still need to suspend allocations if init_reply is not arrived yet. The
patch introduces flag fc->initialized which will serve this purpose.

Signed-off-by: Maxim Patlasov <mpatlasov@parallels.com>
Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
---
 fs/fuse/cuse.c   |    1 +
 fs/fuse/dev.c    |    1 +
 fs/fuse/fuse_i.h |    4 ++++
 fs/fuse/inode.c  |    3 +++
 4 files changed, 9 insertions(+)

--- a/fs/fuse/cuse.c
+++ b/fs/fuse/cuse.c
@@ -496,6 +496,7 @@ static int cuse_channel_open(struct inod
 
 	cc->fc.connected = 1;
 	cc->fc.blocked = 0;
+	cc->fc.initialized = 1;
 	rc = cuse_send_init(cc);
 	if (rc) {
 		fuse_conn_put(&cc->fc);
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -2012,6 +2012,7 @@ void fuse_abort_conn(struct fuse_conn *f
 	if (fc->connected) {
 		fc->connected = 0;
 		fc->blocked = 0;
+		fc->initialized = 1;
 		end_io_requests(fc);
 		end_queued_requests(fc);
 		end_polls(fc);
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@ -405,6 +405,10 @@ struct fuse_conn {
 	/** Batching of FORGET requests (positive indicates FORGET batch) */
 	int forget_batch;
 
+	/** Flag indicating that INIT reply has been received. Allocating
+	 * any fuse request will be suspended until the flag is set */
+	int initialized;
+
 	/** Flag indicating if connection is blocked.  This will be
 	    the case before the INIT reply is received, and if there
 	    are too many outstading backgrounds requests */
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -342,6 +342,7 @@ void fuse_conn_kill(struct fuse_conn *fc
 	spin_lock(&fc->lock);
 	fc->connected = 0;
 	fc->blocked = 0;
+	fc->initialized = 1;
 	spin_unlock(&fc->lock);
 	/* Flush all readers on this fs */
 	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
@@ -556,6 +557,7 @@ void fuse_conn_init(struct fuse_conn *fc
 	fc->polled_files = RB_ROOT;
 	fc->reqctr = 0;
 	fc->blocked = 1;
+	fc->initialized = 0;
 	fc->attr_version = 1;
 	get_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));
 }
@@ -848,6 +850,7 @@ static void process_init_reply(struct fu
 		fc->conn_init = 1;
 	}
 	fc->blocked = 0;
+	fc->initialized = 1;
 	wake_up_all(&fc->blocked_waitq);
 }
 
