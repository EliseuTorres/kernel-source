Git-commit: 310975573ba40ab526b0d76d28225d8d0999d72b
From: Joe Thornber <ejt@redhat.com>
Date: Fri, 27 Jul 2012 15:08:15 +0100
Subject: [PATCH] dm persistent data: introduce dm_bm_set_read_only
Patch-mainline: v3.6-rc1
Reference: FATE#313903

Introduce dm_bm_set_read_only to switch the block manager into a
read-only mode.  To be used when dm-thin degrades due to io errors on
the metadata device.

Signed-off-by: Joe Thornber <ejt@redhat.com>
Signed-off-by: Mike Snitzer <snitzer@redhat.com>
Signed-off-by: Alasdair G Kergon <agk@redhat.com>
Acked-by: NeilBrown <nfbrown@suse.com>

---
 drivers/md/persistent-data/dm-block-manager.c |   18 ++++++++++++++++++
 drivers/md/persistent-data/dm-block-manager.h |   13 +++++++++++++
 2 files changed, 31 insertions(+)

--- linux-3.0-SLE11-SP3.orig/drivers/md/persistent-data/dm-block-manager.c
+++ linux-3.0-SLE11-SP3/drivers/md/persistent-data/dm-block-manager.c
@@ -364,6 +364,7 @@ static void dm_block_manager_write_callb
  *--------------------------------------------------------------*/
 struct dm_block_manager {
 	struct dm_bufio_client *bufio;
+	bool read_only:1;
 };
 
 struct dm_block_manager *dm_block_manager_create(struct block_device *bdev,
@@ -390,6 +391,8 @@ struct dm_block_manager *dm_block_manage
 		goto bad;
 	}
 
+	bm->read_only = false;
+
 	return bm;
 
 bad:
@@ -481,6 +484,9 @@ int dm_bm_write_lock(struct dm_block_man
 	void *p;
 	int r;
 
+	if (bm->read_only)
+		return -EPERM;
+
 	p = dm_bufio_read(bm->bufio, b, (struct dm_buffer **) result);
 	if (unlikely(IS_ERR(p)))
 		return PTR_ERR(p);
@@ -547,6 +553,9 @@ int dm_bm_write_lock_zero(struct dm_bloc
 	struct buffer_aux *aux;
 	void *p;
 
+	if (bm->read_only)
+		return -EPERM;
+
 	p = dm_bufio_new(bm->bufio, b, (struct dm_buffer **) result);
 	if (unlikely(IS_ERR(p)))
 		return PTR_ERR(p);
@@ -589,6 +598,9 @@ int dm_bm_flush_and_unlock(struct dm_blo
 {
 	int r;
 
+	if (bm->read_only)
+		return -EPERM;
+
 	r = dm_bufio_write_dirty_buffers(bm->bufio);
 	if (unlikely(r)) {
 		dm_bm_unlock(superblock);
@@ -600,6 +612,12 @@ int dm_bm_flush_and_unlock(struct dm_blo
 	return dm_bufio_write_dirty_buffers(bm->bufio);
 }
 
+void dm_bm_set_read_only(struct dm_block_manager *bm)
+{
+	bm->read_only = true;
+}
+EXPORT_SYMBOL_GPL(dm_bm_set_read_only);
+
 u32 dm_bm_checksum(const void *data, size_t len, u32 init_xor)
 {
 	return crc32c(~(u32) 0, data, len) ^ init_xor;
--- linux-3.0-SLE11-SP3.orig/drivers/md/persistent-data/dm-block-manager.h
+++ linux-3.0-SLE11-SP3/drivers/md/persistent-data/dm-block-manager.h
@@ -108,6 +108,19 @@ int dm_bm_unlock(struct dm_block *b);
 int dm_bm_flush_and_unlock(struct dm_block_manager *bm,
 			   struct dm_block *superblock);
 
+/*
+ * Switches the bm to a read only mode.  Once read-only mode
+ * has been entered the following functions will return -EPERM.
+ *
+ *   dm_bm_write_lock
+ *   dm_bm_write_lock_zero
+ *   dm_bm_flush_and_unlock
+ *
+ * Additionally you should not use dm_bm_unlock_move, however no error will
+ * be returned if you do.
+ */
+void dm_bm_set_read_only(struct dm_block_manager *bm);
+
 u32 dm_bm_checksum(const void *data, size_t len, u32 init_xor);
 
 /*----------------------------------------------------------------*/
