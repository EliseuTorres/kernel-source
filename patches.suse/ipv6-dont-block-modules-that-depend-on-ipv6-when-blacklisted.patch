From: Jiri Bohac <jbohac@suse.cz>
Subject: allow bonding with blacklisted ipv6
References: bnc#585463
Patch-mainline: no


---
 include/net/ipv6.h              |    3 ++
 net/ipv6/Makefile               |   20 +++++++--------
 net/ipv6/addrconf.c             |    4 +--
 net/ipv6/addrlabel.c            |    4 +--
 net/ipv6/af_inet6.c             |   32 +++++++++++++-----------
 net/ipv6/ah6.c                  |    2 -
 net/ipv6/esp6.c                 |    2 -
 net/ipv6/exthdrs.c              |    2 -
 net/ipv6/fib6_rules.c           |    2 -
 net/ipv6/icmp.c                 |    2 -
 net/ipv6/ip6_fib.c              |    2 -
 net/ipv6/ip6_output.c           |    2 -
 net/ipv6/ip6_tunnel.c           |    2 -
 net/ipv6/ip6mr.c                |    2 -
 net/ipv6/ipcomp6.c              |    2 -
 net/ipv6/ipv6.c                 |   53 ++++++++++++++++++++++++++++++++++++++++
 net/ipv6/mcast.c                |    2 -
 net/ipv6/mip6.c                 |    2 -
 net/ipv6/ndisc.c                |    2 -
 net/ipv6/netfilter.c            |    2 -
 net/ipv6/proc.c                 |    2 -
 net/ipv6/raw.c                  |    4 +--
 net/ipv6/reassembly.c           |    2 -
 net/ipv6/route.c                |    2 -
 net/ipv6/sit.c                  |    2 -
 net/ipv6/tcp_ipv6.c             |    2 -
 net/ipv6/tunnel6.c              |    2 -
 net/ipv6/udp.c                  |    2 -
 net/ipv6/udplite.c              |    4 +--
 net/ipv6/xfrm6_mode_beet.c      |    2 -
 net/ipv6/xfrm6_mode_ro.c        |    2 -
 net/ipv6/xfrm6_mode_transport.c |    2 -
 net/ipv6/xfrm6_mode_tunnel.c    |    2 -
 net/ipv6/xfrm6_policy.c         |    4 +--
 net/ipv6/xfrm6_state.c          |    2 -
 net/ipv6/xfrm6_tunnel.c         |    2 -
 36 files changed, 121 insertions(+), 61 deletions(-)

--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -660,4 +660,7 @@ extern int ipv6_static_sysctl_register(v
 extern void ipv6_static_sysctl_unregister(void);
 #endif
 
+extern struct ipv6_params ipv6_defaults;
+extern int disable_ipv6_mod;
+
 #endif /* _NET_IPV6_H */
--- a/net/ipv6/Makefile
+++ b/net/ipv6/Makefile
@@ -2,25 +2,25 @@
 # Makefile for the Linux TCP/IP (INET6) layer.
 #
 
-obj-$(CONFIG_IPV6) += ipv6.o
+obj-$(CONFIG_IPV6) += ipv6_lib.o ipv6.o
 
-ipv6-objs :=	af_inet6.o anycast.o ip6_output.o ip6_input.o addrconf.o \
+ipv6_lib-objs := af_inet6.o anycast.o ip6_output.o ip6_input.o addrconf.o \
 		addrlabel.o \
 		route.o ip6_fib.o ipv6_sockglue.o ndisc.o udp.o udplite.o \
 		raw.o protocol.o icmp.o mcast.o reassembly.o tcp_ipv6.o \
 		exthdrs.o datagram.o ip6_flowlabel.o inet6_connection_sock.o
 
-ipv6-$(CONFIG_SYSCTL) = sysctl_net_ipv6.o
-ipv6-$(CONFIG_IPV6_MROUTE) += ip6mr.o
+ipv6_lib-$(CONFIG_SYSCTL) = sysctl_net_ipv6.o
+ipv6_lib-$(CONFIG_IPV6_MROUTE) += ip6mr.o
 
-ipv6-$(CONFIG_XFRM) += xfrm6_policy.o xfrm6_state.o xfrm6_input.o \
+ipv6_lib-$(CONFIG_XFRM) += xfrm6_policy.o xfrm6_state.o xfrm6_input.o \
 	xfrm6_output.o
-ipv6-$(CONFIG_NETFILTER) += netfilter.o
-ipv6-$(CONFIG_IPV6_MULTIPLE_TABLES) += fib6_rules.o
-ipv6-$(CONFIG_PROC_FS) += proc.o
-ipv6-$(CONFIG_SYN_COOKIES) += syncookies.o
+ipv6_lib-$(CONFIG_NETFILTER) += netfilter.o
+ipv6_lib-$(CONFIG_IPV6_MULTIPLE_TABLES) += fib6_rules.o
+ipv6_lib-$(CONFIG_PROC_FS) += proc.o
+ipv6_lib-$(CONFIG_SYN_COOKIES) += syncookies.o
 
-ipv6-objs += $(ipv6-y)
+ipv6_lib-objs += $(ipv6-y)
 
 obj-$(CONFIG_INET6_AH) += ah6.o
 obj-$(CONFIG_INET6_ESP) += esp6.o
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -3096,7 +3096,7 @@ static struct pernet_operations if6_proc
        .exit = if6_proc_net_exit,
 };
 
-int __init if6_proc_init(void)
+int  if6_proc_init(void)
 {
 	return register_pernet_subsys(&if6_proc_net_ops);
 }
@@ -4641,7 +4641,7 @@ static struct rtnl_af_ops inet6_ops = {
  *	Init / cleanup code
  */
 
-int __init addrconf_init(void)
+int  addrconf_init(void)
 {
 	int i, err;
 
--- a/net/ipv6/addrlabel.c
+++ b/net/ipv6/addrlabel.c
@@ -386,7 +386,7 @@ static struct pernet_operations ipv6_add
 	.exit = ip6addrlbl_net_exit,
 };
 
-int __init ipv6_addr_label_init(void)
+int  ipv6_addr_label_init(void)
 {
 	spin_lock_init(&ip6addrlbl_table.lock);
 
@@ -590,7 +590,7 @@ out:
 	return err;
 }
 
-void __init ipv6_addr_label_rtnl_register(void)
+void  ipv6_addr_label_rtnl_register(void)
 {
 	__rtnl_register(PF_INET6, RTM_NEWADDRLABEL, ip6addrlbl_newdel,
 			NULL, NULL);
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -77,17 +77,10 @@ struct ipv6_params ipv6_defaults = {
 	.disable_ipv6 = 0,
 	.autoconf = 1,
 };
+EXPORT_SYMBOL(ipv6_defaults);
 
-static int disable_ipv6_mod = 0;
-
-module_param_named(disable, disable_ipv6_mod, int, 0444);
-MODULE_PARM_DESC(disable, "Disable IPv6 module such that it is non-functional");
-
-module_param_named(disable_ipv6, ipv6_defaults.disable_ipv6, int, 0444);
-MODULE_PARM_DESC(disable_ipv6, "Disable IPv6 on all interfaces");
-
-module_param_named(autoconf, ipv6_defaults.autoconf, int, 0444);
-MODULE_PARM_DESC(autoconf, "Enable IPv6 address autoconfiguration on all interfaces");
+int disable_ipv6_mod = 0;
+EXPORT_SYMBOL(disable_ipv6_mod);
 
 static __inline__ struct ipv6_pinfo *inet6_sk_generic(struct sock *sk)
 {
@@ -955,7 +948,7 @@ static struct packet_type ipv6_packet_ty
 	.gro_complete = ipv6_gro_complete,
 };
 
-static int __init ipv6_packet_init(void)
+static int  ipv6_packet_init(void)
 {
 	dev_add_pack(&ipv6_packet_type);
 	return 0;
@@ -1059,7 +1052,7 @@ static struct pernet_operations inet6_ne
 	.exit = inet6_net_exit,
 };
 
-static int __init inet6_init(void)
+static int  inet6_init(void)
 {
 	struct sk_buff *dummy_skb;
 	struct list_head *r;
@@ -1071,6 +1064,13 @@ static int __init inet6_init(void)
 	for(r = &inetsw6[0]; r < &inetsw6[SOCK_MAX]; ++r)
 		INIT_LIST_HEAD(r);
 
+	return err;
+}
+
+int inet6_init_real(void)
+{
+	int err = 0;
+
 	if (disable_ipv6_mod) {
 		printk(KERN_INFO
 		       "IPv6: Loaded, but administratively disabled, "
@@ -1259,9 +1259,14 @@ out_unregister_tcp_proto:
 	goto out;
 }
 module_init(inet6_init);
+EXPORT_SYMBOL(inet6_init_real);
 
 static void __exit inet6_exit(void)
 {
+}
+
+void inet6_exit_real(void)
+{
 	if (disable_ipv6_mod)
 		return;
 
@@ -1311,5 +1316,4 @@ static void __exit inet6_exit(void)
 	rcu_barrier(); /* Wait for completion of call_rcu()'s */
 }
 module_exit(inet6_exit);
-
-MODULE_ALIAS_NETPROTO(PF_INET6);
+EXPORT_SYMBOL(inet6_exit_real);
--- a/net/ipv6/ah6.c
+++ b/net/ipv6/ah6.c
@@ -728,7 +728,7 @@ static const struct inet6_protocol ah6_p
 	.flags		=	INET6_PROTO_NOPOLICY,
 };
 
-static int __init ah6_init(void)
+static int  ah6_init(void)
 {
 	if (xfrm_register_type(&ah6_type, AF_INET6) < 0) {
 		printk(KERN_INFO "ipv6 ah init: can't add xfrm type\n");
--- a/net/ipv6/esp6.c
+++ b/net/ipv6/esp6.c
@@ -648,7 +648,7 @@ static const struct inet6_protocol esp6_
 	.flags		=	INET6_PROTO_NOPOLICY,
 };
 
-static int __init esp6_init(void)
+static int  esp6_init(void)
 {
 	if (xfrm_register_type(&esp6_type, AF_INET6) < 0) {
 		printk(KERN_INFO "ipv6 esp init: can't add xfrm type\n");
--- a/net/ipv6/exthdrs.c
+++ b/net/ipv6/exthdrs.c
@@ -514,7 +514,7 @@ static const struct inet6_protocol nodat
 	.flags		=	INET6_PROTO_NOPOLICY,
 };
 
-int __init ipv6_exthdrs_init(void)
+int  ipv6_exthdrs_init(void)
 {
 	int ret;
 
--- a/net/ipv6/fib6_rules.c
+++ b/net/ipv6/fib6_rules.c
@@ -295,7 +295,7 @@ static struct pernet_operations fib6_rul
 	.exit = fib6_rules_net_exit,
 };
 
-int __init fib6_rules_init(void)
+int  fib6_rules_init(void)
 {
 	return register_pernet_subsys(&fib6_rules_net_ops);
 }
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@ -867,7 +867,7 @@ static struct pernet_operations icmpv6_s
        .exit = icmpv6_sk_exit,
 };
 
-int __init icmpv6_init(void)
+int  icmpv6_init(void)
 {
 	int err;
 
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -1571,7 +1571,7 @@ static struct pernet_operations fib6_net
 	.exit = fib6_net_exit,
 };
 
-int __init fib6_init(void)
+int  fib6_init(void)
 {
 	int ret = -ENOMEM;
 
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -600,7 +600,7 @@ static u32 hashidentrnd __read_mostly;
 #define FID_HASH_SZ 16
 static u32 ipv6_fragmentation_id[FID_HASH_SZ];
 
-void __init initialize_hashidentrnd(void)
+void  initialize_hashidentrnd(void)
 {
 	get_random_bytes(&hashidentrnd, sizeof(hashidentrnd));
 }
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -1527,7 +1527,7 @@ static struct pernet_operations ip6_tnl_
  * Return: 0 on success
  **/
 
-static int __init ip6_tunnel_init(void)
+static int  ip6_tunnel_init(void)
 {
 	int  err;
 
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -1329,7 +1329,7 @@ static struct pernet_operations ip6mr_ne
 	.exit = ip6mr_net_exit,
 };
 
-int __init ip6_mr_init(void)
+int  ip6_mr_init(void)
 {
 	int err;
 
--- a/net/ipv6/ipcomp6.c
+++ b/net/ipv6/ipcomp6.c
@@ -187,7 +187,7 @@ static const struct inet6_protocol ipcom
 	.flags		= INET6_PROTO_NOPOLICY,
 };
 
-static int __init ipcomp6_init(void)
+static int  ipcomp6_init(void)
 {
 	if (xfrm_register_type(&ipcomp6_type, AF_INET6) < 0) {
 		printk(KERN_INFO "ipcomp6 init: can't add xfrm type\n");
--- /dev/null
+++ b/net/ipv6/ipv6.c
@@ -0,0 +1,56 @@
+/*
+ *	This is a hack. SLES 11 turns off ipv6 by blacklisting the ipv6
+ *	module. However, since bonding, bridging and other drivers need bits of
+ *	the ipv6 code, their modules would normally depend on ipv6. Thus, when
+ *	ipv6 is blacklisted, these drivers cannot beloaded.
+ *
+ *	The original ipv6 module is now renamed to ipv6_lib, and drivers that
+ *	depend on it can load it even if ipv6 is blacklisted. The ipv6_lib
+ *	module will do nothing on module_init and all the initialization is
+ *	performed only once this tiny ipv6 module is loaded.
+ *
+ *	Functions originally in the .init.text section need to be put in standard 
+ *	.text in ipv6_lib because the initialization is now done after the module load.
+ *
+ *	Authors: Jiri Bohac <jbohac@suse.cz>
+ *
+ *	This program is free software; you can redistribute it and/or modify it
+ *	under the terms of the GNU General Public License as published by the
+ *	Free Software Foundation; either version 2 of the License, or (at your
+ *	option) any later version.
+ */
+
+#include <linux/module.h>
+#include <net/ipv6.h>
+
+MODULE_AUTHOR("Cast of dozens");
+MODULE_DESCRIPTION("IPv6 protocol stack for Linux");
+MODULE_LICENSE("GPL");
+
+module_param_named(disable, disable_ipv6_mod, int, 0444);
+MODULE_PARM_DESC(disable, "Disable IPv6 module such that it is non-functional");
+
+module_param_named(disable_ipv6, ipv6_defaults.disable_ipv6, int, 0444);
+MODULE_PARM_DESC(disable_ipv6, "Disable IPv6 on all interfaces");
+
+module_param_named(autoconf, ipv6_defaults.autoconf, int, 0444);
+MODULE_PARM_DESC(autoconf, "Enable IPv6 address autoconfiguration on all interfaces");
+
+void inet6_exit_real(void);
+int inet6_init_real(void);
+
+static int  ipv6_init(void)
+{
+        __module_get(THIS_MODULE); /* ipv6 cannot be unloaded */
+	return inet6_init_real();
+}
+module_init(ipv6_init);
+
+static void __exit ipv6_exit(void)
+{
+	inet6_exit_real();
+}
+module_exit(ipv6_exit);
+
+MODULE_ALIAS_NETPROTO(PF_INET6);
+
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -2668,7 +2668,7 @@ static struct pernet_operations igmp6_ne
 	.exit = igmp6_net_exit,
 };
 
-int __init igmp6_init(void)
+int  igmp6_init(void)
 {
 	return register_pernet_subsys(&igmp6_net_ops);
 }
--- a/net/ipv6/mip6.c
+++ b/net/ipv6/mip6.c
@@ -479,7 +479,7 @@ static const struct xfrm_type mip6_rthdr
 	.hdr_offset	= mip6_rthdr_offset,
 };
 
-static int __init mip6_init(void)
+static int  mip6_init(void)
 {
 	printk(KERN_INFO "Mobile IPv6\n");
 
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -1852,7 +1852,7 @@ static struct pernet_operations ndisc_ne
 	.exit = ndisc_net_exit,
 };
 
-int __init ndisc_init(void)
+int  ndisc_init(void)
 {
 	int err;
 
--- a/net/ipv6/netfilter.c
+++ b/net/ipv6/netfilter.c
@@ -174,7 +174,7 @@ static const struct nf_afinfo nf_ip6_afi
 	.route_key_size		= sizeof(struct ip6_rt_info),
 };
 
-int __init ipv6_netfilter_init(void)
+int  ipv6_netfilter_init(void)
 {
 	return nf_register_afinfo(&nf_ip6_afinfo);
 }
--- a/net/ipv6/proc.c
+++ b/net/ipv6/proc.c
@@ -330,7 +330,7 @@ static struct pernet_operations ipv6_pro
 	.exit = ipv6_proc_exit_net,
 };
 
-int __init ipv6_misc_proc_init(void)
+int  ipv6_misc_proc_init(void)
 {
 	return register_pernet_subsys(&ipv6_proc_ops);
 }
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -1307,7 +1307,7 @@ static struct pernet_operations raw6_net
 	.exit = raw6_exit_net,
 };
 
-int __init raw6_proc_init(void)
+int  raw6_proc_init(void)
 {
 	return register_pernet_subsys(&raw6_net_ops);
 }
@@ -1353,7 +1353,7 @@ static struct inet_protosw rawv6_protosw
 	.flags		= INET_PROTOSW_REUSE,
 };
 
-int __init rawv6_init(void)
+int  rawv6_init(void)
 {
 	int ret;
 
--- a/net/ipv6/reassembly.c
+++ b/net/ipv6/reassembly.c
@@ -725,7 +725,7 @@ static struct pernet_operations ip6_frag
 	.exit = ipv6_frags_exit_net,
 };
 
-int __init ipv6_frag_init(void)
+int  ipv6_frag_init(void)
 {
 	int ret;
 
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -2873,7 +2873,7 @@ static struct notifier_block ip6_route_d
 	.priority = 0,
 };
 
-int __init ip6_route_init(void)
+int  ip6_route_init(void)
 {
 	int ret;
 
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@ -1265,7 +1265,7 @@ static void __exit sit_cleanup(void)
 	rcu_barrier(); /* Wait for completion of call_rcu()'s */
 }
 
-static int __init sit_init(void)
+static int  sit_init(void)
 {
 	int err;
 
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -2278,7 +2278,7 @@ static struct pernet_operations tcpv6_ne
 	.exit_batch = tcpv6_net_exit_batch,
 };
 
-int __init tcpv6_init(void)
+int  tcpv6_init(void)
 {
 	int ret;
 
--- a/net/ipv6/tunnel6.c
+++ b/net/ipv6/tunnel6.c
@@ -157,7 +157,7 @@ static const struct inet6_protocol tunne
 	.flags          = INET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,
 };
 
-static int __init tunnel6_init(void)
+static int  tunnel6_init(void)
 {
 	if (inet6_add_protocol(&tunnel6_protocol, IPPROTO_IPV6)) {
 		printk(KERN_ERR "tunnel6 init(): can't add protocol\n");
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -1489,7 +1489,7 @@ static struct inet_protosw udpv6_protosw
 };
 
 
-int __init udpv6_init(void)
+int  udpv6_init(void)
 {
 	int ret;
 
--- a/net/ipv6/udplite.c
+++ b/net/ipv6/udplite.c
@@ -67,7 +67,7 @@ static struct inet_protosw udplite6_prot
 	.flags		= INET_PROTOSW_PERMANENT,
 };
 
-int __init udplitev6_init(void)
+int  udplitev6_init(void)
 {
 	int ret;
 
@@ -120,7 +120,7 @@ static struct pernet_operations udplite6
 	.exit = udplite6_proc_exit_net,
 };
 
-int __init udplite6_proc_init(void)
+int  udplite6_proc_init(void)
 {
 	return register_pernet_subsys(&udplite6_net_ops);
 }
--- a/net/ipv6/xfrm6_mode_beet.c
+++ b/net/ipv6/xfrm6_mode_beet.c
@@ -116,7 +116,7 @@ static struct xfrm_mode xfrm6_beet_mode
 	.flags = XFRM_MODE_FLAG_TUNNEL,
 };
 
-static int __init xfrm6_beet_init(void)
+static int  xfrm6_beet_init(void)
 {
 	return xfrm_register_mode(&xfrm6_beet_mode, AF_INET6);
 }
--- a/net/ipv6/xfrm6_mode_ro.c
+++ b/net/ipv6/xfrm6_mode_ro.c
@@ -65,7 +65,7 @@ static struct xfrm_mode xfrm6_ro_mode =
 	.encap = XFRM_MODE_ROUTEOPTIMIZATION,
 };
 
-static int __init xfrm6_ro_init(void)
+static int  xfrm6_ro_init(void)
 {
 	return xfrm_register_mode(&xfrm6_ro_mode, AF_INET6);
 }
--- a/net/ipv6/xfrm6_mode_transport.c
+++ b/net/ipv6/xfrm6_mode_transport.c
@@ -66,7 +66,7 @@ static struct xfrm_mode xfrm6_transport_
 	.encap = XFRM_MODE_TRANSPORT,
 };
 
-static int __init xfrm6_transport_init(void)
+static int  xfrm6_transport_init(void)
 {
 	return xfrm_register_mode(&xfrm6_transport_mode, AF_INET6);
 }
--- a/net/ipv6/xfrm6_mode_tunnel.c
+++ b/net/ipv6/xfrm6_mode_tunnel.c
@@ -100,7 +100,7 @@ static struct xfrm_mode xfrm6_tunnel_mod
 	.flags = XFRM_MODE_FLAG_TUNNEL,
 };
 
-static int __init xfrm6_mode_tunnel_init(void)
+static int  xfrm6_mode_tunnel_init(void)
 {
 	return xfrm_register_mode(&xfrm6_tunnel_mode, AF_INET6);
 }
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -279,7 +279,7 @@ static struct xfrm_policy_afinfo xfrm6_p
 	.blackhole_route =	ip6_blackhole_route,
 };
 
-static int __init xfrm6_policy_init(void)
+static int  xfrm6_policy_init(void)
 {
 	return xfrm_policy_register_afinfo(&xfrm6_policy_afinfo);
 }
@@ -304,7 +304,7 @@ static struct ctl_table xfrm6_policy_tab
 static struct ctl_table_header *sysctl_hdr;
 #endif
 
-int __init xfrm6_init(void)
+int  xfrm6_init(void)
 {
 	int ret;
 	unsigned int gc_thresh;
--- a/net/ipv6/xfrm6_state.c
+++ b/net/ipv6/xfrm6_state.c
@@ -184,7 +184,7 @@ static struct xfrm_state_afinfo xfrm6_st
 	.transport_finish	= xfrm6_transport_finish,
 };
 
-int __init xfrm6_state_init(void)
+int  xfrm6_state_init(void)
 {
 	return xfrm_state_register_afinfo(&xfrm6_state_afinfo);
 }
--- a/net/ipv6/xfrm6_tunnel.c
+++ b/net/ipv6/xfrm6_tunnel.c
@@ -352,7 +352,7 @@ static struct pernet_operations xfrm6_tu
 	.size	= sizeof(struct xfrm6_tunnel_net),
 };
 
-static int __init xfrm6_tunnel_init(void)
+static int  xfrm6_tunnel_init(void)
 {
 	int rv;
 
