From: Jiri Bohac <jbohac@suse.cz>
Subject: allow bonding with blacklisted ipv6
References: bnc#585463
Patch-mainline: no

This patch moves all the functionality of ipv6.ko into ipv6_lib.ko 
Loading ipv6.ko the only triggers the initialization of IPv6.
Nothing must be placed in the .init section of ipv6_lib.ko.


---
 include/net/ipv6.h               |    3 ++
 net/ipv6/Makefile                |   20 ++++++-------
 net/ipv6/addrconf.c              |    1 
 net/ipv6/addrlabel.c             |    1 
 net/ipv6/af_inet6.c              |   29 +++++++++++---------
 net/ipv6/anycast.c               |    1 
 net/ipv6/datagram.c              |    1 
 net/ipv6/exthdrs.c               |    1 
 net/ipv6/fib6_rules.c            |    1 
 net/ipv6/icmp.c                  |    1 
 net/ipv6/inet6_connection_sock.c |    1 
 net/ipv6/ip6_fib.c               |    1
 net/ipv6/ip6_flowlabel.c         |    1 
 net/ipv6/ip6_input.c             |    1 
 net/ipv6/ip6_output.c            |    1 
 net/ipv6/ip6mr.c                 |    1 
 net/ipv6/ipv6.c                  |   56 +++++++++++++++++++++++++++++++++++++++
 net/ipv6/ipv6_noinit.h           |   10 ++++++
 net/ipv6/ipv6_sockglue.c         |    1 
 net/ipv6/mcast.c                 |    1 
 net/ipv6/ndisc.c                 |    1 
 net/ipv6/netfilter.c             |    1 
 net/ipv6/proc.c                  |    1 
 net/ipv6/protocol.c              |    1 
 net/ipv6/raw.c                   |    1 
 net/ipv6/reassembly.c            |    1 
 net/ipv6/route.c                 |    1 
 net/ipv6/syncookies.c            |    1 
 net/ipv6/sysctl_net_ipv6.c       |    1 
 net/ipv6/tcp_ipv6.c              |    1 
 net/ipv6/udp.c                   |    1 
 net/ipv6/udplite.c               |    1 
 net/ipv6/xfrm6_input.c           |    1 
 net/ipv6/xfrm6_output.c          |    1 
 net/ipv6/xfrm6_policy.c          |    1 
 net/ipv6/xfrm6_state.c           |    1 
 36 files changed, 127 insertions(+), 22 deletions(-)

--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -660,4 +660,7 @@ extern int ipv6_static_sysctl_register(v
 extern void ipv6_static_sysctl_unregister(void);
 #endif
 
+extern struct ipv6_params ipv6_defaults;
+extern int disable_ipv6_mod;
+
 #endif /* _NET_IPV6_H */
--- a/net/ipv6/Makefile
+++ b/net/ipv6/Makefile
@@ -2,25 +2,25 @@
 # Makefile for the Linux TCP/IP (INET6) layer.
 #
 
-obj-$(CONFIG_IPV6) += ipv6.o
+obj-$(CONFIG_IPV6) += ipv6_lib.o ipv6.o
 
-ipv6-objs :=	af_inet6.o anycast.o ip6_output.o ip6_input.o addrconf.o \
+ipv6_lib-objs := af_inet6.o anycast.o ip6_output.o ip6_input.o addrconf.o \
 		addrlabel.o \
 		route.o ip6_fib.o ipv6_sockglue.o ndisc.o udp.o udplite.o \
 		raw.o protocol.o icmp.o mcast.o reassembly.o tcp_ipv6.o \
 		exthdrs.o datagram.o ip6_flowlabel.o inet6_connection_sock.o
 
-ipv6-$(CONFIG_SYSCTL) = sysctl_net_ipv6.o
-ipv6-$(CONFIG_IPV6_MROUTE) += ip6mr.o
+ipv6_lib-$(CONFIG_SYSCTL) = sysctl_net_ipv6.o
+ipv6_lib-$(CONFIG_IPV6_MROUTE) += ip6mr.o
 
-ipv6-$(CONFIG_XFRM) += xfrm6_policy.o xfrm6_state.o xfrm6_input.o \
+ipv6_lib-$(CONFIG_XFRM) += xfrm6_policy.o xfrm6_state.o xfrm6_input.o \
 	xfrm6_output.o
-ipv6-$(CONFIG_NETFILTER) += netfilter.o
-ipv6-$(CONFIG_IPV6_MULTIPLE_TABLES) += fib6_rules.o
-ipv6-$(CONFIG_PROC_FS) += proc.o
-ipv6-$(CONFIG_SYN_COOKIES) += syncookies.o
+ipv6_lib-$(CONFIG_NETFILTER) += netfilter.o
+ipv6_lib-$(CONFIG_IPV6_MULTIPLE_TABLES) += fib6_rules.o
+ipv6_lib-$(CONFIG_PROC_FS) += proc.o
+ipv6_lib-$(CONFIG_SYN_COOKIES) += syncookies.o
 
-ipv6-objs += $(ipv6-y)
+ipv6_lib-objs += $(ipv6_lib-y)
 
 obj-$(CONFIG_INET6_AH) += ah6.o
 obj-$(CONFIG_INET6_ESP) += esp6.o
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -87,6 +87,7 @@
 
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include "ipv6_noinit.h"
 
 /* Set to 3 to get tracing... */
 #define ACONF_DEBUG 2
--- a/net/ipv6/addrlabel.c
+++ b/net/ipv6/addrlabel.c
@@ -18,6 +18,7 @@
 #include <linux/if_addrlabel.h>
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
+#include "ipv6_noinit.h"
 
 #if 0
 #define ADDRLABEL(x...) printk(x)
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -62,6 +62,7 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <linux/mroute6.h>
+#include "ipv6_noinit.h"
 
 MODULE_AUTHOR("Cast of dozens");
 MODULE_DESCRIPTION("IPv6 protocol stack for Linux");
@@ -77,17 +78,10 @@ struct ipv6_params ipv6_defaults = {
 	.disable_ipv6 = 0,
 	.autoconf = 1,
 };
+EXPORT_SYMBOL(ipv6_defaults);
 
-static int disable_ipv6_mod = 0;
-
-module_param_named(disable, disable_ipv6_mod, int, 0444);
-MODULE_PARM_DESC(disable, "Disable IPv6 module such that it is non-functional");
-
-module_param_named(disable_ipv6, ipv6_defaults.disable_ipv6, int, 0444);
-MODULE_PARM_DESC(disable_ipv6, "Disable IPv6 on all interfaces");
-
-module_param_named(autoconf, ipv6_defaults.autoconf, int, 0444);
-MODULE_PARM_DESC(autoconf, "Enable IPv6 address autoconfiguration on all interfaces");
+int disable_ipv6_mod = 0;
+EXPORT_SYMBOL(disable_ipv6_mod);
 
 static __inline__ struct ipv6_pinfo *inet6_sk_generic(struct sock *sk)
 {
@@ -1071,6 +1065,13 @@ static int __init inet6_init(void)
 	for(r = &inetsw6[0]; r < &inetsw6[SOCK_MAX]; ++r)
 		INIT_LIST_HEAD(r);
 
+	return err;
+}
+
+int inet6_init_real(void)
+{
+	int err = 0;
+
 	if (disable_ipv6_mod) {
 		printk(KERN_INFO
 		       "IPv6: Loaded, but administratively disabled, "
@@ -1259,9 +1260,14 @@ out_unregister_tcp_proto:
 	goto out;
 }
 module_init(inet6_init);
+EXPORT_SYMBOL(inet6_init_real);
 
 static void __exit inet6_exit(void)
 {
+}
+
+void inet6_exit_real(void)
+{
 	if (disable_ipv6_mod)
 		return;
 
@@ -1311,5 +1317,4 @@ static void __exit inet6_exit(void)
 	rcu_barrier(); /* Wait for completion of call_rcu()'s */
 }
 module_exit(inet6_exit);
-
-MODULE_ALIAS_NETPROTO(PF_INET6);
+EXPORT_SYMBOL(inet6_exit_real);
--- a/net/ipv6/anycast.c
+++ b/net/ipv6/anycast.c
@@ -43,6 +43,7 @@
 #include <net/ip6_route.h>
 
 #include <net/checksum.h>
+#include "ipv6_noinit.h"
 
 static int ipv6_dev_ac_dec(struct net_device *dev, const struct in6_addr *addr);
 
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -32,6 +32,7 @@
 
 #include <linux/errqueue.h>
 #include <asm/uaccess.h>
+#include "ipv6_noinit.h"
 
 int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
--- a/net/ipv6/exthdrs.c
+++ b/net/ipv6/exthdrs.c
@@ -47,6 +47,7 @@
 #endif
 
 #include <asm/uaccess.h>
+#include "ipv6_noinit.h"
 
 int ipv6_find_tlv(struct sk_buff *skb, int offset, int type)
 {
--- a/net/ipv6/fib6_rules.c
+++ b/net/ipv6/fib6_rules.c
@@ -20,6 +20,7 @@
 #include <net/addrconf.h>
 #include <net/ip6_route.h>
 #include <net/netlink.h>
+#include "ipv6_noinit.h"
 
 struct fib6_rule
 {
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@ -67,6 +67,7 @@
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
+#include "ipv6_noinit.h"
 
 /*
  *	The ICMP socket(s). This is the most convenient way to flow control
--- a/net/ipv6/inet6_connection_sock.c
+++ b/net/ipv6/inet6_connection_sock.c
@@ -26,6 +26,7 @@
 #include <net/ip6_route.h>
 #include <net/sock.h>
 #include <net/inet6_connection_sock.h>
+#include "ipv6_noinit.h"
 
 int inet6_csk_bind_conflict(const struct sock *sk,
 			    const struct inet_bind_bucket *tb)
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -38,6 +38,7 @@
 
 #include <net/ip6_fib.h>
 #include <net/ip6_route.h>
+#include "ipv6_noinit.h"
 
 #define RT6_DEBUG 2
 
--- a/net/ipv6/ip6_flowlabel.c
+++ b/net/ipv6/ip6_flowlabel.c
@@ -35,6 +35,7 @@
 #include <net/transp_v6.h>
 
 #include <asm/uaccess.h>
+#include "ipv6_noinit.h"
 
 #define FL_MIN_LINGER	6	/* Minimal linger. It is set to 6sec specified
 				   in old IPv6 RFC. Well, it was reasonable value.
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -44,6 +44,7 @@
 #include <net/ip6_route.h>
 #include <net/addrconf.h>
 #include <net/xfrm.h>
+#include "ipv6_noinit.h"
 
 
 
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -55,6 +55,7 @@
 #include <net/xfrm.h>
 #include <net/checksum.h>
 #include <linux/mroute6.h>
+#include "ipv6_noinit.h"
 
 int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *));
 
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -52,6 +52,7 @@
 #include <net/addrconf.h>
 #include <linux/netfilter_ipv6.h>
 #include <net/ip6_checksum.h>
+#include "ipv6_noinit.h"
 
 struct mr6_table {
 	struct list_head	list;
--- /dev/null
+++ b/net/ipv6/ipv6.c
@@ -0,0 +1,56 @@
+/*
+ *	This is a hack. SLES 11 turns off ipv6 by blacklisting the ipv6
+ *	module. However, since bonding, bridging and other drivers need bits of
+ *	the ipv6 code, their modules would normally depend on ipv6. Thus, when
+ *	ipv6 is blacklisted, these drivers cannot beloaded.
+ *
+ *	The original ipv6 module is now renamed to ipv6_lib, and drivers that
+ *	depend on it can load it even if ipv6 is blacklisted. The ipv6_lib
+ *	module will do nothing on module_init and all the initialization is
+ *	performed only once this tiny ipv6 module is loaded.
+ *
+ *	Functions originally in the .init.text section need to be put in standard 
+ *	.text in ipv6_lib because the initialization is now done after the module load.
+ *
+ *	Authors: Jiri Bohac <jbohac@suse.cz>
+ *
+ *	This program is free software; you can redistribute it and/or modify it
+ *	under the terms of the GNU General Public License as published by the
+ *	Free Software Foundation; either version 2 of the License, or (at your
+ *	option) any later version.
+ */
+
+#include <linux/module.h>
+#include <net/ipv6.h>
+
+MODULE_AUTHOR("Cast of dozens");
+MODULE_DESCRIPTION("IPv6 protocol stack for Linux");
+MODULE_LICENSE("GPL");
+
+module_param_named(disable, disable_ipv6_mod, int, 0444);
+MODULE_PARM_DESC(disable, "Disable IPv6 module such that it is non-functional");
+
+module_param_named(disable_ipv6, ipv6_defaults.disable_ipv6, int, 0444);
+MODULE_PARM_DESC(disable_ipv6, "Disable IPv6 on all interfaces");
+
+module_param_named(autoconf, ipv6_defaults.autoconf, int, 0444);
+MODULE_PARM_DESC(autoconf, "Enable IPv6 address autoconfiguration on all interfaces");
+
+void inet6_exit_real(void);
+int inet6_init_real(void);
+
+static int  ipv6_init(void)
+{
+        __module_get(THIS_MODULE); /* ipv6 cannot be unloaded */
+	return inet6_init_real();
+}
+module_init(ipv6_init);
+
+static void __exit ipv6_exit(void)
+{
+	inet6_exit_real();
+}
+module_exit(ipv6_exit);
+
+MODULE_ALIAS_NETPROTO(PF_INET6);
+
--- /dev/null
+++ b/net/ipv6/ipv6_noinit.h
@@ -0,0 +1,10 @@
+/*
+ * See somment in ipv6.c
+ * Prevents placing anything in the .init.text section because we will need
+ * it after the module is loaded.
+*/
+
+#undef __init
+#define __init
+#undef __initdata
+#define __initdata
--- a/net/ipv6/ipv6_sockglue.c
+++ b/net/ipv6/ipv6_sockglue.c
@@ -54,6 +54,7 @@
 #include <net/compat.h>
 
 #include <asm/uaccess.h>
+#include "ipv6_noinit.h"
 
 struct ip6_ra_chain *ip6_ra_chain;
 DEFINE_RWLOCK(ip6_ra_lock);
--- a/net/ipv6/mcast.c
+++ b/net/ipv6/mcast.c
@@ -62,6 +62,7 @@
 #include <net/inet_common.h>
 
 #include <net/ip6_checksum.h>
+#include "ipv6_noinit.h"
 
 /* Set to 3 to get tracing... */
 #define MCAST_DEBUG 2
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -90,6 +90,7 @@
 
 #include <linux/netfilter.h>
 #include <linux/netfilter_ipv6.h>
+#include "ipv6_noinit.h"
 
 static u32 ndisc_hash(const void *pkey,
 		      const struct net_device *dev,
--- a/net/ipv6/netfilter.c
+++ b/net/ipv6/netfilter.c
@@ -9,6 +9,7 @@
 #include <net/xfrm.h>
 #include <net/ip6_checksum.h>
 #include <net/netfilter/nf_queue.h>
+#include "ipv6_noinit.h"
 
 int ip6_route_me_harder(struct sk_buff *skb)
 {
--- a/net/ipv6/proc.c
+++ b/net/ipv6/proc.c
@@ -28,6 +28,7 @@
 #include <net/udp.h>
 #include <net/transp_v6.h>
 #include <net/ipv6.h>
+#include "ipv6_noinit.h"
 
 static int sockstat6_seq_show(struct seq_file *seq, void *v)
 {
--- a/net/ipv6/protocol.c
+++ b/net/ipv6/protocol.c
@@ -24,6 +24,7 @@
 #include <linux/netdevice.h>
 #include <linux/spinlock.h>
 #include <net/protocol.h>
+#include "ipv6_noinit.h"
 
 const struct inet6_protocol __rcu *inet6_protos[MAX_INET_PROTOS] __read_mostly;
 
--- a/net/ipv6/raw.c
+++ b/net/ipv6/raw.c
@@ -61,6 +61,7 @@
 
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include "ipv6_noinit.h"
 
 static struct raw_hashinfo raw_v6_hashinfo = {
 	.lock = __RW_LOCK_UNLOCKED(raw_v6_hashinfo.lock),
--- a/net/ipv6/reassembly.c
+++ b/net/ipv6/reassembly.c
@@ -54,6 +54,7 @@
 #include <net/ndisc.h>
 #include <net/addrconf.h>
 #include <net/inet_frag.h>
+#include "ipv6_noinit.h"
 
 struct ip6frag_skb_cb
 {
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -60,6 +60,7 @@
 #ifdef CONFIG_SYSCTL
 #include <linux/sysctl.h>
 #endif
+#include "ipv6_noinit.h"
 
 /* Set to 3 to get tracing. */
 #define RT6_DEBUG 2
--- a/net/ipv6/syncookies.c
+++ b/net/ipv6/syncookies.c
@@ -20,6 +20,7 @@
 #include <linux/kernel.h>
 #include <net/ipv6.h>
 #include <net/tcp.h>
+#include "ipv6_noinit.h"
 
 extern int sysctl_tcp_syncookies;
 extern __u32 syncookie_secret[2][16-4+SHA_DIGEST_WORDS];
--- a/net/ipv6/sysctl_net_ipv6.c
+++ b/net/ipv6/sysctl_net_ipv6.c
@@ -14,6 +14,7 @@
 #include <net/ipv6.h>
 #include <net/addrconf.h>
 #include <net/inet_frag.h>
+#include "ipv6_noinit.h"
 
 static struct ctl_table empty[1];
 
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -70,6 +70,7 @@
 
 #include <linux/crypto.h>
 #include <linux/scatterlist.h>
+#include "ipv6_noinit.h"
 
 static void	tcp_v6_send_reset(struct sock *sk, struct sk_buff *skb);
 static void	tcp_v6_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@ -49,6 +49,7 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include "udp_impl.h"
+#include "ipv6_noinit.h"
 
 int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)
 {
--- a/net/ipv6/udplite.c
+++ b/net/ipv6/udplite.c
@@ -12,6 +12,7 @@
  *		2 of the License, or (at your option) any later version.
  */
 #include "udp_impl.h"
+#include "ipv6_noinit.h"
 
 static int udplitev6_rcv(struct sk_buff *skb)
 {
--- a/net/ipv6/xfrm6_input.c
+++ b/net/ipv6/xfrm6_input.c
@@ -15,6 +15,7 @@
 #include <linux/netfilter_ipv6.h>
 #include <net/ipv6.h>
 #include <net/xfrm.h>
+#include "ipv6_noinit.h"
 
 int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb)
 {
--- a/net/ipv6/xfrm6_output.c
+++ b/net/ipv6/xfrm6_output.c
@@ -19,6 +19,7 @@
 #include <net/ipv6.h>
 #include <net/ip6_route.h>
 #include <net/xfrm.h>
+#include "ipv6_noinit.h"
 
 int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
 			  u8 **prevhdr)
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -23,6 +23,7 @@
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 #include <net/mip6.h>
 #endif
+#include "ipv6_noinit.h"
 
 static struct xfrm_policy_afinfo xfrm6_policy_afinfo;
 
--- a/net/ipv6/xfrm6_state.c
+++ b/net/ipv6/xfrm6_state.c
@@ -18,6 +18,7 @@
 #include <net/dsfield.h>
 #include <net/ipv6.h>
 #include <net/addrconf.h>
+#include "ipv6_noinit.h"
 
 static void
 __xfrm6_init_tempsel(struct xfrm_selector *sel, const struct flowi *fl)
