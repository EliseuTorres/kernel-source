Subject: [SCSI] libfc: Register Symbolic Node Name (RSNN_NN)
References: fate#306857, fate#306859, bnc#551175
Acked-by: Jiri Bohac <jbohac@suse.cz>
From: Chris Leech <christopher.leech@intel.com>
Patch-mainline: 2.6.33-rc1
Git-commit: 5baa17c3e66fc2e414f501b2dd59b962dfc64919

Register the fc_host symbolic name as the symbolic node name
    with the fabric name server.

    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>
---

 drivers/scsi/fcoe/fcoe.c      |    6 +--
 drivers/scsi/libfc/fc_lport.c |   91 +++++++++++++++++++++++++++++++++++++++++
 include/scsi/fc/fc_ns.h       |   10 +++++
 include/scsi/fc_encode.h      |   10 +++++
 include/scsi/libfc.h          |    1 
 5 files changed, 115 insertions(+), 3 deletions(-)


diff --git a/drivers/scsi/fcoe/fcoe.c b/drivers/scsi/fcoe/fcoe.c
index f23cdb3..437eacf 100644
--- a/drivers/scsi/fcoe/fcoe.c
+++ b/drivers/scsi/fcoe/fcoe.c
@@ -591,9 +591,9 @@ static int fcoe_shost_config(struct fc_lport *lp, struct Scsi_Host *shost,
 	if (!lp->vport)
 		fc_host_max_npiv_vports(lp->host) = USHORT_MAX;
 
-	sprintf(fc_host_symbolic_name(lp->host), "%s v%s over %s",
-		FCOE_NAME, FCOE_VERSION,
-		fcoe_netdev(lp)->name);
+	snprintf(fc_host_symbolic_name(lp->host), FC_SYMBOLIC_NAME_SIZE,
+		 "%s v%s over %s", FCOE_NAME, FCOE_VERSION,
+		 fcoe_netdev(lp)->name);
 
 	return 0;
 }
diff --git a/drivers/scsi/libfc/fc_lport.c b/drivers/scsi/libfc/fc_lport.c
index 897b5a8..cc389c0 100644
--- a/drivers/scsi/libfc/fc_lport.c
+++ b/drivers/scsi/libfc/fc_lport.c
@@ -109,6 +109,7 @@ static void fc_lport_enter_reset(struct fc_lport *);
 static void fc_lport_enter_flogi(struct fc_lport *);
 static void fc_lport_enter_dns(struct fc_lport *);
 static void fc_lport_enter_rnn_id(struct fc_lport *);
+static void fc_lport_enter_rsnn_nn(struct fc_lport *);
 static void fc_lport_enter_rft_id(struct fc_lport *);
 static void fc_lport_enter_scr(struct fc_lport *);
 static void fc_lport_enter_ready(struct fc_lport *);
@@ -119,6 +120,7 @@ static const char *fc_lport_state_names[] = {
 	[LPORT_ST_FLOGI] =    "FLOGI",
 	[LPORT_ST_DNS] =      "dNS",
 	[LPORT_ST_RNN_ID] =   "RNN_ID",
+	[LPORT_ST_RSNN_NN] =  "RSNN_NN",
 	[LPORT_ST_RFT_ID] =   "RFT_ID",
 	[LPORT_ST_SCR] =      "SCR",
 	[LPORT_ST_READY] =    "Ready",
@@ -966,6 +968,7 @@ static void fc_lport_error(struct fc_lport *lport, struct fc_frame *fp)
 			case LPORT_ST_READY:
 			case LPORT_ST_RESET:
 			case LPORT_ST_RNN_ID:
+			case LPORT_ST_RSNN_NN:
 			case LPORT_ST_RFT_ID:
 			case LPORT_ST_SCR:
 			case LPORT_ST_DNS:
@@ -1033,6 +1036,60 @@ err:
 }
 
 /**
+ * fc_lport_rsnn_nn_resp() - Handle response to Register Symbolic Node Name
+ *			     by Node Name (RSNN_NN) request
+ * @sp: current sequence in RSNN_NN exchange
+ * @fp: response frame
+ * @lp_arg: Fibre Channel host port instance
+ *
+ * Locking Note: This function will be called without the lport lock
+ * held, but it will lock, call an _enter_* function or fc_lport_error
+ * and then unlock the lport.
+ */
+static void fc_lport_rsnn_nn_resp(struct fc_seq *sp, struct fc_frame *fp,
+				  void *lp_arg)
+{
+	struct fc_lport *lport = lp_arg;
+	struct fc_frame_header *fh;
+	struct fc_ct_hdr *ct;
+
+	FC_LPORT_DBG(lport, "Received a RSNN_NN %s\n", fc_els_resp_type(fp));
+
+	if (fp == ERR_PTR(-FC_EX_CLOSED))
+		return;
+
+	mutex_lock(&lport->lp_mutex);
+
+	if (lport->state != LPORT_ST_RSNN_NN) {
+		FC_LPORT_DBG(lport, "Received a RSNN_NN response, but in state "
+			     "%s\n", fc_lport_state(lport));
+		if (IS_ERR(fp))
+			goto err;
+		goto out;
+	}
+
+	if (IS_ERR(fp)) {
+		fc_lport_error(lport, fp);
+		goto err;
+	}
+
+	fh = fc_frame_header_get(fp);
+	ct = fc_frame_payload_get(fp, sizeof(*ct));
+	if (fh && ct && fh->fh_type == FC_TYPE_CT &&
+	    ct->ct_fs_type == FC_FST_DIR &&
+	    ct->ct_fs_subtype == FC_NS_SUBTYPE &&
+	    ntohs(ct->ct_cmd) == FC_FS_ACC)
+		fc_lport_enter_rsnn_nn(lport);
+	else
+		fc_lport_error(lport, fp);
+
+out:
+	fc_frame_free(fp);
+err:
+	mutex_unlock(&lport->lp_mutex);
+}
+
+/**
  * fc_lport_rnn_id_resp() - Handle response to Register Node
  *			    Name by ID (RNN_ID) request
  * @sp: current sequence in RNN_ID exchange
@@ -1204,6 +1261,37 @@ static void fc_lport_enter_rft_id(struct fc_lport *lport)
 }
 
 /**
+ * fc_rport_enter_rsnn_nn() - Register symbolic node name with the name server
+ * @lport: Fibre Channel local port to register
+ *
+ * Locking Note: The lport lock is expected to be held before calling
+ * this routine.
+ */
+static void fc_lport_enter_rsnn_nn(struct fc_lport *lport)
+{
+	struct fc_frame *fp;
+	size_t len;
+
+	FC_LPORT_DBG(lport, "Entered RSNN_NN state from %s state\n",
+		     fc_lport_state(lport));
+
+	fc_lport_state_enter(lport, LPORT_ST_RSNN_NN);
+
+	len = strnlen(fc_host_symbolic_name(lport->host), 255);
+	fp = fc_frame_alloc(lport, sizeof(struct fc_ct_hdr) +
+			    sizeof(struct fc_ns_rsnn) + len);
+	if (!fp) {
+		fc_lport_error(lport, fp);
+		return;
+	}
+
+	if (!lport->tt.elsct_send(lport, FC_FID_DIR_SERV, fp, FC_NS_RSNN_NN,
+				  fc_lport_rsnn_nn_resp,
+				  lport, lport->e_d_tov))
+		fc_lport_error(lport, fp);
+}
+
+/**
  * fc_rport_enter_rnn_id() - Register node name with the name server
  * @lport: Fibre Channel local port to register
  *
@@ -1296,6 +1384,9 @@ static void fc_lport_timeout(struct work_struct *work)
 	case LPORT_ST_RNN_ID:
 		fc_lport_enter_rnn_id(lport);
 		break;
+	case LPORT_ST_RSNN_NN:
+		fc_lport_enter_rsnn_nn(lport);
+		break;
 	case LPORT_ST_RFT_ID:
 		fc_lport_enter_rft_id(lport);
 		break;
diff --git a/include/scsi/fc/fc_ns.h b/include/scsi/fc/fc_ns.h
index 790d7b9..fa82830 100644
--- a/include/scsi/fc/fc_ns.h
+++ b/include/scsi/fc/fc_ns.h
@@ -47,6 +47,7 @@ enum fc_ns_req {
 	FC_NS_RFT_ID =	0x0217,		/* reg FC4 type for ID */
 	FC_NS_RPN_ID =	0x0212,		/* reg port name for ID */
 	FC_NS_RNN_ID =	0x0213,		/* reg node name for ID */
+	FC_NS_RSNN_NN =	0x0239,		/* reg symbolic node name */
 };
 
 /*
@@ -156,4 +157,13 @@ struct fc_ns_rn_id {
 	__be64		fr_wwn;		/* node name or port name */
 } __attribute__((__packed__));
 
+/*
+ * RSNN_NN request - register symbolic node name
+ */
+struct fc_ns_rsnn {
+	__be64		fr_wwn;		/* node name */
+	__u8		fr_name_len;
+	char		fr_name[];
+} __attribute__((__packed__));
+
 #endif /* _FC_NS_H_ */
diff --git a/include/scsi/fc_encode.h b/include/scsi/fc_encode.h
index ad13cb1..89981af 100644
--- a/include/scsi/fc_encode.h
+++ b/include/scsi/fc_encode.h
@@ -33,6 +33,7 @@ struct fc_ct_req {
 		struct fc_ns_rn_id  rn;
 		struct fc_ns_rft rft;
 		struct fc_ns_fid fid;
+		struct fc_ns_rsnn snn;
 	} payload;
 };
 
@@ -136,6 +137,15 @@ static inline int fc_ct_fill(struct fc_lport *lport,
 		put_unaligned_be64(lport->wwnn, &ct->payload.rn.fr_wwn);
 		break;
 
+	case FC_NS_RSNN_NN:
+		ct = fc_ct_hdr_fill(fp, op, sizeof(struct fc_ns_rsnn));
+		put_unaligned_be64(lport->wwnn, &ct->payload.snn.fr_wwn);
+		strncpy(ct->payload.snn.fr_name,
+			fc_host_symbolic_name(lport->host), 255);
+		ct->payload.snn.fr_name_len =
+			strnlen(ct->payload.snn.fr_name, 255);
+		break;
+
 	default:
 		return -EINVAL;
 	}
diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 3d22dfd..1a63206 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -62,6 +62,7 @@ enum fc_lport_state {
 	LPORT_ST_FLOGI,
 	LPORT_ST_DNS,
 	LPORT_ST_RNN_ID,
+	LPORT_ST_RSNN_NN,
 	LPORT_ST_RFT_ID,
 	LPORT_ST_SCR,
 	LPORT_ST_READY,
