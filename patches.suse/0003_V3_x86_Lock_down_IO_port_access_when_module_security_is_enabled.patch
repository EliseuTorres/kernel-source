From: Matthew Garrett <matthew.garrett@nebula.com>
Subject: [PATCH V3 03/11] x86: Lock down IO port access when module security is enabled
Date: Tue,  3 Sep 2013 19:50:10 -0400

Git-commit: Not yet
Patch-mainline: Not yet, fedora 20
References: fate#314486, bnc#884333
Target: SLE-11 SP3

IO port access would permit users to gain access to PCI configuration
registers, which in turn (on a lot of hardware) give access to MMIO register
space. This would potentially permit root to trigger arbitrary DMA, so lock
it down by default.

Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>

---
 arch/x86/kernel/ioport.c | 5 +++--
 drivers/char/mem.c       | 4 ++++
 2 files changed, 7 insertions(+), 2 deletions(-)

Index: linux-3.0-SLE11-SP3/arch/x86/kernel/ioport.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/arch/x86/kernel/ioport.c
+++ linux-3.0-SLE11-SP3/arch/x86/kernel/ioport.c
@@ -15,6 +15,7 @@
 #include <linux/thread_info.h>
 #include <linux/syscalls.h>
 #include <linux/bitmap.h>
+#include <linux/module.h>
 #include <asm/syscalls.h>
 
 /*
@@ -28,7 +29,7 @@ asmlinkage long sys_ioperm(unsigned long
 
 	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
 		return -EINVAL;
-	if (turn_on && !capable(CAP_SYS_RAWIO))
+	if (turn_on && (!capable(CAP_SYS_RAWIO) || secure_modules()))
 		return -EPERM;
 
 	/*
@@ -102,7 +103,7 @@ long sys_iopl(unsigned int level, struct
 		return -EINVAL;
 	/* Trying to gain more privileges? */
 	if (level > old) {
-		if (!capable(CAP_SYS_RAWIO))
+		if (!capable(CAP_SYS_RAWIO) || secure_modules())
 			return -EPERM;
 	}
 	regs->flags = (regs->flags & ~X86_EFLAGS_IOPL) | (level << 12);
Index: linux-3.0-SLE11-SP3/drivers/char/mem.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/char/mem.c
+++ linux-3.0-SLE11-SP3/drivers/char/mem.c
@@ -27,6 +27,7 @@
 #include <linux/splice.h>
 #include <linux/pfn.h>
 #include <linux/io.h>
+#include <linux/module.h>
 
 #include <asm/uaccess.h>
 
@@ -602,6 +603,9 @@ static ssize_t write_port(struct file *f
 	unsigned long i = *ppos;
 	const char __user * tmp = buf;
 
+	if (secure_modules())
+		return -EPERM;
+
 	if (!access_ok(VERIFY_READ, buf, count))
 		return -EFAULT;
 	while (count-- > 0 && i < 65536) {
