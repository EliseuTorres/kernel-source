From: NeilBrown <neilb@suse.de>
Date: Thu, 12 Apr 2012 16:27:08 +1000
Subject: [PATCH 06/23] md/bitmap: move some fields of 'struct bitmap' into a
 'storage' substruct.3.5
Patch-mainline: fate#311379
References: 

This new 'struct bitmap_storage' reflects the external storage of the
bitmap.
Having this clearly defined will make it easier to change the storage
used while the array is active.

Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: NeilBrown <neilb@suse.de>

---
 drivers/md/bitmap.c |  176 +++++++++++++++++++++++++++-------------------------
 drivers/md/bitmap.h |   17 +++--
 drivers/md/md.c     |   13 ++-
 3 files changed, 110 insertions(+), 96 deletions(-)

--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/md/bitmap.c
+++ linux-3.0-SLE11-SP2-BTMU/drivers/md/bitmap.c
@@ -252,6 +252,7 @@ static int write_sb_page(struct bitmap *
 	mdk_rdev_t *rdev = NULL;
 	struct block_device *bdev;
 	mddev_t *mddev = bitmap->mddev;
+	struct bitmap_storage *store = &bitmap->storage;
 
 	while ((rdev = next_active_rdev(rdev, mddev)) != NULL) {
 		int size = PAGE_SIZE;
@@ -259,8 +260,8 @@ static int write_sb_page(struct bitmap *
 
 		bdev = (rdev->meta_bdev) ? rdev->meta_bdev : rdev->bdev;
 
-		if (page->index == bitmap->file_pages-1)
-			size = roundup(bitmap->last_page_size,
+		if (page->index == store->file_pages-1)
+			size = roundup(store->last_page_size,
 				       bdev_logical_block_size(bdev));
 		/* Just make sure we aren't corrupting data or
 		 * metadata
@@ -320,7 +321,7 @@ static void write_page(struct bitmap *bi
 {
 	struct buffer_head *bh;
 
-	if (bitmap->file == NULL) {
+	if (bitmap->storage.file == NULL) {
 		switch (write_sb_page(bitmap, page, wait)) {
 		case -EINVAL:
 			bitmap->flags |= BITMAP_WRITE_ERROR;
@@ -467,12 +468,12 @@ void bitmap_update_sb(struct bitmap *bit
 	if (bitmap->mddev->bitmap_info.external)
 		return;
 	spin_lock_irqsave(&bitmap->lock, flags);
-	if (!bitmap->sb_page) { /* no superblock */
+	if (!bitmap->storage.sb_page) { /* no superblock */
 		spin_unlock_irqrestore(&bitmap->lock, flags);
 		return;
 	}
 	spin_unlock_irqrestore(&bitmap->lock, flags);
-	sb = kmap_atomic(bitmap->sb_page, KM_USER0);
+	sb = kmap_atomic(bitmap->storage.sb_page, KM_USER0);
 	sb->events = cpu_to_le64(bitmap->mddev->events);
 	if (bitmap->mddev->events < bitmap->events_cleared)
 		/* rocking back to read-only */
@@ -483,7 +484,7 @@ void bitmap_update_sb(struct bitmap *bit
 	sb->daemon_sleep = cpu_to_le32(bitmap->mddev->bitmap_info.daemon_sleep/HZ);
 	sb->write_behind = cpu_to_le32(bitmap->mddev->bitmap_info.max_write_behind);
 	kunmap_atomic(sb, KM_USER0);
-	write_page(bitmap, bitmap->sb_page, 1);
+	write_page(bitmap, bitmap->storage.sb_page, 1);
 }
 
 /* print out the bitmap file superblock */
@@ -491,9 +492,9 @@ void bitmap_print_sb(struct bitmap *bitm
 {
 	bitmap_super_t *sb;
 
-	if (!bitmap || !bitmap->sb_page)
+	if (!bitmap || !bitmap->storage.sb_page)
 		return;
-	sb = kmap_atomic(bitmap->sb_page, KM_USER0);
+	sb = kmap_atomic(bitmap->storage.sb_page, KM_USER0);
 	printk(KERN_DEBUG "%s: bitmap file superblock:\n", bmname(bitmap));
 	printk(KERN_DEBUG "         magic: %08x\n", le32_to_cpu(sb->magic));
 	printk(KERN_DEBUG "       version: %d\n", le32_to_cpu(sb->version));
@@ -532,15 +533,15 @@ static int bitmap_new_disk_sb(struct bit
 	unsigned long chunksize, daemon_sleep, write_behind;
 	int err = -EINVAL;
 
-	bitmap->sb_page = alloc_page(GFP_KERNEL);
-	if (IS_ERR(bitmap->sb_page)) {
-		err = PTR_ERR(bitmap->sb_page);
-		bitmap->sb_page = NULL;
+	bitmap->storage.sb_page = alloc_page(GFP_KERNEL);
+	if (IS_ERR(bitmap->storage.sb_page)) {
+		err = PTR_ERR(bitmap->storage.sb_page);
+		bitmap->storage.sb_page = NULL;
 		return err;
 	}
-	bitmap->sb_page->index = 0;
+	bitmap->storage.sb_page->index = 0;
 
-	sb = kmap_atomic(bitmap->sb_page, KM_USER0);
+	sb = kmap_atomic(bitmap->storage.sb_page, KM_USER0);
 
 	sb->magic = cpu_to_le32(BITMAP_MAGIC);
 	sb->version = cpu_to_le32(BITMAP_MAJOR_HI);
@@ -601,7 +602,7 @@ static int bitmap_read_sb(struct bitmap
 	int err = -EINVAL;
 	struct page *sb_page;
 
-	if (!bitmap->file && !bitmap->mddev->bitmap_info.offset) {
+	if (!bitmap->storage.file && !bitmap->mddev->bitmap_info.offset) {
 		chunksize = 128 * 1024 * 1024;
 		daemon_sleep = 5 * HZ;
 		write_behind = 0;
@@ -613,13 +614,13 @@ static int bitmap_read_sb(struct bitmap
 	sb_page = alloc_page(GFP_KERNEL);
 	if (!sb_page)
 		return -ENOMEM;
-	bitmap->sb_page = sb_page;
+	bitmap->storage.sb_page = sb_page;
 
-	if (bitmap->file) {
-		loff_t isize = i_size_read(bitmap->file->f_mapping->host);
+	if (bitmap->storage.file) {
+		loff_t isize = i_size_read(bitmap->storage.file->f_mapping->host);
 		int bytes = isize > PAGE_SIZE ? PAGE_SIZE : isize;
 
-		err = read_page(bitmap->file, 0,
+		err = read_page(bitmap->storage.file, 0,
 				bitmap, bytes, sb_page);
 	} else {
 		err = read_sb_page(bitmap->mddev,
@@ -712,12 +713,12 @@ static int bitmap_mask_state(struct bitm
 	int old;
 
 	spin_lock_irqsave(&bitmap->lock, flags);
-	if (!bitmap->sb_page) { /* can't set the state */
+	if (!bitmap->storage.sb_page) { /* can't set the state */
 		spin_unlock_irqrestore(&bitmap->lock, flags);
 		return 0;
 	}
 	spin_unlock_irqrestore(&bitmap->lock, flags);
-	sb = kmap_atomic(bitmap->sb_page, KM_USER0);
+	sb = kmap_atomic(bitmap->storage.sb_page, KM_USER0);
 	old = le32_to_cpu(sb->state) & bits;
 	switch (op) {
 	case MASK_SET:
@@ -746,17 +747,19 @@ static int bitmap_mask_state(struct bitm
  * file a page at a time. There's a superblock at the start of the file.
  */
 /* calculate the index of the page that contains this bit */
-static inline unsigned long file_page_index(struct bitmap *bitmap, unsigned long chunk)
+static inline unsigned long file_page_index(struct bitmap_storage *store,
+					    unsigned long chunk)
 {
-	if (!bitmap->mddev->bitmap_info.external)
+	if (store->sb_page)
 		chunk += sizeof(bitmap_super_t) << 3;
 	return chunk >> PAGE_BIT_SHIFT;
 }
 
 /* calculate the (bit) offset of this bit within a page */
-static inline unsigned long file_page_offset(struct bitmap *bitmap, unsigned long chunk)
+static inline unsigned long file_page_offset(struct bitmap_storage *store,
+					     unsigned long chunk)
 {
-	if (!bitmap->mddev->bitmap_info.external)
+	if (store->sb_page)
 		chunk += sizeof(bitmap_super_t) << 3;
 	return chunk & (PAGE_BITS - 1);
 }
@@ -768,13 +771,13 @@ static inline unsigned long file_page_of
  * 1 page (e.g., x86) or less than 1 page -- so the bitmap might start on page
  * 0 or page 1
  */
-static inline struct page *filemap_get_page(struct bitmap *bitmap,
+static inline struct page *filemap_get_page(struct bitmap_storage *store,
 					    unsigned long chunk)
 {
-	if (file_page_index(bitmap, chunk) >= bitmap->file_pages)
+	if (file_page_index(store, chunk) >= store->file_pages)
 		return NULL;
-	return bitmap->filemap[file_page_index(bitmap, chunk)
-			       - file_page_index(bitmap, 0)];
+	return store->filemap[file_page_index(store, chunk)
+			      - file_page_index(store, 0)];
 }
 
 static void bitmap_file_unmap(struct bitmap *bitmap)
@@ -783,16 +786,17 @@ static void bitmap_file_unmap(struct bit
 	unsigned long *attr;
 	int pages;
 	unsigned long flags;
+	struct bitmap_storage *store = &bitmap->storage;
 
 	spin_lock_irqsave(&bitmap->lock, flags);
-	map = bitmap->filemap;
-	bitmap->filemap = NULL;
-	attr = bitmap->filemap_attr;
-	bitmap->filemap_attr = NULL;
-	pages = bitmap->file_pages;
-	bitmap->file_pages = 0;
-	sb_page = bitmap->sb_page;
-	bitmap->sb_page = NULL;
+	map = store->filemap;
+	store->filemap = NULL;
+	attr = store->filemap_attr;
+	store->filemap_attr = NULL;
+	pages = store->file_pages;
+	store->file_pages = 0;
+	sb_page = store->sb_page;
+	store->sb_page = NULL;
 	spin_unlock_irqrestore(&bitmap->lock, flags);
 
 	while (pages--)
@@ -811,8 +815,8 @@ static void bitmap_file_put(struct bitma
 	unsigned long flags;
 
 	spin_lock_irqsave(&bitmap->lock, flags);
-	file = bitmap->file;
-	bitmap->file = NULL;
+	file = bitmap->storage.file;
+	bitmap->storage.file = NULL;
 	spin_unlock_irqrestore(&bitmap->lock, flags);
 
 	if (file) {
@@ -841,11 +845,11 @@ static void bitmap_file_kick(struct bitm
 	if (bitmap_mask_state(bitmap, BITMAP_STALE, MASK_SET) == 0) {
 		bitmap_update_sb(bitmap);
 
-		if (bitmap->file) {
+		if (bitmap->storage.file) {
 			path = kmalloc(PAGE_SIZE, GFP_KERNEL);
 			if (path)
-				ptr = d_path(&bitmap->file->f_path, path,
-					     PAGE_SIZE);
+				ptr = d_path(&bitmap->storage.file->f_path,
+					     path, PAGE_SIZE);
 
 			printk(KERN_ALERT
 			      "%s: kicking failed bitmap file %s from array!\n",
@@ -872,19 +876,19 @@ enum bitmap_page_attr {
 static inline void set_page_attr(struct bitmap *bitmap, int pnum,
 				 enum bitmap_page_attr attr)
 {
-	__set_bit((pnum<<2) + attr, bitmap->filemap_attr);
+	__set_bit((pnum<<2) + attr, bitmap->storage.filemap_attr);
 }
 
 static inline void clear_page_attr(struct bitmap *bitmap, int pnum,
 				   enum bitmap_page_attr attr)
 {
-	__clear_bit((pnum<<2) + attr, bitmap->filemap_attr);
+	__clear_bit((pnum<<2) + attr, bitmap->storage.filemap_attr);
 }
 
 static inline unsigned long test_page_attr(struct bitmap *bitmap, int pnum,
 					   enum bitmap_page_attr attr)
 {
-	return test_bit((pnum<<2) + attr, bitmap->filemap_attr);
+	return test_bit((pnum<<2) + attr, bitmap->storage.filemap_attr);
 }
 
 /*
@@ -901,10 +905,10 @@ static void bitmap_file_set_bit(struct b
 	void *kaddr;
 	unsigned long chunk = block >> bitmap->chunkshift;
 
-	page = filemap_get_page(bitmap, chunk);
+	page = filemap_get_page(&bitmap->storage, chunk);
 	if (!page)
 		return;
-	bit = file_page_offset(bitmap, chunk);
+	bit = file_page_offset(&bitmap->storage, chunk);
 
 	/* set the bit */
 	kaddr = kmap_atomic(page, KM_USER0);
@@ -925,10 +929,10 @@ static void bitmap_file_clear_bit(struct
 	void *paddr;
 	unsigned long chunk = block >> bitmap->chunkshift;
 
-	page = filemap_get_page(bitmap, chunk);
+	page = filemap_get_page(&bitmap->storage, chunk);
 	if (!page)
 		return;
-	bit = file_page_offset(bitmap, chunk);
+	bit = file_page_offset(&bitmap->storage, chunk);
 	paddr = kmap_atomic(page, KM_USER0);
 	if (bitmap->flags & BITMAP_HOSTENDIAN)
 		clear_bit(bit, paddr);
@@ -950,14 +954,14 @@ void bitmap_unplug(struct bitmap *bitmap
 	int dirty, need_write;
 	int wait = 0;
 
-	if (!bitmap || !bitmap->filemap)
+	if (!bitmap || !bitmap->storage.filemap)
 		return;
 
 	/* look at each page to see if there are any set bits that need to be
 	 * flushed out to disk */
-	for (i = 0; i < bitmap->file_pages; i++) {
+	for (i = 0; i < bitmap->storage.file_pages; i++) {
 		spin_lock_irqsave(&bitmap->lock, flags);
-		if (!bitmap->filemap) {
+		if (!bitmap->storage.filemap) {
 			spin_unlock_irqrestore(&bitmap->lock, flags);
 			return;
 		}
@@ -972,10 +976,10 @@ void bitmap_unplug(struct bitmap *bitmap
 		spin_unlock_irqrestore(&bitmap->lock, flags);
 
 		if (dirty || need_write)
-			write_page(bitmap, bitmap->filemap[i], 0);
+			write_page(bitmap, bitmap->storage.filemap[i], 0);
 	}
 	if (wait) { /* if any writes were performed, we need to wait on them */
-		if (bitmap->file)
+		if (bitmap->storage.file)
 			wait_event(bitmap->write_wait,
 				   atomic_read(&bitmap->pending_writes)==0);
 		else
@@ -1009,14 +1013,15 @@ static int bitmap_init_from_disk(struct
 	int outofdate;
 	int ret = -ENOSPC;
 	void *paddr;
+	struct bitmap_storage *store = &bitmap->storage;
 
 	chunks = bitmap->chunks;
-	file = bitmap->file;
+	file = store->file;
 
 	if (!file && !bitmap->mddev->bitmap_info.offset) {
 		/* No permanent bitmap - fill with '1s'. */
-		bitmap->filemap = NULL;
-		bitmap->file_pages = 0;
+		store->filemap = NULL;
+		store->file_pages = 0;
 		for (i = 0; i < chunks ; i++) {
 			/* if the disk bit is set, set the memory bit */
 			int needed = ((sector_t)(i+1) << (bitmap->chunkshift)
@@ -1053,39 +1058,40 @@ static int bitmap_init_from_disk(struct
 
 	ret = -ENOMEM;
 
-	bitmap->filemap = kmalloc(sizeof(struct page *) * num_pages, GFP_KERNEL);
-	if (!bitmap->filemap)
+	store->filemap = kmalloc(sizeof(struct page *)
+					  * num_pages, GFP_KERNEL);
+	if (!store->filemap)
 		goto err;
 
 	pnum = 0;
 	offset = 0;
-	if (bitmap->sb_page) {
-		bitmap->filemap[0] = bitmap->sb_page;
+	if (store->sb_page) {
+		store->filemap[0] = store->sb_page;
 		pnum = 1;
 		offset = sizeof(bitmap_super_t);
 	}
 	for ( ; pnum < num_pages; pnum++) {
-		bitmap->filemap[pnum] = alloc_page(GFP_KERNEL);
-		if (!bitmap->filemap[pnum]) {
-			bitmap->file_pages = pnum;
+		store->filemap[pnum] = alloc_page(GFP_KERNEL);
+		if (!store->filemap[pnum]) {
+			store->file_pages = pnum;
 			goto err;
 		}
 	}
-	bitmap->file_pages = pnum;
+	store->file_pages = pnum;
 
 	/* We need 4 bits per page, rounded up to a multiple of sizeof(unsigned long) */
-	bitmap->filemap_attr = kzalloc(
+	store->filemap_attr = kzalloc(
 		roundup(DIV_ROUND_UP(num_pages*4, 8), sizeof(unsigned long)),
 		GFP_KERNEL);
-	if (!bitmap->filemap_attr)
+	if (!store->filemap_attr)
 		goto err;
 
 	oldindex = ~0L;
 
 	for (i = 0; i < chunks; i++) {
 		int b;
-		index = file_page_index(bitmap, i);
-		bit = file_page_offset(bitmap, i);
+		index = file_page_index(&bitmap->storage, i);
+		bit = file_page_offset(&bitmap->storage, i);
 		if (index != oldindex) { /* this is a new page, read it in */
 			int count;
 			/* unmap the old page, we're done with it */
@@ -1093,7 +1099,7 @@ static int bitmap_init_from_disk(struct
 				count = bytes - index * PAGE_SIZE;
 			else
 				count = PAGE_SIZE;
-			page = bitmap->filemap[index];
+			page = store->filemap[index];
 			if (file)
 				ret = read_page(file, index, bitmap,
 						count, page);
@@ -1109,7 +1115,7 @@ static int bitmap_init_from_disk(struct
 
 			oldindex = index;
 
-			bitmap->last_page_size = count;
+			store->last_page_size = count;
 
 			if (outofdate) {
 				/*
@@ -1148,7 +1154,8 @@ static int bitmap_init_from_disk(struct
 
 	printk(KERN_INFO "%s: bitmap initialized from disk: "
 	       "read %lu/%lu pages, set %lu of %lu bits\n",
-	       bmname(bitmap), bitmap->file_pages, num_pages, bit_cnt, chunks);
+	       bmname(bitmap), store->file_pages,
+	       num_pages, bit_cnt, chunks);
 
 	return 0;
 
@@ -1165,14 +1172,14 @@ void bitmap_write_all(struct bitmap *bit
 	 */
 	int i;
 
-	if (!bitmap || !bitmap->filemap)
+	if (!bitmap || !bitmap->storage.filemap)
 		return;
-	if (bitmap->file)
+	if (bitmap->storage.file)
 		/* Only one copy, so nothing needed */
 		return;
 
 	spin_lock_irq(&bitmap->lock);
-	for (i = 0; i < bitmap->file_pages; i++)
+	for (i = 0; i < bitmap->storage.file_pages; i++)
 		set_page_attr(bitmap, i,
 			      BITMAP_PAGE_NEEDWRITE);
 	spin_unlock_irq(&bitmap->lock);
@@ -1238,7 +1245,7 @@ void bitmap_daemon_work(mddev_t *mddev)
 	 * we will write it.
 	 */
 	spin_lock_irqsave(&bitmap->lock, flags);
-	for (j = 0; j < bitmap->file_pages; j++)
+	for (j = 0; j < bitmap->storage.file_pages; j++)
 		if (test_page_attr(bitmap, j,
 				   BITMAP_PAGE_PENDING)) {
 			set_page_attr(bitmap, j,
@@ -1253,8 +1260,8 @@ void bitmap_daemon_work(mddev_t *mddev)
 		 * other changes */
 		bitmap_super_t *sb;
 		bitmap->need_sync = 0;
-		if (bitmap->filemap) {
-			sb = kmap_atomic(bitmap->sb_page, KM_USER0);
+		if (bitmap->storage.filemap) {
+			sb = kmap_atomic(bitmap->storage.sb_page, KM_USER0);
 			sb->events_cleared =
 				cpu_to_le64(bitmap->events_cleared);
 			kunmap_atomic(sb, KM_USER0);
@@ -1306,7 +1313,7 @@ void bitmap_daemon_work(mddev_t *mddev)
 	 * the first blocking holds the superblock and it has been updated.
 	 * We mustn't write any other blocks before the superblock.
 	 */
-	for (j = 0; j < bitmap->file_pages; j++) {
+	for (j = 0; j < bitmap->storage.file_pages; j++) {
 
 		if (test_page_attr(bitmap, j,
 				    BITMAP_PAGE_DIRTY))
@@ -1317,9 +1324,9 @@ void bitmap_daemon_work(mddev_t *mddev)
 			clear_page_attr(bitmap, j,
 					BITMAP_PAGE_NEEDWRITE);
 			spin_unlock_irqrestore(&bitmap->lock, flags);
-			write_page(bitmap, bitmap->filemap[j], 0);
+			write_page(bitmap, bitmap->storage.filemap[j], 0);
 			spin_lock_irqsave(&bitmap->lock, flags);
-			if (!bitmap->filemap)
+			if (!bitmap->storage.filemap)
 				break;
 		}
 	}
@@ -1775,7 +1782,7 @@ int bitmap_create(mddev_t *mddev)
 	} else
 		bitmap->sysfs_can_clear = NULL;
 
-	bitmap->file = file;
+	bitmap->storage.file = file;
 	if (file) {
 		get_file(file);
 		/* As future accesses to this file will use bmap,
@@ -1931,8 +1938,9 @@ space_store(mddev_t *mddev, const char *
 		return -EINVAL;
 
 	if (mddev->bitmap &&
-	    sectors  < ((mddev->bitmap->file_pages - 1) * PAGE_SIZE
-			+ mddev->bitmap->last_page_size + 511) >> 9)
+	    sectors  < ((mddev->bitmap->storage.file_pages - 1)
+			      * PAGE_SIZE
+			+ mddev->bitmap->storage.last_page_size + 511) >> 9)
 		return -EFBIG; /* Bitmap is too big for this small space */
 
 	/* could make sure it isn't too big, but that isn't really
--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/md/bitmap.h
+++ linux-3.0-SLE11-SP2-BTMU/drivers/md/bitmap.h
@@ -209,12 +209,17 @@ struct bitmap {
 	/* bitmap spinlock */
 	spinlock_t lock;
 
-	struct file *file; /* backing disk file */
-	struct page *sb_page; /* cached copy of the bitmap file superblock */
-	struct page **filemap; /* list of cache pages for the file */
-	unsigned long *filemap_attr; /* attributes associated w/ filemap pages */
-	unsigned long file_pages; /* number of pages in the file */
-	int last_page_size; /* bytes in the last page */
+	struct bitmap_storage {
+		struct file *file;		/* backing disk file */
+		struct page *sb_page;		/* cached copy of the bitmap
+						 * file superblock */
+		struct page **filemap;		/* list of cache pages for
+						 * the file */
+		unsigned long *filemap_attr;	/* attributes associated
+						 * w/ filemap pages */
+		unsigned long file_pages;	/* number of pages in the file*/
+		int last_page_size;		/* bytes in the last page */
+	} storage;
 
 	unsigned long flags;
 
--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/md/md.c
+++ linux-3.0-SLE11-SP2-BTMU/drivers/md/md.c
@@ -1903,7 +1903,7 @@ super_1_allow_new_offset(mdk_rdev_t *rde
 	bitmap = rdev->mddev->bitmap;
 	if (bitmap && !rdev->mddev->bitmap_info.file &&
 	    rdev->sb_start + rdev->mddev->bitmap_info.offset +
-	    bitmap->file_pages * (PAGE_SIZE>>9) > new_offset)
+	    bitmap->storage.file_pages * (PAGE_SIZE>>9) > new_offset)
 		return 0;
 
 	return 1;
@@ -5440,7 +5440,7 @@ static int get_bitmap_file(mddev_t * mdd
 		goto out;
 
 	/* bitmap disabled, zero the first byte and copy out */
-	if (!mddev->bitmap || !mddev->bitmap->file) {
+	if (!mddev->bitmap || !mddev->bitmap->storage.file) {
 		file->pathname[0] = '\0';
 		goto copy_out;
 	}
@@ -5449,7 +5449,8 @@ static int get_bitmap_file(mddev_t * mdd
 	if (!buf)
 		goto out;
 
-	ptr = d_path(&mddev->bitmap->file->f_path, buf, sizeof(file->pathname));
+	ptr = d_path(&mddev->bitmap->storage.file->f_path,
+		     buf, sizeof(file->pathname));
 	if (IS_ERR(ptr))
 		goto out;
 
@@ -6099,7 +6100,7 @@ static int update_array_info(mddev_t *md
 			/* remove the bitmap */
 			if (!mddev->bitmap)
 				return -ENOENT;
-			if (mddev->bitmap->file)
+			if (mddev->bitmap->storage.file)
 				return -EINVAL;
 			mddev->pers->quiesce(mddev, 1);
 			bitmap_destroy(mddev);
@@ -6902,10 +6903,10 @@ static int md_seq_show(struct seq_file *
 					<< (PAGE_SHIFT - 10),
 				chunk_kb ? chunk_kb : mddev->bitmap_info.chunksize,
 				chunk_kb ? "KB" : "B");
-			file = rcu_dereference(bitmap->file);
+			file = rcu_dereference(bitmap->storage.file);
 			if (file) {
 				seq_printf(seq, ", file: ");
-				seq_path(seq, &bitmap->file->f_path, " \t\n");
+				seq_path(seq, &file->f_path, " \t\n");
 			}
 
 			seq_printf(seq, "\n");
