From: Frederic Weisbecker <fweisbec@gmail.com>
Subject: hw-breakpoints: Change/Enforce some breakpoints policies
Date: Sun Apr 18 18:11:53 2010 +0200
Git-commit: b2812d031dea86926e9c10f7714af33ac2f6b43d
Patch-mainline: v2.6.35-rc1
References: FATE#311653, BNC#702123
Signed-off-by: Tony Jones <tonyj@suse.de>

    hw-breakpoints: Change/Enforce some breakpoints policies
    
    The current policies of breakpoints in x86 and SH are the following:
    
    - task bound breakpoints can only break on userspace addresses
    - cpu wide breakpoints can only break on kernel addresses
    
    The former rule prevents ptrace breakpoints to be set to trigger on
    kernel addresses, which is good. But as a side effect, we can't
    breakpoint on kernel addresses for task bound breakpoints.
    
    The latter rule simply makes no sense, there is no reason why we
    can't set breakpoints on userspace while performing cpu bound
    profiles.
    
    We want the following new policies:
    
    - task bound breakpoint can set userspace address breakpoints, with
    no particular privilege required.
    - task bound breakpoints can set kernelspace address breakpoints but
    must be privileged to do that.
    - cpu bound breakpoints can do what they want as they are privileged
    already.
    
    To implement these new policies, this patch checks if we are dealing
    with a kernel address breakpoint, if so and if the exclude_kernel
    parameter is set, we tell the user that the breakpoint is invalid,
    which makes a good generic ptrace protection.
    If we don't have exclude_kernel, ensure the user has the right
    privileges as kernel breakpoints are quite sensitive (risk of
    trap recursion attacks and global performance impacts).
    
    [ Paul Mundt: keep addr space check for sh signal delivery and fix
      double function declaration]

    [Prasad: Edited the patch to remove SH arch related changes]
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Cc: K. Prasad <prasad@linux.vnet.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

---
 arch/x86/include/asm/hw_breakpoint.h |    5 +---
 arch/x86/kernel/hw_breakpoint.c      |   41 +++++------------------------------
 kernel/hw_breakpoint.c               |   26 ++++++++++++++++++++--
 3 files changed, 32 insertions(+), 40 deletions(-)

--- a/arch/x86/include/asm/hw_breakpoint.h
+++ b/arch/x86/include/asm/hw_breakpoint.h
@@ -45,9 +45,8 @@ struct arch_hw_breakpoint {
 struct perf_event;
 struct pmu;
 
-extern int arch_check_va_in_userspace(unsigned long va, u8 hbp_len);
-extern int arch_validate_hwbkpt_settings(struct perf_event *bp,
-					 struct task_struct *tsk);
+extern int arch_check_bp_in_kernelspace(struct perf_event *bp);
+extern int arch_validate_hwbkpt_settings(struct perf_event *bp);
 extern int hw_breakpoint_exceptions_notify(struct notifier_block *unused,
 					   unsigned long val, void *data);
 
--- a/arch/x86/kernel/hw_breakpoint.c
+++ b/arch/x86/kernel/hw_breakpoint.c
@@ -189,25 +189,16 @@ static int get_hbp_len(u8 hbp_len)
 }
 
 /*
- * Check for virtual address in user space.
- */
-int arch_check_va_in_userspace(unsigned long va, u8 hbp_len)
-{
-	unsigned int len;
-
-	len = get_hbp_len(hbp_len);
-
-	return (va <= TASK_SIZE - len);
-}
-
-/*
  * Check for virtual address in kernel space.
  */
-static int arch_check_va_in_kernelspace(unsigned long va, u8 hbp_len)
+int arch_check_bp_in_kernelspace(struct perf_event *bp)
 {
 	unsigned int len;
+	unsigned long va;
+	struct arch_hw_breakpoint *info = counter_arch_bp(bp);
 
-	len = get_hbp_len(hbp_len);
+	va = info->address;
+	len = get_hbp_len(info->len);
 
 	return (va >= TASK_SIZE) && ((va + len - 1) >= TASK_SIZE);
 }
@@ -319,8 +310,7 @@ static int arch_build_bp_info(struct per
 /*
  * Validate the arch-specific HW Breakpoint register settings
  */
-int arch_validate_hwbkpt_settings(struct perf_event *bp,
-				  struct task_struct *tsk)
+int arch_validate_hwbkpt_settings(struct perf_event *bp)
 {
 	struct arch_hw_breakpoint *info = counter_arch_bp(bp);
 	unsigned int align;
@@ -333,16 +323,6 @@ int arch_validate_hwbkpt_settings(struct
 
 	ret = -EINVAL;
 
-	if (info->type == X86_BREAKPOINT_EXECUTE)
-		/*
-		 * Ptrace-refactoring code
-		 * For now, we'll allow instruction breakpoint only for user-space
-		 * addresses
-		 */
-		if ((!arch_check_va_in_userspace(info->address, info->len)) &&
-			info->len != X86_BREAKPOINT_EXECUTE)
-			return ret;
-
 	switch (info->len) {
 	case X86_BREAKPOINT_LEN_1:
 		align = 0;
@@ -373,15 +353,6 @@ int arch_validate_hwbkpt_settings(struct
 	if (info->address & align)
 		return -EINVAL;
 
-	/* Check that the virtual address is in the proper range */
-	if (tsk) {
-		if (!arch_check_va_in_userspace(info->address, info->len))
-			return -EFAULT;
-	} else {
-		if (!arch_check_va_in_kernelspace(info->address, info->len))
-			return -EFAULT;
-	}
-
 	return 0;
 }
 
--- a/kernel/hw_breakpoint.c
+++ b/kernel/hw_breakpoint.c
@@ -308,6 +308,28 @@ int dbg_release_bp_slot(struct perf_even
 	return 0;
 }
 
+static int validate_hw_breakpoint(struct perf_event *bp)
+{
+	int ret;
+
+	ret = arch_validate_hwbkpt_settings(bp);
+	if (ret)
+		return ret;
+
+	if (arch_check_bp_in_kernelspace(bp)) {
+		if (bp->attr.exclude_kernel)
+			return -EINVAL;
+		/*
+		 * Don't let unprivileged users set a breakpoint in the trap
+		 * path to avoid trap recursion attacks.
+		 */
+		if (!capable(CAP_SYS_ADMIN))
+			return -EPERM;
+	}
+
+	return 0;
+}
+
 int register_perf_hw_breakpoint(struct perf_event *bp)
 {
 	int ret;
@@ -316,7 +338,7 @@ int register_perf_hw_breakpoint(struct p
 	if (ret)
 		return ret;
 
-	ret = arch_validate_hwbkpt_settings(bp, bp->ctx->task);
+	ret = validate_hw_breakpoint(bp);
 
 	return ret;
 }
@@ -359,7 +381,7 @@ int modify_user_hw_breakpoint(struct per
 	if (attr->disabled)
 		goto end;
 
-	err = arch_validate_hwbkpt_settings(bp, bp->ctx->task);
+	err = validate_hw_breakpoint(bp);
 	if (!err)
 		perf_event_enable(bp);
 
