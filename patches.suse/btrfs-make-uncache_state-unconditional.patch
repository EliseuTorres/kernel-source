From: Chris Mason <chris.mason@oracle.com>
Date: Tue, 12 Apr 2011 13:57:39 -0400
Patch-mainline: yes
References: FATE#306586
Subject: [PATCH] Btrfs: make uncache_state unconditional

The extent_io code can take cached pointers into the extent state trees,
and these can make lookups much faster in common operations.  The
caching only happens when specific bits are set that prevent merging
and splitting of the extent state.

A help function was added to uncache the state, and it was testing
the same set of conditionals.  This can leak in very strange corner
cases where the lock bit goes away unexpectedly.

The uncaching should be unconditional.  Once we have a ref on the
extent we should always give it up.

Signed-off-by: Chris Mason <chris.mason@oracle.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/extent_io.c |    8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@ -695,10 +695,8 @@ static void uncache_state(struct extent_
 {
 	if (cached_ptr && (*cached_ptr)) {
 		struct extent_state *state = *cached_ptr;
-		if (state->state & (EXTENT_IOBITS | EXTENT_BOUNDARY)) {
-			*cached_ptr = NULL;
-			free_extent_state(state);
-		}
+		*cached_ptr = NULL;
+		free_extent_state(state);
 	}
 }
 
@@ -1765,7 +1763,7 @@ static void end_bio_extent_readpage(stru
 
 		spin_lock(&tree->lock);
 		state = find_first_extent_bit_state(tree, start, 0);
-		if (state) {
+		if (state && state->start == start) {
 			/*
 			 * take a reference on the state, unlock will drop
 			 * the ref
