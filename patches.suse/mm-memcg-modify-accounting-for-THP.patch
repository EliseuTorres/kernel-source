From: Mel Gorman <mgorman@suse.de>
Date: Mon, 23 May 2011 16:51:43 +0100
Subject: [PATCH] memcg: modify accounting function for supporting THP better reimplementation
References: THP + memcg (fate #311931)
Patch-mainline: yes
Commit-ID: e401f1761c0b01966e36e41e2c385d455a7b44ee

mem_cgroup_charge_statisics() was designed for charging a page but now,
we have transparent hugepage.  To fix problems (in following patch)
it's required to change the function to get the number of pages as
its arguments.

The new function gets following as argument.
 - type of page rather than 'pc' - size of page which is accounted.

This is a reimplementation as memcg changed too much in mainline.

Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Cc: Daisuke Nishimura <nishimura@mxp.nes.nec.co.jp>
Cc: Balbir Singh <balbir@linux.vnet.ibm.com>
Cc: Johannes Weiner <hannes@cmpxchg.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/memcontrol.c |   23 +++++++++++------------
 1 files changed, 11 insertions(+), 12 deletions(-)

diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index eea22ed..0c0865d 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -501,26 +501,25 @@ static void mem_cgroup_swap_statistics(struct mem_cgroup *mem,
 
 static void mem_cgroup_charge_statistics(struct mem_cgroup *mem,
 					 struct page_cgroup *pc,
-					 bool charge)
+					 bool file, int nr_pages)
 {
-	int val = (charge) ? 1 : -1;
 	struct mem_cgroup_stat *stat = &mem->stat;
 	struct mem_cgroup_stat_cpu *cpustat;
 	int cpu = get_cpu();
 
 	cpustat = &stat->cpustat[cpu];
-	if (PageCgroupCache(pc))
-		__mem_cgroup_stat_add_safe(cpustat, MEM_CGROUP_STAT_CACHE, val);
+	if (file)
+		__mem_cgroup_stat_add_safe(cpustat, MEM_CGROUP_STAT_CACHE, nr_pages);
 	else
-		__mem_cgroup_stat_add_safe(cpustat, MEM_CGROUP_STAT_RSS, val);
+		__mem_cgroup_stat_add_safe(cpustat, MEM_CGROUP_STAT_RSS, nr_pages);
 
-	if (charge)
+	if (nr_pages > 0)
 		__mem_cgroup_stat_add_safe(cpustat,
-				MEM_CGROUP_STAT_PGPGIN_COUNT, 1);
+				MEM_CGROUP_STAT_PGPGIN_COUNT, nr_pages);
 	else
 		__mem_cgroup_stat_add_safe(cpustat,
-				MEM_CGROUP_STAT_PGPGOUT_COUNT, 1);
-	__mem_cgroup_stat_add_safe(cpustat, MEM_CGROUP_STAT_EVENTS, 1);
+				MEM_CGROUP_STAT_PGPGOUT_COUNT, nr_pages);
+	__mem_cgroup_stat_add_safe(cpustat, MEM_CGROUP_STAT_EVENTS, nr_pages);
 	put_cpu();
 }
 
@@ -1644,7 +1643,7 @@ static void __mem_cgroup_move_account(struct page_cgroup *pc,
 
 	if (!mem_cgroup_is_root(from))
 		res_counter_uncharge(&from->res, PAGE_SIZE);
-	mem_cgroup_charge_statistics(from, pc, false);
+	mem_cgroup_charge_statistics(from, pc, false, -1);
 
 	page = pc->page;
 	if (page_mapped(page) && !PageAnon(page)) {
@@ -1668,7 +1667,7 @@ static void __mem_cgroup_move_account(struct page_cgroup *pc,
 
 	css_get(&to->css);
 	pc->mem_cgroup = to;
-	mem_cgroup_charge_statistics(to, pc, true);
+	mem_cgroup_charge_statistics(to, pc, true, 1);
 	/*
 	 * We charges against "to" which may not have any tasks. Then, "to"
 	 * can be under rmdir(). But in current implementation, caller of
@@ -2062,7 +2061,7 @@ __mem_cgroup_uncharge_common(struct page *page, enum charge_type ctype)
 	if (ctype == MEM_CGROUP_CHARGE_TYPE_SWAPOUT)
 		mem_cgroup_swap_statistics(mem, true);
 	for (i = 0; i < count; i++)
-		mem_cgroup_charge_statistics(mem, pc, false);
+		mem_cgroup_charge_statistics(mem, pc, false, -1);
 
 	ClearPageCgroupUsed(pc);
 	/*
