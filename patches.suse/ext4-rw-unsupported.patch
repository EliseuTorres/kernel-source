From: Jeff Mahoney <jeffm@suse.com>
Subject: ext4: force read-only unless rw=1 module option is used
References: fate#314864
Patch-mainline: never

SLE11 only supports ext4 in read-only mode for migration purposes.
This patch forces mounts read-only and issues a message explaining why.

However, since some users still need to use ext4 in read-write mode,
we'll allow read-write mounts when the rw=1 module parameter is passed
during module load. This will taint the kernel and module as unsupported
and also issues a message explaining why.

This supersedes the ext4-writable KMP implementation.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/ext4/super.c |   55 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 55 insertions(+)

--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -53,6 +53,8 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/ext4.h>
 
+static int allow_rw = 0;
+
 static struct proc_dir_entry *ext4_proc_root;
 static struct kset *ext4_kset;
 static struct ext4_lazy_init *ext4_li_info;
@@ -82,6 +84,8 @@ static int ext4_feature_set_ok(struct su
 static void ext4_destroy_lazyinit_thread(void);
 static void ext4_unregister_li_request(struct super_block *sb);
 static void ext4_clear_request_list(void);
+static int ext4_handle_unsupported_rw(struct super_block *sb,
+				      unsigned long flags);
 
 #if !defined(CONFIG_EXT2_FS) && !defined(CONFIG_EXT2_FS_MODULE) && defined(CONFIG_EXT4_USE_FOR_EXT23)
 static struct file_system_type ext2_fs_type = {
@@ -3124,6 +3128,8 @@ static int ext4_fill_super(struct super_
 		goto cantfind_ext4;
 	sbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);
 
+	sb->s_flags |= ext4_handle_unsupported_rw(sb, sb->s_flags);
+
 	/* Set defaults before we parse the mount options */
 	def_mount_opts = le32_to_cpu(es->s_default_mount_opts);
 	set_opt(sb, INIT_INODE_TABLE);
@@ -4317,6 +4323,8 @@ static int ext4_remount(struct super_blo
 	if (sbi->s_journal && sbi->s_journal->j_task->io_context)
 		journal_ioprio = sbi->s_journal->j_task->io_context->ioprio;
 
+	*flags |= ext4_handle_unsupported_rw(sb, *flags);
+
 	/*
 	 * Allow the "check" option to be passed as a remount option.
 	 */
@@ -5031,3 +5039,50 @@ MODULE_DESCRIPTION("Fourth Extended File
 MODULE_LICENSE("GPL");
 module_init(ext4_init_fs)
 module_exit(ext4_exit_fs)
+
+/* Taint only if a read-write mount is actually used. */
+static int ext4_handle_unsupported_rw(struct super_block *sb,
+				      unsigned long flags)
+{
+	if (flags & MS_RDONLY)
+		return 0;
+
+	if (allow_rw) {
+		ext4_msg(sb, KERN_INFO,
+			 "allowing unsupported read-write mount.");
+		add_taint(TAINT_NO_SUPPORT);
+#ifdef CONFIG_EXT4_FS_MODULE
+		THIS_MODULE->taints |= (1 << TAINT_NO_SUPPORT);
+#endif
+		return 0;
+	}
+
+	ext4_msg(sb, KERN_INFO,
+		 "ext4 is supported in read-only mode only");
+	return MS_RDONLY;
+}
+
+static int ext4_set_rw(const char *buffer, struct kernel_param *kp)
+{
+	char *end;
+	long val = simple_strtoul(buffer, &end, 10);
+	if (end == buffer)
+		return -EINVAL;
+	if (val != 0 && val != 1)
+		return -EINVAL;
+	if (allow_rw && val == 0) {
+		pr_warn("ext4: can't set read-write ext4 module read-only\n");
+	} else if (!allow_rw && val == 1) {
+		pr_warn("ext4: setting module read-write (unsupported)\n");
+		allow_rw = 1;
+	}
+	return 0;
+}
+
+static int ext4_get_rw(char *buffer, struct kernel_param *kp)
+{
+	return sprintf(buffer, "%d", allow_rw);
+}
+
+module_param_call(rw, ext4_set_rw, ext4_get_rw, NULL, 0644);
+MODULE_PARM_DESC(rw, "Allow read-write file systems (marks kernel as unsupported when mounted read-write)");
