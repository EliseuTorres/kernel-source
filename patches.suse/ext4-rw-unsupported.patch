From: Jeff Mahoney <jeffm@suse.com>
Subject: ext4: force read-only unless rw=1 module option is used
References: fate#314864
Patch-mainline: never

SLE11 only supports ext4 in read-only mode for migration purposes.
This patch forces mounts read-only and issues a message explaining why.

However, since some users still need to use ext4 in read-write mode,
we'll allow read-write mounts when the rw=1 module parameter is passed
during module load. This will taint the kernel and module as unsupported
and also issues a message explaining why.

This can eliminate the ext4-writable KMP implementation by just
requiring the 'options ext4 rw=1' line in a file in /etc/modprobe.d.

However, if there are both SLE 11 SP2 and SP3 kernels installed, there
may arise a conflict so we can't just convert ext4-writeable to add that
line and replace the KMP. Thus, if ext4 is built using as the
ext4-writeable KMP, it will set allow_rw to true by default.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/ext4/super.c |   59 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 59 insertions(+)

--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -53,6 +53,12 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/ext4.h>
 
+#ifdef CONFIG_EXT4_FS_RW
+static bool allow_rw = true;
+#else
+static bool allow_rw = false;
+#endif
+
 static struct proc_dir_entry *ext4_proc_root;
 static struct kset *ext4_kset;
 static struct ext4_lazy_init *ext4_li_info;
@@ -82,6 +88,8 @@ static int ext4_feature_set_ok(struct su
 static void ext4_destroy_lazyinit_thread(void);
 static void ext4_unregister_li_request(struct super_block *sb);
 static void ext4_clear_request_list(void);
+static int ext4_handle_unsupported_rw(struct super_block *sb,
+				      unsigned long flags);
 
 #if !defined(CONFIG_EXT2_FS) && !defined(CONFIG_EXT2_FS_MODULE) && defined(CONFIG_EXT4_USE_FOR_EXT23)
 static struct file_system_type ext2_fs_type = {
@@ -3124,6 +3132,8 @@ static int ext4_fill_super(struct super_
 		goto cantfind_ext4;
 	sbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);
 
+	sb->s_flags |= ext4_handle_unsupported_rw(sb, sb->s_flags);
+
 	/* Set defaults before we parse the mount options */
 	def_mount_opts = le32_to_cpu(es->s_default_mount_opts);
 	set_opt(sb, INIT_INODE_TABLE);
@@ -4317,6 +4327,8 @@ static int ext4_remount(struct super_blo
 	if (sbi->s_journal && sbi->s_journal->j_task->io_context)
 		journal_ioprio = sbi->s_journal->j_task->io_context->ioprio;
 
+	*flags |= ext4_handle_unsupported_rw(sb, *flags);
+
 	/*
 	 * Allow the "check" option to be passed as a remount option.
 	 */
@@ -5031,3 +5043,50 @@ MODULE_DESCRIPTION("Fourth Extended File
 MODULE_LICENSE("GPL");
 module_init(ext4_init_fs)
 module_exit(ext4_exit_fs)
+
+/* Taint only if a read-write mount is actually used. */
+static int ext4_handle_unsupported_rw(struct super_block *sb,
+				      unsigned long flags)
+{
+	if (flags & MS_RDONLY)
+		return 0;
+
+	if (allow_rw) {
+		ext4_msg(sb, KERN_INFO,
+			 "allowing unsupported read-write mount.");
+		taint_unsupported();
+		return 0;
+	}
+
+	ext4_msg(sb, KERN_INFO,
+		 "ext4 is supported in read-only mode only");
+	return MS_RDONLY;
+}
+
+static int ext4_set_rw(const char *buffer, const struct kernel_param *kp)
+{
+	int ret;
+	struct kernel_param dummy_kp = *kp;
+	bool newval;
+
+	dummy_kp.arg = &newval;
+
+	ret = param_set_bool(buffer, &dummy_kp);
+	if (ret)
+		return ret;
+
+	if (allow_rw && !newval) {
+		pr_warn("ext4: can't set read-write ext4 module read-only\n");
+	} else if (!allow_rw && newval) {
+		pr_warn("ext4: setting module read-write (unsupported)\n");
+		allow_rw = true;
+	}
+	return 0;
+}
+
+static struct kernel_param_ops ext4_rw_param_ops = {
+	.set = ext4_set_rw,
+	.get = param_get_bool,
+};
+module_param_cb(rw, &ext4_rw_param_ops, &allow_rw, 0644);
+MODULE_PARM_DESC(rw, "Allow read-write file systems (marks kernel as unsupported when mounted read-write)");
