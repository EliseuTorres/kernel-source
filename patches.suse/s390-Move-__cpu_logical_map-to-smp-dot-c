Subject: [S390] Move __cpu_logical_map to smp.c
From: Heiko Carstens <heiko.carstens@de.ibm.com>
Date: Wed Jan 13 20:44:37 2010 +0100
Git-commit: fb380aadfe34e8d3ce628cb3e386882351940874
References: FATE#311860
Patch-mainline: v2.6.33-rc5

Finally move it to the place where it belongs to and make get rid of
it for !CONFIG_SMP.

Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: Mike Galbraith <mgalbraith@suse.de>

---
 arch/s390/include/asm/sigp.h |   18 +++++++++++++-----
 arch/s390/kernel/setup.c     |    1 -
 arch/s390/kernel/smp.c       |    3 +++
 arch/s390/kernel/topology.c  |    2 +-
 arch/s390/lib/spinlock.c     |    2 +-
 5 files changed, 18 insertions(+), 8 deletions(-)

Index: linux-2.6.32-SLE11-SP2/arch/s390/include/asm/sigp.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/s390/include/asm/sigp.h
+++ linux-2.6.32-SLE11-SP2/arch/s390/include/asm/sigp.h
@@ -15,12 +15,20 @@
 #ifndef __SIGP__
 #define __SIGP__
 
-#include <asm/ptrace.h>
-#include <asm/atomic.h>
+#include <asm/system.h>
 
 /* get real cpu address from logical cpu number */
 extern int __cpu_logical_map[];
 
+static inline int cpu_logical_map(int cpu)
+{
+#ifdef CONFIG_SMP
+	return __cpu_logical_map[cpu];
+#else
+	return stap();
+#endif
+}
+
 typedef enum
 {
 	sigp_unassigned=0x0,
@@ -79,7 +87,7 @@ signal_processor(__u16 cpu_addr, sigp_or
 		"	ipm	%0\n"
 		"	srl	%0,28\n"
 		:	"=d"	(ccode)
-		: "d" (reg1), "d" (__cpu_logical_map[cpu_addr]),
+		: "d" (reg1), "d" (cpu_logical_map(cpu_addr)),
 		  "a" (order_code) : "cc" , "memory");
 	return ccode;
 }
@@ -98,7 +106,7 @@ signal_processor_p(__u32 parameter, __u1
 		"	ipm	%0\n"
 		"	srl	%0,28\n"
 		: "=d" (ccode)
-		: "d" (reg1), "d" (__cpu_logical_map[cpu_addr]),
+		: "d" (reg1), "d" (cpu_logical_map(cpu_addr)),
 		  "a" (order_code) : "cc" , "memory");
 	return ccode;
 }
@@ -118,7 +126,7 @@ signal_processor_ps(__u32 *statusptr, __
 		"	ipm	%0\n"
 		"	srl	%0,28\n"
 		: "=d" (ccode), "+d" (reg1)
-		: "d" (__cpu_logical_map[cpu_addr]), "a" (order_code)
+		: "d" (cpu_logical_map(cpu_addr)), "a" (order_code)
 		: "cc" , "memory");
 	*statusptr = reg1;
 	return ccode;
Index: linux-2.6.32-SLE11-SP2/arch/s390/kernel/setup.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/s390/kernel/setup.c
+++ linux-2.6.32-SLE11-SP2/arch/s390/kernel/setup.c
@@ -87,7 +87,6 @@ unsigned long elf_hwcap = 0;
 char elf_platform[ELF_PLATFORM_SIZE];
 
 struct mem_chunk __initdata memory_chunk[MEMORY_CHUNKS];
-int __cpu_logical_map[NR_CPUS]; /* logical cpu to cpu address */
 
 int __initdata memory_end_set;
 unsigned long __initdata memory_end;
Index: linux-2.6.32-SLE11-SP2/arch/s390/kernel/smp.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/s390/kernel/smp.c
+++ linux-2.6.32-SLE11-SP2/arch/s390/kernel/smp.c
@@ -52,6 +52,9 @@
 #include <asm/cpu.h>
 #include "entry.h"
 
+/* logical cpu to cpu address */
+int __cpu_logical_map[NR_CPUS];
+
 static struct task_struct *current_set[NR_CPUS];
 
 static u8 smp_cpu_type;
Index: linux-2.6.32-SLE11-SP2/arch/s390/kernel/topology.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/s390/kernel/topology.c
+++ linux-2.6.32-SLE11-SP2/arch/s390/kernel/topology.c
@@ -114,7 +114,7 @@ static void add_cpus_to_core(struct tl_c
 
 		rcpu = CPU_BITS - 1 - cpu + tl_cpu->origin;
 		for_each_present_cpu(lcpu) {
-			if (__cpu_logical_map[lcpu] == rcpu) {
+			if (cpu_logical_map(lcpu) == rcpu) {
 				cpu_set(lcpu, core->mask);
 				smp_cpu_polarization[lcpu] = tl_cpu->pp;
 			}
Index: linux-2.6.32-SLE11-SP2/arch/s390/lib/spinlock.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/s390/lib/spinlock.c
+++ linux-2.6.32-SLE11-SP2/arch/s390/lib/spinlock.c
@@ -34,7 +34,7 @@ static inline void _raw_yield_cpu(int cp
 {
 	if (MACHINE_HAS_DIAG9C)
 		asm volatile("diag %0,0,0x9c"
-			     : : "d" (__cpu_logical_map[cpu]));
+			     : : "d" (cpu_logical_map(cpu)));
 	else
 		_raw_yield();
 }

