From: Miklos Szeredi <mszeredi@suse.cz>
Date: Mon, 28 Apr 2014 14:19:23 +0200
Subject: fuse: clean up fsync
Git-commit: 22401e7b7a686bff02549cd648ba6f73f8dba868
Patch-mainline: v3.15-rc5
References: FATE#317677

Don't need to start I/O twice (once without i_mutex and one within).

Also make sure that even if the userspace filesystem doesn't support FSYNC
we do all the steps other than sending the message.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
---
 fs/fuse/file.c |   11 +++--------
 1 file changed, 3 insertions(+), 8 deletions(-)

--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -464,13 +464,6 @@ int fuse_fsync_common(struct file *file,
 	if (is_bad_inode(inode))
 		return -EIO;
 
-	err = filemap_write_and_wait_range(inode->i_mapping, start, end);
-	if (err)
-		return err;
-
-	if ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))
-		return 0;
-
 	mutex_lock(&inode->i_mutex);
 
 	/*
@@ -478,7 +471,7 @@ int fuse_fsync_common(struct file *file,
 	 * wait for all outstanding writes, before sending the FSYNC
 	 * request.
 	 */
-	err = write_inode_now(inode, 0);
+	err = filemap_write_and_wait_range(inode->i_mapping, start, end);
 	if (err)
 		goto out;
 
@@ -489,6 +482,8 @@ int fuse_fsync_common(struct file *file,
 		if (err)
 			goto out;
 	}
+	if ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))
+		goto out;
 
 	req = fuse_get_req_nopages(fc);
 	if (IS_ERR(req)) {
