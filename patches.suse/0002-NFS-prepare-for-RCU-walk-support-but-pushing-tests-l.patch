From: NeilBrown <neilb@suse.de>
Date: Tue, 4 Mar 2014 15:06:58 +1100
Patch-mainline: submitted 2014-07-24
References: bnc#866130
Subject: [PATCH 2/8] NFS: prepare for RCU-walk support but pushing tests later
 in code.

nfs_lookup_revalidate, nfs_open_revalidate, and nfs_permission
all need to understand and handle RCU-walk for NFS to gain the
benefits of RCU-walk for cached information.

Currently these functions all immediately return -ECHILD
if the relevant flag (LOOKUP_RCU or IPERM_FLAG_RCU) is set.

This patch pushes those tests later in the code so that we only abort
immediately before we enter rcu-unsafe code.  As subsequent patches
make that rcu-unsafe code rcu-safe, several of these new tests will
disappear.

With this patch there are several paths through the code which will no
longer return -ECHILD during an RCU-walk.  However these are mostly
error paths or other uninteresting cases.

A noteworthy change in nfs_lookup_revalidate is that we don't take
(or put) the reference to ->d_parent when LOOKUP_RCU is set.
Rather we rcu_dereference ->d_parent, and check that ->d_inode
is not NULL.  We also check that ->d_parent hasn't changed after
all the tests.

In nfs4_lookup_revalidate we simple avoid testing LOOKUP_RCU on the
path that simply calls nfs_lookup_revalidate() as that function
already performs the required test.

Signed-off-by: NeilBrown <neilb@suse.de>
---
 fs/nfs/dir.c |   47 +++++++++++++++++++++++++++++++++++------------
 1 file changed, 35 insertions(+), 12 deletions(-)

--- linux-3.0-SLE11-SP3.orig/fs/nfs/dir.c
+++ linux-3.0-SLE11-SP3/fs/nfs/dir.c
@@ -1129,25 +1129,34 @@ static int nfs_lookup_revalidate(struct
 	struct nfs_fattr *fattr = NULL;
 	int error;
 
-	if (nd && (nd->flags & LOOKUP_RCU))
-		return -ECHILD;
-
 	if (nd && (nd->flags & LOOKUP_UMOUNT))
 		/* on unmount, assume all dentries are correct */
 		return 1;
 
-	parent = dget_parent(dentry);
-	dir = parent->d_inode;
+	if (nd && (nd->flags & LOOKUP_RCU)) {
+		parent = ACCESS_ONCE(dentry->d_parent);
+		dir = ACCESS_ONCE(parent->d_inode);
+		if (!dir)
+			return -ECHILD;
+	} else {
+		parent = dget_parent(dentry);
+		dir = parent->d_inode;
+	}
 	nfs_inc_stats(dir, NFSIOS_DENTRYREVALIDATE);
 	inode = dentry->d_inode;
 
 	if (!inode) {
+		if (nd && (nd->flags & LOOKUP_RCU))
+			return -ECHILD;
+
 		if (nfs_neg_need_reval(dir, dentry, nd))
 			goto out_bad;
 		goto out_valid_noent;
 	}
 
 	if (is_bad_inode(inode)) {
+		if (nd && (nd->flags & LOOKUP_RCU))
+			return -ECHILD;
 		dfprintk(LOOKUPCACHE, "%s: %s/%s has dud inode\n",
 				__func__, dentry->d_parent->d_name.name,
 				dentry->d_name.name);
@@ -1157,6 +1166,9 @@ static int nfs_lookup_revalidate(struct
 	if (nfs_have_delegation(inode, FMODE_READ))
 		goto out_set_verifier;
 
+	if (nd && (nd->flags & LOOKUP_RCU))
+		return -ECHILD;
+
 	/* Force a full look up iff the parent directory has changed */
 	if (!nfs_is_exclusive_create(dir, nd) && nfs_check_verifier(dir, dentry)) {
 		if (nfs_server_capable(dir, NFS_CAP_READDIRPLUS)
@@ -1208,7 +1220,11 @@ out_set_verifier:
 	/* Success: notify readdir to use READDIRPLUS */
 	nfs_advise_use_readdirplus(dir);
  out_valid_noent:
-	dput(parent);
+	if (nd && (nd->flags & LOOKUP_RCU)) {
+		if (parent != ACCESS_ONCE(dentry->d_parent))
+			return -ECHILD;
+	} else
+		dput(parent);
 	dfprintk(LOOKUPCACHE, "NFS: %s(%s/%s) is valid\n",
 			__func__, dentry->d_parent->d_name.name,
 			dentry->d_name.name);
@@ -1216,6 +1232,7 @@ out_set_verifier:
 out_zap_parent:
 	nfs_zap_caches(dir);
  out_bad:
+	WARN_ON(nd && (nd->flags & LOOKUP_RCU));
 	nfs_free_fattr(fattr);
 	nfs_free_fhandle(fhandle);
 	nfs_mark_for_revalidate(dir);
@@ -1236,6 +1253,7 @@ out_zap_parent:
 			dentry->d_name.name);
 	return 0;
 out_error:
+	WARN_ON(nd && (nd->flags & LOOKUP_RCU));
 	nfs_free_fattr(fattr);
 	nfs_free_fhandle(fhandle);
 	dput(parent);
@@ -1559,9 +1577,6 @@ static int nfs_open_revalidate(struct de
 	struct nfs_open_context *ctx;
 	int openflags, ret = 0;
 
-	if (nd && (nd->flags & LOOKUP_RCU))
-		return -ECHILD;
-
 	inode = dentry->d_inode;
 	if (!is_atomic_open(nd) || d_mountpoint(dentry))
 		goto no_open;
@@ -1570,6 +1585,9 @@ static int nfs_open_revalidate(struct de
 	 * optimize away revalidation of negative dentries.
 	 */
 	if (inode == NULL) {
+		if (nd && (nd->flags & LOOKUP_RCU))
+			return -ECHILD;
+
 		parent = dget_parent(dentry);
 		dir = parent->d_inode;
 
@@ -1588,6 +1606,8 @@ static int nfs_open_revalidate(struct de
 	/* We can't create new files, or truncate existing ones here */
 	openflags &= ~(O_CREAT|O_EXCL|O_TRUNC);
 
+	if (nd && (nd->flags & LOOKUP_RCU))
+		return -ECHILD;
 	ctx = nameidata_to_nfs_open_context(dentry, nd);
 	ret = PTR_ERR(ctx);
 	if (IS_ERR(ctx))
@@ -2359,9 +2379,6 @@ int nfs_permission(struct inode *inode,
 	struct rpc_cred *cred;
 	int res = 0;
 
-	if (flags & IPERM_FLAG_RCU)
-		return -ECHILD;
-
 	nfs_inc_stats(inode, NFSIOS_VFSACCESS);
 
 	if ((mask & (MAY_READ | MAY_WRITE | MAY_EXEC)) == 0)
@@ -2393,6 +2410,9 @@ force_lookup:
 	if (!NFS_PROTO(inode)->access)
 		goto out_notsup;
 
+	if (flags & IPERM_FLAG_RCU)
+		return -ECHILD;
+
 	cred = rpc_lookup_cred();
 	if (!IS_ERR(cred)) {
 		res = nfs_do_access(inode, cred, mask);
@@ -2407,6 +2427,9 @@ out:
 		inode->i_sb->s_id, inode->i_ino, mask, res);
 	return res;
 out_notsup:
+	if (flags & IPERM_FLAG_RCU)
+		return -ECHILD;
+
 	res = nfs_revalidate_inode(NFS_SERVER(inode), inode);
 	if (res == 0)
 		res = generic_permission(inode, mask, flags, NULL);
