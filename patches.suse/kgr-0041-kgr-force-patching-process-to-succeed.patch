From: Miroslav Benes <mbenes@suse.cz>
Date: Thu, 16 Oct 2014 10:23:13 +0200
Subject: kgr: force patching process to succeed
Patch-mainline: no
References: fate#313296

Patching process can be blocked by kernel thread which has not be amended with
kgr_task_safe() call. Thus we need to have a possibility to mark such thread as
migrated on request.

The patch makes the global attribute kgr_in_progress in kgraft sysfs directory
writable. 'echo 0 > /sys/kernel/kgraft/in_progress' clears the
TIF_KGR_IN_PROGRESS flag for all processes. With that patching process should
finish successfully.

Clearing of the flag is done using kgr_task_safe(). After that it is necessary
to keep the patches list and stuff in the correct state and set internal
kgr_in_progress flag to false. This is equivalent to finalizing, so
kgr_finalize() is called.

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Reviewed-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |  1 +
 kernel/kgraft.c        | 62 +++++++++++++++++++++++++++++++++++++++++++++-----
 kernel/kgraft_files.c  | 14 +++++++++++-
 3 files changed, 70 insertions(+), 7 deletions(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index f02d8025588b..8aa841d95019 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -115,6 +115,7 @@ extern bool kgr_in_progress;
 extern int kgr_patch_kernel(struct kgr_patch *);
 extern void kgr_patch_remove(struct kgr_patch *);
 
+extern int kgr_unmark_processes(void);
 extern int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force);
 extern void kgr_module_init(const struct module *mod);
 extern int kgr_patch_dir_add(struct kgr_patch *patch);
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 043f22e442b2..40d4be5a582a 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -200,15 +200,11 @@ static void kgr_replace_all(void)
 	}
 }
 
-static void kgr_finalize(void)
+static struct kgr_patch *__kgr_finalize(void)
 {
 	struct kgr_patch_fun *patch_fun;
 	struct kgr_patch *p_to_revert = NULL;
 
-	pr_info("kgr succeeded\n");
-
-	mutex_lock(&kgr_in_progress_lock);
-
 	kgr_for_each_patch_fun(kgr_patch, patch_fun) {
 		int ret = kgr_patch_code(patch_fun, true, kgr_revert);
 
@@ -234,12 +230,26 @@ static void kgr_finalize(void)
 	} else {
 		/*
 		 * kgr_in_progress is not cleared to avoid races after the
-		 * unlock below. The force flag is set instead.
+		 * unlock in kgr_finalize() below. The force flag is set
+		 * instead.
 		 */
 		p_to_revert = list_first_entry(&kgr_to_revert, struct kgr_patch,
 				list);
 	}
 
+	return p_to_revert;
+}
+
+static void kgr_finalize(void)
+{
+	struct kgr_patch *p_to_revert;
+
+	pr_info("kgr succeeded\n");
+
+	mutex_lock(&kgr_in_progress_lock);
+
+	p_to_revert = __kgr_finalize();
+
 	mutex_unlock(&kgr_in_progress_lock);
 
 	if (p_to_revert) {
@@ -267,6 +277,46 @@ static void kgr_work_fn(struct work_struct *work)
 	kgr_finalize();
 }
 
+int kgr_unmark_processes(void)
+{
+	struct task_struct *p;
+	struct kgr_patch *p_to_revert;
+
+	mutex_lock(&kgr_in_progress_lock);
+
+	if (!kgr_in_progress) {
+		pr_info("kgr: no patching is in progress\n");
+		mutex_unlock(&kgr_in_progress_lock);
+		return -1;
+	}
+
+	read_lock(&tasklist_lock);
+
+	for_each_process(p)
+		kgr_task_safe(p);
+
+	read_unlock(&tasklist_lock);
+
+	p_to_revert = __kgr_finalize();
+	mutex_unlock(&kgr_in_progress_lock);
+
+	if (p_to_revert) {
+		int ret = kgr_modify_kernel(p_to_revert, true, true);
+		if (ret)
+			pr_err("kgr: continual revert of %s failedwith %d, but continuing\n",
+					p_to_revert->name, ret);
+	}
+
+	/*
+	 * Patching was forced to finish, everything is back in shape via
+	 * kgr_finalize. Last thing is to cancel the workqueue, otherwise
+	 * kgr_finalize would be called again.
+	 */
+	cancel_delayed_work_sync(&kgr_work);
+
+	return 0;
+}
+
 static void kgr_handle_processes(void)
 {
 	struct task_struct *p;
diff --git a/kernel/kgraft_files.c b/kernel/kgraft_files.c
index 0a39c2434d70..f5853c5ba074 100644
--- a/kernel/kgraft_files.c
+++ b/kernel/kgraft_files.c
@@ -153,7 +153,19 @@ static ssize_t in_progress_show(struct kobject *kobj,
 	return snprintf(buf, PAGE_SIZE, "%d\n", kgr_in_progress);
 }
 
-static struct kobj_attribute kgr_attr_in_progress = __ATTR_RO(in_progress);
+static ssize_t in_progress_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	if (count == 0 || buf[0] != '0')
+		return -EINVAL;
+
+	WARN(!kgr_unmark_processes(),
+		"kgr: all processes marked migrated on admin's request\n");
+
+	return count;
+}
+
+static struct kobj_attribute kgr_attr_in_progress = __ATTR_RW(in_progress);
 
 static struct attribute *kgr_sysfs_entries[] = {
 	&kgr_attr_in_progress.attr,
-- 
2.1.2

