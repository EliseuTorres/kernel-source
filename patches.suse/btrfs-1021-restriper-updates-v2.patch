From: Ilya Dryomov <idryomov@gmail.com>
Date: Tue, 10 Jan 2012 20:12:04 +0200
Patch-mainline: pending
References: FATE#306586
Subject: [PATCH] Btrfs: restriper updates

Cumulative updates to restiper patchset.

Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/ioctl.c   |   51 +++++++++++++++++++++++++++++++++++++++++++++++++++
 fs/btrfs/ioctl.h   |    6 ++++++
 fs/btrfs/volumes.c |   35 +++++++++++++++++++++++++++++++++--
 fs/btrfs/volumes.h |    3 +++
 4 files changed, 93 insertions(+), 2 deletions(-)

diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index de0bebe..6834be4 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -3076,10 +3076,37 @@ out:
 	return ret;
 }
 
+void update_ioctl_balance_args(struct btrfs_fs_info *fs_info, int lock,
+			       struct btrfs_ioctl_balance_args *bargs)
+{
+	struct btrfs_balance_control *bctl = fs_info->balance_ctl;
+
+	bargs->flags = bctl->flags;
+
+	if (atomic_read(&fs_info->balance_running))
+		bargs->state |= BTRFS_BALANCE_STATE_RUNNING;
+	if (atomic_read(&fs_info->balance_pause_req))
+		bargs->state |= BTRFS_BALANCE_STATE_PAUSE_REQ;
+	if (atomic_read(&fs_info->balance_cancel_req))
+		bargs->state |= BTRFS_BALANCE_STATE_CANCEL_REQ;
+
+	memcpy(&bargs->data, &bctl->data, sizeof(bargs->data));
+	memcpy(&bargs->meta, &bctl->meta, sizeof(bargs->meta));
+	memcpy(&bargs->sys, &bctl->sys, sizeof(bargs->sys));
+
+	if (lock) {
+		spin_lock(&fs_info->balance_lock);
+		memcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));
+		spin_unlock(&fs_info->balance_lock);
+	} else {
+		memcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));
+	}
+}
+
 static long btrfs_ioctl_balance(struct btrfs_root *root, void __user *arg)
 {
 	struct btrfs_fs_info *fs_info = root->fs_info;
-	struct btrfs_ioctl_balance_args *bargs = NULL;
+	struct btrfs_ioctl_balance_args *bargs;
 	struct btrfs_balance_control *bctl;
 	int ret;
 
@@ -3092,26 +3119,43 @@ static long btrfs_ioctl_balance(struct btrfs_root *root, void __user *arg)
 	mutex_lock(&fs_info->volume_mutex);
 	mutex_lock(&fs_info->balance_mutex);
 
+	if (arg) {
+		bargs = memdup_user(arg, sizeof(*bargs));
+		if (IS_ERR(bargs)) {
+			ret = PTR_ERR(bargs);
+			goto out;
+		}
+
+		if (bargs->flags & BTRFS_BALANCE_RESUME) {
+			if (!fs_info->balance_ctl) {
+				ret = -ENOTCONN;
+				goto out_bargs;
+			}
+
+			bctl = fs_info->balance_ctl;
+			spin_lock(&fs_info->balance_lock);
+			bctl->flags |= BTRFS_BALANCE_RESUME;
+			spin_unlock(&fs_info->balance_lock);
+
+			goto do_balance;
+		}
+	} else {
+		bargs = NULL;
+	}
+
 	if (fs_info->balance_ctl) {
 		ret = -EINPROGRESS;
-		goto out;
+		goto out_bargs;
 	}
 
 	bctl = kzalloc(sizeof(*bctl), GFP_NOFS);
 	if (!bctl) {
 		ret = -ENOMEM;
-		goto out;
+		goto out_bargs;
 	}
 
 	bctl->fs_info = fs_info;
 	if (arg) {
-		bargs = memdup_user(arg, sizeof(*bargs));
-		if (IS_ERR(bargs)) {
-			kfree(bctl);
-			ret = PTR_ERR(bargs);
-			goto out;
-		}
-
 		memcpy(&bctl->data, &bargs->data, sizeof(bctl->data));
 		memcpy(&bctl->meta, &bargs->meta, sizeof(bctl->meta));
 		memcpy(&bctl->sys, &bargs->sys, sizeof(bctl->sys));
@@ -3122,11 +3166,18 @@ static long btrfs_ioctl_balance(struct btrfs_root *root, void __user *arg)
 		bctl->flags |= BTRFS_BALANCE_TYPE_MASK;
 	}
 
-	ret = btrfs_balance(bctl, 0);
+do_balance:
+	ret = btrfs_balance(bctl, bargs);
 	/*
 	 * bctl is freed in __cancel_balance or in free_fs_info if
 	 * restriper was paused all the way until unmount
 	 */
+	if (arg) {
+		if (copy_to_user(arg, bargs, sizeof(*bargs)))
+			ret = -EFAULT;
+	}
+
+out_bargs:
 	kfree(bargs);
 out:
 	mutex_unlock(&fs_info->balance_mutex);
@@ -3144,8 +3195,6 @@ static long btrfs_ioctl_balance_ctl(struct btrfs_root *root, int cmd)
 		return btrfs_pause_balance(root->fs_info);
 	case BTRFS_BALANCE_CTL_CANCEL:
 		return btrfs_cancel_balance(root->fs_info);
-	case BTRFS_BALANCE_CTL_RESUME:
-		return btrfs_resume_balance(root->fs_info);
 	}
 
 	return -EINVAL;
@@ -3156,14 +3205,13 @@ static long btrfs_ioctl_balance_progress(struct btrfs_root *root,
 {
 	struct btrfs_fs_info *fs_info = root->fs_info;
 	struct btrfs_ioctl_balance_args *bargs;
-	struct btrfs_balance_control *bctl;
 	int ret = 0;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
 	mutex_lock(&fs_info->balance_mutex);
-	if (!(bctl = fs_info->balance_ctl)) {
+	if (!fs_info->balance_ctl) {
 		ret = -ENOTCONN;
 		goto out;
 	}
@@ -3174,22 +3222,7 @@ static long btrfs_ioctl_balance_progress(struct btrfs_root *root,
 		goto out;
 	}
 
-	bargs->flags = bctl->flags;
-
-	if (atomic_read(&fs_info->balance_running))
-		bargs->state |= BTRFS_BALANCE_STATE_RUNNING;
-	if (atomic_read(&fs_info->balance_cancel_req))
-		bargs->state |= BTRFS_BALANCE_STATE_CANCEL_REQ;
-	if (atomic_read(&fs_info->balance_pause_req))
-		bargs->state |= BTRFS_BALANCE_STATE_PAUSE_REQ;
-
-	memcpy(&bargs->data, &bctl->data, sizeof(bargs->data));
-	memcpy(&bargs->meta, &bctl->meta, sizeof(bargs->meta));
-	memcpy(&bargs->sys, &bctl->sys, sizeof(bargs->sys));
-
-	spin_lock(&fs_info->balance_lock);
-	memcpy(&bargs->stat, &bctl->stat, sizeof(bargs->stat));
-	spin_unlock(&fs_info->balance_lock);
+	update_ioctl_balance_args(fs_info, 1, bargs);
 
 	if (copy_to_user(arg, bargs, sizeof(*bargs)))
 		ret = -EFAULT;
diff --git a/fs/btrfs/ioctl.h b/fs/btrfs/ioctl.h
index 04f8c1b..4f69028 100644
--- a/fs/btrfs/ioctl.h
+++ b/fs/btrfs/ioctl.h
@@ -112,7 +112,6 @@ struct btrfs_ioctl_fs_info_args {
 /* balance control ioctl modes */
 #define BTRFS_BALANCE_CTL_PAUSE		1
 #define BTRFS_BALANCE_CTL_CANCEL	2
-#define BTRFS_BALANCE_CTL_RESUME	3
 
 /*
  * this is packed, because it should be exactly the same as its disk
@@ -143,8 +142,8 @@ struct btrfs_balance_progress {
 };
 
 #define BTRFS_BALANCE_STATE_RUNNING	(1ULL << 0)
-#define BTRFS_BALANCE_STATE_CANCEL_REQ	(1ULL << 1)
-#define BTRFS_BALANCE_STATE_PAUSE_REQ	(1ULL << 2)
+#define BTRFS_BALANCE_STATE_PAUSE_REQ	(1ULL << 1)
+#define BTRFS_BALANCE_STATE_CANCEL_REQ	(1ULL << 2)
 
 struct btrfs_ioctl_balance_args {
 	__u64 flags;				/* in/out */
@@ -322,8 +321,8 @@ struct btrfs_ioctl_logical_ino_args {
 				 struct btrfs_ioctl_dev_info_args)
 #define BTRFS_IOC_FS_INFO _IOR(BTRFS_IOCTL_MAGIC, 31, \
 			       struct btrfs_ioctl_fs_info_args)
-#define BTRFS_IOC_BALANCE_V2 _IOW(BTRFS_IOCTL_MAGIC, 32, \
-				  struct btrfs_ioctl_balance_args)
+#define BTRFS_IOC_BALANCE_V2 _IOWR(BTRFS_IOCTL_MAGIC, 32, \
+				   struct btrfs_ioctl_balance_args)
 #define BTRFS_IOC_BALANCE_CTL _IOW(BTRFS_IOCTL_MAGIC, 33, int)
 #define BTRFS_IOC_BALANCE_PROGRESS _IOR(BTRFS_IOCTL_MAGIC, 34, \
 					struct btrfs_ioctl_balance_args)
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 38c4b08..7ffdb15 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -2517,8 +2517,10 @@ again:
 
 		ret = btrfs_previous_item(chunk_root, path, 0,
 					  BTRFS_CHUNK_ITEM_KEY);
-		if (ret)
+		if (ret) {
+			ret = 0;
 			break;
+		}
 
 		leaf = path->nodes[0];
 		slot = path->slots[0];
@@ -2603,10 +2605,14 @@ static void __cancel_balance(struct btrfs_fs_info *fs_info)
 	BUG_ON(ret);
 }
 
+void update_ioctl_balance_args(struct btrfs_fs_info *fs_info, int lock,
+			       struct btrfs_ioctl_balance_args *bargs);
+
 /*
  * Should be called with both balance and volume mutexes held
  */
-int btrfs_balance(struct btrfs_balance_control *bctl, int resume)
+int btrfs_balance(struct btrfs_balance_control *bctl,
+		  struct btrfs_ioctl_balance_args *bargs)
 {
 	struct btrfs_fs_info *fs_info = bctl->fs_info;
 	u64 allowed;
@@ -2708,11 +2714,12 @@ do_balance:
 	ret = insert_balance_item(fs_info->tree_root, bctl);
 	if (ret && ret != -EEXIST)
 		goto out;
-	BUG_ON((ret == -EEXIST && !resume) || (ret != -EEXIST && resume));
 
-	if (!resume) {
+	if (!(bctl->flags & BTRFS_BALANCE_RESUME)) {
+		BUG_ON(ret == -EEXIST);
 		set_balance_control(bctl);
 	} else {
+		BUG_ON(ret != -EEXIST);
 		spin_lock(&fs_info->balance_lock);
 		update_balance_args(bctl);
 		spin_unlock(&fs_info->balance_lock);
@@ -2726,6 +2733,11 @@ do_balance:
 	mutex_lock(&fs_info->balance_mutex);
 	atomic_dec(&fs_info->balance_running);
 
+	if (bargs) {
+		memset(bargs, 0, sizeof(*bargs));
+		update_ioctl_balance_args(fs_info, 0, bargs);
+	}
+
 	if ((ret && ret != -ECANCELED && ret != -ENOSPC) ||
 	    balance_need_close(fs_info)) {
 		__cancel_balance(fs_info);
@@ -2735,14 +2747,14 @@ do_balance:
 
 	return ret;
 out:
-	if (resume)
+	if (bctl->flags & BTRFS_BALANCE_RESUME)
 		__cancel_balance(fs_info);
 	else
 		kfree(bctl);
 	return ret;
 }
 
-static int restriper_kthread(void *data)
+static int balance_kthread(void *data)
 {
 	struct btrfs_balance_control *bctl =
 			(struct btrfs_balance_control *)data;
@@ -2758,7 +2770,7 @@ static int restriper_kthread(void *data)
 		printk(KERN_INFO "btrfs: force skipping balance\n");
 	} else {
 		printk(KERN_INFO "btrfs: continuing balance\n");
-		ret = btrfs_balance(bctl, 1);
+		ret = btrfs_balance(bctl, NULL);
 	}
 
 	mutex_unlock(&fs_info->balance_mutex);
@@ -2803,7 +2815,7 @@ int btrfs_recover_balance(struct btrfs_root *tree_root)
 	item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_balance_item);
 
 	bctl->fs_info = tree_root->fs_info;
-	bctl->flags = btrfs_balance_flags(leaf, item);
+	bctl->flags = btrfs_balance_flags(leaf, item) | BTRFS_BALANCE_RESUME;
 
 	btrfs_balance_data(leaf, item, &disk_bargs);
 	btrfs_disk_balance_args_to_cpu(&bctl->data, &disk_bargs);
@@ -2812,7 +2824,7 @@ int btrfs_recover_balance(struct btrfs_root *tree_root)
 	btrfs_balance_sys(leaf, item, &disk_bargs);
 	btrfs_disk_balance_args_to_cpu(&bctl->sys, &disk_bargs);
 
-	tsk = kthread_run(restriper_kthread, bctl, "btrfs-restriper");
+	tsk = kthread_run(balance_kthread, bctl, "btrfs-balance");
 	if (IS_ERR(tsk))
 		ret = PTR_ERR(tsk);
 	else
@@ -2890,33 +2902,6 @@ int btrfs_cancel_balance(struct btrfs_fs_info *fs_info)
 	return 0;
 }
 
-int btrfs_resume_balance(struct btrfs_fs_info *fs_info)
-{
-	int ret;
-
-	if (fs_info->sb->s_flags & MS_RDONLY)
-		return -EROFS;
-
-	mutex_lock(&fs_info->volume_mutex);
-	mutex_lock(&fs_info->balance_mutex);
-
-	if (!fs_info->balance_ctl) {
-		ret = -ENOTCONN;
-		goto out;
-	}
-
-	if (atomic_read(&fs_info->balance_running)) {
-		ret = -EINPROGRESS;
-		goto out;
-	}
-
-	ret = btrfs_balance(fs_info->balance_ctl, 1);
-out:
-	mutex_unlock(&fs_info->balance_mutex);
-	mutex_unlock(&fs_info->volume_mutex);
-	return ret;
-}
-
 /*
  * shrinking a device means finding all of the device extents past
  * the new size, and then following the back refs to the chunks.
diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index 5bad934..19ac950 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -198,6 +198,7 @@ struct map_lookup {
 					 BTRFS_BALANCE_METADATA)
 
 #define BTRFS_BALANCE_FORCE		(1ULL << 3)
+#define BTRFS_BALANCE_RESUME		(1ULL << 4)
 
 /*
  * Balance filters
@@ -272,11 +273,11 @@ struct btrfs_device *btrfs_find_device(struct btrfs_root *root, u64 devid,
 				       u8 *uuid, u8 *fsid);
 int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);
 int btrfs_init_new_device(struct btrfs_root *root, char *path);
-int btrfs_balance(struct btrfs_balance_control *rctl, int resume);
+int btrfs_balance(struct btrfs_balance_control *bctl,
+		  struct btrfs_ioctl_balance_args *bargs);
 int btrfs_recover_balance(struct btrfs_root *tree_root);
 int btrfs_pause_balance(struct btrfs_fs_info *fs_info);
 int btrfs_cancel_balance(struct btrfs_fs_info *fs_info);
-int btrfs_resume_balance(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *max_avail);
