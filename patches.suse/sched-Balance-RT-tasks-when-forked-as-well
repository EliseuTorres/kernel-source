Subject: sched: Balance RT tasks when forked as well
From: Steven Rostedt <srostedt@redhat.com>
Date: Thu, 16 Jun 2011 21:55:22 -0400
Git-commit: c37495fd0f64fc139b5a07d242bcb485174d1206
Patch-mainline: not yet

When a new task is woken, the code to balance the RT task is currently
skipped in the select_task_rq() call. But it will be pushed if the rq
is currently overloaded with RT tasks anyway. The issue is that we
already queued the task, and if it does get pushed, it will have to
be dequeued and requeued on the new run queue. The advantage with
pushing it first is that we avoid this requeuing as we are pushing it
off before the task is ever queued.

See commit 318e0893ce3f524 ("sched: pre-route RT tasks on wakeup")
for more details.

The return of select_task_rq() when it is not a wake up has also been
changed to return task_cpu() instead of smp_processor_id(). This is more
of a sanity because the current only other user of select_task_rq()
besides wake ups, is an exec, where task_cpu() should also be the same
as smp_processor_id(). But if it is used for other purposes, lets keep
the task on the same CPU. Why would we mant to migrate it to the current
CPU?

Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
Cc: Hillf Danton <dhillf@gmail.com>
Link: http://lkml.kernel.org/r/20110617015919.832743148@goodmis.org
Signed-off-by: Ingo Molnar <mingo@elte.hu>
Acked-by: Mike Galbraith <mgalbraith@suse.de>

---
 kernel/sched_rt.c |    9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

Index: linux-3.0-SLE11-SP2-3.0/kernel/sched_rt.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/kernel/sched_rt.c
+++ linux-3.0-SLE11-SP2-3.0/kernel/sched_rt.c
@@ -1005,10 +1005,12 @@ select_task_rq_rt(struct task_struct *p,
 	struct rq *rq;
 	int cpu;
 
-	if (sd_flag != SD_BALANCE_WAKE)
-		return smp_processor_id();
-
 	cpu = task_cpu(p);
+
+	/* For anything but wake ups, just return the task_cpu */
+	if (sd_flag != SD_BALANCE_WAKE && sd_flag != SD_BALANCE_FORK)
+		goto out;
+
 	rq = cpu_rq(cpu);
 
 	rcu_read_lock();
@@ -1047,6 +1049,7 @@ select_task_rq_rt(struct task_struct *p,
 	}
 	rcu_read_unlock();
 
+out:
 	return cpu;
 }
 
