From: NeilBrown <neilb@suse.de>
Date: Thu, 12 Apr 2012 16:27:10 +1000
Subject: [PATCH 18/23] md/bitmap: create a 'struct bitmap_counts'
 substructure of 'struct bitmap'3.5
Patch-mainline: fate#311379
References: 

The new "struct bitmap_counts" contains all the fields that are
related to counting the number of active writes in each bitmap chunk.

Having this separate will make it easier to change the chunksize
or overall size of a bitmap atomically.

Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: NeilBrown <neilb@suse.de>

---
 drivers/md/bitmap.c |  146 +++++++++++++++++++++++++---------------------------
 drivers/md/bitmap.h |   23 ++++----
 drivers/md/md.c     |   10 +--
 3 files changed, 89 insertions(+), 90 deletions(-)

--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/md/bitmap.c
+++ linux-3.0-SLE11-SP2-BTMU/drivers/md/bitmap.c
@@ -66,7 +66,7 @@ static inline char *bmname(struct bitmap
 /*
  * just a placeholder - calls kmalloc for bitmap pages
  */
-static unsigned char *bitmap_alloc_page(struct bitmap *bitmap)
+static unsigned char *bitmap_alloc_page(struct bitmap_counts *bitmap)
 {
 	unsigned char *page;
 
@@ -75,20 +75,14 @@ static unsigned char *bitmap_alloc_page(
 #else
 	page = kzalloc(PAGE_SIZE, GFP_NOIO);
 #endif
-	if (!page)
-		printk("%s: bitmap_alloc_page FAILED\n", bmname(bitmap));
-	else
-		PRINTK("%s: bitmap_alloc_page: allocated page at %p\n",
-			bmname(bitmap), page);
 	return page;
 }
 
 /*
  * for now just a placeholder -- just calls kfree for bitmap pages
  */
-static void bitmap_free_page(struct bitmap *bitmap, unsigned char *page)
+static void bitmap_free_page(struct bitmap_counts *bitmap, unsigned char *page)
 {
-	PRINTK("%s: bitmap_free_page: free page %p\n", bmname(bitmap), page);
 	kfree(page);
 }
 
@@ -102,7 +96,7 @@ static void bitmap_free_page(struct bitm
  * if we find our page, we increment the page's refcount so that it stays
  * allocated while we're using it
  */
-static int bitmap_checkpage(struct bitmap *bitmap,
+static int bitmap_checkpage(struct bitmap_counts *bitmap,
 			    unsigned long page, int create)
 __releases(bitmap->lock)
 __acquires(bitmap->lock)
@@ -133,8 +127,7 @@ __acquires(bitmap->lock)
 	spin_lock_irq(&bitmap->lock);
 
 	if (mappage == NULL) {
-		PRINTK("%s: bitmap map page allocation failed, hijacking\n",
-			bmname(bitmap));
+		PRINTK("md/bitmap map page allocation failed, hijacking\n");
 		/* failed - set the hijacked flag so that we can use the
 		 * pointer as a counter */
 		if (!bitmap->bp[page].map)
@@ -157,7 +150,7 @@ __acquires(bitmap->lock)
 /* if page is completely empty, put it back on the free list, or dealloc it */
 /* if page was hijacked, unmark the flag so it might get alloced next time */
 /* Note: lock should be held when calling this */
-static void bitmap_checkfree(struct bitmap *bitmap, unsigned long page)
+static void bitmap_checkfree(struct bitmap_counts *bitmap, unsigned long page)
 {
 	char *ptr;
 
@@ -465,12 +458,12 @@ void bitmap_update_sb(struct bitmap *bit
 		return;
 	if (bitmap->mddev->bitmap_info.external)
 		return;
-	spin_lock_irqsave(&bitmap->lock, flags);
+	spin_lock_irqsave(&bitmap->counts.lock, flags);
 	if (!bitmap->storage.sb_page) { /* no superblock */
-		spin_unlock_irqrestore(&bitmap->lock, flags);
+		spin_unlock_irqrestore(&bitmap->counts.lock, flags);
 		return;
 	}
-	spin_unlock_irqrestore(&bitmap->lock, flags);
+	spin_unlock_irqrestore(&bitmap->counts.lock, flags);
 	sb = kmap_atomic(bitmap->storage.sb_page, KM_USER0);
 	sb->events = cpu_to_le64(bitmap->mddev->events);
 	if (bitmap->mddev->events < bitmap->events_cleared)
@@ -893,7 +886,7 @@ static void bitmap_file_set_bit(struct b
 	unsigned long bit;
 	struct page *page;
 	void *kaddr;
-	unsigned long chunk = block >> bitmap->chunkshift;
+	unsigned long chunk = block >> bitmap->counts.chunkshift;
 
 	page = filemap_get_page(&bitmap->storage, chunk);
 	if (!page)
@@ -917,7 +910,7 @@ static void bitmap_file_clear_bit(struct
 	unsigned long bit;
 	struct page *page;
 	void *paddr;
-	unsigned long chunk = block >> bitmap->chunkshift;
+	unsigned long chunk = block >> bitmap->counts.chunkshift;
 
 	page = filemap_get_page(&bitmap->storage, chunk);
 	if (!page)
@@ -999,7 +992,7 @@ static int bitmap_init_from_disk(struct
 	void *paddr;
 	struct bitmap_storage *store = &bitmap->storage;
 
-	chunks = bitmap->chunks;
+	chunks = bitmap->counts.chunks;
 	file = store->file;
 
 	if (!file && !bitmap->mddev->bitmap_info.offset) {
@@ -1008,10 +1001,10 @@ static int bitmap_init_from_disk(struct
 		store->file_pages = 0;
 		for (i = 0; i < chunks ; i++) {
 			/* if the disk bit is set, set the memory bit */
-			int needed = ((sector_t)(i+1) << (bitmap->chunkshift)
+			int needed = ((sector_t)(i+1) << (bitmap->counts.chunkshift)
 				      >= start);
 			bitmap_set_memory_bits(bitmap,
-					       (sector_t)i << bitmap->chunkshift,
+					       (sector_t)i << bitmap->counts.chunkshift,
 					       needed);
 		}
 		return 0;
@@ -1091,10 +1084,10 @@ static int bitmap_init_from_disk(struct
 		kunmap_atomic(paddr, KM_USER0);
 		if (b) {
 			/* if the disk bit is set, set the memory bit */
-			int needed = ((sector_t)(i+1) << bitmap->chunkshift
+			int needed = ((sector_t)(i+1) << bitmap->counts.chunkshift
 				      >= start);
 			bitmap_set_memory_bits(bitmap,
-					       (sector_t)i << bitmap->chunkshift,
+					       (sector_t)i << bitmap->counts.chunkshift,
 					       needed);
 			bit_cnt++;
 			set_page_attr(bitmap, page->index, BITMAP_PAGE_PENDING);
@@ -1133,7 +1126,8 @@ void bitmap_write_all(struct bitmap *bit
 			      BITMAP_PAGE_NEEDWRITE);
 }
 
-static void bitmap_count_page(struct bitmap *bitmap, sector_t offset, int inc)
+static void bitmap_count_page(struct bitmap_counts *bitmap,
+			      sector_t offset, int inc)
 {
 	sector_t chunk = offset >> bitmap->chunkshift;
 	unsigned long page = chunk >> PAGE_COUNTER_SHIFT;
@@ -1141,7 +1135,7 @@ static void bitmap_count_page(struct bit
 	bitmap_checkfree(bitmap, page);
 }
 
-static void bitmap_set_pending(struct bitmap *bitmap, sector_t offset)
+static void bitmap_set_pending(struct bitmap_counts *bitmap, sector_t offset)
 {
 	sector_t chunk = offset >> bitmap->chunkshift;
 	unsigned long page = chunk >> PAGE_COUNTER_SHIFT;
@@ -1151,7 +1145,7 @@ static void bitmap_set_pending(struct bi
 		bp->pending = 1;
 }
 
-static bitmap_counter_t *bitmap_get_counter(struct bitmap *bitmap,
+static bitmap_counter_t *bitmap_get_counter(struct bitmap_counts *bitmap,
 					    sector_t offset, sector_t *blocks,
 					    int create);
 
@@ -1166,6 +1160,7 @@ void bitmap_daemon_work(mddev_t *mddev)
 	unsigned long j;
 	unsigned long nextpage;
 	sector_t blocks;
+	struct bitmap_counts *counts;
 
 	/* Use a mutex to guard daemon_work against
 	 * bitmap_destroy.
@@ -1215,21 +1210,22 @@ void bitmap_daemon_work(mddev_t *mddev)
 	/* Now look at the bitmap counters and if any are '2' or '1',
 	 * decrement and handle accordingly.
 	 */
-	spin_lock_irq(&bitmap->lock);
+	counts = &bitmap->counts;
+	spin_lock_irq(&counts->lock);
 	nextpage = 0;
-	for (j = 0; j < bitmap->chunks; j++) {
+	for (j = 0; j < counts->chunks; j++) {
 		bitmap_counter_t *bmc;
-		sector_t  block = (sector_t)j << bitmap->chunkshift;
+		sector_t  block = (sector_t)j << counts->chunkshift;
 
 		if (j == nextpage) {
 			nextpage += PAGE_COUNTER_RATIO;
-			if (!bitmap->bp[j >> PAGE_COUNTER_SHIFT].pending) {
+			if (!counts->bp[j >> PAGE_COUNTER_SHIFT].pending) {
 				j |= PAGE_COUNTER_MASK;
 				continue;
 			}
-			bitmap->bp[j >> PAGE_COUNTER_SHIFT].pending = 0;
+			counts->bp[j >> PAGE_COUNTER_SHIFT].pending = 0;
 		}
-		bmc = bitmap_get_counter(bitmap,
+		bmc = bitmap_get_counter(counts,
 					 block,
 					 &blocks, 0);
 
@@ -1240,15 +1236,15 @@ void bitmap_daemon_work(mddev_t *mddev)
 		if (*bmc == 1 && !bitmap->need_sync) {
 			/* We can clear the bit */
 			*bmc = 0;
-			bitmap_count_page(bitmap, block, -1);
+			bitmap_count_page(counts, block, -1);
 			bitmap_file_clear_bit(bitmap, block);
 		} else if (*bmc && *bmc <= 2) {
 			*bmc = 1;
-			bitmap_set_pending(bitmap, block);
+			bitmap_set_pending(counts, block);
 			bitmap->allclean = 0;
 		}
 	}
-	spin_unlock_irq(&bitmap->lock);
+	spin_unlock_irq(&counts->lock);
 
 	/* Now start writeout on any page in NEEDWRITE that isn't DIRTY.
 	 * DIRTY pages need to be written by bitmap_unplug so it can wait
@@ -1282,7 +1278,7 @@ void bitmap_daemon_work(mddev_t *mddev)
 	mutex_unlock(&mddev->bitmap_info.mutex);
 }
 
-static bitmap_counter_t *bitmap_get_counter(struct bitmap *bitmap,
+static bitmap_counter_t *bitmap_get_counter(struct bitmap_counts *bitmap,
 					    sector_t offset, sector_t *blocks,
 					    int create)
 __releases(bitmap->lock)
@@ -1344,10 +1340,10 @@ int bitmap_startwrite(struct bitmap *bit
 		sector_t blocks;
 		bitmap_counter_t *bmc;
 
-		spin_lock_irq(&bitmap->lock);
-		bmc = bitmap_get_counter(bitmap, offset, &blocks, 1);
+		spin_lock_irq(&bitmap->counts.lock);
+		bmc = bitmap_get_counter(&bitmap->counts, offset, &blocks, 1);
 		if (!bmc) {
-			spin_unlock_irq(&bitmap->lock);
+			spin_unlock_irq(&bitmap->counts.lock);
 			return 0;
 		}
 
@@ -1359,7 +1355,7 @@ int bitmap_startwrite(struct bitmap *bit
 			 */
 			prepare_to_wait(&bitmap->overflow_wait, &__wait,
 					TASK_UNINTERRUPTIBLE);
-			spin_unlock_irq(&bitmap->lock);
+			spin_unlock_irq(&bitmap->counts.lock);
 			io_schedule();
 			finish_wait(&bitmap->overflow_wait, &__wait);
 			continue;
@@ -1368,7 +1364,7 @@ int bitmap_startwrite(struct bitmap *bit
 		switch (*bmc) {
 		case 0:
 			bitmap_file_set_bit(bitmap, offset);
-			bitmap_count_page(bitmap, offset, 1);
+			bitmap_count_page(&bitmap->counts, offset, 1);
 			/* fall through */
 		case 1:
 			*bmc = 2;
@@ -1376,7 +1372,7 @@ int bitmap_startwrite(struct bitmap *bit
 
 		(*bmc)++;
 
-		spin_unlock_irq(&bitmap->lock);
+		spin_unlock_irq(&bitmap->counts.lock);
 
 		offset += blocks;
 		if (sectors > blocks)
@@ -1409,10 +1405,10 @@ void bitmap_endwrite(struct bitmap *bitm
 		unsigned long flags;
 		bitmap_counter_t *bmc;
 
-		spin_lock_irqsave(&bitmap->lock, flags);
-		bmc = bitmap_get_counter(bitmap, offset, &blocks, 0);
+		spin_lock_irqsave(&bitmap->counts.lock, flags);
+		bmc = bitmap_get_counter(&bitmap->counts, offset, &blocks, 0);
 		if (!bmc) {
-			spin_unlock_irqrestore(&bitmap->lock, flags);
+			spin_unlock_irqrestore(&bitmap->counts.lock, flags);
 			return;
 		}
 
@@ -1431,9 +1427,9 @@ void bitmap_endwrite(struct bitmap *bitm
 
 		(*bmc)--;
 		if (*bmc <= 2)
-			bitmap_set_pending(bitmap, offset);
+			bitmap_set_pending(&bitmap->counts, offset);
 
-		spin_unlock_irqrestore(&bitmap->lock, flags);
+		spin_unlock_irqrestore(&bitmap->counts.lock, flags);
 		offset += blocks;
 		if (sectors > blocks)
 			sectors -= blocks;
@@ -1452,8 +1448,8 @@ static int __bitmap_start_sync(struct bi
 		*blocks = 1024;
 		return 1; /* always resync if no bitmap */
 	}
-	spin_lock_irq(&bitmap->lock);
-	bmc = bitmap_get_counter(bitmap, offset, blocks, 0);
+	spin_lock_irq(&bitmap->counts.lock);
+	bmc = bitmap_get_counter(&bitmap->counts, offset, blocks, 0);
 	rv = 0;
 	if (bmc) {
 		/* locked */
@@ -1467,7 +1463,7 @@ static int __bitmap_start_sync(struct bi
 			}
 		}
 	}
-	spin_unlock_irq(&bitmap->lock);
+	spin_unlock_irq(&bitmap->counts.lock);
 	bitmap->allclean = 0;
 	return rv;
 }
@@ -1504,8 +1500,8 @@ void bitmap_end_sync(struct bitmap *bitm
 		*blocks = 1024;
 		return;
 	}
-	spin_lock_irq(&bitmap->lock);
-	bmc = bitmap_get_counter(bitmap, offset, blocks, 0);
+	spin_lock_irq(&bitmap->counts.lock);
+	bmc = bitmap_get_counter(&bitmap->counts, offset, blocks, 0);
 	if (bmc == NULL)
 		goto unlock;
 	/* locked */
@@ -1516,11 +1512,11 @@ void bitmap_end_sync(struct bitmap *bitm
 			*bmc |= NEEDED_MASK;
 		else {
 			if (*bmc <= 2)
-				bitmap_set_pending(bitmap, offset);
+				bitmap_set_pending(&bitmap->counts, offset);
 		}
 	}
  unlock:
-	spin_unlock_irq(&bitmap->lock);
+	spin_unlock_irq(&bitmap->counts.lock);
 	bitmap->allclean = 0;
 }
 EXPORT_SYMBOL(bitmap_end_sync);
@@ -1561,7 +1557,7 @@ void bitmap_cond_end_sync(struct bitmap
 
 	bitmap->mddev->curr_resync_completed = sector;
 	set_bit(MD_CHANGE_CLEAN, &bitmap->mddev->flags);
-	sector &= ~((1ULL << bitmap->chunkshift) - 1);
+	sector &= ~((1ULL << bitmap->counts.chunkshift) - 1);
 	s = 0;
 	while (s < sector && s < bitmap->mddev->resync_max_sectors) {
 		bitmap_end_sync(bitmap, s, &blocks, 0);
@@ -1581,18 +1577,18 @@ static void bitmap_set_memory_bits(struc
 
 	sector_t secs;
 	bitmap_counter_t *bmc;
-	spin_lock_irq(&bitmap->lock);
-	bmc = bitmap_get_counter(bitmap, offset, &secs, 1);
+	spin_lock_irq(&bitmap->counts.lock);
+	bmc = bitmap_get_counter(&bitmap->counts, offset, &secs, 1);
 	if (!bmc) {
-		spin_unlock_irq(&bitmap->lock);
+		spin_unlock_irq(&bitmap->counts.lock);
 		return;
 	}
 	if (!*bmc) {
 		*bmc = 1 | (needed ? NEEDED_MASK : 0);
-		bitmap_count_page(bitmap, offset, 1);
-		bitmap_set_pending(bitmap, offset);
+		bitmap_count_page(&bitmap->counts, offset, 1);
+		bitmap_set_pending(&bitmap->counts, offset);
 	}
-	spin_unlock_irq(&bitmap->lock);
+	spin_unlock_irq(&bitmap->counts.lock);
 	bitmap->allclean = 0;
 }
 
@@ -1602,7 +1598,7 @@ void bitmap_dirty_bits(struct bitmap *bi
 	unsigned long chunk;
 
 	for (chunk = s; chunk <= e; chunk++) {
-		sector_t sec = (sector_t)chunk << bitmap->chunkshift;
+		sector_t sec = (sector_t)chunk << bitmap->counts.chunkshift;
 		bitmap_set_memory_bits(bitmap, sec, 1);
 		bitmap_file_set_bit(bitmap, sec);
 		if (sec < bitmap->mddev->recovery_cp)
@@ -1656,8 +1652,8 @@ static void bitmap_free(struct bitmap *b
 	/* release the bitmap file  */
 	bitmap_file_unmap(&bitmap->storage);
 
-	bp = bitmap->bp;
-	pages = bitmap->pages;
+	bp = bitmap->counts.bp;
+	pages = bitmap->counts.pages;
 
 	/* free all allocated memory */
 
@@ -1712,7 +1708,7 @@ int bitmap_create(mddev_t *mddev)
 	if (!bitmap)
 		return -ENOMEM;
 
-	spin_lock_init(&bitmap->lock);
+	spin_lock_init(&bitmap->counts.lock);
 	atomic_set(&bitmap->pending_writes, 0);
 	init_waitqueue_head(&bitmap->write_wait);
 	init_waitqueue_head(&bitmap->overflow_wait);
@@ -1759,31 +1755,32 @@ int bitmap_create(mddev_t *mddev)
 		goto error;
 
 	bitmap->daemon_lastrun = jiffies;
-	bitmap->chunkshift = (ffz(~mddev->bitmap_info.chunksize)
+	bitmap->counts.chunkshift = (ffz(~mddev->bitmap_info.chunksize)
 			      - BITMAP_BLOCK_SHIFT);
 
 	/* now that chunksize and chunkshift are set, we can use these macros */
-	chunks = (blocks + bitmap->chunkshift - 1) >>
-			bitmap->chunkshift;
+	chunks = (blocks + bitmap->counts.chunkshift - 1) >>
+			bitmap->counts.chunkshift;
 	pages = (chunks + PAGE_COUNTER_RATIO - 1) / PAGE_COUNTER_RATIO;
 
 	BUG_ON(!pages);
 
-	bitmap->chunks = chunks;
-	bitmap->pages = pages;
-	bitmap->missing_pages = pages;
+	bitmap->counts.chunks = chunks;
+	bitmap->counts.pages = pages;
+	bitmap->counts.missing_pages = pages;
 
 #ifdef INJECT_FATAL_FAULT_1
 	bitmap->bp = NULL;
 #else
-	bitmap->bp = kzalloc(pages * sizeof(*bitmap->bp), GFP_KERNEL);
+	bitmap->counts.bp = kzalloc(pages * sizeof(*bitmap->counts.bp),
+				    GFP_KERNEL);
 #endif
 	err = -ENOMEM;
-	if (!bitmap->bp)
+	if (!bitmap->counts.bp)
 		goto error;
 
 	if (file || mddev->bitmap_info.offset) {
-		err = bitmap_storage_alloc(&bitmap->storage, bitmap->chunks,
+		err = bitmap_storage_alloc(&bitmap->storage, bitmap->counts.chunks,
 					   !mddev->bitmap_info.external);
 		if (err)
 			goto error;
@@ -2139,8 +2136,7 @@ behind_writes_used_show(mddev_t *mddev,
 {
 	if (mddev->bitmap == NULL)
 		return sprintf(page, "0\n");
-	return sprintf(page, "%lu\n",
-		       mddev->bitmap->behind_writes_used);
+	return sprintf(page, "%lu\n", mddev->bitmap->behind_writes_used);
 }
 
 static ssize_t
--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/md/bitmap.h
+++ linux-3.0-SLE11-SP2-BTMU/drivers/md/bitmap.h
@@ -193,22 +193,25 @@ struct page_list {
 
 /* the main bitmap structure - one per mddev */
 struct bitmap {
-	struct bitmap_page *bp;
-	unsigned long pages; /* total number of pages in the bitmap */
-	unsigned long missing_pages; /* number of pages not yet allocated */
 
-	mddev_t *mddev; /* the md device that the bitmap is for */
+	struct bitmap_counts {
+		spinlock_t lock;
+		struct bitmap_page *bp;
+		unsigned long pages;		/* total number of pages
+						 * in the bitmap */
+		unsigned long missing_pages;	/* number of pages
+						 * not yet allocated */
+		unsigned long chunkshift;	/* chunksize = 2^chunkshift
+						 * (for bitops) */
+		unsigned long chunks;		/* Total number of data
+						 * chunks for the array */
+	} counts;
 
-	/* bitmap chunksize -- how much data does each bit represent? */
-	unsigned long chunkshift; /* chunksize = 2^(chunkshift+9) (for bitops) */
-	unsigned long chunks; /* total number of data chunks for the array */
+	mddev_t *mddev; /* the md device that the bitmap is for */
 
 	__u64	events_cleared;
 	int need_sync;
 
-	/* bitmap spinlock */
-	spinlock_t lock;
-
 	struct bitmap_storage {
 		struct file *file;		/* backing disk file */
 		struct page *sb_page;		/* cached copy of the bitmap
--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/md/md.c
+++ linux-3.0-SLE11-SP2-BTMU/drivers/md/md.c
@@ -6893,13 +6893,13 @@ static int md_seq_show(struct seq_file *
 			unsigned long chunk_kb;
 			unsigned long flags;
 			struct file *file;
-			spin_lock_irqsave(&bitmap->lock, flags);
+			spin_lock_irqsave(&bitmap->counts.lock, flags);
 			chunk_kb = mddev->bitmap_info.chunksize >> 10;
 			seq_printf(seq, "bitmap: %lu/%lu pages [%luKB], "
 				"%lu%s chunk",
-				bitmap->pages - bitmap->missing_pages,
-				bitmap->pages,
-				(bitmap->pages - bitmap->missing_pages)
+				bitmap->counts.pages - bitmap->counts.missing_pages,
+				bitmap->counts.pages,
+				(bitmap->counts.pages - bitmap->counts.missing_pages)
 					<< (PAGE_SHIFT - 10),
 				chunk_kb ? chunk_kb : mddev->bitmap_info.chunksize,
 				chunk_kb ? "KB" : "B");
@@ -6910,7 +6910,7 @@ static int md_seq_show(struct seq_file *
 			}
 
 			seq_printf(seq, "\n");
-			spin_unlock_irqrestore(&bitmap->lock, flags);
+			spin_unlock_irqrestore(&bitmap->counts.lock, flags);
 		}
 
 		seq_printf(seq, "\n");
