From: Tejun Heo <tj@kernel.org>
Date: Sat, 15 May 2010 20:09:28 +0200
Subject: [PATCH] block: restart partition scan after resizing a device
X-Git: 56bca01738733709bef076e2e97bbd01e5659f24
References: FATE#311692
Patch-Mainline: 2.6.35

Device resize via ->set_capacity() can reveal new partitions (e.g. in
chained partition table formats such as dos extended parts).  Restart
partition scan from the beginning after resizing a device.  This
change also makes libata always revalidate the disk after resize which
makes lower layer native capacity unlocking implementation simpler and
more robust as resize can be handled in the usual path.

Signed-off-by: Tejun Heo <tj@kernel.org>
Reported-by: Ben Hutchings <ben@decadent.org.uk>
Acked-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Jens Axboe <jens.axboe@oracle.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 fs/partitions/check.c |   16 ++++++----------
 1 files changed, 6 insertions(+), 10 deletions(-)

diff --git a/fs/partitions/check.c b/fs/partitions/check.c
index 7fe3c42..c4331a0 100644
--- a/fs/partitions/check.c
+++ b/fs/partitions/check.c
@@ -543,7 +543,7 @@ int rescan_partitions(struct gendisk *disk, struct block_device *bdev)
 	struct hd_struct *part;
 	struct parsed_partitions *state;
 	int p, highest, res;
-
+rescan:
 	if (bdev->bd_part_count)
 		return -EBUSY;
 	res = invalidate_partition(disk, 0);
@@ -582,7 +582,7 @@ int rescan_partitions(struct gendisk *disk, struct block_device *bdev)
 	/* add partitions */
 	for (p = 1; p < state->limit; p++) {
 		sector_t size, from;
-try_scan:
+
 		size = state->parts[p].size;
 		if (!size)
 			continue;
@@ -597,7 +597,6 @@ try_scan:
 
 		if (from + size > get_capacity(disk)) {
 			const struct block_device_operations *bdops = disk->fops;
-			unsigned long long capacity;
 
 			printk(KERN_WARNING
 			       "%s: p%d size %llu exceeds device capacity, ",
@@ -606,14 +605,11 @@ try_scan:
 			if (bdops->set_capacity &&
 			    (disk->flags & GENHD_FL_NATIVE_CAPACITY) == 0) {
 				printk(KERN_CONT "enabling native capacity\n");
-				capacity = bdops->set_capacity(disk, ~0ULL);
+				bdops->set_capacity(disk, ~0ULL);
 				disk->flags |= GENHD_FL_NATIVE_CAPACITY;
-				if (capacity > get_capacity(disk)) {
-					set_capacity(disk, capacity);
-					check_disk_size_change(disk, bdev);
-					bdev->bd_invalidated = 0;
-				}
-				goto try_scan;
+				/* free state and restart */
+				kfree(state);
+				goto rescan;
 			} else {
 				/*
 				 * we can not ignore partitions of broken tables
-- 
1.6.0.2

