From: Josef Bacik <jbacik@fusionio.com>
Date: Fri, 14 Sep 2012 10:34:40 -0400
Patch-mainline: 3.7
Git-commit: 60376ce4a8396bc5cd777be05b6a9bf044520f42
References: FATE#312888
Subject: [PATCH] Btrfs: fix race in sync and freeze again

I screwed this up, there is a race between checking if there is a running
transaction and actually starting a transaction in sync where we could race
with a freezer and get ourselves into trouble.  To fix this we need to make
a new join type to only do the try lock on the freeze stuff.  If it fails
we'll return EPERM and just return from sync.  This fixes a hang Liu Bo
reported when running xfstest 68 in a loop.  Thanks,

Reported-by: Liu Bo <bo.li.liu@oracle.com>
Signed-off-by: Josef Bacik <jbacik@fusionio.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/compat.h      |    4 ++++
 fs/btrfs/super.c       |   15 ++++++---------
 fs/btrfs/transaction.c |   13 +++++++++++++
 fs/btrfs/transaction.h |    1 +
 4 files changed, 24 insertions(+), 9 deletions(-)

--- a/fs/btrfs/compat.h
+++ b/fs/btrfs/compat.h
@@ -28,4 +28,8 @@ static inline const char *printk_skip_le
 	return buffer;
 }
 
+/* stubs, not used */
+static inline int __sb_start_write(struct super_block *sb, int level, bool wait) { return 1; }
+static inline void sb_start_intwrite(struct super_block *sb) { }
+
 #endif /* _COMPAT_H_ */
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -863,16 +863,13 @@ int btrfs_sync_fs(struct super_block *sb
 
 	btrfs_wait_ordered_extents(root, 0, 0);
 
-	spin_lock(&fs_info->trans_lock);
-	if (!fs_info->running_transaction) {
-		spin_unlock(&fs_info->trans_lock);
-		return 0;
-	}
-	spin_unlock(&fs_info->trans_lock);
-
-	trans = btrfs_join_transaction(root);
-	if (IS_ERR(trans))
+	trans = btrfs_join_transaction_freeze(root);
+	if (IS_ERR(trans)) {
+		/* Frozen, don't bother */
+		if (PTR_ERR(trans) == -EPERM)
+			return 0;
 		return PTR_ERR(trans);
+	}
 	return btrfs_commit_transaction(trans, root);
 }
 
--- a/fs/btrfs/transaction.c
+++ b/fs/btrfs/transaction.c
@@ -30,6 +30,7 @@
 #include "tree-log.h"
 #include "inode-map.h"
 #include "volumes.h"
+#include "compat.h"
 
 #define BTRFS_ROOT_TRANS_TAG 0
 
@@ -272,6 +273,7 @@ enum btrfs_trans_type {
 	TRANS_JOIN,
 	TRANS_USERSPACE,
 	TRANS_JOIN_NOLOCK,
+	TRANS_JOIN_FREEZE,
 };
 
 static int may_wait_transaction(struct btrfs_root *root, int type)
@@ -341,6 +343,12 @@ again:
 	if (!h)
 		return ERR_PTR(-ENOMEM);
 
+	if (!__sb_start_write(root->fs_info->sb, 0 /*SB_FREEZE_FS*/, false)) {
+		if (type == TRANS_JOIN_FREEZE)
+			return ERR_PTR(-EPERM);
+		sb_start_intwrite(root->fs_info->sb);
+	}
+
 	if (may_wait_transaction(root, type))
 		wait_current_trans(root);
 
@@ -421,6 +429,11 @@ struct btrfs_trans_handle *btrfs_start_i
 	return start_transaction(root, 0, TRANS_USERSPACE, 0);
 }
 
+struct btrfs_trans_handle *btrfs_join_transaction_freeze(struct btrfs_root *root)
+{
+	return start_transaction(root, 0, TRANS_JOIN_FREEZE, 0);
+}
+
 /* wait for a transaction commit to be fully complete */
 static noinline void wait_for_commit(struct btrfs_root *root,
 				    struct btrfs_transaction *commit)
--- a/fs/btrfs/transaction.h
+++ b/fs/btrfs/transaction.h
@@ -102,6 +102,7 @@ struct btrfs_trans_handle *btrfs_start_t
 					struct btrfs_root *root, int num_items);
 struct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root);
 struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root);
+struct btrfs_trans_handle *btrfs_join_transaction_freeze(struct btrfs_root *root);
 struct btrfs_trans_handle *btrfs_start_ioctl_transaction(struct btrfs_root *root);
 int btrfs_wait_for_commit(struct btrfs_root *root, u64 transid);
 int btrfs_write_and_wait_transaction(struct btrfs_trans_handle *trans,
