Subject: io tracing
From: Michael Meeks <michael.meeks@novell.com>
Date: Fri, 04 Dec 2009 17:47:04 +0000
Patch-mainline: never
References: bnc#785901

This patch, inspired by Arjan, and Scott James Remnant's work adds
the ability to easily add trace points that refer to files, and
print full paths.

It also adds three of these trace points to open(), exec() and uselib()

Signed-off-by: Michael Meeks <michael.meeks@novell.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
Acked-by: Jean Delvare <jdelvare@suse.de>
---
 fs/exec.c                      |    6 +++
 fs/open.c                      |    4 ++
 include/linux/ftrace_event.h   |    4 ++
 include/trace/events/fs-open.h |   66 +++++++++++++++++++++++++++++++++++++++++
 include/trace/ftrace.h         |   24 ++++++++++++++
 kernel/trace/trace_events.c    |   32 +++++++++++++++++++
 6 files changed, 136 insertions(+)

--- a/fs/exec.c
+++ b/fs/exec.c
@@ -56,6 +56,8 @@
 #include <linux/oom.h>
 #include <linux/compat.h>
 
+#include <trace/events/fs-open.h>
+
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 #include <asm/tlb.h>
@@ -140,6 +142,8 @@ SYSCALL_DEFINE1(uselib, const char __use
 
 	fsnotify_open(file);
 
+	trace_uselib(file);
+
 	error = -ENOEXEC;
 	if(file->f_op) {
 		struct linux_binfmt * fmt;
@@ -789,6 +793,8 @@ struct file *open_exec(const char *name)
 
 	fsnotify_open(file);
 
+	trace_open_exec(file);
+
 	if (file->f_op && file->f_op->open_exec) {
 		err = file->f_op->open_exec(file->f_path.dentry->d_inode);
 		if (err)
--- a/fs/open.c
+++ b/fs/open.c
@@ -33,6 +33,9 @@
 
 #include "internal.h"
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/fs-open.h>
+
 int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
 	struct file *filp)
 {
@@ -1006,6 +1009,7 @@ long do_sys_open(int dfd, const char __u
 			} else {
 				fsnotify_open(f);
 				fd_install(fd, f);
+				trace_do_sys_open(f, flags, mode);
 			}
 		}
 		putname(tmp);
--- a/include/linux/ftrace_event.h
+++ b/include/linux/ftrace_event.h
@@ -251,6 +251,10 @@ extern void trace_remove_event_call(stru
 
 int trace_set_clr_event(const char *system, const char *event, int set);
 
+/* file pointer helpers */
+extern int  ftrace_file_name_len (const struct file *f);
+extern void ftrace_assign_file   (char *dest, int dest_len, const struct file *f);
+
 /*
  * The double __builtin_constant_p is because gcc will give us an error
  * if we try to allocate the static variable to fmt if it is not a
--- /dev/null
+++ b/include/trace/events/fs-open.h
@@ -0,0 +1,66 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM fs-open
+
+#if !defined(_TRACE_FS_OPEN_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_FS_OPEN_H
+
+#include <linux/fs.h>
+#include <linux/tracepoint.h>
+
+/*
+ * Here we have a problem; the __string macro uses __dynamic_array,
+ * which requires the ability to know it's own length before we
+ * allocate the buffer - in the get_offsets_ call - which does not
+ * know the length of the resulting path we create in TP_fast_assign.
+ * So - give up and use a fixed length.
+ */
+TRACE_EVENT(do_sys_open,
+
+	TP_PROTO(struct file *filp, int flags, int mode),
+
+	TP_ARGS(filp, flags, mode),
+
+	TP_STRUCT__entry(
+		__file_p(	filename, filp			)
+		__field(	int, flags			)
+		__field(	int, mode			)
+	),
+
+	TP_fast_assign(
+		__assign_file_p(filename, filp);
+		__entry->flags = flags;
+		__entry->mode = mode;
+	),
+
+	TP_printk("\"%s\" %x %o", __get_str(filename),
+		  __entry->flags, __entry->mode)
+);
+
+TRACE_EVENT(uselib,
+	TP_PROTO(struct file *filp),
+	TP_ARGS(filp),
+	TP_STRUCT__entry(
+		__file_p(filename, filp)
+	),
+	TP_fast_assign(
+		__assign_file_p(filename, filp);
+	),
+	TP_printk("\"%s\"", __get_str(filename))
+);
+
+TRACE_EVENT(open_exec,
+	TP_PROTO(struct file *filp),
+	TP_ARGS(filp),
+	TP_STRUCT__entry(
+		__file_p(filename, filp)
+	),
+	TP_fast_assign(
+		__assign_file_p(filename, filp);
+	),
+	TP_printk("\"%s\"", __get_str(filename))
+);
+
+#endif /* _TRACE_FS_OPEN_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
--- a/include/trace/ftrace.h
+++ b/include/trace/ftrace.h
@@ -53,6 +53,9 @@
 #undef __string
 #define __string(item, src) __dynamic_array(char, item, -1)
 
+#undef __file_p
+#define __file_p(item, src) __dynamic_array(char, item, -1)
+
 #undef TP_STRUCT__entry
 #define TP_STRUCT__entry(args...) args
 
@@ -120,6 +123,10 @@
 #undef __string
 #define __string(item, src) __dynamic_array(char, item, -1)
 
+#undef __file_p
+#define __file_p(item, src)			int item; \
+						int item##__size;
+
 #undef DECLARE_EVENT_CLASS
 #define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\
 	struct ftrace_data_offsets_##call {				\
@@ -333,6 +340,9 @@ static struct trace_event_functions ftra
 #undef __string
 #define __string(item, src) __dynamic_array(char, item, -1)
 
+#undef __file_p
+#define __file_p(item, src) __dynamic_array(char, item, -1)
+
 #undef DECLARE_EVENT_CLASS
 #define DECLARE_EVENT_CLASS(call, proto, args, tstruct, func, print)	\
 static int notrace							\
@@ -381,6 +391,13 @@ ftrace_define_fields_##call(struct ftrac
 #undef __string
 #define __string(item, src) __dynamic_array(char, item, strlen(src) + 1)
 
+#undef __file_p
+#define __file_p(item, src)						\
+	__data_offsets->item = __data_size +				\
+			       offsetof(typeof(*entry), __data);	\
+	__data_offsets->item##__size = ftrace_file_name_len(src);	\
+	__data_size += __data_offsets->item##__size;
+
 #undef DECLARE_EVENT_CLASS
 #define DECLARE_EVENT_CLASS(call, proto, args, tstruct, assign, print)	\
 static inline notrace int ftrace_get_offsets_##call(			\
@@ -502,10 +519,17 @@ static inline notrace int ftrace_get_off
 #undef __string
 #define __string(item, src) __dynamic_array(char, item, -1)       	\
 
+#undef __file_p
+#define __file_p(item, src) __dynamic_array(char, item, -1)       	\
+
 #undef __assign_str
 #define __assign_str(dst, src)						\
 	strcpy(__get_str(dst), src);
 
+#undef __assign_file_p
+#define __assign_file_p(dst, src)					\
+	ftrace_assign_file(__get_str (dst), __data_offsets.dst##__size, src);
+
 #undef TP_fast_assign
 #define TP_fast_assign(args...) args
 
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -1306,6 +1306,38 @@ void trace_remove_event_call(struct ftra
 	     (unsigned long)event < (unsigned long)end;		\
 	     event++)
 
+/* file pointer helpers */
+int ftrace_file_name_len (const struct file *f)
+{
+	/* This performs pretty terribly - obviously */
+	int len = 1;
+	char *buf, *fname;
+
+	if (!(buf = kzalloc(PAGE_SIZE, GFP_KERNEL)))
+		return len;
+	fname = d_path(&f->f_path, buf, PAGE_SIZE);
+	if (!IS_ERR (fname))
+		len += strlen (fname);
+	kfree(buf);
+	return len;
+}
+
+void ftrace_assign_file (char *dest, int dest_len, const struct file *f)
+{
+	char *buf, *fname;
+
+	dest[0] = '\0';
+	if (!(buf = kzalloc(PAGE_SIZE, GFP_KERNEL)))
+		return;
+
+	/* it would be nicer to write this directly into the
+	 * allocated buffer, but d_path doesn't like that */
+	fname = d_path(&f->f_path, buf, PAGE_SIZE);
+	if (!IS_ERR (fname))
+		strncpy (dest, fname, dest_len);
+	kfree(buf);
+}
+
 #ifdef CONFIG_MODULES
 
 static LIST_HEAD(ftrace_module_file_list);
