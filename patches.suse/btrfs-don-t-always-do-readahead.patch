From: Josef Bacik <josef@redhat.com>
Date: Fri, 13 May 2011 10:32:11 -0400
Patch-mainline: yes
References: FATE#306586
Subject: [PATCH] Btrfs: don't always do readahead

Our readahead is sort of sloppy, and really isn't always needed.  For example if
ls is doing a stating ls (which is the default) it's going to stat in non-disk
order, so if say you have a directory with a stupid amount of files, readahead
is going to do nothing but waste time in the case of doing the stat.  Taking the
unconditional readahead out made my test go from 57 minutes to 36 minutes.  This
means that everywhere we do loop through the tree we want to make sure we do set
path->reada properly, so I went through and found all of the places where we
loop through the path and set reada to 1.  Thanks,

Signed-off-by: Josef Bacik <josef@redhat.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/ctree.c       |    2 --
 fs/btrfs/extent-tree.c |    3 ++-
 fs/btrfs/inode.c       |   12 ++++++++++--
 fs/btrfs/relocation.c  |    6 ++++++
 4 files changed, 18 insertions(+), 5 deletions(-)

Index: linux-2.6.32-SLE11-SP2/fs/btrfs/ctree.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/ctree.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/ctree.c
@@ -42,8 +42,6 @@ struct btrfs_path *btrfs_alloc_path(void
 {
 	struct btrfs_path *path;
 	path = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);
-	if (path)
-		path->reada = 1;
 	return path;
 }
 
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/extent-tree.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/extent-tree.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/extent-tree.c
@@ -347,7 +347,7 @@ static int caching_kthread(void *data)
 	 */
 	path->skip_locking = 1;
 	path->search_commit_root = 1;
-	path->reada = 2;
+	path->reada = 1;
 
 	key.objectid = last;
 	key.offset = 0;
@@ -6905,6 +6905,7 @@ int btrfs_read_block_groups(struct btrfs
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
+	path->reada = 1;
 
 	cache_gen = btrfs_super_cache_generation(&root->fs_info->super_copy);
 	if (cache_gen != 0 &&
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/inode.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/inode.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/inode.c
@@ -4101,7 +4101,7 @@ static int btrfs_real_readdir(struct fil
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
-	path->reada = 2;
+	path->reada = 1;
 
 	if (key_type == BTRFS_DIR_INDEX_KEY) {
 		INIT_LIST_HEAD(&ins_list);
@@ -4951,7 +4951,15 @@ again:
 
 	if (!path) {
 		path = btrfs_alloc_path();
-		BUG_ON(!path);
+		if (!path) {
+			err = -ENOMEM;
+			goto out;
+		}
+		/*
+		 * Chances are we'll be called again, so go ahead and do
+		 * readahead
+		 */
+		path->reada = 1;
 	}
 
 	ret = btrfs_lookup_file_extent(trans, root, path,
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/relocation.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/relocation.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/relocation.c
@@ -676,6 +676,8 @@ struct backref_node *build_backref_tree(
 		err = -ENOMEM;
 		goto out;
 	}
+	path1->reada = 1;
+	path2->reada = 2;
 
 	node = alloc_backref_node(cache);
 	if (!node) {
@@ -1998,6 +2000,7 @@ static noinline_for_stack int merge_relo
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
+	path->reada = 1;
 
 	reloc_root = root->reloc_root;
 	root_item = &reloc_root->root_item;
@@ -3299,6 +3302,7 @@ static int find_data_references(struct r
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
+	path->reada = 1;
 
 	root = read_fs_root(rc->extent_root->fs_info, ref_root);
 	if (IS_ERR(root)) {
@@ -3667,6 +3671,7 @@ static noinline_for_stack int relocate_b
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
+	path->reada = 1;
 
 	ret = prepare_to_relocate(rc);
 	if (ret) {
@@ -4092,6 +4097,7 @@ int btrfs_recover_relocation(struct btrf
 	path = btrfs_alloc_path();
 	if (!path)
 		return -ENOMEM;
+	path->reada = -1;
 
 	key.objectid = BTRFS_TREE_RELOC_OBJECTID;
 	key.type = BTRFS_ROOT_ITEM_KEY;
