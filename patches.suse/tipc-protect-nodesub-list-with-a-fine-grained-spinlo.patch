From: Erik Hugne <erik.hugne@ericsson.com>
Subject: [PATCH 2/3] tipc: protect nodesub list with a fine grained spinlock
References: bsc#907063 
Patch-mainline: not yet
Acked-by: Jiri Bohac <jbohac@suse.cz>

The node receive queue lock and node lock are heavily dependant
on eachother, and the order of grabbing these must always be
1. node lock
2. receive queue lock
However, the node subscription function use the big node lock to
protect a simple linked list of subscriptions, causing a reverse
order of grabbing these locks. To resolve this, we replace the
node lock protection of the nodesub list with a more fine grained
one, specific for the list. The same thing occurs in
tipc_link_get_max_pkt, where the node lock is grabbed in context of
the receive queue lock. To fix that, we simply revert to the
max default for newly established connections.

Signed-off-by: Erik Hugne <erik.hugne@ericsson.com>
---
 net/tipc/node.c        | 1 +
 net/tipc/node.h        | 2 ++
 net/tipc/node_subscr.c | 9 ++++-----
 net/tipc/port.c        | 2 +-
 4 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/net/tipc/node.c b/net/tipc/node.c
index e98efec..27e03ea 100644
--- a/net/tipc/node.c
+++ b/net/tipc/node.c
@@ -114,6 +114,7 @@ struct tipc_node *tipc_node_create(u32 addr)
 	INIT_HLIST_NODE(&n_ptr->hash);
 	INIT_LIST_HEAD(&n_ptr->list);
 	INIT_LIST_HEAD(&n_ptr->nsub);
+	spin_lock_init(&n_ptr->nsub_lock);
 	skb_queue_head_init(&n_ptr->rq);
 
 	hlist_add_head(&n_ptr->hash, &node_htable[tipc_hashfn(addr)]);
diff --git a/net/tipc/node.h b/net/tipc/node.h
index e3fd578..329b890 100644
--- a/net/tipc/node.h
+++ b/net/tipc/node.h
@@ -58,6 +58,7 @@
  * @lock: spinlock governing access to structure
  * @hash: links to adjacent nodes in unsorted hash chain
  * @list: links to adjacent nodes in sorted list of cluster's nodes
+ * @nsub_lock: lock protecting node subscription list
  * @nsub: list of "node down" subscriptions monitoring node
  * @active_links: pointers to active links to node
  * @links: pointers to all links to node
@@ -83,6 +84,7 @@ struct tipc_node {
 	spinlock_t lock;
 	struct hlist_node hash;
 	struct list_head list;
+	spinlock_t nsub_lock;
 	struct list_head nsub;
 	struct tipc_link *active_links[2];
 	struct tipc_link *links[MAX_BEARERS];
diff --git a/net/tipc/node_subscr.c b/net/tipc/node_subscr.c
index 5e34b01..5b59c99 100644
--- a/net/tipc/node_subscr.c
+++ b/net/tipc/node_subscr.c
@@ -48,7 +48,6 @@ void tipc_nodesub_subscribe(struct tipc_node_subscr *node_sub, u32 addr,
 		node_sub->node = NULL;
 		return;
 	}
-
 	node_sub->node = tipc_node_find(addr);
 	if (!node_sub->node) {
 		pr_warn("Node subscription rejected, unknown node 0x%x\n",
@@ -58,9 +57,9 @@ void tipc_nodesub_subscribe(struct tipc_node_subscr *node_sub, u32 addr,
 	node_sub->handle_node_down = handle_down;
 	node_sub->usr_handle = usr_handle;
 
-	tipc_node_lock(node_sub->node);
+	spin_lock_bh(&node_sub->node->nsub_lock);
 	list_add_tail(&node_sub->nodesub_list, &node_sub->node->nsub);
-	tipc_node_unlock(node_sub->node);
+	spin_unlock_bh(&node_sub->node->nsub_lock);
 }
 
 /**
@@ -71,9 +70,9 @@ void tipc_nodesub_unsubscribe(struct tipc_node_subscr *node_sub)
 	if (!node_sub->node)
 		return;
 
-	tipc_node_lock(node_sub->node);
+	spin_lock_bh(&node_sub->node->nsub_lock);
 	list_del_init(&node_sub->nodesub_list);
-	tipc_node_unlock(node_sub->node);
+	spin_unlock_bh(&node_sub->node->nsub_lock);
 }
 
 /**
diff --git a/net/tipc/port.c b/net/tipc/port.c
index 38d7e49..5ab1d7b 100644
--- a/net/tipc/port.c
+++ b/net/tipc/port.c
@@ -1099,7 +1099,7 @@ int __tipc_connect(u32 ref, struct tipc_port *p_ptr,
 			  (net_ev_handler)port_handle_node_down);
 	res = 0;
 exit:
-	p_ptr->max_pkt = tipc_link_get_max_pkt(peer->node, ref);
+	p_ptr->max_pkt = MAX_PKT_DEFAULT;
 	return res;
 }
 
-- 
2.1.3

