From: Maxim Patlasov <MPatlasov@parallels.com>
Date: Wed, 2 Oct 2013 15:01:07 +0400
Subject: fuse: writepages: roll back changes if request not found
Git-commit: f6011081f5e290756bd90fe96f1e86d3eac76f77
Patch-mainline: v3.13-rc1
References: FATE#317677

fuse_writepage_in_flight() returns false if it fails to find request with
given index in fi->writepages.  Then the caller proceeds with populating
data->orig_pages[] and incrementing req->num_pages.  Hence,
fuse_writepage_in_flight() must revert changes it made in request before
returning false.

Signed-off-by: Maxim Patlasov <MPatlasov@parallels.com>
Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
---
 fs/fuse/file.c |    6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -1631,7 +1631,6 @@ static bool fuse_writepage_in_flight(str
 
 	spin_lock(&fc->lock);
 	list_del(&new_req->writepages_entry);
-	new_req->num_pages = 1;
 	list_for_each_entry(old_req, &fi->writepages, writepages_entry) {
 		BUG_ON(old_req->inode != new_req->inode);
 		curr_index = old_req->misc.write.in.offset >> PAGE_CACHE_SHIFT;
@@ -1641,9 +1640,12 @@ static bool fuse_writepage_in_flight(str
 			break;
 		}
 	}
-	if (!found)
+	if (!found) {
+		list_add(&new_req->writepages_entry, &fi->writepages);
 		goto out_unlock;
+	}
 
+	new_req->num_pages = 1;
 	for (tmp = old_req; tmp != NULL; tmp = tmp->misc.write.next) {
 		BUG_ON(tmp->inode != new_req->inode);
 		curr_index = tmp->misc.write.in.offset >> PAGE_CACHE_SHIFT;
