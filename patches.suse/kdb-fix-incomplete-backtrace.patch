From: Cliff Wickman <cpw@sgi.com>
Subject: kdb shows incomplete backtrace
Patch-mainline: never
References: bnc#618444

In x86_64, at the interrupt that brings each cpu in to KDB, the stack
pointer is not pointing at the frame of the function that was interrupted.
It points to the frame of caller of that function.

And a disconnected task's sp points to the frame of the function that
called schedule().

So interpret the instruction pointer as to top entry of the backtrace.
- for a connected task, ip comes from the pt_regs of the interrupt
- for a disconnected task, ip comes the task's thread_struct

kdb_stack_unwind() and kdb_dump_trace_unwind() imitate
try_stack_unwind() and dump_trace_unwind(), but add the current ip
without disturbing the kernel's trace code.

No change (i.e. no attempt to show the current function) for X86_32.

Diffed against 2.6.32.13

Signed-off-by: Cliff Wickman <cpw@sgi.com>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 kdb/kdb_bt.c |   55 ++++++++++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 50 insertions(+), 5 deletions(-)

--- a/kdb/kdb_bt.c
+++ b/kdb/kdb_bt.c
@@ -17,10 +17,46 @@
 #include <linux/nmi.h>
 #include <asm/system.h>
 #include <linux/unwind.h>
-#ifdef CONFIG_X86
+#ifdef CONFIG_X86_32
 #include "../arch/x86/kernel/dumpstack.h"
 #endif
 
+#ifdef CONFIG_X86_64
+static void
+kdb_dump_trace_unwind (struct unwind_frame_info *info)
+{
+	unsigned long sp = UNW_SP(info);
+
+	if (info && info->regs.ip) {
+		/* vsnprintf: %pS output the name of a symbol with offset */
+		kdb_printf(" [<%p>] %pS\n",
+			(void *)info->regs.ip, (void *)info->regs.ip);
+	}
+	while (unwind(info) == 0 && UNW_PC(info)) {
+		kdb_printf(" [<%p>] %pS\n",
+			(void *)UNW_PC(info), (void *)UNW_PC(info));
+		if ((sp & ~(PAGE_SIZE - 1)) == (UNW_SP(info) & ~(PAGE_SIZE - 1))
+		    && sp > UNW_SP(info))
+			break;
+		sp = UNW_SP(info);
+	}
+}
+
+static void
+kdb_stack_unwind(struct task_struct *task, struct pt_regs *regs)
+{
+	struct unwind_frame_info info;
+	if (regs) {
+		if (unwind_init_frame_info(&info, task, regs))
+			return;
+	} else {
+		if (unwind_init_blocked(&info, task))
+			return;
+	}
+	kdb_dump_trace_unwind(&info);
+}
+#endif
+
 /*
  * kdb_bt
  *
@@ -58,14 +94,23 @@
 static int kdb_show_stack(struct task_struct *p, void *addr, int argcount)
 {
 	/* Use KDB arch-specific backtraces for ia64 */
-#ifdef CONFIG_IA64
+#if defined(CONFIG_IA64)
 	return kdba_bt_process(p, argcount);
-#else
+#elif defined(CONFIG_X86_64)
 	/* Use the in-kernel backtraces */
 	int old_lvl = console_loglevel;
 	console_loglevel = 15;
 	kdb_trap_printk++;
 	kdba_set_current_task(p);
+	if (addr)
+		show_stack((struct task_struct *)p, addr);
+	else
+		kdb_stack_unwind(p, kdb_current_regs);
+	console_loglevel = old_lvl;
+	kdb_trap_printk--;
+	return 0;
+#else /* CONFIG_X86_32 */
+	int old_lvl = console_loglevel;
 	if (addr) {
 		show_stack_log_lvl((struct task_struct *)p, kdb_current_regs,
 				addr, 0, "");
@@ -77,7 +123,7 @@ static int kdb_show_stack(struct task_st
 	console_loglevel = old_lvl;
 	kdb_trap_printk--;
 	return 0;
-#endif /* CONFIG_IA64 */
+#endif
 }
 
 
