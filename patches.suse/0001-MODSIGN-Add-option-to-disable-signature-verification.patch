From 82b4d4aba43a3949249fb01c010ac29d9516869c Mon Sep 17 00:00:00 2001
From: Michal Marek <mmarek@suse.cz>
Date: Tue, 5 Mar 2013 14:12:46 +0100
Subject: [PATCH] MODSIGN: Add option to disable signature verification
Patch-mainline: TBD

Signed-off-by: Michal Marek <mmarek@suse.cz>
---
 init/Kconfig             |   11 ++++++++++-
 kernel/module-internal.h |    2 +-
 kernel/module.c          |   10 +++++++++-
 kernel/module_signing.c  |    5 ++++-
 4 files changed, 24 insertions(+), 4 deletions(-)

--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1446,7 +1446,7 @@ config MODULE_SRCVERSION_ALL
 	  will be created for all modules.  If unsure, say N.
 
 config MODULE_SIG
-	bool "Module signature verification"
+	bool "Module signature support"
 	depends on MODULES
 	select KEYS
 	select CRYPTO
@@ -1466,9 +1466,18 @@ config MODULE_SIG
 	  debuginfo strip done by some packagers (such as rpmbuild) and
 	  inclusion into an initramfs that wants the module size reduced.
 
+config MODULE_SIG_CHECK
+	bool "Check module signatures by default"
+	depends on MODULE_SIG
+	default y
+	help
+	  Check module signatures by default. Modules without signature or
+	  with an invalid signature taint the kernel with TAINT_FORCED_MODULE.
+
 config MODULE_SIG_FORCE
 	bool "Require modules to be validly signed"
 	depends on MODULE_SIG
+	select MODULE_SIG_CHECK
 	help
 	  Reject unsigned modules or signed modules for which we don't have a
 	  key.  Without this, such modules will simply taint the kernel.
--- a/kernel/module-internal.h
+++ b/kernel/module-internal.h
@@ -11,4 +11,4 @@
 
 extern struct key *modsign_keyring;
 
-extern int mod_verify_sig(const void *mod, unsigned long *_modlen);
+extern int mod_verify_sig(const void *mod, unsigned long *_modlen, bool truncate_only);
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -129,6 +129,13 @@ struct list_head *kdb_modules = &modules
 #endif /* CONFIG_KGDB_KDB */
 
 #ifdef CONFIG_MODULE_SIG
+#ifdef CONFIG_MODULE_SIG_CHECK
+static bool sig_check = true;
+#else
+static bool sig_check = false;
+#endif
+module_param(sig_check, bool, 0644);
+
 #ifdef CONFIG_MODULE_SIG_FORCE
 static bool sig_enforce = true;
 #else
@@ -164,6 +171,7 @@ static const struct kernel_param_ops par
 
 module_param(sig_enforce, bool_enable_only, 0644);
 #endif /* !CONFIG_MODULE_SIG_FORCE */
+
 #endif /* CONFIG_MODULE_SIG */
 
 /* Block module loading/unloading? */
@@ -2428,7 +2436,7 @@ static int module_sig_check(struct load_
 	    memcmp(mod + len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {
 		/* We truncate the module to discard the signature */
 		*_len -= markerlen;
-		err = mod_verify_sig(mod, _len);
+		err = mod_verify_sig(mod, _len, !sig_check && !sig_enforce);
 	}
 
 	if (!err) {
--- a/kernel/module_signing.c
+++ b/kernel/module_signing.c
@@ -183,7 +183,7 @@ static struct key *request_asymmetric_ke
 /*
  * Verify the signature on a module.
  */
-int mod_verify_sig(const void *mod, unsigned long *_modlen)
+int mod_verify_sig(const void *mod, unsigned long *_modlen, bool truncate_only)
 {
 	struct public_key_signature *pks;
 	struct module_signature ms;
@@ -209,6 +209,9 @@ int mod_verify_sig(const void *mod, unsi
 	modlen -= (size_t)ms.signer_len + ms.key_id_len;
 
 	*_modlen = modlen;
+	if (truncate_only)
+		return 0;
+
 	sig = mod + modlen;
 
 	/* For the moment, only support RSA and X.509 identifiers */
