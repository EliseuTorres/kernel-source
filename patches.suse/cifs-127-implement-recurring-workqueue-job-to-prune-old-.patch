From 2de970ff69bbcc5a4b7440df669a595b2b1acd73 Mon Sep 17 00:00:00 2001
From: Jeff Layton <jlayton@redhat.com>
Date: Wed, 6 Oct 2010 19:51:12 -0400
Subject: cifs: implement recurring workqueue job to prune old tcons
References: FATE#311695
Patch-mainline: yes

Create a workqueue job that cleans out unused tlinks. For now, it uses
a hardcoded expire time of 10 minutes. When it's done, the work rearms
itself. On umount, the work is cancelled before tearing down the tlink
tree.

Signed-off-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Steve French <sfrench@us.ibm.com>
Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
---
 fs/cifs/cifs_fs_sb.h |    2 +
 fs/cifs/cifsfs.c     |    9 ++++++
 fs/cifs/cifsfs.h     |    3 ++
 fs/cifs/connect.c    |   73 ++++++++++++++++++++++++++++++++++++++++++++++++++-
 4 files changed, 86 insertions(+), 1 deletion(-)

Index: linux-2.6.32-SLE11-SP2/fs/cifs/cifs_fs_sb.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/cifs_fs_sb.h
+++ linux-2.6.32-SLE11-SP2/fs/cifs/cifs_fs_sb.h
@@ -16,6 +16,7 @@
  *
  */
 #include <linux/radix-tree.h>
+#include <linux/workqueue.h>
 
 #ifndef _CIFS_FS_SB_H
 #define _CIFS_FS_SB_H
@@ -55,6 +56,7 @@ struct cifs_sb_info {
 	char   *prepath; /* relative path under the share to mount to */
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	char   *mountdata; /* mount options received at mount time */
+	struct delayed_work prune_tlinks;
 #endif
 };
 #endif				/* _CIFS_FS_SB_H */
Index: linux-2.6.32-SLE11-SP2/fs/cifs/connect.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/connect.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/connect.c
@@ -109,11 +109,15 @@ struct smb_vol {
 	struct nls_table *local_nls;
 };
 
+/* FIXME: should these be tunable? */
 #define TLINK_ERROR_EXPIRE	(1 * HZ)
-
+#define TLINK_IDLE_EXPIRE	(600 * HZ)
 
 static int ipv4_connect(struct TCP_Server_Info *server);
 static int ipv6_connect(struct TCP_Server_Info *server);
+static void cifs_prune_tlinks(struct work_struct *work);
+
+static struct workqueue_struct *tlinks_wq;
 
 /*
  * cifs tcp session reconnection
@@ -2494,6 +2498,8 @@ convert_delimiter(char *path, char delim
 static void setup_cifs_sb(struct smb_vol *pvolume_info,
 			  struct cifs_sb_info *cifs_sb)
 {
+	INIT_DELAYED_WORK(&cifs_sb->prune_tlinks, cifs_prune_tlinks);
+
 	if (pvolume_info->rsize > CIFSMaxBufSize) {
 		cERROR(1, "rsize %d too large, using MaxBufSize",
 			pvolume_info->rsize);
@@ -2904,6 +2910,9 @@ remote_path_check:
 	spin_unlock(&cifs_sb->tlink_tree_lock);
 	radix_tree_preload_end();
 
+	queue_delayed_work(tlinks_wq, &cifs_sb->prune_tlinks,
+				TLINK_IDLE_EXPIRE);
+
 mount_fail_check:
 	/* on error free sesinfo and tcon struct if needed */
 	if (rc) {
@@ -3095,6 +3104,8 @@ cifs_umount(struct super_block *sb, stru
 	struct tcon_link *tlink[8];
 	unsigned long index = 0;
 
+	cancel_delayed_work_sync(&cifs_sb->prune_tlinks);
+
 	do {
 		spin_lock(&cifs_sb->tlink_tree_lock);
 		ret = radix_tree_gang_lookup(&cifs_sb->tlink_tree,
@@ -3368,3 +3379,63 @@ wait_for_construction:
 
 	return tlink;
 }
+
+int cifs_create_tlinks_queue(void)
+{
+	tlinks_wq = create_singlethread_workqueue("cifs_tlinks");
+	if (!tlinks_wq)
+		return -ENOMEM;
+	return 0;
+}
+
+void cifs_destroy_tlinks_queue(void)
+{
+	destroy_workqueue(tlinks_wq);
+}
+
+/*
+ * periodic workqueue job that scans tcon_tree for a superblock and closes
+ * out tcons.
+ */
+static void
+cifs_prune_tlinks(struct work_struct *work)
+{
+	struct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,
+						    prune_tlinks.work);
+	struct tcon_link *tlink[8];
+	unsigned long now = jiffies;
+	unsigned long index = 0;
+	int i, ret;
+
+	do {
+		spin_lock(&cifs_sb->tlink_tree_lock);
+		ret = radix_tree_gang_lookup(&cifs_sb->tlink_tree,
+					     (void **)tlink, index,
+					     ARRAY_SIZE(tlink));
+		/* increment index for next pass */
+		if (ret > 0)
+			index = tlink[ret - 1]->tl_index + 1;
+		for (i = 0; i < ret; i++) {
+			if (test_bit(TCON_LINK_MASTER, &tlink[i]->tl_flags) ||
+			    atomic_read(&tlink[i]->tl_count) != 0 ||
+			    time_after(tlink[i]->tl_time + TLINK_IDLE_EXPIRE,
+				       now)) {
+				tlink[i] = NULL;
+				continue;
+			}
+			cifs_get_tlink(tlink[i]);
+			clear_bit(TCON_LINK_IN_TREE, &tlink[i]->tl_flags);
+			radix_tree_delete(&cifs_sb->tlink_tree,
+					  tlink[i]->tl_index);
+		}
+		spin_unlock(&cifs_sb->tlink_tree_lock);
+
+		for (i = 0; i < ret; i++) {
+			if (tlink[i] != NULL)
+				cifs_put_tlink(tlink[i]);
+		}
+	} while (ret != 0);
+
+	queue_delayed_work(tlinks_wq, &cifs_sb->prune_tlinks,
+				TLINK_IDLE_EXPIRE);
+}
Index: linux-2.6.32-SLE11-SP2/fs/cifs/cifsfs.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/cifsfs.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/cifsfs.c
@@ -954,8 +954,15 @@ init_cifs(void)
 	if (rc)
 		goto out_unregister_resolver_key;
 
+	rc = cifs_create_tlinks_queue();
+	if (rc)
+		goto out_unregister_slow_work;
+
 	return 0;
 
+ out_unregister_slow_work:
+	slow_work_unregister_user(THIS_MODULE);
+
  out_unregister_resolver_key:
 #ifdef CONFIG_CIFS_DFS_UPCALL
 	cifs_exit_dns_resolver();
Index: linux-2.6.32-SLE11-SP2/fs/cifs/cifsfs.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/cifsfs.h
+++ linux-2.6.32-SLE11-SP2/fs/cifs/cifsfs.h
@@ -110,6 +110,9 @@ extern ssize_t	cifs_getxattr(struct dent
 extern ssize_t	cifs_listxattr(struct dentry *, char *, size_t);
 extern long cifs_ioctl(struct file *filep, unsigned int cmd, unsigned long arg);
 
+extern int cifs_create_tlinks_queue(void);
+extern void cifs_destroy_tlinks_queue(void);
+
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 extern const struct export_operations cifs_export_ops;
 #endif /* EXPERIMENTAL */
