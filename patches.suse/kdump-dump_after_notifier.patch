From: Takenori Nagano <t-nagano@ah.jp.nec.com>
Subject: [PATCH] Add dump_after_notifier sysctl
Patch-mainline: never
References: 265764

This patch adds dump_after_notifier sysctl to execute kdump after the notifier
call chain. This basically makes it possible to execute KDB before kdump.

Signed-off-by: Takenori Nagano <t-nagano@ah.jp.nec.com>
Acked-by: Bernhard Walle <bwalle@suse.de>

---
 include/linux/kexec.h |    2 ++
 kernel/kexec.c        |   27 +++++++++++++++++++++++++++
 kernel/panic.c        |    5 ++++-
 3 files changed, 33 insertions(+), 1 deletion(-)

--- a/include/linux/kexec.h
+++ b/include/linux/kexec.h
@@ -158,6 +158,7 @@ unsigned long paddr_vmcoreinfo_note(void
 
 extern struct kimage *kexec_image;
 extern struct kimage *kexec_crash_image;
+extern int dump_after_notifier;
 
 #ifndef kexec_flush_icache_page
 #define kexec_flush_icache_page(page)
@@ -215,5 +216,6 @@ struct pt_regs;
 struct task_struct;
 static inline void crash_kexec(struct pt_regs *regs) { }
 static inline int kexec_should_crash(struct task_struct *p) { return 0; }
+#define dump_after_notifier 0
 #endif /* CONFIG_KEXEC */
 #endif /* LINUX_KEXEC_H */
--- a/kernel/kexec.c
+++ b/kernel/kexec.c
@@ -34,6 +34,7 @@
 #include <linux/swap.h>
 #include <linux/kmsg_dump.h>
 #include <linux/syscore_ops.h>
+#include <linux/sysctl.h>
 
 #include <asm/page.h>
 #include <asm/uaccess.h>
@@ -43,6 +44,7 @@
 
 /* Per cpu memory for storing cpu states in case of system crash. */
 note_buf_t __percpu *crash_notes;
+int dump_after_notifier;
 
 /* vmcoreinfo stuff */
 static unsigned char vmcoreinfo_data[VMCOREINFO_BYTES];
@@ -1202,6 +1204,28 @@ void crash_save_cpu(struct pt_regs *regs
 	final_note(buf);
 }
 
+#ifdef CONFIG_SYSCTL
+static ctl_table dump_after_notifier_table[] = {
+	{
+		.procname = "dump_after_notifier",
+		.data = &dump_after_notifier,
+		.maxlen = sizeof(int),
+		.mode = 0644,
+		.proc_handler = &proc_dointvec,
+	},
+	{ }
+};
+
+static ctl_table kexec_sys_table[] = {
+	{
+		.procname = "kernel",
+		.mode = 0555,
+		.child = dump_after_notifier_table,
+	},
+	{ }
+};
+#endif
+
 static int __init crash_notes_memory_init(void)
 {
 	/* Allocate memory for saving cpu registers. */
@@ -1211,6 +1235,9 @@ static int __init crash_notes_memory_ini
 		" states failed\n");
 		return -ENOMEM;
 	}
+#ifdef CONFIG_SYSCTL
+	register_sysctl_table(kexec_sys_table);
+#endif
 	return 0;
 }
 module_init(crash_notes_memory_init)
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -86,7 +86,8 @@ NORET_TYPE void panic(const char * fmt,
 	 * everything else.
 	 * Do we want to call this before we try to display a message?
 	 */
-	crash_kexec(NULL);
+	if (!dump_after_notifier)
+		crash_kexec(NULL);
 
 	kmsg_dump(KMSG_DUMP_PANIC);
 
@@ -99,6 +100,8 @@ NORET_TYPE void panic(const char * fmt,
 
 	atomic_notifier_call_chain(&panic_notifier_list, 0, buf);
 
+	crash_kexec(NULL);
+
 	bust_spinlocks(0);
 
 	if (!panic_blink)
