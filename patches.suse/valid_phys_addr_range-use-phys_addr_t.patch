From: Petr Tesarik <ptesarik@suse.cz>
Subject: valid_phys_addr_range: use phys_addr_t for the @addr parameter
Patch-Mainline: no
References: FATE#310031

The correct type for physical addresses is phys_addr_t. This is in
fact needed to check 64-bit physical addresses on 32-bit architectures
(such as i386 PAE).

For x86, xlate_dev_mem_ptr() can now handle high memory, so all physical
addresses are valid.  We needn't check the available physical memory (or
memory holes) here, because these cases are handled by xlate_dev_mem_ptr
(using pfn_valid).

Signed-off-by: Petr Tesarik <ptesarik@suse.cz>
---
 arch/arm/include/asm/io.h  |    2 +-
 arch/arm/mm/mmap.c         |    2 +-
 arch/ia64/include/asm/io.h |    2 +-
 arch/ia64/kernel/efi.c     |    2 +-
 arch/sh/include/asm/io.h   |    2 +-
 arch/sh/mm/mmap.c          |    2 +-
 arch/x86/include/asm/io.h  |   11 +++++++++++
 drivers/char/mem.c         |    2 +-
 8 files changed, 18 insertions(+), 7 deletions(-)

--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -79,7 +79,7 @@ static inline int uncached_access(struct
 }
 
 #ifndef ARCH_HAS_VALID_PHYS_ADDR_RANGE
-static inline int valid_phys_addr_range(unsigned long addr, size_t count)
+static inline int valid_phys_addr_range(phys_addr_t addr, size_t count)
 {
 	if (addr + count > __pa(high_memory))
 		return 0;
--- a/arch/arm/include/asm/io.h
+++ b/arch/arm/include/asm/io.h
@@ -271,7 +271,7 @@ extern void pci_iounmap(struct pci_dev *
 
 #ifdef CONFIG_MMU
 #define ARCH_HAS_VALID_PHYS_ADDR_RANGE
-extern int valid_phys_addr_range(unsigned long addr, size_t size);
+extern int valid_phys_addr_range(phys_addr_t addr, size_t size);
 extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
 #endif
 
--- a/arch/arm/mm/mmap.c
+++ b/arch/arm/mm/mmap.c
@@ -121,7 +121,7 @@ full_search:
  * You really shouldn't be using read() or write() on /dev/mem.  This
  * might go away in the future.
  */
-int valid_phys_addr_range(unsigned long addr, size_t size)
+int valid_phys_addr_range(phys_addr_t addr, size_t size)
 {
 	if (addr < PHYS_OFFSET)
 		return 0;
--- a/arch/sh/include/asm/io.h
+++ b/arch/sh/include/asm/io.h
@@ -310,7 +310,7 @@ __ioremap_mode(unsigned long offset, uns
 #define xlate_dev_kmem_ptr(p)	p
 
 #define ARCH_HAS_VALID_PHYS_ADDR_RANGE
-int valid_phys_addr_range(unsigned long addr, size_t size);
+int valid_phys_addr_range(phys_addr_t addr, size_t size);
 int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
 
 #endif /* __KERNEL__ */
--- a/arch/sh/mm/mmap.c
+++ b/arch/sh/mm/mmap.c
@@ -238,7 +238,7 @@ bottomup:
  * You really shouldn't be using read() or write() on /dev/mem.  This
  * might go away in the future.
  */
-int valid_phys_addr_range(unsigned long addr, size_t count)
+int valid_phys_addr_range(phys_addr_t addr, size_t count)
 {
 	if (addr < __MEMORY_START)
 		return 0;
--- a/arch/ia64/include/asm/io.h
+++ b/arch/ia64/include/asm/io.h
@@ -91,7 +91,7 @@ phys_to_virt (unsigned long address)
 
 #define ARCH_HAS_VALID_PHYS_ADDR_RANGE
 extern u64 kern_mem_attribute (unsigned long phys_addr, unsigned long size);
-extern int valid_phys_addr_range (unsigned long addr, size_t count); /* efi.c */
+extern int valid_phys_addr_range (phys_addr_t addr, size_t count); /* efi.c */
 extern int valid_mmap_phys_addr_range (unsigned long pfn, size_t count);
 
 /*
--- a/arch/ia64/kernel/efi.c
+++ b/arch/ia64/kernel/efi.c
@@ -867,7 +867,7 @@ kern_mem_attribute (unsigned long phys_a
 EXPORT_SYMBOL(kern_mem_attribute);
 
 int
-valid_phys_addr_range (unsigned long phys_addr, unsigned long size)
+valid_phys_addr_range (phys_addr_t phys_addr, unsigned long size)
 {
 	u64 attr;
 
--- a/arch/x86/include/asm/io.h
+++ b/arch/x86/include/asm/io.h
@@ -180,6 +180,17 @@ extern void set_iounmap_nonlazy(void);
 # include "io_64.h"
 #endif
 
+#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
+static inline int valid_phys_addr_range (phys_addr_t addr, size_t size)
+{
+	return 1;
+}
+
+static inline int valid_mmap_phys_addr_range (unsigned long pfn, size_t size)
+{
+	return 1;
+}
+
 extern void *xlate_dev_mem_ptr(phys_addr_t phys);
 extern void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr);
 
