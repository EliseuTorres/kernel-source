From: Jens Axboe <axboe@fb.com>
Date: Tue, 10 Jun 2014 12:53:56 -0600
Subject: block: ensure that bio_add_page() always accepts a page for an empty
References: bnc#940180,FATE#318723
Patch-Mainline: v3.17
Git-commit: 58a4915ad2f8a87f4456aac260396df7e300e6f2
 bio

With commit 762380ad9322 added support for chunk sizes and no merging
across them, it broke the rule of always allowing adding of a single
page to an empty bio. So relax the restriction a bit to allow for that,
similarly to what we have always done.

This fixes a crash with mkfs.xfs and 512b sector sizes on NVMe.

Reported-by: Keith Busch <keith.busch@intel.com>
Signed-off-by: Jens Axboe <axboe@fb.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 block/blk-settings.c | 5 ++++-
 fs/bio.c             | 7 ++++++-
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/block/blk-settings.c b/block/blk-settings.c
index 3633b9a..cf4895f 100644
--- a/block/blk-settings.c
+++ b/block/blk-settings.c
@@ -285,7 +285,10 @@ EXPORT_SYMBOL(blk_queue_max_hw_sectors);
  * Description:
  *    If a driver doesn't want IOs to cross a given chunk size, it can set
  *    this limit and prevent merging across chunks. Note that the chunk size
- *    must currently be a power-of-2 in sectors.
+ *    must currently be a power-of-2 in sectors. Also note that the block
+ *    layer must accept a page worth of data at any offset. So if the
+ *    crossing of chunks is a hard limitation in the driver, it must still be
+ *    prepared to split single page bios.
  **/
 void blk_queue_chunk_sectors(struct request_queue *q, unsigned int chunk_sectors)
 {
diff --git a/fs/bio.c b/fs/bio.c
index 76d39ea..8cf2fb1 100644
--- a/fs/bio.c
+++ b/fs/bio.c
@@ -759,8 +759,13 @@ int bio_add_page(struct bio *bio, struct page *page, unsigned int len,
 		 unsigned int offset)
 {
 	struct request_queue *q = bdev_get_queue(bio->bi_bdev);
+	unsigned int max_sectors;
 
-	return __bio_add_page(q, bio, page, len, offset, blk_max_size_offset(q, bio->bi_sector));
+	max_sectors = blk_max_size_offset(q, bio->bi_sector);
+	if ((max_sectors < (len >> 9)) && !bio->bi_size)
+		max_sectors = len >> 9;
+
+	return __bio_add_page(q, bio, page, len, offset, max_sectors);
 }
 EXPORT_SYMBOL(bio_add_page);
 
-- 
1.8.5.2

