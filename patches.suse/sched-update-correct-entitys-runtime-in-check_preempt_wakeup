Subject: sched: update correct entity's runtime in check_preempt_wakeup()
From: Paul Turner <pjt@google.com>
Date: Tue, 5 Jul 2011 19:07:21 -0700
Git-commit: 9bbd7374361d9bfc75108c3ad1c1b6db28b1be59
Patch-mainline: v3.1-rc1

While looking at check_preempt_wakeup() I realized that we are
potentially updating the wrong entity in the fair-group scheduling
case. In this case the current task's cfs_rq may not be the same as
the one used for the comparison between the waking task and the
existing task's vruntime.

This potentially results in us using a stale vruntime in the
pre-emption decision, providing a small false preference for the
previous task. The effects of this are bounded since we always
perform a hierarchal update on the tick.

Signed-off-by: Paul Turner <pjt@google.com>
Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/CAPM31R+2Ke2urUZKao5W92_LupdR4AYEv-EZWiJ3tG=tEes2cw@mail.gmail.com
Signed-off-by: Ingo Molnar <mingo@elte.hu>
Acked-by: Mike Galbraith <mgalbraith@suse.de>

---
 kernel/sched_fair.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

Index: linux-3.0-SLE11-SP2-3.0/kernel/sched_fair.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/kernel/sched_fair.c
+++ linux-3.0-SLE11-SP2-3.0/kernel/sched_fair.c
@@ -1921,8 +1921,8 @@ static void check_preempt_wakeup(struct
 	if (!sched_feat(WAKEUP_PREEMPT))
 		return;
 
-	update_curr(cfs_rq);
 	find_matching_se(&se, &pse);
+	update_curr(cfs_rq_of(se));
 	BUG_ON(!pse);
 	if (wakeup_preempt_entity(se, pse) == 1) {
 		/*
