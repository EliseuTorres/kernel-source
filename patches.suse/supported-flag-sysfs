From: Jeff Mahoney <jeffm@suse.com>
Subject: Export supported status via sysfs
Patch-mainline: Never, SLES feature

 This patch adds a /sys/kernel/supported file indicating the supportability
 status of the entire kernel.

 It also adds a /sys/module/<module>/supported file indicating the
 supportability status of individual modules.

 This is useful because it can be used to obtain the supported status
 of a running system without current modules (ie: immediately after
 a kernel update but before a reboot) and without generating an oops.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>

---

 include/linux/kernel.h |    1 
 include/linux/module.h |    1 
 kernel/ksysfs.c        |   23 +++++++++++++++
 kernel/module.c        |   71 +++++++++++++++++++++++++++++++++----------------
 kernel/panic.c         |    5 +++
 5 files changed, 78 insertions(+), 23 deletions(-)

Index: linux-3.0-tmp-jikos/include/linux/kernel.h
===================================================================
--- linux-3.0-tmp-jikos.orig/include/linux/kernel.h
+++ linux-3.0-tmp-jikos/include/linux/kernel.h
@@ -334,6 +334,7 @@ extern int panic_on_io_nmi;
 extern int unsupported;
 extern const char *print_tainted(void);
 extern void add_taint(unsigned flag);
+extern void add_nonfatal_taint(unsigned flag);
 extern int test_taint(unsigned flag);
 extern unsigned long get_taint(void);
 extern int root_mountflags;
Index: linux-3.0-tmp-jikos/include/linux/module.h
===================================================================
--- linux-3.0-tmp-jikos.orig/include/linux/module.h
+++ linux-3.0-tmp-jikos/include/linux/module.h
@@ -442,6 +442,7 @@ struct module *__module_address(unsigned
 bool is_module_address(unsigned long addr);
 bool is_module_percpu_address(unsigned long addr);
 bool is_module_text_address(unsigned long addr);
+const char *supported_printable(int taint);
 
 static inline int within_module_core(unsigned long addr, struct module *mod)
 {
Index: linux-3.0-tmp-jikos/kernel/ksysfs.c
===================================================================
--- linux-3.0-tmp-jikos.orig/kernel/ksysfs.c
+++ linux-3.0-tmp-jikos/kernel/ksysfs.c
@@ -166,6 +166,28 @@ static struct bin_attribute notes_attr =
 struct kobject *kernel_kobj;
 EXPORT_SYMBOL_GPL(kernel_kobj);
 
+const char *supported_printable(int taint)
+{
+	int mask = TAINT_PROPRIETARY_MODULE|TAINT_NO_SUPPORT;
+	if ((taint & mask) == mask)
+		return "No, Proprietary and Unsupported modules are loaded";
+	else if (taint & TAINT_PROPRIETARY_MODULE)
+		return "No, Proprietary modules are loaded";
+	else if (taint & TAINT_NO_SUPPORT)
+		return "No, Unsupported modules are loaded";
+	else if (taint & TAINT_EXTERNAL_SUPPORT)
+		return "Yes, External";
+	else
+		return "Yes";
+}
+
+static ssize_t supported_show(struct kobject *kobj,
+			      struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", supported_printable(get_taint()));
+}
+KERNEL_ATTR_RO(supported);
+
 static struct attribute * kernel_attrs[] = {
 	&fscaps_attr.attr,
 #if defined(CONFIG_HOTPLUG)
@@ -181,6 +203,7 @@ static struct attribute * kernel_attrs[]
 	&kexec_crash_size_attr.attr,
 	&vmcoreinfo_attr.attr,
 #endif
+	&supported_attr.attr,
 	NULL
 };
 
Index: linux-3.0-tmp-jikos/kernel/module.c
===================================================================
--- linux-3.0-tmp-jikos.orig/kernel/module.c
+++ linux-3.0-tmp-jikos/kernel/module.c
@@ -989,10 +989,36 @@ static struct module_attribute initstate
 	.show = show_initstate,
 };
 
+static void setup_modinfo_supported(struct module *mod, const char *s)
+{
+	if (!s) {
+		mod->taints |= (1 << TAINT_NO_SUPPORT);
+		return;
+	}
+
+	if (strcmp(s, "external") == 0)
+		mod->taints |= (1 << TAINT_EXTERNAL_SUPPORT);
+	else if (strcmp(s, "yes"))
+		mod->taints |= (1 << TAINT_NO_SUPPORT);
+}
+
+static ssize_t show_modinfo_supported(struct module_attribute *mattr,
+	                struct module *mod, char *buffer)
+{
+	return sprintf(buffer, "%s\n", supported_printable(mod->taints));
+}
+
+static struct module_attribute modinfo_supported = {
+	.attr = { .name = "supported", .mode = 0444 },
+	.show = show_modinfo_supported,
+	.setup = setup_modinfo_supported,
+};
+
 static struct module_attribute *modinfo_attrs[] = {
 	&modinfo_version,
 	&modinfo_srcversion,
 	&initstate,
+	&modinfo_supported,
 #ifdef CONFIG_MODULE_UNLOAD
 	&refcnt,
 #endif
@@ -2802,28 +2828,6 @@ static struct module *load_module(void _
 
 	flush_module_icache(mod);
 
-	supported = get_modinfo(sechdrs, infoindex, "supported");
-	if (supported) {
-		if (!strcmp(supported, "external"))
-			add_taint_module(mod, TAINT_EXTERNAL_SUPPORT);
-		else if (strcmp(supported, "yes"))
-			supported = NULL;
-	}
-	if (!supported) {
-		if (unsupported == 0) {
-			printk(KERN_WARNING "%s: module not supported by "
-			       "Novell, refusing to load. To override, echo "
-			       "1 > /proc/sys/kernel/unsupported\n", mod->name);
-			err = -ENOEXEC;
-			goto free_hdr;
-		}
-		add_taint_module(mod, TAINT_NO_SUPPORT);
-		if (unsupported == 1) {
-			printk(KERN_WARNING "%s: module not supported by "
-			       "Novell, setting U taint flag.\n", mod->name);
-		}
-	}
-
 	/* Now copy in args */
 	mod->args = strndup_user(uargs, ~0UL >> 1);
 	if (IS_ERR(mod->args)) {
@@ -2870,6 +2874,27 @@ static struct module *load_module(void _
 	if (err < 0)
 		goto unlink;
 
+	/* We don't use add_taint() here because it also disables lockdep. */
+	if (mod->taints & (1 << TAINT_EXTERNAL_SUPPORT))
+		add_nonfatal_taint(TAINT_EXTERNAL_SUPPORT);
+	else if (mod->taints == (1 << TAINT_NO_SUPPORT)) {
+		if (unsupported == 0) {
+			printk(KERN_WARNING "%s: module not supported by "
+					"Novell, refusing to load. To override, echo "
+					"1 > /proc/sys/kernel/unsupported\n", mod->name);
+			err = -ENOEXEC;
+			goto unlink;
+		}
+		add_nonfatal_taint(TAINT_NO_SUPPORT);
+		if (unsupported == 1) {
+			printk(KERN_WARNING "%s: module is not supported by "
+					"Novell. Novell Technical Services may decline "
+					"your support request if it involves a kernel "
+					"fault.\n", mod->name);
+		}
+	}
+
+
 	/* Get rid of temporary copy and strmap. */
 	kfree(info.strmap);
 	free_copy(&info);
@@ -3447,6 +3472,7 @@ void print_modules(void)
 	if (last_unloaded_module[0])
 		printk(" [last unloaded: %s]", last_unloaded_module);
 	printk("\n");
+	printk("Supported: %s\n", supported_printable(get_taint()));
 }
 
 #ifdef CONFIG_MODVERSIONS
Index: linux-3.0-tmp-jikos/kernel/panic.c
===================================================================
--- linux-3.0-tmp-jikos.orig/kernel/panic.c
+++ linux-3.0-tmp-jikos/kernel/panic.c
@@ -231,6 +231,11 @@ unsigned long get_taint(void)
 	return tainted_mask;
 }
 
+void add_nonfatal_taint(unsigned flag)
+{
+	set_bit(flag, &tainted_mask);
+}
+
 void add_taint(unsigned flag)
 {
 	/*
