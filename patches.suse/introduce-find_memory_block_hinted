From: Robin Holt <holt@sgi.com>
Subject: driver core: Introduce find_memory_block_hinted
Patch-mainline: 98383031ed77c6eb49ab612166fef9c0efe1604a
References: bnc#700512, FATE#311655

driver core: Introduce find_memory_block_hinted which utilizes kset_find_obj_hinted.

Introduce a find_memory_block_hinted() which utilizes the
recently added kset_find_obj_hinted().

Signed-off-by: Robin Holt <holt@sgi.com>
To: Dave Hansen <haveblue@us.ibm.com>
To: Matt Tolentino <matthew.e.tolentino@intel.com>
Reviewed-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
Acked-by: Torsten Duwe <duwe@suse.de>

---
 drivers/base/memory.c  |   28 ++++++++++++++++++----------
 include/linux/memory.h |    2 ++
 2 files changed, 20 insertions(+), 10 deletions(-)

--- a/drivers/base/memory.c	2011-06-15 11:11:16.000000000 -0500
+++ b/drivers/base/memory.c	2011-06-15 12:59:53.000000000 -0500
@@ -466,15 +466,8 @@ int __weak arch_get_memory_phys_device(u
 	return 0;
 }
 
-/*
- * For now, we have a linear search to go find the appropriate
- * memory_block corresponding to a particular phys_index. If
- * this gets to be a real problem, we can always use a radix
- * tree or something here.
- *
- * This could be made generic for all sysdev classes.
- */
-struct memory_block *find_memory_block(struct mem_section *section)
+struct memory_block *find_memory_block_hinted(struct mem_section *section,
+					      struct memory_block *hint)
 {
 	struct kobject *kobj;
 	struct sys_device *sysdev;
@@ -482,13 +475,15 @@ struct memory_block *find_memory_block(s
 	char name[sizeof(MEMORY_CLASS_NAME) + 9 + 1];
 	int block_id = base_memory_block_id(__section_nr(section));
 
+	kobj = hint ? &hint->sysdev.kobj : NULL;
+
 	/*
 	 * This only works because we know that section == sysdev->id
 	 * slightly redundant with sysdev_register()
 	 */
 	sprintf(&name[0], "%s%d", MEMORY_CLASS_NAME, block_id);
 
-	kobj = kset_find_obj(&memory_sysdev_class.kset, name);
+	kobj = kset_find_obj_hinted(&memory_sysdev_class.kset, name, kobj);
 	if (!kobj)
 		return NULL;
 
@@ -561,6 +556,19 @@ static int add_memory_section(int nid, s
 	return ret;
 }
 
+/*
+ * For now, we have a linear search to go find the appropriate
+ * memory_block corresponding to a particular phys_index. If
+ * this gets to be a real problem, we can always use a radix
+ * tree or something here.
+ *
+ * This could be made generic for all sysdev classes.
+ */
+struct memory_block *find_memory_block(struct mem_section *section)
+{
+	return find_memory_block_hinted(section, NULL);
+}
+
 int remove_memory_block(unsigned long node_id, struct mem_section *section,
 		int phys_device)
 {
--- a/include/linux/memory.h	2011-06-15 11:11:16.000000000 -0500
+++ b/include/linux/memory.h	2011-06-15 13:02:40.000000000 -0500
@@ -89,6 +89,8 @@ extern int unregister_memory_section(str
 extern int memory_dev_init(void);
 extern int remove_memory_block(unsigned long, struct mem_section *, int);
 extern int memory_notify(unsigned long val, void *v);
+extern struct memory_block *find_memory_block_hinted(struct mem_section *,
+						     struct memory_block *);
 extern struct memory_block *find_memory_block(struct mem_section *);
 #define CONFIG_MEM_BLOCK_SIZE	(PAGES_PER_SECTION<<PAGE_SHIFT)
 enum mem_add_context { BOOT, HOTPLUG };
