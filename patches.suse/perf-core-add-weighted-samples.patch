From: Andi Kleen <ak@linux.intel.com>
Subject: perf/core: Add weighted samples
Date: Thu Jan 24 16:10:28 2013 +0100
Git-commit: c3feedf2aaf9ac8bad6f19f5d21e4ee0b4b87e9c
Patch-mainline: v3.10-rc1
References: bnc#876114, fate#317174
Signed-off-by: Tony Jones <tonyj@suse.de>

    perf/core: Add weighted samples
    
    For some events it's useful to weight sample with a hardware
    provided number. This expresses how expensive the action the
    sample represent was.  This allows the profiler to scale
    the samples to be more informative to the programmer.
    
    There is already the period which is used similarly, but it
    means something different, so I chose to not overload it.
    Instead a new sample type for WEIGHT is added.
    
    Can be used for multiple things. Initially it is used for TSX
    abort costs and profiling by memory latencies (so to make
    expensive load appear higher up in the histograms). The concept
    is quite generic and can be extended to many other kinds of
    events or architectures, as long as the hardware provides
    suitable auxillary values. In principle it could be also used
    for software tracepoints.
    
    This adds the generic glue. A new optional sample format for a
    64-bit weight value.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Stephane Eranian <eranian@google.com>
    Cc: peterz@infradead.org
    Cc: acme@redhat.com
    Cc: jolsa@redhat.com
    Cc: namhyung.kim@lge.com
    Link: http://lkml.kernel.org/r/1359040242-8269-5-git-send-email-eranian@google.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index cd3bb2c..7ce0b37 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -573,6 +573,7 @@ struct perf_sample_data {
 	struct perf_callchain_entry	*callchain;
 	struct perf_raw_record		*raw;
 	struct perf_branch_stack	*br_stack;
+	u64				weight;
 };
 
 static inline void perf_sample_data_init(struct perf_sample_data *data,
@@ -586,6 +587,7 @@ static inline void perf_sample_data_init(struct perf_sample_data *data,
 	data->raw  = NULL;
 	data->br_stack = NULL;
 	data->period	= period;
+	data->weight = 0;
 }
 
 extern void perf_output_sample(struct perf_output_handle *handle,
diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index 9fa9c62..cdc255d 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -132,8 +132,10 @@ enum perf_event_sample_format {
 	PERF_SAMPLE_STREAM_ID			= 1U << 9,
 	PERF_SAMPLE_RAW				= 1U << 10,
 	PERF_SAMPLE_BRANCH_STACK		= 1U << 11,
+	PERF_SAMPLE_WEIGHT			= 1U << 14,
+
+	PERF_SAMPLE_MAX = 1U << 15,		/* non-ABI */
 
-	PERF_SAMPLE_MAX = 1U << 12,		/* non-ABI */
 };
 
 /*
@@ -588,6 +590,8 @@ enum perf_event_type {
 	 *	  char                  data[size];}&& PERF_SAMPLE_RAW
 	 *
 	 *	{ u64 from, to, flags } lbr[nr];} && PERF_SAMPLE_BRANCH_STACK
+	 *
+	 *	{ u64			weight;   } && PERF_SAMPLE_WEIGHT
 	 * };
 	 */
 	PERF_RECORD_SAMPLE			= 9,
diff --git a/kernel/events/core.c b/kernel/events/core.c
index 7b4a55d..9e3edb2 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -976,6 +976,9 @@ static void perf_event__header_size(struct perf_event *event)
 	if (sample_type & PERF_SAMPLE_PERIOD)
 		size += sizeof(data->period);
 
+	if (sample_type & PERF_SAMPLE_WEIGHT)
+		size += sizeof(data->weight);
+
 	if (sample_type & PERF_SAMPLE_READ)
 		size += event->read_size;
 
@@ -4193,6 +4196,9 @@ void perf_output_sample(struct perf_output_handle *handle,
 			perf_output_put(handle, nr);
 		}
 	}
+
+	if (sample_type & PERF_SAMPLE_WEIGHT)
+		perf_output_put(handle, data->weight);
 }
 
 void perf_prepare_sample(struct perf_event_header *header,
