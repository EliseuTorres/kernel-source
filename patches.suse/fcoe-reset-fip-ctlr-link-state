Subject: fcoe: reset FIP ctlr link state on disable/enable
From: Chris Leech <christopher.leech@intel.com>
References: bnc#590996
Patch-Mainline: 2.6.35

The FIP controler state wasn't being reset on a disable.
So FCF discovery would attempt to continue durring disable,
and login would jump directly to the non-FIP fallback on
enable.

Signed-off-by: Chris Leech <christopher.leech@intel.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---

 drivers/scsi/fcoe/fcoe.c |   11 +++++++----
 1 files changed, 7 insertions(+), 4 deletions(-)


diff --git a/drivers/scsi/fcoe/fcoe.c b/drivers/scsi/fcoe/fcoe.c
index abadea2..8cc5422 100644
--- a/drivers/scsi/fcoe/fcoe.c
+++ b/drivers/scsi/fcoe/fcoe.c
@@ -1904,9 +1904,10 @@ static int fcoe_disable(const char *buffer, struct kernel_param *kp)
 	fcoe = fcoe_hostlist_lookup_port(netdev);
 	rtnl_unlock();
 
-	if (fcoe)
+	if (fcoe) {
 		fc_fabric_logoff(fcoe->ctlr.lp);
-	else
+		fcoe_ctlr_link_down(&fcoe->ctlr);
+	} else
 		rc = -ENODEV;
 
 	dev_put(netdev);
@@ -1953,9 +1954,11 @@ static int fcoe_enable(const char *buffer, struct kernel_param *kp)
 	fcoe = fcoe_hostlist_lookup_port(netdev);
 	rtnl_unlock();
 
-	if (fcoe)
+	if (fcoe) {
+		if (!fcoe_link_ok(fcoe->ctlr.lp))
+			fcoe_ctlr_link_up(&fcoe->ctlr);
 		rc = fc_fabric_login(fcoe->ctlr.lp);
-	else
+	} else
 		rc = -ENODEV;
 
 	dev_put(netdev);
