From: Tejun Heo <tj@kernel.org>
Date: Mon, 10 May 2010 21:41:28 +0200
Subject: [PATCH] libata-sff: update bmdma host bus error handling
X-Git: 2a7adff09ac3dd3d1facaf92b4a8cc1b92d370b6
References: FATE#311692
Patch-Mainline: 2.6.34

* Clearing IRQ from ata_sff_error_handler() is necessary only when the
  port is gonna be thawed before performing EH actions and some
  controllers don't like being accessed after certain failure modes
  until they're reset.  Clear IRQ iff the port is being thawed.

* When the controller succesfully indicated bus error, the point of
  thawing doesn't matter.  Move thawing inside bmdma part of EH.  This
  is a bit ugly but will ease code reorganization later.

* Remove the unneeded ata_sff_sync().

Signed-off-by: Tejun Heo <tj@kernel.org>
Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/ata/libata-sff.c |   20 ++++++++++++--------
 1 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/drivers/ata/libata-sff.c b/drivers/ata/libata-sff.c
index 992628b..48921b4 100644
--- a/drivers/ata/libata-sff.c
+++ b/drivers/ata/libata-sff.c
@@ -2378,7 +2378,7 @@ void ata_sff_error_handler(struct ata_port *ap)
 	ata_reset_fn_t hardreset = ap->ops->hardreset;
 	struct ata_queued_cmd *qc;
 	unsigned long flags;
-	int thaw = 0;
+	bool thaw = false;
 
 	qc = __ata_qc_from_tag(ap, ap->link.active_tag);
 	if (qc && !(qc->flags & ATA_QCFLAG_FAILED))
@@ -2404,15 +2404,22 @@ void ata_sff_error_handler(struct ata_port *ap)
 		if (qc->err_mask == AC_ERR_TIMEOUT
 						&& (host_stat & ATA_DMA_ERR)) {
 			qc->err_mask = AC_ERR_HOST_BUS;
-			thaw = 1;
+			thaw = true;
 		}
 
 		ap->ops->bmdma_stop(qc);
+
+		/* if we're gonna thaw, make sure IRQ is clear */
+		if (thaw) {
+			ap->ops->sff_check_status(ap);
+			ap->ops->sff_irq_clear(ap);
+
+			spin_unlock_irqrestore(ap->lock, flags);
+			ata_eh_thaw_port(ap);
+			spin_lock_irqsave(ap->lock, flags);
+		}
 	}
 
-	ata_sff_sync(ap);		/* FIXME: We don't need this */
-	ap->ops->sff_check_status(ap);
-	ap->ops->sff_irq_clear(ap);
 	/* We *MUST* do FIFO draining before we issue a reset as several
 	 * devices helpfully clear their internal state and will lock solid
 	 * if we touch the data port post reset. Pass qc in case anyone wants
@@ -2423,9 +2430,6 @@ void ata_sff_error_handler(struct ata_port *ap)
 
 	spin_unlock_irqrestore(ap->lock, flags);
 
-	if (thaw)
-		ata_eh_thaw_port(ap);
-
 	/* PIO and DMA engines have been stopped, perform recovery */
 
 	/* Ignore ata_sff_softreset if ctl isn't accessible and
-- 
1.6.0.2

