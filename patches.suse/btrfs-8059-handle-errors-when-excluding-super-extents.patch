From: David Sterba <dsterba@suse.cz>
Date: Thu, 8 Mar 2012 02:14:32 +0100
Patch-mainline: pending
References: FATE#306586 bnc#751015
Subject: [PATCH] btrfs: handle errors when excluding super extents

Some images produced by btrfs-image cause a mount crash in rmap block
when excluding superblock extents. Handle the errors gracefully.

Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/extent-tree.c |   21 +++++++++++++++++----
 fs/btrfs/volumes.c     |   20 +++++++++++++++++---
 2 files changed, 34 insertions(+), 7 deletions(-)

--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -238,7 +238,7 @@ static int exclude_super_stripes(struct
 	u64 bytenr;
 	u64 *logical;
 	int stripe_len;
-	int i, nr, ret;
+	int i, nr, ret = -EIO;
 
 	if (cache->key.objectid < BTRFS_SUPER_INFO_OFFSET) {
 		stripe_len = BTRFS_SUPER_INFO_OFFSET - cache->key.objectid;
@@ -250,10 +250,17 @@ static int exclude_super_stripes(struct
 
 	for (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {
 		bytenr = btrfs_sb_offset(i);
+		if (bytenr <= cache->key.objectid + cache->key.offset)
+			break;
+		logical = NULL;
 		ret = btrfs_rmap_block(&root->fs_info->mapping_tree,
 				       cache->key.objectid, bytenr,
 				       0, &logical, &nr, &stripe_len);
-		BUG_ON(ret); /* -ENOMEM */
+		if (ret < 0) {
+			kfree(logical);
+			free_excluded_extents(root, cache);
+			goto out;
+		}
 
 		while (nr--) {
 			cache->bytes_super += stripe_len;
@@ -264,7 +271,9 @@ static int exclude_super_stripes(struct
 
 		kfree(logical);
 	}
-	return 0;
+
+out:
+	return ret;
 }
 
 static struct btrfs_caching_control *
@@ -7664,7 +7673,11 @@ int btrfs_read_block_groups(struct btrfs
 		 * info has super bytes accounted for, otherwise we'll think
 		 * we have more space than we actually do.
 		 */
-		exclude_super_stripes(root, cache);
+		ret = exclude_super_stripes(root, cache);
+		if (ret < 0) {
+			kfree(cache);
+			goto error;
+		}
 
 		/*
 		 * check for two cases, either we are full, and therefore
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -3910,12 +3910,22 @@ int btrfs_rmap_block(struct btrfs_mappin
 	u64 length;
 	u64 stripe_nr;
 	int i, j, nr = 0;
+	int ret = 0;
 
 	read_lock(&em_tree->lock);
 	em = lookup_extent_mapping(em_tree, chunk_start, 1);
 	read_unlock(&em_tree->lock);
 
-	BUG_ON(!em || em->start != chunk_start);
+	if (!em)
+		return -EIO;
+
+	if (em->start != chunk_start) {
+		printk(KERN_DEBUG "btrfs: rmap em->start %llu != %llu\n",
+				em->start, chunk_start);
+		ret = -EIO;
+		goto out_error;
+	}
+
 	map = (struct map_lookup *)em->bdev;
 
 	length = em->len;
@@ -3925,7 +3935,10 @@ int btrfs_rmap_block(struct btrfs_mappin
 		do_div(length, map->num_stripes);
 
 	buf = kzalloc(sizeof(u64) * map->num_stripes, GFP_NOFS);
-	BUG_ON(!buf); /* -ENOMEM */
+	if (!buf) {
+		ret = -ENOMEM;
+		goto out_error;
+	}
 
 	for (i = 0; i < map->num_stripes; i++) {
 		if (devid && map->stripes[i].dev->devid != devid)
@@ -3959,8 +3972,9 @@ int btrfs_rmap_block(struct btrfs_mappin
 	*naddrs = nr;
 	*stripe_len = map->stripe_len;
 
+out_error:
 	free_extent_map(em);
-	return 0;
+	return ret;
 }
 
 static void btrfs_end_bio(struct bio *bio, int err)
