From: Hannes Reinecke <hare@Suse.de>
Subject: dasd: Set and unset timeout flag automatically
References: bnc#768084
Patch-mainline: no

With this patch the TIMEOUT flag is set and unset automatically.
This avoids any delay in processing requests.

Signed-off-by: Hannes Reinecke <hare@suse.de>

---
 drivers/s390/block/dasd.c       |   11 +++++++++++
 drivers/s390/block/dasd_erp.c   |    4 ++++
 drivers/s390/block/dasd_ioctl.c |   12 ++++++++----
 3 files changed, 23 insertions(+), 4 deletions(-)

--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/s390/block/dasd.c
+++ linux-3.0-SLE11-SP2-BTMU/drivers/s390/block/dasd.c
@@ -2083,6 +2083,14 @@ restart:
 			goto restart;
 		}
 
+		/*
+		 * Clear timeout flag once a request
+		 * has returned without error
+		 */
+		if (cqr->status == DASD_CQR_DONE &&
+		    test_and_clear_bit(DASD_FLAG_TIMEOUT, &base->flags))
+			dev_err(&base->cdev->dev, "blk timeout flag unset\n");
+
 		/* Rechain finished requests to final queue */
 		cqr->endclk = get_clock();
 		list_move_tail(&cqr->blocklist, final_queue);
@@ -2293,6 +2301,9 @@ enum blk_eh_timer_return dasd_times_out(
 
 	device = cqr->startdev ? cqr->startdev : block->base;
 
+	if (!test_and_set_bit(DASD_FLAG_TIMEOUT, &device->flags))
+		dev_err(&device->cdev->dev, "blk timeout flag set\n");
+
 	spin_lock(&block->queue_lock);
 
 	/* Abort all requests in the queue */
--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/s390/block/dasd_erp.c
+++ linux-3.0-SLE11-SP2-BTMU/drivers/s390/block/dasd_erp.c
@@ -160,6 +160,10 @@ dasd_log_sense(struct dasd_ccw_req *cqr,
 	struct dasd_device *device;
 
 	device = cqr->startdev;
+	if (cqr->intrc == -ETIMEDOUT) {
+		dev_err(&device->cdev->dev, "cqr %p timeout error", cqr);
+		return;
+	}
 	/* dump sense data */
 	if (device->discipline && device->discipline->dump_sense)
 		device->discipline->dump_sense(device, cqr, irb);
--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/s390/block/dasd_ioctl.c
+++ linux-3.0-SLE11-SP2-BTMU/drivers/s390/block/dasd_ioctl.c
@@ -154,8 +154,12 @@ static int dasd_ioctl_timeout(struct das
 	if (!capable (CAP_SYS_ADMIN))
 		return -EACCES;
 
+	if (test_and_set_bit(DASD_FLAG_TIMEOUT, &base->flags))
+		return 0;
+
+	dev_err(&base->cdev->dev, "ioctl timeout flag set\n");
+
 	spin_lock_irqsave(&block->request_queue_lock, flags);
-	set_bit(DASD_FLAG_TIMEOUT, &base->flags);
 	/*
 	 * We need to abort the first noretry requests as
 	 * there might be requests on the ccw_queue.
@@ -195,9 +199,9 @@ static int dasd_ioctl_resync(struct dasd
 	if (!capable (CAP_SYS_ADMIN))
 		return -EACCES;
 
-	spin_lock_irqsave(get_ccwdev_lock(base->cdev), flags);
-	clear_bit(DASD_FLAG_TIMEOUT, &base->flags);
-	spin_unlock_irqrestore(get_ccwdev_lock(base->cdev), flags);
+	if (test_and_clear_bit(DASD_FLAG_TIMEOUT, &base->flags))
+		dev_err(&base->cdev->dev, "ioctl timeout flag unset\n");
+
 	return 0;
 }
 
