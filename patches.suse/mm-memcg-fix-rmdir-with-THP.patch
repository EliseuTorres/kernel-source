From: Mel Gorman <mgorman@suse.de>
Date: Mon, 23 May 2011 16:32:22 +0100
Subject: [PATCH] [PATCH] memcg: fix rmdir, force_empty with THP reimplementation
References: THP + memcg (fate #311931)
Patch-mainline: yes
Commit-ID: 987eba66e0e6aa654d60881a14731a353ee0acb4

Now, when THP is enabled, memcg's rmdir() function is broken because
move_account() for THP page is not supported.

This will cause account leak or -EBUSY issue at rmdir().  This patch
fixes the issue by supporting move_account() THP pages.

This is a reimplementation due to the number of memcg changes upstream.

Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Cc: Daisuke Nishimura <nishimura@mxp.nes.nec.co.jp>
Cc: Balbir Singh <balbir@linux.vnet.ibm.com>
Cc: Johannes Weiner <hannes@cmpxchg.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Mel Gorman <mgorman@suse.de>

---
 mm/memcontrol.c |   34 +++++++++++++++++++++++++---------
 1 files changed, 25 insertions(+), 9 deletions(-)

Index: linux-2.6.32-thp/mm/memcontrol.c
===================================================================
--- linux-2.6.32-thp.orig/mm/memcontrol.c
+++ linux-2.6.32-thp/mm/memcontrol.c
@@ -1649,13 +1649,15 @@ void mem_cgroup_split_huge_fixup(struct
  */
 
 static void __mem_cgroup_move_account(struct page_cgroup *pc,
-	struct mem_cgroup *from, struct mem_cgroup *to)
+	struct mem_cgroup *from, struct mem_cgroup *to,
+	int charge_size)
 {
 	struct page *page;
 	int cpu;
 	struct mem_cgroup_stat *stat;
 	struct mem_cgroup_stat_cpu *cpustat;
 	bool file = PageCgroupCache(pc);
+	int nr_pages = charge_size >> PAGE_SHIFT;
 
 	VM_BUG_ON(from == to);
 	VM_BUG_ON(PageLRU(pc->page));
@@ -1664,8 +1666,8 @@ static void __mem_cgroup_move_account(st
 	VM_BUG_ON(pc->mem_cgroup != from);
 
 	if (!mem_cgroup_is_root(from))
-		res_counter_uncharge(&from->res, PAGE_SIZE);
-	mem_cgroup_charge_statistics(from, pc, file, -1);
+		res_counter_uncharge(&from->res, charge_size);
+	mem_cgroup_charge_statistics(from, pc, file, -nr_pages);
 
 	page = pc->page;
 	if (page_mapped(page) && !PageAnon(page)) {
@@ -1684,12 +1686,12 @@ static void __mem_cgroup_move_account(st
 	}
 
 	if (do_swap_account && !mem_cgroup_is_root(from))
-		res_counter_uncharge(&from->memsw, PAGE_SIZE);
+		res_counter_uncharge(&from->memsw, charge_size);
 	css_put(&from->css);
 
 	css_get(&to->css);
 	pc->mem_cgroup = to;
-	mem_cgroup_charge_statistics(to, pc, file, 1);
+	mem_cgroup_charge_statistics(to, pc, file, nr_pages);
 	/*
 	 * We charges against "to" which may not have any tasks. Then, "to"
 	 * can be under rmdir(). But in current implementation, caller of
@@ -1703,12 +1705,17 @@ static void __mem_cgroup_move_account(st
  * __mem_cgroup_move_account()
  */
 static int mem_cgroup_move_account(struct page_cgroup *pc,
-				struct mem_cgroup *from, struct mem_cgroup *to)
+				struct mem_cgroup *from, struct mem_cgroup *to,
+				int charge_size)
 {
 	int ret = -EINVAL;
+
+	if ((charge_size > PAGE_SIZE) && !PageTransHuge(pc->page))
+		return -EBUSY;
+
 	lock_page_cgroup(pc);
 	if (PageCgroupUsed(pc) && pc->mem_cgroup == from) {
-		__mem_cgroup_move_account(pc, from, to);
+		__mem_cgroup_move_account(pc, from, to, charge_size);
 		ret = 0;
 	}
 	unlock_page_cgroup(pc);
@@ -1727,6 +1734,8 @@ static int mem_cgroup_move_parent(struct
 	struct cgroup *cg = child->css.cgroup;
 	struct cgroup *pcg = cg->parent;
 	struct mem_cgroup *parent;
+	int charge = PAGE_SIZE;
+	unsigned long flags;
 	int ret;
 
 	/* Is ROOT ? */
@@ -1738,17 +1747,24 @@ static int mem_cgroup_move_parent(struct
 		goto out;
 	if (isolate_lru_page(page))
 		goto put;
+	/* The page is isolated from LRU and we have no race with splitting */
+	charge = PAGE_SIZE << compound_order(page);
 
 	parent = mem_cgroup_from_cont(pcg);
-	ret = __mem_cgroup_try_charge(NULL, gfp_mask, &parent, false, page, PAGE_SIZE);
+	ret = __mem_cgroup_try_charge(NULL, gfp_mask, &parent, false, page, charge);
 	if (ret || !parent)
 		goto put_back;
 
-	ret = mem_cgroup_move_account(pc, child, parent);
+	if (charge > PAGE_SIZE)
+		flags = compound_lock_irqsave(page);
+
+	ret = mem_cgroup_move_account(pc, child, parent, charge);
 	if (!ret)
 		css_put(&parent->css);	/* drop extra refcnt by try_charge() */
 	else
-		mem_cgroup_cancel_charge(parent, PAGE_SIZE);	/* does css_put */
+		mem_cgroup_cancel_charge(parent, charge);	/* does css_put */
+	if (charge > PAGE_SIZE)
+		compound_unlock_irqrestore(page, flags);
 put_back:
 	putback_lru_page(page);
 put:
