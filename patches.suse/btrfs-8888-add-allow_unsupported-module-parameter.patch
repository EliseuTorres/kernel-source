From: David Sterba <dsterba@suse.cz>
Date: Fri, 18 Jan 2013 00:28:40 +0100
Patch-mainline: Never, SLES-specific
References: fate#314697
Subject: [PATCH] btrfs: add allow_unsupported module parameter

Disallow access to filesystem with unsupported features by default but
leave a chance to access the filesystem via module parameter override
(taints kernel).

The status can be toggled during runtime by changing the exported module
parameter in /sys/module/btrfs/parameters/allow_unsupported.

Current:
- mount: inode_cache - deny mount
- mount: autodefrag - deny mount
- ioctl: fallocate and hole punch - return, warning printed only once
- ioctl: receive - completely disallow
- ioctl: device replace - disallow
- mount: raid56 - remount RO
- mount: compression - deny mount
- mount: seeding device - deny mount
- balance: use of raid56 taints kernel
- chattr: +c - disallow, no change

Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/ctree.h   |    5 +++
 fs/btrfs/disk-io.c |   14 ++++++++++
 fs/btrfs/file.c    |    8 +++++-
 fs/btrfs/ioctl.c   |   28 ++++++++++++++++++++-
 fs/btrfs/send.c    |    5 +++
 fs/btrfs/super.c   |   70 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 128 insertions(+), 2 deletions(-)

--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -4123,4 +4123,9 @@ int btrfs_verify_qgroup_counts(struct bt
 			       u64 rfer, u64 excl);
 #endif
 
+/*
+ * Module parameter
+ */
+extern bool btrfs_allow_unsupported;
+
 #endif
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -2439,6 +2439,14 @@ int open_ctree(struct super_block *sb,
 	if (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_ERROR)
 		set_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);
 
+	if (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_SEEDING) {
+		if (!btrfs_allow_unsupported) {
+			printk(KERN_WARNING "btrfs: seeding mode is not supported, load module with allow_unsupported=1\n");
+			ret = -EOPNOTSUPP;
+			goto fail_alloc;
+		}
+	}
+
 	/*
 	 * run through our array of backup supers and setup
 	 * our ring pointer to the oldest one
@@ -2521,6 +2529,12 @@ int open_ctree(struct super_block *sb,
 				sb->s_id);
 		goto fail_alloc;
 	}
+	if (features & BTRFS_FEATURE_INCOMPAT_RAID56) {
+		if (!btrfs_allow_unsupported) {
+			printk(KERN_WARNING "btrfs: RAID56 is supported read-only, load module with allow_unsupported=1\n");
+			sb->s_flags |= MS_RDONLY;
+		}
+	}
 
 	/*
 	 * Needn't use the lock because there is no other task which will
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@ -2472,8 +2472,14 @@ static long btrfs_fallocate(struct file
 	if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))
 		return -EOPNOTSUPP;
 
-	if (mode & FALLOC_FL_PUNCH_HOLE)
+	if (mode & FALLOC_FL_PUNCH_HOLE) {
+		if (!btrfs_allow_unsupported) {
+			printk_once(KERN_WARNING
+		"btrfs: fallocate/PUNCH_HOLE is not supported, load module with allow_unsupported=1\n");
+			return -EOPNOTSUPP;
+		}
 		return btrfs_punch_hole(inode, offset, len);
+	}
 
 	/*
 	 * Make sure we have enough space before we do the
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -142,6 +142,15 @@ void btrfs_inherit_iflags(struct inode *
 
 	flags = BTRFS_I(dir)->flags;
 
+	/*
+	 * This should not happen, but just in case
+	 */
+	if (!btrfs_allow_unsupported && (flags & BTRFS_INODE_COMPRESS)) {
+		printk_once(KERN_WARNING
+			"btrfs: detected directory with compression bit set, not inherited, load module with allow_unsupported=1\n");
+		flags &= ~BTRFS_INODE_COMPRESS;
+	}
+
 	if (flags & BTRFS_INODE_NOCOMPRESS) {
 		BTRFS_I(inode)->flags &= ~BTRFS_INODE_COMPRESS;
 		BTRFS_I(inode)->flags |= BTRFS_INODE_NOCOMPRESS;
@@ -205,6 +214,12 @@ static int btrfs_ioctl_setflags(struct f
 	if (copy_from_user(&flags, arg, sizeof(flags)))
 		return -EFAULT;
 
+	if (!btrfs_allow_unsupported && (flags & FS_COMPR_FL)) {
+		printk_ratelimited(KERN_WARNING
+			"btrfs: IOC_SETFLAGS: enabling compression is not supported, load module with allow_unsupported=1\n");
+		return -EOPNOTSUPP;
+	}
+
 	ret = check_flags(flags);
 	if (ret)
 		return ret;
@@ -4985,6 +5000,7 @@ long btrfs_ioctl(struct file *file, unsi
 {
 	struct btrfs_root *root = BTRFS_I(file_inode(file))->root;
 	void __user *argp = (void __user *)arg;
+	int ret = -ENOTTY;
 
 	switch (cmd) {
 	case FS_IOC_GETFLAGS:
@@ -5077,6 +5093,11 @@ long btrfs_ioctl(struct file *file, unsi
 	case BTRFS_IOC_BALANCE_PROGRESS:
 		return btrfs_ioctl_balance_progress(root, argp);
 	case BTRFS_IOC_SET_RECEIVED_SUBVOL:
+		if (!btrfs_allow_unsupported) {
+			printk(KERN_WARNING "btrfs: IOC_SET_RECEIVED_SUBVOL is not supported, load module with allow_unsupported=1\n");
+			ret = -EOPNOTSUPP;
+			break;
+		}
 		return btrfs_ioctl_set_received_subvol(file, argp);
 	case BTRFS_IOC_SEND:
 		return btrfs_ioctl_send(file, argp);
@@ -5097,6 +5118,11 @@ long btrfs_ioctl(struct file *file, unsi
 	case BTRFS_IOC_QUOTA_RESCAN_WAIT:
 		return btrfs_ioctl_quota_rescan_wait(file, argp);
 	case BTRFS_IOC_DEV_REPLACE:
+		if (!btrfs_allow_unsupported) {
+			printk(KERN_WARNING "btrfs: IOC_DEV_REPLACE is not supported, load module with allow_unsupported=1\n");
+			ret = -EOPNOTSUPP;
+			break;
+		}
 		return btrfs_ioctl_dev_replace(root, argp);
 	case BTRFS_IOC_GET_FSLABEL:
 		return btrfs_ioctl_get_fslabel(file, argp);
@@ -5112,5 +5138,5 @@ long btrfs_ioctl(struct file *file, unsi
 		return btrfs_ioctl_set_features(file, argp);
 	}
 
-	return -ENOTTY;
+	return ret;
 }
--- a/fs/btrfs/send.c
+++ b/fs/btrfs/send.c
@@ -5618,6 +5618,11 @@ long btrfs_ioctl_send(struct file *mnt_f
 		ret = -EINVAL;
 		goto out;
 	}
+	if (!btrfs_allow_unsupported && !(arg->flags & BTRFS_SEND_FLAG_NO_FILE_DATA)) {
+		printk(KERN_WARNING "btrfs: IOC_SEND supported in NO_FILE_DATA mode, load module with allow_unsupported=1\n");
+		ret = -EOPNOTSUPP;
+		goto out;
+	}
 
 	sctx = kzalloc(sizeof(struct send_ctx), GFP_NOFS);
 	if (!sctx) {
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -18,6 +18,7 @@
 
 #include <linux/blkdev.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/buffer_head.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
@@ -491,6 +492,11 @@ int btrfs_parse_options(struct btrfs_roo
 			/* Fallthrough */
 		case Opt_compress:
 		case Opt_compress_type:
+			if (!btrfs_allow_unsupported) {
+				printk(KERN_WARNING "btrfs: compression is not supported, load module with allow_unsupported=1\n");
+				ret = -EOPNOTSUPP;
+				break;
+			}
 			compress = true;
 			if (token == Opt_compress ||
 			    token == Opt_compress_force ||
@@ -655,6 +661,11 @@ int btrfs_parse_options(struct btrfs_roo
 					     "disabling disk space caching");
 			break;
 		case Opt_inode_cache:
+			if (!btrfs_allow_unsupported) {
+				printk(KERN_WARNING "btrfs: inode_cache is not supported, load module with allow_unsupported=1\n");
+				ret = -EOPNOTSUPP;
+				break;
+			}
 			btrfs_set_and_info(root, CHANGE_INODE_CACHE,
 					   "enabling inode map caching");
 			break;
@@ -676,6 +687,11 @@ int btrfs_parse_options(struct btrfs_roo
 			btrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);
 			break;
 		case Opt_defrag:
+			if (!btrfs_allow_unsupported) {
+				printk(KERN_WARNING "btrfs: autodefrag is not supported, load module with allow_unsupported=1\n");
+				ret = -EOPNOTSUPP;
+				break;
+			}
 			btrfs_set_and_info(root, AUTO_DEFRAG,
 					   "enabling auto defrag");
 			break;
@@ -1461,6 +1477,13 @@ static int btrfs_remount(struct super_bl
 			ret = -EACCES;
 			goto restore;
 		}
+		if ((btrfs_super_incompat_flags(fs_info->super_copy)
+					& BTRFS_FEATURE_INCOMPAT_RAID56)
+				&& !btrfs_allow_unsupported) {
+			printk(KERN_WARNING "btrfs: cannot remount RW, RAID56 is supported read-only, load module with allow_unsupported=1\n");
+			ret = -EINVAL;
+			goto restore;
+		}
 
 		if (btrfs_super_log_root(fs_info->super_copy) != 0) {
 			ret = -EINVAL;
@@ -2014,6 +2037,13 @@ static int __init init_btrfs_fs(void)
 
 	btrfs_print_info();
 
+#ifdef CONFIG_SUSE_KERNEL_SUPPORTED
+	if (btrfs_allow_unsupported) {
+		add_taint(TAINT_NO_SUPPORT, LOCKDEP_STILL_OK);
+		printk(KERN_INFO "btrfs: allow_unsupported=1 taints kernel\n");
+	}
+#endif
+
 	err = btrfs_run_sanity_tests();
 	if (err)
 		goto unregister_ioctl;
@@ -2068,6 +2098,46 @@ static void __exit exit_btrfs_fs(void)
 	btrfs_hash_exit();
 }
 
+#ifdef CONFIG_SUSE_KERNEL_SUPPORTED
+bool btrfs_allow_unsupported = false;
+#else
+bool btrfs_allow_unsupported = true;
+#endif
+
+static int btrfs_set_allow_unsupported(const char *buffer, const struct kernel_param *kp)
+{
+	int ret;
+	struct kernel_param dummy_kp = *kp;
+	bool newval;
+
+	dummy_kp.arg = &newval;
+
+	ret = param_set_bool(buffer, &dummy_kp);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_SUSE_KERNEL_SUPPORTED
+	if (btrfs_allow_unsupported && !newval) {
+		printk(KERN_INFO "btrfs: disallowing unsupported features, kernel remains tainted\n");
+		btrfs_allow_unsupported = false;
+	} else if (!btrfs_allow_unsupported && newval) {
+		printk(KERN_INFO "btrfs: allowing unsupported features, kernel tainted\n");
+		add_taint(TAINT_NO_SUPPORT, LOCKDEP_STILL_OK);
+		btrfs_allow_unsupported = true;
+	}
+#endif
+	return 0;
+}
+
+static struct kernel_param_ops btrfs_allow_unsupported_param_ops = {
+	.set = btrfs_set_allow_unsupported,
+	.get = param_get_bool,
+};
+
+module_param_cb(allow_unsupported, &btrfs_allow_unsupported_param_ops,
+		&btrfs_allow_unsupported, 0644);
+MODULE_PARM_DESC(allow_unsupported, "Allow using features that are out of supported scope");
+
 late_initcall(init_btrfs_fs);
 module_exit(exit_btrfs_fs)
 
