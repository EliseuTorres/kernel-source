From: NeilBrown <neilb@suse.de>
Subject: update overlayfs to account for changes to support NFSv4 delegations
Patch-mainline: no
References: bnc#876463

Support for releasing delegations on rename/unlink etc required an
extra arg to be added to various function.  This patch adds a NULL
to those functions for overlayfs.

Acked-by: NeilBrown <neilb@suse.de>
Signed-off-by: Neil Brown <neilb@suse.de>

---
 fs/overlayfs/copy_up.c |    6 +++---
 fs/overlayfs/dir.c     |   10 +++++-----
 fs/overlayfs/inode.c   |    2 +-
 fs/overlayfs/readdir.c |    2 +-
 4 files changed, 10 insertions(+), 10 deletions(-)

--- linux-3.12-SLE12.orig/fs/overlayfs/copy_up.c
+++ linux-3.12-SLE12/fs/overlayfs/copy_up.c
@@ -164,7 +164,7 @@ static int ovl_set_timestamps(struct den
 		.ia_mtime = stat->mtime,
 	};
 
-	return notify_change(upperdentry, &attr);
+	return notify_change(upperdentry, &attr, NULL);
 }
 
 static int ovl_set_mode(struct dentry *upperdentry, umode_t mode)
@@ -174,7 +174,7 @@ static int ovl_set_mode(struct dentry *u
 		.ia_mode = mode,
 	};
 
-	return notify_change(upperdentry, &attr);
+	return notify_change(upperdentry, &attr, NULL);
 }
 
 static int ovl_copy_up_locked(struct dentry *upperdir, struct dentry *dentry,
@@ -229,7 +229,7 @@ err_remove:
 	if (S_ISDIR(stat->mode))
 		vfs_rmdir(upperdir->d_inode, newpath.dentry);
 	else
-		vfs_unlink(upperdir->d_inode, newpath.dentry);
+		vfs_unlink(upperdir->d_inode, newpath.dentry, NULL);
 
 	dput(newpath.dentry);
 
--- linux-3.12-SLE12.orig/fs/overlayfs/dir.c
+++ linux-3.12-SLE12/fs/overlayfs/dir.c
@@ -59,7 +59,7 @@ static int ovl_whiteout(struct dentry *u
 
 	err = vfs_setxattr(newdentry, ovl_whiteout_xattr, "y", 1, 0);
 	if (err)
-		vfs_unlink(upperdir->d_inode, newdentry);
+		vfs_unlink(upperdir->d_inode, newdentry, NULL);
 
 out_dput:
 	dput(newdentry);
@@ -117,7 +117,7 @@ static struct dentry *ovl_lookup_create(
 
 		err = -EEXIST;
 		if (ovl_is_whiteout(newdentry))
-			err = vfs_unlink(upperdir->d_inode, newdentry);
+			err = vfs_unlink(upperdir->d_inode, newdentry, NULL);
 
 		revert_creds(old_cred);
 		put_cred(override_cred);
@@ -367,7 +367,7 @@ static int ovl_do_remove(struct dentry *
 		if (is_dir)
 			err = vfs_rmdir(upperdir->d_inode, realpath.dentry);
 		else
-			err = vfs_unlink(upperdir->d_inode, realpath.dentry);
+			err = vfs_unlink(upperdir->d_inode, realpath.dentry, NULL);
 		if (err)
 			goto out_d_drop;
 
@@ -436,7 +436,7 @@ static int ovl_link(struct dentry *old,
 		goto out_unlock;
 
 	olddentry = ovl_dentry_upper(old);
-	err = vfs_link(olddentry, upperdir->d_inode, newdentry);
+	err = vfs_link(olddentry, upperdir->d_inode, newdentry, NULL);
 	if (!err) {
 		if (WARN_ON(!newdentry->d_inode)) {
 			dput(newdentry);
@@ -557,7 +557,7 @@ static int ovl_rename(struct inode *oldd
 	}
 
 	err = vfs_rename(old_upperdir->d_inode, olddentry,
-			 new_upperdir->d_inode, newdentry);
+			 new_upperdir->d_inode, newdentry, NULL);
 
 	if (err) {
 		if (new_create && ovl_dentry_is_opaque(new))
--- linux-3.12-SLE12.orig/fs/overlayfs/inode.c
+++ linux-3.12-SLE12/fs/overlayfs/inode.c
@@ -30,7 +30,7 @@ int ovl_setattr(struct dentry *dentry, s
 		attr->ia_valid &= ~ATTR_MODE;
 
 	mutex_lock(&upperdentry->d_inode->i_mutex);
-	err = notify_change(upperdentry, attr);
+	err = notify_change(upperdentry, attr, NULL);
 	if (!err)
 		ovl_copyattr(upperdentry->d_inode, dentry->d_inode);
 	mutex_unlock(&upperdentry->d_inode->i_mutex);
--- linux-3.12-SLE12.orig/fs/overlayfs/readdir.c
+++ linux-3.12-SLE12/fs/overlayfs/readdir.c
@@ -536,7 +536,7 @@ static int ovl_remove_whiteouts(struct d
 			    p->len, p->name, PTR_ERR(dentry));
 			continue;
 		}
-		ret = vfs_unlink(upperdir->d_inode, dentry);
+		ret = vfs_unlink(upperdir->d_inode, dentry, NULL);
 		dput(dentry);
 		if (ret)
 			pr_warn(
