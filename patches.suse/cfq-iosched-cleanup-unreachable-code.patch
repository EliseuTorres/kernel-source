From: Corrado Zoccolo <czoccolo@gmail.com>
Date: Thu, 26 Nov 2009 09:41:21 +0100
Subject: [PATCH] cfq-iosched: cleanup unreachable code
Git-commit: c16632bab1a17e357cec66920ceb3f0630009360
References: FATE#311054
Patch-Mainline: 2.6.33

cfq_should_idle returns false for no-idle queues that are not the last,
so the control flow will never reach the removed code in a state that
satisfies the if condition.
The unreachable code was added to emulate previous cfq behaviour for
non-NCQ rotational devices. My tests show that even without it, the
performances and fairness are comparable with previous cfq, thanks to
the fact that all seeky queues are grouped together, and that we idle at
the end of the tree.

Signed-off-by: Corrado Zoccolo <czoccolo@gmail.com>
Acked-by: Vivek Goyal <vgoyal@redhat.com>
Signed-off-by: Jens Axboe <jens.axboe@oracle.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 block/cfq-iosched.c |   13 -------------
 1 files changed, 0 insertions(+), 13 deletions(-)

diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c
index e8c6fbe..c3364af 100644
--- a/block/cfq-iosched.c
+++ b/block/cfq-iosched.c
@@ -1271,19 +1271,6 @@ static void cfq_arm_slice_timer(struct cfq_data *cfqd)
 	cfq_mark_cfqq_wait_request(cfqq);
 
 	sl = cfqd->cfq_slice_idle;
-	/* are we servicing noidle tree, and there are more queues?
-	 * non-rotational or NCQ: no idle
-	 * non-NCQ rotational : very small idle, to allow
-	 *     fair distribution of slice time for a process doing back-to-back
-	 *     seeks.
-	 */
-	if (cfqd->serving_type == SYNC_NOIDLE_WORKLOAD &&
-	    service_tree_for(cfqd->serving_prio, SYNC_NOIDLE_WORKLOAD, cfqd)
-		->count > 0) {
-		if (blk_queue_nonrot(cfqd->queue) || cfqd->hw_tag)
-			return;
-		sl = min(sl, msecs_to_jiffies(CFQ_MIN_TT));
-	}
 
 	mod_timer(&cfqd->idle_slice_timer, jiffies + sl);
 	cfq_log_cfqq(cfqd, cfqq, "arm_idle: %lu", sl);
-- 
1.6.0.2

