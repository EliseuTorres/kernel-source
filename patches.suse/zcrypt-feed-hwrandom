From: Torsten Duwe <duwe@suse.de>
Subject: s390: provide hardware randomness from zcrypt card to /dev/random
Patch-mainline: not yet submitted
References: fate 310591

Running completely virtualised, system Z severely lacks good true random sources.
Gathering entropy in a virtual environment is difficult. To compensate, there is
specialised crypto hardware which includes a source for hardware randomness;
the zcrypt driver is able to access this random source. This patch adds an interface
to the random pool for feeding entropy in-kernel and enables the driver to utilise
it. This may be considered a kernel equivalent of the user-space entropy daemon which
works automatically and without the risk of random bits being compromised
in user space.

Signed-off-by: Torsten Duwe <duwe@suse.de>
Acked-by: Torsten Duwe <duwe@suse.de>

--- a/include/linux/hw_random.h	2011-07-14 18:26:24.613446970 +0200
+++ b/include/linux/hw_random.h	2011-07-14 18:25:39.172974576 +0200
@@ -44,5 +44,7 @@ struct hwrng {
 extern int hwrng_register(struct hwrng *rng);
 /** Unregister a Hardware Random Number Generator driver. */
 extern void hwrng_unregister(struct hwrng *rng);
+/** Feed random bits into the pool. */
+extern void add_hwgenerator_randomness(const char *buffer, size_t count);
 
 #endif /* LINUX_HWRANDOM_H_ */
--- a/drivers/char/random.c	2011-07-14 18:25:00.436571389 +0200
+++ b/drivers/char/random.c	2011-07-14 18:31:57.620890778 +0200
@@ -714,6 +714,24 @@ void add_disk_randomness(struct gendisk
 }
 #endif
 
+/* Interface for in-kernel drivers of true hardware RNGs.
+ * Those devices may produce endless random bits and will be throttled
+ * when our pool is full.
+ */
+void add_hwgenerator_randomness(const char *buffer, size_t count)
+{
+	struct entropy_store *poolp = &nonblocking_pool;
+
+	/* Suspend writing if we're above the trickle threshold.
+	 * We'll be woken up again once below random_write_wakeup_thresh.
+	 */
+	wait_event_interruptible(random_write_wait,
+				 input_pool.entropy_count <= trickle_thresh);
+	mix_pool_bytes(poolp, buffer, count);
+	credit_entropy_bits(poolp, count*8);
+}
+EXPORT_SYMBOL_GPL(add_hwgenerator_randomness);
+
 #define EXTRACT_SIZE 10
 
 /*********************************************************************
--- a/drivers/s390/crypto/zcrypt_api.c	2011-07-14 18:25:00.440571431 +0200
+++ b/drivers/s390/crypto/zcrypt_api.c	2011-07-14 18:28:08.710526877 +0200
@@ -38,6 +38,7 @@
 #include <asm/atomic.h>
 #include <asm/uaccess.h>
 #include <linux/hw_random.h>
+#include <linux/kthread.h>
 
 #include "zcrypt_api.h"
 
@@ -1129,6 +1130,8 @@ static int zcrypt_rng_device_count;
 static u32 *zcrypt_rng_buffer;
 static int zcrypt_rng_buffer_index;
 static DEFINE_MUTEX(zcrypt_rng_mutex);
+static struct task_struct *zcrypt_hwrng_fill;
+static u32 rng_pooldata;
 
 static int zcrypt_rng_data_read(struct hwrng *rng, u32 *data)
 {
@@ -1153,6 +1156,16 @@ static struct hwrng zcrypt_rng_dev = {
 	.data_read	= zcrypt_rng_data_read,
 };
 
+static void zcrypt_hwrng_fillfn(void * unused)
+{
+	while (!kthread_should_stop())
+		{
+			zcrypt_rng_data_read(&zcrypt_rng_dev, &rng_pooldata);
+			add_hwgenerator_randomness(&rng_pooldata, sizeof(u32));
+		}
+	do_exit(0);
+}
+
 static int zcrypt_rng_device_add(void)
 {
 	int rc = 0;
@@ -1169,6 +1182,7 @@ static int zcrypt_rng_device_add(void)
 		if (rc)
 			goto out_free;
 		zcrypt_rng_device_count = 1;
+		zcrypt_hwrng_fill = kthread_run(zcrypt_hwrng_fillfn, NULL, "zcrypt_hwrng_fill");
 	} else
 		zcrypt_rng_device_count++;
 	mutex_unlock(&zcrypt_rng_mutex);
@@ -1186,6 +1200,8 @@ static void zcrypt_rng_device_remove(voi
 	mutex_lock(&zcrypt_rng_mutex);
 	zcrypt_rng_device_count--;
 	if (zcrypt_rng_device_count == 0) {
+		if (zcrypt_hwrng_fill)
+			kthread_stop(zcrypt_hwrng_fill);
 		hwrng_unregister(&zcrypt_rng_dev);
 		free_page((unsigned long) zcrypt_rng_buffer);
 	}
