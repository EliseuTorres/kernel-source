From: Josef Bacik <josef@redhat.com>
Date: Fri, 18 Mar 2011 15:27:43 -0400
Patch-mainline: yes
References: FATE#306586
Subject: [PATCH] Btrfs: deal with min_bytes appropriately when
 looking for a cluster

We do all this fun stuff with min_bytes, but either don't use it in the case of
just normal extents, or use it completely wrong in the case of bitmaps.  So fix
this for both cases

1) In the extent case, stop looking for space with window_free >= min_bytes
instead of bytes + empty_size.

2) In the bitmap case, we were looking for streches of free space that was at
least min_bytes in size, which was not right at all.  So instead search for
stretches of free space that are at least bytes in size (this will make a
difference when we have > page size blocks) and then only search for min_bytes
amount of free space.

Thanks,

Reviewed-by: Li Zefan <lizf@cn.fujitsu.com>
Signed-off-by: Josef Bacik <josef@redhat.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/free-space-cache.c |    9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@ -1909,8 +1909,8 @@ static int btrfs_bitmap_cluster(struct b
 
 	i = offset_to_bit(entry->offset, block_group->sectorsize,
 			  max_t(u64, offset, entry->offset));
-	search_bits = bytes_to_bits(min_bytes, block_group->sectorsize);
-	total_bits = bytes_to_bits(bytes, block_group->sectorsize);
+	search_bits = bytes_to_bits(bytes, block_group->sectorsize);
+	total_bits = bytes_to_bits(min_bytes, block_group->sectorsize);
 
 again:
 	found_bits = 0;
@@ -2033,8 +2033,7 @@ again:
 
 		if (entry->bitmap && entry->bytes > bytes + empty_size) {
 			ret = btrfs_bitmap_cluster(block_group, entry, cluster,
-						   offset, bytes + empty_size,
-						   min_bytes);
+						   offset, bytes, min_bytes);
 			if (!ret)
 				goto got_it;
 		}
@@ -2064,7 +2063,7 @@ again:
 
 	while (1) {
 		/* out window is just right, lets fill it */
-		if (window_free >= bytes + empty_size)
+		if (window_free >= min_bytes)
 			break;
 
 		node = rb_next(&last->offset_index);
