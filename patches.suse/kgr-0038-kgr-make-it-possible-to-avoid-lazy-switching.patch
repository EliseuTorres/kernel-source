From: Jiri Kosina <jkosina@suse.cz>
Date: Tue, 12 Aug 2014 16:03:06 +0200
Subject: kgr: make it possible to avoid lazy switching
Patch-mainline: submitted for review
References: fate#313296

In cases where the patch is known to be completely independent on other
context (such as, but not limited to, added check at the beginning of a
syscall), it's convenient to be able to completely avoid going through the
hoops of lazy migration to the new universe.

Allow patches to set an 'immediate' flag and not (re-)start the lazy
migration when it's set.

js: fix queue_work argument (&kgr_work -> &kgr_work.work)

Signed-off-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |  2 ++
 kernel/kgraft.c        | 19 ++++++++++++++++---
 2 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index 30701157cd4b..f02d8025588b 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -81,6 +81,7 @@ struct kgr_patch_fun {
  * @name: name of the patch (to appear in sysfs)
  * @owner: module to refcount on patching
  * @replace_all: revert everything applied before and apply this one instead
+ * @immediate: avoid the lazy-switching mechanism and flip the switch ASAP
  * @patches: array of @kgr_patch_fun structures
  */
 struct kgr_patch {
@@ -95,6 +96,7 @@ struct kgr_patch {
 	const char *name;
 	struct module *owner;
 	bool replace_all;
+	bool immediate;
 	struct kgr_patch_fun patches[];
 };
 
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 64603d7ee487..9f0288efdf38 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -553,7 +553,13 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force)
 		goto err_unlock;
 	}
 
-	kgr_mark_processes();
+	/*
+	 * If the patch has immediate flag set, avoid the lazy-switching
+	 * between universes completely, and just flip the switch as soon
+	 * as possible
+	 */
+	if (!patch->immediate)
+		kgr_mark_processes();
 
 	kgr_for_each_patch_fun(patch, patch_fun) {
 		patch_fun->patch = patch;
@@ -586,9 +592,16 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force)
 	kgr_handle_processes();
 
 	/*
-	 * give everyone time to exit kernel, and check after a while
+	 * Give everyone time to exit kernel, and check after a while.
+	 *
+	 * When applying the patch with 'immediate' flag set, it makes
+	 * sense to check immediately; in case there was no other patching
+	 * running in parallel, we will claim victory right away.
 	 */
-	queue_delayed_work(kgr_wq, &kgr_work, 10 * HZ);
+	if (patch->immediate)
+		queue_work(kgr_wq, &kgr_work.work);
+	else
+		queue_delayed_work(kgr_wq, &kgr_work, 10 * HZ);
 
 	return 0;
 err_free:
-- 
2.1.0

