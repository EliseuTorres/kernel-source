From: Jiri Kosina <jkosina@suse.cz>
Date: Tue, 12 Aug 2014 16:03:06 +0200
Subject: kgr: make it possible to avoid lazy switching
Patch-mainline: submitted for review
References: fate#313296

In cases where the patch is known to be completely independent on other
context (such as, but not limited to, added check at the beginning of a
syscall), it's convenient to be able to completely avoid going through the
hoops of lazy migration to the new universe.

Allow patches to set an 'immediate' flag and not (re-)start the lazy
migration when it's set.

jk: simplify 'immediate' logic (remove preparation to parallelism)

Signed-off-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |  2 ++
 kernel/kgraft.c        | 10 ++++++++--
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index 30701157cd4b..f02d8025588b 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -81,6 +81,7 @@ struct kgr_patch_fun {
  * @name: name of the patch (to appear in sysfs)
  * @owner: module to refcount on patching
  * @replace_all: revert everything applied before and apply this one instead
+ * @immediate: avoid the lazy-switching mechanism and flip the switch ASAP
  * @patches: array of @kgr_patch_fun structures
  */
 struct kgr_patch {
@@ -95,6 +96,7 @@ struct kgr_patch {
 	const char *name;
 	struct module *owner;
 	bool replace_all;
+	bool immediate;
 	struct kgr_patch_fun patches[];
 };
 
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 06aec5a12003..3b3e3d2937e5 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -553,7 +553,12 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force)
 		goto err_unlock;
 	}
 
-	kgr_mark_processes();
+	/*
+	 * If the patch has immediate flag set, avoid the lazy-switching
+	 * between universes completely.
+	 */
+	if (!patch->immediate)
+		kgr_mark_processes();
 
 	kgr_for_each_patch_fun(patch, patch_fun) {
 		patch_fun->patch = patch;
@@ -588,7 +593,8 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force)
 	/*
 	 * give everyone time to exit kernel, and check after a while
 	 */
-	queue_delayed_work(kgr_wq, &kgr_work, 10 * HZ);
+	if (!patch->immediate)
+		queue_delayed_work(kgr_wq, &kgr_work, 10 * HZ);
 
 	return 0;
 err_free:
-- 
2.1.0

