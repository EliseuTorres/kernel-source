From: Jiri Bohac <jbohac@suse.cz>
Subject: allow bonding with blacklisted ipv6
References: bnc#585463
Patch-mainline: no

This is an ugly hack. SLES turns off ipv6 by blacklisting the
ipv6 module. However, since bonding supports ipv6, it is built to
depend on ipv6. Thus, when ipv6 is blacklisted, bonding cannot be
loaded.

This file provides a global structure bonding_ipv6_ops that
is initialized by ipv6 when it loads.
Instead of depending on ipv6, bonding calls the ipv6 functions
through bonding_ipv6_ops.

Blacklisting the ipv6 module is no more a good method of disabling ipv6. We
keep it in SLE11 for backwards compatibility only. For newer products, ipv6
is disabled differently and this hack is not needed.

Signed-off-by: Jiri Bohac <jbohac@suse.cz>

Index: work/drivers/net/bonding/bond_ipv6.c
===================================================================
--- work.orig/drivers/net/bonding/bond_ipv6.c	2011-03-09 21:45:38.000000000 +0100
+++ work/drivers/net/bonding/bond_ipv6.c	2011-03-09 21:54:30.000000000 +0100
@@ -26,6 +26,7 @@
 #include <net/ndisc.h>
 #include <net/addrconf.h>
 #include "bonding.h"
+#include "../bonding_ipv6_ops.h"
 
 /*
  * Assign bond->master_ipv6 to the next IPv6 address in the list, or
@@ -36,6 +37,9 @@ static void bond_glean_dev_ipv6(struct n
 	struct inet6_dev *idev;
 	struct inet6_ifaddr *ifa;
 
+	if (!bonding_ipv6_ops->in6_dev_put)
+		return;
+
 	if (!dev)
 		return;
 
@@ -52,7 +56,7 @@ static void bond_glean_dev_ipv6(struct n
 
 	read_unlock_bh(&idev->lock);
 
-	in6_dev_put(idev);
+	bonding_ipv6_ops->in6_dev_put(idev);
 }
 
 static void bond_na_send(struct net_device *slave_dev,
@@ -75,7 +79,7 @@ static void bond_na_send(struct net_devi
 	pr_debug("ipv6 na on slave %s: dest %pI6, src %pI6\n",
 	       slave_dev->name, &mcaddr, daddr);
 
-	skb = ndisc_build_skb(slave_dev, &mcaddr, daddr, &icmp6h, daddr,
+	skb = bonding_ipv6_ops->ndisc_build_skb(slave_dev, &mcaddr, daddr, &icmp6h, daddr,
 			      ND_OPT_TARGET_LL_ADDR);
 
 	if (!skb) {
@@ -91,7 +95,7 @@ static void bond_na_send(struct net_devi
 		}
 	}
 
-	ndisc_send_skb(skb, slave_dev, NULL, &mcaddr, daddr, &icmp6h);
+	bonding_ipv6_ops->ndisc_send_skb(skb, slave_dev, NULL, &mcaddr, daddr, &icmp6h);
 }
 
 /*
@@ -108,6 +112,9 @@ void bond_send_unsolicited_na(struct bon
 	struct inet6_dev *idev;
 	int is_router;
 
+	if (!bonding_ipv6_ops->in6_dev_put)
+		return;
+
 	pr_debug("bond_send_unsol_na: bond %s slave %s\n", bond->dev->name,
 				slave ? slave->dev->name : "NULL");
 
@@ -117,13 +124,14 @@ void bond_send_unsolicited_na(struct bon
 
 	bond->send_unsol_na--;
 
+
 	idev = in6_dev_get(bond->dev);
 	if (!idev)
 		return;
 
 	is_router = !!idev->cnf.forwarding;
 
-	in6_dev_put(idev);
+	bonding_ipv6_ops->in6_dev_put(idev);
 
 	if (!ipv6_addr_any(&bond->master_ipv6))
 		bond_na_send(slave->dev, &bond->master_ipv6, is_router, 0);
@@ -206,11 +214,11 @@ static struct notifier_block bond_inet6a
 
 void bond_register_ipv6_notifier(void)
 {
-	register_inet6addr_notifier(&bond_inet6addr_notifier);
+	bonding_ipv6_ops->register_inet6addr_notifier(&bond_inet6addr_notifier);
 }
 
 void bond_unregister_ipv6_notifier(void)
 {
-	unregister_inet6addr_notifier(&bond_inet6addr_notifier);
+	bonding_ipv6_ops->unregister_inet6addr_notifier(&bond_inet6addr_notifier);
 }
 
Index: work/drivers/net/bonding_ipv6_ops.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ work/drivers/net/bonding_ipv6_ops.c	2011-03-09 21:51:53.000000000 +0100
@@ -0,0 +1,35 @@
+/*
+ * This is an ugly hack. SLES turns off ipv6 by blacklisting the
+ * ipv6 module. However, since bonding supports ipv6, it is built to
+ * depend on ipv6. Thus, when ipv6 is blacklisted, bonding cannot be
+ * loaded.
+ *
+ * This file provides a global structure bonding_ipv6_ops that
+ * is initialized by ipv6 when it loads.
+ * Instead of depending on ipv6, bonding calls the ipv6 functions
+ * through bonding_ipv6_ops.
+ */
+
+
+#include "bonding_ipv6_ops.h"
+
+
+static void bonding_ipv6_dummy_function(void)
+{
+};
+
+struct bonding_ipv6_ops bonding_ipv6_ops_dummy = {
+	.ndisc_build_skb = NULL,
+	.ndisc_send_skb = NULL,
+	.in6_dev_put = NULL,
+	.register_inet6addr_notifier = (void *)bonding_ipv6_dummy_function,
+	.unregister_inet6addr_notifier = (void *)bonding_ipv6_dummy_function,
+};
+
+struct bonding_ipv6_ops *bonding_ipv6_ops = &bonding_ipv6_ops_dummy;
+
+EXPORT_SYMBOL(bonding_ipv6_ops);
+EXPORT_SYMBOL(bonding_ipv6_ops_dummy);
+DECLARE_RWSEM(bonding_ipv6_ops_sem);
+EXPORT_SYMBOL(bonding_ipv6_ops_sem);
+
Index: work/drivers/net/bonding_ipv6_ops.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ work/drivers/net/bonding_ipv6_ops.h	2011-03-09 21:51:53.000000000 +0100
@@ -0,0 +1,26 @@
+#include <net/ipv6.h>
+#include <linux/rwsem.h>
+
+struct bonding_ipv6_ops {
+	struct sk_buff* (*ndisc_build_skb)(struct net_device *dev,
+                                                 const struct in6_addr *daddr,
+                                                 const struct in6_addr *saddr,
+                                                 struct icmp6hdr *icmp6h,
+                                                 const struct in6_addr *target,
+                                                 int llinfo);
+	void (*ndisc_send_skb)(struct sk_buff *skb,
+                                               struct net_device *dev,
+                                               struct neighbour *neigh,
+                                               const struct in6_addr *daddr,
+                                               const struct in6_addr *saddr,
+                                               struct icmp6hdr *icmp6h);
+
+	void (*in6_dev_put)(struct inet6_dev *idev);
+	int (*register_inet6addr_notifier)(struct notifier_block *nb);
+	int (*unregister_inet6addr_notifier)(struct notifier_block *nb);
+};
+
+
+extern struct bonding_ipv6_ops bonding_ipv6_ops_dummy;
+extern struct bonding_ipv6_ops *bonding_ipv6_ops;
+
Index: work/net/ipv6/af_inet6.c
===================================================================
--- work.orig/net/ipv6/af_inet6.c	2011-03-09 21:45:38.000000000 +0100
+++ work/net/ipv6/af_inet6.c	2011-03-09 21:55:58.000000000 +0100
@@ -61,6 +61,7 @@
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <linux/mroute6.h>
+#include "../../drivers/net/bonding_ipv6_ops.h"
 
 MODULE_AUTHOR("Cast of dozens");
 MODULE_DESCRIPTION("IPv6 protocol stack for Linux");
@@ -1054,6 +1055,29 @@ static struct pernet_operations inet6_ne
 	.exit = inet6_net_exit,
 };
 
+static noinline void in6_dev_put_noinline(struct inet6_dev *idev)
+{
+	in6_dev_put(idev);
+}
+
+struct bonding_ipv6_ops bonding_ipv6_ops_real = {
+	.ndisc_build_skb = ndisc_build_skb,
+	.ndisc_send_skb = ndisc_send_skb,
+	.in6_dev_put = in6_dev_put_noinline,
+	.register_inet6addr_notifier = register_inet6addr_notifier,
+	.unregister_inet6addr_notifier = unregister_inet6addr_notifier,
+};
+
+static void ipv6_bonding_ipv6_ops_init(void)
+{
+	bonding_ipv6_ops = &bonding_ipv6_ops_real;
+}
+
+static void ipv6_bonding_ipv6_ops_exit(void)
+{
+	bonding_ipv6_ops = &bonding_ipv6_ops_dummy;
+}
+
 static int __init inet6_init(void)
 {
 	struct sk_buff *dummy_skb;
@@ -1187,6 +1211,7 @@ static int __init inet6_init(void)
 	if (err)
 		goto sysctl_fail;
 #endif
+	ipv6_bonding_ipv6_ops_init();
 out:
 	return err;
 
@@ -1258,6 +1283,8 @@ static void __exit inet6_exit(void)
 	if (disable_ipv6_mod)
 		return;
 
+	ipv6_bonding_ipv6_ops_exit();
+
 	/* First of all disallow new sockets creation. */
 	sock_unregister(PF_INET6);
 	/* Disallow any further netlink messages */
Index: work/drivers/net/Makefile
===================================================================
--- work.orig/drivers/net/Makefile	2011-03-09 21:45:38.000000000 +0100
+++ work/drivers/net/Makefile	2011-03-09 21:51:53.000000000 +0100
@@ -21,6 +21,7 @@ obj-$(CONFIG_CHELSIO_T3) += cxgb3/
 obj-$(CONFIG_EHEA) += ehea/
 obj-$(CONFIG_CAN) += can/
 obj-$(CONFIG_BONDING) += bonding/
+obj-y += bonding_ipv6_ops.o
 obj-$(CONFIG_ATL1) += atlx/
 obj-$(CONFIG_ATL2) += atlx/
 obj-$(CONFIG_ATL1E) += atl1e/
