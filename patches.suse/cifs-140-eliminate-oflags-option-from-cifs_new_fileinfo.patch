From: Jeff Layton <jlayton@redhat.com>
Date: Fri, 15 Oct 2010 15:33:57 -0400
Subject: cifs: eliminate oflags option from cifs_new_fileinfo
References: FATE#311695
Git-commit: f6a53460e2a105904deeada737b3f878d78517b3
Patch-mainline: v2.6.37-rc1

Eliminate the poor, misunderstood "oflags" option from cifs_new_fileinfo.
The callers mostly pass in the filp->f_flags here.

That's not correct however since we're checking that value for
the presence of FMODE_READ. Luckily that only affects how the f_list is
ordered. What it really wants here is the file->f_mode. Just use that
field from the filp to determine it.

Signed-off-by: Jeff Layton <jlayton@redhat.com>
Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
Signed-off-by: Steve French <sfrench@us.ibm.com>
Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
---
 fs/cifs/cifsproto.h |    3 +--
 fs/cifs/dir.c       |    9 ++++-----
 fs/cifs/file.c      |    5 ++---
 3 files changed, 7 insertions(+), 10 deletions(-)

Index: linux-2.6.32-SLE11-SP2/fs/cifs/cifsproto.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/cifsproto.h
+++ linux-2.6.32-SLE11-SP2/fs/cifs/cifsproto.h
@@ -107,8 +107,7 @@ extern struct timespec cnvrtDosUnixTm(__
 
 extern struct cifsFileInfo *cifs_new_fileinfo(struct inode *newinode,
 				__u16 fileHandle, struct file *file,
-				struct tcon_link *tlink,
-				unsigned int oflags, __u32 oplock);
+				struct tcon_link *tlink, __u32 oplock);
 extern int cifs_posix_open(char *full_path, struct inode **pinode,
 				struct super_block *sb,
 				int mode, unsigned int f_flags,
Index: linux-2.6.32-SLE11-SP2/fs/cifs/dir.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/dir.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/dir.c
@@ -132,7 +132,7 @@ cifs_bp_rename_retry:
 
 struct cifsFileInfo *
 cifs_new_fileinfo(struct inode *newinode, __u16 fileHandle, struct file *file,
-		  struct tcon_link *tlink, unsigned int oflags, __u32 oplock)
+		  struct tcon_link *tlink, __u32 oplock)
 {
 	struct dentry *dentry = file->f_path.dentry;
 	struct cifsFileInfo *pCifsFile;
@@ -161,7 +161,7 @@ cifs_new_fileinfo(struct inode *newinode
 	pCifsInode = CIFS_I(newinode);
 	if (pCifsInode) {
 		/* if readable file instance put first in list*/
-		if (oflags & FMODE_READ)
+		if (file->f_mode & FMODE_READ)
 			list_add(&pCifsFile->flist, &pCifsInode->openFileList);
 		else
 			list_add_tail(&pCifsFile->flist,
@@ -396,7 +396,7 @@ cifs_create_set_dentry:
 		}
 
 		pfile_info = cifs_new_fileinfo(newinode, fileHandle, filp,
-						tlink, oflags, oplock);
+						tlink, oplock);
 		if (pfile_info == NULL) {
 			fput(filp);
 			CIFSSMBClose(xid, tcon, fileHandle);
@@ -670,8 +670,7 @@ cifs_lookup(struct inode *parent_dir_ino
 			}
 
 			cfile = cifs_new_fileinfo(newInode, fileHandle, filp,
-						  tlink, nd->intent.open.flags,
-						  oplock);
+						  tlink, oplock);
 			if (cfile == NULL) {
 				fput(filp);
 				CIFSSMBClose(xid, pTcon, fileHandle);
Index: linux-2.6.32-SLE11-SP2/fs/cifs/file.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/file.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/file.c
@@ -272,7 +272,7 @@ int cifs_open(struct inode *inode, struc
 			cFYI(1, "posix open succeeded");
 
 			pCifsFile = cifs_new_fileinfo(inode, netfid, file,
-							tlink, oflags, oplock);
+							tlink, oplock);
 			if (pCifsFile == NULL) {
 				CIFSSMBClose(xid, tcon, netfid);
 				rc = -ENOMEM;
@@ -364,8 +364,7 @@ int cifs_open(struct inode *inode, struc
 	if (rc != 0)
 		goto out;
 
-	pCifsFile = cifs_new_fileinfo(inode, netfid, file, tlink,
-					file->f_flags, oplock);
+	pCifsFile = cifs_new_fileinfo(inode, netfid, file, tlink, oplock);
 	if (pCifsFile == NULL) {
 		rc = -ENOMEM;
 		goto out;
