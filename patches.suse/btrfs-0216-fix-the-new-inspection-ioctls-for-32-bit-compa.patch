From: Chris Mason <chris.mason@oracle.com>
Date: Wed, 2 Nov 2011 15:48:34 -0400
Patch-mainline: yes
References: FATE#306586
Git-commit: 740c3d226cbba6cd6a32adfb66809c94938f3e57
Subject: [PATCH] Btrfs: fix the new inspection ioctls for 32 bit
 compat

The new ioctls to follow backrefs are not clean for 32/64 bit
compat.  This reworks them for u64s everywhere.  They are brand new, so
there are no problems with changing the interface now.

Signed-off-by: Chris Mason <chris.mason@oracle.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/backref.c |    8 ++++----
 fs/btrfs/ioctl.c   |   10 +++++-----
 fs/btrfs/ioctl.h   |   11 +++++------
 fs/btrfs/scrub.c   |    2 +-
 4 files changed, 15 insertions(+), 16 deletions(-)

--- a/fs/btrfs/backref.c
+++ b/fs/btrfs/backref.c
@@ -676,14 +676,14 @@ static int inode_to_path(u64 inum, struc
 	bytes_left = ipath->fspath->bytes_left > s_ptr ?
 					ipath->fspath->bytes_left - s_ptr : 0;
 
-	fspath_min = (char *)ipath->fspath->str + (i + 1) * s_ptr;
+	fspath_min = (char *)ipath->fspath->val + (i + 1) * s_ptr;
 	fspath = iref_to_path(ipath->fs_root, ipath->btrfs_path, iref, eb,
 				inum, fspath_min, bytes_left);
 	if (IS_ERR(fspath))
 		return PTR_ERR(fspath);
 
 	if (fspath > fspath_min) {
-		ipath->fspath->str[i] = fspath;
+		ipath->fspath->val[i] = (u64)fspath;
 		++ipath->fspath->elem_cnt;
 		ipath->fspath->bytes_left = fspath - fspath_min;
 	} else {
@@ -698,9 +698,9 @@ static int inode_to_path(u64 inum, struc
 /*
  * this dumps all file system paths to the inode into the ipath struct, provided
  * is has been created large enough. each path is zero-terminated and accessed
- * from ipath->fspath->str[i].
+ * from ipath->fspath->val[i].
  * when it returns, there are ipath->fspath->elem_cnt number of paths available
- * in ipath->fspath->str[]. when the allocated space wasn't sufficient, the
+ * in ipath->fspath->val[]. when the allocated space wasn't sufficient, the
  * number of missed paths in recored in ipath->fspath->elem_missed, otherwise,
  * it's zero. ipath->fspath->bytes_missing holds the number of bytes that would
  * have been needed to return all paths.
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -2895,7 +2895,7 @@ static long btrfs_ioctl_ino_to_path(stru
 {
 	int ret = 0;
 	int i;
-	unsigned long rel_ptr;
+	u64 rel_ptr;
 	int size;
 	struct btrfs_ioctl_ino_path_args *ipa = NULL;
 	struct inode_fs_paths *ipath = NULL;
@@ -2930,11 +2930,11 @@ static long btrfs_ioctl_ino_to_path(stru
 		goto out;
 
 	for (i = 0; i < ipath->fspath->elem_cnt; ++i) {
-		rel_ptr = ipath->fspath->str[i] - (char *)ipath->fspath->str;
-		ipath->fspath->str[i] = (void *)rel_ptr;
+		rel_ptr = ipath->fspath->val[i] - (u64)ipath->fspath->val;
+		ipath->fspath->val[i] = rel_ptr;
 	}
 
-	ret = copy_to_user(ipa->fspath, ipath->fspath, size);
+	ret = copy_to_user((void *)ipa->fspath, (void *)ipath->fspath, size);
 	if (ret) {
 		ret = -EFAULT;
 		goto out;
@@ -3017,7 +3017,7 @@ static long btrfs_ioctl_logical_to_ino(s
 	if (ret < 0)
 		goto out;
 
-	ret = copy_to_user(loi->inodes, inodes, size);
+	ret = copy_to_user((void *)loi->inodes, (void *)inodes, size);
 	if (ret)
 		ret = -EFAULT;
 
--- a/fs/btrfs/ioctl.h
+++ b/fs/btrfs/ioctl.h
@@ -198,24 +198,23 @@ struct btrfs_data_container {
 	__u32	bytes_missing;	/* out -- additional bytes needed for result */
 	__u32	elem_cnt;	/* out */
 	__u32	elem_missed;	/* out */
-	union {
-		char	*str[0];	/* out */
-		__u64	val[0];		/* out */
-	};
+	__u64	val[0];		/* out */
 };
 
 struct btrfs_ioctl_ino_path_args {
 	__u64				inum;		/* in */
 	__u32				size;		/* in */
 	__u64				reserved[4];
-	struct btrfs_data_container	*fspath;	/* out */
+	/* struct btrfs_data_container	*fspath;	   out */
+	__u64				fspath;		/* out */
 };
 
 struct btrfs_ioctl_logical_ino_args {
 	__u64				logical;	/* in */
 	__u32				size;		/* in */
 	__u64				reserved[4];
-	struct btrfs_data_container	*inodes;	/* out */
+	/* struct btrfs_data_container	*inodes;	out   */
+	__u64				inodes;
 };
 
 #define BTRFS_IOC_SNAP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 1, \
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@ -272,7 +272,7 @@ static int scrub_print_warning_inode(u64
 			swarn->logical, swarn->dev->name,
 			(unsigned long long)swarn->sector, root, inum, offset,
 			min(isize - offset, (u64)PAGE_SIZE), nlink,
-			ipath->fspath->str[i]);
+			(char *)ipath->fspath->val[i]);
 
 	free_ipath(ipath);
 	return 0;
