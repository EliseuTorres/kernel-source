From 2e396b83f6087b78dac5a18d6d0cf9f8426a00b3 Mon Sep 17 00:00:00 2001
From: Jeff Layton <jlayton@redhat.com>
Date: Fri, 15 Oct 2010 15:34:01 -0400
Subject: cifs: eliminate pfile pointer from cifsFileInfo
References: FATE#311695
Patch-mainline: yes

All the remaining users of cifsFileInfo->pfile just use it to get
at the f_flags/f_mode. Now that we store that separately in the
cifsFileInfo, there's no need to consult the pfile at all from
a cifsFileInfo pointer.

Signed-off-by: Jeff Layton <jlayton@redhat.com>
Reviewed-by: Suresh Jayaraman <sjayaraman@suse.de>
Acked-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
Signed-off-by: Steve French <sfrench@us.ibm.com>
Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
---

Index: linux-2.6.32-SLE11-SP2/fs/cifs/cifsglob.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/cifsglob.h
+++ linux-2.6.32-SLE11-SP2/fs/cifs/cifsglob.h
@@ -387,7 +387,6 @@ struct cifsFileInfo {
 	__u16 netfid;		/* file id from remote */
 	/* BB add lock scope info here if needed */ ;
 	/* lock scope id (0 if none) */
-	struct file *pfile; /* needed for writepage */
 	struct dentry *dentry;
 	unsigned int f_flags;
 	struct tcon_link *tlink;
Index: linux-2.6.32-SLE11-SP2/fs/cifs/dir.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/dir.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/dir.c
@@ -148,7 +148,6 @@ cifs_new_fileinfo(__u16 fileHandle, stru
 	pCifsFile->uid = current_fsuid();
 	pCifsFile->dentry = dget(dentry);
 	pCifsFile->f_flags = file->f_flags;
-	pCifsFile->pfile = file;
 	pCifsFile->invalidHandle = false;
 	pCifsFile->closePend = false;
 	pCifsFile->tlink = cifs_get_tlink(tlink);
Index: linux-2.6.32-SLE11-SP2/fs/cifs/file.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/file.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/file.c
@@ -1143,8 +1143,7 @@ struct cifsFileInfo *find_readable_file(
 			continue;
 		if (fsuid_only && open_file->uid != current_fsuid())
 			continue;
-		if (open_file->pfile && ((open_file->pfile->f_flags & O_RDWR) ||
-		    (open_file->pfile->f_flags & O_RDONLY))) {
+		if ((__force fmode_t)((open_file->f_flags+1) & O_ACCMODE) & FMODE_READ) {
 			if (!open_file->invalidHandle) {
 				/* found a good file */
 				/* lock it so it will not be closed on us */
@@ -1193,9 +1192,7 @@ refind_writable:
 			continue;
 		if (fsuid_only && open_file->uid != current_fsuid())
 			continue;
-		if (open_file->pfile &&
-		    ((open_file->pfile->f_flags & O_RDWR) ||
-		     (open_file->pfile->f_flags & O_WRONLY))) {
+		if ((__force fmode_t)((open_file->f_flags+1) & O_ACCMODE) & FMODE_WRITE) {
 			cifsFileInfo_get(open_file);
 
 			if (!open_file->invalidHandle) {
@@ -2166,9 +2163,7 @@ static int is_inode_writable(struct cifs
 	list_for_each_entry(open_file, &cifs_inode->openFileList, flist) {
 		if (open_file->closePend)
 			continue;
-		if (open_file->pfile &&
-		    ((open_file->pfile->f_flags & O_RDWR) ||
-		     (open_file->pfile->f_flags & O_WRONLY))) {
+		if ((__force fmode_t)((open_file->f_flags+1) & O_ACCMODE) & FMODE_WRITE) {
 			read_unlock(&GlobalSMBSeslock);
 			return 1;
 		}
