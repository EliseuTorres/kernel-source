From: Mike Anderson <andmike@us.ibm.com>
Subject: block: Implement REQ_ATOM_ABORT flag
References: bnc#527028
Patch-Mainline: Submitted to scsi-misc

This patchset provides a method to mark a request as
aborted so that retry can be stopped for these requests.

blk: Add request atomic flag for abort
blk: Mark aborted requests
scsi: Add scsi_requeue_request function
scsi: Add blk_request_aborted check

Signed-off-by: Mike Anderson <andmike@us.ibm.com>
Acked-by: Hannes Reinecke <hare@suse.de>

diff --git a/block/blk-timeout.c b/block/blk-timeout.c
index 89fbe0a..45469fa 100644
--- a/block/blk-timeout.c
+++ b/block/blk-timeout.c
@@ -155,6 +155,12 @@ void blk_abort_request(struct request *req)
 }
 EXPORT_SYMBOL_GPL(blk_abort_request);
 
+int blk_request_aborted(struct request *req)
+{
+	return blk_test_rq_aborted(req);
+}
+EXPORT_SYMBOL_GPL(blk_request_aborted);
+
 /**
  * blk_add_timer - Start timeout timer for a single request
  * @req:	request that is about to start running.
@@ -223,9 +229,11 @@ void blk_abort_queue(struct request_queue *q)
 	 */
 	list_splice_init(&q->timeout_list, &list);
 
-	list_for_each_entry_safe(rq, tmp, &list, timeout_list)
+	list_for_each_entry_safe(rq, tmp, &list, timeout_list) {
 		if (!blk_queue_stopped(q))
 			blk_abort_request(rq);
+		blk_mark_rq_aborted(rq);
+	}
 
 	/*
 	 * Occasionally, blk_abort_request() will return without
diff --git a/block/blk.h b/block/blk.h
index 5ee3d7e..165262a 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -30,6 +30,7 @@ void __generic_unplug_device(struct request_queue *);
  */
 enum rq_atomic_flags {
 	REQ_ATOM_COMPLETE = 0,
+	REQ_ATOM_ABORT = 1,
 };
 
 /*
@@ -47,6 +48,19 @@ static inline void blk_clear_rq_complete(struct request *rq)
 }
 
 /*
+ * Mark and test a request for aborted.
+ */
+static inline int blk_mark_rq_aborted(struct request *rq)
+{
+	return test_and_set_bit(REQ_ATOM_ABORT, &rq->atomic_flags);
+}
+
+static inline int blk_test_rq_aborted(struct request *rq)
+{
+	return test_bit(REQ_ATOM_ABORT, &rq->atomic_flags);
+}
+
+/*
  * Internal elevator interface
  */
 #define ELV_ON_HASH(rq)		(!hlist_unhashed(&(rq)->hash))
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 2d356b5..5404d51 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -102,6 +102,40 @@ static void scsi_unprep_fn(struct request_queue *q, struct request *req)
 }
 
 
+/*
+ * Function:	scsi_requeue_request()
+ *
+ * Purpose:	Requeue a request.
+ *
+ * Arguments:	q	- queue to operate on
+ *		req	- request to be requeued.
+ *		unprep	- indicate if unprep needed.
+ *
+ * Returns:	Nothing
+ *
+ * Notes:	Upon return, req is a stale pointer.
+ */
+static void scsi_requeue_request(struct request_queue *q, struct request *req,
+				 int unprep)
+{
+	unsigned long flags;
+
+	if (blk_request_aborted(req)) {
+		scsi_unprep_fn(q, req);
+		blk_end_request_all(req, -EIO);
+		goto out;
+	}
+
+	spin_lock_irqsave(q->queue_lock, flags);
+	if (unprep)
+		scsi_unprep_request(req);
+	blk_requeue_request(q, req);
+	spin_unlock_irqrestore(q->queue_lock, flags);
+
+out:
+	scsi_run_queue(q);
+}
+
 /**
  * __scsi_queue_insert - private queue insertion
  * @cmd: The SCSI command being requeued
@@ -120,7 +154,6 @@ static int __scsi_queue_insert(struct scsi_cmnd *cmd, int reason, int unbusy)
 	struct scsi_device *device = cmd->device;
 	struct scsi_target *starget = scsi_target(device);
 	struct request_queue *q = device->request_queue;
-	unsigned long flags;
 
 	SCSI_LOG_MLQUEUE(1,
 		 printk("Inserting command %p into mlqueue\n", cmd));
@@ -157,22 +190,7 @@ static int __scsi_queue_insert(struct scsi_cmnd *cmd, int reason, int unbusy)
 	if (unbusy)
 		scsi_device_unbusy(device);
 
-	/*
-	 * Requeue this command.  It will go before all other commands
-	 * that are already in the queue.
-	 *
-	 * NOTE: there is magic here about the way the queue is plugged if
-	 * we have no outstanding commands.
-	 * 
-	 * Although we *don't* plug the queue, we call the request
-	 * function.  The SCSI request function detects the blocked condition
-	 * and plugs the queue appropriately.
-         */
-	spin_lock_irqsave(q->queue_lock, flags);
-	blk_requeue_request(q, cmd->request);
-	spin_unlock_irqrestore(q->queue_lock, flags);
-
-	scsi_run_queue(q);
+	scsi_requeue_request(q, cmd->request, 0);
 
 	return 0;
 }
@@ -489,14 +507,8 @@ static void scsi_run_queue(struct request_queue *q)
 static void scsi_requeue_command(struct request_queue *q, struct scsi_cmnd *cmd)
 {
 	struct request *req = cmd->request;
-	unsigned long flags;
-
-	spin_lock_irqsave(q->queue_lock, flags);
-	scsi_unprep_request(req);
-	blk_requeue_request(q, req);
-	spin_unlock_irqrestore(q->queue_lock, flags);
 
-	scsi_run_queue(q);
+	scsi_requeue_request(q, req, 1);
 }
 
 void scsi_next_command(struct scsi_cmnd *cmd)
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 642ec53..6fd2ddf 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -916,6 +916,7 @@ extern void blk_complete_request(struct request *);
 extern void __blk_complete_request(struct request *);
 extern void blk_abort_request(struct request *);
 extern void blk_abort_queue(struct request_queue *);
+extern int blk_request_aborted(struct request *);
 
 /*
  * Access functions for manipulating queue properties
