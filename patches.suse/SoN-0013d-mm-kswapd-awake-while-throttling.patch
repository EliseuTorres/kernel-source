From: Mel Gorman <mgorman@suse.de>
Date: Tue, 28 Feb 2012 10:45:23 +0000
Subject: [PATCH] mm: Ensure that kswapd is awake if throttling on pfmemmalloc reserves
References: Swap over NFS (fate#304949, bnc#747944)
Patch-mainline: Not yet, merging efforts ongoing

If a process gets throttled as pfmemalloc reserves are being depleted,
only kswapd can wake it again. Hence, it is important that kswapd stay
awake while processes are being throttled to prevent deadlock. An
example interaction is as follows

Process                                 kswapd
-------                                 ------
throttle_direct_reclaim
 -> wait_event_killable
    ->prepare_to_wait
    -> pfmemalloc_watermark_ok
      -> waitqueue_active(kswapd_wait) == false
                                        kswapd_try_to_sleep
                                        -> all_unreclaimable, consider sleeping
                                        -> prepare_to_wait
                                        -> waitqueue_active(pfmemalloc_wait) == true
                                           -> wake_up(pfmemalloc_wait)
                                        -> schedule
    -> schedule(), but keeps running

The problem is in kswapd_try_to_sleep as pointed out by Jan Kara. If
kswapd is going to sleep because all zones are unreclaimable, then it
sleeps for a short interval and checks sleeping_prematurely again. If
the first sleeping_prematurely was false, it sleeps but if the second
sleeping_prematurely is true because of a parallel wakeup or a process
freed one page then throttled processes never get woken. This can leave the
system in a state where there is just enough activity to prevent kswapd
ever waking throttled processes. This patch forces kswapd to stay awake
while processes are being throttled.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/vmscan.c |   27 ++++++++++++++-------------
 1 files changed, 14 insertions(+), 13 deletions(-)

diff --git a/mm/vmscan.c b/mm/vmscan.c
index 9194350..277c2dc 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -2549,6 +2549,20 @@ static bool sleeping_prematurely(pg_data_t *pgdat, int order, long remaining,
 	if (remaining)
 		return true;
 
+	/*
+	 * There is a potential race between when kswapd checks it watermarks
+	 * and a process gets throttled. There is also a potential race if
+	 * processes get throttled, kswapd wakes, a large process exits therby
+	 * balancing the zones that causes kswapd to miss a wakeup. If kswapd
+	 * is going to sleep, no process should be sleeping on pfmemalloc_wait
+	 * so wake them now if necessary. If necessary, processes will wake
+	 * kswapd and get throttled again
+	 */
+	if (waitqueue_active(&pgdat->pfmemalloc_wait)) {
+		wake_up(&pgdat->pfmemalloc_wait);
+		return true;
+	}
+
 	/* Check the watermark levels */
 	for (i = 0; i <= classzone_idx; i++) {
 		struct zone *zone = pgdat->node_zones + i;
@@ -2925,19 +2939,6 @@ static void kswapd_try_to_sleep(pg_data_t *pgdat, int order, int classzone_idx)
 		trace_mm_vmscan_kswapd_sleep(pgdat->node_id);
 
 		/*
-		 * There is a potential race between when kswapd checks it
-		 * watermarks and a process gets throttled. There is also
-		 * a potential race if processes get throttled, kswapd wakes,
-		 * a large process exits therby balancing the zones that causes
-		 * kswapd to miss a wakeup. If kswapd is going to sleep, no
-		 * process should be sleeping on pfmemalloc_wait so wake them
-		 * now if necessary. If necessary, processes will wake kswapd
-		 * and get throttled again
-		 */
-		if (waitqueue_active(&pgdat->pfmemalloc_wait))
-			wake_up(&pgdat->pfmemalloc_wait);
-
-		/*
 		 * vmstat counters are not perfectly accurate and the estimated
 		 * value for counters such as NR_FREE_PAGES can deviate from the
 		 * true value by nr_online_cpus * threshold. To avoid the zone
