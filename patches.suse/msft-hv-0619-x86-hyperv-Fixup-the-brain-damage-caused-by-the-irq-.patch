From: Thomas Gleixner <tglx@linutronix.de>
Date: Wed, 5 Mar 2014 13:42:14 +0100
Patch-mainline: v3.15-rc1
Subject: x86: hyperv: Fixup the (brain) damage caused by the irq cleanup
Git-commit: 76d388cd72ab08c2c56b1e2bd430e7422fc40168

Compiling last minute changes without setting the proper config
options is not really clever.

Reported-by: Fengguang Wu <fengguang.wu@intel.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Acked-by: <ohering@suse.de>
---
 arch/x86/include/asm/mshyperv.h |  4 ++--
 arch/x86/kernel/cpu/mshyperv.c  |  6 +++---
 drivers/hv/vmbus_drv.c          | 26 ++++++--------------------
 3 files changed, 11 insertions(+), 25 deletions(-)

diff --git a/arch/x86/include/asm/mshyperv.h b/arch/x86/include/asm/mshyperv.h
index e98f66f..c163215 100644
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@ -17,7 +17,7 @@ void hyperv_callback_vector(void);
 #define trace_hyperv_callback_vector hyperv_callback_vector
 #endif
 void hyperv_vector_handler(struct pt_regs *regs);
-int hv_setup_vmbus_irq(int irq, irq_handler_t handler, void *dev_id);
-void hv_remove_vmbus_irq(int irq, void *dev_id);
+void hv_setup_vmbus_irq(void (*handler)(void));
+void hv_remove_vmbus_irq(void);
 
 #endif
diff --git a/arch/x86/kernel/cpu/mshyperv.c b/arch/x86/kernel/cpu/mshyperv.c
index a6f5f35..b4dcca1 100644
--- a/arch/x86/kernel/cpu/mshyperv.c
+++ b/arch/x86/kernel/cpu/mshyperv.c
@@ -32,7 +32,7 @@ struct ms_hyperv_info ms_hyperv;
 EXPORT_SYMBOL_GPL(ms_hyperv);
 
 #if IS_ENABLED(CONFIG_HYPERV)
-static irq_handler_t vmbus_handler;
+static void (*vmbus_handler)(void);
 
 void hyperv_vector_handler(struct pt_regs *regs)
 {
@@ -49,7 +49,7 @@ void hyperv_vector_handler(struct pt_regs *regs)
 	set_irq_regs(old_regs);
 }
 
-int hv_setup_vmbus_irq(int irq, irq_handler_t handler, void *dev_id)
+void hv_setup_vmbus_irq(void (*handler)(void))
 {
 	vmbus_handler = handler;
 	/*
@@ -61,7 +61,7 @@ int hv_setup_vmbus_irq(int irq, irq_handler_t handler, void *dev_id)
 				hyperv_callback_vector);
 }
 
-void hv_remove_vmbus_irq(int irq, void *dev_id)
+void hv_remove_vmbus_irq(void)
 {
 	/* We have no way to deallocate the interrupt gate */
 	vmbus_handler = NULL;
diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c
index 5a6909f..3f0a952 100644
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@ -615,7 +615,7 @@ static void vmbus_on_msg_dpc(unsigned long data)
 	}
 }
 
-static irqreturn_t vmbus_isr(int irq, void *dev_id)
+static void vmbus_isr(void)
 {
 	int cpu = smp_processor_id();
 	void *page_addr;
@@ -625,7 +625,7 @@ static irqreturn_t vmbus_isr(int irq, void *dev_id)
 
 	page_addr = hv_context.synic_event_page[cpu];
 	if (page_addr == NULL)
-		return IRQ_NONE;
+		return;
 
 	event = (union hv_synic_event_flags *)page_addr +
 					 VMBUS_MESSAGE_SINT;
@@ -661,15 +661,8 @@ static irqreturn_t vmbus_isr(int irq, void *dev_id)
 	msg = (struct hv_message *)page_addr + VMBUS_MESSAGE_SINT;
 
 	/* Check if there are actual msgs to be processed */
-	if (msg->header.message_type != HVMSG_NONE) {
-		handled = true;
+	if (msg->header.message_type != HVMSG_NONE)
 		tasklet_schedule(&msg_dpc);
-	}
-
-	if (handled)
-		return IRQ_HANDLED;
-	else
-		return IRQ_NONE;
 }
 
 /*
@@ -698,12 +691,7 @@ static int vmbus_bus_init(int irq)
 	if (ret)
 		goto err_cleanup;
 
-	ret = hv_setup_vmbus_irq(irq, vmbus_isr, hv_acpi_dev);
-
-	if (ret != 0) {
-		pr_err("Unable to request IRQ %d\n", irq);
-		goto err_unregister;
-	}
+	hv_setup_vmbus_irq(vmbus_isr);
 
 	ret = hv_synic_alloc();
 	if (ret)
@@ -723,9 +711,8 @@ static int vmbus_bus_init(int irq)
 
 err_alloc:
 	hv_synic_free();
-	hv_remove_vmbus_irq(irq, hv_acpi_dev);
+	hv_remove_vmbus_irq();
 
-err_unregister:
 	bus_unregister(&hv_bus);
 
 err_cleanup:
@@ -917,7 +904,6 @@ static int __init hv_acpi_init(void)
 	/*
 	 * Get irq resources first.
 	 */
-
 	ret = acpi_bus_register_driver(&vmbus_acpi_driver);
 
 	if (ret)
@@ -948,7 +934,7 @@ cleanup:
 
 static void __exit vmbus_exit(void)
 {
-	hv_remove_vmbus_irq(irq, hv_acpi_dev);
+	hv_remove_vmbus_irq();
 	vmbus_free_channels();
 	bus_unregister(&hv_bus);
 	hv_cleanup();
