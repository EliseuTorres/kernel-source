From: Al Viro <viro@zeniv.linux.org.uk>
Date: Sat Dec 19 10:10:39 2009 -0500
Subject: Fix f_flags/f_mode in case of lookup_instantiate_filp() from open(pathname, 3)
References: FATE#311695
Git-commit: 482928d59db668b8d82a48717f78986d8cea72e9
Patch-mainline: v2.6.33-rc2

    Just set f_flags when shoving struct file into nameidata; don't
    postpone that until __dentry_open().  do_filp_open() has correct
    value; lookup_instantiate_filp() doesn't - we lose the difference
    between O_RDWR and 3 by that point.
    
    We still set .intent.open.flags, so no fs code needs to be changed.
    
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
---

Index: linux-2.6.32-SLE11-SP2/fs/internal.h
===================================================================
 fs/internal.h         |    7 +++++++
 fs/namei.c            |   13 +++++++++----
 fs/open.c             |   15 ++++++++-------
 include/linux/namei.h |    2 --
 4 files changed, 24 insertions(+), 13 deletions(-)

--- linux-2.6.32-SLE11-SP2.orig/fs/internal.h
+++ linux-2.6.32-SLE11-SP2/fs/internal.h
@@ -84,3 +84,10 @@ extern void mark_files_ro(struct super_b
  * super.c
  */
 extern int do_remount_sb(struct super_block *, int, void *, int);
+
+/*
+ * open.c
+ */
+struct nameidata;
+extern struct file *nameidata_to_filp(struct nameidata *);
+extern void release_open_intent(struct nameidata *);
Index: linux-2.6.32-SLE11-SP2/fs/namei.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/namei.c
+++ linux-2.6.32-SLE11-SP2/fs/namei.c
@@ -35,6 +35,8 @@
 #include <linux/fs_struct.h>
 #include <asm/uaccess.h>
 
+#include "internal.h"
+
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
 
 /* [Feb-1997 T. Schoebel-Theuer]
@@ -109,6 +111,7 @@
  */
 
 static int __link_path_walk(const char *name, struct nameidata *nd);
+static inline int open_to_namei_flags(int flag);
 
 /* In order to reduce some races, while at the same time doing additional
  * checking and hopefully speeding things up, we copy filenames to the
@@ -1170,7 +1173,8 @@ static int path_lookup_open(int dfd, con
 	if (filp == NULL)
 		return -ENFILE;
 	nd->intent.open.file = filp;
-	nd->intent.open.flags = open_flags;
+	filp->f_flags = open_flags;
+	nd->intent.open.flags = open_to_namei_flags(open_flags);
 	nd->intent.open.create_mode = 0;
 	err = do_path_lookup(dfd, name, lookup_flags|LOOKUP_OPEN, nd);
 	if (IS_ERR(nd->intent.open.file)) {
@@ -1707,7 +1711,7 @@ struct file *do_filp_open(int dfd, const
 	 */
 	if (!(flag & O_CREAT)) {
 		error = path_lookup_open(dfd, pathname, lookup_flags(flag),
-					 &nd, flag);
+					 &nd, open_flag);
 		if (error)
 			return ERR_PTR(error);
 		goto ok;
@@ -1742,6 +1746,7 @@ struct file *do_filp_open(int dfd, const
 	if (filp == NULL)
 		goto exit_parent;
 	nd.intent.open.file = filp;
+	filp->f_flags = open_flag;
 	nd.intent.open.flags = flag;
 	nd.intent.open.create_mode = mode;
 	dir = nd.path.dentry;
@@ -1782,7 +1787,7 @@ do_last:
 			mnt_drop_write(nd.path.mnt);
 			goto exit;
 		}
-		filp = nameidata_to_filp(&nd, open_flag);
+		filp = nameidata_to_filp(&nd);
 		if (IS_ERR(filp))
 			ima_counts_put(&nd.path,
 				       acc_mode & (MAY_READ | MAY_WRITE |
@@ -1842,7 +1847,7 @@ ok:
 			mnt_drop_write(nd.path.mnt);
 		goto exit;
 	}
-	filp = nameidata_to_filp(&nd, open_flag);
+	filp = nameidata_to_filp(&nd);
 	if (IS_ERR(filp))
 		ima_counts_put(&nd.path,
 			       acc_mode & (MAY_READ | MAY_WRITE | MAY_EXEC));
Index: linux-2.6.32-SLE11-SP2/fs/open.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/open.c
+++ linux-2.6.32-SLE11-SP2/fs/open.c
@@ -31,6 +31,8 @@
 #include <linux/falloc.h>
 #include <linux/fs_struct.h>
 
+#include "internal.h"
+
 int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	int retval = -ENODEV;
@@ -805,15 +807,14 @@ static inline int __get_file_write_acces
 }
 
 static struct file *__dentry_open(struct dentry *dentry, struct vfsmount *mnt,
-					int flags, struct file *f,
+					struct file *f,
 					int (*open)(struct inode *, struct file *),
 					const struct cred *cred)
 {
 	struct inode *inode;
 	int error;
 
-	f->f_flags = flags;
-	f->f_mode = (__force fmode_t)((flags+1) & O_ACCMODE) | FMODE_LSEEK |
+	f->f_mode = (__force fmode_t)((f->f_flags+1) & O_ACCMODE) | FMODE_LSEEK |
 				FMODE_PREAD | FMODE_PWRITE;
 	inode = dentry->d_inode;
 	if (f->f_mode & FMODE_WRITE) {
@@ -913,7 +914,6 @@ struct file *lookup_instantiate_filp(str
 	if (IS_ERR(dentry))
 		goto out_err;
 	nd->intent.open.file = __dentry_open(dget(dentry), mntget(nd->path.mnt),
-					     nd->intent.open.flags - 1,
 					     nd->intent.open.file,
 					     open, cred);
 out:
@@ -932,7 +932,7 @@ EXPORT_SYMBOL_GPL(lookup_instantiate_fil
  *
  * Note that this function destroys the original nameidata
  */
-struct file *nameidata_to_filp(struct nameidata *nd, int flags)
+struct file *nameidata_to_filp(struct nameidata *nd)
 {
 	const struct cred *cred = current_cred();
 	struct file *filp;
@@ -941,7 +941,7 @@ struct file *nameidata_to_filp(struct na
 	filp = nd->intent.open.file;
 	/* Has the filesystem initialised the file for us? */
 	if (filp->f_path.dentry == NULL)
-		filp = __dentry_open(nd->path.dentry, nd->path.mnt, flags, filp,
+		filp = __dentry_open(nd->path.dentry, nd->path.mnt, filp,
 				     NULL, cred);
 	else
 		path_put(&nd->path);
@@ -980,7 +980,8 @@ struct file *dentry_open(struct dentry *
 		return ERR_PTR(error);
 	}
 
-	return __dentry_open(dentry, mnt, flags, f, NULL, cred);
+	f->f_flags = flags;
+	return __dentry_open(dentry, mnt, f, NULL, cred);
 }
 EXPORT_SYMBOL(dentry_open);
 
Index: linux-2.6.32-SLE11-SP2/include/linux/namei.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/include/linux/namei.h
+++ linux-2.6.32-SLE11-SP2/include/linux/namei.h
@@ -72,8 +72,6 @@ extern int vfs_path_lookup(struct dentry
 
 extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
 		int (*open)(struct inode *, struct file *));
-extern struct file *nameidata_to_filp(struct nameidata *nd, int flags);
-extern void release_open_intent(struct nameidata *);
 
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 extern struct dentry *lookup_one_noperm(const char *, struct dentry *);

