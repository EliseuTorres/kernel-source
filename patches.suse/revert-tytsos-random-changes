From: Torsten Duwe <duwe@suse.de>
Subject: /dev/urandom returning EOF
Git-commit: 3e035335b0578f6a, ebb6006e3be88bb1 et.al. reverted
Patch-mainline: reverse
References: bnc#89359

One of these upstream commits eventually kills sshd on system Z.

Acked-by: Torsten Duwe <duwe@suse.de>
Signed-off-by: Torsten Duwe <duwe@suse.de>

diff -Burbp linux-3.0-SLE11-SP3.orig/MAINTAINERS linux-3.0-SLE11-SP3/MAINTAINERS
--- linux-3.0-SLE11-SP3.orig/MAINTAINERS	2013-04-05 18:19:37.920624748 +0200
+++ linux-3.0-SLE11-SP3/MAINTAINERS	2013-04-05 18:21:00.681569087 +0200
@@ -5258,7 +5258,7 @@ F:	Documentation/blockdev/ramdisk.txt
 F:	drivers/block/brd.c
 
 RANDOM NUMBER DRIVER
-M:	Theodore Ts'o" <tytso@mit.edu>
+M:	Matt Mackall <mpm@selenic.com>
 S:	Maintained
 F:	drivers/char/random.c
 
diff -Burbp linux-3.0-SLE11-SP3.orig/drivers/char/random.c linux-3.0-SLE11-SP3/drivers/char/random.c
--- linux-3.0-SLE11-SP3.orig/drivers/char/random.c	2013-04-05 18:16:37.595743558 +0200
+++ linux-3.0-SLE11-SP3/drivers/char/random.c	2013-04-05 18:21:00.682569139 +0200
@@ -125,26 +125,21 @@
  * The current exported interfaces for gathering environmental noise
  * from the devices are:
  *
- *	void add_device_randomness(const void *buf, unsigned int size);
  * 	void add_input_randomness(unsigned int type, unsigned int code,
  *                                unsigned int value);
- *	void add_interrupt_randomness(int irq, int irq_flags);
+ * 	void add_interrupt_randomness(int irq);
  * 	void add_disk_randomness(struct gendisk *disk);
  *
- * add_device_randomness() is for adding data to the random pool that
- * is likely to differ between two devices (or possibly even per boot).
- * This would be things like MAC addresses or serial numbers, or the
- * read-out of the RTC. This does *not* add any actual entropy to the
- * pool, but it initializes the pool to different values for devices
- * that might otherwise be identical and have very little entropy
- * available to them (particularly common in the embedded world).
- *
  * add_input_randomness() uses the input layer interrupt timing, as well as
  * the event type information from the hardware.
  *
- * add_interrupt_randomness() uses the interrupt timing as random
- * inputs to the entropy pool. Using the cycle counters and the irq source
- * as inputs, it feeds the randomness roughly once a second.
+ * add_interrupt_randomness() uses the inter-interrupt timing as random
+ * inputs to the entropy pool.  Note that not all interrupts are good
+ * sources of randomness!  For example, the timer interrupts is not a
+ * good choice, because the periodicity of the interrupts is too
+ * regular, and hence predictable to an attacker.  Network Interface
+ * Controller interrupts are a better measure, since the timing of the
+ * NIC interrupts are more unpredictable.
  *
  * add_disk_randomness() uses what amounts to the seek time of block
  * layer request events, on a per-disk_devt basis, as input to the
@@ -254,8 +249,6 @@
 #include <linux/percpu.h>
 #include <linux/cryptohash.h>
 #include <linux/fips.h>
-#include <linux/ptrace.h>
-#include <linux/kmemcheck.h>
 
 #ifdef CONFIG_GENERIC_HARDIRQS
 # include <linux/irq.h>
@@ -264,12 +257,8 @@
 #include <asm/processor.h>
 #include <asm/uaccess.h>
 #include <asm/irq.h>
-#include <asm/irq_regs.h>
 #include <asm/io.h>
 
-#define CREATE_TRACE_POINTS
-#include <trace/events/random.h>
-
 /*
  * Configuration information
  */
@@ -278,8 +267,6 @@
 #define SEC_XFER_SIZE 512
 #define EXTRACT_SIZE 10
 
-#define LONGS(x) (((x) + sizeof(unsigned long) - 1)/sizeof(unsigned long))
-
 /*
  * The minimum number of bits of entropy before we wake up a read on
  * /dev/random.  Should be enough to do a significant reseed.
@@ -434,10 +421,8 @@ struct entropy_store {
 	/* read-write data: */
 	spinlock_t lock;
 	unsigned add_ptr;
-	unsigned input_rotate;
 	int entropy_count;
-	int entropy_total;
-	unsigned int initialized:1;
+	int input_rotate;
 	__u8 last_data[EXTRACT_SIZE];
 };
 
@@ -470,10 +455,6 @@ static struct entropy_store nonblocking_
 	.pool = nonblocking_pool_data
 };
 
-static __u32 const twist_table[8] = {
-	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
-	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
-
 /*
  * This function adds bytes into the entropy "pool".  It does not
  * update the entropy estimate.  The caller should call
@@ -484,24 +465,29 @@ static __u32 const twist_table[8] = {
  * it's cheap to do so and helps slightly in the expected case where
  * the entropy is concentrated in the low-order bits.
  */
-static void _mix_pool_bytes(struct entropy_store *r, const void *in,
+static void mix_pool_bytes_extract(struct entropy_store *r, const void *in,
 			    int nbytes, __u8 out[64])
 {
+	static __u32 const twist_table[8] = {
+		0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
+		0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
 	unsigned long i, j, tap1, tap2, tap3, tap4, tap5;
 	int input_rotate;
 	int wordmask = r->poolinfo->poolwords - 1;
 	const char *bytes = in;
 	__u32 w;
+	unsigned long flags;
 
+	/* Taps are constant, so we can load them without holding r->lock.  */
 	tap1 = r->poolinfo->tap1;
 	tap2 = r->poolinfo->tap2;
 	tap3 = r->poolinfo->tap3;
 	tap4 = r->poolinfo->tap4;
 	tap5 = r->poolinfo->tap5;
 
-	smp_rmb();
-	input_rotate = ACCESS_ONCE(r->input_rotate);
-	i = ACCESS_ONCE(r->add_ptr);
+	spin_lock_irqsave(&r->lock, flags);
+	input_rotate = r->input_rotate;
+	i = r->add_ptr;
 
 	/* mix one byte at a time to simplify size handling and churn faster */
 	while (nbytes--) {
@@ -528,61 +514,19 @@ static void _mix_pool_bytes(struct entro
 		input_rotate += i ? 7 : 14;
 	}
 
-	ACCESS_ONCE(r->input_rotate) = input_rotate;
-	ACCESS_ONCE(r->add_ptr) = i;
-	smp_wmb();
+	r->input_rotate = input_rotate;
+	r->add_ptr = i;
 
 	if (out)
 		for (j = 0; j < 16; j++)
 			((__u32 *)out)[j] = r->pool[(i - j) & wordmask];
-}
-
-static void __mix_pool_bytes(struct entropy_store *r, const void *in,
-			     int nbytes, __u8 out[64])
-{
-	trace_mix_pool_bytes_nolock(r->name, nbytes, _RET_IP_);
-	_mix_pool_bytes(r, in, nbytes, out);
-}
 
-static void mix_pool_bytes(struct entropy_store *r, const void *in,
-			   int nbytes, __u8 out[64])
-{
-	unsigned long flags;
-
-	trace_mix_pool_bytes(r->name, nbytes, _RET_IP_);
-	spin_lock_irqsave(&r->lock, flags);
-	_mix_pool_bytes(r, in, nbytes, out);
 	spin_unlock_irqrestore(&r->lock, flags);
 }
 
-struct fast_pool {
-	__u32		pool[4];
-	unsigned long	last;
-	unsigned short	count;
-	unsigned char	rotate;
-	unsigned char	last_timer_intr;
-};
-
-/*
- * This is a fast mixing routine used by the interrupt randomness
- * collector.  It's hardcoded for an 128 bit pool and assumes that any
- * locks that might be needed are taken by the caller.
- */
-static void fast_mix(struct fast_pool *f, const void *in, int nbytes)
+static void mix_pool_bytes(struct entropy_store *r, const void *in, int bytes)
 {
-	const char	*bytes = in;
-	__u32		w;
-	unsigned	i = f->count;
-	unsigned	input_rotate = f->rotate;
-
-	while (nbytes--) {
-		w = rol32(*bytes++, input_rotate & 31) ^ f->pool[i & 3] ^
-			f->pool[(i + 1) & 3];
-		f->pool[i & 3] = (w >> 3) ^ twist_table[w & 7];
-		input_rotate += (i++ & 3) ? 7 : 14;
-	}
-	f->count = i;
-	f->rotate = input_rotate;
+       mix_pool_bytes_extract(r, in, bytes, NULL);
 }
 
 /*
@@ -590,16 +534,17 @@ static void fast_mix(struct fast_pool *f
  */
 static void credit_entropy_bits(struct entropy_store *r, int nbits)
 {
-	int entropy_count, orig;
+	unsigned long flags;
+	int entropy_count;
 
 	if (!nbits)
 		return;
 
+	spin_lock_irqsave(&r->lock, flags);
+
 	DEBUG_ENT("added %d entropy credits to %s\n", nbits, r->name);
-retry:
-	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
+	entropy_count = r->entropy_count;
 	entropy_count += nbits;
-
 	if (entropy_count < 0) {
 		DEBUG_ENT("negative entropy/overflow\n");
 		entropy_count = 0;
@@ -605,23 +550,14 @@ retry:
 		entropy_count = 0;
 	} else if (entropy_count > r->poolinfo->POOLBITS)
 		entropy_count = r->poolinfo->POOLBITS;
-	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
-		goto retry;
-
-	if (!r->initialized && nbits > 0) {
-		r->entropy_total += nbits;
-		if (r->entropy_total > 128)
-			r->initialized = 1;
-	}
-
-	trace_credit_entropy_bits(r->name, nbits, entropy_count,
-				  r->entropy_total, _RET_IP_);
+	r->entropy_count = entropy_count;
 
 	/* should we wake readers? */
 	if (r == &input_pool && entropy_count >= random_read_wakeup_thresh) {
 		wake_up_interruptible(&random_read_wait);
 		kill_fasync(&fasync, SIGIO, POLL_IN);
 	}
+	spin_unlock_irqrestore(&r->lock, flags);
 }
 
 /*********************************************************************
@@ -637,24 +573,42 @@ struct timer_rand_state {
 	unsigned dont_count_entropy:1;
 };
 
-/*
- * Add device- or boot-specific data to the input and nonblocking
- * pools to help initialize them to unique values.
- *
- * None of this adds any entropy, it is meant to avoid the
- * problem of the nonblocking pool having similar initial state
- * across largely identical devices.
- */
-void add_device_randomness(const void *buf, unsigned int size)
+#ifndef CONFIG_GENERIC_HARDIRQS
+
+static struct timer_rand_state *irq_timer_state[NR_IRQS];
+
+static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
 {
-	unsigned long time = get_cycles() ^ jiffies;
+	return irq_timer_state[irq];
+}
 
-	mix_pool_bytes(&input_pool, buf, size, NULL);
-	mix_pool_bytes(&input_pool, &time, sizeof(time), NULL);
-	mix_pool_bytes(&nonblocking_pool, buf, size, NULL);
-	mix_pool_bytes(&nonblocking_pool, &time, sizeof(time), NULL);
+static void set_timer_rand_state(unsigned int irq,
+				 struct timer_rand_state *state)
+{
+	irq_timer_state[irq] = state;
 }
-EXPORT_SYMBOL(add_device_randomness);
+
+#else
+
+static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
+{
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+
+	return desc->timer_rand_state;
+}
+
+static void set_timer_rand_state(unsigned int irq,
+				 struct timer_rand_state *state)
+{
+	struct irq_desc *desc;
+
+	desc = irq_to_desc(irq);
+
+	desc->timer_rand_state = state;
+}
+#endif
 
 static struct timer_rand_state input_timer_state;
 
@@ -671,8 +625,8 @@ static struct timer_rand_state input_tim
 static void add_timer_randomness(struct timer_rand_state *state, unsigned num)
 {
 	struct {
+		cycles_t cycles;
 		long jiffies;
-		unsigned cycles;
 		unsigned num;
 	} sample;
 	long delta, delta2, delta3;
@@ -686,7 +640,7 @@ static void add_timer_randomness(struct
 	sample.jiffies = jiffies;
 	sample.cycles = get_cycles();
 	sample.num = num;
-	mix_pool_bytes(&input_pool, &sample, sizeof(sample), NULL);
+	mix_pool_bytes(&input_pool, &sample, sizeof(sample));
 
 	/*
 	 * Calculate number of bits of randomness we probably added.
@@ -743,48 +697,17 @@ void add_input_randomness(unsigned int t
 }
 EXPORT_SYMBOL_GPL(add_input_randomness);
 
-static DEFINE_PER_CPU(struct fast_pool, irq_randomness);
-
-void add_interrupt_randomness(int irq, int irq_flags)
+void add_interrupt_randomness(int irq)
 {
-	struct entropy_store	*r;
-	struct fast_pool	*fast_pool = &__get_cpu_var(irq_randomness);
-	struct pt_regs		*regs = get_irq_regs();
-	unsigned long		now = jiffies;
-	__u32			input[4], cycles = get_cycles();
-
-	input[0] = cycles ^ jiffies;
-	input[1] = irq;
-	if (regs) {
-		__u64 ip = instruction_pointer(regs);
-		input[2] = ip;
-		input[3] = ip >> 32;
-	}
+	struct timer_rand_state *state;
 
-	fast_mix(fast_pool, input, sizeof(input));
+	state = get_timer_rand_state(irq);
 
-	if ((fast_pool->count & 1023) &&
-	    !time_after(now, fast_pool->last + HZ))
+	if (state == NULL)
 		return;
 
-	fast_pool->last = now;
-
-	r = nonblocking_pool.initialized ? &input_pool : &nonblocking_pool;
-	__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool), NULL);
-	/*
-	 * If we don't have a valid cycle counter, and we see
-	 * back-to-back timer interrupts, then skip giving credit for
-	 * any entropy.
-	 */
-	if (cycles == 0) {
-		if (irq_flags & __IRQF_TIMER) {
-			if (fast_pool->last_timer_intr)
-				return;
-			fast_pool->last_timer_intr = 1;
-		} else
-			fast_pool->last_timer_intr = 0;
-	}
-	credit_entropy_bits(r, 1);
+	DEBUG_ENT("irq event %d\n", irq);
+	add_timer_randomness(state, 0x100 + irq);
 }
 
 #ifdef CONFIG_BLOCK
@@ -835,7 +758,7 @@ static void xfer_secondary_pool(struct e
 
 		bytes = extract_entropy(r->pull, tmp, bytes,
 					random_read_wakeup_thresh / 8, rsvd);
-		mix_pool_bytes(r, tmp, bytes, NULL);
+		mix_pool_bytes(r, tmp, bytes);
 		credit_entropy_bits(r, bytes*8);
 	}
 }
@@ -894,19 +817,13 @@ static size_t account(struct entropy_sto
 static void extract_buf(struct entropy_store *r, __u8 *out)
 {
 	int i;
-	union {
-		__u32 w[5];
-		unsigned long l[LONGS(EXTRACT_SIZE)];
-	} hash;
-	__u32 workspace[SHA_WORKSPACE_WORDS];
+	__u32 hash[5], workspace[SHA_WORKSPACE_WORDS];
 	__u8 extract[64];
-	unsigned long flags;
 
 	/* Generate a hash across the pool, 16 words (512 bits) at a time */
-	sha_init(hash.w);
-	spin_lock_irqsave(&r->lock, flags);
+	sha_init(hash);
 	for (i = 0; i < r->poolinfo->poolwords; i += 16)
-		sha_transform(hash.w, (__u8 *)(r->pool + i), workspace);
+		sha_transform(hash, (__u8 *)(r->pool + i), workspace);
 
 	/*
 	 * We mix the hash back into the pool to prevent backtracking
@@ -917,14 +834,13 @@ static void extract_buf(struct entropy_s
 	 * brute-forcing the feedback as hard as brute-forcing the
 	 * hash.
 	 */
-	__mix_pool_bytes(r, hash.w, sizeof(hash.w), extract);
-	spin_unlock_irqrestore(&r->lock, flags);
+	mix_pool_bytes_extract(r, hash, sizeof(hash), extract);
 
 	/*
 	 * To avoid duplicates, we atomically extract a portion of the
 	 * pool while mixing, and hash one final time.
 	 */
-	sha_transform(hash.w, extract, workspace);
+	sha_transform(hash, extract, workspace);
 	memset(extract, 0, sizeof(extract));
 	memset(workspace, 0, sizeof(workspace));
 
@@ -933,23 +849,11 @@ static void extract_buf(struct entropy_s
 	 * pattern, we fold it in half. Thus, we always feed back
 	 * twice as much data as we output.
 	 */
-	hash.w[0] ^= hash.w[3];
-	hash.w[1] ^= hash.w[4];
-	hash.w[2] ^= rol32(hash.w[2], 16);
-
-	/*
-	 * If we have a architectural hardware random number
-	 * generator, mix that in, too.
-	 */
-	for (i = 0; i < LONGS(EXTRACT_SIZE); i++) {
-		unsigned long v;
-		if (!arch_get_random_long(&v))
-			break;
-		hash.l[i] ^= v;
-	}
-
-	memcpy(out, &hash, EXTRACT_SIZE);
-	memset(&hash, 0, sizeof(hash));
+	hash[0] ^= hash[3];
+	hash[1] ^= hash[4];
+	hash[2] ^= rol32(hash[2], 16);
+	memcpy(out, hash, EXTRACT_SIZE);
+	memset(hash, 0, sizeof(hash));
 }
 
 static ssize_t extract_entropy(struct entropy_store *r, void *buf,
@@ -957,8 +861,8 @@ static ssize_t extract_entropy(struct en
 {
 	ssize_t ret = 0, i;
 	__u8 tmp[EXTRACT_SIZE];
+	unsigned long flags;
 
-	trace_extract_entropy(r->name, nbytes, r->entropy_count, _RET_IP_);
 	xfer_secondary_pool(r, nbytes);
 	nbytes = account(r, nbytes, min, reserved);
 
@@ -966,8 +870,6 @@ static ssize_t extract_entropy(struct en
 		extract_buf(r, tmp);
 
 		if (fips_enabled) {
-			unsigned long flags;
-
 			spin_lock_irqsave(&r->lock, flags);
 			if (!memcmp(tmp, r->last_data, EXTRACT_SIZE))
 				panic("Hardware RNG duplicated output!\n");
@@ -993,7 +895,6 @@ static ssize_t extract_entropy_user(stru
 	ssize_t ret = 0, i;
 	__u8 tmp[EXTRACT_SIZE];
 
-	trace_extract_entropy_user(r->name, nbytes, r->entropy_count, _RET_IP_);
 	xfer_secondary_pool(r, nbytes);
 	nbytes = account(r, nbytes, 0, 0);
 
@@ -1027,9 +928,8 @@ static ssize_t extract_entropy_user(stru
 
 /*
  * This function is the exported kernel interface.  It returns some
- * number of good random numbers, suitable for key generation, seeding
- * TCP sequence numbers, etc.  It does not use the hw random number
- * generator, if available; use get_random_bytes_arch() for that.
+ * number of good random numbers, suitable for seeding TCP sequence
+ * numbers, etc.
  */
 void get_random_bytes(void *buf, int nbytes)
 {
@@ -1038,39 +938,6 @@ void get_random_bytes(void *buf, int nby
 EXPORT_SYMBOL(get_random_bytes);
 
 /*
- * This function will use the architecture-specific hardware random
- * number generator if it is available.  The arch-specific hw RNG will
- * almost certainly be faster than what we can do in software, but it
- * is impossible to verify that it is implemented securely (as
- * opposed, to, say, the AES encryption of a sequence number using a
- * key known by the NSA).  So it's useful if we need the speed, but
- * only if we're willing to trust the hardware manufacturer not to
- * have put in a back door.
- */
-void get_random_bytes_arch(void *buf, int nbytes)
-{
-	char *p = buf;
-
-	trace_get_random_bytes(nbytes, _RET_IP_);
-	while (nbytes) {
-		unsigned long v;
-		int chunk = min(nbytes, (int)sizeof(unsigned long));
-
-		if (!arch_get_random_long(&v))
-			break;
-
-		memcpy(p, &v, chunk);
-		p += chunk;
-		nbytes -= chunk;
-	}
-
-	if (nbytes)
-		extract_entropy(&nonblocking_pool, p, nbytes, 0, 0);
-}
-EXPORT_SYMBOL(get_random_bytes_arch);
-
-
-/*
  * init_std_data - initialize pool with system data
  *
  * @r: pool to initialize
@@ -1081,31 +948,18 @@ EXPORT_SYMBOL(get_random_bytes_arch);
  */
 static void init_std_data(struct entropy_store *r)
 {
-	int i;
-	ktime_t now = ktime_get_real();
-	unsigned long rv;
+	ktime_t now;
+	unsigned long flags;
 
+	spin_lock_irqsave(&r->lock, flags);
 	r->entropy_count = 0;
-	r->entropy_total = 0;
-	mix_pool_bytes(r, &now, sizeof(now), NULL);
-	for (i = r->poolinfo->POOLBYTES; i > 0; i -= sizeof(rv)) {
-		if (!arch_get_random_long(&rv))
-			break;
-		mix_pool_bytes(r, &rv, sizeof(rv), NULL);
-	}
-	mix_pool_bytes(r, utsname(), sizeof(*(utsname())), NULL);
+	spin_unlock_irqrestore(&r->lock, flags);
+
+	now = ktime_get_real();
+	mix_pool_bytes(r, &now, sizeof(now));
+	mix_pool_bytes(r, utsname(), sizeof(*(utsname())));
 }
 
-/*
- * Note that setup_arch() may call add_device_randomness()
- * long before we get here. This allows seeding of the pools
- * with some platform dependent data very early in the boot
- * process. But it limits our options here. We must use
- * statically allocated structures that already have all
- * initializations complete at compile time. We should also
- * take care not to overwrite the precious per platform data
- * we were given.
- */
 static int rand_initialize(void)
 {
 	init_std_data(&input_pool);
@@ -1115,6 +969,24 @@ static int rand_initialize(void)
 }
 module_init(rand_initialize);
 
+void rand_initialize_irq(int irq)
+{
+	struct timer_rand_state *state;
+
+	state = get_timer_rand_state(irq);
+
+	if (state)
+		return;
+
+	/*
+	 * If kzalloc returns null, we just won't use that entropy
+	 * source.
+	 */
+	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
+	if (state)
+		set_timer_rand_state(irq, state);
+}
+
 #ifdef CONFIG_BLOCK
 void rand_initialize_disk(struct gendisk *disk)
 {
@@ -1222,7 +1094,7 @@ write_pool(struct entropy_store *r, cons
 		count -= bytes;
 		p += bytes;
 
-		mix_pool_bytes(r, buf, bytes, NULL);
+		mix_pool_bytes(r, buf, bytes);
 		cond_resched();
 	}
 
@@ -1365,15 +1237,10 @@ static int proc_do_uuid(ctl_table *table
 	uuid = table->data;
 	if (!uuid) {
 		uuid = tmp_uuid;
-		generate_random_uuid(uuid);
-	} else {
-		static DEFINE_SPINLOCK(bootid_spinlock);
-
-		spin_lock(&bootid_spinlock);
-		if (!uuid[8])
-			generate_random_uuid(uuid);
-		spin_unlock(&bootid_spinlock);
+		uuid[8] = 0;
 	}
+	if (uuid[8] == 0)
+		generate_random_uuid(uuid);
 
 	sprintf(buf, "%pU", uuid);
 
@@ -1452,14 +1319,9 @@ late_initcall(random_int_secret_init);
 DEFINE_PER_CPU(__u32 [MD5_DIGEST_WORDS], get_random_int_hash);
 unsigned int get_random_int(void)
 {
-	__u32 *hash;
+	__u32 *hash = get_cpu_var(get_random_int_hash);
 	unsigned int ret;
 
-	if (arch_get_random_int(&ret))
-		return ret;
-
-	hash = get_cpu_var(get_random_int_hash);
-
 	hash[0] += current->pid + jiffies + get_cycles();
 	md5_transform(hash, random_int_secret);
 	ret = hash[0];
@@ -1463,7 +1363,7 @@ void add_hwgenerator_randomness(const ch
 	 */
 	wait_event_interruptible(random_write_wait, kthread_should_stop() ||
 				 input_pool.entropy_count <= trickle_thresh);
-	mix_pool_bytes(poolp, buffer, count, NULL);
+	mix_pool_bytes(poolp, buffer, count);
 	credit_entropy_bits(poolp, count*8);
 }
 EXPORT_SYMBOL_GPL(add_hwgenerator_randomness);
diff -Burbp linux-3.0-SLE11-SP3.orig/drivers/firmware/dmi_scan.c linux-3.0-SLE11-SP3/drivers/firmware/dmi_scan.c
--- linux-3.0-SLE11-SP3.orig/drivers/firmware/dmi_scan.c	2013-04-05 18:19:57.620611703 +0200
+++ linux-3.0-SLE11-SP3/drivers/firmware/dmi_scan.c	2013-04-05 18:21:00.682569139 +0200
@@ -6,7 +6,6 @@
 #include <linux/dmi.h>
 #include <linux/efi.h>
 #include <linux/bootmem.h>
-#include <linux/random.h>
 #include <asm/dmi.h>
 
 /*
@@ -113,8 +112,6 @@ static int __init dmi_walk_early(void (*
 
 	dmi_table(buf, dmi_len, dmi_num, decode, NULL);
 
-	add_device_randomness(buf, dmi_len);
-
 	dmi_iounmap(buf, dmi_len);
 	return 0;
 }
diff -Burbp linux-3.0-SLE11-SP3.orig/drivers/mfd/ab3100-core.c linux-3.0-SLE11-SP3/drivers/mfd/ab3100-core.c
--- linux-3.0-SLE11-SP3.orig/drivers/mfd/ab3100-core.c	2013-04-05 18:16:31.506747551 +0200
+++ linux-3.0-SLE11-SP3/drivers/mfd/ab3100-core.c	2013-04-05 18:21:00.682569139 +0200
@@ -408,6 +408,8 @@ static irqreturn_t ab3100_irq_handler(in
 	u32 fatevent;
 	int err;
 
+	add_interrupt_randomness(irq);
+
 	err = ab3100_get_register_page_interruptible(ab3100, AB3100_EVENTA1,
 				       event_regs, 3);
 	if (err)
@@ -936,6 +938,9 @@ static int __devinit ab3100_probe(struct
 
 	err = request_threaded_irq(client->irq, NULL, ab3100_irq_handler,
 				IRQF_ONESHOT, "ab3100-core", ab3100);
+	/* This real unpredictable IRQ is of course sampled for entropy */
+	rand_initialize_irq(client->irq);
+
 	if (err)
 		goto exit_no_irq;
 
diff -Burbp linux-3.0-SLE11-SP3.orig/drivers/mfd/ab3550-core.c linux-3.0-SLE11-SP3/drivers/mfd/ab3550-core.c
--- linux-3.0-SLE11-SP3.orig/drivers/mfd/ab3550-core.c	2013-04-05 18:16:31.506747551 +0200
+++ linux-3.0-SLE11-SP3/drivers/mfd/ab3550-core.c	2013-04-05 18:21:00.682569139 +0200
@@ -1309,6 +1309,8 @@ static int __init ab3550_probe(struct i2
 
 	err = request_threaded_irq(client->irq, NULL, ab3550_irq_handler,
 		IRQF_ONESHOT, "ab3550-core", ab);
+	/* This real unpredictable IRQ is of course sampled for entropy */
+	rand_initialize_irq(client->irq);
 
 	if (err)
 		goto exit_no_irq;
diff -Burbp linux-3.0-SLE11-SP3.orig/drivers/mfd/wm831x-otp.c linux-3.0-SLE11-SP3/drivers/mfd/wm831x-otp.c
--- linux-3.0-SLE11-SP3.orig/drivers/mfd/wm831x-otp.c	2013-04-05 18:16:31.506747551 +0200
+++ linux-3.0-SLE11-SP3/drivers/mfd/wm831x-otp.c	2013-04-05 18:21:00.683569185 +0200
@@ -18,7 +18,6 @@
 #include <linux/bcd.h>
 #include <linux/delay.h>
 #include <linux/mfd/core.h>
-#include <linux/random.h>
 
 #include <linux/mfd/wm831x/core.h>
 #include <linux/mfd/wm831x/otp.h>
@@ -67,7 +66,6 @@ static DEVICE_ATTR(unique_id, 0444, wm83
 
 int wm831x_otp_init(struct wm831x *wm831x)
 {
-	char uuid[WM831X_UNIQUE_ID_LEN];
 	int ret;
 
 	ret = device_create_file(wm831x->dev, &dev_attr_unique_id);
@@ -75,12 +73,6 @@ int wm831x_otp_init(struct wm831x *wm831
 		dev_err(wm831x->dev, "Unique ID attribute not created: %d\n",
 			ret);
 
-	ret = wm831x_unique_id_read(wm831x, uuid);
-	if (ret == 0)
-		add_device_randomness(uuid, sizeof(uuid));
-	else
-		dev_err(wm831x->dev, "Failed to read UUID: %d\n", ret);
-
 	return ret;
 }
 
diff -Burbp linux-3.0-SLE11-SP3.orig/drivers/rtc/rtc-wm831x.c linux-3.0-SLE11-SP3/drivers/rtc/rtc-wm831x.c
--- linux-3.0-SLE11-SP3.orig/drivers/rtc/rtc-wm831x.c	2013-04-05 18:16:31.508747549 +0200
+++ linux-3.0-SLE11-SP3/drivers/rtc/rtc-wm831x.c	2013-04-05 18:21:00.683569185 +0200
@@ -24,7 +24,7 @@
 #include <linux/mfd/wm831x/core.h>
 #include <linux/delay.h>
 #include <linux/platform_device.h>
-#include <linux/random.h>
+
 
 /*
  * R16416 (0x4020) - RTC Write Counter
@@ -96,26 +96,6 @@ struct wm831x_rtc {
 	unsigned int alarm_enabled:1;
 };
 
-static void wm831x_rtc_add_randomness(struct wm831x *wm831x)
-{
-	int ret;
-	u16 reg;
-
-	/*
-	 * The write counter contains a pseudo-random number which is
-	 * regenerated every time we set the RTC so it should be a
-	 * useful per-system source of entropy.
-	 */
-	ret = wm831x_reg_read(wm831x, WM831X_RTC_WRITE_COUNTER);
-	if (ret >= 0) {
-		reg = ret;
-		add_device_randomness(&reg, sizeof(reg));
-	} else {
-		dev_warn(wm831x->dev, "Failed to read RTC write counter: %d\n",
-			 ret);
-	}
-}
-
 /*
  * Read current time and date in RTC
  */
@@ -469,8 +449,6 @@ static int wm831x_rtc_probe(struct platf
 			alm_irq, ret);
 	}
 
-	wm831x_rtc_add_randomness(wm831x);
-
 	return 0;
 
 err:
diff -Burbp linux-3.0-SLE11-SP3.orig/drivers/usb/core/hub.c linux-3.0-SLE11-SP3/drivers/usb/core/hub.c
--- linux-3.0-SLE11-SP3.orig/drivers/usb/core/hub.c	2013-04-05 18:19:21.704635476 +0200
+++ linux-3.0-SLE11-SP3/drivers/usb/core/hub.c	2013-04-05 18:21:00.684569228 +0200
@@ -24,7 +24,6 @@
 #include <linux/kthread.h>
 #include <linux/mutex.h>
 #include <linux/freezer.h>
-#include <linux/random.h>
 
 #include <asm/uaccess.h>
 #include <asm/byteorder.h>
@@ -2206,14 +2205,6 @@ int usb_new_device(struct usb_device *ud
 	/* Tell the world! */
 	announce_device(udev);
 
-	if (udev->serial)
-		add_device_randomness(udev->serial, strlen(udev->serial));
-	if (udev->product)
-		add_device_randomness(udev->product, strlen(udev->product));
-	if (udev->manufacturer)
-		add_device_randomness(udev->manufacturer,
-				      strlen(udev->manufacturer));
-
 	device_enable_async_suspend(&udev->dev);
 	/* Register the device.  The device driver is responsible
 	 * for configuring the device and invoking the add-device
diff -Burbp linux-3.0-SLE11-SP3.orig/include/linux/random.h linux-3.0-SLE11-SP3/include/linux/random.h
--- linux-3.0-SLE11-SP3.orig/include/linux/random.h	2013-04-05 18:16:31.510747548 +0200
+++ linux-3.0-SLE11-SP3/include/linux/random.h	2013-04-05 18:21:00.684569228 +0200
@@ -48,13 +48,13 @@ struct rnd_state {
 
 #ifdef __KERNEL__
 
-extern void add_device_randomness(const void *, unsigned int);
+extern void rand_initialize_irq(int irq);
+
 extern void add_input_randomness(unsigned int type, unsigned int code,
 				 unsigned int value);
-extern void add_interrupt_randomness(int irq, int irq_flags);
+extern void add_interrupt_randomness(int irq);
 
 extern void get_random_bytes(void *buf, int nbytes);
-extern void get_random_bytes_arch(void *buf, int nbytes);
 void generate_random_uuid(unsigned char uuid_out[16]);
 
 #ifndef MODULE
@@ -91,19 +91,6 @@ static inline void prandom32_seed(struct
 	state->s3 = __seed(i, 15);
 }
 
-#ifdef CONFIG_ARCH_RANDOM
-# include <asm/archrandom.h>
-#else
-static inline int arch_get_random_long(unsigned long *v)
-{
-	return 0;
-}
-static inline int arch_get_random_int(unsigned int *v)
-{
-	return 0;
-}
-#endif
-
 #endif /* __KERNEL___ */
 
 #endif /* _LINUX_RANDOM_H */
Only in linux-3.0-SLE11-SP3.orig/include/trace/events: random.h
diff -Burbp linux-3.0-SLE11-SP3.orig/kernel/irq/handle.c linux-3.0-SLE11-SP3/kernel/irq/handle.c
--- linux-3.0-SLE11-SP3.orig/kernel/irq/handle.c	2013-04-05 18:16:31.511747547 +0200
+++ linux-3.0-SLE11-SP3/kernel/irq/handle.c	2013-04-05 18:21:00.684569228 +0200
@@ -117,7 +117,7 @@ irqreturn_t
 handle_irq_event_percpu(struct irq_desc *desc, struct irqaction *action)
 {
 	irqreturn_t retval = IRQ_NONE;
-	unsigned int flags = 0, irq = desc->irq_data.irq;
+	unsigned int random = 0, irq = desc->irq_data.irq;
 
 	do {
 		irqreturn_t res;
@@ -145,7 +145,7 @@ handle_irq_event_percpu(struct irq_desc
 
 			/* Fall through to add to randomness */
 		case IRQ_HANDLED:
-			flags |= action->flags;
+			random |= action->flags;
 			break;
 
 		default:
@@ -156,7 +156,8 @@ handle_irq_event_percpu(struct irq_desc
 		action = action->next;
 	} while (action);
 
-	add_interrupt_randomness(irq, flags);
+	if (random & IRQF_SAMPLE_RANDOM)
+		add_interrupt_randomness(irq);
 
 	if (!noirqdebug)
 		note_interrupt(irq, desc, retval);
diff -Burbp linux-3.0-SLE11-SP3.orig/kernel/irq/manage.c linux-3.0-SLE11-SP3/kernel/irq/manage.c
--- linux-3.0-SLE11-SP3.orig/kernel/irq/manage.c	2013-04-05 18:16:32.013747218 +0200
+++ linux-3.0-SLE11-SP3/kernel/irq/manage.c	2013-04-05 18:21:00.685569268 +0200
@@ -895,6 +895,22 @@ __setup_irq(unsigned int irq, struct irq
 
 	if (desc->irq_data.chip == &no_irq_chip)
 		return -ENOSYS;
+	/*
+	 * Some drivers like serial.c use request_irq() heavily,
+	 * so we have to be careful not to interfere with a
+	 * running system.
+	 */
+	if (new->flags & IRQF_SAMPLE_RANDOM) {
+		/*
+		 * This function might sleep, we want to call it first,
+		 * outside of the atomic block.
+		 * Yes, this might clear the entropy pool if the wrong
+		 * driver is attempted to be loaded, without actually
+		 * installing a new handler, but is this really a problem,
+		 * only the sysadmin is able to do this.
+		 */
+		rand_initialize_irq(irq);
+	}
 
 	/*
 	 * Check whether the interrupt nests into another interrupt
@@ -1328,6 +1344,7 @@ EXPORT_SYMBOL(free_irq);
  *	Flags:
  *
  *	IRQF_SHARED		Interrupt is shared
+ *	IRQF_SAMPLE_RANDOM	The interrupt can be used for entropy
  *	IRQF_TRIGGER_*		Specify active edge(s) or level
  *
  */
diff -Burbp linux-3.0-SLE11-SP3.orig/net/core/dev.c linux-3.0-SLE11-SP3/net/core/dev.c
--- linux-3.0-SLE11-SP3.orig/net/core/dev.c	2013-04-05 18:18:28.462670639 +0200
+++ linux-3.0-SLE11-SP3/net/core/dev.c	2013-04-05 18:21:00.686569305 +0200
@@ -1171,7 +1171,6 @@ static int __dev_open(struct net_device
 		net_dmaengine_get();
 		dev_set_rx_mode(dev);
 		dev_activate(dev);
-		add_device_randomness(dev->dev_addr, dev->addr_len);
 	}
 
 	return ret;
@@ -4807,7 +4806,6 @@ int dev_set_mac_address(struct net_devic
 	err = ops->ndo_set_mac_address(dev, sa);
 	if (!err)
 		call_netdevice_notifiers(NETDEV_CHANGEADDR, dev);
-	add_device_randomness(dev->dev_addr, dev->addr_len);
 	return err;
 }
 EXPORT_SYMBOL(dev_set_mac_address);
@@ -5585,7 +5583,6 @@ int register_netdevice(struct net_device
 	dev_init_scheduler(dev);
 	dev_hold(dev);
 	list_netdevice(dev);
-	add_device_randomness(dev->dev_addr, dev->addr_len);
 
 	/* Notify protocols, that a new device appeared. */
 	ret = call_netdevice_notifiers(NETDEV_REGISTER, dev);
diff -Burbp linux-3.0-SLE11-SP3.orig/net/core/rtnetlink.c linux-3.0-SLE11-SP3/net/core/rtnetlink.c
--- linux-3.0-SLE11-SP3.orig/net/core/rtnetlink.c	2013-04-05 18:18:56.685652011 +0200
+++ linux-3.0-SLE11-SP3/net/core/rtnetlink.c	2013-04-05 18:21:00.686569305 +0200
@@ -1372,7 +1372,6 @@ static int do_setlink(struct net_device
 			goto errout;
 		send_addr_notify = 1;
 		modified = 1;
-		add_device_randomness(dev->dev_addr, dev->addr_len);
 	}
 
 	if (tb[IFLA_MTU]) {
