From 533574c6bc30cf526cc1c41bde050c854a945efb Mon Sep 17 00:00:00 2001
From: Joe Perches <joe@perches.com>
Date: Mon, 30 Jul 2012 14:40:13 -0700
Subject: btrfs: use printk_get_level and printk_skip_level, add __printf, fix
 fallout
Git-commit: 533574c6bc30cf526cc1c41bde050c854a945efb
Patch-mainline: v3.6-rc1

Use the generic printk_get_level() to search a message for a kern_level.

Add __printf to verify format and arguments.  Fix a few messages that
had mismatches in format and arguments.  Add #ifdef CONFIG_PRINTK blocks
to shrink the object size a bit when not using printk.

[akpm@linux-foundation.org: whitespace tweak]
Signed-off-by: Joe Perches <joe@perches.com>
Cc: Kay Sievers <kay.sievers@vrfy.org>
Cc: Chris Mason <chris.mason@oracle.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/btrfs/ctree.h      |   13 +++++++++++++
 fs/btrfs/disk-io.c    |    2 +-
 fs/btrfs/relocation.c |    2 +-
 fs/btrfs/super.c      |   41 +++++++++++++++++++++++++++++++++++------
 4 files changed, 50 insertions(+), 8 deletions(-)

--- a/fs/btrfs/ctree.h	2013-11-23 14:29:55.922586823 -0500
+++ b/fs/btrfs/ctree.h	2013-11-23 14:31:18.925351161 -0500
@@ -3342,10 +3342,22 @@ ssize_t btrfs_listxattr(struct dentry *d
 /* super.c */
 int btrfs_parse_options(struct btrfs_root *root, char *options);
 int btrfs_sync_fs(struct super_block *sb, int wait);
+
+#ifdef CONFIG_PRINTK
+__printf(2, 3)
 void btrfs_printk(struct btrfs_fs_info *fs_info, const char *fmt, ...);
+#else
+static inline __printf(2, 3)
+void btrfs_printk(struct btrfs_fs_info *fs_info, const char *fmt, ...)
+{
+}
+#endif
+
+__printf(5, 6)
 void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
 		     unsigned int line, int errno, const char *fmt, ...);
 
+
 void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,
 			       struct btrfs_root *root, const char *function,
 			       unsigned int line, int errno);
@@ -3386,6 +3398,7 @@ do {								\
 			  (errno), fmt, ##args);		\
 } while (0)
 
+__printf(5, 6)
 void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,
 		   unsigned int line, int errno, const char *fmt, ...);
 
--- a/fs/btrfs/disk-io.c	2013-11-23 14:30:15.338297872 -0500
+++ b/fs/btrfs/disk-io.c	2013-11-23 14:31:18.929351101 -0500
@@ -1117,7 +1117,7 @@ void clean_tree_block(struct btrfs_trans
 				spin_unlock(&root->fs_info->delalloc_lock);
 				btrfs_panic(root->fs_info, -EOVERFLOW,
 					  "Can't clear %lu bytes from "
-					  " dirty_mdatadata_bytes (%lu)",
+					  " dirty_mdatadata_bytes (%llu)",
 					  buf->len,
 					  root->fs_info->dirty_metadata_bytes);
 			}
--- a/fs/btrfs/relocation.c	2013-11-23 14:29:55.422594263 -0500
+++ b/fs/btrfs/relocation.c	2013-11-23 14:31:18.933351042 -0500
@@ -1241,7 +1241,7 @@ static int __must_check __add_reloc_root
 	if (rb_node) {
 		btrfs_panic(root->fs_info, -EEXIST, "Duplicate root found "
 			    "for start=%llu while inserting into relocation "
-			    "tree\n");
+			    "tree\n", node->bytenr);
 		kfree(node);
 		return -EEXIST;
 	}
--- a/fs/btrfs/super.c	2013-11-23 14:31:08.837501392 -0500
+++ b/fs/btrfs/super.c	2013-11-23 14:31:18.937350982 -0500
@@ -126,6 +126,7 @@ static void btrfs_handle_error(struct bt
 	}
 }
 
+#ifdef CONFIG_PRINTK
 /*
  * __btrfs_std_error decodes expected errors from the caller and
  * invokes the approciate error response.
@@ -168,7 +169,7 @@ void __btrfs_std_error(struct btrfs_fs_i
 	va_end(args);
 }
 
-const char *logtypes[] = {
+static const char * const logtypes[] = {
 	"emergency",
 	"alert",
 	"critical",
@@ -186,21 +187,49 @@ void btrfs_printk(struct btrfs_fs_info *
 	struct va_format vaf;
 	va_list args;
 	const char *type = logtypes[4];
+	int kern_level;
 
 	va_start(args, fmt);
 
-	if (fmt[0] == '<' && isdigit(fmt[1]) && fmt[2] == '>') {
-		memcpy(lvl, fmt, 3);
-		lvl[3] = '\0';
-		fmt += 3;
-		type = logtypes[fmt[1] - '0'];
+	kern_level = printk_get_level(fmt);
+	if (kern_level) {
+		size_t size = printk_skip_level(fmt) - fmt;
+		memcpy(lvl, fmt,  size);
+		lvl[size] = '\0';
+		fmt += size;
+		type = logtypes[kern_level - '0'];
 	} else
 		*lvl = '\0';
 
 	vaf.fmt = fmt;
 	vaf.va = &args;
+
 	printk("%sBTRFS %s (device %s): %pV", lvl, type, sb->s_id, &vaf);
+
+	va_end(args);
+}
+
+#else
+
+void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,
+		       unsigned int line, int errno, const char *fmt, ...)
+{
+	struct super_block *sb = fs_info->sb;
+
+	/*
+	 * Special case: if the error is EROFS, and we're already
+	 * under MS_RDONLY, then it is safe here.
+	 */
+	if (errno == -EROFS && (sb->s_flags & MS_RDONLY))
+		return;
+
+	/* Don't go through full error handling during mount */
+	if (sb->s_flags & MS_BORN) {
+		save_error_info(fs_info);
+		btrfs_handle_error(fs_info);
+	}
 }
+#endif
 
 /*
  * We only mark the transaction aborted and then set the file system read-only.
