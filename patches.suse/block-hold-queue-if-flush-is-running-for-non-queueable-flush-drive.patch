From: shaohua.li@intel.com <shaohua.li@intel.com>
Date: Fri, 6 May 2011 11:34:41 -0600
Subject: block: hold queue if flush is running for non-queueable flush drive
References: FATE#312039
Patch-mainline: v3.0-rc1
Git-commit: 3ac0cc4508709d42ec9aa351086c7d38bfc0660c

In some drives, flush requests are non-queueable. When flush request is
running, normal read/write requests can't run. If block layer dispatches
such request, driver can't handle it and requeue it.  Tejun suggested we
can hold the queue when flush is running. This can avoid unnecessary
requeue.  Also this can improve performance. For example, we have
request flush1, write1, flush 2. flush1 is dispatched, then queue is
hold, write1 isn't inserted to queue. After flush1 is finished, flush2
will be dispatched. Since disk cache is already clean, flush2 will be
finished very soon, so looks like flush2 is folded to flush1.

In my test, the queue holding completely solves a regression introduced by
commit 53d63e6b0dfb95882ec0219ba6bbd50cde423794:

    block: make the flush insertion use the tail of the dispatch list

    It's not a preempt type request, in fact we have to insert it
    behind requests that do specify INSERT_FRONT.

which causes about 20% regression running a sysbench fileio
workload.

Stable: 2.6.39 only

Cc: stable@kernel.org
Signed-off-by: Shaohua Li <shaohua.li@intel.com>
Acked-by: Tejun Heo <tj@kernel.org>
Signed-off-by: Jens Axboe <jaxboe@fusionio.com>
Acked-by: Suresh Jayaraman <sjayaraman@suse.de>
---
 block/blk-flush.c      |   18 ++++++++++++------
 include/linux/blkdev.h |    1 +
 2 files changed, 13 insertions(+), 6 deletions(-)

Index: linux-2.6.32-SLE11-SP2/block/blk-flush.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/block/blk-flush.c
+++ linux-2.6.32-SLE11-SP2/block/blk-flush.c
@@ -211,14 +211,20 @@ static void flush_end_io(struct request
 		queued |= blk_flush_complete_seq(rq, seq, error);
 	}
 
- 	/*
- 	 * Moving a request silently to empty queue_head may stall the
-	 * queue.  Kick the queue in those cases.  This function is called
-	 * from request completion path and calling directly into
-	 * request_fn may confuse the driver.  Always use kblockd.
+	/*
+	 * Kick the queue to avoid stall for two cases:
+	 * 1. Moving a request silently to empty queue_head may stall the
+	 * queue.
+	 * 2. When flush request is running in non-queueable queue, the
+	 * queue is hold. Restart the queue after flush request is finished
+	 * to avoid stall.
+	 * This function is called from request completion path and calling
+	 * directly into request_fn may confuse the driver.  Always use
+	 * kblockd.
 	 */
-	if (queued && was_empty)
+	if ((queued && was_empty) || q->flush_queue_delayed)
 		__blk_run_queue(q, true);
+	q->flush_queue_delayed = 0;
 }
 
 /**
Index: linux-2.6.32-SLE11-SP2/include/linux/blkdev.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/include/linux/blkdev.h
+++ linux-2.6.32-SLE11-SP2/include/linux/blkdev.h
@@ -369,6 +369,7 @@ struct request_queue
 	 */
 	unsigned int		flush_flags;
 	unsigned int		flush_not_queueable:1;
+	unsigned int		flush_queue_delayed:1;
 	unsigned int		flush_pending_idx:1;
 	unsigned int		flush_running_idx:1;
 	unsigned long		flush_pending_since;
