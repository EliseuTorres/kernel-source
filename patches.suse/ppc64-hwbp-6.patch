From: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
Subject: powerpc/booke: Fix breakpoint/watchpoint one-shot behavior
Date: Mon Mar 1 04:57:34 2010 +0000
Git-commit: 30124d11097e371e42052144d8a3f4a78d26e09f
Patch-mainline: v2.6.34-rc2
References: FATE#311653, BNC#702123
Signed-off-by: Tony Jones <tonyj@suse.de>

    powerpc/booke: Fix breakpoint/watchpoint one-shot behavior
    
    Another fix for the extended ptrace patches in the -next tree.
    
    The handling of breakpoints and watchpoints is inconsistent.  When a
    breakpoint or watchpoint is hit, the interrupt handler is clearing the
    proper bits in the dbcr* registers, but leaving the dac* and iac* registers
    alone.  The ptrace code to delete the break/watchpoints checks the dac* and
    iac* registers for zero to determine if they are enabled.  Instead, they
    should check the dbcr* bits.
    
    Signed-off-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

---
 arch/powerpc/kernel/ptrace.c |   12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

--- a/arch/powerpc/kernel/ptrace.c
+++ b/arch/powerpc/kernel/ptrace.c
@@ -949,7 +949,7 @@ static int del_instruction_bp(struct tas
 {
 	switch (slot) {
 	case 1:
-		if (child->thread.iac1 == 0)
+		if ((child->thread.dbcr0 & DBCR0_IAC1) == 0)
 			return -ENOENT;
 
 		if (dbcr_iac_range(child) & DBCR_IAC12MODE) {
@@ -961,7 +961,7 @@ static int del_instruction_bp(struct tas
 		child->thread.dbcr0 &= ~DBCR0_IAC1;
 		break;
 	case 2:
-		if (child->thread.iac2 == 0)
+		if ((child->thread.dbcr0 & DBCR0_IAC2) == 0)
 			return -ENOENT;
 
 		if (dbcr_iac_range(child) & DBCR_IAC12MODE)
@@ -972,7 +972,7 @@ static int del_instruction_bp(struct tas
 		break;
 #if CONFIG_PPC_ADV_DEBUG_IACS > 2
 	case 3:
-		if (child->thread.iac3 == 0)
+		if ((child->thread.dbcr0 & DBCR0_IAC3) == 0)
 			return -ENOENT;
 
 		if (dbcr_iac_range(child) & DBCR_IAC34MODE) {
@@ -984,7 +984,7 @@ static int del_instruction_bp(struct tas
 		child->thread.dbcr0 &= ~DBCR0_IAC3;
 		break;
 	case 4:
-		if (child->thread.iac4 == 0)
+		if ((child->thread.dbcr0 & DBCR0_IAC4) == 0)
 			return -ENOENT;
 
 		if (dbcr_iac_range(child) & DBCR_IAC34MODE)
@@ -1063,7 +1063,7 @@ static int set_dac(struct task_struct *c
 static int del_dac(struct task_struct *child, int slot)
 {
 	if (slot == 1) {
-		if (child->thread.dac1 == 0)
+		if ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)
 			return -ENOENT;
 
 		child->thread.dac1 = 0;
@@ -1079,7 +1079,7 @@ static int del_dac(struct task_struct *c
 		child->thread.dvc1 = 0;
 #endif
 	} else if (slot == 2) {
-		if (child->thread.dac2 == 0)
+		if ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)
 			return -ENOENT;
 
 #ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE
