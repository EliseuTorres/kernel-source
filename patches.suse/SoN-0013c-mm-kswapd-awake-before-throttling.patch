From: Mel Gorman <mgorman@suse.de>
Date: Fri, 23 Sep 2011 11:33:46 +0100
Subject: [PATCH] mm: Ensure that kswapd is awake if throttling on pfmemmalloc reserves
References: Swap over NFS (fate#304949, bnc#717939)
Patch-mainline: no

If a process gets throttled as pfmemalloc reserves are being depleted,
only kswapd can wake it again. However if kswapd was awake but going to
sleep because all_unreclaimable == true, then it will continue to go to
sleep. As watermarks are low, processes still get throttled but kswapd
is no longer awake so they sleep indefinitely.

This patch ensures that kswapd is active before throttling. The downside
is that kswapd may consume slightly more CPU when under memory pressure
and processes are getting throttled.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/vmscan.c |   12 +++++++++++-
 1 files changed, 11 insertions(+), 1 deletions(-)

diff --git a/mm/vmscan.c b/mm/vmscan.c
index f706d29..9f3603e 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -2171,6 +2171,7 @@ static bool pfmemalloc_watermark_ok(pg_data_t *pgdat, int high_zoneidx)
 	unsigned long pfmemalloc_reserve = 0;
 	unsigned long free_pages = 0;
 	int i;
+	bool wmark_ok;
 
 	for (i = 0; i <= high_zoneidx; i++) {
 		zone = &pgdat->node_zones[i];
@@ -2178,7 +2179,16 @@ static bool pfmemalloc_watermark_ok(pg_data_t *pgdat, int high_zoneidx)
 		free_pages += zone_page_state(zone, NR_FREE_PAGES);
 	}
 
-	return (free_pages > pfmemalloc_reserve / 2) ? true : false;
+	wmark_ok = (free_pages > pfmemalloc_reserve / 2) ? true : false;
+
+	/* kswapd must be awake if processes are being throttled */
+	if (!wmark_ok && waitqueue_active(&pgdat->kswapd_wait)) {
+		pgdat->classzone_idx = min(pgdat->classzone_idx,
+						(enum zone_type)high_zoneidx);
+		wake_up_interruptible(&pgdat->kswapd_wait);
+	}
+
+	return wmark_ok;
 }
 
 /*
