From: Andre Przywara <andre.przywara@amd.com>
Subject: [PATCH 05/12] KVM: SVM: Add clean-bit for interrupt state
References: FATE#309760
Git-commit: decdbf6a4c4f5cf14343946031aff24ff815c909
Patch-mainline: v2.6.38

This patch implements the clean-bit for all interrupt
related state in the vmcb. This corresponds to vmcb offset
0x60-0x67.

Backport of decdbf6a4c4f5cf14343946031aff24ff815c909
(done by: Joerg Roedel <joerg.roedel@amd.com>)

Signed-off-by: Andre Przywara <andre.przywara@amd.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/kvm/svm.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

Index: b/arch/x86/kvm/svm.c
===================================================================
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -146,10 +146,12 @@ enum {
 	                    pause filter count */
 	VMCB_PERM_MAP,   /* IOPM Base and MSRPM Base */
 	VMCB_ASID,       /* ASID */
+	VMCB_INTR,       /* int_ctl, int_vector */
 	VMCB_DIRTY_MAX,
 };
 
-#define VMCB_ALWAYS_DIRTY_MASK 0U
+/* TPR is always written before VMRUN */
+#define VMCB_ALWAYS_DIRTY_MASK (1U << VMCB_INTR)
 
 static inline void mark_all_dirty(struct vmcb *vmcb)
 {
@@ -2103,6 +2105,7 @@ static int clgi_interception(struct vcpu
 	/* After a CLGI no interrupts should come */
 	svm_clear_vintr(svm);
 	svm->vmcb->control.int_ctl &= ~V_IRQ_MASK;
+	mark_dirty(svm->vmcb, VMCB_INTR);
 
 	return 1;
 }
@@ -2541,6 +2544,7 @@ static int interrupt_window_interception
 {
 	svm_clear_vintr(svm);
 	svm->vmcb->control.int_ctl &= ~V_IRQ_MASK;
+	mark_dirty(svm->vmcb, VMCB_INTR);
 	/*
 	 * If the user space waits to inject interrupts, exit as soon as
 	 * possible
@@ -2724,6 +2728,7 @@ static inline void svm_inject_irq(struct
 	control->int_ctl &= ~V_INTR_PRIO_MASK;
 	control->int_ctl |= V_IRQ_MASK |
 		((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);
+	mark_dirty(svm->vmcb, VMCB_INTR);
 }
 
 static void svm_set_irq(struct kvm_vcpu *vcpu)
@@ -2853,6 +2858,7 @@ static inline void sync_lapic_to_cr8(str
 	cr8 = kvm_get_cr8(vcpu);
 	svm->vmcb->control.int_ctl &= ~V_TPR_MASK;
 	svm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;
+	mark_dirty(svm->vmcb, VMCB_INTR);
 }
 
 static void svm_complete_interrupts(struct vcpu_svm *svm)
