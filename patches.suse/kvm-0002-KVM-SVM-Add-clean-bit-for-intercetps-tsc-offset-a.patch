From: Andre Przywara <andre.przywara@amd.com>
Subject: [PATCH 02/12] KVM: SVM: Add clean-bit for intercepts, tsc-offset and pause filter count
References: FATE#309760
Git-commit:116a0a23676e7d29b7747a53f819baaaf4b88575
Patch-mainline: v2.6.38

This patch adds the clean-bit for intercepts-vectors, the
TSC offset and the pause-filter count to the appropriate
places. The IO and MSR permission bitmaps are not subject to
this bit.

Backport of 116a0a23676e7d29b7747a53f819baaaf4b88575
(done by: Joerg Roedel <joerg.roedel@amd.com>)

Signed-off-by: Andre Przywara <andre.przywara@amd.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/kvm/svm.c |   18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

Index: b/arch/x86/kvm/svm.c
===================================================================
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -142,6 +142,8 @@ static int nested_svm_check_exception(st
 				      bool has_error_code, u32 error_code);
 
 enum {
+	VMCB_INTERCEPTS, /* Intercept vectors, TSC offset,
+	                    pause filter count */
 	VMCB_DIRTY_MAX,
 };
 
@@ -790,6 +792,7 @@ static struct kvm_vcpu *svm_create_vcpu(
 	svm->asid_generation = 0;
 	init_vmcb(svm);
 	svm->vmcb->control.tsc_offset = 0-native_read_tsc();
+	mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 
 	fx_init(&svm->vcpu);
 	svm->vcpu.arch.apic_base = 0xfee00000 | MSR_IA32_APICBASE_ENABLE;
@@ -839,6 +842,7 @@ static void svm_vcpu_load(struct kvm_vcp
 			 */
 			delta = vcpu->arch.host_tsc - native_read_tsc();
 			svm->vmcb->control.tsc_offset += delta;
+			mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 			if (is_nested(svm))
 				svm->nested.hsave->control.tsc_offset += delta;
 		}
@@ -889,11 +893,13 @@ static void svm_cache_reg(struct kvm_vcp
 static void svm_set_vintr(struct vcpu_svm *svm)
 {
 	svm->vmcb->control.intercept |= 1ULL << INTERCEPT_VINTR;
+	mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 }
 
 static void svm_clear_vintr(struct vcpu_svm *svm)
 {
 	svm->vmcb->control.intercept &= ~(1ULL << INTERCEPT_VINTR);
+	mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 }
 
 static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
@@ -1051,6 +1057,7 @@ static void update_cr0_intercept(struct
 		svm->vmcb->control.intercept_cr_read |= INTERCEPT_CR0_MASK;
 		svm->vmcb->control.intercept_cr_write |= INTERCEPT_CR0_MASK;
 	}
+	mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 }
 
 static void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)
@@ -1150,6 +1157,8 @@ static void update_db_intercept(struct k
 				1 << BP_VECTOR;
 	} else
 		vcpu->guest_debug = 0;
+
+	mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 }
 
 static int svm_guest_debug(struct kvm_vcpu *vcpu, struct kvm_guest_debug *dbg)
@@ -2193,6 +2202,7 @@ static int iret_interception(struct vcpu
 	++svm->vcpu.stat.nmi_window_exits;
 	svm->vmcb->control.intercept &= ~(1ULL << INTERCEPT_IRET);
 	svm->vcpu.arch.hflags |= HF_IRET_MASK;
+	mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 	return 1;
 }
 
@@ -2321,6 +2331,7 @@ static int cr8_write_interception(struct
 	r = cr_interception(svm, kvm_run);
 	if (irqchip_in_kernel(svm->vcpu.kvm)) {
 		svm->vmcb->control.intercept_cr_write &= ~INTERCEPT_CR8_MASK;
+		mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 		return r;
 	}
 	if (cr8_prev <= kvm_get_cr8(&svm->vcpu))
@@ -2693,6 +2704,7 @@ static void svm_inject_nmi(struct kvm_vc
 	svm->vmcb->control.event_inj = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;
 	vcpu->arch.hflags |= HF_NMI_MASK;
 	svm->vmcb->control.intercept |= (1ULL << INTERCEPT_IRET);
+	mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 	++vcpu->stat.nmi_injections;
 }
 
@@ -2727,8 +2739,10 @@ static void update_cr8_intercept(struct
 	if (irr == -1)
 		return;
 
-	if (tpr >= irr)
+	if (tpr >= irr) {
 		svm->vmcb->control.intercept_cr_write |= INTERCEPT_CR8_MASK;
+		mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
+	}
 }
 
 static int svm_nmi_allowed(struct kvm_vcpu *vcpu)
@@ -2757,6 +2771,7 @@ static void svm_set_nmi_mask(struct kvm_
 		svm->vcpu.arch.hflags &= ~HF_NMI_MASK;
 		svm->vmcb->control.intercept &= ~(1UL << INTERCEPT_IRET);
 	}
+	mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 }
 
 static int svm_interrupt_allowed(struct kvm_vcpu *vcpu)
@@ -3153,6 +3168,7 @@ static void svm_fpu_deactivate(struct kv
 
 	update_cr0_intercept(svm);
 	svm->vmcb->control.intercept_exceptions |= 1 << NM_VECTOR;
+	mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 }
 
 static struct kvm_x86_ops svm_x86_ops = {
