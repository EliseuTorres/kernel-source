From: David Sterba <dsterba@suse.cz>
Date: Wed, 7 Dec 2011 16:52:42 +0100
Patch-mainline: pending
References: FATE#306586
Subject: [PATCH] btrfs: skip compression of very small extents

Experimentally found that for LZO:
1 - highly incompressible data - does not matter
2 - highly compressible data   - compression wins at < 32 bytes,
    ie. just header + some RLE/dictionary bytes
3 - textual data               - c. wins at ~220 bytes
4 - textual digits             - c. wins at ~128 bytes

for ZLIB:
1 - does not matter
2 - < 32
3 - between 64 and 128
4 - < 64

Should save pointless processing of probably incompressible data.
This idea comes from reiser4.

Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/inode.c |   36 +++++++++++++++++++++++++++++++++---
 1 files changed, 33 insertions(+), 3 deletions(-)

diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index c5ccec2..58a1f53 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -339,6 +339,7 @@ static noinline int compress_file_range(struct inode *inode,
 	unsigned long total_in = 0;
 	unsigned long max_compressed = 128 * 1024;
 	unsigned long max_uncompressed = 128 * 1024;
+	unsigned long min_compress_threshold;
 	int i;
 	int will_compress;
 	int compress_type = root->fs_info->compress_type;
@@ -394,15 +395,44 @@ again:
 	     (BTRFS_I(inode)->force_compress) ||
 	     (BTRFS_I(inode)->flags & BTRFS_INODE_COMPRESS))) {
 		WARN_ON(pages);
+
+		if (BTRFS_I(inode)->force_compress)
+			compress_type = BTRFS_I(inode)->force_compress;
+
+		/* experimentally found that for LZO:
+		 * 1 - highly incompressible data - does not matter
+		 * 2 - highly compressible data   - compression wins at < 32 bytes,
+		 *     ie. just header + some RLE/dictionary bytes
+		 * 3 - textual data               - c. wins at ~220 bytes
+		 * 4 - limited set of chars ~32   - c. wins at ~128 bytes
+		 *
+		 * for ZLIB:
+		 * 1 - does not matter
+		 * 2 - < 32
+		 * 3 - between 64 and 128
+		 * 4 - < 64
+		 *
+		 * Should save pointless processing of probably incompressible
+		 * data.
+		 */
+		switch (compress_type) {
+		case BTRFS_COMPRESS_LZO: min_compress_threshold = 256; break;
+		case BTRFS_COMPRESS_ZLIB: min_compress_threshold = 64; break;
+		default: min_compress_threshold = 0; break;
+		}
+
+		if (total_compressed < min_compress_threshold) {
+			trace_printk("btrfs: skip compression of %llu bytes\n",
+				(unsigned long long)total_compressed);
+			goto cont;
+		}
+
 		pages = kzalloc(sizeof(struct page *) * nr_pages, GFP_NOFS);
 		if (!pages) {
 			/* just bail out to the uncompressed code */
 			goto cont;
 		}
 
-		if (BTRFS_I(inode)->force_compress)
-			compress_type = BTRFS_I(inode)->force_compress;
-
 		ret = btrfs_compress_pages(compress_type,
 					   inode->i_mapping, start,
 					   total_compressed, pages,
-- 
1.7.7.3

