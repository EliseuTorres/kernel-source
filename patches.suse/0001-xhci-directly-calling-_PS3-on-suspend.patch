From 4c20edd1dbc1372d793d86b0240529222c758a2c Mon Sep 17 00:00:00 2001
From: Oliver Neukum <oneukum@suse.de>
Date: Wed, 14 Aug 2013 08:51:46 +0200
Subject: [PATCH] xhci: directly calling _PS3 on suspend
Git-Commit: 4c20edd1dbc1372d793d86b0240529222c758a2c
Patch-Mainline: Never (Generic solution in upstream)
References: bnc#833148

From external information:
I think the Linux auto wake up issue is caused by XHCI_BAR + 0x8154[31] setting.
On win7 OS, Intel XCHI driver will call _PS3 method under XHCI namespace to clear XHCI_BAR + 0x8154[31] before going to sleep state.
However, on Linux OS, Linux XHCI driver does not call OSC/PS0/PS3 method. This is problem.

Upstream this is solved by a generic PM system. Our kernel is too old.
We need to call directly.

Signed-off-by: Oliver Neukum <oneukum@suse.de>
---
 drivers/usb/host/xhci-pci.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index eed395a..317e901 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -22,6 +22,7 @@
 
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/acpi.h>
 
 #include "xhci.h"
 
@@ -219,6 +220,10 @@ static void xhci_pci_remove(struct pci_dev *dev)
 static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
+	struct pci_dev          *pdev = to_pci_dev(hcd->self.controller);
+	acpi_handle handle = DEVICE_ACPI_HANDLE(&pdev->dev);
+	acpi_status status;
+
 	int	retval = 0;
 
 	if (hcd->state != HC_STATE_SUSPENDED ||
@@ -226,6 +231,10 @@ static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 		return -EINVAL;
 
 	retval = xhci_suspend(xhci);
+	dev_printk(KERN_INFO, &pdev->dev, "%s try to enter PS3\n", __FUNCTION__);
+	status = acpi_bus_set_power(handle, ACPI_STATE_D3);
+	if (ACPI_FAILURE(status))
+	    dev_printk(KERN_ERR, &pdev->dev, "%s FAILED to enter PS3\n", __FUNCTION__);		
 
 	return retval;
 }
-- 
1.8.3.1

