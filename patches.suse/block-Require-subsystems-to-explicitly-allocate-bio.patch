From: Martin K. Petersen <martin.petersen@oracle.com>
Date: Thu, 17 Mar 2011 11:11:05 +0100
Subject: [PATCH] block: Require subsystems to explicitly allocate bio_set integrity mempool
X-Git: a91a2785b200864aef2270ed6a3babac7a253a20
References: FATE#311755
Patch-Mainline: 2.6.38

MD and DM create a new bio_set for every metadevice. Each bio_set has an
integrity mempool attached regardless of whether the metadevice is
capable of passing integrity metadata. This is a waste of memory.

Instead we defer the allocation decision to MD and DM since we know at
metadevice creation time whether integrity passthrough is needed or not.

Automatic integrity mempool allocation can then be removed from
bioset_create() and we make an explicit integrity allocation for the
fs_bio_set.

Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Reported-by: Zdenek Kabelac <zkabelac@redhat.com>
Acked-by: Mike Snitzer <snizer@redhat.com>
Signed-off-by: Jens Axboe <jaxboe@fusionio.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 fs/bio-integrity.c     |    3 +++
 fs/bio.c               |    6 +++---
 11 files changed, 41 insertions(+), 22 deletions(-)

diff --git a/fs/bio-integrity.c b/fs/bio-integrity.c
index 8209786..7e1099f 100644
--- a/fs/bio-integrity.c
+++ b/fs/bio-integrity.c
@@ -760,6 +760,9 @@ int bioset_integrity_create(struct bio_set *bs, int pool_size)
 {
 	unsigned int max_slab = vecs_to_idx(BIO_MAX_PAGES);
 
+	if (bs->bio_integrity_pool)
+		return 0;
+
 	bs->bio_integrity_pool =
 		mempool_create_slab_pool(pool_size, bip_slab[max_slab].slab);
 
diff --git a/fs/bio.c b/fs/bio.c
index 4c1a2e6..debb10e 100644
--- a/fs/bio.c
+++ b/fs/bio.c
@@ -1647,9 +1647,6 @@ struct bio_set *bioset_create(unsigned int pool_size, unsigned int front_pad)
 	if (!bs->bio_pool)
 		goto bad;
 
-	if (bioset_integrity_create(bs, pool_size))
-		goto bad;
-
 	if (!biovec_create_pools(bs, pool_size))
 		return bs;
 
@@ -1693,6 +1690,9 @@ static int __init init_bio(void)
 	if (!fs_bio_set)
 		panic("bio: can't allocate bios\n");
 
+	if (bioset_integrity_create(fs_bio_set, BIO_POOL_SIZE))
+		panic("bio: can't create integrity pool\n");
+
 	bio_split_pool = mempool_create_kmalloc_pool(BIO_SPLIT_ENTRIES,
 						     sizeof(struct bio_pair));
 	if (!bio_split_pool)

