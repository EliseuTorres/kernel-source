From: Christoph Hellwig <hch@lst.de>
Date: Thu, 21 Aug 2014 11:09:29 -0500
Subject: [PATCH] pnfs/blocklayout: correctly decrement extent length
Git-commit: 921b81a8cd5a4acc2a009778d13eedd377362c4c
Patch-mainline: v3.18
References: bnc#898675

When we do non-page sized reads we can underflow the extent_length variable
and read incorrect data.  Fix the extent_length calculation and change to
defensive <= checks for the extent length in the read and write path.

Signed-off-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/nfs/blocklayout/blocklayout.c |    7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

--- linux-3.12-SLE12.orig/fs/nfs/blocklayout/blocklayout.c
+++ linux-3.12-SLE12/fs/nfs/blocklayout/blocklayout.c
@@ -275,7 +275,7 @@ bl_read_pagelist(struct nfs_read_data *r
 	isect = (sector_t) (f_offset >> SECTOR_SHIFT);
 	/* Code assumes extents are page-aligned */
 	for (i = pg_index; i < rdata->pages.npages; i++) {
-		if (!extent_length) {
+		if (extent_length <= 0) {
 			/* We've used up the previous extent */
 			bl_put_extent(be);
 			bl_put_extent(cow_read);
@@ -306,6 +306,7 @@ bl_read_pagelist(struct nfs_read_data *r
 			f_offset += pg_len;
 			bytes_left -= pg_len;
 			isect += (pg_offset >> SECTOR_SHIFT);
+			extent_length -= (pg_offset >> SECTOR_SHIFT);
 		} else {
 			pg_offset = 0;
 			pg_len = PAGE_CACHE_SIZE;
@@ -335,7 +336,7 @@ bl_read_pagelist(struct nfs_read_data *r
 			}
 		}
 		isect += (pg_len >> SECTOR_SHIFT);
-		extent_length -= PAGE_CACHE_SECTORS;
+		extent_length -= (pg_len >> SECTOR_SHIFT);
 	}
 	if ((isect << SECTOR_SHIFT) >= header->inode->i_size) {
 		rdata->res.eof = 1;
@@ -806,7 +807,7 @@ next_page:
 	/* Middle pages */
 	pg_index = wdata->args.pgbase >> PAGE_CACHE_SHIFT;
 	for (i = pg_index; i < wdata->pages.npages; i++) {
-		if (!extent_length) {
+		if (extent_length <= 0) {
 			/* We've used up the previous extent */
 			bl_put_extent(be);
 			bl_put_extent(cow_read);
