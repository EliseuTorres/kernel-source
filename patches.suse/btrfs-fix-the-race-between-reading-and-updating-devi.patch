From: Xiao Guangrong <xiaoguangrong@cn.fujitsu.com>
Date: Wed, 20 Apr 2011 10:07:30 +0000
Patch-mainline: yes
References: FATE#306586
Subject: [PATCH] Btrfs: fix the race between reading and updating
 devices

On btrfs_congested_fn and __unplug_io_fn paths, we should hold
device_list_mutex to avoid remove/add device path to
update fs_devices->devices

On __btrfs_close_devices and btrfs_prepare_sprout paths, the devices in
fs_devices->devices or fs_devices->devices is updated, so we should hold
the mutex to avoid the reader side to reach them

Signed-off-by: Xiao Guangrong <xiaoguangrong@cn.fujitsu.com>
Signed-off-by: Chris Mason <chris.mason@oracle.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/disk-io.c |    2 ++
 fs/btrfs/volumes.c |    7 +++++++
 2 files changed, 9 insertions(+)

Index: linux-2.6.32-SLE11-SP2/fs/btrfs/disk-io.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/disk-io.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/disk-io.c
@@ -1372,6 +1372,7 @@ static int btrfs_congested_fn(void *cong
 	struct btrfs_device *device;
 	struct backing_dev_info *bdi;
 
+	mutex_lock(&info->fs_devices->device_list_mutex);
 	list_for_each_entry(device, &info->fs_devices->devices, dev_list) {
 		if (!device->bdev)
 			continue;
@@ -1381,6 +1382,7 @@ static int btrfs_congested_fn(void *cong
 			break;
 		}
 	}
+	mutex_unlock(&info->fs_devices->device_list_mutex);
 	return ret;
 }
 
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/volumes.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/volumes.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/volumes.c
@@ -501,6 +501,7 @@ static int __btrfs_close_devices(struct
 	if (--fs_devices->opened > 0)
 		return 0;
 
+	mutex_lock(&fs_devices->device_list_mutex);
 	list_for_each_entry(device, &fs_devices->devices, dev_list) {
 		if (device->bdev) {
 			close_bdev_exclusive(device->bdev, device->mode);
@@ -515,6 +516,8 @@ static int __btrfs_close_devices(struct
 		device->writeable = 0;
 		device->in_fs_metadata = 0;
 	}
+	mutex_unlock(&fs_devices->device_list_mutex);
+
 	WARN_ON(fs_devices->open_devices);
 	WARN_ON(fs_devices->rw_devices);
 	fs_devices->opened = 0;
@@ -1430,7 +1433,11 @@ static int btrfs_prepare_sprout(struct b
 	INIT_LIST_HEAD(&seed_devices->devices);
 	INIT_LIST_HEAD(&seed_devices->alloc_list);
 	mutex_init(&seed_devices->device_list_mutex);
+
+	mutex_lock(&root->fs_info->fs_devices->device_list_mutex);
 	list_splice_init(&fs_devices->devices, &seed_devices->devices);
+	mutex_unlock(&root->fs_info->fs_devices->device_list_mutex);
+
 	list_splice_init(&fs_devices->alloc_list, &seed_devices->alloc_list);
 	list_for_each_entry(device, &seed_devices->devices, dev_list) {
 		device->fs_devices = seed_devices;
