From 16dc0cb4eacab5c4d603e92942d15c985b4330f1 Mon Sep 17 00:00:00 2001
From: Ilya Dryomov <idryomov@gmail.com>
Date: Wed, 12 Oct 2011 10:09:42 +0300
Patch-mainline: pending
References: FATE#306586
Subject: [PATCH] Btrfs: save restripe parameters to disk

Introduce a new btree objectid for storing restripe item.  The reason is
to be able to resume restriper after a crash with the same parameters.
Restripe item has a very high objectid and goes into tree of tree roots.

The key for the new item is as follows:

    [ BTRFS_RESTRIPE_OBJECTID ; BTRFS_RESTRIPE_ITEM_KEY ; 0 ]

Older kernels simply ignore it so it's safe to mount with an older
kernel and then go back to the newer one.

Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/ctree.h   |  129 +++++++++++++++++++++++++++++++++++++++++++++++++++-
 fs/btrfs/volumes.c |  105 +++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 230 insertions(+), 4 deletions(-)

diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index 5c570db..446c7e1 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -86,6 +86,9 @@ struct btrfs_ordered_sum;
 /* holds checksums of all the data extents */
 #define BTRFS_CSUM_TREE_OBJECTID 7ULL
 
+/* for storing restripe params in the root tree */
+#define BTRFS_RESTRIPE_OBJECTID -4ULL
+
 /* orhpan objectid for tracking unlinked/truncated files */
 #define BTRFS_ORPHAN_OBJECTID -5ULL
 
@@ -692,6 +695,47 @@ struct btrfs_root_ref {
 	__le16 name_len;
 } __attribute__ ((__packed__));
 
+/*
+ * Restriper stuff
+ */
+struct btrfs_disk_restripe_args {
+	/* profiles to touch, in-memory format */
+	__le64 profiles;
+
+	/* usage filter */
+	__le64 usage;
+
+	/* devid filter */
+	__le64 devid;
+
+	/* devid subset filter [pstart..pend) */
+	__le64 pstart;
+	__le64 pend;
+
+	/* btrfs virtual address space subset filter [vstart..vend) */
+	__le64 vstart;
+	__le64 vend;
+
+	/* profile to convert to, in-memory format */
+	__le64 target;
+
+	/* BTRFS_RESTRIPE_ARGS_* */
+	__le64 flags;
+
+	__le64 unused[8];
+} __attribute__ ((__packed__));
+
+struct btrfs_restripe_item {
+	/* BTRFS_RESTRIPE_* */
+	__le64 flags;
+
+	struct btrfs_disk_restripe_args data;
+	struct btrfs_disk_restripe_args sys;
+	struct btrfs_disk_restripe_args meta;
+
+	__le64 unused[4];
+} __attribute__ ((__packed__));
+
 #define BTRFS_FILE_EXTENT_INLINE 0
 #define BTRFS_FILE_EXTENT_REG 1
 #define BTRFS_FILE_EXTENT_PREALLOC 2
@@ -770,7 +814,8 @@ struct btrfs_csum_item {
 					 BTRFS_BLOCK_GROUP_RAID10)
 /*
  * We need a bit for restriper to be able to tell when chunks of type
- * SINGLE are available.  It is used in avail_*_alloc_bits.
+ * SINGLE are available.  It is used in avail_*_alloc_bits and restripe
+ * item fields.
  */
 #define BTRFS_AVAIL_ALLOC_BIT_SINGLE (1 << 7)
 
@@ -1404,6 +1449,8 @@ struct btrfs_ioctl_defrag_range_args {
 #define BTRFS_DEV_ITEM_KEY	216
 #define BTRFS_CHUNK_ITEM_KEY	228
 
+#define BTRFS_RESTRIPE_ITEM_KEY	248
+
 /*
  * string items are for debugging.  They just store a short string of
  * data in the FS
@@ -2098,8 +2145,86 @@ BTRFS_SETGET_STACK_FUNCS(backup_bytes_used, struct btrfs_root_backup,
 BTRFS_SETGET_STACK_FUNCS(backup_num_devices, struct btrfs_root_backup,
 		   num_devices, 64);
 
-/* struct btrfs_super_block */
+/* struct btrfs_restripe_item */
+BTRFS_SETGET_FUNCS(restripe_flags, struct btrfs_restripe_item, flags, 64);
+
+static inline void btrfs_restripe_data(struct extent_buffer *eb,
+				       struct btrfs_restripe_item *ri,
+				       struct btrfs_disk_restripe_args *ra)
+{
+	read_eb_member(eb, ri, struct btrfs_restripe_item, data, ra);
+}
 
+static inline void btrfs_set_restripe_data(struct extent_buffer *eb,
+					   struct btrfs_restripe_item *ri,
+					   struct btrfs_disk_restripe_args *ra)
+{
+	write_eb_member(eb, ri, struct btrfs_restripe_item, data, ra);
+}
+
+static inline void btrfs_restripe_meta(struct extent_buffer *eb,
+				       struct btrfs_restripe_item *ri,
+				       struct btrfs_disk_restripe_args *ra)
+{
+	read_eb_member(eb, ri, struct btrfs_restripe_item, meta, ra);
+}
+
+static inline void btrfs_set_restripe_meta(struct extent_buffer *eb,
+					   struct btrfs_restripe_item *ri,
+					   struct btrfs_disk_restripe_args *ra)
+{
+	write_eb_member(eb, ri, struct btrfs_restripe_item, meta, ra);
+}
+
+static inline void btrfs_restripe_sys(struct extent_buffer *eb,
+				      struct btrfs_restripe_item *ri,
+				      struct btrfs_disk_restripe_args *ra)
+{
+	read_eb_member(eb, ri, struct btrfs_restripe_item, sys, ra);
+}
+
+static inline void btrfs_set_restripe_sys(struct extent_buffer *eb,
+					  struct btrfs_restripe_item *ri,
+					  struct btrfs_disk_restripe_args *ra)
+{
+	write_eb_member(eb, ri, struct btrfs_restripe_item, sys, ra);
+}
+
+static inline void
+btrfs_disk_restripe_args_to_cpu(struct btrfs_restripe_args *cpu,
+				struct btrfs_disk_restripe_args *disk)
+{
+	memset(cpu, 0, sizeof(*cpu));
+
+	cpu->profiles = le64_to_cpu(disk->profiles);
+	cpu->usage = le64_to_cpu(disk->usage);
+	cpu->devid = le64_to_cpu(disk->devid);
+	cpu->pstart = le64_to_cpu(disk->pstart);
+	cpu->pend = le64_to_cpu(disk->pend);
+	cpu->vstart = le64_to_cpu(disk->vstart);
+	cpu->vend = le64_to_cpu(disk->vend);
+	cpu->target = le64_to_cpu(disk->target);
+	cpu->flags = le64_to_cpu(disk->flags);
+}
+
+static inline void
+btrfs_cpu_restripe_args_to_disk(struct btrfs_disk_restripe_args *disk,
+				struct btrfs_restripe_args *cpu)
+{
+	memset(disk, 0, sizeof(*disk));
+
+	disk->profiles = cpu_to_le64(cpu->profiles);
+	disk->usage = cpu_to_le64(cpu->usage);
+	disk->devid = cpu_to_le64(cpu->devid);
+	disk->pstart = cpu_to_le64(cpu->pstart);
+	disk->pend = cpu_to_le64(cpu->pend);
+	disk->vstart = cpu_to_le64(cpu->vstart);
+	disk->vend = cpu_to_le64(cpu->vend);
+	disk->target = cpu_to_le64(cpu->target);
+	disk->flags = cpu_to_le64(cpu->flags);
+}
+
+/* struct btrfs_super_block */
 BTRFS_SETGET_STACK_FUNCS(super_bytenr, struct btrfs_super_block, bytenr, 64);
 BTRFS_SETGET_STACK_FUNCS(super_flags, struct btrfs_super_block, flags, 64);
 BTRFS_SETGET_STACK_FUNCS(super_generation, struct btrfs_super_block,
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 38b8bfa..5bbd063 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -2173,6 +2173,97 @@ error:
 	return ret;
 }
 
+static int insert_restripe_item(struct btrfs_root *root,
+				struct restripe_control *rctl)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_restripe_item *item;
+	struct btrfs_disk_restripe_args disk_rargs;
+	struct btrfs_path *path;
+	struct extent_buffer *leaf;
+	struct btrfs_key key;
+	int ret, err;
+
+	path = btrfs_alloc_path();
+	if (!path)
+		return -ENOMEM;
+
+	trans = btrfs_start_transaction(root, 0);
+	if (IS_ERR(trans)) {
+		btrfs_free_path(path);
+		return PTR_ERR(trans);
+	}
+
+	key.objectid = BTRFS_RESTRIPE_OBJECTID;
+	key.type = BTRFS_RESTRIPE_ITEM_KEY;
+	key.offset = 0;
+
+	ret = btrfs_insert_empty_item(trans, root, path, &key,
+				      sizeof(*item));
+	if (ret)
+		goto out;
+
+	leaf = path->nodes[0];
+	item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_restripe_item);
+
+	memset_extent_buffer(leaf, 0, (unsigned long)item, sizeof(*item));
+
+	btrfs_cpu_restripe_args_to_disk(&disk_rargs, &rctl->data);
+	btrfs_set_restripe_data(leaf, item, &disk_rargs);
+	btrfs_cpu_restripe_args_to_disk(&disk_rargs, &rctl->meta);
+	btrfs_set_restripe_meta(leaf, item, &disk_rargs);
+	btrfs_cpu_restripe_args_to_disk(&disk_rargs, &rctl->sys);
+	btrfs_set_restripe_sys(leaf, item, &disk_rargs);
+
+	btrfs_set_restripe_flags(leaf, item, rctl->flags);
+
+	btrfs_mark_buffer_dirty(leaf);
+out:
+	btrfs_free_path(path);
+	err = btrfs_commit_transaction(trans, root);
+	if (err && !ret)
+		ret = err;
+	return ret;
+}
+
+static int del_restripe_item(struct btrfs_root *root)
+{
+	struct btrfs_trans_handle *trans;
+	struct btrfs_path *path;
+	struct btrfs_key key;
+	int ret, err;
+
+	path = btrfs_alloc_path();
+	if (!path)
+		return -ENOMEM;
+
+	trans = btrfs_start_transaction(root, 0);
+	if (IS_ERR(trans)) {
+		btrfs_free_path(path);
+		return PTR_ERR(trans);
+	}
+
+	key.objectid = BTRFS_RESTRIPE_OBJECTID;
+	key.type = BTRFS_RESTRIPE_ITEM_KEY;
+	key.offset = 0;
+
+	ret = btrfs_search_slot(trans, root, &key, path, -1, 1);
+	if (ret < 0)
+		goto out;
+	if (ret > 0) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	ret = btrfs_del_item(trans, root, path);
+out:
+	btrfs_free_path(path);
+	err = btrfs_commit_transaction(trans, root);
+	if (err && !ret)
+		ret = err;
+	return ret;
+}
+
 /*
  * Should be called with both restripe and volume mutexes held to
  * serialize other volume operations (add_dev/rm_dev/resize) wrt
@@ -2508,6 +2599,7 @@ int btrfs_restripe(struct restripe_control *rctl)
 {
 	struct btrfs_fs_info *fs_info = rctl->fs_info;
 	u64 allowed;
+	int err;
 	int ret;
 
 	mutex_lock(&fs_info->volume_mutex);
@@ -2595,16 +2687,25 @@ int btrfs_restripe(struct restripe_control *rctl)
 	}
 
 do_restripe:
+	ret = insert_restripe_item(fs_info->tree_root, rctl);
+	if (ret && ret != -EEXIST)
+		goto out;
+	BUG_ON(ret == -EEXIST);
+
 	set_restripe_control(rctl);
 	mutex_unlock(&fs_info->volume_mutex);
 
-	ret = __btrfs_restripe(fs_info->dev_root);
+	err = __btrfs_restripe(fs_info->dev_root);
 
 	mutex_lock(&fs_info->volume_mutex);
+
 	unset_restripe_control(fs_info);
+	ret = del_restripe_item(fs_info->tree_root);
+	BUG_ON(ret);
+
 	mutex_unlock(&fs_info->volume_mutex);
 
-	return ret;
+	return err;
 
 out:
 	mutex_unlock(&fs_info->volume_mutex);
-- 
1.7.6.233.gd79bc

