From a8ec8fa1c6182e85b1c88eb903a6a37084821825 Mon Sep 17 00:00:00 2001
From: Ilya Dryomov <idryomov@gmail.com>
Date: Wed, 12 Oct 2011 10:09:43 +0300
Patch-mainline: pending
References: FATE#306586
Subject: [PATCH] Btrfs: add restripe progress reporting

Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/ioctl.c   |   45 +++++++++++++++++++++++++++++++++++++++++++++
 fs/btrfs/ioctl.h   |    2 ++
 fs/btrfs/volumes.c |   40 ++++++++++++++++++++++++++++++++++------
 fs/btrfs/volumes.h |    3 +++
 4 files changed, 84 insertions(+), 6 deletions(-)

--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -3230,6 +3230,49 @@ static long btrfs_ioctl_restripe_ctl(str
 	return -EINVAL;
 }
 
+static long btrfs_ioctl_restripe_progress(struct btrfs_root *root,
+					  void __user *arg)
+{
+	struct btrfs_fs_info *fs_info = root->fs_info;
+	struct btrfs_ioctl_restripe_args *rargs;
+	struct restripe_control *rctl;
+	int ret = 0;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	mutex_lock(&fs_info->restripe_mutex);
+	if (!(rctl = fs_info->restripe_ctl)) {
+		ret = -ENOTCONN;
+		goto out;
+	}
+
+	rargs = kzalloc(sizeof(*rargs), GFP_NOFS);
+	if (!rargs) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	rargs->flags = rctl->flags;
+	rargs->state = fs_info->restripe_state;
+
+	memcpy(&rargs->data, &rctl->data, sizeof(rargs->data));
+	memcpy(&rargs->sys, &rctl->sys, sizeof(rargs->sys));
+	memcpy(&rargs->meta, &rctl->meta, sizeof(rargs->meta));
+
+	spin_lock(&fs_info->restripe_lock);
+	memcpy(&rargs->stat, &rctl->stat, sizeof(rargs->stat));
+	spin_unlock(&fs_info->restripe_lock);
+
+	if (copy_to_user(arg, rargs, sizeof(*rargs)))
+		ret = -EFAULT;
+
+	kfree(rargs);
+out:
+	mutex_unlock(&fs_info->restripe_mutex);
+	return ret;
+}
+
 long btrfs_ioctl(struct file *file, unsigned int
 		cmd, unsigned long arg)
 {
@@ -3279,6 +3322,8 @@ long btrfs_ioctl(struct file *file, unsi
  		return btrfs_ioctl_restripe(root, argp);
 	case BTRFS_IOC_RESTRIPE_CTL:
 		return btrfs_ioctl_restripe_ctl(root, arg);
+	case BTRFS_IOC_RESTRIPE_PROGRESS:
+		return btrfs_ioctl_restripe_progress(root, argp);
 	case BTRFS_IOC_CLONE:
 		return btrfs_ioctl_clone(file, arg, 0, 0, 0);
 	case BTRFS_IOC_CLONE_RANGE:
--- a/fs/btrfs/ioctl.h
+++ b/fs/btrfs/ioctl.h
@@ -318,6 +318,8 @@ struct btrfs_ioctl_logical_ino_args {
 #define BTRFS_IOC_RESTRIPE _IOW(BTRFS_IOCTL_MAGIC, 32, \
 				struct btrfs_ioctl_restripe_args)
 #define BTRFS_IOC_RESTRIPE_CTL _IOW(BTRFS_IOCTL_MAGIC, 33, int)
+#define BTRFS_IOC_RESTRIPE_PROGRESS _IOR(BTRFS_IOCTL_MAGIC, 34, \
+				struct btrfs_ioctl_restripe_args)
 #define BTRFS_IOC_INO_PATHS _IOWR(BTRFS_IOCTL_MAGIC, 35, \
 					struct btrfs_ioctl_ino_path_args)
 #define BTRFS_IOC_LOGICAL_INO _IOWR(BTRFS_IOCTL_MAGIC, 36, \
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -2210,8 +2210,10 @@ static void set_restripe_control(struct
 
 	spin_lock(&fs_info->restripe_lock);
 	fs_info->restripe_ctl = rctl;
-	if (update)
+	if (update) {
 		update_restripe_args(rctl);
+		memset(&rctl->stat, 0, sizeof(rctl->stat));
+	}
 	spin_unlock(&fs_info->restripe_lock);
 }
 
@@ -2442,6 +2444,7 @@ static int __btrfs_restripe(struct btrfs
 	int slot;
 	int ret;
 	int enospc_errors = 0;
+	bool counting_only = true;
 
 	/* step one make some room on all the devices */
 	devices = &dev_root->fs_info->fs_devices->devices;
@@ -2474,12 +2477,14 @@ static int __btrfs_restripe(struct btrfs
 		goto error;
 	}
 
+again:
 	key.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;
 	key.offset = (u64)-1;
 	key.type = BTRFS_CHUNK_ITEM_KEY;
 
 	while (1) {
 		struct btrfs_fs_info *fs_info = dev_root->fs_info;
+		struct restripe_control *rctl = fs_info->restripe_ctl;
 
 		if (test_bit(RESTRIPE_CANCEL_REQ, &fs_info->restripe_state) ||
 		    test_bit(RESTRIPE_PAUSE_REQ, &fs_info->restripe_state)) {
@@ -2516,25 +2521,48 @@ static int __btrfs_restripe(struct btrfs
 
 		chunk = btrfs_item_ptr(leaf, slot, struct btrfs_chunk);
 
-		if (!should_restripe_chunk(chunk_root, leaf, chunk,
-					   found_key.offset)) {
-			btrfs_release_path(path);
-			goto loop;
+		if (!counting_only) {
+			spin_lock(&fs_info->restripe_lock);
+			rctl->stat.considered++;
+			spin_unlock(&fs_info->restripe_lock);
 		}
 
+		ret = should_restripe_chunk(chunk_root, leaf, chunk,
+					    found_key.offset);
 		btrfs_release_path(path);
+		if (!ret)
+			goto loop;
+
+		if (counting_only) {
+			spin_lock(&fs_info->restripe_lock);
+			rctl->stat.expected++;
+			spin_unlock(&fs_info->restripe_lock);
+			goto loop;
+		}
+
 		ret = btrfs_relocate_chunk(chunk_root,
 					   chunk_root->root_key.objectid,
 					   found_key.objectid,
 					   found_key.offset);
 		if (ret && ret != -ENOSPC)
 			goto error;
-		if (ret == -ENOSPC)
+		if (ret == -ENOSPC) {
 			enospc_errors++;
+		} else {
+			spin_lock(&fs_info->restripe_lock);
+			rctl->stat.completed++;
+			spin_unlock(&fs_info->restripe_lock);
+		}
 loop:
 		key.offset = found_key.offset - 1;
 	}
 
+	if (counting_only) {
+		btrfs_release_path(path);
+		counting_only = false;
+		goto again;
+	}
+
 error:
 	btrfs_free_path(path);
 	if (enospc_errors) {
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -225,6 +225,7 @@ struct map_lookup {
 #define RESTRIPE_PAUSE_REQ	2
 
 struct btrfs_restripe_args;
+struct btrfs_restripe_progress;
 struct restripe_control {
 	struct btrfs_fs_info *fs_info;
 	u64 flags;
@@ -232,6 +233,8 @@ struct restripe_control {
 	struct btrfs_restripe_args data;
 	struct btrfs_restripe_args sys;
 	struct btrfs_restripe_args meta;
+
+	struct btrfs_restripe_progress stat;
 };
 
 int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
