Subject: sched: Kill WAKEUP_PREEMPT
From: Yong Zhang <yong.zhang0@gmail.com>
Date: Fri, 29 Jul 2011 16:20:33 +0800
Git-commit: 2c2efaed9bc973e3aeab1385c618017b56c8f6d7
Patch-mainline: not yet

Remove the WAKEUP_PREEMPT feature, disabling it doesn't make any sense
and its outlived its use by a long long while.

Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
Acked-by: Mike Galbraith <efault@gmx.de>
Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/20110729082033.GB12106@zhy
Signed-off-by: Ingo Molnar <mingo@elte.hu>
Acked-by: Mike Galbraith <mgalbraith@suse.de>

---
 kernel/sched_fair.c     |    9 +--------
 kernel/sched_features.h |    5 -----
 2 files changed, 1 insertion(+), 13 deletions(-)

Index: linux-3.0-SLE11-SP2-3.0/kernel/sched_fair.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/kernel/sched_fair.c
+++ linux-3.0-SLE11-SP2-3.0/kernel/sched_fair.c
@@ -1095,9 +1095,6 @@ check_preempt_tick(struct cfs_rq *cfs_rq
 	 * narrow margin doesn't have to wait for a full slice.
 	 * This also mitigates buddy induced latencies under load.
 	 */
-	if (!sched_feat(WAKEUP_PREEMPT))
-		return;
-
 	if (delta_exec < sysctl_sched_min_granularity)
 		return;
 
@@ -1233,7 +1230,7 @@ entity_tick(struct cfs_rq *cfs_rq, struc
 		return;
 #endif
 
-	if (cfs_rq->nr_running > 1 || !sched_feat(WAKEUP_PREEMPT))
+	if (cfs_rq->nr_running > 1)
 		check_preempt_tick(cfs_rq, curr);
 }
 
@@ -1901,10 +1898,6 @@ static void check_preempt_wakeup(struct
 	if (unlikely(p->policy != SCHED_NORMAL))
 		return;
 
-
-	if (!sched_feat(WAKEUP_PREEMPT))
-		return;
-
 	find_matching_se(&se, &pse);
 	update_curr(cfs_rq_of(se));
 	BUG_ON(!pse);
Index: linux-3.0-SLE11-SP2-3.0/kernel/sched_features.h
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/kernel/sched_features.h
+++ linux-3.0-SLE11-SP2-3.0/kernel/sched_features.h
@@ -12,11 +12,6 @@ SCHED_FEAT(GENTLE_FAIR_SLEEPERS, 1)
 SCHED_FEAT(START_DEBIT, 1)
 
 /*
- * Should wakeups try to preempt running tasks.
- */
-SCHED_FEAT(WAKEUP_PREEMPT, 1)
-
-/*
  * Based on load and program behaviour, see if it makes sense to place
  * a newly woken task on the same cpu as the task that woke it --
  * improve cache locality. Typically used with SYNC wakeups as
