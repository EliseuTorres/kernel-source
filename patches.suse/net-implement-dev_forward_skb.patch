From: Jiri Bohac <jbohac@suse.cz>
Subject: net: implement dev_forward_skb()
Git-commit: 445409602c09219767c06497c0dc2285eac244ed
Git-commit: 79b569f0ec53a14c4d71e79d93a8676d9a0fda6d
Git-commit: c736eefadb71a01a5e61e0de700f28f6952b4444
References: fate#311478
Patch-mainline: v2.6.33-rc1

Backported implementation of dev_forward_skb() needed by macvlan bridging.
Includes only parts of all the above patches that implement/fix
dev_forward_skb().


 include/linux/netdevice.h |    3 +-
 net/core/dev.c            |   56 ++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 58 insertions(+), 1 deletion(-)

diff --git a/net/core/dev.c b/net/core/dev.c
index f40fada..4acb456 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -2142,6 +2142,62 @@ static void net_tx_action(struct softirq_action *h)
 	}
 }
 
+static inline bool is_skb_forwardable(struct net_device *dev,
+				      struct sk_buff *skb)
+{
+	unsigned int len;
+
+	if (!(dev->flags & IFF_UP))
+		return false;
+
+	len = dev->mtu + dev->hard_header_len + VLAN_HLEN;
+	if (skb->len <= len)
+		return true;
+
+	/* if TSO is enabled, we don't care about the length as the packet
+	 * could be forwarded without being segmented before
+	 */
+	if (skb_is_gso(skb))
+		return true;
+
+	return false;
+}
+
+/**
+ * dev_forward_skb - loopback an skb to another netif
+ *
+ * @dev: destination network device
+ * @skb: buffer to forward
+ *
+ * return values:
+ *	NET_RX_SUCCESS	(no congestion)
+ *	NET_RX_DROP     (packet was dropped, but freed)
+ *
+ * dev_forward_skb can be used for injecting an skb from the
+ * start_xmit function of one device into the receive queue
+ * of another device.
+ *
+ * The receiving device may be in another namespace, so
+ * we have to clear all information in the skb that could
+ * impact namespace isolation.
+ */
+int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)
+{
+	skb_orphan(skb);
+	nf_reset(skb);
+
+	if (unlikely(!is_skb_forwardable(dev, skb))) {
+		kfree_skb(skb);
+		return NET_RX_DROP;
+	}
+	skb->dev = dev;
+	skb->tstamp.tv64 = 0;
+	skb->pkt_type = PACKET_HOST;
+	skb->protocol = eth_type_trans(skb, dev);
+	return netif_rx(skb);
+}
+EXPORT_SYMBOL_GPL(dev_forward_skb);
+
 static inline int deliver_skb(struct sk_buff *skb,
 			      struct packet_type *pt_prev,
 			      struct net_device *orig_dev)
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index a4b7d99..3affbd4 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1509,7 +1509,8 @@ extern int		dev_set_mac_address(struct net_device *,
 extern int		dev_hard_start_xmit(struct sk_buff *skb,
 					    struct net_device *dev,
 					    struct netdev_queue *txq);
-
+extern int		dev_forward_skb(struct net_device *dev,
+					struct sk_buff *skb);
 extern int		netdev_budget;
 
 /* Called by rtnetlink.c:rtnl_unlock() */
