From: Jeff Mahoney <jeffm@suse.com>
Subject: XFS/DMAPI: Update to 3.0 API
Patch-mainline: Depends on DMAPI

 - address_space->i_mmap_lock has been replaced with a mutex.
 - xfs_trans_ijoin no longer takes a lock argument
 - An additional reference does not need to be taken before starting
   a transaction
 - KM_LARGE was removed (was a no-op before)
 - Re-introduce xfs_fsync

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/xfs/dmapi/xfs_dm.c        |   33 ++++++++++++++++++---------------
 fs/xfs/linux-2.6/xfs_file.c  |   21 ++++++++++++++++++---
 fs/xfs/linux-2.6/xfs_ksyms.c |    4 ----
 fs/xfs/xfs_vnodeops.h        |    1 +
 4 files changed, 37 insertions(+), 22 deletions(-)

--- a/fs/xfs/dmapi/xfs_dm.c
+++ b/fs/xfs/dmapi/xfs_dm.c
@@ -48,6 +48,7 @@
 #include "xfs_vnodeops.h"
 #include <dmapi.h>
 #include <dmapi_kern.h>
+#include "xfs_trace.h"
 #include "xfs_dm.h"
 
 #include <linux/mount.h>
@@ -184,10 +185,10 @@ prohibited_mr_events(
 	if (!mapping_mapped(mapping))
 		return 0;
 
-	spin_lock(&mapping->i_mmap_lock);
+	mutex_lock(&mapping->i_mmap_mutex);
 	if (mapping_writably_mapped(mapping))
 		prohibited |= (1 << DM_EVENT_WRITE);
-	spin_unlock(&mapping->i_mmap_lock);
+	mutex_unlock(&mapping->i_mmap_mutex);
 
 	return prohibited;
 }
@@ -556,7 +557,8 @@ xfs_dm_bulkattr_iget_one(
 	dm_ip_to_handle(&ip->i_vnode, &handle);
 	xfs_dm_handle_to_stat(sbuf, stat_sz, &handle, sizeof(handle));
 
-	xfs_iput(ip, XFS_ILOCK_SHARED);
+	xfs_iunlock(ip, XFS_ILOCK_SHARED);
+	IRELE(ip);
 	return 0;
 }
 
@@ -703,12 +705,12 @@ xfs_dm_f_set_eventlist(
 		return(error);
 	}
 	xfs_ilock(ip, XFS_ILOCK_EXCL);
-	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+	xfs_trans_ijoin(tp, ip);
 
 	ip->i_d.di_dmevmask = (eventset & max_mask) | (ip->i_d.di_dmevmask & ~max_mask);
 
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
-	igrab(&ip->i_vnode);
+//	igrab(&ip->i_vnode);
 	xfs_trans_commit(tp, 0);
 
 	return(0);
@@ -1037,7 +1039,7 @@ xfs_dm_get_allocinfo_rvp(
 		lock = xfs_ilock_map_shared(ip);
 
 		error = xfs_bmapi(NULL, ip, fsb_offset, fsb_length,
-			XFS_BMAPI_ENTIRE, NULL, 0, bmp, &num, NULL, NULL);
+			XFS_BMAPI_ENTIRE, NULL, 0, bmp, &num, NULL);
 
 		xfs_iunlock_map_shared(ip, lock);
 		xfs_iunlock(ip, XFS_IOLOCK_SHARED);
@@ -1720,7 +1722,7 @@ xfs_dm_get_dmattr(
 		alloc_size = XFS_BUG_KLUDGE;
 	if (alloc_size > ATTR_MAX_VALUELEN)
 		alloc_size = ATTR_MAX_VALUELEN;
-	value = kmem_alloc(alloc_size, KM_SLEEP | KM_LARGE);
+	value = kmem_alloc(alloc_size, KM_SLEEP);
 
 	/* Get the attribute's value. */
 
@@ -2584,12 +2586,12 @@ xfs_dm_set_region(
 		return(-error); /* Return negative error to DMAPI */
 	}
 	xfs_ilock(ip, XFS_ILOCK_EXCL);
-	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+	xfs_trans_ijoin(tp, ip);
 
 	ip->i_d.di_dmevmask = (ip->i_d.di_dmevmask & ~mr_mask) | new_mask;
 
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
-	igrab(inode);
+//	igrab(inode);
 	xfs_trans_commit(tp, 0);
 
 	/* Return the proper value for *exactflagp depending upon whether or not
@@ -2641,7 +2643,7 @@ xfs_dm_sync_by_handle(
 	/* We need to protect against concurrent writers.. */
 	ret = filemap_fdatawrite(inode->i_mapping);
 	down_rw_sems(inode, DM_FLAGS_IMUX);
-	err = -xfs_fsync(ip);
+	err = -xfs_fsync(ip, 0);
 	if (!ret)
 		ret = err;
 	up_rw_sems(inode, DM_FLAGS_IMUX);
@@ -2916,12 +2918,12 @@ STATIC int
 xfs_dm_send_namesp_event(
 	dm_eventtype_t	event,
 	struct xfs_mount *mp,
-	xfs_inode_t	*ip1,
+	struct xfs_inode *ip1,
 	dm_right_t	vp1_right,
-	xfs_inode_t	*ip2,
+	struct xfs_inode *ip2,
 	dm_right_t	vp2_right,
-	const char	*name1,
-	const char	*name2,
+	const unsigned char	*name1,
+	const unsigned char	*name2,
 	mode_t		mode,
 	int		retcode,
 	int		flags)
@@ -3015,7 +3017,8 @@ xfs_dm_fh_to_inode(
 		return -EIO;
 
 	if (!ip->i_d.di_mode || ip->i_d.di_gen != igen) {
-		xfs_iput_new(ip, XFS_ILOCK_SHARED);
+		xfs_iunlock(ip, XFS_ILOCK_SHARED);
+		IRELE(ip);
 		return -ENOENT;
 	}
 
--- a/fs/xfs/linux-2.6/xfs_file.c
+++ b/fs/xfs/linux-2.6/xfs_file.c
@@ -129,13 +129,12 @@ xfs_iozero(
 }
 
 STATIC int
-xfs_file_fsync(
-	struct file		*file,
+__xfs_fsync(
+	struct inode		*inode,
 	loff_t			start,
 	loff_t			end,
 	int			datasync)
 {
-	struct inode		*inode = file->f_mapping->host;
 	struct xfs_inode	*ip = XFS_I(inode);
 	struct xfs_mount	*mp = ip->i_mount;
 	struct xfs_trans	*tp;
@@ -257,6 +256,22 @@ xfs_file_fsync(
 	return -error;
 }
 
+STATIC int
+xfs_file_fsync(
+	struct file		*file,
+	loff_t			start,
+	loff_t			end,
+	int			datasync)
+{
+	return __xfs_fsync(file->f_mapping->host, start, end, datasync);
+}
+
+int
+xfs_fsync(struct xfs_inode *ip, int datasync)
+{
+	return -__xfs_fsync(VFS_I(ip), 0, LLONG_MAX, datasync);
+}
+
 STATIC ssize_t
 xfs_file_aio_read(
 	struct kiocb		*iocb,
--- a/fs/xfs/linux-2.6/xfs_ksyms.c
+++ b/fs/xfs/linux-2.6/xfs_ksyms.c
@@ -49,7 +49,6 @@
 #include "xfs_dir2_leaf.h"
 #include "xfs_dir2_block.h"
 #include "xfs_dir2_node.h"
-#include "xfs_dir2_trace.h"
 #include "xfs_acl.h"
 #include "xfs_attr.h"
 #include "xfs_attr_leaf.h"
@@ -63,7 +62,6 @@
 #include "xfs_iomap.h"
 #include "xfs_filestream.h"
 #include "xfs_vnodeops.h"
-#include "support/ktrace.h"
 
 EXPORT_SYMBOL(xfs_iunlock);
 EXPORT_SYMBOL(xfs_attr_remove);
@@ -84,10 +82,8 @@ EXPORT_SYMBOL(xfs_setattr);
 EXPORT_SYMBOL(xfs_trans_alloc);
 EXPORT_SYMBOL(xfs_trans_cancel);
 EXPORT_SYMBOL(xfs_fsync);
-EXPORT_SYMBOL(xfs_iput_new);
 EXPORT_SYMBOL(xfs_bulkstat);
 EXPORT_SYMBOL(xfs_ilock_map_shared);
-EXPORT_SYMBOL(xfs_iput);
 EXPORT_SYMBOL(xfs_trans_log_inode);
 EXPORT_SYMBOL(xfs_attr_list);
 EXPORT_SYMBOL(kmem_alloc);
--- a/fs/xfs/xfs_vnodeops.h
+++ b/fs/xfs/xfs_vnodeops.h
@@ -21,6 +21,7 @@ int xfs_setattr(struct xfs_inode *ip, st
 #define XFS_ATTR_SYNC		0x10	/* synchronous operation required */
 
 int xfs_readlink(struct xfs_inode *ip, char *link);
+int xfs_fsync(struct xfs_inode *ip, int datasync);
 int xfs_release(struct xfs_inode *ip);
 int xfs_inactive(struct xfs_inode *ip);
 int xfs_lookup(struct xfs_inode *dp, struct xfs_name *name,
