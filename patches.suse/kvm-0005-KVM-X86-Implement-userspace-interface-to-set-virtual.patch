From: Joerg Roedel <joerg.roedel@amd.com>
Subject: [PATCH 5/5] KVM: X86: Implement userspace interface to set virtual_tsc_khz
References: FATE#309762
Git-commit: 92a1f12d2598f429bd8639e21d89305e787115c5
Patch-mainline: v3.0-rc1

This patch implements two new vm-ioctls to get and set the
virtual_tsc_khz if the machine supports tsc-scaling. Setting
the tsc-frequency is only possible before userspace creates
any vcpu.

Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 Documentation/kvm/api.txt       |   22 ++++++++++++++++++++++
 arch/x86/include/asm/kvm_host.h |    7 +++++++
 arch/x86/kvm/svm.c              |   21 +++++++++++++++++++++
 arch/x86/kvm/x86.c              |   36 ++++++++++++++++++++++++++++++++++++
 include/linux/kvm.h             |    7 +++++++
 5 files changed, 93 insertions(+)

Index: b/Documentation/kvm/api.txt
===================================================================
--- a/Documentation/kvm/api.txt
+++ b/Documentation/kvm/api.txt
@@ -694,6 +694,28 @@ If KVM_CAP_INTR_SHADOW is available, KVM
 the flags field to signal that interrupt.shadow contains a valid state and
 shall be written into the VCPU.
 
+4.31 KVM_SET_TSC_KHZ
+
+Capability: KVM_CAP_TSC_CONTROL
+Architectures: x86
+Type: vcpu ioctl
+Parameters: virtual tsc_khz
+Returns: 0 on success, -1 on error
+
+Specifies the tsc frequency for the virtual machine. The unit of the
+frequency is KHz.
+
+4.32 KVM_GET_TSC_KHZ
+
+Capability: KVM_CAP_GET_TSC_KHZ
+Architectures: x86
+Type: vcpu ioctl
+Parameters: none
+Returns: virtual tsc-khz on success, negative value on error
+
+Returns the tsc frequency of the guest. The unit of the return value is
+KHz. If the host has unstable tsc this ioctl returns -EIO instead as an
+error.
 
 4.41 KVM_GET_XSAVE
 
Index: b/arch/x86/include/asm/kvm_host.h
===================================================================
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -570,6 +570,13 @@ u8 kvm_get_guest_memory_type(struct kvm_
 
 extern bool tdp_enabled;
 
+/* control of guest tsc rate supported? */
+extern bool kvm_has_tsc_control;
+/* minimum supported tsc_khz for guests */
+extern u32  kvm_min_guest_tsc_khz;
+/* maximum supported tsc_khz for guests */
+extern u32  kvm_max_guest_tsc_khz;
+
 enum emulation_result {
 	EMULATE_DONE,       /* no further processing */
 	EMULATE_DO_MMIO,      /* kvm_run filled with mmio request */
Index: b/arch/x86/kvm/svm.c
===================================================================
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -68,6 +68,8 @@ MODULE_LICENSE("GPL");
 #endif
 
 #define TSC_RATIO_RSVD          0xffffff0000000000ULL
+#define TSC_RATIO_MIN		0x0000000000000001ULL
+#define TSC_RATIO_MAX		0x000000ffffffffffULL
 
 static bool erratum_383_found __read_mostly;
 
@@ -146,10 +148,12 @@ static void svm_complete_interrupts(stru
 static int svm_set_msr(struct kvm_vcpu *vcpu, unsigned ecx, u64 data);
 static int svm_get_msr(struct kvm_vcpu *vcpu, unsigned ecx, u64 *data);
 
+
 static int nested_svm_exit_handled(struct vcpu_svm *svm);
 static int nested_svm_vmexit(struct vcpu_svm *svm);
 static int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,
 				      bool has_error_code, u32 error_code);
+static u64 __scale_tsc(u64 ratio, u64 tsc);
 
 enum {
 	VMCB_INTERCEPTS, /* Intercept vectors, TSC offset,
@@ -590,6 +594,23 @@ static __init int svm_hardware_setup(voi
 	} else
 		kvm_disable_tdp();
 
+	if (svm_has(SVM_FEATURE_TSC_RATE)) {
+		u64 max;
+
+		kvm_has_tsc_control = true;
+
+		/*
+		 * Make sure the user can only configure tsc_khz values that
+		 * fit into a signed integer.
+		 * A min value is not calculated needed because it will always
+		 * be 1 on all machines and a value of 0 is used to disable
+		 * tsc-scaling for the vcpu.
+		 */
+		max = min(0x7fffffffULL, __scale_tsc(tsc_khz, TSC_RATIO_MAX));
+
+		kvm_max_guest_tsc_khz = max;
+	}
+
 	return 0;
 
 err:
Index: b/arch/x86/kvm/x86.c
===================================================================
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -93,6 +93,11 @@ EXPORT_SYMBOL_GPL(kvm_x86_ops);
 int ignore_msrs = 0;
 module_param_named(ignore_msrs, ignore_msrs, bool, S_IRUGO | S_IWUSR);
 
+bool kvm_has_tsc_control;
+EXPORT_SYMBOL_GPL(kvm_has_tsc_control);
+u32  kvm_max_guest_tsc_khz;
+EXPORT_SYMBOL_GPL(kvm_max_guest_tsc_khz);
+
 struct kvm_stats_debugfs_item debugfs_entries[] = {
 	{ "pf_fixed", VCPU_STAT(pf_fixed) },
 	{ "pf_guest", VCPU_STAT(pf_guest) },
@@ -1328,6 +1333,7 @@ int kvm_dev_ioctl_check_extension(long e
 	case KVM_CAP_SET_IDENTITY_MAP_ADDR:
 	case KVM_CAP_ADJUST_CLOCK:
 	case KVM_CAP_VCPU_EVENTS:
+	case KVM_CAP_GET_TSC_KHZ:
 	case KVM_CAP_XSAVE:
 		r = 1;
 		break;
@@ -1355,6 +1361,9 @@ int kvm_dev_ioctl_check_extension(long e
 	case KVM_CAP_XCRS:
 		r = cpu_has_xsave;
 		break;
+	case KVM_CAP_TSC_CONTROL:
+		r = kvm_has_tsc_control;
+		break;
 	default:
 		r = 0;
 		break;
@@ -2267,6 +2276,33 @@ long kvm_arch_vcpu_ioctl(struct file *fi
 		r = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, xcrs);
 		break;
 	}
+	case KVM_SET_TSC_KHZ: {
+	      u32 user_tsc_khz;
+
+	      r = -EINVAL;
+	      if (!kvm_has_tsc_control)
+		      break;
+
+	      user_tsc_khz = (u32)arg;
+
+	      if (user_tsc_khz >= kvm_max_guest_tsc_khz)
+		      goto out;
+
+	      kvm_x86_ops->set_tsc_khz(vcpu, user_tsc_khz);
+
+	      r = 0;
+	      goto out;
+	}
+	case KVM_GET_TSC_KHZ: {
+	      r = -EIO;
+
+	      if (check_tsc_unstable())
+		      goto out;
+
+	      r = vcpu_tsc_khz(vcpu);
+
+	      goto out;
+	}
 	default:
 		r = -EINVAL;
 	}
Index: b/include/linux/kvm.h
===================================================================
--- a/include/linux/kvm.h
+++ b/include/linux/kvm.h
@@ -451,6 +451,9 @@ struct kvm_ioeventfd {
 #define KVM_CAP_XCRS 56
 #endif
 
+#define KVM_CAP_TSC_CONTROL 60
+#define KVM_CAP_GET_TSC_KHZ 61
+
 #ifdef KVM_CAP_IRQ_ROUTING
 
 struct kvm_irq_routing_irqchip {
@@ -617,6 +620,10 @@ struct kvm_clock_data {
 #define KVM_X86_GET_MCE_CAP_SUPPORTED _IOR(KVMIO,  0x9d, __u64)
 #define KVM_X86_SET_MCE           _IOW(KVMIO,  0x9e, struct kvm_x86_mce)
 
+/* Available with KVM_CAP_TSC_CONTROL */
+#define KVM_SET_TSC_KHZ           _IO(KVMIO,  0xa2)
+#define KVM_GET_TSC_KHZ           _IO(KVMIO,  0xa3)
+
 /*
  * Deprecated interfaces
  */
