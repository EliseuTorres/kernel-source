From: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Date: Mon, 9 Nov 2009 12:31:05 +0900
Subject: perf bench: Fix bench/sched-pipe.c to wait for child process
Patch-mainline: v2.6.33-rc1
Git-commit: 5ff0cfc67f00fe0feaa1da0b2359232ea4aa0ee7

Ingo reported this small 'perf bench sched pipe' output problem:

 | $ ./perf bench sched pipe
 | (executing 1000000 pipe operations between two tasks)
 |
 |	Total time:4.898 sec
 | $		4.898586 usecs/op
 |		204140 ops/sec
 |
 | the shell prompt came back before the usecs/op and ops/sec line
 | was printed. Process teardown race, lack of wait() or so?

This caused by lack of calling waitpid() by parent process,
so I added it.

Signed-off-by: Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
Cc: Rusty Russell <rusty@rustcorp.com.au>
Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Cc: Paul Mackerras <paulus@samba.org>
Cc: Mike Galbraith <efault@gmx.de>
Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: Jiri Kosina <jkosina@suse.cz>
LKML-Reference: <1257737465-7546-1-git-send-email-mitake@dcl.info.waseda.ac.jp>
Signed-off-by: Ingo Molnar <mingo@elte.hu>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 tools/perf/bench/sched-pipe.c |   10 +++++++---
 1 files changed, 7 insertions(+), 3 deletions(-)

diff --git a/tools/perf/bench/sched-pipe.c b/tools/perf/bench/sched-pipe.c
index 3214ed2..6a29100 100644
--- a/tools/perf/bench/sched-pipe.c
+++ b/tools/perf/bench/sched-pipe.c
@@ -26,6 +26,7 @@
 #include <errno.h>
 #include <assert.h>
 #include <sys/time.h>
+#include <sys/types.h>
 
 #define LOOPS_DEFAULT 1000000
 static int loops = LOOPS_DEFAULT;
@@ -58,8 +59,8 @@ int bench_sched_pipe(int argc, const char **argv,
 	 * discarding returned value of read(), write()
 	 * causes error in building environment for perf
 	 */
-	int ret;
-	pid_t pid;
+	int ret, wait_stat;
+	pid_t pid, retpid;
 
 	argc = parse_options(argc, argv, options,
 			     bench_sched_pipe_usage, 0);
@@ -87,8 +88,11 @@ int bench_sched_pipe(int argc, const char **argv,
 	gettimeofday(&stop, NULL);
 	timersub(&stop, &start, &diff);
 
-	if (pid)
+	if (pid) {
+		retpid = waitpid(pid, &wait_stat, 0);
+		assert((retpid == pid) && WIFEXITED(wait_stat));
 		return 0;
+	}
 
 	if (simple)
 		printf("%lu.%03lu\n",

