From: Russ Anderson <rja@sgi.com>
Subject: Add KDB support to UV NMI handler.
References: bnc#579647, FATE#306952
Patch-mainline: no

Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---
 arch/x86/kernel/apic/x2apic_uv_x.c |   22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

Index: linux-2.6.32-SLE11-SP1/arch/x86/kernel/apic/x2apic_uv_x.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/kernel/apic/x2apic_uv_x.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/kernel/apic/x2apic_uv_x.c
@@ -21,6 +21,9 @@
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/kdebug.h>
+#ifdef CONFIG_KDB
+#include <linux/kdb.h>
+#endif
 
 #include <asm/uv/uv_mmrs.h>
 #include <asm/uv/uv_hub.h>
@@ -43,11 +46,29 @@ EXPORT_SYMBOL_GPL(uv_min_hub_revision_id
 int uv_handle_nmi(struct notifier_block *self,
 		  unsigned long reason, void *data)
 {
+#ifdef CONFIG_KDB
+	struct die_args *args = data;
+	struct pt_regs *regs = args->regs;
+	static int controlling_cpu = -1;
+#endif
 	unsigned long flags;
 	static DEFINE_SPINLOCK(uv_nmi_lock);
 
 	if (reason != DIE_NMI_IPI)
 		return NOTIFY_OK;
+
+#ifdef CONFIG_KDB
+	spin_lock_irqsave(&uv_nmi_lock, flags);
+	if (controlling_cpu == -1) {
+		controlling_cpu = smp_processor_id();
+		spin_unlock_irqrestore(&uv_nmi_lock, flags);
+		(void)kdb(KDB_REASON_NMI, reason, regs);
+		controlling_cpu = -1;
+	} else {
+		spin_unlock_irqrestore(&uv_nmi_lock, flags);
+		(void)kdb(KDB_REASON_ENTER_SLAVE, reason, regs);
+	}
+#else
 	/*
 	 * Use a lock so only one cpu prints at a time
 	 * to prevent intermixed output.
@@ -57,6 +78,7 @@ int uv_handle_nmi(struct notifier_block 
 				smp_processor_id());
 	dump_stack();
 	spin_unlock_irqrestore(&uv_nmi_lock, flags);
+#endif /* CONFIG_KDB */
 
 	return NOTIFY_STOP;
 }
