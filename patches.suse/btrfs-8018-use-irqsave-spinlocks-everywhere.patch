From: David Sterba <dsterba@suse.cz>
Date: Thu Dec  8 03:32:58 CET 2011
Patch-mainline: no
References: FATE#306586 bnc#734522
Subject: [PATCH] btrfs: use irqsave spinlocks everywhere

Workaround for rcu stall when timer interrupt fires but is not able to continue
for yet unknown reasons.
All _irq variants are changed to _irqsave.

Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/async-thread.c     |   45 +++++++++++++++++++++++++-------------------
 fs/btrfs/disk-io.c          |    6 +++--
 fs/btrfs/extent_io.c        |    5 ++--
 fs/btrfs/free-space-cache.c |    5 ++--
 4 files changed, 36 insertions(+), 25 deletions(-)

--- a/fs/btrfs/async-thread.c
+++ b/fs/btrfs/async-thread.c
@@ -231,8 +231,9 @@ static void put_worker(struct btrfs_work
 static int try_worker_shutdown(struct btrfs_worker_thread *worker)
 {
 	int freeit = 0;
+	unsigned long flags;
 
-	spin_lock_irq(&worker->lock);
+	spin_lock_irqsave(&worker->lock, flags);
 	spin_lock(&worker->workers->lock);
 	if (worker->workers->num_workers > 1 &&
 	    worker->idle &&
@@ -246,7 +247,7 @@ static int try_worker_shutdown(struct bt
 		worker->workers->num_workers--;
 	}
 	spin_unlock(&worker->workers->lock);
-	spin_unlock_irq(&worker->lock);
+	spin_unlock_irqrestore(&worker->lock, flags);
 
 	if (freeit)
 		put_worker(worker);
@@ -259,6 +260,7 @@ static struct btrfs_work *get_next_work(
 {
 	struct btrfs_work *work = NULL;
 	struct list_head *cur = NULL;
+	unsigned long flags;
 
 	if(!list_empty(prio_head))
 		cur = prio_head->next;
@@ -274,7 +276,7 @@ static struct btrfs_work *get_next_work(
 		goto out;
 
 refill:
-	spin_lock_irq(&worker->lock);
+	spin_lock_irqsave(&worker->lock, flags);
 	list_splice_tail_init(&worker->prio_pending, prio_head);
 	list_splice_tail_init(&worker->pending, head);
 
@@ -282,7 +284,7 @@ refill:
 		cur = prio_head->next;
 	else if (!list_empty(head))
 		cur = head->next;
-	spin_unlock_irq(&worker->lock);
+	spin_unlock_irqrestore(&worker->lock, flags);
 
 	if (!cur)
 		goto out_fail;
@@ -303,6 +305,7 @@ static int worker_loop(void *arg)
 	struct list_head head;
 	struct list_head prio_head;
 	struct btrfs_work *work;
+	unsigned long flags;
 
 	INIT_LIST_HEAD(&head);
 	INIT_LIST_HEAD(&prio_head);
@@ -334,15 +337,15 @@ again:
 			cond_resched();
 		}
 
-		spin_lock_irq(&worker->lock);
+		spin_lock_irqsave(&worker->lock, flags);
 		check_idle_worker(worker);
 
 		if (freezing(current)) {
 			worker->working = 0;
-			spin_unlock_irq(&worker->lock);
+			spin_unlock_irqrestore(&worker->lock, flags);
 			refrigerator();
 		} else {
-			spin_unlock_irq(&worker->lock);
+			spin_unlock_irqrestore(&worker->lock, flags);
 			if (!kthread_should_stop()) {
 				cpu_relax();
 				/*
@@ -372,7 +375,7 @@ again:
 					break;
 
 				/* still no more work?, sleep for real */
-				spin_lock_irq(&worker->lock);
+				spin_lock_irqsave(&worker->lock, flags);
 				set_current_state(TASK_INTERRUPTIBLE);
 				if (!list_empty(&worker->pending) ||
 				    !list_empty(&worker->prio_pending)) {
@@ -386,7 +389,7 @@ again:
 				 * adds something new to the queue
 				 */
 				worker->working = 0;
-				spin_unlock_irq(&worker->lock);
+				spin_unlock_irqrestore(&worker->lock, flags);
 
 				if (!kthread_should_stop()) {
 					schedule_timeout(HZ * 120);
@@ -410,8 +413,9 @@ void btrfs_stop_workers(struct btrfs_wor
 	struct list_head *cur;
 	struct btrfs_worker_thread *worker;
 	int can_stop;
+	unsigned long flags;
 
-	spin_lock_irq(&workers->lock);
+	spin_lock_irqsave(&workers->lock, flags);
 	list_splice_init(&workers->idle_list, &workers->worker_list);
 	while (!list_empty(&workers->worker_list)) {
 		cur = workers->worker_list.next;
@@ -426,13 +430,13 @@ void btrfs_stop_workers(struct btrfs_wor
 			can_stop = 1;
 		} else
 			can_stop = 0;
-		spin_unlock_irq(&workers->lock);
+		spin_unlock_irqrestore(&workers->lock, flags);
 		if (can_stop)
 			kthread_stop(worker->task);
-		spin_lock_irq(&workers->lock);
+		spin_lock_irqsave(&workers->lock, flags);
 		put_worker(worker);
 	}
-	spin_unlock_irq(&workers->lock);
+	spin_unlock_irqrestore(&workers->lock, flags);
 }
 
 /*
@@ -465,6 +469,7 @@ static int __btrfs_start_workers(struct
 {
 	struct btrfs_worker_thread *worker;
 	int ret = 0;
+	unsigned long flags;
 
 	worker = kzalloc(sizeof(*worker), GFP_NOFS);
 	if (!worker) {
@@ -488,27 +493,29 @@ static int __btrfs_start_workers(struct
 		kfree(worker);
 		goto fail;
 	}
-	spin_lock_irq(&workers->lock);
+	spin_lock_irqsave(&workers->lock, flags);
 	list_add_tail(&worker->worker_list, &workers->idle_list);
 	worker->idle = 1;
 	workers->num_workers++;
 	workers->num_workers_starting--;
 	WARN_ON(workers->num_workers_starting < 0);
-	spin_unlock_irq(&workers->lock);
+	spin_unlock_irqrestore(&workers->lock, flags);
 
 	return 0;
 fail:
-	spin_lock_irq(&workers->lock);
+	spin_lock_irqsave(&workers->lock, flags);
 	workers->num_workers_starting--;
-	spin_unlock_irq(&workers->lock);
+	spin_unlock_irqrestore(&workers->lock, flags);
 	return ret;
 }
 
 int btrfs_start_workers(struct btrfs_workers *workers)
 {
-	spin_lock_irq(&workers->lock);
+	unsigned long flags;
+
+	spin_lock_irqsave(&workers->lock, flags);
 	workers->num_workers_starting++;
-	spin_unlock_irq(&workers->lock);
+	spin_unlock_irqrestore(&workers->lock, flags);
 	return __btrfs_start_workers(workers);
 }
 
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -3537,12 +3537,14 @@ static int btrfs_destroy_marked_extents(
 
 			lock_page(page);
 			if (PageDirty(page)) {
+				unsigned long flags;
+
 				clear_page_dirty_for_io(page);
-				spin_lock_irq(&page->mapping->tree_lock);
+				spin_lock_irqsave(&page->mapping->tree_lock, flags);
 				radix_tree_tag_clear(&page->mapping->page_tree,
 							page_index(page),
 							PAGECACHE_TAG_DIRTY);
-				spin_unlock_irq(&page->mapping->tree_lock);
+				spin_unlock_irqrestore(&page->mapping->tree_lock, flags);
 			}
 
 			page->mapping->a_ops->invalidatepage(page, 0);
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@ -4293,6 +4293,7 @@ void clear_extent_buffer_dirty(struct ex
 	unsigned long i;
 	unsigned long num_pages;
 	struct page *page;
+	unsigned long flags;
 
 	num_pages = num_extent_pages(eb->start, eb->len);
 	WARN_ON(atomic_read(&eb->refs) == 0);
@@ -4306,13 +4307,13 @@ void clear_extent_buffer_dirty(struct ex
 		WARN_ON(!PagePrivate(page));
 
 		clear_page_dirty_for_io(page);
-		spin_lock_irq(&page->mapping->tree_lock);
+		spin_lock_irqsave(&page->mapping->tree_lock, flags);
 		if (!PageDirty(page)) {
 			radix_tree_tag_clear(&page->mapping->page_tree,
 						page_index(page),
 						PAGECACHE_TAG_DIRTY);
 		}
-		spin_unlock_irq(&page->mapping->tree_lock);
+		spin_unlock_irqrestore(&page->mapping->tree_lock, flags);
 		ClearPageError(page);
 		unlock_page(page);
 	}
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@ -2104,10 +2104,11 @@ u64 btrfs_find_space_for_alloc(struct bt
 {
 	struct btrfs_free_space_ctl *ctl = block_group->free_space_ctl;
 	struct btrfs_free_space *entry = NULL;
+	unsigned long flags;
 	u64 bytes_search = bytes + empty_size;
 	u64 ret = 0;
 
-	spin_lock_irq(&ctl->tree_lock);
+	spin_lock_irqsave(&ctl->tree_lock, flags);
 	entry = find_free_space(ctl, &offset, &bytes_search);
 	if (!entry)
 		goto out;
@@ -2128,7 +2129,7 @@ u64 btrfs_find_space_for_alloc(struct bt
 	}
 
 out:
-	spin_unlock_irq(&ctl->tree_lock);
+	spin_unlock_irqrestore(&ctl->tree_lock, flags);
 
 	return ret;
 }
