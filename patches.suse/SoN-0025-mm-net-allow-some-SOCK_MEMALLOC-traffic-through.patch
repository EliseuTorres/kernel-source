From: Bodo Stroesser <bstroesser@ts.fujitsu.com>
Date: Tue, 22 Jan 2013 11:13:37 +0000
Subject: [PATCH] mm: net: Allow some !SOCK_MEMALLOC traffic through even if
 skb_pfmemalloc

References: GPFS (bnc#786900)
Patch-mainline: No, never.

GPFS abuses PF_MEMALLOC by setting it for all threads of its daemon mmfsd
with the help of a module. Thus, in case of memory pressure local socket
connections of mmfsd are hanging as skbs allocated for send_to(), that
come from emergency buffers are dropped on the receive side.

This patch changes the receive path to drop such skbs more selectively. The
skb is only dropped if:

   (!skb_shared(skb) &&
        (skb->fclone == SKB_FCLONE_UNAVAILABLE ||
         (fclone_ref == 1 &&
               (skb->fclone == SKB_FCLONE_ORIG ||
                skb->fclone == SKB_FCLONE_CLONE))))

In these cases, kfree_skb() will free some memory after RX completes.
In all other cases the received skb is not dropped. This leads to the
first transmission of a packet being queued in the receiving socket,
but if a retransmission is done, that skb would be dropped.

On a sendto() normally a skb from skbuff_fclone_cache is allocated.
The ORIG skb is queued in the socket and the CLONE is used for transmission.
If on a local connection the transmitted skb is dropped on the receive
side because of pf_memalloc being set, no memory is freed as the skb stays
queued in the transmitting socket for the duration of all retransmissions
which all will be dropped.  So probability is high that skb will be freed
earlier if it is handled like a normal skb.

With the patch, if a packet isn't dropped that would have been dropped
without the patch, a WARN_ON() is done.

The patch is a workaround only. It doesn't eliminate the risk that GPFS
can livelock the system due to memory exhaustion.  This problem can be
solved by GPFS only.

Signed-off-by: Bodo Stroesser <bstroesser@ts.fujitsu.com>
Signed-off-by: Mel Gorman <mgorman@suse.de>
Signed-off-by: Petr Tesarik <ptesarik@suse.cz>
---
 net/core/filter.c |   54 +++++++++++++++++++++++++++++++++++++++++++++++++++--
 net/core/sock.c   |   18 ++++++++++++++++--
 2 files changed, 68 insertions(+), 4 deletions(-)

diff --git a/net/core/filter.c b/net/core/filter.c
index 4ccf6f4..fa4318f 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -64,6 +64,39 @@ static inline void *load_pointer(const struct sk_buff *skb, int k,
 }
 
 /**
+ *	skb_kfree_would_free_mem - would a call to kfree_skb
+ *	                           actually free some memory
+ *	@skb: buffer to check
+ *
+ *	Returns true if a call to kfree_skb at least would free a skb
+ *	to skbuff_fclone_cache or skbuff_head_cache
+ */
+static int skb_kfree_would_free_mem(const struct sk_buff *skb)
+{
+	unsigned int fclone_ref;
+
+	switch (skb->fclone) {
+	case SKB_FCLONE_UNAVAILABLE:
+		fclone_ref = 0;
+		break;
+	case SKB_FCLONE_ORIG:
+		fclone_ref = atomic_read((atomic_t *) (skb + 2));
+		break;
+	case SKB_FCLONE_CLONE:
+		fclone_ref = atomic_read((atomic_t *) (skb + 1));
+		break;
+	default:
+		WARN_ON(1);
+		fclone_ref = 0;
+		break;
+	}
+
+	return !skb_shared(skb) &&
+	       (skb->fclone == SKB_FCLONE_UNAVAILABLE ||
+		(fclone_ref == 1 && (skb->fclone == SKB_FCLONE_ORIG || skb->fclone == SKB_FCLONE_CLONE)));
+}
+
+/**
  *	sk_filter - run a packet through a socket filter
  *	@sk: sock associated with &sk_buff
  *	@skb: buffer to filter
@@ -85,8 +118,25 @@ int sk_filter(struct sock *sk, struct sk_buff *skb)
 	 * allow SOCK_MEMALLOC sockets to use it as this socket is
 	 * helping free memory
 	 */
-	if (skb_pfmemalloc(skb) && !sock_flag(sk, SOCK_MEMALLOC))
-		return -ENOMEM;
+	if (skb_pfmemalloc(skb) && !sock_flag(sk, SOCK_MEMALLOC)) {
+		/*
+		 * SLES: Unfortunately, GPFS is abusing PF_MEMALLOC to allocate
+		 * its buffers, likely in an effort to avoid recursing into the
+		 * filesystem during writeback and deadlocking instead of using
+		 * GFP_NOFS. Alternatively it may be using PF_MEMALLOC to avoid
+		 * a stack overflow from direct reclaim in their aops writepage
+		 * handler If that's the case it should make a check for direct
+		 * reclaim similar to what XFS does.
+		 *
+		 * Without this skb_kfree_would_free_kmem() check,  the packets
+		 * can be discarded so allow the packets to be received in some
+		 * cases. The risk is that GPFS can livelock the system due  to
+		 * memory exhaustion but the common case will be that processes
+		 * stall while writeback is in progress.
+		 */
+		if (skb_kfree_would_free_mem(skb))
+			return -ENOMEM;
+	}
 
 	err = security_sock_rcv_skb(sk, skb);
 	if (err)
diff --git a/net/core/sock.c b/net/core/sock.c
index 168e8c2..4d23862 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -249,9 +249,23 @@ int __sk_backlog_rcv(struct sock *sk, struct sk_buff *skb)
 {
 	int ret;
 	unsigned long pflags = current->flags;
+	static bool warned = false;
 
-	/* these should have been dropped before queueing */
-	BUG_ON(!sock_flag(sk, SOCK_MEMALLOC));
+	/*
+	 * Ordinarily these should have been dropped before queueing but in
+	 * the case of GPFS the processes are abusing PF_MEMALLOC running
+	 * a risk of livelock due to memory exhaustion. Warn when this
+	 * happens. See https://bugzilla.novell.com/show_bug.cgi?id=786900
+	 */
+	if (!sock_flag(sk, SOCK_MEMALLOC) && !warned) {
+		pr_warning("Network buffers allocated using PF_MEMALLOC.\n");
+		pr_info("Use of PF_MEMALLOC reserves to allocate network buffers are\n");
+		pr_info("usually the result of a third-party module and should be updated.\n");
+		if (sk_memalloc_socks())
+			pr_info("Use of such a module in combination with swap-over-NFS is particularly risky.");
+		WARN_ON(1);
+		warned = true;
+	}
 
 	current->flags |= PF_MEMALLOC;
 	ret = sk->sk_backlog_rcv(sk, skb);
