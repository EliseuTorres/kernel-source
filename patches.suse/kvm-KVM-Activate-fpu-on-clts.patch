From: Avi Kivity <avi@redhat.com>
Subject: [PATCH] KVM: Activate fpu on clts
Patch-mainline: yes
References: FATE#311768
Git-commit: 6b52d18605f580bdffaffd48c8da228c3e848deb

Assume that if the guest executes clts, it knows what it's doing, and load the
guest fpu to prevent an #NM exception.

Signed-off-by: Avi Kivity <avi@redhat.com>
Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/include/asm/kvm_host.h |    1 +
 arch/x86/kvm/svm.c              |    8 +++++++-
 arch/x86/kvm/vmx.c              |    1 +
 arch/x86/kvm/x86.c              |    1 +
 4 files changed, 10 insertions(+), 1 deletions(-)

Index: linux-2.6.32-SLE11-SP2/arch/x86/include/asm/kvm_host.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/include/asm/kvm_host.h
+++ linux-2.6.32-SLE11-SP2/arch/x86/include/asm/kvm_host.h
@@ -502,6 +502,7 @@ struct kvm_x86_ops {
 	void (*cache_reg)(struct kvm_vcpu *vcpu, enum kvm_reg reg);
 	unsigned long (*get_rflags)(struct kvm_vcpu *vcpu);
 	void (*set_rflags)(struct kvm_vcpu *vcpu, unsigned long rflags);
+	void (*fpu_activate)(struct kvm_vcpu *vcpu);
 	void (*fpu_deactivate)(struct kvm_vcpu *vcpu);
 
 	void (*tlb_flush)(struct kvm_vcpu *vcpu);
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/svm.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/svm.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/svm.c
@@ -1278,18 +1278,22 @@ static int ud_interception(struct vcpu_s
 	return 1;
 }
 
-static int nm_interception(struct vcpu_svm *svm, struct kvm_run *kvm_run)
+static void svm_fpu_activate(struct kvm_vcpu *vcpu)
 {
+	struct vcpu_svm *svm = to_svm(vcpu);
 	svm->vmcb->control.intercept_exceptions &= ~(1 << NM_VECTOR);
 	if (!(svm->vcpu.arch.cr0 & X86_CR0_TS))
 		svm->vmcb->save.cr0 &= ~X86_CR0_TS;
 	else
 		svm->vmcb->save.cr0 |= X86_CR0_TS;
 	svm->vcpu.fpu_active = 1;
+}
 
+static int nm_interception(struct vcpu_svm *svm, struct kvm_run *kvm_run)
+{
+	svm_fpu_activate(&svm->vcpu);
 	return 1;
 }
-
 static bool is_erratum_383(void)
 {
 	int err, i;
@@ -3040,6 +3044,7 @@ static struct kvm_x86_ops svm_x86_ops =
 	.cache_reg = svm_cache_reg,
 	.get_rflags = svm_get_rflags,
 	.set_rflags = svm_set_rflags,
+	.fpu_activate = svm_fpu_activate,
 	.fpu_deactivate = svm_fpu_deactivate,
 
 	.tlb_flush = svm_flush_tlb,
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/vmx.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/vmx.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/vmx.c
@@ -3006,6 +3006,7 @@ static int handle_cr(struct kvm_vcpu *vc
 		vcpu->arch.cr0 &= ~X86_CR0_TS;
 		vmcs_writel(CR0_READ_SHADOW, vcpu->arch.cr0);
 		skip_emulated_instruction(vcpu);
+		vmx_fpu_activate(vcpu);
 		return 1;
 	case 1: /*mov from cr*/
 		switch (cr) {
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/x86.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/x86.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/x86.c
@@ -2989,6 +2989,7 @@ int emulate_invlpg(struct kvm_vcpu *vcpu
 int emulate_clts(struct kvm_vcpu *vcpu)
 {
 	kvm_x86_ops->set_cr0(vcpu, vcpu->arch.cr0 & ~X86_CR0_TS);
+	kvm_x86_ops->fpu_activate(vcpu);
 	return X86EMUL_CONTINUE;
 }
 
