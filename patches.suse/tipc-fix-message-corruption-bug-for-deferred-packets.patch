From: Erik Hugne <erik.hugne@ericsson.com>
Subject: tipc: fix message corruption bug for deferred packets
Git-commit: 64380a04deeed4720de76b086a3a4eab8dd41671
Patch-mainline: v3.14
References: bsc#907063
Acked-by: Jiri Bohac <jbohac@suse.cz>

If a packet received on a link is out-of-sequence, it will be
placed on a deferred queue and later reinserted in the receive
path once the preceding packets have been processed. The problem
with this is that it will be subject to the buffer adjustment from
link_recv_buf_validate twice. The second adjustment for 20 bytes
header space will corrupt the packet.

We solve this by tagging the deferred packets and bail out from
receive buffer validation for packets that have already been
subjected to this.

Signed-off-by: Erik Hugne <erik.hugne@ericsson.com>
---
 net/tipc/core.h |    1 +
 net/tipc/link.c |    7 +++++++
 2 files changed, 8 insertions(+)

diff --git a/net/tipc/core.h b/net/tipc/core.h
index 0207db0..81a083d 100644
--- a/net/tipc/core.h
+++ b/net/tipc/core.h
@@ -178,6 +178,7 @@ static inline void k_term_timer(struct timer_list *timer)
 #define BUF_HEADROOM LL_MAX_HEADER
 
 struct tipc_skb_cb {
+	char deferred;
 	void *handle;
 };
 
diff --git a/net/tipc/link.c b/net/tipc/link.c
index b1590a5..9c5cd74 100644
--- a/net/tipc/link.c
+++ b/net/tipc/link.c
@@ -1556,6 +1556,12 @@ static int link_recv_buf_validate(struct sk_buff *buf)
 	u32 hdr_size;
 	u32 min_hdr_size;
 
+	/* If this packet comes from the defer queue, the skb has already
+	 * been validated
+	 */
+	if (unlikely(TIPC_SKB_CB(buf)->deferred))
+		return 1;
+
 	if (unlikely(buf->len < MIN_H_SIZE))
 		return 0;
 
@@ -1872,6 +1878,7 @@ static void link_handle_out_of_seq_msg(struct tipc_link *l_ptr,
 				&l_ptr->newest_deferred_in, buf)) {
 		l_ptr->deferred_inqueue_sz++;
 		l_ptr->stats.deferred_recv++;
+		TIPC_SKB_CB(buf)->deferred = 1;
 		if ((l_ptr->deferred_inqueue_sz % 16) == 1)
 			tipc_link_send_proto_msg(l_ptr, STATE_MSG, 0, 0, 0, 0, 0);
 	} else
-- 
1.7.9.5

