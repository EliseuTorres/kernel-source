From f155c6619a80528155f8b5c0c4b6c7f2738e9d06 Mon Sep 17 00:00:00 2001
From: Ilya Dryomov <idryomov@gmail.com>
Date: Wed, 12 Oct 2011 10:09:43 +0300
Patch-mainline: pending
References: FATE#306586
Subject: [PATCH] Btrfs: allow for resuming restriper after it was
 paused

Implement an ioctl for resuming restriper.  We use the same heuristics
used when recovering restripe after a crash to try to start where we
left off last time.  If needed those parameters can be made configurable
through the userspace "resume" command in future.

Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/ioctl.c   |    2 ++
 fs/btrfs/ioctl.h   |    1 +
 fs/btrfs/volumes.c |   25 +++++++++++++++++++++++++
 fs/btrfs/volumes.h |    1 +
 4 files changed, 29 insertions(+), 0 deletions(-)

diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index 948d65d..e80e9f3 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -3119,6 +3119,8 @@ static long btrfs_ioctl_restripe_ctl(struct btrfs_root *root,
 		return btrfs_cancel_restripe(root->fs_info);
 	case BTRFS_RESTRIPE_CTL_PAUSE:
 		return btrfs_pause_restripe(root->fs_info, 0);
+	case BTRFS_RESTRIPE_CTL_RESUME:
+		return btrfs_resume_restripe(root->fs_info);
 	}
 
 	return -EINVAL;
diff --git a/fs/btrfs/ioctl.h b/fs/btrfs/ioctl.h
index 81d27ea..6c36ab74 100644
--- a/fs/btrfs/ioctl.h
+++ b/fs/btrfs/ioctl.h
@@ -111,6 +111,7 @@ struct btrfs_ioctl_fs_info_args {
 
 #define BTRFS_RESTRIPE_CTL_CANCEL	1
 #define BTRFS_RESTRIPE_CTL_PAUSE	2
+#define BTRFS_RESTRIPE_CTL_RESUME	3
 
 /*
  * this is packed, because it should have the same size as its
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 9ff1379..a120c10 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -2921,6 +2921,31 @@ out:
 	return ret;
 }
 
+int btrfs_resume_restripe(struct btrfs_fs_info *fs_info)
+{
+	int ret;
+
+	if (fs_info->sb->s_flags & MS_RDONLY)
+		return -EROFS;
+
+	mutex_lock(&fs_info->restripe_mutex);
+	if (!fs_info->restripe_ctl) {
+		ret = -ENOTCONN;
+		goto out;
+	}
+
+	if (test_bit(RESTRIPE_RUNNING, &fs_info->restripe_state)) {
+		ret = -EINPROGRESS;
+		goto out;
+	}
+
+	ret = btrfs_restripe(fs_info->restripe_ctl, 1);
+
+out:
+	mutex_unlock(&fs_info->restripe_mutex);
+	return ret;
+}
+
 /*
  * shrinking a device means finding all of the device extents past
  * the new size, and then following the back refs to the chunks.
diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index e25c580..687ec74 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -275,6 +275,7 @@ int btrfs_restripe(struct restripe_control *rctl, int resume);
 int btrfs_recover_restripe(struct btrfs_root *tree_root);
 int btrfs_cancel_restripe(struct btrfs_fs_info *fs_info);
 int btrfs_pause_restripe(struct btrfs_fs_info *fs_info, int unset);
+int btrfs_resume_restripe(struct btrfs_fs_info *fs_info);
 int btrfs_chunk_readonly(struct btrfs_root *root, u64 chunk_offset);
 int find_free_dev_extent(struct btrfs_trans_handle *trans,
 			 struct btrfs_device *device, u64 num_bytes,
-- 
1.7.6.233.gd79bc

