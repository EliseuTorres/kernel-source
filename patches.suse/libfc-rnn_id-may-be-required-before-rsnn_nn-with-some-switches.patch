Subject: [SCSI] libfc: RNN_ID may be required before RSNN_NN with some switches
References: fate#306857, fate#306859, bnc#551175
Acked-by: Jiri Bohac <jbohac@suse.cz>
From: Chris Leech <christopher.leech@intel.com>

One could interpret FC-GS-5 to say that an explicit RNN_ID is required
    before RSNN_NN is allowed to succeed, which is why RNN_ID was not obsoleted
    along with RPN_ID acording to this document:
    ftp://ftp.t11.org/t11/member/fc/gs-5/05-546v2.pdf

    Signed-off-by: Chris Leech <christopher.leech@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>
---

 drivers/scsi/libfc/fc_lport.c |   91 +++++++++++++++++++++++++++++++++++++++++
 include/scsi/fc_encode.h      |    4 +-
 include/scsi/libfc.h          |    1 
 3 files changed, 93 insertions(+), 3 deletions(-)


diff --git a/drivers/scsi/libfc/fc_lport.c b/drivers/scsi/libfc/fc_lport.c
index 47577e4..897b5a8 100644
--- a/drivers/scsi/libfc/fc_lport.c
+++ b/drivers/scsi/libfc/fc_lport.c
@@ -108,6 +108,7 @@ static void fc_lport_error(struct fc_lport *, struct fc_frame *);
 static void fc_lport_enter_reset(struct fc_lport *);
 static void fc_lport_enter_flogi(struct fc_lport *);
 static void fc_lport_enter_dns(struct fc_lport *);
+static void fc_lport_enter_rnn_id(struct fc_lport *);
 static void fc_lport_enter_rft_id(struct fc_lport *);
 static void fc_lport_enter_scr(struct fc_lport *);
 static void fc_lport_enter_ready(struct fc_lport *);
@@ -117,6 +118,7 @@ static const char *fc_lport_state_names[] = {
 	[LPORT_ST_DISABLED] = "disabled",
 	[LPORT_ST_FLOGI] =    "FLOGI",
 	[LPORT_ST_DNS] =      "dNS",
+	[LPORT_ST_RNN_ID] =   "RNN_ID",
 	[LPORT_ST_RFT_ID] =   "RFT_ID",
 	[LPORT_ST_SCR] =      "SCR",
 	[LPORT_ST_READY] =    "Ready",
@@ -151,7 +153,7 @@ static void fc_lport_rport_callback(struct fc_lport *lport,
 	case RPORT_EV_READY:
 		if (lport->state == LPORT_ST_DNS) {
 			lport->dns_rp = rdata;
-			fc_lport_enter_rft_id(lport);
+			fc_lport_enter_rnn_id(lport);
 		} else {
 			FC_LPORT_DBG(lport, "Received an READY event "
 				     "on port (%6x) for the directory "
@@ -963,6 +965,7 @@ static void fc_lport_error(struct fc_lport *lport, struct fc_frame *fp)
 			case LPORT_ST_DISABLED:
 			case LPORT_ST_READY:
 			case LPORT_ST_RESET:
+			case LPORT_ST_RNN_ID:
 			case LPORT_ST_RFT_ID:
 			case LPORT_ST_SCR:
 			case LPORT_ST_DNS:
@@ -1030,6 +1033,60 @@ err:
 }
 
 /**
+ * fc_lport_rnn_id_resp() - Handle response to Register Node
+ *			    Name by ID (RNN_ID) request
+ * @sp: current sequence in RNN_ID exchange
+ * @fp: response frame
+ * @lp_arg: Fibre Channel host port instance
+ *
+ * Locking Note: This function will be called without the lport lock
+ * held, but it will lock, call an _enter_* function or fc_lport_error
+ * and then unlock the lport.
+ */
+static void fc_lport_rnn_id_resp(struct fc_seq *sp, struct fc_frame *fp,
+				 void *lp_arg)
+{
+	struct fc_lport *lport = lp_arg;
+	struct fc_frame_header *fh;
+	struct fc_ct_hdr *ct;
+
+	FC_LPORT_DBG(lport, "Received a RNN_ID %s\n", fc_els_resp_type(fp));
+
+	if (fp == ERR_PTR(-FC_EX_CLOSED))
+		return;
+
+	mutex_lock(&lport->lp_mutex);
+
+	if (lport->state != LPORT_ST_RNN_ID) {
+		FC_LPORT_DBG(lport, "Received a RNN_ID response, but in state "
+			     "%s\n", fc_lport_state(lport));
+		if (IS_ERR(fp))
+			goto err;
+		goto out;
+	}
+
+	if (IS_ERR(fp)) {
+		fc_lport_error(lport, fp);
+		goto err;
+	}
+
+	fh = fc_frame_header_get(fp);
+	ct = fc_frame_payload_get(fp, sizeof(*ct));
+	if (fh && ct && fh->fh_type == FC_TYPE_CT &&
+	    ct->ct_fs_type == FC_FST_DIR &&
+	    ct->ct_fs_subtype == FC_NS_SUBTYPE &&
+	    ntohs(ct->ct_cmd) == FC_FS_ACC)
+		fc_lport_enter_rft_id(lport);
+	else
+		fc_lport_error(lport, fp);
+
+out:
+	fc_frame_free(fp);
+err:
+	mutex_unlock(&lport->lp_mutex);
+}
+
+/**
  * fc_lport_scr_resp() - Handle response to State Change Register (SCR) request
  * @sp: current sequence in SCR exchange
  * @fp: response frame
@@ -1146,6 +1203,35 @@ static void fc_lport_enter_rft_id(struct fc_lport *lport)
 		fc_lport_error(lport, fp);
 }
 
+/**
+ * fc_rport_enter_rnn_id() - Register node name with the name server
+ * @lport: Fibre Channel local port to register
+ *
+ * Locking Note: The lport lock is expected to be held before calling
+ * this routine.
+ */
+static void fc_lport_enter_rnn_id(struct fc_lport *lport)
+{
+	struct fc_frame *fp;
+
+	FC_LPORT_DBG(lport, "Entered RNN_ID state from %s state\n",
+		     fc_lport_state(lport));
+
+	fc_lport_state_enter(lport, LPORT_ST_RNN_ID);
+
+	fp = fc_frame_alloc(lport, sizeof(struct fc_ct_hdr) +
+			    sizeof(struct fc_ns_rn_id));
+	if (!fp) {
+		fc_lport_error(lport, fp);
+		return;
+	}
+
+	if (!lport->tt.elsct_send(lport, FC_FID_DIR_SERV, fp, FC_NS_RNN_ID,
+				  fc_lport_rnn_id_resp,
+				  lport, lport->e_d_tov))
+		fc_lport_error(lport, fp);
+}
+
 static struct fc_rport_operations fc_lport_rport_ops = {
 	.event_callback = fc_lport_rport_callback,
 };
@@ -1207,6 +1293,9 @@ static void fc_lport_timeout(struct work_struct *work)
 	case LPORT_ST_DNS:
 		fc_lport_enter_dns(lport);
 		break;
+	case LPORT_ST_RNN_ID:
+		fc_lport_enter_rnn_id(lport);
+		break;
 	case LPORT_ST_RFT_ID:
 		fc_lport_enter_rft_id(lport);
 		break;
diff --git a/include/scsi/fc_encode.h b/include/scsi/fc_encode.h
index c93ca3e..ad13cb1 100644
--- a/include/scsi/fc_encode.h
+++ b/include/scsi/fc_encode.h
@@ -128,12 +128,12 @@ static inline int fc_ct_fill(struct fc_lport *lport,
 		ct->payload.rft.fts = lport->fcts;
 		break;
 
-	case FC_NS_RPN_ID:
+	case FC_NS_RNN_ID:
 		ct = fc_ct_hdr_fill(fp, op, sizeof(struct fc_ns_rn_id));
 		hton24(ct->payload.rn.fr_fid.fp_fid,
 		       fc_host_port_id(lport->host));
 		ct->payload.rft.fts = lport->fcts;
-		put_unaligned_be64(lport->wwpn, &ct->payload.rn.fr_wwn);
+		put_unaligned_be64(lport->wwnn, &ct->payload.rn.fr_wwn);
 		break;
 
 	default:
diff --git a/include/scsi/libfc.h b/include/scsi/libfc.h
index 75be713..3d22dfd 100644
--- a/include/scsi/libfc.h
+++ b/include/scsi/libfc.h
@@ -61,6 +61,7 @@ enum fc_lport_state {
 	LPORT_ST_DISABLED = 0,
 	LPORT_ST_FLOGI,
 	LPORT_ST_DNS,
+	LPORT_ST_RNN_ID,
 	LPORT_ST_RFT_ID,
 	LPORT_ST_SCR,
 	LPORT_ST_READY,
