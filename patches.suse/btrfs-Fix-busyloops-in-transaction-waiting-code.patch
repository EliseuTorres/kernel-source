From: Jan Kara <jack@suse.cz>
Subject: [PATCH] btrfs: Fix busyloops in transaction waiting code
References: bnc#730103
Patch-mainline: 3.3

wait_log_commit() and wait_for_writer() were using slightly different
conditions for deciding whether they should call schedule() and whether they
should continue in the wait loop. Thus it could happen that we busylooped when
the first condition was not true while the second one was. That is burning CPU
cycles needlessly and is deadly on UP machines...

Signed-off-by: Jan Kara <jack@suse.cz>
---
 fs/btrfs/tree-log.c |    6 ++++--
 1 files changed, 4 insertions(+), 2 deletions(-)

diff -rupX /crypted/home/jack/.kerndiffexclude linux-3.0-SLE11-SP2/fs/btrfs/tree-log.c linux-3.0-SLE11-SP2-1-btrfs-busyloop/fs/btrfs/tree-log.c
--- linux-3.0-SLE11-SP2/fs/btrfs/tree-log.c	2012-01-23 20:10:07.809532868 +0100
+++ linux-3.0-SLE11-SP2-1-btrfs-busyloop/fs/btrfs/tree-log.c	2012-01-24 23:21:04.749963792 +0100
@@ -1962,7 +1962,8 @@ static int wait_log_commit(struct btrfs_
 
 		finish_wait(&root->log_commit_wait[index], &wait);
 		mutex_lock(&root->log_mutex);
-	} while (root->log_transid < transid + 2 &&
+	} while (root->fs_info->last_trans_log_full_commit !=
+		 trans->transid && root->log_transid < transid + 2 &&
 		 atomic_read(&root->log_commit[index]));
 	return 0;
 }
@@ -1971,7 +1972,8 @@ static void wait_for_writer(struct btrfs
 			    struct btrfs_root *root)
 {
 	DEFINE_WAIT(wait);
-	while (atomic_read(&root->log_writers)) {
+	while (root->fs_info->last_trans_log_full_commit !=
+	       trans->transid && atomic_read(&root->log_writers)) {
 		prepare_to_wait(&root->log_writer_wait,
 				&wait, TASK_UNINTERRUPTIBLE);
 		mutex_unlock(&root->log_mutex);
