From: Joerg Roedel <joerg.roedel@amd.com>
Subject: [PATCH 3/5] KVM: SVM: Make tsc_delta calculation a function of guest tsc
Reference: FATE#309762
Git-commit: 8f6055cbaf68cbd9ff2692a2cfa691b43629ccd4
Patch-mainline: v3.0-rc1

The calculation of the tsc_delta value to ensure a
forward-going tsc for the guest is a function of the
host-tsc. This works as long as the guests tsc_khz is equal
to the hosts tsc_khz. With tsc-scaling hardware support this
is not longer true and the tsc_delta needs to be calculated
using guest_tsc values.

Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/include/asm/kvm_host.h |    1 +
 arch/x86/kvm/svm.c              |    7 ++++++-
 2 files changed, 7 insertions(+), 1 deletions(-)

Index: linux-2.6.32-SLE11-SP2/arch/x86/include/asm/kvm_host.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/include/asm/kvm_host.h
+++ linux-2.6.32-SLE11-SP2/arch/x86/include/asm/kvm_host.h
@@ -262,6 +262,7 @@ struct kvm_mmu {
 
 struct kvm_vcpu_arch {
 	u64 host_tsc;
+	u64 guest_tsc;
 	/*
 	 * rip and regs accesses must go through
 	 * kvm_{register,rip}_{read,write} functions.
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/svm.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/svm.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/svm.c
@@ -144,6 +144,7 @@ module_param(nested, int, S_IRUGO);
 static void svm_flush_tlb(struct kvm_vcpu *vcpu);
 static void svm_complete_interrupts(struct vcpu_svm *svm);
 static int svm_set_msr(struct kvm_vcpu *vcpu, unsigned ecx, u64 data);
+static int svm_get_msr(struct kvm_vcpu *vcpu, unsigned ecx, u64 *data);
 
 static int nested_svm_exit_handled(struct vcpu_svm *svm);
 static int nested_svm_vmexit(struct vcpu_svm *svm);
@@ -898,7 +899,10 @@ static void svm_vcpu_load(struct kvm_vcp
 			 * Make sure that the guest sees a monotonically
 			 * increasing TSC.
 			 */
-			delta = vcpu->arch.host_tsc - native_read_tsc();
+			u64 guest_tsc;
+
+			svm_get_msr(vcpu, MSR_IA32_TSC, &guest_tsc);
+			delta = vcpu->arch.guest_tsc - guest_tsc;
 			svm->vmcb->control.tsc_offset += delta;
 			mark_dirty(svm->vmcb, VMCB_INTERCEPTS);
 			if (is_nested(svm))
@@ -930,6 +934,7 @@ static void svm_vcpu_put(struct kvm_vcpu
 		wrmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);
 
 	rdtscll(vcpu->arch.host_tsc);
+	svm_get_msr(vcpu, MSR_IA32_TSC, &vcpu->arch.guest_tsc);
 }
 
 static unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)
