From: shaohua.li@intel.com <shaohua.li@intel.com>
Date: Fri, 6 May 2011 11:35:31 -0600
Subject: SATA: enable non-queueable flush flag
References: FATE#312039
Patch-mainline: v3.0-rc1
Git-commit: 900e599eb0c16390ff671652a44e0ea90532220e

Enable non-queueable flush flag for SATA.

Stable: 2.6.39 only

Cc: stable@kernel.org
Signed-off-by: Shaohua Li <shaohua.li@intel.com>
Acked-by: Tejun Heo <tj@kernel.org>
Acked-by: Jeff Garzik <jgarzik@redhat.com>
Signed-off-by: Jens Axboe <jaxboe@fusionio.com>
Acked-by: Suresh Jayaraman <sjayaraman@suse.de>
---
 drivers/ata/libata-scsi.c |   13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

Index: linux-2.6.32-SLE11-SP2/drivers/ata/libata-scsi.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/drivers/ata/libata-scsi.c
+++ linux-2.6.32-SLE11-SP2/drivers/ata/libata-scsi.c
@@ -1088,21 +1088,21 @@ static int atapi_drain_needed(struct req
 static int ata_scsi_dev_config(struct scsi_device *sdev,
 			       struct ata_device *dev)
 {
+	struct request_queue *q = sdev->request_queue;
+
 	if (!ata_id_has_unload(dev->id))
 		dev->flags |= ATA_DFLAG_NO_UNLOAD;
 
 	/* configure max sectors */
-	blk_queue_max_hw_sectors(sdev->request_queue, dev->max_sectors);
+	blk_queue_max_hw_sectors(q, dev->max_sectors);
 
 	sdev->sector_size = ATA_SECT_SIZE;
 
 	if (dev->class == ATA_DEV_ATAPI) {
-		struct request_queue *q = sdev->request_queue;
 		void *buf;
 
 		/* set DMA padding */
-		blk_queue_update_dma_pad(sdev->request_queue,
-					 ATA_DMA_PAD_SZ - 1);
+		blk_queue_update_dma_pad(q, ATA_DMA_PAD_SZ - 1);
 
 		/* configure draining */
 		buf = kmalloc(ATAPI_MAX_DRAIN, q->bounce_gfp | GFP_KERNEL);
@@ -1133,8 +1133,7 @@ static int ata_scsi_dev_config(struct sc
 			"sector_size=%u > PAGE_SIZE, PIO may malfunction\n",
 			sdev->sector_size);
 
-	blk_queue_update_dma_alignment(sdev->request_queue,
-				       sdev->sector_size - 1);
+	blk_queue_update_dma_alignment(q, sdev->sector_size - 1);
 
 	if (dev->flags & ATA_DFLAG_AN)
 		set_bit(SDEV_EVT_MEDIA_CHANGE, sdev->supported_events);
@@ -2128,6 +2127,8 @@ static unsigned int ata_scsiop_inq_b0(st
 		put_unaligned_be32(1, &rbuf[28]);
 	}
 
+	blk_queue_flush_queueable(q, false);
+
 	return 0;
 }
 
