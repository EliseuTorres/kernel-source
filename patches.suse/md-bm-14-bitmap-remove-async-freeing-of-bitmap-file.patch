From: NeilBrown <neilb@suse.de>
Date: Thu, 12 Apr 2012 16:27:10 +1000
Subject: [PATCH 14/23] md/bitmap: remove async freeing of bitmap file.
Patch-mainline: 3.5
References: fate#311379

There is no real value in freeing things the moment there is an error.
It is just as good to free the bitmap file and pages when the bitmap
is explicitly removed (and replaced?) or at shutdown.

With this gone, the bitmap will only disappear when the array is
quiescent, so we can remove some locking.

As the 'filemap' doesn't disappear now, include extra checks before
trying to write any of it out.

Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: NeilBrown <neilb@suse.de>

---
 drivers/md/bitmap.c |   16 ++++++----------
 1 file changed, 6 insertions(+), 10 deletions(-)

--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/md/bitmap.c
+++ linux-3.0-SLE11-SP2-BTMU/drivers/md/bitmap.c
@@ -802,7 +802,6 @@ static void bitmap_file_unmap(struct bit
 	int pages;
 	struct bitmap_storage *store = &bitmap->storage;
 
-	spin_lock_irq(&bitmap->lock);
 	map = store->filemap;
 	store->filemap = NULL;
 	attr = store->filemap_attr;
@@ -811,7 +810,6 @@ static void bitmap_file_unmap(struct bit
 	store->file_pages = 0;
 	sb_page = store->sb_page;
 	store->sb_page = NULL;
-	spin_unlock_irq(&bitmap->lock);
 
 	while (pages--)
 		if (map[pages] != sb_page) /* 0 is sb_page, release it below */
@@ -827,10 +825,8 @@ static void bitmap_file_put(struct bitma
 {
 	struct file *file;
 
-	spin_lock_irq(&bitmap->lock);
 	file = bitmap->storage.file;
 	bitmap->storage.file = NULL;
-	spin_unlock_irq(&bitmap->lock);
 
 	if (file) {
 		synchronize_rcu();
@@ -875,10 +871,6 @@ static void bitmap_file_kick(struct bitm
 			       "%s: disabling internal bitmap due to errors\n",
 			       bmname(bitmap));
 	}
-
-	bitmap_file_put(bitmap);
-
-	return;
 }
 
 enum bitmap_page_attr {
@@ -968,7 +960,8 @@ void bitmap_unplug(struct bitmap *bitmap
 	int dirty, need_write;
 	int wait = 0;
 
-	if (!bitmap || !bitmap->storage.filemap)
+	if (!bitmap || !bitmap->storage.filemap ||
+	    test_bit(BITMAP_STALE, &bitmap->flags))
 		return;
 
 	/* look at each page to see if there are any set bits that need to be
@@ -1291,7 +1284,10 @@ void bitmap_daemon_work(mddev_t *mddev)
 	 * the first blocking holds the superblock and it has been updated.
 	 * We mustn't write any other blocks before the superblock.
 	 */
-	for (j = 0; j < bitmap->storage.file_pages; j++) {
+	for (j = 0;
+	     j < bitmap->storage.file_pages
+		     && !test_bit(BITMAP_STALE, &bitmap->flags);
+	     j++) {
 
 		if (test_page_attr(bitmap, j,
 				    BITMAP_PAGE_DIRTY))
