From 66cc69e34e86a231fbe68d8918c6119e3b7549a3 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Date: Thu, 13 Mar 2014 12:11:30 +1030
Subject: [PATCH] Fix: module signature vs tracepoints: add new TAINT_UNSIGNED_MODULE
Git-commit: 66cc69e34e86a231fbe68d8918c6119e3b7549a3
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux.git
Patch-mainline: to be in 3.15-rc1
References: bnc#870450,FATE#317134

Users have reported being unable to trace non-signed modules loaded
within a kernel supporting module signature.

This is caused by tracepoint.c:tracepoint_module_coming() refusing to
take into account tracepoints sitting within force-loaded modules
(TAINT_FORCED_MODULE). The reason for this check, in the first place, is
that a force-loaded module may have a struct module incompatible with
the layout expected by the kernel, and can thus cause a kernel crash
upon forced load of that module on a kernel with CONFIG_TRACEPOINTS=y.

Tracepoints, however, specifically accept TAINT_OOT_MODULE and
TAINT_CRAP, since those modules do not lead to the "very likely system
crash" issue cited above for force-loaded modules.

With kernels having CONFIG_MODULE_SIG=y (signed modules), a non-signed
module is tainted re-using the TAINT_FORCED_MODULE taint flag.
Unfortunately, this means that Tracepoints treat that module as a
force-loaded module, and thus silently refuse to consider any tracepoint
within this module.

Since an unsigned module does not fit within the "very likely system
crash" category of tainting, add a new TAINT_UNSIGNED_MODULE taint flag
to specifically address this taint behavior, and accept those modules
within Tracepoints. We use the letter 'X' as a taint flag character for
a module being loaded that doesn't know how to sign its name (proposed
by Steven Rostedt).

Also add the missing 'O' entry to trace event show_module_flags() list
for the sake of completeness.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Acked-by: Steven Rostedt <rostedt@goodmis.org>
Naked-by: Ingo Molnar <mingo@redhat.com>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: David Howells <dhowells@redhat.com>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 Documentation/oops-tracing.txt  |    3 +++
 Documentation/sysctl/kernel.txt |    2 ++
 include/linux/kernel.h          |    1 +
 include/trace/events/module.h   |    3 ++-
 kernel/module.c                 |    4 +++-
 kernel/panic.c                  |    2 ++
 6 files changed, 13 insertions(+), 2 deletions(-)

--- a/Documentation/oops-tracing.txt
+++ b/Documentation/oops-tracing.txt
@@ -263,6 +263,9 @@ characters, each representing a particul
  12: 'I' if the kernel is working around a severe bug in the platform
      firmware (BIOS or similar).
 
+ 13: 'X' if an unsigned module has been loaded in a kernel supporting
+     module signature.
+
 The primary reason for the 'Tainted: ' string is to tell kernel
 debuggers if this is a clean kernel or if anything unusual has
 occurred.  Tainting is permanent: even if an offending module is
--- a/Documentation/sysctl/kernel.txt
+++ b/Documentation/sysctl/kernel.txt
@@ -506,6 +506,8 @@ can be ORed together:
         instead of using the one provided by the hardware.
  512 - A kernel warning has occurred.
 1024 - A module from drivers/staging was loaded.
+8192 - An unsigned module has been loaded in a kernel supporting module
+       signature.
  0x40000000 - An unsupported kernel module was loaded.
  0x80000000 - An kernel module with external support was loaded.
 
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -384,6 +384,7 @@ extern enum system_states {
 #define TAINT_WARN			9
 #define TAINT_CRAP			10
 #define TAINT_FIRMWARE_WORKAROUND	11
+#define TAINT_UNSIGNED_MODULE		13
 
 #ifdef CONFIG_ENTERPRISE_SUPPORT
 /*
--- a/include/trace/events/module.h
+++ b/include/trace/events/module.h
@@ -23,7 +23,8 @@ struct module;
 #define show_module_flags(flags) __print_flags(flags, "",	\
 	{ (1UL << TAINT_PROPRIETARY_MODULE),	"P" },		\
 	{ (1UL << TAINT_FORCED_MODULE),		"F" },		\
-	{ (1UL << TAINT_CRAP),			"C" })
+	{ (1UL << TAINT_CRAP),			"C" },		\
+	{ (1UL << TAINT_UNSIGNED_MODULE),	"X" })
 
 TRACE_EVENT(module_load,
 
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -2952,7 +2952,7 @@ static struct module *load_module(void _
 #ifdef CONFIG_MODULE_SIG
 	mod->sig_ok = info.sig_ok;
 	if (!mod->sig_ok)
-		add_taint_module(mod, TAINT_FORCED_MODULE);
+		add_taint_module(mod, TAINT_UNSIGNED_MODULE);
 #endif
 
 	/* Now module is in final location, initialize linked lists, etc. */
@@ -3405,6 +3405,8 @@ static char *module_flags(struct module
 			buf[bx++] = 'F';
 		if (mod->taints & (1 << TAINT_CRAP))
 			buf[bx++] = 'C';
+		if (mod->taints & (1 << TAINT_UNSIGNED_MODULE))
+			buf[bx++] = 'X';
 #ifdef CONFIG_ENTERPRISE_SUPPORT
 		if (mod->taints & (1 << TAINT_NO_SUPPORT))
 			buf[bx++] = 'N';
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -186,6 +186,7 @@ static const struct tnt tnts[] = {
 	{ TAINT_WARN,			'W', ' ' },
 	{ TAINT_CRAP,			'C', ' ' },
 	{ TAINT_FIRMWARE_WORKAROUND,	'I', ' ' },
+	{ TAINT_UNSIGNED_MODULE,	'X', ' ' },
 #ifdef CONFIG_ENTERPRISE_SUPPORT
 	{ TAINT_NO_SUPPORT,		'N', ' ' },
 	{ TAINT_EXTERNAL_SUPPORT,	'X', ' ' },
@@ -207,6 +208,7 @@ static const struct tnt tnts[] = {
  *  'W' - Taint on warning.
  *  'C' - modules from drivers/staging are loaded.
  *  'I' - Working around severe firmware bug.
+ *  'X' - Unsigned module has been loaded.
  *  'N' - Unsuported modules loaded.
  *  'X' - Modules with external support loaded.
  *
