From d54ff73259a852d4b3886dc586587fdef5e9c8de Mon Sep 17 00:00:00 2001
From: Steve French <sfrench@us.ibm.com>
Date: Tue, 27 Apr 2010 04:38:15 +0000
Subject: [CIFS] Fix lease break for writes
References: FATE#311695
Patch-mainline: yes

On lease break we were breaking to readonly leases always
even if write requested.  Also removed experimental
ifdef around setlease code

Signed-off-by: Steve French <sfrench@us.ibm.com>
Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
---
 fs/cifs/cifsfs.c |   12 ------------
 fs/cifs/cifsfs.h |    2 +-
 fs/cifs/file.c   |    6 ++----
 3 files changed, 3 insertions(+), 17 deletions(-)

Index: linux-2.6.32-SLE11-SP2/fs/cifs/cifsfs.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/cifsfs.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/cifsfs.c
@@ -645,7 +645,6 @@ static loff_t cifs_llseek(struct file *f
 	return generic_file_llseek_unlocked(file, offset, origin);
 }
 
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 static int cifs_setlease(struct file *file, long arg, struct file_lock **lease)
 {
 	/* note that this is called by vfs setlease with the BKL held
@@ -674,7 +673,6 @@ static int cifs_setlease(struct file *fi
 	else
 		return -EAGAIN;
 }
-#endif
 
 struct file_system_type cifs_fs_type = {
 	.owner = THIS_MODULE,
@@ -751,10 +749,7 @@ const struct file_operations cifs_file_o
 #ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
-
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 	.setlease = cifs_setlease,
-#endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
 const struct file_operations cifs_file_direct_ops = {
@@ -773,9 +768,7 @@ const struct file_operations cifs_file_d
 	.unlocked_ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 	.setlease = cifs_setlease,
-#endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 const struct file_operations cifs_file_nobrl_ops = {
 	.read = do_sync_read,
@@ -792,10 +785,7 @@ const struct file_operations cifs_file_n
 #ifdef CONFIG_CIFS_POSIX
 	.unlocked_ioctl	= cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
-
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 	.setlease = cifs_setlease,
-#endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
 const struct file_operations cifs_file_direct_nobrl_ops = {
@@ -813,9 +803,7 @@ const struct file_operations cifs_file_d
 	.unlocked_ioctl  = cifs_ioctl,
 #endif /* CONFIG_CIFS_POSIX */
 	.llseek = cifs_llseek,
-#ifdef CONFIG_CIFS_EXPERIMENTAL
 	.setlease = cifs_setlease,
-#endif /* CONFIG_CIFS_EXPERIMENTAL */
 };
 
 const struct file_operations cifs_dir_ops = {
Index: linux-2.6.32-SLE11-SP2/fs/cifs/cifsfs.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/cifsfs.h
+++ linux-2.6.32-SLE11-SP2/fs/cifs/cifsfs.h
@@ -114,5 +114,5 @@ extern long cifs_ioctl(struct file *file
 extern const struct export_operations cifs_export_ops;
 #endif /* EXPERIMENTAL */
 
-#define CIFS_VERSION   "1.63"
+#define CIFS_VERSION   "1.64"
 #endif				/* _CIFSFS_H */
Index: linux-2.6.32-SLE11-SP2/fs/cifs/file.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/file.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/file.c
@@ -2279,12 +2279,10 @@ cifs_oplock_break(struct slow_work *work
 	int rc, waitrc = 0;
 
 	if (inode && S_ISREG(inode->i_mode)) {
-#ifdef CONFIG_CIFS_EXPERIMENTAL
-		if (cinode->clientCanCacheAll == 0)
+		if (cinode->clientCanCacheRead)
 			break_lease(inode, FMODE_READ);
-		else if (cinode->clientCanCacheRead == 0)
+		else
 			break_lease(inode, FMODE_WRITE);
-#endif
 		rc = filemap_fdatawrite(inode->i_mapping);
 		if (cinode->clientCanCacheRead == 0) {
 			waitrc = filemap_fdatawait(inode->i_mapping);
