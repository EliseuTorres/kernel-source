From: NeilBrown <neilb@suse.de>
Date: Wed, 7 Mar 2012 13:53:31 +1100
Subject: [PATCH] md: allow last device to be forcibly removed from RAID1/RAID10.
Patch-mainline: 3.4?
References: bnc#746717

When the 'last' device in a RAID1 or RAID10 reports an error,
we do not mark it as failed.  This would serve little purpose
as there is no risk of losing data beyond that which is obviously
lost (as there is with RAID5), and there could be other sectors
on the device which are readable, and only readable from this device.
This in general this maximises access to data.

However the current implementation also stops an admin from removing
the last device by direct action.  This is rarely useful, but in many
case is not harmful and can make automation easier by removing special
cases.

Also, if an attempt to write metadata fails the device must be marked
as faulty, else an infinite loop will result, attempting to update
the metadata on all non-faulty devices.

So add a 'force' option to 'md_error()' and '*errorhandler()' which
bypasses the 'last disk' checks for RAID1 and RAID10.
Set it when the removal is explicitly requested by user-space, or
when it is the result of a failed metadata write.

Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: NeilBrown <neilb@suse.de>

---
 drivers/md/md.c        |   10 +++++-----
 drivers/md/md.h        |    4 ++--
 drivers/md/multipath.c |    6 +++---
 drivers/md/raid1.c     |   23 ++++++++++++-----------
 drivers/md/raid10.c    |   21 +++++++++++----------
 drivers/md/raid5.c     |    8 ++++----
 6 files changed, 37 insertions(+), 35 deletions(-)

--- linux-3.0-SLE11-SP2.orig/drivers/md/md.c
+++ linux-3.0-SLE11-SP2/drivers/md/md.c
@@ -779,7 +779,7 @@ static void super_written(struct bio *bi
 		printk("md: super_written gets error=%d, uptodate=%d\n",
 		       error, test_bit(BIO_UPTODATE, &bio->bi_flags));
 		WARN_ON(test_bit(BIO_UPTODATE, &bio->bi_flags));
-		md_error(mddev, rdev);
+		md_error(mddev, rdev, 1);
 		if (!test_bit(Faulty, &rdev->flags)
 		    && (bio->bi_rw & REQ_FAILFAST_DEV)) {
 			set_bit(MD_NEED_REWRITE, &mddev->flags);
@@ -2439,7 +2439,7 @@ state_store(mdk_rdev_t *rdev, const char
 	 */
 	int err = -EINVAL;
 	if (cmd_match(buf, "faulty") && rdev->mddev->pers) {
-		md_error(rdev->mddev, rdev);
+		md_error(rdev->mddev, rdev, 1);
 		err = 0;
 	} else if (cmd_match(buf, "remove")) {
 		if (rdev->raid_disk >= 0)
@@ -5835,7 +5835,7 @@ static int set_disk_faulty(mddev_t *mdde
 	if (!rdev)
 		return -ENODEV;
 
-	md_error(mddev, rdev);
+	md_error(mddev, rdev, 1);
 	return 0;
 }
 
@@ -6281,7 +6281,7 @@ void md_unregister_thread(mdk_thread_t *
 	kfree(thread);
 }
 
-void md_error(mddev_t *mddev, mdk_rdev_t *rdev)
+void md_error(mddev_t *mddev, mdk_rdev_t *rdev, int force)
 {
 	if (!mddev) {
 		MD_BUG();
@@ -6304,7 +6304,7 @@ void md_error(mddev_t *mddev, mdk_rdev_t
 		return;
 	if (!mddev->pers->error_handler)
 		return;
-	mddev->pers->error_handler(mddev,rdev);
+	mddev->pers->error_handler(mddev, rdev, force);
 	if (mddev->degraded)
 		set_bit(MD_RECOVERY_RECOVER, &mddev->recovery);
 	sysfs_notify_dirent_safe(rdev->sysfs_state);
--- linux-3.0-SLE11-SP2.orig/drivers/md/md.h
+++ linux-3.0-SLE11-SP2/drivers/md/md.h
@@ -371,7 +371,7 @@ struct mdk_personality
 	/* error_handler must set ->faulty and clear ->in_sync
 	 * if appropriate, and should abort recovery if needed 
 	 */
-	void (*error_handler)(mddev_t *mddev, mdk_rdev_t *rdev);
+	void (*error_handler)(mddev_t *mddev, mdk_rdev_t *rdev, int force);
 	int (*hot_add_disk) (mddev_t *mddev, mdk_rdev_t *rdev);
 	int (*hot_remove_disk) (mddev_t *mddev, int number);
 	int (*spare_active) (mddev_t *mddev);
@@ -492,7 +492,7 @@ extern void md_check_recovery(mddev_t *m
 extern void md_write_start(mddev_t *mddev, struct bio *bi);
 extern void md_write_end(mddev_t *mddev);
 extern void md_done_sync(mddev_t *mddev, int blocks, int ok);
-extern void md_error(mddev_t *mddev, mdk_rdev_t *rdev);
+extern void md_error(mddev_t *mddev, mdk_rdev_t *rdev, int force);
 
 extern int mddev_congested(mddev_t *mddev, int bits);
 extern void md_flush_request(mddev_t *mddev, struct bio *bio);
--- linux-3.0-SLE11-SP2.orig/drivers/md/multipath.c
+++ linux-3.0-SLE11-SP2/drivers/md/multipath.c
@@ -96,7 +96,7 @@ static void multipath_end_request(struct
 		 * oops, IO error:
 		 */
 		char b[BDEVNAME_SIZE];
-		md_error (mp_bh->mddev, rdev);
+		md_error (mp_bh->mddev, rdev, 0);
 		printk(KERN_ERR "multipath: %s: rescheduling sector %llu\n", 
 		       bdevname(rdev->bdev,b), 
 		       (unsigned long long)bio->bi_sector);
@@ -183,12 +183,12 @@ static int multipath_congested(void *dat
 /*
  * Careful, this can execute in IRQ contexts as well!
  */
-static void multipath_error (mddev_t *mddev, mdk_rdev_t *rdev)
+static void multipath_error(mddev_t *mddev, mdk_rdev_t *rdev, int force)
 {
 	multipath_conf_t *conf = mddev->private;
 	char b[BDEVNAME_SIZE];
 
-	if (conf->raid_disks - mddev->degraded <= 1) {
+	if (conf->raid_disks - mddev->degraded <= 1 && !force) {
 		/*
 		 * Uh oh, we can do nothing if this is our last path, but
 		 * first check if this is a queued request for a device
--- linux-3.0-SLE11-SP2.orig/drivers/md/raid1.c
+++ linux-3.0-SLE11-SP2/drivers/md/raid1.c
@@ -352,7 +352,7 @@ static void raid1_end_write_request(stru
 	r1_bio->bios[mirror] = NULL;
 	to_put = bio;
 	if (!uptodate) {
-		md_error(r1_bio->mddev, conf->mirrors[mirror].rdev);
+		md_error(r1_bio->mddev, conf->mirrors[mirror].rdev, 0);
 		/* an I/O failed, we can't clear the bitmap */
 
 		if (test_bit(FailFast, &rdev->flags) &&
@@ -989,7 +989,7 @@ static void status(struct seq_file *seq,
 }
 
 
-static void error(mddev_t *mddev, mdk_rdev_t *rdev)
+static void error(mddev_t *mddev, mdk_rdev_t *rdev, int force)
 {
 	char b[BDEVNAME_SIZE];
 	conf_t *conf = mddev->private;
@@ -1003,6 +1003,7 @@ static void error(mddev_t *mddev, mdk_rd
 	 */
 	spin_lock_irqsave(&conf->device_lock, flags);
 	if (test_bit(In_sync, &rdev->flags)
+	    && !force
 	    && (conf->raid_disks - mddev->degraded) == 1) {
 		/*
 		 * Don't fail the drive, act as though we were just a
@@ -1229,7 +1230,7 @@ static void end_sync_write(struct bio *b
 			s += sync_blocks;
 			sectors_to_go -= sync_blocks;
 		} while (sectors_to_go > 0);
-		md_error(mddev, conf->mirrors[mirror].rdev);
+		md_error(mddev, conf->mirrors[mirror].rdev, 0);
 	}
 
 	update_head_pos(mirror, r1_bio);
@@ -1263,7 +1264,7 @@ static int fix_sync_read_error(r1bio_t *
 	if (test_bit(FailFast, &rdev->flags)) {
 		/* Don't try recovering from here - just fail it
 		 * ... unless it is the last working device of course */
-		md_error(mddev, rdev);
+		md_error(mddev, rdev, 0);
 		if (test_bit(Faulty, &rdev->flags))
 			/* Don't try to read from here, but make sure
 			 * put_buf does it's thing
@@ -1303,7 +1304,7 @@ static int fix_sync_read_error(r1bio_t *
 		if (!success) {
 			char b[BDEVNAME_SIZE];
 			/* Cannot read from anywhere, array is toast */
-			md_error(mddev, conf->mirrors[r1_bio->read_disk].rdev);
+			md_error(mddev, conf->mirrors[r1_bio->read_disk].rdev, 0);
 			printk(KERN_ALERT "md/raid1:%s: %s: unrecoverable I/O read error"
 			       " for block %llu\n",
 			       mdname(mddev),
@@ -1330,7 +1331,7 @@ static int fix_sync_read_error(r1bio_t *
 					 WRITE, false) == 0) {
 				r1_bio->bios[d]->bi_end_io = NULL;
 				rdev_dec_pending(rdev, mddev);
-				md_error(mddev, rdev);
+				md_error(mddev, rdev, 0);
 			} else
 				atomic_add(s, &rdev->corrected_errors);
 		}
@@ -1347,7 +1348,7 @@ static int fix_sync_read_error(r1bio_t *
 					 s<<9,
 					 bio->bi_io_vec[idx].bv_page,
 					 READ, false) == 0)
-				md_error(mddev, rdev);
+				md_error(mddev, rdev, 0);
 		}
 		sectors -= s;
 		sect += s;
@@ -1530,7 +1531,7 @@ static void fix_read_error(conf_t *conf,
 
 		if (!success) {
 			/* Cannot read from anywhere -- bye bye array */
-			md_error(mddev, conf->mirrors[read_disk].rdev);
+			md_error(mddev, conf->mirrors[read_disk].rdev, 0);
 			break;
 		}
 		/* write it back and re-read */
@@ -1546,7 +1547,7 @@ static void fix_read_error(conf_t *conf,
 						 conf->tmppage, WRITE, false)
 				    == 0)
 					/* Well, this device is dead */
-					md_error(mddev, rdev);
+					md_error(mddev, rdev, 0);
 			}
 		}
 		d = start;
@@ -1562,7 +1563,7 @@ static void fix_read_error(conf_t *conf,
 						 conf->tmppage, READ, false)
 				    == 0)
 					/* Well, this device is dead */
-					md_error(mddev, rdev);
+					md_error(mddev, rdev, 0);
 				else {
 					atomic_add(s, &rdev->corrected_errors);
 					printk(KERN_INFO
@@ -1696,7 +1697,7 @@ static void raid1d(mddev_t *mddev)
 				unfreeze_array(conf);
 			} else
 				md_error(mddev,
-					 conf->mirrors[r1_bio->read_disk].rdev);
+					 conf->mirrors[r1_bio->read_disk].rdev, 0);
 
 			bio = r1_bio->bios[r1_bio->read_disk];
 			r1_bio->bios[r1_bio->read_disk] =
--- linux-3.0-SLE11-SP2.orig/drivers/md/raid10.c
+++ linux-3.0-SLE11-SP2/drivers/md/raid10.c
@@ -320,7 +320,7 @@ static void raid10_end_write_request(str
 	 * this branch is our 'one mirror IO has finished' event handler:
 	 */
 	if (!uptodate) {
-		md_error(r10_bio->mddev, conf->mirrors[dev].rdev);
+		md_error(r10_bio->mddev, conf->mirrors[dev].rdev, 0);
 		/* an I/O failed, we can't clear the bitmap */
 		set_bit(R10BIO_Degraded, &r10_bio->state);
 
@@ -1023,7 +1023,7 @@ static int enough(conf_t *conf, int igno
 	return 1;
 }
 
-static void error(mddev_t *mddev, mdk_rdev_t *rdev)
+static void error(mddev_t *mddev, mdk_rdev_t *rdev, int force)
 {
 	char b[BDEVNAME_SIZE];
 	conf_t *conf = mddev->private;
@@ -1037,6 +1037,7 @@ static void error(mddev_t *mddev, mdk_rd
 	 */
 	spin_lock_irqsave(&conf->device_lock, flags);
 	if (test_bit(In_sync, &rdev->flags)
+	    && !force
 	    && !enough(conf, rdev->raid_disk)) {
 		/*
 		 * Don't fail the drive, just return an IO error.
@@ -1241,7 +1242,7 @@ static void end_sync_read(struct bio *bi
 			   &conf->mirrors[d].rdev->corrected_errors);
 		if (!test_bit(MD_RECOVERY_SYNC, &conf->mddev->recovery))
 			md_error(r10_bio->mddev,
-				 conf->mirrors[d].rdev);
+				 conf->mirrors[d].rdev, 0);
 	}
 
 	/* for reconstruct, we always reschedule after a read.
@@ -1271,7 +1272,7 @@ static void end_sync_write(struct bio *b
 	d = r10_bio->devs[i].devnum;
 
 	if (!uptodate)
-		md_error(mddev, conf->mirrors[d].rdev);
+		md_error(mddev, conf->mirrors[d].rdev, 0);
 
 	update_head_pos(i, r10_bio);
 
@@ -1358,7 +1359,7 @@ static void sync_request_write(mddev_t *
 				continue;
 		} else if (test_bit(FailFast, &rdev->flags)) {
 			/* Just give up on this device */
-			md_error(rdev->mddev, rdev);
+			md_error(rdev->mddev, rdev, 0);
 			continue;
 		}
 		/* Ok, we need to write this bio
@@ -1520,7 +1521,7 @@ static void fix_read_error(conf_t *conf,
 		printk(KERN_NOTICE
 		       "md/raid10:%s: %s: Failing raid device\n",
 		       mdname(mddev), b);
-		md_error(mddev, conf->mirrors[d].rdev);
+		md_error(mddev, conf->mirrors[d].rdev, 0);
 		r10_bio->devs[r10_bio->read_slot].bio = IO_BLOCKED;
 		return;
 	}
@@ -1561,7 +1562,7 @@ static void fix_read_error(conf_t *conf,
 		if (!success) {
 			/* Cannot read from anywhere -- bye bye array */
 			int dn = r10_bio->devs[r10_bio->read_slot].devnum;
-			md_error(mddev, conf->mirrors[dn].rdev);
+			md_error(mddev, conf->mirrors[dn].rdev, 0);
 			r10_bio->devs[r10_bio->read_slot].bio = IO_BLOCKED;
 			break;
 		}
@@ -1600,7 +1601,7 @@ static void fix_read_error(conf_t *conf,
 					       "drive\n",
 					       mdname(mddev),
 					       bdevname(rdev->bdev, b));
-					md_error(mddev, rdev);
+					md_error(mddev, rdev, 0);
 				}
 				rdev_dec_pending(rdev, mddev);
 				rcu_read_lock();
@@ -1637,7 +1638,7 @@ static void fix_read_error(conf_t *conf,
 					       mdname(mddev),
 					       bdevname(rdev->bdev, b));
 
-					md_error(mddev, rdev);
+					md_error(mddev, rdev, 0);
 				} else {
 					printk(KERN_INFO
 					       "md/raid10:%s: read error corrected"
@@ -1780,7 +1781,7 @@ static void raid10d(mddev_t *mddev)
 				fix_read_error(conf, mddev, r10_bio);
 				unfreeze_array(conf);
 			} else {
-				md_error(mddev, rdev);
+				md_error(mddev, rdev, 0);
 				r10_bio->devs[slot].bio = IO_BLOCKED;
 			}
 
--- linux-3.0-SLE11-SP2.orig/drivers/md/raid5.c
+++ linux-3.0-SLE11-SP2/drivers/md/raid5.c
@@ -1634,7 +1634,7 @@ static void raid5_end_read_request(struc
 		else {
 			clear_bit(R5_ReadError, &sh->dev[i].flags);
 			clear_bit(R5_ReWrite, &sh->dev[i].flags);
-			md_error(conf->mddev, rdev);
+			md_error(conf->mddev, rdev, 0);
 		}
 	}
 	rdev_dec_pending(conf->disks[i].rdev, conf->mddev);
@@ -1663,7 +1663,7 @@ static void raid5_end_write_request(stru
 	}
 
 	if (!uptodate)
-		md_error(conf->mddev, conf->disks[i].rdev);
+		md_error(conf->mddev, conf->disks[i].rdev, 0);
 
 	rdev_dec_pending(conf->disks[i].rdev, conf->mddev);
 	
@@ -1694,7 +1694,7 @@ static void raid5_build_block(struct str
 	dev->sector = compute_blocknr(sh, i, previous);
 }
 
-static void error(mddev_t *mddev, mdk_rdev_t *rdev)
+static void error(mddev_t *mddev, mdk_rdev_t *rdev, int force)
 {
 	char b[BDEVNAME_SIZE];
 	raid5_conf_t *conf = mddev->private;
@@ -2239,7 +2239,7 @@ handle_failed_stripe(raid5_conf_t *conf,
 			rdev = rcu_dereference(conf->disks[i].rdev);
 			if (rdev && test_bit(In_sync, &rdev->flags))
 				/* multiple read failures in one stripe */
-				md_error(conf->mddev, rdev);
+				md_error(conf->mddev, rdev, 0);
 			rcu_read_unlock();
 		}
 		spin_lock_irq(&conf->device_lock);
