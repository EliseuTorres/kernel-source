Git-commit: 532a2a3fba8df076d65fdf17518eeb327b37a313
From: Shaohua Li <shli@kernel.org>
Date: Thu, 11 Oct 2012 13:30:52 +1100
Subject: md: raid 10 supports TRIM
Patch-mainline: v3.7
References: FATE#313625

This makes md raid 10 support TRIM.

If one disk supports discard and another not, or one has
discard_zero_data and another not, there could be inconsistent between
data from such disks. But this should not matter, discarded data is
useless. This will add extra copy in rebuild though.

Signed-off-by: Shaohua Li <shli@fusionio.com>
Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: NeilBrown <neilb@suse.de>

---
 drivers/md/raid10.c |   26 +++++++++++++++++++++++---
 1 file changed, 23 insertions(+), 3 deletions(-)

--- a/drivers/md/raid10.c
+++ b/drivers/md/raid10.c
@@ -749,7 +749,11 @@ static void flush_pending_writes(conf_t
 			bio->bi_next = NULL;
 			bio->bi_bdev = rdev->bdev;
 
-			if (test_bit(Faulty, &rdev->flags)) {
+			if (unlikely((bio->bi_rw & REQ_DISCARD) &&
+			    !blk_queue_discard(bdev_get_queue(bio->bi_bdev))))
+				/* Just ignore it */
+				bio_endio(bio, 0);
+			else if (test_bit(Faulty, &rdev->flags)) {
 				/*
 				 * Do not send requests down
 				 * a faulty device.
@@ -912,6 +916,8 @@ static int make_request(mddev_t *mddev,
 	const int rw = bio_data_dir(bio);
 	const unsigned long do_sync = (bio->bi_rw & REQ_SYNC);
 	const unsigned long do_fua = (bio->bi_rw & REQ_FUA);
+	const unsigned long do_discard = (bio->bi_rw
+					  & (REQ_DISCARD | REQ_SECURE));
 	unsigned long flags;
 	mdk_rdev_t *blocked_rdev;
 	int plugged = 1;
@@ -931,7 +937,7 @@ static int make_request(mddev_t *mddev,
 			 || conf->prev.near_copies < conf->prev.raid_disks))) {
 		struct bio_pair *bp;
 		/* Sanity check -- queue functions should prevent this happening */
-		if (bio->bi_vcnt != 1 ||
+		if ((bio->bi_vcnt != 1 && bio->bi_vcnt != 0) ||
 		    bio->bi_idx != 0)
 			goto bad_map;
 		/* This is a one page bio that upper layers
@@ -1121,7 +1127,7 @@ static int make_request(mddev_t *mddev,
 					      conf->mirrors[d].rdev);
 		mbio->bi_bdev = conf->mirrors[d].rdev->bdev;
 		mbio->bi_end_io	= raid10_end_write_request;
-		mbio->bi_rw = WRITE | do_sync | do_fua;
+		mbio->bi_rw = WRITE | do_sync | do_fua | do_discard;
 		if (test_bit(FailFast, &conf->mirrors[d].rdev->flags) &&
 		    _enough(conf,
 			    test_bit(R10BIO_Previous, &r10_bio->state)
@@ -1384,6 +1390,9 @@ static int raid10_add_disk(mddev_t *mdde
 		clear_bit(Unmerged, &rdev->flags);
 	}
 	md_integrity_add_rdev(rdev, mddev);
+	if (blk_queue_discard(bdev_get_queue(rdev->bdev)))
+		queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, mddev->queue);
+
 	print_conf(conf);
 	return err;
 }
@@ -2708,6 +2717,7 @@ static int run(mddev_t *mddev)
 	sector_t size;
 	sector_t min_offset_diff = 0;
 	int first = 1;
+	bool discard_supported = false;
 
 	if (mddev->private == NULL) {
 		conf = setup_conf(mddev);
@@ -2722,6 +2732,8 @@ static int run(mddev_t *mddev)
 	conf->thread = NULL;
 
 	chunk_size = mddev->chunk_sectors << 9;
+	blk_queue_max_discard_sectors(mddev->queue,
+				      mddev->chunk_sectors);
 	blk_queue_io_min(mddev->queue, chunk_size);
 	if (conf->geo.raid_disks % conf->geo.near_copies)
 		blk_queue_io_opt(mddev->queue, chunk_size * conf->geo.raid_disks);
@@ -2758,8 +2770,16 @@ static int run(mddev_t *mddev)
 				  rdev->data_offset << 9);
 
 		disk->head_position = 0;
+
+		if (blk_queue_discard(bdev_get_queue(rdev->bdev)))
+			discard_supported = true;
 	}
 
+	if (discard_supported)
+		queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, mddev->queue);
+	else
+		queue_flag_clear_unlocked(QUEUE_FLAG_DISCARD, mddev->queue);
+
 	/* need to check that every block has at least one working mirror */
 	if (!enough(conf, -1)) {
 		printk(KERN_ERR "md/raid10:%s: not enough operational mirrors.\n",
