From: Miklos Szeredi <mszeredi@suse.cz>
Date: Sat, 13 Dec 2014 00:59:48 +0100
Subject: ovl: mount: change order of initialization
Git-commit: 3b7a9a249a93e68b7bb318de40e64d3b68ba1a6d
Patch-mainline: v4.0-rc1
References: FATE#318783

Move allocation of root entry above to where it's needed.

Move initializations related to upperdir and workdir near each other.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
---
 fs/overlayfs/super.c |   70 +++++++++++++++++++++++----------------------------
 1 file changed, 32 insertions(+), 38 deletions(-)

--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -723,7 +723,6 @@ static int ovl_fill_super(struct super_b
 	struct path lowerpath;
 	struct path upperpath;
 	struct path workpath;
-	struct inode *root_inode;
 	struct dentry *root_dentry;
 	struct ovl_entry *oe;
 	struct ovl_fs *ufs;
@@ -749,54 +748,49 @@ static int ovl_fill_super(struct super_b
 		goto out_free_config;
 	}
 
-	err = -ENOMEM;
-	oe = ovl_alloc_entry(1);
-	if (oe == NULL)
-		goto out_free_config;
-
 	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 	if (err)
-		goto out_free_oe;
+		goto out_free_config;
 
-	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
+	err = ovl_mount_dir(ufs->config.workdir, &workpath);
 	if (err)
 		goto out_put_upperpath;
 
-	err = ovl_mount_dir(ufs->config.workdir, &workpath);
+	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
 	if (err)
-		goto out_put_lowerpath;
+		goto out_put_workpath;
 
 	err = -EINVAL;
 	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
 	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
 	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
 		pr_err("overlayfs: upperdir or lowerdir or workdir not a directory\n");
-		goto out_put_workpath;
+		goto out_put_lowerpath;
 	}
 
 	if (upperpath.mnt != workpath.mnt) {
 		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
-		goto out_put_workpath;
+		goto out_put_lowerpath;
 	}
 	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
-		goto out_put_workpath;
+		goto out_put_lowerpath;
 	}
 
 	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
 		pr_err("overlayfs: filesystem of upperdir is not supported\n");
-		goto out_put_workpath;
+		goto out_put_lowerpath;
 	}
 
 	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
 		pr_err("overlayfs: filesystem of lowerdir is not supported\n");
-		goto out_put_workpath;
+		goto out_put_lowerpath;
 	}
 
 	err = vfs_statfs(&lowerpath, &statfs);
 	if (err) {
 		pr_err("overlayfs: statfs failed on lowerpath\n");
-		goto out_put_workpath;
+		goto out_put_lowerpath;
 	}
 	ufs->lower_namelen = statfs.f_namelen;
 
@@ -806,19 +800,27 @@ static int ovl_fill_super(struct super_b
 	err = -EINVAL;
 	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
-		goto out_put_workpath;
+		goto out_put_lowerpath;
 	}
 
 	ufs->upper_mnt = clone_private_mount(&upperpath);
 	err = PTR_ERR(ufs->upper_mnt);
 	if (IS_ERR(ufs->upper_mnt)) {
 		pr_err("overlayfs: failed to clone upperpath\n");
-		goto out_put_workpath;
+		goto out_put_lowerpath;
+	}
+
+	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
+	err = PTR_ERR(ufs->workdir);
+	if (IS_ERR(ufs->workdir)) {
+		pr_err("overlayfs: failed to create directory %s/%s\n",
+		       ufs->config.workdir, OVL_WORKDIR_NAME);
+		goto out_put_upper_mnt;
 	}
 
 	ufs->lower_mnt = kcalloc(1, sizeof(struct vfsmount *), GFP_KERNEL);
 	if (ufs->lower_mnt == NULL)
-		goto out_put_upper_mnt;
+		goto out_put_workdir;
 
 	mnt = clone_private_mount(&lowerpath);
 	err = PTR_ERR(mnt);
@@ -835,14 +837,6 @@ static int ovl_fill_super(struct super_b
 	ufs->lower_mnt[0] = mnt;
 	ufs->numlower = 1;
 
-	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
-	err = PTR_ERR(ufs->workdir);
-	if (IS_ERR(ufs->workdir)) {
-		pr_err("overlayfs: failed to create directory %s/%s\n",
-		       ufs->config.workdir, OVL_WORKDIR_NAME);
-		goto out_put_lower_mnt;
-	}
-
 	/* If the upper fs is r/o, we mark overlayfs r/o too */
 	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
 		sb->s_flags |= MS_RDONLY;
@@ -850,13 +844,13 @@ static int ovl_fill_super(struct super_b
 	sb->s_d_op = &ovl_dentry_operations;
 
 	err = -ENOMEM;
-	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
-	if (!root_inode)
-		goto out_put_workdir;
+	oe = ovl_alloc_entry(1);
+	if (!oe)
+		goto out_put_lower_mnt;
 
-	root_dentry = d_make_root(root_inode);
+	root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, oe));
 	if (!root_dentry)
-		goto out_put_workdir;
+		goto out_free_oe;
 
 	mntput(upperpath.mnt);
 	mntput(lowerpath.mnt);
@@ -875,22 +869,22 @@ static int ovl_fill_super(struct super_b
 
 	return 0;
 
-out_put_workdir:
-	dput(ufs->workdir);
+out_free_oe:
+	kfree(oe);
 out_put_lower_mnt:
 	for (i = 0; i < ufs->numlower; i++)
 		mntput(ufs->lower_mnt[i]);
 	kfree(ufs->lower_mnt);
+out_put_workdir:
+	dput(ufs->workdir);
 out_put_upper_mnt:
 	mntput(ufs->upper_mnt);
-out_put_workpath:
-	path_put(&workpath);
 out_put_lowerpath:
 	path_put(&lowerpath);
+out_put_workpath:
+	path_put(&workpath);
 out_put_upperpath:
 	path_put(&upperpath);
-out_free_oe:
-	kfree(oe);
 out_free_config:
 	kfree(ufs->config.lowerdir);
 	kfree(ufs->config.upperdir);
