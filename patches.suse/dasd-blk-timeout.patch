From: Hannes Reinecke <hare@suse.de>
Date: Wed, 7 Mar 2012 10:42:48 +0100
Subject: [PATCH] dasd: Implement block timeout handling
Patch-Mainline: Not yet
References: bnc#746717

This patch implements generic block layer timeout handling
callbacks for DASDs. We now can set a fixed upper limit
to DASD requests, after which the I/O is either terminated
or completed.

It is currently activated by setting the 'failfast' attribute
to '2'. The timeout is then set to the value of the
'failfast_retries' attribute times the value of the
'failfast_expires' attribute.

Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/arch/s390/include/asm/dasd.h b/arch/s390/include/asm/dasd.h
index 0be28ef..d358057 100644
--- a/arch/s390/include/asm/dasd.h
+++ b/arch/s390/include/asm/dasd.h
@@ -83,6 +83,7 @@ typedef struct dasd_information2_t {
 #define DASD_FEATURE_FAILFAST	     0x10
 #define DASD_FEATURE_FAILONSLCK      0x20
 #define DASD_FEATURE_USERAW	     0x40
+#define DASD_FEATURE_BLKTIMEOUT     0x80
 
 #define DASD_PARTN_BITS 2
 
diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c
index a024bda..f1eae48 100644
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -1981,6 +1981,7 @@ static void __dasd_process_request_queue(struct dasd_block *block)
 		 */
 		cqr->callback_data = (void *) req;
 		cqr->status = DASD_CQR_FILLED;
+		req->completion_data = cqr;
 		blk_start_request(req);
 		list_add_tail(&cqr->blocklist, &block->ccw_queue);
 		dasd_profile_start(block, cqr, req);
@@ -2247,6 +2248,36 @@ static void do_dasd_request(struct request_queue *queue)
 	spin_unlock(&block->queue_lock);
 }
 
+enum blk_eh_timer_return dasd_times_out(struct request *req)
+{
+	struct dasd_ccw_req *cqr = req->completion_data;
+	struct dasd_block *block = req->q->queuedata;
+	int rc = 0;
+
+	if (!cqr)
+		return BLK_EH_NOT_HANDLED;
+	if (!(block->base->features & DASD_FEATURE_BLKTIMEOUT))
+		return BLK_EH_RESET_TIMER;
+	DBF_DEV_EVENT(DBF_WARNING, device,
+		      " dasd_times_out cqr %p status %x", cqr, cqr->status);
+	if (cqr->status >= DASD_CQR_QUEUED) {
+		rc = dasd_cancel_req(cqr);
+		if (rc)
+			return BLK_EH_RESET_TIMER;
+	}
+	/* Set final status */
+	cqr->endclk = get_clock();
+	cqr->status = DASD_CQR_FAILED;
+	cqr->intrc = -ETIME;
+	/* Un-thread from lists */
+	list_del_init(&cqr->blocklist);
+	list_del_init(&cqr->devlist);
+	/* cleanup cqr */
+	__dasd_cleanup_cqr(cqr);
+
+	return BLK_EH_NOT_HANDLED;
+}
+
 /*
  * Allocate and initialize request queue and default I/O scheduler.
  */
@@ -2277,6 +2308,7 @@ static int dasd_alloc_queue(struct dasd_block *block)
 static void dasd_setup_queue(struct dasd_block *block)
 {
 	int max;
+	unsigned int timeout;
 
 	if (block->base->features & DASD_FEATURE_USERAW) {
 		/*
@@ -2299,6 +2331,14 @@ static void dasd_setup_queue(struct dasd_block *block)
 	 */
 	blk_queue_max_segment_size(block->request_queue, PAGE_SIZE);
 	blk_queue_segment_boundary(block->request_queue, PAGE_SIZE - 1);
+	blk_queue_rq_timed_out(block->request_queue, dasd_times_out);
+	/*
+	 * We always set the failfast timeout;
+	 * dasd_times_out() will ignore requests when failfast
+	 * is not enabled.
+	 */
+	timeout = block->base->failfast_expires * block->base->failfast_retries;
+	blk_queue_rq_timeout(block->request_queue, timeout * HZ);
 }
 
 /*
diff --git a/drivers/s390/block/dasd_devmap.c b/drivers/s390/block/dasd_devmap.c
index 9bb58d9..d062fa1 100644
--- a/drivers/s390/block/dasd_devmap.c
+++ b/drivers/s390/block/dasd_devmap.c
@@ -718,11 +718,13 @@ static ssize_t dasd_ff_show(struct device *dev, struct device_attribute *attr,
 	int ff_flag;
 
 	devmap = dasd_find_busid(dev_name(dev));
-	if (!IS_ERR(devmap))
+	if (!IS_ERR(devmap)) {
 		ff_flag = (devmap->features & DASD_FEATURE_FAILFAST) != 0;
-	else
+		if (ff_flag && devmap->features & DASD_FEATURE_BLKTIMEOUT)
+			ff_flag = 2;
+	} else
 		ff_flag = (DASD_FEATURE_DEFAULT & DASD_FEATURE_FAILFAST) != 0;
-	return snprintf(buf, PAGE_SIZE, ff_flag ? "1\n" : "0\n");
+	return snprintf(buf, PAGE_SIZE, "%d\n", ff_flag);
 }
 
 static ssize_t dasd_ff_store(struct device *dev, struct device_attribute *attr,
@@ -737,14 +739,18 @@ static ssize_t dasd_ff_store(struct device *dev, struct device_attribute *attr,
 		return PTR_ERR(devmap);
 
 	val = simple_strtoul(buf, &endp, 0);
-	if (((endp + 1) < (buf + count)) || (val > 1))
+	if (((endp + 1) < (buf + count)) || (val > 2))
 		return -EINVAL;
 
 	spin_lock(&dasd_devmap_lock);
-	if (val)
+	if (val) {
+		if (val > 1)
+			devmap->features |= DASD_FEATURE_BLKTIMEOUT;
 		devmap->features |= DASD_FEATURE_FAILFAST;
-	else
+	} else {
 		devmap->features &= ~DASD_FEATURE_FAILFAST;
+		devmap->features &= ~DASD_FEATURE_BLKTIMEOUT;
+	}
 	if (devmap->device)
 		devmap->device->features = devmap->features;
 	spin_unlock(&dasd_devmap_lock);
@@ -1232,7 +1238,7 @@ dasd_failfast_expires_store(struct device *dev, struct device_attribute *attr,
 	       const char *buf, size_t count)
 {
 	struct dasd_device *device;
-	unsigned long val;
+	unsigned long val, timeout;
 
 	device = dasd_device_from_cdev(to_ccwdev(dev));
 	if (IS_ERR(device))
@@ -1244,8 +1250,11 @@ dasd_failfast_expires_store(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	}
 
-	if (val)
+	if (val) {
 		device->failfast_expires = val;
+		timeout = val * device->failfast_retries;
+		blk_queue_rq_timeout(device->block->request_queue, timeout * HZ);
+	}
 
 	dasd_put_device(device);
 	return count;
@@ -1314,7 +1323,7 @@ dasd_failfast_retries_store(struct device *dev, struct device_attribute *attr,
 	       const char *buf, size_t count)
 {
 	struct dasd_device *device;
-	unsigned long val;
+	unsigned long val, timeout;
 
 	device = dasd_device_from_cdev(to_ccwdev(dev));
 	if (IS_ERR(device))
@@ -1326,8 +1335,11 @@ dasd_failfast_retries_store(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	}
 
-	if (val)
+	if (val) {
 		device->failfast_retries = val;
+		timeout = val * device->failfast_expires;
+		blk_queue_rq_timeout(device->block->request_queue, timeout * HZ);
+	}
 
 	dasd_put_device(device);
 	return count;
diff --git a/drivers/s390/block/dasd_diag.c b/drivers/s390/block/dasd_diag.c
index 287c645..93d1549 100644
--- a/drivers/s390/block/dasd_diag.c
+++ b/drivers/s390/block/dasd_diag.c
@@ -566,13 +566,8 @@ static struct dasd_ccw_req *dasd_diag_build_cp(struct dasd_device *memdev,
 	cqr->startdev = memdev;
 	cqr->memdev = memdev;
 	cqr->block = block;
-	if (req->cmd_flags & REQ_FAILFAST_DEV) {
-		cqr->expires = memdev->failfast_expires * HZ;
-		cqr->retries = memdev->failfast_retries;
-	} else {
-		cqr->expires = memdev->default_expires * HZ;
-		cqr->retries = memdev->default_retries;
-	}
+	cqr->expires = memdev->default_expires * HZ;
+	cqr->retries = memdev->default_retries;
 	cqr->status = DASD_CQR_FILLED;
 	return cqr;
 }
diff --git a/drivers/s390/block/dasd_eckd.c b/drivers/s390/block/dasd_eckd.c
index 510be62..aaaf9a7 100644
--- a/drivers/s390/block/dasd_eckd.c
+++ b/drivers/s390/block/dasd_eckd.c
@@ -2292,13 +2292,8 @@ static struct dasd_ccw_req *dasd_eckd_build_cp_cmd_single(
 	cqr->startdev = startdev;
 	cqr->memdev = startdev;
 	cqr->block = block;
-	if (req->cmd_flags & REQ_FAILFAST_DEV) {
-		cqr->expires = startdev->failfast_expires * HZ;
-		cqr->retries = startdev->failfast_retries;
-	} else {
-		cqr->expires = startdev->default_expires * HZ;
-		cqr->retries = startdev->default_retries;
-	}
+	cqr->expires = startdev->default_expires * HZ;
+	cqr->retries = startdev->default_retries;
 	cqr->lpm = startdev->path_data.ppm;
 	cqr->buildclk = get_clock();
 	cqr->status = DASD_CQR_FILLED;
@@ -2472,13 +2467,8 @@ static struct dasd_ccw_req *dasd_eckd_build_cp_cmd_track(
 	cqr->startdev = startdev;
 	cqr->memdev = startdev;
 	cqr->block = block;
-	if (req->cmd_flags & REQ_FAILFAST_DEV) {
-		cqr->expires = startdev->failfast_expires * HZ;
-		cqr->retries = startdev->failfast_retries;
-	} else {
-		cqr->expires = startdev->default_expires * HZ;
-		cqr->retries = startdev->default_retries;
-	}
+	cqr->expires = startdev->default_expires * HZ;
+	cqr->retries = startdev->default_retries;
 	cqr->lpm = startdev->path_data.ppm;
 	cqr->buildclk = get_clock();
 	cqr->status = DASD_CQR_FILLED;
@@ -2765,13 +2755,8 @@ static struct dasd_ccw_req *dasd_eckd_build_cp_tpm_track(
 	cqr->startdev = startdev;
 	cqr->memdev = startdev;
 	cqr->block = block;
-	if (req->cmd_flags & REQ_FAILFAST_DEV) {
-		cqr->expires = startdev->failfast_expires * HZ;
-		cqr->retries = startdev->failfast_retries;
-	} else {
-		cqr->expires = startdev->default_expires * HZ;
-		cqr->retries = startdev->default_retries;
-	}
+	cqr->expires = startdev->default_expires * HZ;
+	cqr->retries = startdev->default_retries;
 	cqr->lpm = startdev->path_data.ppm;
 	cqr->buildclk = get_clock();
 	cqr->status = DASD_CQR_FILLED;
@@ -2970,13 +2955,8 @@ static struct dasd_ccw_req *dasd_raw_build_cp(struct dasd_device *startdev,
 	cqr->startdev = startdev;
 	cqr->memdev = startdev;
 	cqr->block = block;
-	if (req->cmd_flags & REQ_FAILFAST_DEV) {
-		cqr->expires = startdev->failfast_expires * HZ;
-		cqr->retries = startdev->failfast_retries;
-	} else {
-		cqr->expires = startdev->default_expires * HZ;
-		cqr->retries = startdev->default_retries;
-	}
+	cqr->expires = startdev->default_expires * HZ;
+	cqr->retries = startdev->default_retries;
 	cqr->lpm = startdev->path_data.ppm;
 	cqr->buildclk = get_clock();
 	cqr->status = DASD_CQR_FILLED;
diff --git a/drivers/s390/block/dasd_fba.c b/drivers/s390/block/dasd_fba.c
index 839df09..3a3bb2a 100644
--- a/drivers/s390/block/dasd_fba.c
+++ b/drivers/s390/block/dasd_fba.c
@@ -372,13 +372,8 @@ static struct dasd_ccw_req *dasd_fba_build_cp(struct dasd_device * memdev,
 	cqr->startdev = memdev;
 	cqr->memdev = memdev;
 	cqr->block = block;
-	if (req->cmd_flags & REQ_FAILFAST_DEV) {
-		cqr->expires = memdev->failfast_expires * HZ;
-		cqr->retries = memdev->failfast_retries;
-	} else {
-		cqr->expires = memdev->default_expires * HZ;
-		cqr->retries = memdev->default_retries;
-	}
+	cqr->expires = memdev->default_expires * HZ;
+	cqr->retries = memdev->default_retries;
 	cqr->buildclk = get_clock();
 	cqr->status = DASD_CQR_FILLED;
 	return cqr;
