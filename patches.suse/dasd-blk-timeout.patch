From: Hannes Reinecke <hare@suse.de>
Date: Wed, 7 Mar 2012 10:42:48 +0100
Subject: [PATCH] dasd: Implement block timeout handling
Patch-Mainline: Not yet
References: bnc#746717

This patch implements generic block layer timeout handling
callbacks for DASDs. We now can set a fixed upper limit
to DASD requests, after which the I/O is either terminated
or completed.

It is currently activated by setting bit 2 of the 'failfast'
attribute. Bit 1 continues to activate the normal 'failfast'
behaviour. The timeout is then set to the value of the
'failfast_retries' attribute times the value of the
'failfast_expires' attribute.

Signed-off-by: Hannes Reinecke <hare@suse.de>
Acked-by: Stefan Weinhuber <wein@de.ibm.com>

diff --git a/arch/s390/include/asm/dasd.h b/arch/s390/include/asm/dasd.h
index 0be28ef..d358057 100644
--- a/arch/s390/include/asm/dasd.h
+++ b/arch/s390/include/asm/dasd.h
@@ -83,6 +83,7 @@ typedef struct dasd_information2_t {
 #define DASD_FEATURE_FAILFAST	     0x10
 #define DASD_FEATURE_FAILONSLCK      0x20
 #define DASD_FEATURE_USERAW	     0x40
+#define DASD_FEATURE_BLKTIMEOUT     0x80
 
 #define DASD_PARTN_BITS 2
 
diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c
index a024bda..2964814 100644
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -1981,8 +1981,10 @@ static void __dasd_process_request_queue(struct dasd_block *block)
 		 */
 		cqr->callback_data = (void *) req;
 		cqr->status = DASD_CQR_FILLED;
+		req->completion_data = cqr;
 		blk_start_request(req);
 		list_add_tail(&cqr->blocklist, &block->ccw_queue);
+		INIT_LIST_HEAD(&cqr->devlist);
 		dasd_profile_start(block, cqr, req);
 	}
 }
@@ -2248,6 +2250,52 @@ static void do_dasd_request(struct request_queue *queue)
 }
 
 /*
+ * Block timeout callback, called from the block layer
+ *
+ * request_queue lock is held on entry.
+ *
+ * Return values:
+ * BLK_EH_RESET_TIMER if the request should be left running
+ * BLK_EH_NOT_HANDLED if the request is handled or terminated
+ *                    by the driver.
+ * BLK_EH_HANDLED     if the request should be aborted by
+ *                    the block layer.
+ */
+enum blk_eh_timer_return dasd_times_out(struct request *req)
+{
+	struct dasd_ccw_req *cqr = req->completion_data;
+	struct dasd_block *block = req->q->queuedata;
+	struct dasd_device *device;
+
+	if (!cqr)
+		return BLK_EH_NOT_HANDLED;
+
+	if (!test_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags))
+		return BLK_EH_RESET_TIMER;
+
+	device = cqr->startdev ? cqr->startdev : block->base;
+	DBF_DEV_EVENT(DBF_WARNING, device,
+		      " dasd_times_out cqr %p status %x",
+		      cqr, cqr->status);
+	/* Wait for ERP to finish */
+	if (cqr->status == DASD_CQR_IN_ERP)
+		return BLK_EH_RESET_TIMER;
+	spin_lock(get_ccwdev_lock(device->cdev));
+	cqr->retries = -1;
+	list_del(&cqr->devlist);
+	spin_unlock(get_ccwdev_lock(device->cdev));
+	if (cqr->status >= DASD_CQR_QUEUED) {
+		if (dasd_cancel_req(cqr))
+			return BLK_EH_RESET_TIMER;
+	} else if (cqr->status == DASD_CQR_FILLED ||
+		   cqr->status == DASD_CQR_NEED_ERP)
+		cqr->status = DASD_CQR_TERMINATED;
+
+	dasd_schedule_block_bh(block);
+	return BLK_EH_NOT_HANDLED;
+}
+
+/*
  * Allocate and initialize request queue and default I/O scheduler.
  */
 static int dasd_alloc_queue(struct dasd_block *block)
@@ -2277,6 +2325,7 @@ static int dasd_alloc_queue(struct dasd_block *block)
 static void dasd_setup_queue(struct dasd_block *block)
 {
 	int max;
+	unsigned int timeout;
 
 	if (block->base->features & DASD_FEATURE_USERAW) {
 		/*
@@ -2299,6 +2348,14 @@ static void dasd_setup_queue(struct dasd_block *block)
 	 */
 	blk_queue_max_segment_size(block->request_queue, PAGE_SIZE);
 	blk_queue_segment_boundary(block->request_queue, PAGE_SIZE - 1);
+	blk_queue_rq_timed_out(block->request_queue, dasd_times_out);
+	/*
+	 * We always set the failfast timeout;
+	 * dasd_times_out() will ignore requests when failfast
+	 * is not enabled.
+	 */
+	timeout = block->base->failfast_expires * block->base->failfast_retries;
+	blk_queue_rq_timeout(block->request_queue, timeout * HZ);
 }
 
 /*
diff --git a/drivers/s390/block/dasd_devmap.c b/drivers/s390/block/dasd_devmap.c
index 9bb58d9..61e0707 100644
--- a/drivers/s390/block/dasd_devmap.c
+++ b/drivers/s390/block/dasd_devmap.c
@@ -214,6 +214,8 @@ dasd_feature_list(char *str, char **endp)
 			features |= DASD_FEATURE_ERPLOG;
 		else if (len == 8 && !strncmp(str, "failfast", 8))
 			features |= DASD_FEATURE_FAILFAST;
+		else if (len == 10 && !strncmp(str, "blktimeout", 10))
+			features |= DASD_FEATURE_BLKTIMEOUT;
 		else {
 			pr_warning("%*s is not a supported device option\n",
 				   len, str);
@@ -715,14 +717,17 @@ static ssize_t dasd_ff_show(struct device *dev, struct device_attribute *attr,
 			    char *buf)
 {
 	struct dasd_devmap *devmap;
-	int ff_flag;
+	int ff_flag = 0;
 
 	devmap = dasd_find_busid(dev_name(dev));
-	if (!IS_ERR(devmap))
-		ff_flag = (devmap->features & DASD_FEATURE_FAILFAST) != 0;
-	else
+	if (!IS_ERR(devmap)) {
+		if (devmap->features & DASD_FEATURE_FAILFAST)
+			ff_flag |= 1;
+		if (devmap->features & DASD_FEATURE_BLKTIMEOUT)
+			ff_flag |= 2;
+	} else
 		ff_flag = (DASD_FEATURE_DEFAULT & DASD_FEATURE_FAILFAST) != 0;
-	return snprintf(buf, PAGE_SIZE, ff_flag ? "1\n" : "0\n");
+	return snprintf(buf, PAGE_SIZE, "%d\n", ff_flag);
 }
 
 static ssize_t dasd_ff_store(struct device *dev, struct device_attribute *attr,
@@ -737,11 +742,15 @@ static ssize_t dasd_ff_store(struct device *dev, struct device_attribute *attr,
 		return PTR_ERR(devmap);
 
 	val = simple_strtoul(buf, &endp, 0);
-	if (((endp + 1) < (buf + count)) || (val > 1))
+	if (((endp + 1) < (buf + count)) || (val > 3))
 		return -EINVAL;
 
 	spin_lock(&dasd_devmap_lock);
-	if (val)
+	if (val & 2)
+		devmap->features |= DASD_FEATURE_BLKTIMEOUT;
+	else
+		devmap->features &= ~DASD_FEATURE_BLKTIMEOUT;
+	if (val & 1)
 		devmap->features |= DASD_FEATURE_FAILFAST;
 	else
 		devmap->features &= ~DASD_FEATURE_FAILFAST;
@@ -1232,7 +1241,7 @@ dasd_failfast_expires_store(struct device *dev, struct device_attribute *attr,
 	       const char *buf, size_t count)
 {
 	struct dasd_device *device;
-	unsigned long val;
+	unsigned long val, timeout;
 
 	device = dasd_device_from_cdev(to_ccwdev(dev));
 	if (IS_ERR(device))
@@ -1244,8 +1253,11 @@ dasd_failfast_expires_store(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	}
 
-	if (val)
+	if (val) {
 		device->failfast_expires = val;
+		timeout = val * device->failfast_retries;
+		blk_queue_rq_timeout(device->block->request_queue, timeout * HZ);
+	}
 
 	dasd_put_device(device);
 	return count;
@@ -1314,7 +1326,7 @@ dasd_failfast_retries_store(struct device *dev, struct device_attribute *attr,
 	       const char *buf, size_t count)
 {
 	struct dasd_device *device;
-	unsigned long val;
+	unsigned long val, timeout;
 
 	device = dasd_device_from_cdev(to_ccwdev(dev));
 	if (IS_ERR(device))
@@ -1326,8 +1338,11 @@ dasd_failfast_retries_store(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	}
 
-	if (val)
+	if (val) {
 		device->failfast_retries = val;
+		timeout = val * device->failfast_expires;
+		blk_queue_rq_timeout(device->block->request_queue, timeout * HZ);
+	}
 
 	dasd_put_device(device);
 	return count;
diff --git a/drivers/s390/block/dasd_diag.c b/drivers/s390/block/dasd_diag.c
index 287c645..c604361 100644
--- a/drivers/s390/block/dasd_diag.c
+++ b/drivers/s390/block/dasd_diag.c
@@ -591,7 +591,10 @@ dasd_diag_free_cp(struct dasd_ccw_req *cqr, struct request *req)
 
 static void dasd_diag_handle_terminated_request(struct dasd_ccw_req *cqr)
 {
-	cqr->status = DASD_CQR_FILLED;
+	if (cqr->retries < 0)
+		cqr->status = DASD_CQR_FAILED;
+	else
+		cqr->status = DASD_CQR_FILLED;
 };
 
 /* Fill in IOCTL data for device. */
diff --git a/drivers/s390/block/dasd_eckd.c b/drivers/s390/block/dasd_eckd.c
index 1fab77a..6dd044a 100644
--- a/drivers/s390/block/dasd_eckd.c
+++ b/drivers/s390/block/dasd_eckd.c
@@ -2017,6 +2017,10 @@ dasd_eckd_format_device(struct dasd_device * device,
 
 static void dasd_eckd_handle_terminated_request(struct dasd_ccw_req *cqr)
 {
+	if (cqr->retries < 0) {
+		cqr->status = DASD_CQR_FAILED;
+		return;
+	}
 	cqr->status = DASD_CQR_FILLED;
 	if (cqr->block && (cqr->startdev != cqr->block->base)) {
 		dasd_eckd_reset_ccw_to_base_io(cqr);
diff --git a/drivers/s390/block/dasd_fba.c b/drivers/s390/block/dasd_fba.c
index 839df09..7257a52 100644
--- a/drivers/s390/block/dasd_fba.c
+++ b/drivers/s390/block/dasd_fba.c
@@ -434,7 +434,10 @@ out:
 
 static void dasd_fba_handle_terminated_request(struct dasd_ccw_req *cqr)
 {
-	cqr->status = DASD_CQR_FILLED;
+	if (cqr->retries < 0)
+		cqr->status = DASD_CQR_FAILED;
+	else
+		cqr->status = DASD_CQR_FILLED;
 };
 
 static int
