From: Hannes Reinecke <hare@suse.de>
Date: Mon, 9 Jul 2012 16:35:43 +0200
Subject: dasd: Fail all requests after timeout
References: bnc#768084
Patch-Mainline: n/a

Whenever a DASD request encounters a timeout we need to abort
all outstanding requests if the FAILFAST flag is set.
Otherwise we will continue submitting requests until MD
sets the device to 'faulty'. And as MD has to wait for
the last I/O on the faulty device to finish we'll actually
have to wait for two times the pre-defined timeout.

So what we're doing now is setting a new stop flag
DASD_STOPPED_TIMEOUT, which is getting removed after
dasd_block_tasklet has run.
This ensures that all requests have been flushed.

Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c
index 2119c66..170b366 100644
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -1396,7 +1396,11 @@ static void __dasd_device_start_head(struct dasd_device *device)
 	if (device->stopped &&
 	    !(!(device->stopped & ~(DASD_STOPPED_DC_WAIT | DASD_UNRESUMED_PM))
 	      && test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags))) {
-		cqr->intrc = -EAGAIN;
+		if (device->stopped & DASD_STOPPED_TIMEOUT) {
+			cqr->retries = -1;
+			cqr->intrc = -ETIMEDOUT;
+		} else
+			cqr->intrc = -EAGAIN;
 		cqr->status = DASD_CQR_CLEARED;
 		dasd_schedule_device_bh(device);
 		return;
@@ -1944,6 +1948,13 @@ static void __dasd_process_request_queue(struct dasd_block *block)
 			__blk_end_request_all(req, -EIO);
 			continue;
 		}
+		if ((basedev->stopped & DASD_STOPPED_TIMEOUT) &&
+		    (basedev->features & DASD_FEATURE_FAILFAST) &&
+		    blk_noretry_request(req)) {
+			blk_start_request(req);
+			__blk_end_request_all(req, -ETIMEDOUT);
+			continue;
+		}
 		cqr = basedev->discipline->build_cp(basedev, block, req);
 		if (IS_ERR(cqr)) {
 			if (PTR_ERR(cqr) == -EBUSY)
@@ -2089,8 +2100,11 @@ static void __dasd_block_start_head(struct dasd_block *block)
 {
 	struct dasd_ccw_req *cqr;
 
-	if (list_empty(&block->ccw_queue))
+	if (list_empty(&block->ccw_queue)) {
+		dasd_device_remove_stop_bits(block->base, DASD_STOPPED_TIMEOUT);
 		return;
+	}
+
 	/* We allways begin with the first requests on the queue, as some
 	 * of previously started requests have to be enqueued on a
 	 * dasd_device again for error recovery.
@@ -2110,12 +2124,16 @@ static void __dasd_block_start_head(struct dasd_block *block)
 		    test_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags) &&
 		    (!dasd_eer_enabled(block->base))) {
 			cqr->status = DASD_CQR_FAILED;
-			cqr->intrc = -ENOLINK;
+			if (block->base->stopped & DASD_STOPPED_TIMEOUT) {
+				cqr->retries = -1;
+				cqr->intrc = -ETIMEDOUT;
+			} else
+				cqr->intrc = -ENOLINK;
 			dasd_schedule_block_bh(block);
 			continue;
 		}
 		/* Don't try to start requests if device is stopped */
-		if (block->base->stopped)
+		if (block->base->stopped & ~DASD_STOPPED_TIMEOUT)
 			return;
 
 		/* just a fail safe check, should not happen */
@@ -2127,6 +2145,7 @@ static void __dasd_block_start_head(struct dasd_block *block)
 
 		dasd_add_request_tail(cqr);
 	}
+	dasd_device_remove_stop_bits(block->base, DASD_STOPPED_TIMEOUT);
 }
 
 /*
@@ -2292,6 +2311,7 @@ enum blk_eh_timer_return dasd_times_out(struct request *req)
 	spin_lock(get_ccwdev_lock(device->cdev));
 	cqr->retries = -1;
 	cqr->intrc = -ETIMEDOUT;
+	dasd_device_set_stop_bits(device, DASD_STOPPED_TIMEOUT);
 	spin_unlock(get_ccwdev_lock(device->cdev));
 	if (cqr->status >= DASD_CQR_QUEUED) {
 		rc = dasd_cancel_req(cqr);
diff --git a/drivers/s390/block/dasd_int.h b/drivers/s390/block/dasd_int.h
index bd48b60..de9e30d 100644
--- a/drivers/s390/block/dasd_int.h
+++ b/drivers/s390/block/dasd_int.h
@@ -475,6 +475,7 @@ struct dasd_block {
 #define DASD_STOPPED_SU      16        /* summary unit check handling */
 #define DASD_STOPPED_PM      32        /* pm state transition */
 #define DASD_UNRESUMED_PM    64        /* pm resume failed state */
+#define DASD_STOPPED_TIMEOUT 128       /* device timeout */
 
 /* per device flags */
 #define DASD_FLAG_OFFLINE	3	/* device is in offline processing */
