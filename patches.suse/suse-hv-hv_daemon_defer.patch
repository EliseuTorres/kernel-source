Subject: hyperv: Negotiate version with the host without waiting for the daemon
From: <kys@microsoft.com>
Patch-mainline: Never
References: bnc#930821

The daemons have to be started within a certain timeframe to negotiate
with the host. If they are started later the host will timeout and the
given service will be unavailabe.

Do the negotiation with the host once the daemon actually connects.

Acked-by: <ohering@suse.de>

diff --git a/drivers/hv/hv_fcopy.c b/drivers/hv/hv_fcopy.c
index cd453e4..fa96db3 100644
--- a/drivers/hv/hv_fcopy.c
+++ b/drivers/hv/hv_fcopy.c
@@ -239,6 +239,7 @@ void hv_fcopy_onchannelcallback(void *context)
 		fcopy_srv_version = WIN8_SRV_VERSION;
 		vmbus_prep_negotiate_resp(icmsghdr, negop, recv_buffer,
 				util_fw_version, fcopy_srv_version);
+		fcopy_transaction.active = true;
 	} else {
 		fcopy_msg = (struct hv_fcopy_hdr *)&recv_buffer[
 				sizeof(struct vmbuspipe_hdr) +
@@ -428,7 +429,6 @@ int hv_fcopy_init(struct hv_util_service *srv)
 	 * Defer processing channel callbacks until the daemon
 	 * has registered.
 	 */
-	fcopy_transaction.active = true;
 	sema_init(&fcopy_transaction.read_sema, 0);
 
 	return fcopy_dev_init();
diff --git a/drivers/hv/hv_kvp.c b/drivers/hv/hv_kvp.c
index 6fb3a76..5c52dd4 100644
--- a/drivers/hv/hv_kvp.c
+++ b/drivers/hv/hv_kvp.c
@@ -650,6 +650,7 @@ void hv_kvp_onchannelcallback(void *context)
 			vmbus_prep_negotiate_resp(icmsghdrp, negop,
 				 recv_buffer, util_fw_version,
 				 kvp_srv_version);
+			kvp_transaction.active = true;
 
 		} else {
 			kvp_msg = (struct hv_kvp_msg *)&recv_buffer[
@@ -709,7 +710,6 @@ hv_kvp_init(struct hv_util_service *srv)
 	 * Defer processing channel callbacks until the daemon
 	 * has registered.
 	 */
-	kvp_transaction.active = true;
 
 	return 0;
 }
diff --git a/drivers/hv/hv_snapshot.c b/drivers/hv/hv_snapshot.c
index e24bc71..ba2c98b 100644
--- a/drivers/hv/hv_snapshot.c
+++ b/drivers/hv/hv_snapshot.c
@@ -211,6 +211,7 @@ void hv_vss_onchannelcallback(void *context)
 			vmbus_prep_negotiate_resp(icmsghdrp, negop,
 				 recv_buffer, UTIL_FW_VERSION,
 				 VSS_VERSION);
+			vss_transaction.active = true;
 		} else {
 			vss_msg = (struct hv_vss_msg *)&recv_buffer[
 				sizeof(struct vmbuspipe_hdr) +
@@ -291,7 +292,6 @@ hv_vss_init(struct hv_util_service *srv)
 	 * Defer processing channel callbacks until the daemon
 	 * has registered.
 	 */
-	vss_transaction.active = true;
 	return 0;
 }
 
