From: Hannes Reinecke <hare@suse.de>
Date: Mon, 30 Jul 2012 15:08:04 +0200
Subject: dasd: Fail all requests on dasd_times_out()
References: bnc#768084
Patch-Mainline: n/a

Whenever a request incurs a timeout it's affecting all
outstanding requests, not just the one receiving the timeout.
So we need to abort all noretry requests on dasd_times_out()
to avoid incurring additional timeouts.

Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c
index b22a142..a08756c 100644
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -2282,60 +2282,58 @@ static void do_dasd_request(struct request_queue *queue)
 enum blk_eh_timer_return dasd_times_out(struct request *req)
 {
 	struct dasd_ccw_req *cqr = req->completion_data;
-	struct dasd_block *block = req->q->queuedata;
+	struct request_queue *queue = req->q;
+	struct dasd_block *block = queue->queuedata;
 	struct dasd_device *device;
+	struct dasd_ccw_req *searchcqr, *nextcqr;
 	int rc = 0;
 
 	if (!cqr)
 		return BLK_EH_NOT_HANDLED;
 
-	if (!test_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags))
-		return BLK_EH_RESET_TIMER;
-
 	device = cqr->startdev ? cqr->startdev : block->base;
-	DBF_DEV_EVENT(DBF_WARNING, device,
-		      " dasd_times_out cqr %p status %x",
-		      cqr, cqr->status);
 
 	spin_lock(&block->queue_lock);
-	spin_lock(get_ccwdev_lock(device->cdev));
-	cqr->retries = -1;
-	cqr->intrc = -ETIMEDOUT;
-	spin_unlock(get_ccwdev_lock(device->cdev));
-	if (cqr->status >= DASD_CQR_QUEUED) {
-		rc = dasd_cancel_req(cqr);
-	} else if (cqr->status == DASD_CQR_FILLED ||
-		   cqr->status == DASD_CQR_NEED_ERP) {
-		cqr->status = DASD_CQR_TERMINATED;
-	} else if (cqr->status == DASD_CQR_IN_ERP) {
-		struct dasd_ccw_req *searchcqr, *nextcqr, *tmpcqr;
-
-		list_for_each_entry_safe(searchcqr, nextcqr,
-					 &block->ccw_queue, blocklist) {
-			tmpcqr = searchcqr;
-			while (tmpcqr->refers)
-				tmpcqr = tmpcqr->refers;
-			if (tmpcqr != cqr)
-				continue;
-			/* searchcqr is an ERP request for cqr */
-			spin_lock(get_ccwdev_lock(device->cdev));
-			searchcqr->retries = -1;
-			searchcqr->intrc = -ETIMEDOUT;
-			spin_unlock(get_ccwdev_lock(device->cdev));
-			if (searchcqr->status >= DASD_CQR_QUEUED) {
-				rc = dasd_cancel_req(searchcqr);
-			} else if ((searchcqr->status == DASD_CQR_FILLED) ||
-				   (searchcqr->status == DASD_CQR_NEED_ERP)) {
-				searchcqr->status = DASD_CQR_TERMINATED;
-				rc = 0;
-			} else if (searchcqr->status == DASD_CQR_IN_ERP) {
-				/*
-				 * Shouldn't happen; most recent ERP
-				 * request is at the front of queue
-				 */
-				continue;
-			}
-			break;
+
+	/* Abort all requests in the queue */
+	list_for_each_entry_safe(searchcqr, nextcqr,
+				 &block->ccw_queue, blocklist) {
+		/*
+		 * Ignore all requests with final status;
+		 * requests with DASD_CQR_NEED_ERP will
+		 * also be aborted as ERP shouldn't be invoked.
+		 */
+		if (searchcqr->status == DASD_CQR_DONE ||
+		    searchcqr->status == DASD_CQR_FAILED ||
+		    searchcqr->status == DASD_CQR_TERMINATED)
+			continue;
+		/*
+		 * Only abort requests with failfast set.
+		 */
+		if (searchcqr->callback_data &&
+		    searchcqr->callback_data != DASD_SLEEPON_END_TAG &&
+		    searchcqr->callback_data != DASD_SLEEPON_START_TAG)
+			req = searchcqr->callback_data;
+		if (!req || !blk_noretry_request(req))
+			continue;
+		DBF_DEV_EVENT(DBF_WARNING, device,
+			      "dasd_times_out cqr %p status %x",
+			      searchcqr, searchcqr->status);
+		spin_lock(get_ccwdev_lock(device->cdev));
+		searchcqr->retries = -1;
+		searchcqr->intrc = -ETIMEDOUT;
+		spin_unlock(get_ccwdev_lock(device->cdev));
+		if (searchcqr->status >= DASD_CQR_QUEUED) {
+			rc = dasd_cancel_req(searchcqr);
+		} else if ((searchcqr->status == DASD_CQR_FILLED) ||
+			   (searchcqr->status == DASD_CQR_NEED_ERP)) {
+			searchcqr->status = DASD_CQR_TERMINATED;
+			rc = 0;
+		} else if (searchcqr->status == DASD_CQR_IN_ERP) {
+			/*
+			 * Ignore, will be terminated once
+			 * the related cqrs are finished.
+			 */
 		}
 	}
 	dasd_schedule_block_bh(block);
