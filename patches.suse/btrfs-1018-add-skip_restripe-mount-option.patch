From 353ff954f82f3b5971833f67063863439c486a02 Mon Sep 17 00:00:00 2001
From: Ilya Dryomov <idryomov@gmail.com>
Date: Wed, 12 Oct 2011 10:09:43 +0300
Patch-mainline: pending
References: FATE#306586
Subject: [PATCH] Btrfs: add skip_restripe mount option

Since restriper kthread starts involuntarily on mount and can suck cpu
and memory bandwidth add a mount option to forcefully skip it.  The
restriper in that case hangs around in paused state and can be resumed
from userspace when it's convenient.

Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/ctree.h   |    1 +
 fs/btrfs/super.c   |    7 +++++++
 fs/btrfs/volumes.c |   15 +++++++++++++--
 3 files changed, 21 insertions(+), 2 deletions(-)

--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -1486,6 +1486,7 @@ struct btrfs_ioctl_defrag_range_args {
 #define BTRFS_MOUNT_INODE_MAP_CACHE	(1 << 17)
 #define BTRFS_MOUNT_RECOVERY		(1 << 18)
 #define BTRFS_MOUNT_PANIC_ON_FATAL_ERROR	(1 << 19)
+#define BTRFS_MOUNT_SKIP_RESTRIPE	(1 << 20)
 
 #define btrfs_clear_opt(o, opt)		((o) &= ~BTRFS_MOUNT_##opt)
 #define btrfs_set_opt(o, opt)		((o) |= BTRFS_MOUNT_##opt)
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -198,6 +198,7 @@ enum {
 	Opt_space_cache, Opt_clear_cache, Opt_user_subvol_rm_allowed,
 	Opt_enospc_debug, Opt_subvolrootid, Opt_defrag,
 	Opt_inode_cache, Opt_no_space_cache, Opt_recovery, Opt_fatal_errors,
+	Opt_skip_restripe,
 	Opt_err,
 };
 
@@ -234,6 +235,7 @@ static match_table_t tokens = {
 	{Opt_no_space_cache, "nospace_cache"},
 	{Opt_recovery, "recovery"},
 	{Opt_fatal_errors, "fatal_errors=%s"},
+	{Opt_skip_restripe, "skip_restripe"},
 	{Opt_err, NULL},
 };
 
@@ -444,6 +446,9 @@ int btrfs_parse_options(struct btrfs_roo
 				goto out;
 			}
 			break;
+		case Opt_skip_restripe:
+			btrfs_set_opt(info->mount_opt, SKIP_RESTRIPE);
+			break;
 		case Opt_err:
 			printk(KERN_INFO "btrfs: unrecognized mount option "
 			       "'%s'\n", p);
@@ -771,6 +776,8 @@ static int btrfs_show_options(struct seq
 		seq_puts(seq, ",inode_cache");
 	if (btrfs_test_opt(root, PANIC_ON_FATAL_ERROR))
 		seq_puts(seq, ",fatal_errors=panic");
+	if (btrfs_test_opt(root, SKIP_RESTRIPE))
+		seq_puts(seq, ",skip_restripe");
 	return 0;
 }
 
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -2779,13 +2779,24 @@ static int restriper_kthread(void *data)
 {
 	struct restripe_control *rctl = (struct restripe_control *)data;
 	struct btrfs_fs_info *fs_info = rctl->fs_info;
-	int ret;
+	int ret = 0;
 
 	mutex_lock(&fs_info->restripe_mutex);
 
-	printk(KERN_INFO "btrfs: continuing restripe\n");
+	if (btrfs_test_opt(fs_info->tree_root, SKIP_RESTRIPE)) {
+		mutex_lock(&fs_info->volume_mutex);
+		set_restripe_control(rctl, 0);
+		mutex_unlock(&fs_info->volume_mutex);
+
+		printk(KERN_INFO "btrfs: force skipping restripe\n");
+		goto out;
+	} else {
+		printk(KERN_INFO "btrfs: continuing restripe\n");
+	}
+
 	ret = btrfs_restripe(rctl, 1);
 
+out:
 	mutex_unlock(&fs_info->restripe_mutex);
 	return ret;
 }
