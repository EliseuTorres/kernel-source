From: Andre Przywara <andre.przywara@amd.com>
Subject: [PATCH 3/8] KVM: cleanup emulate_instruction
References: FATE#309761
Git-commit: 51d8b66199e94284e7725a79eae4a38de4b80d54
Patch-mainline: v2.6.38

emulate_instruction had many callers, but only one used all
parameters. One parameter was unused, another one is now
hidden by a wrapper function (required for a future addition
anyway), so most callers use now a shorter parameter list.

Backport from 51d8b66199e94284e7725a79eae4a38de4b80d54.

Signed-off-by: Andre Przywara <andre.przywara@amd.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/include/asm/kvm_host.h |   11 +++++++++--
 arch/x86/kvm/mmu.c              |    2 +-
 arch/x86/kvm/svm.c              |   12 ++++++------
 arch/x86/kvm/vmx.c              |   10 +++++-----
 arch/x86/kvm/x86.c              |    9 ++++-----
 5 files changed, 25 insertions(+), 19 deletions(-)

Index: linux-2.6.32-SLE11-SP2/arch/x86/include/asm/kvm_host.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/include/asm/kvm_host.h
+++ linux-2.6.32-SLE11-SP2/arch/x86/include/asm/kvm_host.h
@@ -571,8 +571,15 @@ enum emulation_result {
 #define EMULTYPE_NO_DECODE	    (1 << 0)
 #define EMULTYPE_TRAP_UD	    (1 << 1)
 #define EMULTYPE_SKIP		    (1 << 2)
-int emulate_instruction(struct kvm_vcpu *vcpu, struct kvm_run *run,
-			unsigned long cr2, u16 error_code, int emulation_type);
+int x86_emulate_instruction(struct kvm_vcpu *vcpu, struct kvm_run *run,
+			unsigned long cr2, int emulation_type);
+
+static inline int emulate_instruction(struct kvm_vcpu *vcpu,
+			struct kvm_run *run, int emulation_type)
+{
+	return x86_emulate_instruction(vcpu, run, 0, emulation_type);
+}
+
 void kvm_report_emulation_failure(struct kvm_vcpu *cvpu, const char *context);
 void realmode_lgdt(struct kvm_vcpu *vcpu, u16 size, unsigned long address);
 void realmode_lidt(struct kvm_vcpu *vcpu, u16 size, unsigned long address);
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/mmu.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/mmu.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/mmu.c
@@ -2836,7 +2836,7 @@ int kvm_mmu_page_fault(struct kvm_vcpu *
 	if (r)
 		goto out;
 
-	er = emulate_instruction(vcpu, vcpu->run, cr2, error_code, 0);
+	er = x86_emulate_instruction(vcpu, vcpu->run, cr2, 0);
 
 	switch (er) {
 	case EMULATE_DONE:
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/svm.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/svm.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/svm.c
@@ -294,7 +294,7 @@ static void skip_emulated_instruction(st
 		svm->next_rip = svm->vmcb->control.next_rip;
 
 	if (!svm->next_rip) {
-		if (emulate_instruction(vcpu, vcpu->run, 0, 0, EMULTYPE_SKIP) !=
+		if (emulate_instruction(vcpu, vcpu->run, EMULTYPE_SKIP) !=
 				EMULATE_DONE)
 			printk(KERN_DEBUG "%s: NOP\n", __func__);
 		return;
@@ -1276,7 +1276,7 @@ static int ud_interception(struct vcpu_s
 {
 	int er;
 
-	er = emulate_instruction(&svm->vcpu, kvm_run, 0, 0, EMULTYPE_TRAP_UD);
+	er = emulate_instruction(&svm->vcpu, kvm_run, EMULTYPE_TRAP_UD);
 	if (er != EMULATE_DONE)
 		kvm_queue_exception(&svm->vcpu, UD_VECTOR);
 	return 1;
@@ -1394,7 +1394,7 @@ static int io_interception(struct vcpu_s
 
 	if (string) {
 		if (emulate_instruction(&svm->vcpu,
-					kvm_run, 0, 0, 0) == EMULATE_DO_MMIO)
+					kvm_run, 0) == EMULATE_DO_MMIO)
 			return 0;
 		return 1;
 	}
@@ -2144,7 +2144,7 @@ static int iret_interception(struct vcpu
 
 static int invlpg_interception(struct vcpu_svm *svm, struct kvm_run *kvm_run)
 {
-	if (emulate_instruction(&svm->vcpu, kvm_run, 0, 0, 0) != EMULATE_DONE)
+	if (emulate_instruction(&svm->vcpu, kvm_run, 0) != EMULATE_DONE)
 		pr_unimpl(&svm->vcpu, "%s: failed\n", __func__);
 	return 1;
 }
@@ -2152,7 +2152,7 @@ static int invlpg_interception(struct vc
 static int emulate_on_interception(struct vcpu_svm *svm,
 				   struct kvm_run *kvm_run)
 {
-	if (emulate_instruction(&svm->vcpu, NULL, 0, 0, 0) != EMULATE_DONE)
+	if (emulate_instruction(&svm->vcpu, NULL, 0) != EMULATE_DONE)
 		pr_unimpl(&svm->vcpu, "%s: failed\n", __func__);
 	return 1;
 }
@@ -2163,7 +2163,7 @@ static int cr8_write_interception(struct
 
 	u8 cr8_prev = kvm_get_cr8(&svm->vcpu);
 	/* instruction emulation calls kvm_set_cr8() */
-	r = emulate_instruction(&svm->vcpu, NULL, 0, 0, 0);
+	r = emulate_instruction(&svm->vcpu, NULL, 0);
 	if (irqchip_in_kernel(svm->vcpu.kvm)) {
 		svm->vmcb->control.intercept_cr_write &= ~INTERCEPT_CR8_MASK;
 		return r == EMULATE_DONE;
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/vmx.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/vmx.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/vmx.c
@@ -2761,7 +2761,7 @@ static int handle_rmode_exception(struct
 	 * Cause the #SS fault with 0 error code in VM86 mode.
 	 */
 	if (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0)
-		if (emulate_instruction(vcpu, NULL, 0, 0, 0) == EMULATE_DONE)
+		if (emulate_instruction(vcpu, NULL, 0) == EMULATE_DONE)
 			return 1;
 	/*
 	 * Forward all other exceptions that are valid in real mode.
@@ -2852,7 +2852,7 @@ static int handle_exception(struct kvm_v
 	}
 
 	if (is_invalid_opcode(intr_info)) {
-		er = emulate_instruction(vcpu, kvm_run, 0, 0, EMULTYPE_TRAP_UD);
+		er = emulate_instruction(vcpu, kvm_run, EMULTYPE_TRAP_UD);
 		if (er != EMULATE_DONE)
 			kvm_queue_exception(vcpu, UD_VECTOR);
 		return 1;
@@ -2943,7 +2943,7 @@ static int handle_io(struct kvm_vcpu *vc
 
 	if (string) {
 		if (emulate_instruction(vcpu,
-					kvm_run, 0, 0, 0) == EMULATE_DO_MMIO)
+					kvm_run, 0) == EMULATE_DO_MMIO)
 			return 0;
 		return 1;
 	}
@@ -3259,7 +3259,7 @@ static int handle_apic_access(struct kvm
 	exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
 	offset = exit_qualification & 0xffful;
 
-	er = emulate_instruction(vcpu, kvm_run, 0, 0, 0);
+	er = emulate_instruction(vcpu, kvm_run, 0);
 
 	if (er !=  EMULATE_DONE) {
 		printk(KERN_ERR
@@ -3461,7 +3461,7 @@ static void handle_invalid_guest_state(s
 	preempt_enable();
 
 	while (!guest_state_valid(vcpu)) {
-		err = emulate_instruction(vcpu, kvm_run, 0, 0, 0);
+		err = emulate_instruction(vcpu, kvm_run, 0);
 
 		if (err == EMULATE_DO_MMIO)
 			break;
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/x86.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/x86.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/x86.c
@@ -3279,10 +3279,9 @@ static void cache_all_regs(struct kvm_vc
 	vcpu->arch.regs_dirty = ~0;
 }
 
-int emulate_instruction(struct kvm_vcpu *vcpu,
+int x86_emulate_instruction(struct kvm_vcpu *vcpu,
 			struct kvm_run *run,
 			unsigned long cr2,
-			u16 error_code,
 			int emulation_type)
 {
 	int r, shadow_mask;
@@ -3394,7 +3393,7 @@ int emulate_instruction(struct kvm_vcpu
 
 	return EMULATE_DONE;
 }
-EXPORT_SYMBOL_GPL(emulate_instruction);
+EXPORT_SYMBOL_GPL(x86_emulate_instruction);
 
 static int pio_copy_data(struct kvm_vcpu *vcpu)
 {
@@ -4356,8 +4355,8 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_v
 		vcpu->mmio_needed = 0;
 
 		vcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);
-		r = emulate_instruction(vcpu, kvm_run,
-					vcpu->arch.mmio_fault_cr2, 0,
+		r = x86_emulate_instruction(vcpu, kvm_run,
+					vcpu->arch.mmio_fault_cr2,
 					EMULTYPE_NO_DECODE);
 		srcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);
 		if (r == EMULATE_DO_MMIO) {
