From: Mike Travis <travis@sgi.com>
Subject: Pass add_efi_memmap entries to kexec'd kernel
References: bnc#603738
Patch-mainline: Never. The ideal fix is to modify bootloader to pass all the
entries (>128) via linked list of setup_data in real-mode kernel header,
rather than using the add_efi_memmap param.
See-also: patches.suse/xen-add_efi_memmap-update-e820_saved.patch - Nikanth

Currently, the e820_reserve_resources() function does not add entries
obtained via the "add_efi_memmap" kernel cmdline option.  This causes
/sys/firmware/memmap/... to be incomplete (stops after 128 entries).
Utilities that examine these entries then do not get the complete
picture of system memory.

This patch causes the add_efi_memmap function to add the memmap entries
to both the e820 map and the e820_saved map.

Signed-off-by: Mike Travis <travis@sgi.com>
Signed-off-by: Jack Steiner <steiner@sgi.com>

v2: drop call to sanitize e820_saved map after adding efi_memmap
    entries.  (Note: it may still be "sanitized" via setup_arch->
    early_reserve_e820_mpc_new-> early_reserve_e820->update_e820_saved->
    sanitize_e820_map)

Signed-off-by: Nikanth Karthikesan <knikanth@suse.de>

---

Index: linux-2.6.32-SLE11-SP1/arch/x86/include/asm/e820.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/include/asm/e820.h
+++ linux-2.6.32-SLE11-SP1/arch/x86/include/asm/e820.h
@@ -70,6 +70,7 @@ extern unsigned long pci_mem_start;
 extern int e820_any_mapped(u64 start, u64 end, unsigned type);
 extern int e820_all_mapped(u64 start, u64 end, unsigned type);
 extern void e820_add_region(u64 start, u64 size, int type);
+extern void e820_saved_add_region(u64 start, u64 size, int type);
 extern void e820_print_map(char *who);
 extern int
 sanitize_e820_map(struct e820entry *biosmap, int max_nr_map, u32 *pnr_map);
Index: linux-2.6.32-SLE11-SP1/arch/x86/kernel/e820.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/kernel/e820.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/kernel/e820.c
@@ -33,9 +33,9 @@
  * and that is also registered with modifications in the kernel resource tree
  * with the iomem_resource as parent.
  *
- * The e820_saved is directly saved after the BIOS-provided memory map is
- * copied. It doesn't get modified afterwards. It's registered for the
- * /sys/firmware/memmap interface.
+ * The e820_saved is saved after the BIOS-provided memory map is copied as
+ * well as the optional add_efi_memmap entries are processed.  It doesn't get
+ * modified afterwards. It's registered for the /sys/firmware/memmap interface.
  *
  * That memory map is not modified and is used as base for kexec. The kexec'd
  * kernel should get the same memory map as the firmware provides. Then the
@@ -131,6 +131,11 @@ void __init e820_add_region(u64 start, u
 	__e820_add_region(&e820, start, size, type);
 }
 
+void __init e820_saved_add_region(u64 start, u64 size, int type)
+{
+	__e820_add_region(&e820_saved, start, size, type);
+}
+
 static void __init e820_print_type(u32 type)
 {
 	switch (type) {
Index: linux-2.6.32-SLE11-SP1/arch/x86/kernel/efi.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/kernel/efi.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/kernel/efi.c
@@ -271,6 +271,7 @@ static void __init do_add_efi_memmap(voi
 			break;
 		}
 		e820_add_region(start, size, e820_type);
+		e820_saved_add_region(start, size, e820_type);
 	}
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
 }
