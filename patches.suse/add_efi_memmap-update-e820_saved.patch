From: Mike Travis <travis@sgi.com>
Subject: x86 efi: Fill all reserved memmap entries if add_efi_memmap specified
References: bnc#603738
Patch-mainline: Never. The ideal fix is to modify bootloader to pass all the
entries (>128) via linked list of setup_data in real-mode kernel header,
rather than using the add_efi_memmap param.
See-also: patches.suse/xen-add_efi_memmap-update-e820_saved.patch - Nikanth

Currently, the e820_reserve_resources() function does not add entries
obtained via the "add_efi_memmap" kernel cmdline option.  This causes
/sys/firmware/memmap/... to be incomplete (stops after 128 entries).
Utilities that examine these entries then do not get the complete
picture of system memory.

This patch causes the above function to use the e820 memmap instead
of the e820_saved memmap if "add_efi_memmap" cmdline option is
specified.

Signed-off-by: Mike Travis <travis@sgi.com>
Signed-off-by: Jack Steiner <steiner@sgi.com>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---
 arch/x86/include/asm/e820.h |    1 +
 arch/x86/kernel/e820.c      |   11 ++++++++---
 arch/x86/platform/efi/efi.c |    1 +
 3 files changed, 10 insertions(+), 3 deletions(-)

Index: linux-3.0-SLE11-SP2-3.0/arch/x86/include/asm/e820.h
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/arch/x86/include/asm/e820.h
+++ linux-3.0-SLE11-SP2-3.0/arch/x86/include/asm/e820.h
@@ -88,6 +88,7 @@ extern unsigned long pci_mem_start;
 extern int e820_any_mapped(u64 start, u64 end, unsigned type);
 extern int e820_all_mapped(u64 start, u64 end, unsigned type);
 extern void e820_add_region(u64 start, u64 size, int type);
+extern void e820_saved_add_region(u64 start, u64 size, int type);
 extern void e820_print_map(char *who);
 extern int
 sanitize_e820_map(struct e820entry *biosmap, int max_nr_map, u32 *pnr_map);
Index: linux-3.0-SLE11-SP2-3.0/arch/x86/kernel/e820.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/arch/x86/kernel/e820.c
+++ linux-3.0-SLE11-SP2-3.0/arch/x86/kernel/e820.c
@@ -28,9 +28,9 @@
  * and that is also registered with modifications in the kernel resource tree
  * with the iomem_resource as parent.
  *
- * The e820_saved is directly saved after the BIOS-provided memory map is
- * copied. It doesn't get modified afterwards. It's registered for the
- * /sys/firmware/memmap interface.
+ * The e820_saved is saved after the BIOS-provided memory map is copied as
+ * well as the optional add_efi_memmap entries are processed.  It doesn't get
+ * modified afterwards. It's registered for the /sys/firmware/memmap interface.
  *
  * That memory map is not modified and is used as base for kexec. The kexec'd
  * kernel should get the same memory map as the firmware provides. Then the
@@ -127,6 +127,11 @@ void __init e820_add_region(u64 start, u
 	__e820_add_region(&e820, start, size, type);
 }
 
+void __init e820_saved_add_region(u64 start, u64 size, int type)
+{
+	__e820_add_region(&e820_saved, start, size, type);
+}
+
 static void __init e820_print_type(u32 type)
 {
 	switch (type) {
Index: linux-3.0-SLE11-SP2-3.0/arch/x86/platform/efi/efi.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/arch/x86/platform/efi/efi.c
+++ linux-3.0-SLE11-SP2-3.0/arch/x86/platform/efi/efi.c
@@ -261,6 +261,7 @@ static void __init do_add_efi_memmap(voi
 			break;
 		}
 		e820_add_region(start, size, e820_type);
+		e820_saved_add_region(start, size, e820_type);
 	}
 	sanitize_e820_map(e820.map, ARRAY_SIZE(e820.map), &e820.nr_map);
 }
