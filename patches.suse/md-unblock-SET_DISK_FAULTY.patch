From: Hannes Reinecke <hare@suse.de>
Date: Wed, 27 Jun 2012 08:50:00 +0200
Subject: md: unblock 'SET_DISK_FAULTY' ioctl
Patch-Mainline: n/a
References: bnc#768084

During reconfiguration ioctls might stall due to contention on
the MD lock. However, when trying to implement an anticipatory
failover (ie fail all disks in one set as soon as one disk in
the set fails) SET_DISK_FAULTY needs to be called _precisely_
during reconfiguration, as the initial disk might not have
been finished with the reconfiguration.
And SET_DISK_FAULTY doesn't need the lock anyway, so we
should unlock it.

Signed-off-by: Hannes Reinecke <hare@suse.de>

---
 drivers/md/md.c |   24 ++++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

--- linux-3.12-SLE12.orig/drivers/md/md.c
+++ linux-3.12-SLE12/drivers/md/md.c
@@ -706,6 +706,21 @@ static struct md_rdev *find_rdev_rcu(str
 	return NULL;
 }
 
+static mdk_rdev_t * find_rdev_rcu(mddev_t * mddev, dev_t dev)
+{
+	mdk_rdev_t *rdev;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(rdev, &mddev->disks, same_set)
+		if (rdev->bdev->bd_dev == dev) {
+			rcu_read_unlock();
+			return rdev;
+		}
+
+	rcu_read_unlock();
+	return NULL;
+}
+
 static struct md_personality *find_pers(int level, char *clevel)
 {
 	struct md_personality *pers;
@@ -5955,7 +5970,7 @@ static int hot_remove_disk(struct mddev
 	char b[BDEVNAME_SIZE];
 	struct md_rdev *rdev;
 
-	rdev = find_rdev(mddev, dev);
+	rdev = find_rdev_rcu(mddev, dev);
 	if (!rdev)
 		return -ENXIO;
 
@@ -6514,6 +6529,12 @@ static int md_ioctl(struct block_device
 		mutex_unlock(&mddev->open_mutex);
 		sync_blockdev(bdev);
 	}
+	if ((mddev->raid_disks || mddev->external) &&
+	    (cmd == SET_DISK_FAULTY)) {
+		err = set_disk_faulty(mddev, new_decode_dev(arg));
+		goto abort;
+	}
+
 	err = mddev_lock(mddev);
 	if (err) {
 		printk(KERN_INFO 
@@ -6690,7 +6711,6 @@ static int md_ioctl(struct block_device
 	case HOT_ADD_DISK:
 		err = hot_add_disk(mddev, new_decode_dev(arg));
 		goto done_unlock;
-
 	case RUN_ARRAY:
 		err = do_md_run(mddev);
 		goto done_unlock;
