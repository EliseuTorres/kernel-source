From: Hannes Reinecke <hare@suse.de>
Date: Wed, 27 Jun 2012 08:50:00 +0200
Subject: md: unblock 'SET_DISK_FAULTY' ioctl
Patch-Mainline: n/a
References: bnc#768084

During reconfiguration ioctls might stall due to contention on
the MD lock. However, when trying to implement an anticipatory
failover (ie fail all disks in one set as soon as one disk in
the set fails) SET_DISK_FAULTY needs to be called _precisely_
during reconfiguration, as the initial disk might not have
been finished with the reconfiguration.
And SET_DISK_FAULTY doesn't need the lock anyway, so we
should unlock it.

Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/md/md.c b/drivers/md/md.c
index bb61936..79eb02f 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -727,6 +727,21 @@ static mdk_rdev_t * find_rdev(mddev_t * mddev, dev_t dev)
 	return NULL;
 }
 
+static mdk_rdev_t * find_rdev_rcu(mddev_t * mddev, dev_t dev)
+{
+	mdk_rdev_t *rdev;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(rdev, &mddev->disks, same_set)
+		if (rdev->bdev->bd_dev == dev) {
+			rcu_read_unlock();
+			return rdev;
+		}
+
+	rcu_read_unlock();
+	return NULL;
+}
+
 static struct mdk_personality *find_pers(int level, char *clevel)
 {
 	struct mdk_personality *pers;
@@ -5844,7 +5859,7 @@ static int set_disk_faulty(mddev_t *mddev, dev_t dev)
 	if (mddev->pers == NULL)
 		return -ENODEV;
 
-	rdev = find_rdev(mddev, dev);
+	rdev = find_rdev_rcu(mddev, dev);
 	if (!rdev)
 		return -ENODEV;
 
@@ -5914,6 +5929,12 @@ static int md_ioctl(struct block_device *bdev, fmode_t mode,
 		goto abort;
 	}
 
+	if ((mddev->raid_disks || mddev->external) &&
+	    (cmd == SET_DISK_FAULTY)) {
+		err = set_disk_faulty(mddev, new_decode_dev(arg));
+		goto abort;
+	}
+
 	err = mddev_lock(mddev);
 	if (err) {
 		printk(KERN_INFO 
@@ -6079,10 +6100,6 @@ static int md_ioctl(struct block_device *bdev, fmode_t mode,
 			err = hot_add_disk(mddev, new_decode_dev(arg));
 			goto done_unlock;
 
-		case SET_DISK_FAULTY:
-			err = set_disk_faulty(mddev, new_decode_dev(arg));
-			goto done_unlock;
-
 		case RUN_ARRAY:
 			err = do_md_run(mddev);
 			goto done_unlock;
