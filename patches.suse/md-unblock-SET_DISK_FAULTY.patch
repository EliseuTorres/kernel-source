From: Hannes Reinecke <hare@suse.de>
Date: Wed, 27 Jun 2012 08:50:00 +0200
Subject: md: unblock 'SET_DISK_FAULTY' ioctl
Patch-Mainline: n/a
References: bnc#768084

During reconfiguration ioctls might stall due to contention on
the MD lock. However, when trying to implement an anticipatory
failover (ie fail all disks in one set as soon as one disk in
the set fails) SET_DISK_FAULTY needs to be called _precisely_
during reconfiguration, as the initial disk might not have
been finished with the reconfiguration.
And SET_DISK_FAULTY doesn't need the lock anyway, so we
should unlock it.

Signed-off-by: Hannes Reinecke <hare@suse.de>

---
 drivers/md/md.c |   27 ++++++++++++++++++++++-----
 1 file changed, 22 insertions(+), 5 deletions(-)

--- linux-3.0-SLE11-SP3.orig/drivers/md/md.c
+++ linux-3.0-SLE11-SP3/drivers/md/md.c
@@ -743,6 +743,21 @@ static mdk_rdev_t * find_rdev(mddev_t *
 	return NULL;
 }
 
+static mdk_rdev_t * find_rdev_rcu(mddev_t * mddev, dev_t dev)
+{
+	mdk_rdev_t *rdev;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(rdev, &mddev->disks, same_set)
+		if (rdev->bdev->bd_dev == dev) {
+			rcu_read_unlock();
+			return rdev;
+		}
+
+	rcu_read_unlock();
+	return NULL;
+}
+
 static struct mdk_personality *find_pers(int level, char *clevel)
 {
 	struct mdk_personality *pers;
@@ -6144,7 +6159,7 @@ static int set_disk_faulty(mddev_t *mdde
 	if (mddev->pers == NULL)
 		return -ENODEV;
 
-	rdev = find_rdev(mddev, dev);
+	rdev = find_rdev_rcu(mddev, dev);
 	if (!rdev)
 		return -ENODEV;
 
@@ -6244,6 +6259,12 @@ static int md_ioctl(struct block_device
 		goto abort;
 	}
 
+	if ((mddev->raid_disks || mddev->external) &&
+	    (cmd == SET_DISK_FAULTY)) {
+		err = set_disk_faulty(mddev, new_decode_dev(arg));
+		goto abort;
+	}
+
 	err = mddev_lock(mddev);
 	if (err) {
 		printk(KERN_INFO 
@@ -6397,10 +6418,6 @@ static int md_ioctl(struct block_device
 			err = hot_add_disk(mddev, new_decode_dev(arg));
 			goto done_unlock;
 
-		case SET_DISK_FAULTY:
-			err = set_disk_faulty(mddev, new_decode_dev(arg));
-			goto done_unlock;
-
 		case RUN_ARRAY:
 			err = do_md_run(mddev);
 			goto done_unlock;
