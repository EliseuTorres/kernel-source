From: Mel Gorman <mgorman@suse.de>
Date: Tue, 31 Jul 2012 16:44:23 -0700
Subject: [PATCH] netvm: propagate page->pfmemalloc to skb

References: Swap over NFS (fate#304949)
Patch-mainline: Yes (v3.6)
Git-commit: c48a11c7ad2623b99bbd6859b0b4234e7f11176f

The skb->pfmemalloc flag gets set to true iff during the slab allocation
of data in __alloc_skb that the the PFMEMALLOC reserves were used.  If the
packet is fragmented, it is possible that pages will be allocated from the
PFMEMALLOC reserve without propagating this information to the skb.  This
patch propagates page->pfmemalloc from pages allocated for fragments to
the skb.

Signed-off-by: Mel Gorman <mgorman@suse.de>
Acked-by: David S. Miller <davem@davemloft.net>
Cc: Neil Brown <neilb@suse.de>
Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Cc: Mike Christie <michaelc@cs.wisc.edu>
Cc: Eric B Munson <emunson@mgebm.net>
Cc: Eric Dumazet <eric.dumazet@gmail.com>
Cc: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
Cc: Mel Gorman <mgorman@suse.de>
Cc: Christoph Lameter <cl@linux.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 net/core/skbuff.c |   12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 6bc72e2..5cfc6bd 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -2513,6 +2513,18 @@ int skb_append_datato_frags(struct sock *sk, struct sk_buff *skb,
 		left = PAGE_SIZE - frag->page_offset;
 		copy = (length > left)? left : length;
 
+		/* 
+		 * Propagate page->pfmemalloc to the skb if we can. The problem is
+		 * that not all callers have unique ownership of the page. If
+		 * pfmemalloc is set, we check the mapping as a mapping implies
+		 * page->index is set (index and pfmemalloc share space).
+		 * If it's a valid mapping, we cannot use page->pfmemalloc but we
+		 * do not lose pfmemalloc information as the pages would not be
+		 * allocated using __GFP_MEMALLOC.
+		 */
+		if (frag->page->pfmemalloc && !frag->page->mapping)
+			skb->pfmemalloc = true;
+
 		ret = getfrag(from, (page_address(frag->page) +
 			    frag->page_offset + frag->size),
 			    offset, copy, 0, skb);
