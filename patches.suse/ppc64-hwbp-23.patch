From: K.Prasad <prasad@linux.vnet.ibm.com>
Subject: powerpc, hw_breakpoint: Discard extraneous interrupt due to accesses outside symbol length
Date: Tue Jun 15 11:36:12 2010 +0530
Git-commit: e3e94084adb5610987283367574ebc771e8206e1
Patch-mainline: v2.6.36-rc1
References: FATE#311653, BNC#702123
Signed-off-by: Tony Jones <tonyj@suse.de>

    powerpc, hw_breakpoint: Discard extraneous interrupt due to accesses outside symbol length
    
    Many a times, the requested breakpoint length can be less than the
    fixed breakpoint length i.e. 8 bytes supported by PowerPC 64-bit
    server (Book III S) processors.  This could lead to extraneous
    interrupts resulting in false breakpoint notifications.  This
    detects and discards such interrupts for non-ptrace requests.
    We don't change ptrace behaviour to avoid breaking compatability.
    
    [Suggestion from Paul Mackerras <paulus@samba.org> to add a new flag in
    'struct arch_hw_breakpoint' to identify extraneous interrupts]
    
    Signed-off-by: K.Prasad <prasad@linux.vnet.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

---
 arch/powerpc/include/asm/hw_breakpoint.h |    1 +
 arch/powerpc/kernel/hw_breakpoint.c      |   23 +++++++++++++++++++++--
 2 files changed, 22 insertions(+), 2 deletions(-)

--- a/arch/powerpc/include/asm/hw_breakpoint.h
+++ b/arch/powerpc/include/asm/hw_breakpoint.h
@@ -27,6 +27,7 @@
 #ifdef CONFIG_HAVE_HW_BREAKPOINT
 
 struct arch_hw_breakpoint {
+	bool		extraneous_interrupt;
 	u8		len; /* length of the target data symbol */
 	int		type;
 	unsigned long	address;
--- a/arch/powerpc/kernel/hw_breakpoint.c
+++ b/arch/powerpc/kernel/hw_breakpoint.c
@@ -204,6 +204,7 @@ int __kprobes hw_breakpoint_handler(stru
 	int stepped = 1;
 	struct arch_hw_breakpoint *info;
 	unsigned int instr;
+	unsigned long dar = regs->dar;
 
 	/* Disable breakpoints during exception handling */
 	set_dabr(0);
@@ -234,6 +235,22 @@ int __kprobes hw_breakpoint_handler(stru
 		goto out;
 	}
 
+	/*
+	 * Verify if dar lies within the address range occupied by the symbol
+	 * being watched to filter extraneous exceptions.
+	 */
+	if (!((bp->attr.bp_addr <= dar) &&
+	     (dar <= (bp->attr.bp_addr + bp->attr.bp_len)))) {
+		/*
+		 * This exception is triggered not because of a memory access
+		 * on the monitored variable but in the double-word address
+		 * range in which it is contained. We will consume this
+		 * exception, considering it as 'noise'.
+		 */
+		info->extraneous_interrupt = true;
+	} else
+		info->extraneous_interrupt = false;
+
 	/* Do not emulate user-space instructions, instead single-step them */
 	if (user_mode(regs)) {
 		bp->ctx->task->thread.last_hit_ubp = bp;
@@ -261,7 +278,8 @@ int __kprobes hw_breakpoint_handler(stru
 	 * As a policy, the callback is invoked in a 'trigger-after-execute'
 	 * fashion
 	 */
-	perf_bp_event(bp, regs);
+	if (!info->extraneous_interrupt)
+		perf_bp_event(bp, regs);
 
 	set_dabr(info->address | info->type | DABR_TRANSLATION);
 out:
@@ -292,7 +310,8 @@ int __kprobes single_step_dabr_instructi
 	 * We shall invoke the user-defined callback function in the single
 	 * stepping handler to confirm to 'trigger-after-execute' semantics
 	 */
-	perf_bp_event(bp, regs);
+	if (!bp_info->extraneous_interrupt)
+		perf_bp_event(bp, regs);
 
 	/*
 	 * Do not disable MSR_SE if the process was already in
