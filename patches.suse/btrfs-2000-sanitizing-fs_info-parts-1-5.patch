From: Al Viro <viro@zeniv.linux.org.uk>
Date: Thu, 17 Nov 2011 00:32:06 -0500
Git-commit: 2eb34cd368b3e5cef960ae9d9971a037cd6fa9d3
Git-commit: 1233f546ec29ac32424327baf6ae5df81e3d9eae
Git-commit: 38a77db49ad8f78369dcdfb693b8e5a818a60104
Git-commit: 6f07e42ee6fcc252a210781d7262f4051e9fd8f6
Git-commit: e3029d9fd426c8f582210ba35551ae5506218345
Patch-mainline: 3.3
Subject: [PATCH 01/12] btrfs: sanitizing ->fs_info, parts 1-5

[1] take assignment of ->fs_info to callers of __setup_root()
[2] lift assignment to callers of find_and_setup_root()
[3] move assignments to ->fs_info in open_ctree() up, to the place just after
    the original allocations.  Assignment for tree_root becomes a no-op - we'd
    obtained fs_info from tree_root->fs_info in the first place.
[4] A new helper: btrfs_alloc_root(fs_info); allocates btrfs_root
    and sets ->fs_info.  All places allocating the suckers converted
    to it.  At that point we *never* reassign ->fs_info of btrfs_root;
    it's set before anyone sees the address of newly allocated
    struct btrfs_root and never assigned anywhere else.
[5] close_ctree() uses a weird mix of accesses to root->fs_info and
   its value at the beginning of function stored in local variable.
   Since ->fs_info *never* changes, let's just use the local variable
   to avoid confusion.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/disk-io.c |   47 +++++++++++++++++++++++++----------------------
 fs/btrfs/disk-io.h |    2 ++
 fs/btrfs/super.c   |    3 +--
 3 files changed, 28 insertions(+), 24 deletions(-)

--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -1143,7 +1143,6 @@ static int __setup_root(u32 nodesize, u3
 	root->orphan_item_inserted = 0;
 	root->orphan_cleanup_state = 0;
 
-	root->fs_info = fs_info;
 	root->objectid = objectid;
 	root->last_trans = 0;
 	root->highest_objectid = 0;
@@ -1222,6 +1221,14 @@ static int find_and_setup_root(struct bt
 	return 0;
 }
 
+struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info)
+{
+	struct btrfs_root *root = kzalloc(sizeof(*root), GFP_NOFS);
+	if (root)
+		root->fs_info = fs_info;
+	return root;
+}
+
 static struct btrfs_root *alloc_log_tree(struct btrfs_trans_handle *trans,
 					 struct btrfs_fs_info *fs_info)
 {
@@ -1229,7 +1236,7 @@ static struct btrfs_root *alloc_log_tree
 	struct btrfs_root *tree_root = fs_info->tree_root;
 	struct extent_buffer *leaf;
 
-	root = kzalloc(sizeof(*root), GFP_NOFS);
+	root = btrfs_alloc_root(fs_info);
 	if (!root)
 		return ERR_PTR(-ENOMEM);
 
@@ -1324,7 +1331,7 @@ struct btrfs_root *btrfs_read_fs_root_no
 	u32 blocksize;
 	int ret = 0;
 
-	root = kzalloc(sizeof(*root), GFP_NOFS);
+	root = btrfs_alloc_root(fs_info);
 	if (!root)
 		return ERR_PTR(-ENOMEM);
 	if (location->offset == (u64)-1) {
@@ -1910,14 +1917,10 @@ struct btrfs_root *open_ctree(struct sup
 	int num_backups_tried = 0;
 	int backup_index = 0;
 
-	extent_root = fs_info->extent_root =
-		kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
-	csum_root = fs_info->csum_root =
-		kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
-	chunk_root = fs_info->chunk_root =
-		kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
-	dev_root = fs_info->dev_root =
-		kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
+	extent_root = fs_info->extent_root = btrfs_alloc_root(fs_info);
+	csum_root = fs_info->csum_root = btrfs_alloc_root(fs_info);
+	chunk_root = fs_info->chunk_root = btrfs_alloc_root(fs_info);
+	dev_root = fs_info->dev_root = btrfs_alloc_root(fs_info);
 
 	if (!extent_root || !csum_root || !chunk_root || !dev_root) {
 		err = -ENOMEM;
@@ -2381,7 +2384,7 @@ retry_root_backup:
 		     btrfs_level_size(tree_root,
 				      btrfs_super_log_root_level(disk_super));
 
-		log_tree_root = kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
+		log_tree_root = btrfs_alloc_root(fs_info);
 		if (!log_tree_root) {
 			err = -ENOMEM;
 			goto fail_trans_kthread;
@@ -3002,7 +3005,7 @@ int close_ctree(struct btrfs_root *root)
 		   (atomic_read(&fs_info->defrag_running) == 0));
 
 	/* clear out the rbtree of defraggable inodes */
-	btrfs_run_defrag_inodes(root->fs_info);
+	btrfs_run_defrag_inodes(fs_info);
 
 	/*
 	 * Here come 2 situations when btrfs is broken to flip readonly:
@@ -3031,8 +3034,8 @@ int close_ctree(struct btrfs_root *root)
 
 	btrfs_put_block_group_cache(fs_info);
 
-	kthread_stop(root->fs_info->transaction_kthread);
-	kthread_stop(root->fs_info->cleaner_kthread);
+	kthread_stop(fs_info->transaction_kthread);
+	kthread_stop(fs_info->cleaner_kthread);
 
 	fs_info->closing = 2;
 	smp_mb();
@@ -3050,14 +3053,14 @@ int close_ctree(struct btrfs_root *root)
 	free_extent_buffer(fs_info->extent_root->commit_root);
 	free_extent_buffer(fs_info->tree_root->node);
 	free_extent_buffer(fs_info->tree_root->commit_root);
-	free_extent_buffer(root->fs_info->chunk_root->node);
-	free_extent_buffer(root->fs_info->chunk_root->commit_root);
-	free_extent_buffer(root->fs_info->dev_root->node);
-	free_extent_buffer(root->fs_info->dev_root->commit_root);
-	free_extent_buffer(root->fs_info->csum_root->node);
-	free_extent_buffer(root->fs_info->csum_root->commit_root);
+	free_extent_buffer(fs_info->chunk_root->node);
+	free_extent_buffer(fs_info->chunk_root->commit_root);
+	free_extent_buffer(fs_info->dev_root->node);
+	free_extent_buffer(fs_info->dev_root->commit_root);
+	free_extent_buffer(fs_info->csum_root->node);
+	free_extent_buffer(fs_info->csum_root->commit_root);
 
-	btrfs_free_block_groups(root->fs_info);
+	btrfs_free_block_groups(fs_info);
 
 	del_fs_roots(fs_info);
 
--- a/fs/btrfs/disk-io.h
+++ b/fs/btrfs/disk-io.h
@@ -86,6 +86,8 @@ int btrfs_init_log_root_tree(struct btrf
 int btrfs_add_log_tree(struct btrfs_trans_handle *trans,
 		       struct btrfs_root *root);
 
+struct btrfs_root *btrfs_alloc_root(struct btrfs_fs_info *fs_info);
+
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
 void btrfs_init_lockdep(void);
 void btrfs_set_buffer_lockdep_class(u64 objectid,
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -934,12 +934,11 @@ static struct dentry *btrfs_mount(struct
 	if (!fs_info)
 		return ERR_PTR(-ENOMEM);
 
-	fs_info->tree_root = kzalloc(sizeof(struct btrfs_root), GFP_NOFS);
+	fs_info->tree_root = btrfs_alloc_root(fs_info);
 	if (!fs_info->tree_root) {
 		error = -ENOMEM;
 		goto error_fs_info;
 	}
-	fs_info->tree_root->fs_info = fs_info;
 	fs_info->fs_devices = fs_devices;
 
 	fs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);
