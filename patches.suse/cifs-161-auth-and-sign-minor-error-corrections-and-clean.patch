From f7c5445a9deecffea8a4fffc0163bf582411ac8a Mon Sep 17 00:00:00 2001
From: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Date: Tue, 26 Oct 2010 18:10:24 -0500
Subject: NTLM auth and sign - minor error corrections and cleanup
References: FATE#311695
Patch-mainline: yes

Minor cleanup - Fix spelling mistake, make meaningful (goto) label

In function setup_ntlmv2_rsp(), do not return 0 and leak memory,
let the tiblob get freed.

For function find_domain_name(), pass already available nls table pointer
instead of loading and unloading the table again in this function.

For ntlmv2, the case sensitive password length is the length of the
response, so subtract session key length (16 bytes) from the .len.

Signed-off-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>
Signed-off-by: Steve French <sfrench@us.ibm.com>
Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
---
 fs/cifs/cifsencrypt.c |   15 ++++++---------
 fs/cifs/cifsglob.h    |    2 +-
 fs/cifs/connect.c     |    8 ++++----
 fs/cifs/sess.c        |    2 +-
 4 files changed, 12 insertions(+), 15 deletions(-)

Index: linux-2.6.32-SLE11-SP2/fs/cifs/cifsencrypt.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/cifsencrypt.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/cifsencrypt.c
@@ -390,7 +390,7 @@ build_avpair_blob(struct cifsSesInfo *se
  * about target string i.e. for some, just user name might suffice.
  */
 static int
-find_domain_name(struct cifsSesInfo *ses)
+find_domain_name(struct cifsSesInfo *ses, const struct nls_table *nls_cp)
 {
 	unsigned int attrsize;
 	unsigned int type;
@@ -419,16 +419,13 @@ find_domain_name(struct cifsSesInfo *ses
 			if (!attrsize)
 				break;
 			if (!ses->domainName) {
-				struct nls_table *default_nls;
 				ses->domainName =
 					kmalloc(attrsize + 1, GFP_KERNEL);
 				if (!ses->domainName)
 						return -ENOMEM;
-				default_nls = load_nls_default();
 				cifs_from_ucs2(ses->domainName,
 					(__le16 *)blobptr, attrsize, attrsize,
-					default_nls, false);
-				unload_nls(default_nls);
+					nls_cp, false);
 				break;
 			}
 		}
@@ -560,7 +557,7 @@ setup_ntlmv2_rsp(struct cifsSesInfo *ses
 
 	if (ses->server->secType == RawNTLMSSP) {
 		if (!ses->domainName) {
-			rc = find_domain_name(ses);
+			rc = find_domain_name(ses, nls_cp);
 			if (rc) {
 				cERROR(1, "error %d finding domain name", rc);
 				goto setup_ntlmv2_rsp_ret;
@@ -593,12 +590,14 @@ setup_ntlmv2_rsp(struct cifsSesInfo *ses
 
 	memcpy(ses->auth_key.response + baselen, ses->tiblob, ses->tilen);
 
-	/* calculate buf->ntlmv2_hash */
+	/* calculate ntlmv2_hash */
 	rc = calc_ntlmv2_hash(ses, nls_cp);
 	if (rc) {
 		cERROR(1, "could not get v2 hash rc %d", rc);
 		goto setup_ntlmv2_rsp_ret;
 	}
+
+	/* calculate first part of the client response (CR1) */
 	rc = CalcNTLMv2_response(ses);
 	if (rc) {
 		cERROR(1, "Could not calculate CR1  rc: %d", rc);
@@ -622,8 +621,6 @@ setup_ntlmv2_rsp(struct cifsSesInfo *ses
 	rc = crypto_shash_final(&ses->server->secmech.sdeschmacmd5->shash,
 		ses->auth_key.response);
 
-	return 0;
-
 setup_ntlmv2_rsp_ret:
 	kfree(ses->tiblob);
 	ses->tiblob = NULL;
Index: linux-2.6.32-SLE11-SP2/fs/cifs/cifsglob.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/cifsglob.h
+++ linux-2.6.32-SLE11-SP2/fs/cifs/cifsglob.h
@@ -110,7 +110,7 @@ struct sdesc {
 	char ctx[];
 };
 
-/* crypto hashing related structure/fields, not speicific to a sec mech */
+/* crypto hashing related structure/fields, not specific to a sec mech */
 struct cifs_secmech {
 	struct crypto_shash *hmacmd5; /* hmac-md5 hash function */
 	struct crypto_shash *md5; /* md5 hash function */
Index: linux-2.6.32-SLE11-SP2/fs/cifs/connect.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/connect.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/connect.c
@@ -1633,7 +1633,7 @@ cifs_get_tcp_session(struct smb_vol *vol
 	tcp_ses->hostname = extract_hostname(volume_info->UNC);
 	if (IS_ERR(tcp_ses->hostname)) {
 		rc = PTR_ERR(tcp_ses->hostname);
-		goto out_err2;
+		goto out_err_crypto_release;
 	}
 
 	tcp_ses->noblocksnd = volume_info->noblocksnd;
@@ -1677,7 +1677,7 @@ cifs_get_tcp_session(struct smb_vol *vol
 	}
 	if (rc < 0) {
 		cERROR(1, "Error connecting to socket. Aborting operation");
-		goto out_err2;
+		goto out_err_crypto_release;
 	}
 
 	/*
@@ -1691,7 +1691,7 @@ cifs_get_tcp_session(struct smb_vol *vol
 		rc = PTR_ERR(tcp_ses->tsk);
 		cERROR(1, "error %d create cifsd thread", rc);
 		module_put(THIS_MODULE);
-		goto out_err2;
+		goto out_err_crypto_release;
 	}
 
 	/* thread spawned, put it on the list */
@@ -1703,7 +1703,7 @@ cifs_get_tcp_session(struct smb_vol *vol
 
 	return tcp_ses;
 
-out_err2:
+out_err_crypto_release:
 	cifs_crypto_shash_release(tcp_ses);
 
 out_err:
Index: linux-2.6.32-SLE11-SP2/fs/cifs/sess.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/cifs/sess.c
+++ linux-2.6.32-SLE11-SP2/fs/cifs/sess.c
@@ -737,7 +737,7 @@ ssetup_ntlmssp_authenticate:
 		 * assigned, tilen is 0 otherwise.
 		 */
 		pSMB->req_no_secext.CaseSensitivePasswordLength =
-			cpu_to_le16(ses->auth_key.len);
+			cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
 
 		if (ses->capabilities & CAP_UNICODE) {
 			if (iov[0].iov_len % 2) {
