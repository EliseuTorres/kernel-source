From: Kiyoshi Ueda <k-ueda@ct.jp.nec.com>
Date: Thu, 10 Dec 2009 23:52:15 +0000
Subject: [PATCH] dm: abstract clone_rq
Git-commit: 6facdaff229f2b25d0de82be9be99b9f562e72ba
References: FATE#311054
Patch-Mainline: 2.6.33

This patch factors out the request cloning code in dm_prep_fn()
as clone_rq().  No functional change.

This patch is a preparation for a later patch in this series which needs to
make clones from an original barrier request.

Signed-off-by: Kiyoshi Ueda <k-ueda@ct.jp.nec.com>
Signed-off-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
Signed-off-by: Alasdair G Kergon <agk@redhat.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/md/dm.c |   41 ++++++++++++++++++++++++++---------------
 1 files changed, 26 insertions(+), 15 deletions(-)

diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index fc48a45..5a5c80e 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -1457,24 +1457,15 @@ static int setup_clone(struct request *clone, struct request *rq,
 	return 0;
 }
 
-/*
- * Called with the queue lock held.
- */
-static int dm_prep_fn(struct request_queue *q, struct request *rq)
+static struct request *clone_rq(struct request *rq, struct mapped_device *md,
+				gfp_t gfp_mask)
 {
-	struct mapped_device *md = q->queuedata;
-	struct dm_rq_target_io *tio;
 	struct request *clone;
+	struct dm_rq_target_io *tio;
 
-	if (unlikely(rq->special)) {
-		DMWARN("Already has something in rq->special.");
-		return BLKPREP_KILL;
-	}
-
-	tio = alloc_rq_tio(md, GFP_ATOMIC);
+	tio = alloc_rq_tio(md, gfp_mask);
 	if (!tio)
-		/* -ENOMEM */
-		return BLKPREP_DEFER;
+		return NULL;
 
 	tio->md = md;
 	tio->ti = NULL;
@@ -1486,9 +1477,29 @@ static int dm_prep_fn(struct request_queue *q, struct request *rq)
 	if (setup_clone(clone, rq, tio)) {
 		/* -ENOMEM */
 		free_rq_tio(tio);
-		return BLKPREP_DEFER;
+		return NULL;
 	}
 
+	return clone;
+}
+
+/*
+ * Called with the queue lock held.
+ */
+static int dm_prep_fn(struct request_queue *q, struct request *rq)
+{
+	struct mapped_device *md = q->queuedata;
+	struct request *clone;
+
+	if (unlikely(rq->special)) {
+		DMWARN("Already has something in rq->special.");
+		return BLKPREP_KILL;
+	}
+
+	clone = clone_rq(rq, md, GFP_ATOMIC);
+	if (!clone)
+		return BLKPREP_DEFER;
+
 	rq->special = clone;
 	rq->cmd_flags |= REQ_DONTPREP;
 
-- 
1.6.0.2

