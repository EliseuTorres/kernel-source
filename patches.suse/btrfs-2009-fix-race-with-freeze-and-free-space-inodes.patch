From: Josef Bacik <jbacik@fusionio.com>
Date: Fri, 14 Sep 2012 11:22:38 -0400
Patch-mainline: 3.7
Git-commit: 98114659e0d467e2c0ee6f24f2429329328fc312
References: FATE#312888
Subject: [PATCH] Btrfs: fix race with freeze and free space inodes

So we start our freeze, somebody comes in and does an fsync() on a file
where we have to commit a transaction for whatever reason, and we will
deadlock because the freeze is waiting on FS_FREEZE people to stop writing
to the file system, but the transaction is waiting for its free space inodes
to be written out, which are in turn waiting on sb_start_intwrite while
trying to write the file extents.  To fix this we'll just skip the
sb_start_intwrite() if we TRANS_JOIN_NOLOCK since we're being waited on by a
transaction commit so we're safe wrt to freeze and this will keep us from
deadlocking.  Thanks,

Signed-off-by: Josef Bacik <jbacik@fusionio.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/transaction.c |   16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

--- a/fs/btrfs/transaction.c
+++ b/fs/btrfs/transaction.c
@@ -33,9 +33,10 @@
 
 #define BTRFS_ROOT_TRANS_TAG 0
 
-/* stubs, not used */
+/* stubs */
 static inline int __sb_start_write(struct super_block *sb, int level, bool wait) { return 1; }
 static inline void sb_start_intwrite(struct super_block *sb) { }
+static inline void sb_end_intwrite(struct super_block *sb) { }
 
 void put_transaction(struct btrfs_transaction *transaction)
 {
@@ -346,7 +347,15 @@ again:
 	if (!h)
 		return ERR_PTR(-ENOMEM);
 
-	if (!__sb_start_write(root->fs_info->sb, 0 /*SB_FREEZE_FS*/, false)) {
+	/*
+	 * If we are JOIN_NOLOCK we're already committing a transaction and
+	 * waiting on this guy, so we don't need to do the sb_start_intwrite
+	 * because we're already holding a ref.  We need this because we could
+	 * have raced in and did an fsync() on a file which can kick a commit
+	 * and then we deadlock with somebody doing a freeze.
+	 */
+	if (type != TRANS_JOIN_NOLOCK &&
+	    !__sb_start_write(root->fs_info->sb, 0 /*SB_FREEZE_FS*/, false)) {
 		if (type == TRANS_JOIN_FREEZE)
 			return ERR_PTR(-EPERM);
 		sb_start_intwrite(root->fs_info->sb);
@@ -602,6 +611,9 @@ static int __btrfs_end_transaction(struc
 		}
 	}
 
+	if (lock)
+		sb_end_intwrite(root->fs_info->sb);
+
 	WARN_ON(cur_trans != info->running_transaction);
 	WARN_ON(atomic_read(&cur_trans->num_writers) < 1);
 	atomic_dec(&cur_trans->num_writers);
