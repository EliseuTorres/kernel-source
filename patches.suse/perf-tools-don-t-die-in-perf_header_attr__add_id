From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Tue, 17 Nov 2009 01:18:10 -0200
Subject: perf tools: Don't die() in perf_header_attr__add_id()
Patch-mainline: v2.6.33-rc1
Git-commit: 5875412152ce67fb5087157b86ab6597f91d23e8

Propagate the errors instead, the users are the ones to decide
what to do if a library call fails.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: Mike Galbraith <efault@gmx.de>
Cc: Paul Mackerras <paulus@samba.org>
Cc: Peter Zijlstra <peterz@infradead.org>
LKML-Reference: <1258427892-16312-2-git-send-email-acme@infradead.org>
Signed-off-by: Ingo Molnar <mingo@elte.hu>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 tools/perf/builtin-record.c |    5 ++++-
 tools/perf/util/header.c    |   18 ++++++++++++------
 tools/perf/util/header.h    |    2 +-
 3 files changed, 17 insertions(+), 8 deletions(-)

diff --git a/tools/perf/builtin-record.c b/tools/perf/builtin-record.c
index 5411be4..2a85205 100644
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@ -327,7 +327,10 @@ try_again:
 		exit(-1);
 	}
 
-	perf_header_attr__add_id(h_attr, read_data.id);
+	if (perf_header_attr__add_id(h_attr, read_data.id) < 0) {
+		pr_warning("Not enough memory to add id\n");
+		exit(-1);
+	}
 
 	assert(fd[nr_cpu][counter] >= 0);
 	fcntl(fd[nr_cpu][counter], F_SETFL, O_NONBLOCK);
diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c
index 23ccdda..dee1ed2 100644
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@ -39,18 +39,23 @@ void perf_header_attr__delete(struct perf_header_attr *self)
 	free(self);
 }
 
-void perf_header_attr__add_id(struct perf_header_attr *self, u64 id)
+int perf_header_attr__add_id(struct perf_header_attr *self, u64 id)
 {
 	int pos = self->ids;
 
 	self->ids++;
 	if (self->ids > self->size) {
-		self->size *= 2;
-		self->id = realloc(self->id, self->size * sizeof(u64));
-		if (!self->id)
-			die("nomem");
+		int nsize = self->size * 2;
+		u64 *nid = realloc(self->id, nsize * sizeof(u64));
+
+		if (nid == NULL)
+			return -1;
+
+		self->size = nsize;
+		self->id = nid;
 	}
 	self->id[pos] = id;
+	return 0;
 }
 
 /*
@@ -444,7 +449,8 @@ struct perf_header *perf_header__read(int fd)
 		for (j = 0; j < nr_ids; j++) {
 			do_read(fd, &f_id, sizeof(f_id));
 
-			perf_header_attr__add_id(attr, f_id);
+			if (perf_header_attr__add_id(attr, f_id) < 0)
+				die("nomem");
 		}
 		if (perf_header__add_attr(self, attr) < 0)
 			 die("nomem");
diff --git a/tools/perf/util/header.h b/tools/perf/util/header.h
index b0d5cd7..f46a94e 100644
--- a/tools/perf/util/header.h
+++ b/tools/perf/util/header.h
@@ -67,7 +67,7 @@ char *perf_header__find_event(u64 id);
 struct perf_header_attr *perf_header_attr__new(struct perf_event_attr *attr);
 void perf_header_attr__delete(struct perf_header_attr *self);
 
-void perf_header_attr__add_id(struct perf_header_attr *self, u64 id);
+int perf_header_attr__add_id(struct perf_header_attr *self, u64 id);
 
 u64 perf_header__sample_type(struct perf_header *header);
 struct perf_event_attr *

