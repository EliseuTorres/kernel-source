From 3c5308285cad0d6617e9535492c424beb47383f1 Mon Sep 17 00:00:00 2001
From: NeilBrown <neilb@suse.de>
Date: Thu, 24 Nov 2011 14:19:30 +1100
Subject: [PATCH 5/5] md/raid10 - add failfast handling for writes.
References: Fate#311379
Patch-mainline: 3.3?

When writing to a fastfail device we use REQ_FASTFAIL_DEV unless it is
the only device being written to.
For resync/recovery assume there was a working device to read from so
always use REQ_FASTFAIL_DEV.

If a write for resync/recovery fails we just fail the device - there
is not much else to do.

If a normal write fail but the device cannot be failed (must be only
one left) we queue for write error handling.

Signed-off-by: NeilBrown <neilb@suse.de>
---
 drivers/md/raid10.c |  114 ++++++++++++++++++++++++++++++++++++++++++++++++----
 drivers/md/raid10.h |    1 
 2 files changed, 108 insertions(+), 7 deletions(-)

--- linux-3.0-SLE11-SP2.orig/drivers/md/raid10.c
+++ linux-3.0-SLE11-SP2/drivers/md/raid10.c
@@ -291,12 +291,17 @@ static void raid10_end_write_request(str
 	r10bio_t *r10_bio = bio->bi_private;
 	int slot, dev;
 	conf_t *conf = r10_bio->mddev->private;
+	struct bio *to_put;
+	mdk_rdev_t *rdev;
 
 	for (slot = 0; slot < conf->copies; slot++)
 		if (r10_bio->devs[slot].bio == bio)
 			break;
 	dev = r10_bio->devs[slot].devnum;
+	rdev = conf->mirrors[dev].rdev;
 
+	to_put = bio;
+	r10_bio->devs[slot].bio = NULL;
 	/*
 	 * this branch is our 'one mirror IO has finished' event handler:
 	 */
@@ -304,6 +309,17 @@ static void raid10_end_write_request(str
 		md_error(r10_bio->mddev, conf->mirrors[dev].rdev);
 		/* an I/O failed, we can't clear the bitmap */
 		set_bit(R10BIO_Degraded, &r10_bio->state);
+
+		if (test_bit(FailFast, &rdev->flags) &&
+		    !test_bit(Faulty, &rdev->flags)) {
+			/* This is the only remaining device,
+			 * We need to retry the write without
+			 * FailFast
+			 */
+			set_bit(R10BIO_WriteError, &r10_bio->state);
+			r10_bio->devs[slot].bio = to_put;
+			to_put = NULL;
+		}
 	} else
 		/*
 		 * Set R10BIO_Uptodate in our master bio, so that
@@ -324,6 +340,9 @@ static void raid10_end_write_request(str
 	 * already.
 	 */
 	if (atomic_dec_and_test(&r10_bio->remaining)) {
+		if (test_bit(R10BIO_WriteError, &r10_bio->state))
+			reschedule_retry(r10_bio);
+		else {
 		/* clear the bitmap if all writes complete successfully */
 		bitmap_endwrite(r10_bio->mddev->bitmap, r10_bio->sector,
 				r10_bio->sectors,
@@ -331,9 +350,13 @@ static void raid10_end_write_request(str
 				0);
 		md_write_end(r10_bio->mddev);
 		raid_end_bio_io(r10_bio);
+		}
 	}
 
-	rdev_dec_pending(conf->mirrors[dev].rdev, conf->mddev);
+	if (to_put) {
+		rdev_dec_pending(rdev, conf->mddev);
+		bio_put(to_put);
+	}
 }
 
 
@@ -724,6 +747,7 @@ static void unfreeze_array(conf_t *conf)
 	spin_unlock_irq(&conf->resync_lock);
 }
 
+static int enough(conf_t *conf, int ignore);
 static int make_request(mddev_t *mddev, struct bio * bio)
 {
 	conf_t *conf = mddev->private;
@@ -906,6 +930,9 @@ static int make_request(mddev_t *mddev,
 		mbio->bi_bdev = conf->mirrors[d].rdev->bdev;
 		mbio->bi_end_io	= raid10_end_write_request;
 		mbio->bi_rw = WRITE | do_sync | do_fua;
+		if (test_bit(FailFast, &conf->mirrors[d].rdev->flags) &&
+		    enough(conf, d))
+			mbio->bi_rw |= REQ_FAILFAST_DEV;
 		mbio->bi_private = r10_bio;
 
 		atomic_inc(&r10_bio->remaining);
@@ -1034,7 +1061,7 @@ static void close_sync(conf_t *conf)
 /* check if there are enough drives for
  * every block to appear on atleast one
  */
-static int enough(conf_t *conf)
+static int enough(conf_t *conf, int ignore)
 {
 	int first = 0;
 
@@ -1042,7 +1069,10 @@ static int enough(conf_t *conf)
 		int n = conf->copies;
 		int cnt = 0;
 		while (n--) {
-			if (conf->mirrors[first].rdev)
+			mdk_rdev_t *rdev = conf->mirrors[first].rdev;
+			if (rdev &&
+			    test_bit(In_sync, &rdev->flags) &&
+			    first != ignore)
 				cnt++;
 			first = (first+1) % conf->raid_disks;
 		}
@@ -1096,7 +1126,7 @@ static int raid10_add_disk(mddev_t *mdde
 		 * very different from resync
 		 */
 		return -EBUSY;
-	if (!enough(conf))
+	if (!enough(conf, -1))
 		return -EINVAL;
 
 	if (rdev->raid_disk >= 0)
@@ -1158,7 +1188,7 @@ static int raid10_remove_disk(mddev_t *m
 		 * is not possible.
 		 */
 		if (!test_bit(Faulty, &rdev->flags) &&
-		    enough(conf)) {
+		    enough(conf, -1)) {
 			err = -EBUSY;
 			goto abort;
 		}
@@ -1348,6 +1378,8 @@ static void sync_request_write(mddev_t *
 		atomic_inc(&r10_bio->remaining);
 		md_sync_acct(conf->mirrors[d].rdev->bdev, tbio->bi_size >> 9);
 
+		if (test_bit(FailFast, &conf->mirrors[d].rdev->flags))
+			tbio->bi_rw |= REQ_FAILFAST_DEV;
 		tbio->bi_sector += conf->mirrors[d].rdev->data_offset;
 		tbio->bi_bdev = conf->mirrors[d].rdev->bdev;
 		generic_make_request(tbio);
@@ -1613,6 +1645,70 @@ static void fix_read_error(conf_t *conf,
 	}
 }
 
+static void bi_complete(struct bio *bio, int error)
+{
+	complete((struct completion *)bio->bi_private);
+}
+
+static int submit_bio_wait(int rw, struct bio *bio)
+{
+	struct completion event;
+	rw |= REQ_SYNC;
+
+	init_completion(&event);
+	bio->bi_private = &event;
+	bio->bi_end_io = bi_complete;
+	submit_bio(rw, bio);
+	wait_for_completion(&event);
+
+	return test_bit(BIO_UPTODATE, &bio->bi_flags);
+}
+
+static void handle_write_error(conf_t *conf, r10bio_t *r10_bio)
+{
+	int slot;
+
+	for (slot = 0; slot < conf->copies; slot++) {
+		struct bio *wbio = r10_bio->devs[slot].bio;
+		mdk_rdev_t *rdev;
+		int d;
+		if (!wbio)
+			continue;
+		/* We got a write error on this FailFast
+		 * device.  Need to try again without
+		 * FailFast as it is only device remaining
+		 */
+		wbio->bi_sector = r10_bio->devs[slot].addr;
+		wbio->bi_flags &= ~(BIO_POOL_MASK-1);
+		wbio->bi_flags |= 1 << BIO_UPTODATE;
+		wbio->bi_rw = WRITE;
+		wbio->bi_vcnt = r10_bio->master_bio->bi_vcnt;
+		memcpy(wbio->bi_io_vec,
+		       r10_bio->master_bio->bi_io_vec,
+		       wbio->bi_vcnt *sizeof(struct bio_vec));
+		wbio->bi_idx = r10_bio->master_bio->bi_idx;
+		wbio->bi_size = r10_bio->sectors << 9;
+
+		d = r10_bio->devs[slot].devnum;
+		rdev = conf->mirrors[d].rdev;
+		wbio->bi_sector += rdev->data_offset;
+		wbio->bi_bdev = rdev->bdev;
+		if (submit_bio_wait(WRITE, wbio) != 0)
+			set_bit(R10BIO_Uptodate, &r10_bio->state);
+		else
+			set_bit(R10BIO_Degraded, &r10_bio->state);
+		rdev_dec_pending(rdev, conf->mddev);
+	}
+	/* Now we can really finish the request */
+	bitmap_endwrite(r10_bio->mddev->bitmap, r10_bio->sector,
+			r10_bio->sectors,
+			!test_bit(R10BIO_Degraded, &r10_bio->state),
+			0);
+	md_write_end(r10_bio->mddev);
+	raid_end_bio_io(r10_bio);
+}
+
+
 static void raid10d(mddev_t *mddev)
 {
 	r10bio_t *r10_bio;
@@ -1643,7 +1739,9 @@ static void raid10d(mddev_t *mddev)
 
 		mddev = r10_bio->mddev;
 		conf = mddev->private;
-		if (test_bit(R10BIO_IsSync, &r10_bio->state))
+		if (test_bit(R10BIO_WriteError, &r10_bio->state))
+			handle_write_error(conf, r10_bio);
+		else if (test_bit(R10BIO_IsSync, &r10_bio->state))
 			sync_request_write(mddev, r10_bio);
 		else if (test_bit(R10BIO_IsRecover, &r10_bio->state))
 			recovery_request_write(mddev, r10_bio);
@@ -1942,6 +2040,8 @@ static sector_t sync_request(mddev_t *md
 				bio->bi_rw = WRITE;
 				bio->bi_sector = r10_bio->devs[k].addr +
 					conf->mirrors[i].rdev->data_offset;
+				if (test_bit(FailFast, &conf->mirrors[i].rdev->flags))
+					bio->bi_rw |= REQ_FAILFAST_DEV;
 				bio->bi_bdev = conf->mirrors[i].rdev->bdev;
 
 				r10_bio->devs[0].devnum = d;
@@ -2313,7 +2413,7 @@ static int run(mddev_t *mddev)
 		disk->head_position = 0;
 	}
 	/* need to check that every block has at least one working mirror */
-	if (!enough(conf)) {
+	if (!enough(conf, -1)) {
 		printk(KERN_ERR "md/raid10:%s: not enough operational mirrors.\n",
 		       mdname(mddev));
 		goto out_free_conf;
--- linux-3.0-SLE11-SP2.orig/drivers/md/raid10.h
+++ linux-3.0-SLE11-SP2/drivers/md/raid10.h
@@ -121,4 +121,5 @@ struct r10bio_s {
 #define	R10BIO_Degraded 3
 /* failfast devices did receive failfast requests. */
 #define	R10BIO_FailFast 4
+#define	R10BIO_WriteError 8
 #endif
