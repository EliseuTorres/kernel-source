From: Petr Tesarik <ptesarik@suse.cz>
Subject: (un)xlate_dev_mem_ptr: use phys_addr_t for the @phys parameter
Patch-Mainline: no
References: FATE#310031

To read/write 64-bit physical addresses on 32-bit architectures,
the type must be changed to phys_addr_t. It is also semantically
more exact.

Note that the default xlate_dev_mem_ptr() is defined as a macro,
so no adjustment is needed there.

Signed-off-by: Petr Tesarik <ptesarik@suse.cz>
---
 arch/ia64/include/asm/uaccess.h |    2 +-
 arch/x86/include/asm/io.h       |    4 ++--
 arch/x86/mm/ioremap.c           |   24 ++++++++++++++++++------
 drivers/char/mem.c              |    2 +-
 4 files changed, 22 insertions(+), 10 deletions(-)

--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -119,7 +119,7 @@ static inline int range_is_allowed(unsig
 }
 #endif
 
-void __attribute__((weak)) unxlate_dev_mem_ptr(unsigned long phys, void *addr)
+void __attribute__((weak)) unxlate_dev_mem_ptr(phys_addr_t phys, void *addr)
 {
 }
 
--- a/arch/x86/include/asm/io.h
+++ b/arch/x86/include/asm/io.h
@@ -180,8 +180,8 @@ extern void set_iounmap_nonlazy(void);
 # include "io_64.h"
 #endif
 
-extern void *xlate_dev_mem_ptr(unsigned long phys);
-extern void unxlate_dev_mem_ptr(unsigned long phys, void *addr);
+extern void *xlate_dev_mem_ptr(phys_addr_t phys);
+extern void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr);
 
 extern int ioremap_change_attr(unsigned long vaddr, unsigned long size,
 				unsigned long prot_val);
--- a/arch/x86/mm/ioremap.c
+++ b/arch/x86/mm/ioremap.c
@@ -369,26 +369,38 @@ EXPORT_SYMBOL(iounmap);
  * Convert a physical pointer to a virtual kernel pointer for /dev/mem
  * access
  */
-void *xlate_dev_mem_ptr(unsigned long phys)
+void *xlate_dev_mem_ptr(phys_addr_t phys)
 {
 	void *addr;
-	unsigned long start = phys & PAGE_MASK;
+	unsigned long pfn = phys >> PAGE_SHIFT;
+	phys_addr_t start = phys & PHYSICAL_PAGE_MASK;
 
 	/* If page is RAM, we can use __va. Otherwise ioremap and unmap. */
-	if (page_is_ram(start >> PAGE_SHIFT))
+	if (page_is_ram(pfn)) {
+		if (phys >= __pa(high_memory))
+			return pfn_valid(pfn)
+				? kmap(pfn_to_page(pfn))
+				: NULL;
 		return __va(phys);
+	}
 
 	addr = (void __force *)ioremap_default(start, PAGE_SIZE);
 	if (addr)
-		addr = (void *)((unsigned long)addr | (phys & ~PAGE_MASK));
+		addr = (void *)((unsigned long)addr |
+			((unsigned long)phys & ~PAGE_MASK));
 
 	return addr;
 }
 
-void unxlate_dev_mem_ptr(unsigned long phys, void *addr)
+void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr)
 {
-	if (page_is_ram(phys >> PAGE_SHIFT))
+	unsigned long pfn = phys >> PAGE_SHIFT;
+
+	if (page_is_ram(pfn)) {
+		if (phys >= __pa(high_memory))
+			kunmap(pfn_to_page(pfn));
 		return;
+	}
 
 	iounmap((void __iomem *)((unsigned long)addr & PAGE_MASK));
 	return;
--- a/arch/ia64/include/asm/uaccess.h
+++ b/arch/ia64/include/asm/uaccess.h
@@ -366,7 +366,7 @@ ia64_done_with_exception (struct pt_regs
 
 #define ARCH_HAS_TRANSLATE_MEM_PTR	1
 static __inline__ char *
-xlate_dev_mem_ptr (unsigned long p)
+xlate_dev_mem_ptr (phys_addr_t p)
 {
 	struct page *page;
 	char * ptr;
