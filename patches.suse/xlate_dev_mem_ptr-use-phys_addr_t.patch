From: Petr Tesarik <ptesarik@suse.cz>
Subject: (un)xlate_dev_mem_ptr: use phys_addr_t for the @phys parameter
Patch-Mainline: no
References: FATE#310031

To read/write 64-bit physical addresses on 32-bit architectures,
the type must be changed to phys_addr_t. It is also semantically
more exact.

Note that the default xlate_dev_mem_ptr() is defined as a macro,
so no adjustment is needed there.

Signed-off-by: Petr Tesarik <ptesarik@suse.cz>
---
 arch/ia64/include/asm/uaccess.h |    2 +-
 arch/x86/include/asm/io.h       |    4 ++--
 arch/x86/mm/ioremap.c           |   24 ++++++++++++++++++------
 drivers/char/mem.c              |    2 +-
 4 files changed, 22 insertions(+), 10 deletions(-)

Index: linux-3.0-tmp-jikos/drivers/char/mem.c
===================================================================
--- linux-3.0-tmp-jikos.orig/drivers/char/mem.c
+++ linux-3.0-tmp-jikos/drivers/char/mem.c
@@ -82,7 +82,7 @@ static inline int range_is_allowed(unsig
 }
 #endif
 
-void __weak unxlate_dev_mem_ptr(unsigned long phys, void *addr)
+void __weak unxlate_dev_mem_ptr(phys_addr_t phys, void *addr)
 {
 }
 
Index: linux-3.0-tmp-jikos/arch/x86/include/asm/io.h
===================================================================
--- linux-3.0-tmp-jikos.orig/arch/x86/include/asm/io.h
+++ linux-3.0-tmp-jikos/arch/x86/include/asm/io.h
@@ -311,8 +311,8 @@ BUILDIO(b, b, char)
 BUILDIO(w, w, short)
 BUILDIO(l, , int)
 
-extern void *xlate_dev_mem_ptr(unsigned long phys);
-extern void unxlate_dev_mem_ptr(unsigned long phys, void *addr);
+extern void *xlate_dev_mem_ptr(phys_addr_t phys);
+extern void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr);
 
 extern int ioremap_change_attr(unsigned long vaddr, unsigned long size,
 				unsigned long prot_val);
Index: linux-3.0-tmp-jikos/arch/x86/mm/ioremap.c
===================================================================
--- linux-3.0-tmp-jikos.orig/arch/x86/mm/ioremap.c
+++ linux-3.0-tmp-jikos/arch/x86/mm/ioremap.c
@@ -308,26 +308,39 @@ EXPORT_SYMBOL(iounmap);
  * Convert a physical pointer to a virtual kernel pointer for /dev/mem
  * access
  */
-void *xlate_dev_mem_ptr(unsigned long phys)
+void *xlate_dev_mem_ptr(phys_addr_t phys)
 {
 	void *addr;
-	unsigned long start = phys & PAGE_MASK;
+	unsigned long pfn = phys >> PAGE_SHIFT;
+	phys_addr_t start = phys & PHYSICAL_PAGE_MASK;
 
 	/* If page is RAM, we can use __va. Otherwise ioremap and unmap. */
-	if (page_is_ram(start >> PAGE_SHIFT))
+ 	if (page_is_ram(pfn)) {
+ 		if (phys >= __pa(high_memory))
+ 			return pfn_valid(pfn)
+ 				? kmap(pfn_to_page(pfn))
+ 				: NULL;
+
 		return __va(phys);
+	}
 
 	addr = (void __force *)ioremap_cache(start, PAGE_SIZE);
 	if (addr)
-		addr = (void *)((unsigned long)addr | (phys & ~PAGE_MASK));
+ 		addr = (void *)((unsigned long)addr |
+ 			((unsigned long)phys & ~PAGE_MASK));
 
 	return addr;
 }
 
-void unxlate_dev_mem_ptr(unsigned long phys, void *addr)
+void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr)
 {
-	if (page_is_ram(phys >> PAGE_SHIFT))
+	unsigned long pfn = phys >> PAGE_SHIFT;
+
+	if (page_is_ram(pfn)) {
+		if (phys >= __pa(high_memory))
+			kunmap(pfn_to_page(pfn));
 		return;
+	}
 
 	iounmap((void __iomem *)((unsigned long)addr & PAGE_MASK));
 	return;
Index: linux-3.0-tmp-jikos/arch/ia64/include/asm/uaccess.h
===================================================================
--- linux-3.0-tmp-jikos.orig/arch/ia64/include/asm/uaccess.h
+++ linux-3.0-tmp-jikos/arch/ia64/include/asm/uaccess.h
@@ -366,7 +366,7 @@ ia64_done_with_exception (struct pt_regs
 
 #define ARCH_HAS_TRANSLATE_MEM_PTR	1
 static __inline__ char *
-xlate_dev_mem_ptr (unsigned long p)
+xlate_dev_mem_ptr (phys_addr_t p)
 {
 	struct page *page;
 	char * ptr;
