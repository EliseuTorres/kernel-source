From: Jiri Slaby <jslaby@suse.cz>
Date: Thu, 21 Aug 2014 15:03:08 +0200
Subject: kgr: fix ugly race
Patch-mainline: submitted for review
References: fate#313296

The code contains an ugly race. If you are familiar with this notion:
(kgr_mark_processes . for_each_patch(kgr_patch_code)) || kgr_mark_safe

I.e. informally, when we set the in_progress bit for a process, it can
immediately clear the flag, but still calls the old function, because
we have not installed the slow stub via kgr_patch_code yet. When we
suddenly install it, the process can be in the middle of something
(and not safe to switch at all).

To fix that, we have to introduce a three-state logic:
* old-world-immutable
* old-world
* new-world

This is accomplished by introducing an atomic bit which we set prior
marking processes (old-world-immutable state) and clear after
installing the slow stub (old-world state). The slow stub always
re-sets the in_progress flag to 1 when in the old-world-immutable
universe. So only the exit from the syscall allows the switch to the
new-world.

jk: describe kgr_immutable

Signed-off-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Cc: Vojtech Pavlik <vojtech@suse.cz>
Cc: Petr Mladek <pmladek@suse.cz>
---
 kernel/kgraft.c | 21 +++++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)

diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 3b3e3d2937e5..73ec3a88a827 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -14,6 +14,7 @@
  * any later version.
  */
 
+#include <linux/bitmap.h>
 #include <linux/ftrace.h>
 #include <linux/hardirq.h> /* for in_interrupt() */
 #include <linux/kallsyms.h>
@@ -41,6 +42,16 @@ bool kgr_in_progress;
 static bool kgr_initialized;
 static struct kgr_patch *kgr_patch;
 static bool kgr_revert;
+/*
+ * Setting the per-process flag and stub instantiation has to be performed
+ * "atomically", otherwise the flag might get cleared and old function called
+ * during the race window.
+ *
+ * kgr_immutable is an atomic flag which signals whether we are in the
+ * actual race window and lets the stub take a proper action (reset the
+ * 'in progress' state)
+ */
+static DECLARE_BITMAP(kgr_immutable, 1);
 
 /*
  * The stub needs to modify the RIP value stored in struct pt_regs
@@ -63,7 +74,10 @@ static void kgr_stub_slow(unsigned long ip, unsigned long parent_ip,
 
 	if (in_interrupt())
 		go_old = !*this_cpu_ptr(p->patch->irq_use_new);
-	else
+	else if (test_bit(0, kgr_immutable)) {
+		kgr_mark_task_in_progress(current);
+		go_old = true;
+	} else
 		go_old = kgr_task_in_progress(current);
 
 	if (p->state == KGR_PATCH_REVERT_SLOW)
@@ -557,8 +571,10 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force)
 	 * If the patch has immediate flag set, avoid the lazy-switching
 	 * between universes completely.
 	 */
-	if (!patch->immediate)
+	if (!patch->immediate) {
 		kgr_mark_processes();
+		set_bit(0, kgr_immutable);
+	}
 
 	kgr_for_each_patch_fun(patch, patch_fun) {
 		patch_fun->patch = patch;
@@ -587,6 +603,7 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force)
 		kgr_refs_inc();
 	mutex_unlock(&kgr_in_progress_lock);
 
+	clear_bit(0, kgr_immutable);
 	kgr_handle_irqs();
 	kgr_handle_processes();
 
-- 
2.1.0

