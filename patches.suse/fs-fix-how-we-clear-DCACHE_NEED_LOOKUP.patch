From: Josef Bacik <josef@redhat.com>
Date: Thu, 18 Aug 2011 15:10:26 -0400
Patch-mainline: pending
References: FATE#306586
Git-commit-unstable: 0627ed4f914c079b029243cebf894a371fdb91ce
Subject: [PATCH] fs: fix how we clear DCACHE_NEED_LOOKUP

We've been hitting random -ENOENT's with stress testing btrfs, and it turns out
it's because we're clearing the DCACHE_NEED_LOOKUP flag too early.  We clear it
before we actually have done the lookup, so there is a short period where a
process doing a lookup can come upon the stub dentry still on the hash list and
get it, and then have the flag cleared before it checks for it and will return a
dentry with no d_inode, thus resulting in a -ENOENT.  So instead of allowing the
fs to clear DCACHE_NEED_LOOKUP, instead make it be cleared in __d_instantiate
when we set the d_inode.  This way anybody doing the rcu lookup will have to be
refreshed because we do the rcu seq barrier on the dentry and it will get the
inode.  With this patch the reproducer no longer reproduces the problem.
Thanks,

Signed-off-by: Josef Bacik <josef@redhat.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/inode.c |   17 +----------------
 fs/dcache.c      |   29 ++++-------------------------
 2 files changed, 5 insertions(+), 41 deletions(-)

--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -3959,8 +3959,6 @@ struct inode *btrfs_lookup_dentry(struct
 		memcpy(&location, dentry->d_fsdata, sizeof(struct btrfs_key));
 		kfree(dentry->d_fsdata);
 		dentry->d_fsdata = NULL;
-		/* This thing is hashed, drop it for now */
-		d_drop(dentry);
 	} else {
 		ret = btrfs_inode_by_name(dir, dentry, &location);
 	}
@@ -4027,20 +4025,7 @@ static void btrfs_dentry_release(struct
 static struct dentry *btrfs_lookup(struct inode *dir, struct dentry *dentry,
 				   struct nameidata *nd)
 {
-	struct inode *inode;
-	struct dentry *ret;
-
-	inode = btrfs_lookup_dentry(dir, dentry);
-	if (IS_ERR(inode))
-		return ERR_CAST(inode);
-
-	ret = d_splice_alias(inode, dentry);
-	if (unlikely(d_need_lookup(dentry))) {
-		spin_lock(&dentry->d_lock);
-		dentry->d_flags &= ~DCACHE_NEED_LOOKUP;
-		spin_unlock(&dentry->d_lock);
-	}
-	return ret;
+	return d_splice_alias(btrfs_lookup_dentry(dir, dentry), dentry);
 }
 
 unsigned char btrfs_filetype_table[] = {
--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -344,24 +344,6 @@ void d_drop(struct dentry *dentry)
 EXPORT_SYMBOL(d_drop);
 
 /*
- * d_clear_need_lookup - drop a dentry from cache and clear the need lookup flag
- * @dentry: dentry to drop
- *
- * This is called when we do a lookup on a placeholder dentry that needed to be
- * looked up.  The dentry should have been hashed in order for it to be found by
- * the lookup code, but now needs to be unhashed while we do the actual lookup
- * and clear the DCACHE_NEED_LOOKUP flag.
- */
-void d_clear_need_lookup(struct dentry *dentry)
-{
-	spin_lock(&dentry->d_lock);
-	__d_drop(dentry);
-	dentry->d_flags &= ~DCACHE_NEED_LOOKUP;
-	spin_unlock(&dentry->d_lock);
-}
-EXPORT_SYMBOL(d_clear_need_lookup);
-
-/*
  * Finish off a dentry we've decided to kill.
  * dentry->d_lock must be held, returns with it unlocked.
  * If ref is non-zero, then decrement the refcount too.
@@ -1399,6 +1381,10 @@ static void __d_instantiate(struct dentr
 		list_add(&dentry->d_alias, &inode->i_dentry);
 	}
 	dentry->d_inode = inode;
+	if (d_need_lookup(dentry)) {
+		__d_drop(dentry);
+		dentry->d_flags &= ~DCACHE_NEED_LOOKUP;
+	}
 	dentry_rcuwalk_barrier(dentry);
 	spin_unlock(&dentry->d_lock);
 	fsnotify_d_instantiate(dentry, inode);
@@ -1731,13 +1717,6 @@ struct dentry *d_add_ci(struct dentry *d
 	}
 
 	/*
-	 * We are going to instantiate this dentry, unhash it and clear the
-	 * lookup flag so we can do that.
-	 */
-	if (unlikely(d_need_lookup(found)))
-		d_clear_need_lookup(found);
-
-	/*
 	 * Negative dentry: instantiate it unless the inode is a directory and
 	 * already has a dentry.
 	 */

