From: Andre Przywara <andre.przywara@amd.com>
Subject: [PATCH 2/8] KVM: x86: fix CR8 handling
References: FATE#309761
Git-commit: eea1cff9ab732ea56358ff5e1bd8b99db2e8402d
Patch-mainline: v2.6.38

Enhance the CR8 write function to return an error code so that a #GP
condition can be properly handled.
This fixes a possible issue in VMX, where the RIP would be incremented
despite an injected #GP.

Partly a backport from eea1cff9ab732ea56358ff5e1bd8b99db2e8402d.

Signed-off-by: Andre Przywara <andre.przywara@amd.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/include/asm/kvm_host.h |    2 +-
 arch/x86/kvm/svm.c              |    8 +++++---
 arch/x86/kvm/vmx.c              |    6 ++++--
 arch/x86/kvm/x86.c              |   17 ++++++++++-------
 4 files changed, 20 insertions(+), 13 deletions(-)

Index: linux-2.6.32-SLE11-SP2/arch/x86/include/asm/kvm_host.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/include/asm/kvm_host.h
+++ linux-2.6.32-SLE11-SP2/arch/x86/include/asm/kvm_host.h
@@ -610,7 +610,7 @@ int kvm_task_switch(struct kvm_vcpu *vcp
 void kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);
 void kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3);
 void kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);
-void kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8);
+int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8);
 unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu);
 void kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw);
 void kvm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l);
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/svm.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/svm.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/svm.c
@@ -2159,15 +2159,17 @@ static int emulate_on_interception(struc
 
 static int cr8_write_interception(struct vcpu_svm *svm, struct kvm_run *kvm_run)
 {
+	int r;
+
 	u8 cr8_prev = kvm_get_cr8(&svm->vcpu);
 	/* instruction emulation calls kvm_set_cr8() */
-	emulate_instruction(&svm->vcpu, NULL, 0, 0, 0);
+	r = emulate_instruction(&svm->vcpu, NULL, 0, 0, 0);
 	if (irqchip_in_kernel(svm->vcpu.kvm)) {
 		svm->vmcb->control.intercept_cr_write &= ~INTERCEPT_CR8_MASK;
-		return 1;
+		return r == EMULATE_DONE;
 	}
 	if (cr8_prev <= kvm_get_cr8(&svm->vcpu))
-		return 1;
+		return r == EMULATE_DONE;
 	kvm_run->exit_reason = KVM_EXIT_SET_TPR;
 	return 0;
 }
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/vmx.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/vmx.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/vmx.c
@@ -2996,8 +2996,10 @@ static int handle_cr(struct kvm_vcpu *vc
 		case 8: {
 				u8 cr8_prev = kvm_get_cr8(vcpu);
 				u8 cr8 = kvm_register_read(vcpu, reg);
-				kvm_set_cr8(vcpu, cr8);
-				skip_emulated_instruction(vcpu);
+				if (kvm_set_cr8(vcpu, cr8))
+					kvm_inject_gp(vcpu, 0);
+				else
+					skip_emulated_instruction(vcpu);
 				if (irqchip_in_kernel(vcpu->kvm))
 					return 1;
 				if (cr8_prev <= cr8)
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/x86.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/x86.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/x86.c
@@ -506,16 +506,15 @@ void kvm_set_cr3(struct kvm_vcpu *vcpu,
 }
 EXPORT_SYMBOL_GPL(kvm_set_cr3);
 
-void kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
+int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
 {
-	if (cr8 & CR8_RESERVED_BITS) {
-		kvm_inject_gp(vcpu, 0);
-		return;
-	}
+	if (cr8 & CR8_RESERVED_BITS)
+		return 1;
 	if (irqchip_in_kernel(vcpu->kvm))
 		kvm_lapic_set_tpr(vcpu, cr8);
 	else
 		vcpu->arch.cr8 = cr8;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(kvm_set_cr8);
 
@@ -4338,8 +4337,12 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_v
 	}
 
 	/* re-sync apic's tpr */
-	if (!irqchip_in_kernel(vcpu->kvm))
-		kvm_set_cr8(vcpu, kvm_run->cr8);
+	if (!irqchip_in_kernel(vcpu->kvm)) {
+		if (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {
+			r = -EINVAL;
+			goto out;
+		}
+	}
 
 	if (vcpu->arch.pio.cur_count) {
 		r = complete_pio(vcpu);
