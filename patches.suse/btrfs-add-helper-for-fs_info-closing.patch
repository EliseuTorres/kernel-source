From: David Sterba <dsterba@suse.cz>
Date: Tue, 31 May 2011 18:07:27 +0200
Patch-mainline: yes
References: FATE#306586
Subject: [PATCH] btrfs: add helper for fs_info->closing

wrap checking of filesystem 'closing' flag and fix a few missing memory
barriers.

Signed-off-by: David Sterba <dsterba@suse.cz>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/ctree.h            |    9 +++++++++
 fs/btrfs/extent-tree.c      |    3 +--
 fs/btrfs/file.c             |    4 ++--
 fs/btrfs/free-space-cache.c |   10 ++++------
 fs/btrfs/inode-map.c        |    3 +--
 fs/btrfs/inode.c            |    3 +--
 fs/btrfs/scrub.c            |    2 +-
 fs/btrfs/transaction.c      |    2 +-
 8 files changed, 20 insertions(+), 16 deletions(-)

Index: linux-2.6.32-SLE11-SP2/fs/btrfs/ctree.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/ctree.h
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/ctree.h
@@ -2354,6 +2354,15 @@ int btrfs_drop_subtree(struct btrfs_tran
 			struct btrfs_root *root,
 			struct extent_buffer *node,
 			struct extent_buffer *parent);
+static inline int btrfs_fs_closing(struct btrfs_fs_info *fs_info)
+{
+	/*
+	 * Get synced with close_ctree()
+	 */
+	smp_mb();
+	return fs_info->closing;
+}
+
 /* root-item.c */
 int btrfs_find_root_ref(struct btrfs_root *tree_root,
 			struct btrfs_path *path,
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/extent-tree.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/extent-tree.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/extent-tree.c
@@ -365,8 +365,7 @@ again:
 	nritems = btrfs_header_nritems(leaf);
 
 	while (1) {
-		smp_mb();
-		if (fs_info->closing > 1) {
+		if (btrfs_fs_closing(fs_info) > 1) {
 			last = (u64)-1;
 			break;
 		}
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/file.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/file.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/file.c
@@ -127,7 +127,7 @@ int btrfs_add_inode_defrag(struct btrfs_
 	if (!btrfs_test_opt(root, AUTO_DEFRAG))
 		return 0;
 
-	if (root->fs_info->closing)
+	if (btrfs_fs_closing(root->fs_info))
 		return 0;
 
 	if (BTRFS_I(inode)->in_defrag)
@@ -227,7 +227,7 @@ int btrfs_run_defrag_inodes(struct btrfs
 		first_ino = defrag->ino + 1;
 		rb_erase(&defrag->rb_node, &fs_info->defrag_inodes);
 
-		if (fs_info->closing)
+		if (btrfs_fs_closing(fs_info))
 			goto next_free;
 
 		spin_unlock(&fs_info->defrag_inodes_lock);
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/free-space-cache.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/free-space-cache.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/free-space-cache.c
@@ -97,7 +97,7 @@ struct inode *lookup_free_space_inode(st
 		return inode;
 
 	spin_lock(&block_group->lock);
-	if (!root->fs_info->closing) {
+	if (!btrfs_fs_closing(root->fs_info)) {
 		block_group->inode = igrab(inode);
 		block_group->iref = 1;
 	}
@@ -492,8 +492,7 @@ int load_free_space_cache(struct btrfs_f
 	 * If we're unmounting then just return, since this does a search on the
 	 * normal root and not the commit root and we could deadlock.
 	 */
-	smp_mb();
-	if (fs_info->closing)
+	if (btrfs_fs_closing(fs_info))
 		return 0;
 
 	/*
@@ -2407,7 +2406,7 @@ struct inode *lookup_free_ino_inode(stru
 		return inode;
 
 	spin_lock(&root->cache_lock);
-	if (!root->fs_info->closing)
+	if (!btrfs_fs_closing(root->fs_info))
 		root->cache_inode = igrab(inode);
 	spin_unlock(&root->cache_lock);
 
@@ -2437,8 +2436,7 @@ int load_free_ino_cache(struct btrfs_fs_
 	 * If we're unmounting then just return, since this does a search on the
 	 * normal root and not the commit root and we could deadlock.
 	 */
-	smp_mb();
-	if (fs_info->closing)
+	if (btrfs_fs_closing(fs_info))
 		return 0;
 
 	path = btrfs_alloc_path();
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/inode-map.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/inode-map.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/inode-map.c
@@ -62,8 +62,7 @@ again:
 		goto out;
 
 	while (1) {
-		smp_mb();
-		if (fs_info->closing)
+		if (btrfs_fs_closing(fs_info))
 			goto out;
 
 		leaf = path->nodes[0];
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/inode.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/inode.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/inode.c
@@ -4255,8 +4255,7 @@ int btrfs_write_inode(struct inode *inod
 	if (BTRFS_I(inode)->dummy_inode)
 		return 0;
 
-	smp_mb();
-	if (root->fs_info->closing && is_free_space_inode(root, inode))
+	if (btrfs_fs_closing(root->fs_info) && is_free_space_inode(root, inode))
 		nolock = true;
 
 	if (wait) {
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/scrub.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/scrub.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/scrub.c
@@ -1182,7 +1182,7 @@ int btrfs_scrub_dev(struct btrfs_root *r
 	int ret;
 	struct btrfs_device *dev;
 
-	if (root->fs_info->closing)
+	if (btrfs_fs_closing(root->fs_info))
 		return -EINVAL;
 
 	/*
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/transaction.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/transaction.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/transaction.c
@@ -816,7 +816,7 @@ int btrfs_defrag_root(struct btrfs_root
 		btrfs_btree_balance_dirty(info->tree_root, nr);
 		cond_resched();
 
-		if (root->fs_info->closing || ret != -EAGAIN)
+		if (btrfs_fs_closing(root->fs_info) || ret != -EAGAIN)
 			break;
 	}
 	root->defrag_running = 0;
