From: Joerg Roedel <joerg.roedel@amd.com>
Subject: [PATCH 4/5] KVM: X86: Implement call-back to propagate virtual_tsc_khz
Reference: FATE#309762
Git-commit: 4051b18801f5b47bb0369feefdc80e57819d0ddf
Patch-mainline: v3.0-rc1

This patch implements a call-back into the architecture code
to allow the propagation of changes to the virtual tsc_khz
of the vcpu.
On SVM it updates the tsc_ratio variable, on VMX it does
nothing.

Signed-off-by: Joerg Roedel <joerg.roedel@amd.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/include/asm/kvm_host.h |    2 ++
 arch/x86/kvm/svm.c              |   39 +++++++++++++++++++++++++++++++++++++++
 arch/x86/kvm/vmx.c              |   12 ++++++++++++
 3 files changed, 53 insertions(+)

Index: b/arch/x86/include/asm/kvm_host.h
===================================================================
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -536,6 +536,8 @@ struct kvm_x86_ops {
 	u64 (*get_mt_mask)(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio);
 	bool (*gb_page_enable)(void);
 
+	void (*set_tsc_khz)(struct kvm_vcpu *vcpu, u32 user_tsc_khz);
+
 	const struct trace_print_flags *exit_reasons_str;
 };
 
Index: b/arch/x86/kvm/svm.c
===================================================================
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -635,6 +635,43 @@ static u64 svm_scale_tsc(struct kvm_vcpu
 	return _tsc;
 }
 
+static void svm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)
+{
+	struct vcpu_svm *svm = to_svm(vcpu);
+	u64 ratio;
+	u64 khz;
+	u64 tsc;
+
+	/* TSC scaling supported? */
+	if (!svm_has(SVM_FEATURE_TSC_RATE))
+		return;
+
+	/* TSC-Scaling disabled or guest TSC same frequency as host TSC? */
+	if (user_tsc_khz == 0) {
+		vcpu->arch.virtual_tsc_khz = 0;
+		svm->tsc_ratio = TSC_RATIO_DEFAULT;
+		return;
+	}
+
+	svm_get_msr(vcpu, MSR_IA32_TSC, &tsc);
+
+	khz = user_tsc_khz;
+
+	/* TSC scaling required  - calculate ratio */
+	ratio = khz << 32;
+	do_div(ratio, tsc_khz);
+
+	if (ratio == 0 || ratio & TSC_RATIO_RSVD) {
+		WARN_ONCE(1, "Invalid TSC ratio - virtual-tsc-khz=%u\n",
+				user_tsc_khz);
+		return;
+	}
+	vcpu->arch.virtual_tsc_khz = user_tsc_khz;
+	svm->tsc_ratio             = ratio;
+
+	svm_set_msr(vcpu, MSR_IA32_TSC, tsc);
+}
+
 static void init_seg(struct vmcb_seg *seg)
 {
 	seg->selector = 0;
@@ -3332,6 +3369,8 @@ static struct kvm_x86_ops svm_x86_ops =
 
 	.exit_reasons_str = svm_exit_reasons_str,
 	.gb_page_enable = svm_gb_page_enable,
+
+	.set_tsc_khz = svm_set_tsc_khz,
 };
 
 static int __init svm_init(void)
Index: b/arch/x86/kvm/vmx.c
===================================================================
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -4079,6 +4079,16 @@ static bool vmx_gb_page_enable(void)
 	return false;
 }
 
+/*
+ * Empty call-back. Needs to be implemented when VMX enables the SET_TSC_KHZ
+ * ioctl. In this case the call-back should update internal vmx state to make
+ * the changes effective.
+ */
+static void vmx_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)
+{
+	/* Nothing to do here */
+}
+
 static struct kvm_x86_ops vmx_x86_ops = {
 	.cpu_has_kvm_support = cpu_has_kvm_support,
 	.disabled_by_bios = vmx_disabled_by_bios,
@@ -4146,6 +4156,8 @@ static struct kvm_x86_ops vmx_x86_ops =
 
 	.exit_reasons_str = vmx_exit_reasons_str,
 	.gb_page_enable = vmx_gb_page_enable,
+
+	.set_tsc_khz = vmx_set_tsc_khz,
 };
 
 static int __init vmx_init(void)
