From c5bd4d85d356199ebdbc2c8bbfff86a292c65a9f Mon Sep 17 00:00:00 2001
From: Allan Stephens <allan.stephens@windriver.com>
Date: Thu, 7 Apr 2011 11:58:08 -0400
Subject: [PATCH 030/183] tipc: Enhance cleanup of broadcast link when contact
 with node is lost
Git-commit: c5bd4d85d356199ebdbc2c8bbfff86a292c65a9f
Patch-mainline: Merged into tipc-devel
References: bnc#797455

Enhances cleanup of broadcast link-related information when contact
with a node is lost.

1) All broadcast link-related cleanup now occurs only if the lost node
   was capable of communicating over the broadcast link.

2) Following cleanup, the lost node is marked as no longer supporting
   the broadcast link, ensuring that any remaining broadcast messages
   received from that node prior to the re-establishment of a normal
   communication link are ignored.

Thanks to Surya [Suryanarayana.Garlapati@emerson.com] for contributing
a prototype version of this patch.

Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Erik Hugne <erik.hugne@ericsson.com>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>

---
 net/tipc/node.c |   32 ++++++++++++++++++--------------
 1 files changed, 18 insertions(+), 14 deletions(-)

diff --git a/net/tipc/node.c b/net/tipc/node.c
index 2d106ef..810b395 100644
--- a/net/tipc/node.c
+++ b/net/tipc/node.c
@@ -331,28 +331,32 @@ static void node_lost_contact(struct tipc_node *n_ptr)
 	char addr_string[16];
 	u32 i;
 
-	/* Clean up broadcast reception remains */
-	n_ptr->bclink.gap_after = n_ptr->bclink.gap_to = 0;
-	while (n_ptr->bclink.deferred_head) {
-		struct sk_buff *buf = n_ptr->bclink.deferred_head;
-		n_ptr->bclink.deferred_head = buf->next;
-		buf_discard(buf);
-	}
-	if (n_ptr->bclink.defragm) {
-		buf_discard(n_ptr->bclink.defragm);
-		n_ptr->bclink.defragm = NULL;
-	}
+	info("Lost contact with %s\n",
+	     tipc_addr_string_fill(addr_string, n_ptr->addr));
+
+	/* Flush broadcast link info associated with lost node */
 
 	if (n_ptr->bclink.supported) {
+		n_ptr->bclink.gap_after = n_ptr->bclink.gap_to = 0;
+		while (n_ptr->bclink.deferred_head) {
+			struct sk_buff *buf = n_ptr->bclink.deferred_head;
+			n_ptr->bclink.deferred_head = buf->next;
+			buf_discard(buf);
+		}
+
+		if (n_ptr->bclink.defragm) {
+			buf_discard(n_ptr->bclink.defragm);
+			n_ptr->bclink.defragm = NULL;
+		}
+
 		tipc_bclink_acknowledge(n_ptr,
 					mod(n_ptr->bclink.acked + 10000));
 		tipc_nmap_remove(&tipc_bcast_nmap, n_ptr->addr);
 		if (n_ptr->addr < tipc_own_addr)
 			tipc_own_tag--;
-	}
 
-	info("Lost contact with %s\n",
-	     tipc_addr_string_fill(addr_string, n_ptr->addr));
+		n_ptr->bclink.supported = 0;
+	}
 
 	/* Abort link changeover */
 	for (i = 0; i < MAX_BEARERS; i++) {
-- 
1.7.8.3

