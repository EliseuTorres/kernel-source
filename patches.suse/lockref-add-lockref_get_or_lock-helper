From b3abd80250c13414bc258b53e57242feb159af91 Mon Sep 17 00:00:00 2001
From: Linus Torvalds <torvalds@linux-foundation.org>
Date: Mon, 2 Sep 2013 11:14:19 -0700
Subject: lockref: add 'lockref_get_or_lock() helper
Git-commit: b3abd80250c13414bc258b53e57242feb159af91
Patch-mainline: v3.12-rc1
References: FATE#317271

This behaves like "lockref_get_not_zero()", but instead of doing nothing
if the count was zero, it returns with the lock held.

This allows callers to revalidate the lockref-protected data structure
if required even if the count was zero to begin with, and possibly
increment the count if it passes muster.

In particular, the dentry code wants this when it wants to turn an
RCU-protected dentry into a stable refcounted one: if the dentry count
it zero, but the sequence number still validates the dentry, we can take
a reference to it.

Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 include/linux/lockref.h | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/include/linux/lockref.h b/include/linux/lockref.h
index 01233e0..0ea0260 100644
--- a/include/linux/lockref.h
+++ b/include/linux/lockref.h
@@ -54,6 +54,22 @@ static inline int lockref_get_not_zero(struct lockref *lockref)
 }
 
 /**
+ * lockref_get_or_lock - Increments count unless the count is 0
+ * @lockcnt: pointer to lockref structure
+ * Return: 1 if count updated successfully or 0 if count was zero
+ * and we got the lock instead.
+ */
+static inline int lockref_get_or_lock(struct lockref *lockref)
+{
+	spin_lock(&lockref->lock);
+	if (!lockref->count)
+		return 0;
+	lockref->count++;
+	spin_unlock(&lockref->lock);
+	return 1;
+}
+
+/**
  * lockref_put_or_lock - decrements count unless count <= 1 before decrement
  * @lockcnt: pointer to lockref structure
  * Return: 1 if count updated successfully or 0 if count <= 1 and lock taken

