From c42b4045ebafda8e622b9db00e79da2814a8c5cf Mon Sep 17 00:00:00 2001
From: Mel Gorman <mgorman@suse.de>
Date: Sun, 9 Mar 2014 11:37:10 +0000
Subject: [PATCH] mm: vmscan: Do not force reclaim file pages until it exceeds
 anon

References: High memory utilisation performance (bnc#859225)
Patch-mainline: No (Unnecessary in mainline)

File pages are force reclaimed if the ratio of inactive/active is low but
it does not take into account the absolute size of file pages vs anon. This
patch takes the absolute size into account.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/vmscan.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/mm/vmscan.c b/mm/vmscan.c
index d1de3ac1..4835f27 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -1863,6 +1863,7 @@ static void get_scan_count(struct zone *zone, struct scan_control *sc,
 					unsigned long *nr)
 {
 	unsigned long anon, file, free;
+	unsigned long inactive_file, active_file;
 	unsigned long anon_prio, file_prio;
 	unsigned long ap, fp;
 	struct zone_reclaim_stat *reclaim_stat = get_reclaim_stat(zone, sc);
@@ -1899,8 +1900,9 @@ static void get_scan_count(struct zone *zone, struct scan_control *sc,
 
 	anon  = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_ANON) +
 		zone_nr_lru_pages(zone, sc, LRU_INACTIVE_ANON);
-	file  = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_FILE) +
-		zone_nr_lru_pages(zone, sc, LRU_INACTIVE_FILE);
+	active_file   = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_FILE);
+	inactive_file = zone_nr_lru_pages(zone, sc, LRU_INACTIVE_FILE);
+	file = active_file + inactive_file;
 
 	/*
 	 * Because workloads change over time (and to avoid overflow)
@@ -1935,7 +1937,7 @@ static void get_scan_count(struct zone *zone, struct scan_control *sc,
 			fraction[1] = 0;
 			denominator = 1;
 			goto out_unlock;
-		} else if (!inactive_file_is_low_global(zone)) {
+		} else if (!inactive_file_is_low_global(zone) && inactive_file > (anon << 1)) {
 			/*
 			 * There is enough inactive page cache, do not
 			 * reclaim anything from the working set right now.
