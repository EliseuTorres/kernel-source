From a1228e1e07f39ae3527f2402767e677ba8d488ab Mon Sep 17 00:00:00 2001
From: David Sterba <dsterba@suse.cz>
Date: Thu, 8 Dec 2011 01:15:35 +0100
Patch-mainline: no
Subject: [PATCH] setpagedirty tracing v2

Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/inode.c           |    5 +++++
 fs/btrfs/ordered-data.c    |    3 +++
 include/linux/mm_types.h   |   10 ++++++++++
 include/linux/page-flags.h |   43 +++++++++++++++++++++++++++++++++++++++++++
 mm/filemap.c               |   27 +++++++++++++++++++++++++--
 mm/page_alloc.c            |    3 +++
 6 files changed, 89 insertions(+), 2 deletions(-)

--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -1616,6 +1616,9 @@ again:
 		btrfs_start_ordered_extent(inode, ordered, 1);
 		goto again;
 	}
+	printk(KERN_ERR "btrfs: fixup failure: flags=0x%lx\n",
+			page->flags);
+	print_stack_trace(&page->dirty_trace, 5);
 
 	BUG();
 	btrfs_set_extent_delalloc(inode, page_start, page_end, &cached_state);
@@ -1662,6 +1665,8 @@ static int btrfs_writepage_start_hook(st
 	fixup->work.func = btrfs_writepage_fixup_worker;
 	fixup->page = page;
 	btrfs_queue_worker(&root->fs_info->fixup_workers, &fixup->work);
+	printk(KERN_ERR "btrfs: schedule fixup for %p 0x%lx\n",
+			page, page->flags);
 	return -EAGAIN;
 }
 
--- a/fs/btrfs/ordered-data.c
+++ b/fs/btrfs/ordered-data.c
@@ -238,6 +238,9 @@ int btrfs_add_ordered_extent(struct inod
 int btrfs_add_ordered_extent_dio(struct inode *inode, u64 file_offset,
 				 u64 start, u64 len, u64 disk_len, int type)
 {
+	if (BTRFS_I(inode)->force_compress) {
+		printk(KERN_ERR "btrfs: submit DIO with inode compression\n");
+	}
 	return __btrfs_add_ordered_extent(inode, file_offset, start, len,
 					  disk_len, type, 1,
 					  BTRFS_COMPRESS_NONE);
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -12,6 +12,8 @@
 #include <linux/completion.h>
 #include <linux/cpumask.h>
 #include <linux/page-debug-flags.h>
+#include <linux/hrtimer.h>
+#include <linux/stacktrace.h>
 #include <asm/page.h>
 #include <asm/mmu.h>
 
@@ -24,6 +26,8 @@ struct address_space;
 
 #define USE_SPLIT_PTLOCKS	(NR_CPUS >= CONFIG_SPLIT_PTLOCK_CPUS)
 
+#define PAGE_STACKTRACE_SIZE   (12UL)
+
 /*
  * Each physical page in the system has a struct page associated with
  * it to keep track of whatever it is we are using the page for at the
@@ -122,6 +126,12 @@ struct page {
 	 */
 	void *shadow;
 #endif
+	/*
+	 * Debugging
+	 */
+	struct list_head bt_list;
+	struct stack_trace dirty_trace;
+	unsigned long dirty_entries[PAGE_STACKTRACE_SIZE];
 };
 
 typedef unsigned long __nocast vm_flags_t;
--- a/include/linux/page-flags.h
+++ b/include/linux/page-flags.h
@@ -209,7 +209,41 @@ TESTPAGEFLAG(Locked, locked)
 PAGEFLAG(Waiters, waiters)
 PAGEFLAG(Error, error) TESTCLEARFLAG(Error, error)
 PAGEFLAG(Referenced, referenced) TESTCLEARFLAG(Referenced, referenced)
+#if 0
 PAGEFLAG(Dirty, dirty) TESTSCFLAG(Dirty, dirty) __CLEARPAGEFLAG(Dirty, dirty)
+#else
+extern void save_page_dirty_trace(struct page *pg);
+static inline int PageDirty(const struct page *page)
+{
+        return test_bit((PG_dirty), (&page-> flags));
+}
+static inline void SetPageDirty(struct page *page)
+{
+        set_bit(PG_dirty, &page->flags);
+	save_page_dirty_trace(page);
+}
+static inline void ClearPageDirty(struct page *page)
+{
+        clear_bit(PG_dirty, &page->flags);
+}
+static inline int TestSetPageDirty(struct page *page)
+{
+        int ret = test_and_set_bit(PG_dirty, &page->flags);
+	if (ret)
+		save_page_dirty_trace(page);
+	return ret;
+}
+static inline int TestClearPageDirty(struct page *page)
+{
+        return test_and_clear_bit(PG_dirty, &page->flags);
+}
+static inline void __ClearPageDirty(struct page *page)
+{
+        __clear_bit(PG_dirty, &page->flags);
+}
+
+#endif
+
 PAGEFLAG(LRU, lru) __CLEARPAGEFLAG(LRU, lru)
 PAGEFLAG(Active, active) __CLEARPAGEFLAG(Active, active)
 	TESTCLEARFLAG(Active, active)
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -1198,8 +1198,9 @@ static void shrink_readahead_size_eio(st
  * This is really ugly. But the goto's actually try to clarify some
  * of the logic when it comes to error handling etc.
  */
-static void do_generic_file_read(struct file *filp, loff_t *ppos,
-		read_descriptor_t *desc, read_actor_t actor)
+static noinline void do_generic_file_read(struct file *filp, loff_t *ppos,
+					  read_descriptor_t *desc,
+					  read_actor_t actor)
 {
 	struct address_space *mapping = filp->f_mapping;
 	struct inode *inode = mapping->host;
@@ -2769,3 +2770,25 @@ int try_to_release_page(struct page *pag
 }
 
 EXPORT_SYMBOL(try_to_release_page);
+
+/* Debugging */
+
+void init_page_dirty_trace(struct page *page)
+{
+       INIT_LIST_HEAD(&page->bt_list);
+       page->dirty_trace.nr_entries = 0;
+}
+EXPORT_SYMBOL(init_page_dirty_trace);
+
+void save_page_dirty_trace(struct page *page)
+{
+       page->dirty_trace.nr_entries = 0;
+       page->dirty_trace.max_entries = PAGE_STACKTRACE_SIZE;
+       page->dirty_trace.entries = page->dirty_entries;
+       page->dirty_trace.skip = 1;
+
+       save_stack_trace(&page->dirty_trace);
+       page->dirty_trace.nr_entries--;
+}
+EXPORT_SYMBOL(save_page_dirty_trace);
+
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -768,6 +768,7 @@ static inline int check_new_page(struct
 	return 0;
 }
 
+extern void init_page_dirty_trace(struct page *page);
 static int prep_new_page(struct page *page, int order, gfp_t gfp_flags)
 {
 	int i;
@@ -790,6 +791,8 @@ static int prep_new_page(struct page *pa
 	if (order && (gfp_flags & __GFP_COMP))
 		prep_compound_page(page, order);
 
+	init_page_dirty_trace(page);
+
 	return 0;
 }
 
