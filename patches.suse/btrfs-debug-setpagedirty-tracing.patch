From: David Sterba <dsterba@suse.cz>
Date: Thu, 8 Dec 2011 01:15:35 +0100
Patch-mainline: no
Subject: [PATCH] setpagedirty tracing v2

Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/inode.c           |    5 +++++
 fs/btrfs/ordered-data.c    |    3 +++
 include/linux/mm_types.h   |   10 ++++++++++
 include/linux/page-flags.h |   36 ++++++++++++++++++++++++++++++++++++
 mm/filemap.c               |   27 +++++++++++++++++++++++++--
 mm/page_alloc.c            |    3 +++
 6 files changed, 82 insertions(+), 2 deletions(-)

diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index c5ccec2..b10d41c 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -1583,6 +1583,9 @@ again:
 		btrfs_start_ordered_extent(inode, ordered, 1);
 		goto again;
 	}
+	printk(KERN_ERR "btrfs: fixup failure: flags=0x%lx\n",
+			page->flags);
+	print_stack_trace(&page->dirty_trace, 5);
 
 	BUG();
 	btrfs_set_extent_delalloc(inode, page_start, page_end, &cached_state);
@@ -1629,6 +1632,8 @@ static int btrfs_writepage_start_hook(struct page *page, u64 start, u64 end)
 	fixup->work.func = btrfs_writepage_fixup_worker;
 	fixup->page = page;
 	btrfs_queue_worker(&root->fs_info->fixup_workers, &fixup->work);
+	printk(KERN_DEBUG "btrfs: schedule fixup for %p 0x%lx\n",
+			page, page->flags);
 	return -EAGAIN;
 }
 
diff --git a/fs/btrfs/ordered-data.c b/fs/btrfs/ordered-data.c
index a1c9404..2a5df8a 100644
--- a/fs/btrfs/ordered-data.c
+++ b/fs/btrfs/ordered-data.c
@@ -230,6 +230,9 @@ int btrfs_add_ordered_extent(struct inode *inode, u64 file_offset,
 int btrfs_add_ordered_extent_dio(struct inode *inode, u64 file_offset,
 				 u64 start, u64 len, u64 disk_len, int type)
 {
+	if (BTRFS_I(inode)->force_compress) {
+		printk(KERN_DEBUG "btrfs: submit DIO with inode compression\n");
+	}
 	return __btrfs_add_ordered_extent(inode, file_offset, start, len,
 					  disk_len, type, 1,
 					  BTRFS_COMPRESS_NONE);
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 774b895..b5b5fd2 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -12,6 +12,8 @@
 #include <linux/completion.h>
 #include <linux/cpumask.h>
 #include <linux/page-debug-flags.h>
+#include <linux/hrtimer.h>
+#include <linux/stacktrace.h>
 #include <asm/page.h>
 #include <asm/mmu.h>
 
@@ -24,6 +26,8 @@ struct address_space;
 
 #define USE_SPLIT_PTLOCKS	(NR_CPUS >= CONFIG_SPLIT_PTLOCK_CPUS)
 
+#define PAGE_STACKTRACE_SIZE   (12UL)
+
 /*
  * Each physical page in the system has a struct page associated with
  * it to keep track of whatever it is we are using the page for at the
@@ -124,6 +128,12 @@ struct page {
 	 */
 	void *shadow;
 #endif
+	/*
+	 * Debugging
+	 */
+	struct list_head bt_list;
+	struct stack_trace dirty_trace;
+	unsigned long dirty_entries[PAGE_STACKTRACE_SIZE];
 }
 /*
  * If another subsystem starts using the double word pairing for atomic
diff --git a/include/linux/page-flags.h b/include/linux/page-flags.h
index e90a673..760f97a 100644
--- a/include/linux/page-flags.h
+++ b/include/linux/page-flags.h
@@ -196,7 +196,43 @@ struct page;	/* forward declaration */
 TESTPAGEFLAG(Locked, locked)
 PAGEFLAG(Error, error) TESTCLEARFLAG(Error, error)
 PAGEFLAG(Referenced, referenced) TESTCLEARFLAG(Referenced, referenced)
+#if 0
 PAGEFLAG(Dirty, dirty) TESTSCFLAG(Dirty, dirty) __CLEARPAGEFLAG(Dirty, dirty)
+#else
+extern void save_page_dirty_trace(struct page *pg);
+static inline int PageDirty(const struct page *page)
+{
+        return (__builtin_constant_p((PG_dirty)) ?
+		constant_test_bit((PG_dirty), (&page-> flags)) :
+		variable_test_bit((PG_dirty), (&page-> flags)));
+}
+static inline void SetPageDirty(struct page *page)
+{
+        set_bit(PG_dirty, &page->flags);
+	save_page_dirty_trace(page);
+}
+static inline void ClearPageDirty(struct page *page)
+{
+        clear_bit(PG_dirty, &page->flags);
+}
+static inline int TestSetPageDirty(struct page *page)
+{
+        int ret = test_and_set_bit(PG_dirty, &page->flags);
+	if (ret)
+		save_page_dirty_trace(page);
+	return ret;
+}
+static inline int TestClearPageDirty(struct page *page)
+{
+        return test_and_clear_bit(PG_dirty, &page->flags);
+}
+static inline void __ClearPageDirty(struct page *page)
+{
+        __clear_bit(PG_dirty, &page->flags);
+}
+
+#endif
+
 PAGEFLAG(LRU, lru) __CLEARPAGEFLAG(LRU, lru)
 PAGEFLAG(Active, active) __CLEARPAGEFLAG(Active, active)
 	TESTCLEARFLAG(Active, active)
diff --git a/mm/filemap.c b/mm/filemap.c
index 7771871..869a8d5 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -1101,8 +1101,9 @@ static void shrink_readahead_size_eio(struct file *filp,
  * This is really ugly. But the goto's actually try to clarify some
  * of the logic when it comes to error handling etc.
  */
-static void do_generic_file_read(struct file *filp, loff_t *ppos,
-		read_descriptor_t *desc, read_actor_t actor)
+static noinline void do_generic_file_read(struct file *filp, loff_t *ppos,
+					  read_descriptor_t *desc,
+					  read_actor_t actor)
 {
 	struct address_space *mapping = filp->f_mapping;
 	struct inode *inode = mapping->host;
@@ -2672,3 +2673,25 @@ int try_to_release_page(struct page *page, gfp_t gfp_mask)
 }
 
 EXPORT_SYMBOL(try_to_release_page);
+
+/* Debugging */
+
+void init_page_dirty_trace(struct page *page)
+{
+       INIT_LIST_HEAD(&page->bt_list);
+       page->dirty_trace.nr_entries = 0;
+}
+EXPORT_SYMBOL(init_page_dirty_trace);
+
+void save_page_dirty_trace(struct page *page)
+{
+       page->dirty_trace.nr_entries = 0;
+       page->dirty_trace.max_entries = PAGE_STACKTRACE_SIZE;
+       page->dirty_trace.entries = page->dirty_entries;
+       page->dirty_trace.skip = 1;
+
+       save_stack_trace(&page->dirty_trace);
+       page->dirty_trace.nr_entries--;
+}
+EXPORT_SYMBOL(save_page_dirty_trace);
+
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 6e8ecb6..61a7331 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -767,6 +767,7 @@ static inline int check_new_page(struct page *page)
 	return 0;
 }
 
+extern void init_page_dirty_trace(struct page *page);
 static int prep_new_page(struct page *page, int order, gfp_t gfp_flags)
 {
 	int i;
@@ -789,6 +790,8 @@ static int prep_new_page(struct page *page, int order, gfp_t gfp_flags)
 	if (order && (gfp_flags & __GFP_COMP))
 		prep_compound_page(page, order);
 
+	init_page_dirty_trace(page);
+
 	return 0;
 }
 
-- 
1.7.7.3

