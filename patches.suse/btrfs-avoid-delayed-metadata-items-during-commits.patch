From: Chris Mason <chris.mason@oracle.com>
Date: Fri, 17 Jun 2011 16:14:09 -0400
Patch-mainline: yes
References: FATE#306586
Subject: [PATCH] Btrfs: avoid delayed metadata items during commits

Snapshot creation has two phases.  One is the initial snapshot setup,
and the second is done during commit, while nobody is allowed to modify
the root we are snapshotting.

The delayed metadata insertion code can break that rule, it does a
delayed inode update on the inode of the parent of the snapshot,
and delayed directory item insertion.

This makes sure to run the pending delayed operations before we
record the snapshot root, which avoids corruptions.

Signed-off-by: Chris Mason <chris.mason@oracle.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/delayed-inode.c |    7 +++++++
 fs/btrfs/delayed-inode.h |    4 ++++
 fs/btrfs/transaction.c   |   27 +++++++++++++++++----------
 3 files changed, 28 insertions(+), 10 deletions(-)

Index: linux-2.6.32-SLE11-SP2/fs/btrfs/delayed-inode.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/delayed-inode.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/delayed-inode.c
@@ -1237,6 +1237,13 @@ again:
 	return 0;
 }
 
+void btrfs_assert_delayed_root_empty(struct btrfs_root *root)
+{
+	struct btrfs_delayed_root *delayed_root;
+	delayed_root = btrfs_get_delayed_root(root);
+	WARN_ON(btrfs_first_delayed_node(delayed_root));
+}
+
 void btrfs_balance_delayed_items(struct btrfs_root *root)
 {
 	struct btrfs_delayed_root *delayed_root;
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/delayed-inode.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/delayed-inode.h
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/delayed-inode.h
@@ -137,4 +137,8 @@ int btrfs_readdir_delayed_dir_index(stru
 /* for init */
 int __init btrfs_delayed_inode_init(void);
 void btrfs_delayed_inode_exit(void);
+
+/* for debugging */
+void btrfs_assert_delayed_root_empty(struct btrfs_root *root);
+
 #endif
Index: linux-2.6.32-SLE11-SP2/fs/btrfs/transaction.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/fs/btrfs/transaction.c
+++ linux-2.6.32-SLE11-SP2/fs/btrfs/transaction.c
@@ -956,6 +956,15 @@ static noinline int create_pending_snaps
 	ret = btrfs_update_inode(trans, parent_root, parent_inode);
 	BUG_ON(ret);
 
+	/*
+	 * pull in the delayed directory update
+	 * and the delayed inode item
+	 * otherwise we corrupt the FS during
+	 * snapshot
+	 */
+	ret = btrfs_run_delayed_items(trans, root);
+	BUG_ON(ret);
+
 	record_root_in_trans(trans, root);
 	btrfs_set_root_last_snapshot(&root->root_item, trans->transid);
 	memcpy(new_root_item, &root->root_item, sizeof(*new_root_item));
@@ -1017,14 +1026,6 @@ static noinline int create_pending_snaps
 	int ret;
 
 	list_for_each_entry(pending, head, list) {
-		/*
-		 * We must deal with the delayed items before creating
-		 * snapshots, or we will create a snapthot with inconsistent
-		 * information.
-		*/
-		ret = btrfs_run_delayed_items(trans, fs_info->fs_root);
-		BUG_ON(ret);
-
 		ret = create_pending_snapshot(trans, fs_info, pending);
 		BUG_ON(ret);
 	}
@@ -1318,15 +1319,21 @@ int btrfs_commit_transaction(struct btrf
 	 */
 	mutex_lock(&root->fs_info->reloc_mutex);
 
-	ret = create_pending_snapshots(trans, root->fs_info);
+	ret = btrfs_run_delayed_items(trans, root);
 	BUG_ON(ret);
 
-	ret = btrfs_run_delayed_items(trans, root);
+	ret = create_pending_snapshots(trans, root->fs_info);
 	BUG_ON(ret);
 
 	ret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);
 	BUG_ON(ret);
 
+	/*
+	 * make sure none of the code above managed to slip in a
+	 * delayed item
+	 */
+	btrfs_assert_delayed_root_empty(root);
+
 	WARN_ON(cur_trans != trans->transaction);
 
 	btrfs_scrub_pause(root);
