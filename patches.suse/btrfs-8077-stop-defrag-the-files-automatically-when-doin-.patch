From: Miao Xie <miaox@cn.fujitsu.com>
Date: Thu, 17 May 2012 19:55:23 +0800
Patch-mainline: pending
References: FATE#306586
Subject: [PATCH] Btrfs: stop defrag the files automatically when
 doin readonly remount or umount

If we remount the fs to be readonly or umount it, we should not continue
defraging the files, it is because
- the auto defragment will introduce lots of dirty pages, it breaks the rule
  of a readonly file system.
- it make the time of remount/umount become longer.

Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/disk-io.c |   13 +++++++------
 fs/btrfs/file.c    |    3 ++-
 fs/btrfs/super.c   |    5 +++++
 3 files changed, 14 insertions(+), 7 deletions(-)

diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index 58a232d..eca93d4 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -1619,16 +1619,19 @@ static int cleaner_kthread(void *arg)
 	do {
 		vfs_check_frozen(root->fs_info->sb, SB_FREEZE_WRITE);
 
+		if (!down_read_trylock(&root->fs_info->sb->s_umount))
+			goto skip;
+
 		if (!(root->fs_info->sb->s_flags & MS_RDONLY) &&
-			down_read_trylock(&root->fs_info->sb->s_umount) &&
 		    mutex_trylock(&root->fs_info->cleaner_mutex)) {
 			btrfs_run_delayed_iputs(root);
 			btrfs_clean_old_snapshots(root);
 			mutex_unlock(&root->fs_info->cleaner_mutex);
 			btrfs_run_defrag_inodes(root->fs_info);
-			up_read(&root->fs_info->sb->s_umount);
 		}
 
+		up_read(&root->fs_info->sb->s_umount);
+skip:
 		if (freezing(current)) {
 			refrigerator();
 		} else {
@@ -3108,13 +3111,11 @@ int close_ctree(struct btrfs_root *root)
 
 	btrfs_scrub_cancel(root);
 
-	/* wait for any defraggers to finish */
-	wait_event(fs_info->transaction_wait,
-		   (atomic_read(&fs_info->defrag_running) == 0));
-
 	/* clear out the rbtree of defraggable inodes */
 	btrfs_run_defrag_inodes(root->fs_info);
 
+	BUG_ON(atomic_read(&fs_info->defrag_running));
+
 	/*
 	 * Here come 2 situations when btrfs is broken to flip readonly:
 	 *
diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c
index 88831b7..961a54b 100644
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@ -259,7 +259,8 @@ int btrfs_run_defrag_inodes(struct btrfs_fs_info *fs_info)
 		root_objectid = defrag->root;
 		rb_erase(&defrag->rb_node, &fs_info->defrag_inodes);
 
-		if (btrfs_fs_closing(fs_info))
+		if (btrfs_fs_closing(fs_info) ||
+				(fs_info->sb->s_flags & MS_RDONLY))
 			goto next_free;
 
 		spin_unlock(&fs_info->defrag_inodes_lock);
diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c
index 131760d..ccb4532 100644
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@ -1149,6 +1149,11 @@ static int btrfs_remount(struct super_block *sb, int *flags, char *data)
 		ret = btrfs_commit_super(root);
 		if (ret)
 			goto restore;
+
+		/* clear out the rbtree of defraggable inodes */
+		btrfs_run_defrag_inodes(fs_info);
+
+		BUG_ON(atomic_read(&fs_info->defrag_running));
 	} else {
 		if (root->fs_info->fs_devices->rw_devices == 0) {
 			ret = -EACCES;
-- 
1.7.6.233.gd79bc

