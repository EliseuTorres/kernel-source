From: Tejun Heo <tj@kernel.org>
Date: Fri, 9 Apr 2010 19:46:38 +0900
Subject: [PATCH] libata: use longer 0xff wait if parallel scan is enabled
X-Git: b48d58f55aa1d2d0d12378e45663842d4021916e
References: FATE#311692
Patch-Mainline: 2.6.34

There are some SATA devices which take relatively long to get out of
0xff status after reset.  In libata, this timeout is determined by
ATA_TMOUT_FF_WAIT.  Quantum GoVault is the worst requring about 2s for
reliable detection.  However, because 2s 0xff timeout can introduce
rather long spurious delay during boot, libata has been compromising
at the next longest timeout of 800ms for HHD424020F7SV00 iVDR drive.

Now that parallel scan is in place for common drivers, libata can
afford 2s 0xff timeout.  Use 2s 0xff timeout if parallel scan is
enabled.

Please note that the chance of spurious wait is pretty slim w/ working
SCR access so this will only affect SATA controllers w/o SCR access
which isn't too common these days.

Please read the following thread for more information on the GoVault
drive.

  http://thread.gmane.org/gmane.linux.ide/14545/focus=14663

Signed-off-by: Tejun Heo <tj@kernel.org>
Cc: Gary Hade <garyhade@us.ibm.com>
Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/ata/libata-core.c |   18 ++++++++++++------
 include/linux/libata.h    |   11 ++++++-----
 2 files changed, 18 insertions(+), 11 deletions(-)

diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c
index 1d5931e..2b5737b 100644
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -3635,9 +3635,15 @@ int ata_wait_ready(struct ata_link *link, unsigned long deadline,
 		   int (*check_ready)(struct ata_link *link))
 {
 	unsigned long start = jiffies;
-	unsigned long nodev_deadline = ata_deadline(start, ATA_TMOUT_FF_WAIT);
+	unsigned long nodev_deadline;
 	int warned = 0;
 
+	/* choose which 0xff timeout to use, read comment in libata.h */
+	if (link->ap->host->flags & ATA_HOST_PARALLEL_SCAN)
+		nodev_deadline = ata_deadline(start, ATA_TMOUT_FF_WAIT_LONG);
+	else
+		nodev_deadline = ata_deadline(start, ATA_TMOUT_FF_WAIT);
+
 	/* Slave readiness can't be tested separately from master.  On
 	 * M/S emulation configuration, this function should be called
 	 * only on the master and it will handle both master and slave.
@@ -3655,12 +3661,12 @@ int ata_wait_ready(struct ata_link *link, unsigned long deadline,
 		if (ready > 0)
 			return 0;
 
-		/* -ENODEV could be transient.  Ignore -ENODEV if link
+		/*
+		 * -ENODEV could be transient.  Ignore -ENODEV if link
 		 * is online.  Also, some SATA devices take a long
-		 * time to clear 0xff after reset.  For example,
-		 * HHD424020F7SV00 iVDR needs >= 800ms while Quantum
-		 * GoVault needs even more than that.  Wait for
-		 * ATA_TMOUT_FF_WAIT on -ENODEV if link isn't offline.
+		 * time to clear 0xff after reset.  Wait for
+		 * ATA_TMOUT_FF_WAIT[_LONG] on -ENODEV if link isn't
+		 * offline.
 		 *
 		 * Note that some PATA controllers (pata_ali) explode
 		 * if status register is read more than once when
diff --git a/include/linux/libata.h b/include/linux/libata.h
index 59d7064..2af5365 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -256,12 +256,13 @@ enum {
 	ATA_TMOUT_INTERNAL_QUICK = 5000,
 	ATA_TMOUT_MAX_PARK	= 30000,
 
-	/* FIXME: GoVault needs 2s but we can't afford that without
-	 * parallel probing.  800ms is enough for iVDR disk
-	 * HHD424020F7SV00.  Increase to 2secs when parallel probing
-	 * is in place.
+	/*
+	 * GoVault needs 2s and iVDR disk HHD424020F7SV00 800ms.  2s
+	 * is too much without parallel probing.  Use 2s if parallel
+	 * probing is available, 800ms otherwise.
 	 */
-	ATA_TMOUT_FF_WAIT	=  2000,
+	ATA_TMOUT_FF_WAIT_LONG	=  2000,
+	ATA_TMOUT_FF_WAIT	=   800,
 
 	/* Spec mandates to wait for ">= 2ms" before checking status
 	 * after reset.  We wait 150ms, because that was the magic
-- 
1.6.0.2

