From: Andre Przywara <andre.przywara@amd.com>
Subject: [PATCH 01/12] KVM: SVM: Add clean-bits infrastructure code
References: FATE#309760
Git-commit: 8d28fec406e4d5ce6c109fe12699976e72e9748e
Patch-mainline: v2.6.38

This patch adds the infrastructure for the implementation of
the individual clean-bits.

Backport of 8d28fec406e4d5ce6c109fe12699976e72e9748e
(done by: Joerg Roedel <joerg.roedel@amd.com>)

Signed-off-by: Andre Przywara <andre.przywara@amd.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/include/asm/svm.h |    3 ++-
 arch/x86/kvm/svm.c         |   31 +++++++++++++++++++++++++++++++
 2 files changed, 33 insertions(+), 1 deletions(-)

Index: linux-2.6.32-SLE11-SP2/arch/x86/include/asm/svm.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/include/asm/svm.h
+++ linux-2.6.32-SLE11-SP2/arch/x86/include/asm/svm.h
@@ -81,7 +81,8 @@ struct __attribute__ ((__packed__)) vmcb
 	u32 event_inj_err;
 	u64 nested_cr3;
 	u64 lbr_ctl;
-	u64 reserved_5;
+	u32 clean;
+	u32 reserved_5;
 	u64 next_rip;
 	u8 insn_len;
 	u8 insn_bytes[15];
Index: linux-2.6.32-SLE11-SP2/arch/x86/kvm/svm.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/arch/x86/kvm/svm.c
+++ linux-2.6.32-SLE11-SP2/arch/x86/kvm/svm.c
@@ -141,6 +141,28 @@ static int nested_svm_vmexit(struct vcpu
 static int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,
 				      bool has_error_code, u32 error_code);
 
+enum {
+	VMCB_DIRTY_MAX,
+};
+
+#define VMCB_ALWAYS_DIRTY_MASK 0U
+
+static inline void mark_all_dirty(struct vmcb *vmcb)
+{
+	vmcb->control.clean = 0;
+}
+
+static inline void mark_all_clean(struct vmcb *vmcb)
+{
+	vmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)
+		               & ~VMCB_ALWAYS_DIRTY_MASK;
+}
+
+static inline void mark_dirty(struct vmcb *vmcb, int bit)
+{
+	vmcb->control.clean &= ~(1 << bit);
+}
+
 static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)
 {
 	return container_of(vcpu, struct vcpu_svm, vcpu);
@@ -696,6 +718,8 @@ static void init_vmcb(struct vcpu_svm *s
 		control->intercept |= (1ULL << INTERCEPT_PAUSE);
 	}
 
+	mark_all_dirty(svm->vmcb);
+
 	enable_gif(svm);
 }
 
@@ -821,6 +845,7 @@ static void svm_vcpu_load(struct kvm_vcp
 		vcpu->cpu = cpu;
 		kvm_migrate_timers(vcpu);
 		svm->asid_generation = 0;
+		mark_all_dirty(svm->vmcb);
 	}
 
 	for (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)
@@ -1768,6 +1793,8 @@ static int nested_svm_vmexit(struct vcpu
 	/* Exit nested SVM mode */
 	svm->nested.vmcb = 0;
 
+	mark_all_dirty(svm->vmcb);
+
 	nested_svm_unmap(nested_vmcb, KM_USER0);
 
 	kvm_mmu_reset_context(&svm->vcpu);
@@ -1924,6 +1951,8 @@ static bool nested_svm_vmrun(struct vcpu
 
 	enable_gif(svm);
 
+	mark_all_dirty(svm->vmcb);
+
 	return true;
 }
 
@@ -2984,6 +3013,8 @@ static void svm_vcpu_run(struct kvm_vcpu
 	if (unlikely(svm->vmcb->control.exit_code ==
 		     SVM_EXIT_EXCP_BASE + MC_VECTOR))
 		svm_handle_mce(svm);
+
+	mark_all_clean(svm->vmcb);
 }
 
 #undef R
