From d88064e608333b39c301cc21d98d4303a044d8b1 Mon Sep 17 00:00:00 2001
From: Dan Carpenter <error27@gmail.com>
Date: Thu, 21 Jul 2011 00:55:26 +0800
Subject: [PATCH 12/31] dcb: unlock on error in dcbnl_ieee_get()
References: bnc#687049, fate#311957
Patch-mainline: 2.6.38
Git-commit: 70bfa2d2e1bfd90ef26758b5e2749f043a940037

There is a "goto nla_put_failure" hidden inside the NLA_PUT() macro, but
we're holding the dcb_lock so we need to unlock first.

Signed-off-by: Dan Carpenter <error27@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
Acked-by: Michal Marek <mmarek@suse.cz>

---
 net/dcb/dcbnl.c |   11 ++++++++---
 1 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/net/dcb/dcbnl.c b/net/dcb/dcbnl.c
index 9399af5..4323bd4 100644
--- a/net/dcb/dcbnl.c
+++ b/net/dcb/dcbnl.c
@@ -1264,9 +1264,14 @@ static int dcbnl_ieee_get(struct net_device *netdev, struct nlattr **tb,
 
 	spin_lock(&dcb_lock);
 	list_for_each_entry(itr, &dcb_app_list, list) {
-		if (strncmp(itr->name, netdev->name, IFNAMSIZ) == 0)
-			NLA_PUT(skb, DCB_ATTR_IEEE_APP,
-				sizeof(itr->app), &itr->app);
+		if (strncmp(itr->name, netdev->name, IFNAMSIZ) == 0) {
+			err = nla_put(skb, DCB_ATTR_IEEE_APP, sizeof(itr->app),
+					 &itr->app);
+			if (err) {
+				spin_unlock(&dcb_lock);
+				goto nla_put_failure;
+			}
+		}
 	}
 	spin_unlock(&dcb_lock);
 	nla_nest_end(skb, app);
-- 
1.7.6

