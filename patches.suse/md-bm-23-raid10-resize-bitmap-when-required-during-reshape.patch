From: NeilBrown <neilb@suse.de>
Date: Thu, 12 Apr 2012 16:27:11 +1000
Subject: [PATCH 23/23] md/raid10: resize bitmap when required during reshape.
Patch-mainline: 3.5
References: fate#311379

If a reshape changes the size of the array, then we can now
update the bitmap to suit - so do so.

Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: NeilBrown <neilb@suse.de>

---
 drivers/md/raid10.c |   37 ++++++++++++++++++++++++-------------
 1 file changed, 24 insertions(+), 13 deletions(-)

--- linux-3.0-SLE11-SP2-BTMU.orig/drivers/md/raid10.c
+++ linux-3.0-SLE11-SP2-BTMU/drivers/md/raid10.c
@@ -2918,8 +2918,6 @@ static int raid10_check_reshape(mddev_t
 			/* not factor of array size */
 			return -EINVAL;
 
-	if (mddev->bitmap)
-		return -EBUSY;
 	if (!enough(conf, -1))
 		return -EINVAL;
 
@@ -3014,6 +3012,7 @@ static int raid10_start_reshape(mddev_t
 	conf_t *conf = mddev->private;
 	mdk_rdev_t *rdev;
 	int spares = 0;
+	int ret;
 
 	if (test_bit(MD_RECOVERY_RUNNING, &mddev->recovery))
 		return -EBUSY;
@@ -3066,6 +3065,14 @@ static int raid10_start_reshape(mddev_t
 		conf->reshape_progress = 0;
 	spin_unlock_irq(&conf->device_lock);
 
+	if (mddev->delta_disks && mddev->bitmap) {
+		ret = bitmap_resize(mddev->bitmap,
+				    raid10_size(mddev, 0,
+						conf->geo.raid_disks),
+				    0, 0);
+		if (ret)
+			goto abort;
+	}
 	if (mddev->delta_disks > 0) {
 		list_for_each_entry(rdev, &mddev->disks, same_set)
 			if (rdev->raid_disk < 0 &&
@@ -3111,22 +3118,26 @@ static int raid10_start_reshape(mddev_t
 	mddev->sync_thread = md_register_thread(md_do_sync, mddev,
 						"reshape");
 	if (!mddev->sync_thread) {
-		mddev->recovery = 0;
-		spin_lock_irq(&conf->device_lock);
-		conf->geo = conf->prev;
-		mddev->raid_disks = conf->geo.raid_disks;
-		list_for_each_entry(rdev, &mddev->disks, same_set)
-			rdev->new_data_offset = rdev->data_offset;
-		smp_wmb();
-		conf->reshape_progress = MaxSector;
-		mddev->reshape_position = MaxSector;
-		spin_unlock_irq(&conf->device_lock);
-		return -EAGAIN;
+		ret = -EAGAIN;
+		goto abort;
 	}
 	conf->reshape_checkpoint = jiffies;
 	md_wakeup_thread(mddev->sync_thread);
 	md_new_event(mddev);
 	return 0;
+
+abort:
+	mddev->recovery = 0;
+	spin_lock_irq(&conf->device_lock);
+	conf->geo = conf->prev;
+	mddev->raid_disks = conf->geo.raid_disks;
+	list_for_each_entry(rdev, &mddev->disks, same_set)
+		rdev->new_data_offset = rdev->data_offset;
+	smp_wmb();
+	conf->reshape_progress = MaxSector;
+	mddev->reshape_position = MaxSector;
+	spin_unlock_irq(&conf->device_lock);
+	return ret;
 }
 
 /* Calculate the last device-address that could contain
