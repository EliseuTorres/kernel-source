From 940c5651fad5e2bcbecc6932f49e814e252a0e54 Mon Sep 17 00:00:00 2001
From: Hank Janssen <hjanssen@microsoft.com>
Date: Wed, 18 Aug 2010 14:32:42 -0700
Subject: staging: hyper-v: Added all patches for Hyper-V - same as 2.6.35 now
Patch-mainline: 2.6.35
References: bnc#618379


Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/hv/BlkVsc.c       |   14 -
 drivers/staging/hv/Channel.c      |  222 +++++++++++++------------
 drivers/staging/hv/ChannelMgmt.c  |  129 +++++++-------
 drivers/staging/hv/ChannelMgmt.h  |    8 
 drivers/staging/hv/Connection.c   |   53 ++----
 drivers/staging/hv/Hv.c           |  269 +++++++++++--------------------
 drivers/staging/hv/Hv.h           |   10 -
 drivers/staging/hv/NetVsc.c       |  164 ++++++------------
 drivers/staging/hv/NetVsc.h       |    1 
 drivers/staging/hv/NetVscApi.h    |   11 -
 drivers/staging/hv/RingBuffer.c   |  217 +++++++++++++------------
 drivers/staging/hv/RingBuffer.h   |   35 ++--
 drivers/staging/hv/RndisFilter.c  |  143 +++-------------
 drivers/staging/hv/StorVsc.c      |  124 +++++++-------
 drivers/staging/hv/StorVscApi.h   |    5 
 drivers/staging/hv/VersionInfo.h  |   23 ++
 drivers/staging/hv/Vmbus.c        |   54 +-----
 drivers/staging/hv/VmbusApi.h     |   18 ++
 drivers/staging/hv/blkvsc_drv.c   |   79 +++------
 drivers/staging/hv/hv_api.h       |    4 
 drivers/staging/hv/hyperv_utils.c |  165 ++++++++++++++++++-
 drivers/staging/hv/logging.h      |   24 --
 drivers/staging/hv/netvsc_drv.c   |  296 ++++++++++++----------------------
 drivers/staging/hv/osd.c          |   71 ++++++++
 drivers/staging/hv/rndis.h        |    2 
 drivers/staging/hv/storvsc_drv.c  |  329 ++++----------------------------------
 drivers/staging/hv/utils.h        |   99 +++++++----
 drivers/staging/hv/vmbus.h        |   12 -
 drivers/staging/hv/vmbus_drv.c    |  232 +++++++++-----------------
 drivers/staging/hv/vstorage.h     |    2 
 30 files changed, 1216 insertions(+), 1599 deletions(-)

--- a/drivers/staging/hv/BlkVsc.c
+++ b/drivers/staging/hv/BlkVsc.c
@@ -40,15 +40,11 @@ static int BlkVscOnDeviceAdd(struct hv_d
 	struct storvsc_device_info *deviceInfo;
 	int ret = 0;
 
-	DPRINT_ENTER(BLKVSC);
-
 	deviceInfo = (struct storvsc_device_info *)AdditionalInfo;
 
 	ret = StorVscOnDeviceAdd(Device, AdditionalInfo);
-	if (ret != 0) {
-		DPRINT_EXIT(BLKVSC);
+	if (ret != 0)
 		return ret;
-	}
 
 	/*
 	 * We need to use the device instance guid to set the path and target
@@ -63,8 +59,6 @@ static int BlkVscOnDeviceAdd(struct hv_d
 	deviceInfo->TargetId = Device->deviceInstance.data[5] << 8 |
 			       Device->deviceInstance.data[4];
 
-	DPRINT_EXIT(BLKVSC);
-
 	return ret;
 }
 
@@ -73,12 +67,10 @@ int BlkVscInitialize(struct hv_driver *D
 	struct storvsc_driver_object *storDriver;
 	int ret = 0;
 
-	DPRINT_ENTER(BLKVSC);
-
 	storDriver = (struct storvsc_driver_object *)Driver;
 
 	/* Make sure we are at least 2 pages since 1 page is used for control */
-	ASSERT(storDriver->RingBufferSize >= (PAGE_SIZE << 1));
+	/* ASSERT(storDriver->RingBufferSize >= (PAGE_SIZE << 1)); */
 
 	Driver->name = gBlkDriverName;
 	memcpy(&Driver->deviceType, &gBlkVscDeviceType, sizeof(struct hv_guid));
@@ -106,7 +98,5 @@ int BlkVscInitialize(struct hv_driver *D
 	storDriver->Base.OnCleanup = StorVscOnCleanup;
 	storDriver->OnIORequest	= StorVscOnIORequest;
 
-	DPRINT_EXIT(BLKVSC);
-
 	return ret;
 }
--- a/drivers/staging/hv/Channel.c
+++ b/drivers/staging/hv/Channel.c
@@ -20,6 +20,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/slab.h>
 #include <linux/module.h>
 #include "osd.h"
 #include "logging.h"
@@ -65,15 +66,14 @@ static void DumpMonitorPage(struct hv_mo
 }
 #endif
 
-/**
- * VmbusChannelSetEvent - Trigger an event notification on the specified channel.
+/*
+ * VmbusChannelSetEvent - Trigger an event notification on the specified
+ * channel.
  */
 static void VmbusChannelSetEvent(struct vmbus_channel *Channel)
 {
 	struct hv_monitor_page *monitorPage;
 
-	DPRINT_ENTER(VMBUS);
-
 	if (Channel->OfferMsg.MonitorAllocated) {
 		/* Each u32 represents 32 channels */
 		sync_set_bit(Channel->OfferMsg.ChildRelId & 31,
@@ -90,8 +90,6 @@ static void VmbusChannelSetEvent(struct
 	} else {
 		VmbusSetEvent(Channel->OfferMsg.ChildRelId);
 	}
-
-	DPRINT_EXIT(VMBUS);
 }
 
 #if 0
@@ -99,8 +97,6 @@ static void VmbusChannelClearEvent(struc
 {
 	struct hv_monitor_page *monitorPage;
 
-	DPRINT_ENTER(VMBUS);
-
 	if (Channel->OfferMsg.MonitorAllocated) {
 		/* Each u32 represents 32 channels */
 		sync_clear_bit(Channel->OfferMsg.ChildRelId & 31,
@@ -115,12 +111,10 @@ static void VmbusChannelClearEvent(struc
 			  (unsigned long *)&monitorPage->TriggerGroup
 					[Channel->MonitorGroup].Pending);
 	}
-
-	DPRINT_EXIT(VMBUS);
 }
 
 #endif
-/**
+/*
  * VmbusChannelGetDebugInfo -Retrieve various channel debug info
  */
 void VmbusChannelGetDebugInfo(struct vmbus_channel *Channel,
@@ -165,7 +159,7 @@ void VmbusChannelGetDebugInfo(struct vmb
 	RingBufferGetDebugInfo(&Channel->Outbound, &DebugInfo->Outbound);
 }
 
-/**
+/*
  * VmbusChannelOpen - Open the specified channel.
  */
 int VmbusChannelOpen(struct vmbus_channel *NewChannel, u32 SendRingBufferSize,
@@ -173,16 +167,14 @@ int VmbusChannelOpen(struct vmbus_channe
 		     void (*OnChannelCallback)(void *context), void *Context)
 {
 	struct vmbus_channel_open_channel *openMsg;
-	struct vmbus_channel_msginfo *openInfo;
+	struct vmbus_channel_msginfo *openInfo = NULL;
 	void *in, *out;
 	unsigned long flags;
-	int ret;
-
-	DPRINT_ENTER(VMBUS);
+	int ret, err = 0;
 
 	/* Aligned to page size */
-	ASSERT(!(SendRingBufferSize & (PAGE_SIZE - 1)));
-	ASSERT(!(RecvRingBufferSize & (PAGE_SIZE - 1)));
+	/* ASSERT(!(SendRingBufferSize & (PAGE_SIZE - 1))); */
+	/* ASSERT(!(RecvRingBufferSize & (PAGE_SIZE - 1))); */
 
 	NewChannel->OnChannelCallback = OnChannelCallback;
 	NewChannel->ChannelCallbackContext = Context;
@@ -190,8 +182,10 @@ int VmbusChannelOpen(struct vmbus_channe
 	/* Allocate the ring buffer */
 	out = osd_PageAlloc((SendRingBufferSize + RecvRingBufferSize)
 			     >> PAGE_SHIFT);
-	ASSERT(out);
-	ASSERT(((unsigned long)out & (PAGE_SIZE-1)) == 0);
+	if (!out)
+		return -ENOMEM;
+
+	/* ASSERT(((unsigned long)out & (PAGE_SIZE-1)) == 0); */
 
 	in = (void *)((unsigned long)out + SendRingBufferSize);
 
@@ -199,9 +193,18 @@ int VmbusChannelOpen(struct vmbus_channe
 	NewChannel->RingBufferPageCount = (SendRingBufferSize +
 					   RecvRingBufferSize) >> PAGE_SHIFT;
 
-	RingBufferInit(&NewChannel->Outbound, out, SendRingBufferSize);
+	ret = RingBufferInit(&NewChannel->Outbound, out, SendRingBufferSize);
+	if (ret != 0) {
+		err = ret;
+		goto errorout;
+	}
+
+	ret = RingBufferInit(&NewChannel->Inbound, in, RecvRingBufferSize);
+	if (ret != 0) {
+		err = ret;
+		goto errorout;
+	}
 
-	RingBufferInit(&NewChannel->Inbound, in, RecvRingBufferSize);
 
 	/* Establish the gpadl for the ring buffer */
 	DPRINT_DBG(VMBUS, "Establishing ring buffer's gpadl for channel %p...",
@@ -215,6 +218,11 @@ int VmbusChannelOpen(struct vmbus_channe
 					 RecvRingBufferSize,
 					 &NewChannel->RingBufferGpadlHandle);
 
+	if (ret != 0) {
+		err = ret;
+		goto errorout;
+	}
+
 	DPRINT_DBG(VMBUS, "channel %p <relid %d gpadl 0x%x send ring %p "
 		   "size %d recv ring %p size %d, downstreamoffset %d>",
 		   NewChannel, NewChannel->OfferMsg.ChildRelId,
@@ -229,21 +237,31 @@ int VmbusChannelOpen(struct vmbus_channe
 	openInfo = kmalloc(sizeof(*openInfo) +
 			   sizeof(struct vmbus_channel_open_channel),
 			   GFP_KERNEL);
-	ASSERT(openInfo != NULL);
+	if (!openInfo) {
+		err = -ENOMEM;
+		goto errorout;
+	}
 
 	openInfo->WaitEvent = osd_WaitEventCreate();
+	if (!openInfo->WaitEvent) {
+		err = -ENOMEM;
+		goto errorout;
+	}
 
 	openMsg = (struct vmbus_channel_open_channel *)openInfo->Msg;
 	openMsg->Header.MessageType = ChannelMessageOpenChannel;
 	openMsg->OpenId = NewChannel->OfferMsg.ChildRelId; /* FIXME */
 	openMsg->ChildRelId = NewChannel->OfferMsg.ChildRelId;
 	openMsg->RingBufferGpadlHandle = NewChannel->RingBufferGpadlHandle;
-	ASSERT(openMsg->RingBufferGpadlHandle);
 	openMsg->DownstreamRingBufferPageOffset = SendRingBufferSize >>
 						  PAGE_SHIFT;
 	openMsg->ServerContextAreaGpadlHandle = 0; /* TODO */
 
-	ASSERT(UserDataLen <= MAX_USER_DEFINED_BYTES);
+	if (UserDataLen > MAX_USER_DEFINED_BYTES) {
+		err = -EINVAL;
+		goto errorout;
+	}
+
 	if (UserDataLen)
 		memcpy(openMsg->UserData, UserData, UserDataLen);
 
@@ -277,14 +295,20 @@ Cleanup:
 
 	kfree(openInfo->WaitEvent);
 	kfree(openInfo);
-
-	DPRINT_EXIT(VMBUS);
-
 	return 0;
+
+errorout:
+	RingBufferCleanup(&NewChannel->Outbound);
+	RingBufferCleanup(&NewChannel->Inbound);
+	osd_PageFree(out, (SendRingBufferSize + RecvRingBufferSize)
+		     >> PAGE_SHIFT);
+	kfree(openInfo);
+	return err;
 }
 
-/**
- * DumpGpadlBody - Dump the gpadl body message to the console for debugging purposes.
+/*
+ * DumpGpadlBody - Dump the gpadl body message to the console for
+ * debugging purposes.
  */
 static void DumpGpadlBody(struct vmbus_channel_gpadl_body *Gpadl, u32 Len)
 {
@@ -300,8 +324,9 @@ static void DumpGpadlBody(struct vmbus_c
 			   i, Gpadl->Pfn[i]);
 }
 
-/**
- * DumpGpadlHeader - Dump the gpadl header message to the console for debugging purposes.
+/*
+ * DumpGpadlHeader - Dump the gpadl header message to the console for
+ * debugging purposes.
  */
 static void DumpGpadlHeader(struct vmbus_channel_gpadl_header *Gpadl)
 {
@@ -325,7 +350,7 @@ static void DumpGpadlHeader(struct vmbus
 	}
 }
 
-/**
+/*
  * VmbusChannelCreateGpadlHeader - Creates a gpadl for the specified buffer
  */
 static int VmbusChannelCreateGpadlHeader(void *Kbuffer, u32 Size,
@@ -338,13 +363,13 @@ static int VmbusChannelCreateGpadlHeader
 	struct vmbus_channel_gpadl_header *gpaHeader;
 	struct vmbus_channel_gpadl_body *gpadlBody;
 	struct vmbus_channel_msginfo *msgHeader;
-	struct vmbus_channel_msginfo *msgBody;
+	struct vmbus_channel_msginfo *msgBody = NULL;
 	u32 msgSize;
 
 	int pfnSum, pfnCount, pfnLeft, pfnCurr, pfnSize;
 
 	/* ASSERT((kbuffer & (PAGE_SIZE-1)) == 0); */
-	ASSERT((Size & (PAGE_SIZE-1)) == 0);
+	/* ASSERT((Size & (PAGE_SIZE-1)) == 0); */
 
 	pageCount = Size >> PAGE_SHIFT;
 	pfn = virt_to_phys(Kbuffer) >> PAGE_SHIFT;
@@ -362,6 +387,8 @@ static int VmbusChannelCreateGpadlHeader
 			  sizeof(struct vmbus_channel_gpadl_header) +
 			  sizeof(struct gpa_range) + pfnCount * sizeof(u64);
 		msgHeader =  kzalloc(msgSize, GFP_KERNEL);
+		if (!msgHeader)
+			goto nomem;
 
 		INIT_LIST_HEAD(&msgHeader->SubMsgList);
 		msgHeader->MessageSize = msgSize;
@@ -396,7 +423,9 @@ static int VmbusChannelCreateGpadlHeader
 				  sizeof(struct vmbus_channel_gpadl_body) +
 				  pfnCurr * sizeof(u64);
 			msgBody = kzalloc(msgSize, GFP_KERNEL);
-			ASSERT(msgBody);
+			/* FIXME: we probably need to more if this fails */
+			if (!msgBody)
+				goto nomem;
 			msgBody->MessageSize = msgSize;
 			(*MessageCount)++;
 			gpadlBody =
@@ -423,6 +452,8 @@ static int VmbusChannelCreateGpadlHeader
 			  sizeof(struct vmbus_channel_gpadl_header) +
 			  sizeof(struct gpa_range) + pageCount * sizeof(u64);
 		msgHeader = kzalloc(msgSize, GFP_KERNEL);
+		if (msgHeader == NULL)
+			goto nomem;
 		msgHeader->MessageSize = msgSize;
 
 		gpaHeader = (struct vmbus_channel_gpadl_header *)msgHeader->Msg;
@@ -439,9 +470,13 @@ static int VmbusChannelCreateGpadlHeader
 	}
 
 	return 0;
+nomem:
+	kfree(msgHeader);
+	kfree(msgBody);
+	return -ENOMEM;
 }
 
-/**
+/*
  * VmbusChannelEstablishGpadl - Estabish a GPADL for the specified buffer
  *
  * @Channel: a channel
@@ -455,24 +490,27 @@ int VmbusChannelEstablishGpadl(struct vm
 	struct vmbus_channel_gpadl_header *gpadlMsg;
 	struct vmbus_channel_gpadl_body *gpadlBody;
 	/* struct vmbus_channel_gpadl_created *gpadlCreated; */
-	struct vmbus_channel_msginfo *msgInfo;
+	struct vmbus_channel_msginfo *msgInfo = NULL;
 	struct vmbus_channel_msginfo *subMsgInfo;
 	u32 msgCount;
 	struct list_head *curr;
 	u32 nextGpadlHandle;
 	unsigned long flags;
-	int ret;
-
-	DPRINT_ENTER(VMBUS);
+	int ret = 0;
 
 	nextGpadlHandle = atomic_read(&gVmbusConnection.NextGpadlHandle);
 	atomic_inc(&gVmbusConnection.NextGpadlHandle);
 
-	VmbusChannelCreateGpadlHeader(Kbuffer, Size, &msgInfo, &msgCount);
-	ASSERT(msgInfo != NULL);
-	ASSERT(msgCount > 0);
+	ret = VmbusChannelCreateGpadlHeader(Kbuffer, Size, &msgInfo, &msgCount);
+	if (ret)
+		return ret;
 
 	msgInfo->WaitEvent = osd_WaitEventCreate();
+	if (!msgInfo->WaitEvent) {
+		ret = -ENOMEM;
+		goto Cleanup;
+	}
+
 	gpadlMsg = (struct vmbus_channel_gpadl_header *)msgInfo->Msg;
 	gpadlMsg->Header.MessageType = ChannelMessageGpadlHeader;
 	gpadlMsg->ChildRelId = Channel->OfferMsg.ChildRelId;
@@ -518,7 +556,9 @@ int VmbusChannelEstablishGpadl(struct vm
 			ret = VmbusPostMessage(gpadlBody,
 					       subMsgInfo->MessageSize -
 					       sizeof(*subMsgInfo));
-			ASSERT(ret == 0);
+			if (ret != 0)
+				goto Cleanup;
+
 		}
 	}
 	osd_WaitEventWait(msgInfo->WaitEvent);
@@ -539,13 +579,10 @@ Cleanup:
 
 	kfree(msgInfo->WaitEvent);
 	kfree(msgInfo);
-
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 }
 
-/**
+/*
  * VmbusChannelTeardownGpadl -Teardown the specified GPADL handle
  */
 int VmbusChannelTeardownGpadl(struct vmbus_channel *Channel, u32 GpadlHandle)
@@ -555,15 +592,18 @@ int VmbusChannelTeardownGpadl(struct vmb
 	unsigned long flags;
 	int ret;
 
-	DPRINT_ENTER(VMBUS);
-
-	ASSERT(GpadlHandle != 0);
+	/* ASSERT(GpadlHandle != 0); */
 
 	info = kmalloc(sizeof(*info) +
 		       sizeof(struct vmbus_channel_gpadl_teardown), GFP_KERNEL);
-	ASSERT(info != NULL);
+	if (!info)
+		return -ENOMEM;
 
 	info->WaitEvent = osd_WaitEventCreate();
+	if (!info->WaitEvent) {
+		kfree(info);
+		return -ENOMEM;
+	}
 
 	msg = (struct vmbus_channel_gpadl_teardown *)info->Msg;
 
@@ -592,13 +632,10 @@ int VmbusChannelTeardownGpadl(struct vmb
 
 	kfree(info->WaitEvent);
 	kfree(info);
-
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 }
 
-/**
+/*
  * VmbusChannelClose - Close the specified channel
  */
 void VmbusChannelClose(struct vmbus_channel *Channel)
@@ -608,8 +645,6 @@ void VmbusChannelClose(struct vmbus_chan
 	unsigned long flags;
 	int ret;
 
-	DPRINT_ENTER(VMBUS);
-
 	/* Stop callback and cancel the timer asap */
 	Channel->OnChannelCallback = NULL;
 	del_timer_sync(&Channel->poll_timer);
@@ -617,7 +652,10 @@ void VmbusChannelClose(struct vmbus_chan
 	/* Send a closing message */
 	info = kmalloc(sizeof(*info) +
 		       sizeof(struct vmbus_channel_close_channel), GFP_KERNEL);
-	ASSERT(info != NULL);
+        /* FIXME: can't do anything other than return here because the
+	 *        function is void */
+	if (!info)
+		return;
 
 	/* info->waitEvent = osd_WaitEventCreate(); */
 
@@ -659,8 +697,6 @@ void VmbusChannelClose(struct vmbus_chan
 
 		FreeVmbusChannel(Channel);
 	}
-
-	DPRINT_EXIT(VMBUS);
 }
 
 /**
@@ -688,13 +724,12 @@ int VmbusChannelSendPacket(struct vmbus_
 	u64 alignedData = 0;
 	int ret;
 
-	DPRINT_ENTER(VMBUS);
 	DPRINT_DBG(VMBUS, "channel %p buffer %p len %d",
 		   Channel, Buffer, BufferLen);
 
 	DumpVmbusChannel(Channel);
 
-	ASSERT((packetLenAligned - packetLen) < sizeof(u64));
+	/* ASSERT((packetLenAligned - packetLen) < sizeof(u64)); */
 
 	/* Setup the descriptor */
 	desc.Type = Type; /* VmbusPacketTypeDataInBand; */
@@ -715,14 +750,13 @@ int VmbusChannelSendPacket(struct vmbus_
 	if (ret == 0 && !GetRingBufferInterruptMask(&Channel->Outbound))
 		VmbusChannelSetEvent(Channel);
 
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 }
 EXPORT_SYMBOL(VmbusChannelSendPacket);
 
-/**
- * VmbusChannelSendPacketPageBuffer - Send a range of single-page buffer packets using a GPADL Direct packet type.
+/*
+ * VmbusChannelSendPacketPageBuffer - Send a range of single-page buffer
+ * packets using a GPADL Direct packet type.
  */
 int VmbusChannelSendPacketPageBuffer(struct vmbus_channel *Channel,
 				     struct hv_page_buffer PageBuffers[],
@@ -738,9 +772,8 @@ int VmbusChannelSendPacketPageBuffer(str
 	struct scatterlist bufferList[3];
 	u64 alignedData = 0;
 
-	DPRINT_ENTER(VMBUS);
-
-	ASSERT(PageCount <= MAX_PAGE_BUFFER_COUNT);
+	if (PageCount > MAX_PAGE_BUFFER_COUNT)
+		return -EINVAL;
 
 	DumpVmbusChannel(Channel);
 
@@ -754,7 +787,7 @@ int VmbusChannelSendPacketPageBuffer(str
 	packetLen = descSize + BufferLen;
 	packetLenAligned = ALIGN_UP(packetLen, sizeof(u64));
 
-	ASSERT((packetLenAligned - packetLen) < sizeof(u64));
+	/* ASSERT((packetLenAligned - packetLen) < sizeof(u64)); */
 
 	/* Setup the descriptor */
 	desc.Type = VmbusPacketTypeDataUsingGpaDirect;
@@ -781,13 +814,12 @@ int VmbusChannelSendPacketPageBuffer(str
 	if (ret == 0 && !GetRingBufferInterruptMask(&Channel->Outbound))
 		VmbusChannelSetEvent(Channel);
 
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 }
 
-/**
- * VmbusChannelSendPacketMultiPageBuffer - Send a multi-page buffer packet using a GPADL Direct packet type.
+/*
+ * VmbusChannelSendPacketMultiPageBuffer - Send a multi-page buffer packet
+ * using a GPADL Direct packet type.
  */
 int VmbusChannelSendPacketMultiPageBuffer(struct vmbus_channel *Channel,
 				struct hv_multipage_buffer *MultiPageBuffer,
@@ -803,15 +835,13 @@ int VmbusChannelSendPacketMultiPageBuffe
 	u32 PfnCount = NUM_PAGES_SPANNED(MultiPageBuffer->Offset,
 					 MultiPageBuffer->Length);
 
-	DPRINT_ENTER(VMBUS);
-
 	DumpVmbusChannel(Channel);
 
 	DPRINT_DBG(VMBUS, "data buffer - offset %u len %u pfn count %u",
 		   MultiPageBuffer->Offset, MultiPageBuffer->Length, PfnCount);
 
-	ASSERT(PfnCount > 0);
-	ASSERT(PfnCount <= MAX_MULTIPAGE_BUFFER_COUNT);
+	if ((PfnCount < 0) || (PfnCount > MAX_MULTIPAGE_BUFFER_COUNT))
+		return -EINVAL;
 
 	/*
 	 * Adjust the size down since VMBUS_CHANNEL_PACKET_MULITPAGE_BUFFER is
@@ -823,7 +853,7 @@ int VmbusChannelSendPacketMultiPageBuffe
 	packetLen = descSize + BufferLen;
 	packetLenAligned = ALIGN_UP(packetLen, sizeof(u64));
 
-	ASSERT((packetLenAligned - packetLen) < sizeof(u64));
+	/* ASSERT((packetLenAligned - packetLen) < sizeof(u64)); */
 
 	/* Setup the descriptor */
 	desc.Type = VmbusPacketTypeDataUsingGpaDirect;
@@ -850,11 +880,10 @@ int VmbusChannelSendPacketMultiPageBuffe
 	if (ret == 0 && !GetRingBufferInterruptMask(&Channel->Outbound))
 		VmbusChannelSetEvent(Channel);
 
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 }
 
+
 /**
  * VmbusChannelRecvPacket() - Retrieve the user packet on the specified channel
  * @Channel: Pointer to vmbus_channel structure.
@@ -877,8 +906,6 @@ int VmbusChannelRecvPacket(struct vmbus_
 	int ret;
 	unsigned long flags;
 
-	DPRINT_ENTER(VMBUS);
-
 	*BufferActualLen = 0;
 	*RequestId = 0;
 
@@ -890,7 +917,6 @@ int VmbusChannelRecvPacket(struct vmbus_
 		spin_unlock_irqrestore(&Channel->inbound_lock, flags);
 
 		/* DPRINT_DBG(VMBUS, "nothing to read!!"); */
-		DPRINT_EXIT(VMBUS);
 		return 0;
 	}
 
@@ -912,8 +938,6 @@ int VmbusChannelRecvPacket(struct vmbus_
 
 		DPRINT_ERR(VMBUS, "buffer too small - got %d needs %d",
 			   BufferLen, userLen);
-		DPRINT_EXIT(VMBUS);
-
 		return -1;
 	}
 
@@ -925,13 +949,11 @@ int VmbusChannelRecvPacket(struct vmbus_
 
 	spin_unlock_irqrestore(&Channel->inbound_lock, flags);
 
-	DPRINT_EXIT(VMBUS);
-
 	return 0;
 }
 EXPORT_SYMBOL(VmbusChannelRecvPacket);
 
-/**
+/*
  * VmbusChannelRecvPacketRaw - Retrieve the raw packet on the specified channel
  */
 int VmbusChannelRecvPacketRaw(struct vmbus_channel *Channel, void *Buffer,
@@ -944,8 +966,6 @@ int VmbusChannelRecvPacketRaw(struct vmb
 	int ret;
 	unsigned long flags;
 
-	DPRINT_ENTER(VMBUS);
-
 	*BufferActualLen = 0;
 	*RequestId = 0;
 
@@ -957,7 +977,6 @@ int VmbusChannelRecvPacketRaw(struct vmb
 		spin_unlock_irqrestore(&Channel->inbound_lock, flags);
 
 		/* DPRINT_DBG(VMBUS, "nothing to read!!"); */
-		DPRINT_EXIT(VMBUS);
 		return 0;
 	}
 
@@ -978,7 +997,6 @@ int VmbusChannelRecvPacketRaw(struct vmb
 
 		DPRINT_ERR(VMBUS, "buffer too small - needed %d bytes but "
 			   "got space for only %d bytes", packetLen, BufferLen);
-		DPRINT_EXIT(VMBUS);
 		return -2;
 	}
 
@@ -988,38 +1006,34 @@ int VmbusChannelRecvPacketRaw(struct vmb
 	ret = RingBufferRead(&Channel->Inbound, Buffer, packetLen, 0);
 
 	spin_unlock_irqrestore(&Channel->inbound_lock, flags);
-
-	DPRINT_EXIT(VMBUS);
-
 	return 0;
 }
 
-/**
+/*
  * VmbusChannelOnChannelEvent - Channel event callback
  */
 void VmbusChannelOnChannelEvent(struct vmbus_channel *Channel)
 {
 	DumpVmbusChannel(Channel);
-	ASSERT(Channel->OnChannelCallback);
+	/* ASSERT(Channel->OnChannelCallback); */
 
 	Channel->OnChannelCallback(Channel->ChannelCallbackContext);
 
 	mod_timer(&Channel->poll_timer, jiffies + usecs_to_jiffies(100));
 }
 
-/**
+/*
  * VmbusChannelOnTimer - Timer event callback
  */
 void VmbusChannelOnTimer(unsigned long data)
 {
 	struct vmbus_channel *channel = (struct vmbus_channel *)data;
 
-	if (channel->OnChannelCallback) {
+	if (channel->OnChannelCallback)
 		channel->OnChannelCallback(channel->ChannelCallbackContext);
-	}
 }
 
-/**
+/*
  * DumpVmbusChannel - Dump vmbus channel info to the console
  */
 static void DumpVmbusChannel(struct vmbus_channel *Channel)
--- a/drivers/staging/hv/ChannelMgmt.c
+++ b/drivers/staging/hv/ChannelMgmt.c
@@ -20,6 +20,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/slab.h>
 #include <linux/list.h>
 #include <linux/module.h>
 #include "osd.h"
@@ -32,8 +33,8 @@ struct vmbus_channel_message_table_entry
 	void (*messageHandler)(struct vmbus_channel_message_header *msg);
 };
 
-#define MAX_MSG_TYPES                    1
-#define MAX_NUM_DEVICE_CLASSES_SUPPORTED 5
+#define MAX_MSG_TYPES                    3
+#define MAX_NUM_DEVICE_CLASSES_SUPPORTED 7
 
 static const struct hv_guid
 	gSupportedDeviceClasses[MAX_NUM_DEVICE_CLASSES_SUPPORTED] = {
@@ -80,8 +81,25 @@ static const struct hv_guid
 			0x81, 0x8B, 0x38, 0XD9, 0x0C, 0xED, 0x39, 0xDB
 		}
 	},
+	/* {9527E630-D0AE-497b-ADCE-E80AB0175CAF} */
+	/* TimeSync */
+	{
+		.data = {
+			0x30, 0xe6, 0x27, 0x95, 0xae, 0xd0, 0x7b, 0x49,
+			0xad, 0xce, 0xe8, 0x0a, 0xb0, 0x17, 0x5c, 0xaf
+		}
+	},
+	/* {57164f39-9115-4e78-ab55-382f3bd5422d} */
+	/* Heartbeat */
+	{
+		.data = {
+			0x39, 0x4f, 0x16, 0x57, 0x15, 0x91, 0x78, 0x4e,
+			0xab, 0x55, 0x38, 0x2f, 0x3b, 0xd5, 0x42, 0x2d
+		}
+	},
 };
 
+
 /**
  * prep_negotiate_resp() - Create default response for Hyper-V Negotiate message
  * @icmsghdrp: Pointer to msg header structure
@@ -189,10 +207,33 @@ struct hyperv_service_callback hv_cb_uti
 		.callback = chn_cb_negotiate,
 		.log_msg = "Shutdown channel functionality initialized"
 	},
+
+	/* {9527E630-D0AE-497b-ADCE-E80AB0175CAF} */
+	/* TimeSync */
+	{
+		.msg_type = HV_TIMESYNC_MSG,
+		.data = {
+			0x30, 0xe6, 0x27, 0x95, 0xae, 0xd0, 0x7b, 0x49,
+			0xad, 0xce, 0xe8, 0x0a, 0xb0, 0x17, 0x5c, 0xaf
+		},
+		.callback = chn_cb_negotiate,
+		.log_msg = "Timesync channel functionality initialized"
+	},
+	/* {57164f39-9115-4e78-ab55-382f3bd5422d} */
+	/* Heartbeat */
+	{
+		.msg_type = HV_HEARTBEAT_MSG,
+		.data = {
+			0x39, 0x4f, 0x16, 0x57, 0x15, 0x91, 0x78, 0x4e,
+			0xab, 0x55, 0x38, 0x2f, 0x3b, 0xd5, 0x42, 0x2d
+		},
+		.callback = chn_cb_negotiate,
+		.log_msg = "Heartbeat channel functionality initialized"
+	},
 };
 EXPORT_SYMBOL(hv_cb_utils);
 
-/**
+/*
  * AllocVmbusChannel - Allocate and initialize a vmbus channel object
  */
 struct vmbus_channel *AllocVmbusChannel(void)
@@ -218,25 +259,21 @@ struct vmbus_channel *AllocVmbusChannel(
 	return channel;
 }
 
-/**
+/*
  * ReleaseVmbusChannel - Release the vmbus channel object itself
  */
 static inline void ReleaseVmbusChannel(void *context)
 {
 	struct vmbus_channel *channel = context;
 
-	DPRINT_ENTER(VMBUS);
-
 	DPRINT_DBG(VMBUS, "releasing channel (%p)", channel);
 	destroy_workqueue(channel->ControlWQ);
 	DPRINT_DBG(VMBUS, "channel released (%p)", channel);
 
 	kfree(channel);
-
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * FreeVmbusChannel - Release the resources used by the vmbus channel object
  */
 void FreeVmbusChannel(struct vmbus_channel *Channel)
@@ -252,7 +289,7 @@ void FreeVmbusChannel(struct vmbus_chann
 			      Channel);
 }
 
-/**
+/*
  * VmbusChannelProcessOffer - Process the offer by creating a channel/device
  * associated with this offer
  */
@@ -265,8 +302,6 @@ static void VmbusChannelProcessOffer(voi
 	int cnt;
 	unsigned long flags;
 
-	DPRINT_ENTER(VMBUS);
-
 	/* Make sure this is a new offer */
 	spin_lock_irqsave(&gVmbusConnection.channel_lock, flags);
 
@@ -292,7 +327,6 @@ static void VmbusChannelProcessOffer(voi
 		DPRINT_DBG(VMBUS, "Ignoring duplicate offer for relid (%d)",
 			   newChannel->OfferMsg.ChildRelId);
 		FreeVmbusChannel(newChannel);
-		DPRINT_EXIT(VMBUS);
 		return;
 	}
 
@@ -350,22 +384,19 @@ static void VmbusChannelProcessOffer(voi
 			cnt++;
 		}
 	}
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusChannelProcessRescindOffer - Rescind the offer by initiating a device removal
  */
 static void VmbusChannelProcessRescindOffer(void *context)
 {
 	struct vmbus_channel *channel = context;
 
-	DPRINT_ENTER(VMBUS);
 	VmbusChildDeviceRemove(channel->DeviceObject);
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusChannelOnOffer - Handler for channel offers from vmbus in parent partition.
  *
  * We ignore all offers except network and storage offers. For each network and
@@ -381,8 +412,6 @@ static void VmbusChannelOnOffer(struct v
 	int i;
 	int fSupported = 0;
 
-	DPRINT_ENTER(VMBUS);
-
 	offer = (struct vmbus_channel_offer_channel *)hdr;
 	for (i = 0; i < MAX_NUM_DEVICE_CLASSES_SUPPORTED; i++) {
 		if (memcmp(&offer->Offer.InterfaceType,
@@ -395,7 +424,6 @@ static void VmbusChannelOnOffer(struct v
 	if (!fSupported) {
 		DPRINT_DBG(VMBUS, "Ignoring channel offer notification for "
 			   "child relid %d", offer->ChildRelId);
-		DPRINT_EXIT(VMBUS);
 		return;
 	}
 
@@ -444,11 +472,9 @@ static void VmbusChannelOnOffer(struct v
 	/* TODO: Make sure the offer comes from our parent partition */
 	osd_schedule_callback(newChannel->ControlWQ, VmbusChannelProcessOffer,
 			      newChannel);
-
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusChannelOnOfferRescind - Rescind offer handler.
  *
  * We queue a work item to process this offer synchronously
@@ -458,8 +484,6 @@ static void VmbusChannelOnOfferRescind(s
 	struct vmbus_channel_rescind_offer *rescind;
 	struct vmbus_channel *channel;
 
-	DPRINT_ENTER(VMBUS);
-
 	rescind = (struct vmbus_channel_rescind_offer *)hdr;
 	channel = GetChannelFromRelId(rescind->ChildRelId);
 	if (channel == NULL) {
@@ -471,11 +495,9 @@ static void VmbusChannelOnOfferRescind(s
 	osd_schedule_callback(channel->ControlWQ,
 			      VmbusChannelProcessRescindOffer,
 			      channel);
-
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusChannelOnOffersDelivered - This is invoked when all offers have been delivered.
  *
  * Nothing to do here.
@@ -483,11 +505,9 @@ static void VmbusChannelOnOfferRescind(s
 static void VmbusChannelOnOffersDelivered(
 			struct vmbus_channel_message_header *hdr)
 {
-	DPRINT_ENTER(VMBUS);
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusChannelOnOpenResult - Open result handler.
  *
  * This is invoked when we received a response to our channel open request.
@@ -503,8 +523,6 @@ static void VmbusChannelOnOpenResult(str
 	struct vmbus_channel_open_channel *openMsg;
 	unsigned long flags;
 
-	DPRINT_ENTER(VMBUS);
-
 	result = (struct vmbus_channel_open_result *)hdr;
 	DPRINT_DBG(VMBUS, "vmbus open result - %d", result->Status);
 
@@ -531,11 +549,9 @@ static void VmbusChannelOnOpenResult(str
 		}
 	}
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
-
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusChannelOnGpadlCreated - GPADL created handler.
  *
  * This is invoked when we received a response to our gpadl create request.
@@ -551,8 +567,6 @@ static void VmbusChannelOnGpadlCreated(s
 	struct vmbus_channel_gpadl_header *gpadlHeader;
 	unsigned long flags;
 
-	DPRINT_ENTER(VMBUS);
-
 	gpadlCreated = (struct vmbus_channel_gpadl_created *)hdr;
 	DPRINT_DBG(VMBUS, "vmbus gpadl created result - %d",
 		   gpadlCreated->CreationStatus);
@@ -583,11 +597,9 @@ static void VmbusChannelOnGpadlCreated(s
 		}
 	}
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
-
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusChannelOnGpadlTorndown - GPADL torndown handler.
  *
  * This is invoked when we received a response to our gpadl teardown request.
@@ -604,8 +616,6 @@ static void VmbusChannelOnGpadlTorndown(
 	struct vmbus_channel_gpadl_teardown *gpadlTeardown;
 	unsigned long flags;
 
-	DPRINT_ENTER(VMBUS);
-
 	gpadlTorndown = (struct vmbus_channel_gpadl_torndown *)hdr;
 
 	/*
@@ -631,11 +641,9 @@ static void VmbusChannelOnGpadlTorndown(
 		}
 	}
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
-
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusChannelOnVersionResponse - Version response handler
  *
  * This is invoked when we received a response to our initiate contact request.
@@ -652,8 +660,6 @@ static void VmbusChannelOnVersionRespons
 	struct vmbus_channel_version_response *versionResponse;
 	unsigned long flags;
 
-	DPRINT_ENTER(VMBUS);
-
 	versionResponse = (struct vmbus_channel_version_response *)hdr;
 	spin_lock_irqsave(&gVmbusConnection.channelmsg_lock, flags);
 
@@ -672,8 +678,6 @@ static void VmbusChannelOnVersionRespons
 		}
 	}
 	spin_unlock_irqrestore(&gVmbusConnection.channelmsg_lock, flags);
-
-	DPRINT_EXIT(VMBUS);
 }
 
 /* Channel message dispatch table */
@@ -698,7 +702,7 @@ static struct vmbus_channel_message_tabl
 	{ChannelMessageUnload,			NULL},
 };
 
-/**
+/*
  * VmbusOnChannelMessage - Handler for channel protocol messages.
  *
  * This is invoked in the vmbus worker thread context.
@@ -709,8 +713,6 @@ void VmbusOnChannelMessage(void *Context
 	struct vmbus_channel_message_header *hdr;
 	int size;
 
-	DPRINT_ENTER(VMBUS);
-
 	hdr = (struct vmbus_channel_message_header *)msg->u.Payload;
 	size = msg->Header.PayloadSize;
 
@@ -734,10 +736,9 @@ void VmbusOnChannelMessage(void *Context
 
 	/* Free the msg that was allocated in VmbusOnMsgDPC() */
 	kfree(msg);
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusChannelRequestOffers - Send a request to get all our pending offers.
  */
 int VmbusChannelRequestOffers(void)
@@ -746,14 +747,18 @@ int VmbusChannelRequestOffers(void)
 	struct vmbus_channel_msginfo *msgInfo;
 	int ret;
 
-	DPRINT_ENTER(VMBUS);
-
 	msgInfo = kmalloc(sizeof(*msgInfo) +
 			  sizeof(struct vmbus_channel_message_header),
 			  GFP_KERNEL);
-	ASSERT(msgInfo != NULL);
+	if (!msgInfo)
+		return -ENOMEM;
 
 	msgInfo->WaitEvent = osd_WaitEventCreate();
+	if (!msgInfo->WaitEvent) {
+		kfree(msgInfo);
+		return -ENOMEM;
+	}
+
 	msg = (struct vmbus_channel_message_header *)msgInfo->Msg;
 
 	msg->MessageType = ChannelMessageRequestOffers;
@@ -787,12 +792,12 @@ Cleanup:
 		kfree(msgInfo);
 	}
 
-	DPRINT_EXIT(VMBUS);
 	return ret;
 }
 
-/**
- * VmbusChannelReleaseUnattachedChannels - Release channels that are unattached/unconnected ie (no drivers associated)
+/*
+ * VmbusChannelReleaseUnattachedChannels - Release channels that are
+ * unattached/unconnected ie (no drivers associated)
  */
 void VmbusChannelReleaseUnattachedChannels(void)
 {
--- a/drivers/staging/hv/ChannelMgmt.h
+++ b/drivers/staging/hv/ChannelMgmt.h
@@ -247,8 +247,8 @@ struct vmbus_channel {
 	/* Allocated memory for ring buffer */
 	void *RingBufferPages;
 	u32 RingBufferPageCount;
-	RING_BUFFER_INFO Outbound;	/* send to parent */
-	RING_BUFFER_INFO Inbound;	/* receive from parent */
+	struct hv_ring_buffer_info Outbound;	/* send to parent */
+	struct hv_ring_buffer_info Inbound;	/* receive from parent */
 	spinlock_t inbound_lock;
 	struct workqueue_struct *ControlWQ;
 
@@ -272,8 +272,8 @@ struct vmbus_channel_debug_info {
 	u32 ClientMonitorLatency;
 	u32 ClientMonitorConnectionId;
 
-	RING_BUFFER_DEBUG_INFO Inbound;
-	RING_BUFFER_DEBUG_INFO Outbound;
+	struct hv_ring_buffer_debug_info Inbound;
+	struct hv_ring_buffer_debug_info Outbound;
 };
 
 /*
--- a/drivers/staging/hv/Connection.c
+++ b/drivers/staging/hv/Connection.c
@@ -22,6 +22,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include "osd.h"
 #include "logging.h"
@@ -33,7 +34,7 @@ struct VMBUS_CONNECTION gVmbusConnection
 	.NextGpadlHandle	= ATOMIC_INIT(0xE1E10),
 };
 
-/**
+/*
  * VmbusConnect - Sends a connect request on the partition service connection
  */
 int VmbusConnect(void)
@@ -43,8 +44,6 @@ int VmbusConnect(void)
 	struct vmbus_channel_initiate_contact *msg;
 	unsigned long flags;
 
-	DPRINT_ENTER(VMBUS);
-
 	/* Make sure we are not connecting or connected */
 	if (gVmbusConnection.ConnectState != Disconnected)
 		return -1;
@@ -92,11 +91,16 @@ int VmbusConnect(void)
 			  sizeof(struct vmbus_channel_initiate_contact),
 			  GFP_KERNEL);
 	if (msgInfo == NULL) {
-		ret = -1;
+		ret = -ENOMEM;
 		goto Cleanup;
 	}
 
 	msgInfo->WaitEvent = osd_WaitEventCreate();
+	if (!msgInfo->WaitEvent) {
+		ret = -ENOMEM;
+		goto Cleanup;
+	}
+
 	msg = (struct vmbus_channel_initiate_contact *)msgInfo->Msg;
 
 	msg->Header.MessageType = ChannelMessageInitiateContact;
@@ -149,8 +153,6 @@ int VmbusConnect(void)
 
 	kfree(msgInfo->WaitEvent);
 	kfree(msgInfo);
-	DPRINT_EXIT(VMBUS);
-
 	return 0;
 
 Cleanup:
@@ -174,12 +176,10 @@ Cleanup:
 		kfree(msgInfo);
 	}
 
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 }
 
-/**
+/*
  * VmbusDisconnect - Sends a disconnect request on the partition service connection
  */
 int VmbusDisconnect(void)
@@ -187,13 +187,13 @@ int VmbusDisconnect(void)
 	int ret = 0;
 	struct vmbus_channel_message_header *msg;
 
-	DPRINT_ENTER(VMBUS);
-
 	/* Make sure we are connected */
 	if (gVmbusConnection.ConnectState != Connected)
 		return -1;
 
 	msg = kzalloc(sizeof(struct vmbus_channel_message_header), GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
 
 	msg->MessageType = ChannelMessageUnload;
 
@@ -213,11 +213,10 @@ int VmbusDisconnect(void)
 
 Cleanup:
 	kfree(msg);
-	DPRINT_EXIT(VMBUS);
 	return ret;
 }
 
-/**
+/*
  * GetChannelFromRelId - Get the channel object given its child relative id (ie channel id)
  */
 struct vmbus_channel *GetChannelFromRelId(u32 relId)
@@ -238,7 +237,7 @@ struct vmbus_channel *GetChannelFromRelI
 	return foundChannel;
 }
 
-/**
+/*
  * VmbusProcessChannelEvent - Process a channel event notification
  */
 static void VmbusProcessChannelEvent(void *context)
@@ -246,7 +245,7 @@ static void VmbusProcessChannelEvent(voi
 	struct vmbus_channel *channel;
 	u32 relId = (u32)(unsigned long)context;
 
-	ASSERT(relId > 0);
+	/* ASSERT(relId > 0); */
 
 	/*
 	 * Find the channel based on this relid and invokes the
@@ -258,15 +257,15 @@ static void VmbusProcessChannelEvent(voi
 		VmbusChannelOnChannelEvent(channel);
 		/*
 		 * WorkQueueQueueWorkItem(channel->dataWorkQueue,
-		 * 			  VmbusChannelOnChannelEvent,
-		 * 			  (void*)channel);
+		 *			  VmbusChannelOnChannelEvent,
+		 *			  (void*)channel);
 		 */
 	} else {
 		DPRINT_ERR(VMBUS, "channel not found for relid - %d.", relId);
 	}
 }
 
-/**
+/*
  * VmbusOnEvents - Handler for events
  */
 void VmbusOnEvents(void)
@@ -277,8 +276,6 @@ void VmbusOnEvents(void)
 	int relid;
 	u32 *recvInterruptPage = gVmbusConnection.RecvInterruptPage;
 
-	DPRINT_ENTER(VMBUS);
-
 	/* Check events */
 	if (recvInterruptPage) {
 		for (dword = 0; dword < maxdword; dword++) {
@@ -304,12 +301,10 @@ void VmbusOnEvents(void)
 			}
 		 }
 	}
-	DPRINT_EXIT(VMBUS);
-
 	return;
 }
 
-/**
+/*
  * VmbusPostMessage - Send a msg on the vmbus's message connection
  */
 int VmbusPostMessage(void *buffer, size_t bufferLen)
@@ -321,23 +316,15 @@ int VmbusPostMessage(void *buffer, size_
 	return HvPostMessage(connId, 1, buffer, bufferLen);
 }
 
-/**
+/*
  * VmbusSetEvent - Send an event notification to the parent
  */
 int VmbusSetEvent(u32 childRelId)
 {
-	int ret = 0;
-
-	DPRINT_ENTER(VMBUS);
-
 	/* Each u32 represents 32 channels */
 	sync_set_bit(childRelId & 31,
 		(unsigned long *)gVmbusConnection.SendInterruptPage +
 		(childRelId >> 5));
 
-	ret = HvSignalEvent();
-
-	DPRINT_EXIT(VMBUS);
-
-	return ret;
+	return HvSignalEvent();
 }
--- a/drivers/staging/hv/Hv.c
+++ b/drivers/staging/hv/Hv.c
@@ -21,6 +21,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include "osd.h"
 #include "logging.h"
@@ -34,7 +35,7 @@ struct hv_context gHvContext = {
 	.SignalEventBuffer	= NULL,
 };
 
-/**
+/*
  * HvQueryHypervisorPresence - Query the cpuid for presense of windows hypervisor
  */
 static int HvQueryHypervisorPresence(void)
@@ -55,7 +56,7 @@ static int HvQueryHypervisorPresence(voi
 	return ecx & HV_PRESENT_BIT;
 }
 
-/**
+/*
  * HvQueryHypervisorInfo - Get version info of the windows hypervisor
  */
 static int HvQueryHypervisorInfo(void)
@@ -124,7 +125,7 @@ static int HvQueryHypervisorInfo(void)
 	return maxLeaf;
 }
 
-/**
+/*
  * HvDoHypercall - Invoke the specified hypercall
  */
 static u64 HvDoHypercall(u64 Control, void *Input, void *Output)
@@ -179,7 +180,7 @@ static u64 HvDoHypercall(u64 Control, vo
 #endif /* !x86_64 */
 }
 
-/**
+/*
  * HvInit - Main initialization routine.
  *
  * This routine must be called before any other routines in here are called
@@ -191,8 +192,6 @@ int HvInit(void)
 	union hv_x64_msr_hypercall_contents hypercallMsr;
 	void *virtAddr = NULL;
 
-	DPRINT_ENTER(VMBUS);
-
 	memset(gHvContext.synICEventPage, 0, sizeof(void *) * MAX_NUM_CPUS);
 	memset(gHvContext.synICMessagePage, 0, sizeof(void *) * MAX_NUM_CPUS);
 
@@ -208,50 +207,51 @@ int HvInit(void)
 	/* HvQueryHypervisorFeatures(maxLeaf); */
 
 	/*
-	 * Determine if we are running on xenlinux (ie x2v shim) or native
-	 * linux
+	 * We only support running on top of Hyper-V
 	 */
 	rdmsrl(HV_X64_MSR_GUEST_OS_ID, gHvContext.GuestId);
-	if (gHvContext.GuestId == 0) {
-		/* Write our OS info */
-		wrmsrl(HV_X64_MSR_GUEST_OS_ID, HV_LINUX_GUEST_ID);
-		gHvContext.GuestId = HV_LINUX_GUEST_ID;
+
+	if (gHvContext.GuestId != 0) {
+		DPRINT_ERR(VMBUS, "Unknown guest id (0x%llx)!!",
+				gHvContext.GuestId);
+		goto Cleanup;
 	}
 
+	/* Write our OS info */
+	wrmsrl(HV_X64_MSR_GUEST_OS_ID, HV_LINUX_GUEST_ID);
+	gHvContext.GuestId = HV_LINUX_GUEST_ID;
+
 	/* See if the hypercall page is already set */
 	rdmsrl(HV_X64_MSR_HYPERCALL, hypercallMsr.AsUINT64);
-	if (gHvContext.GuestId == HV_LINUX_GUEST_ID) {
-		/* Allocate the hypercall page memory */
-		/* virtAddr = osd_PageAlloc(1); */
-		virtAddr = osd_VirtualAllocExec(PAGE_SIZE);
-
-		if (!virtAddr) {
-			DPRINT_ERR(VMBUS,
-				   "unable to allocate hypercall page!!");
-			goto Cleanup;
-		}
 
-		hypercallMsr.Enable = 1;
-		/* hypercallMsr.GuestPhysicalAddress =
-		 * 		virt_to_phys(virtAddr) >> PAGE_SHIFT; */
-		hypercallMsr.GuestPhysicalAddress = vmalloc_to_pfn(virtAddr);
-		wrmsrl(HV_X64_MSR_HYPERCALL, hypercallMsr.AsUINT64);
+	/*
+	* Allocate the hypercall page memory
+	* virtAddr = osd_PageAlloc(1);
+	*/
+	virtAddr = osd_VirtualAllocExec(PAGE_SIZE);
 
-		/* Confirm that hypercall page did get setup. */
-		hypercallMsr.AsUINT64 = 0;
-		rdmsrl(HV_X64_MSR_HYPERCALL, hypercallMsr.AsUINT64);
-		if (!hypercallMsr.Enable) {
-			DPRINT_ERR(VMBUS, "unable to set hypercall page!!");
-			goto Cleanup;
-		}
+	if (!virtAddr) {
+		DPRINT_ERR(VMBUS,
+			   "unable to allocate hypercall page!!");
+		goto Cleanup;
+	}
 
-		gHvContext.HypercallPage = virtAddr;
-	} else {
-		DPRINT_ERR(VMBUS, "Unknown guest id (0x%llx)!!",
-				gHvContext.GuestId);
+	hypercallMsr.Enable = 1;
+
+	hypercallMsr.GuestPhysicalAddress = vmalloc_to_pfn(virtAddr);
+	wrmsrl(HV_X64_MSR_HYPERCALL, hypercallMsr.AsUINT64);
+
+	/* Confirm that hypercall page did get setup. */
+	hypercallMsr.AsUINT64 = 0;
+	rdmsrl(HV_X64_MSR_HYPERCALL, hypercallMsr.AsUINT64);
+
+	if (!hypercallMsr.Enable) {
+		DPRINT_ERR(VMBUS, "unable to set hypercall page!!");
 		goto Cleanup;
 	}
 
+	gHvContext.HypercallPage = virtAddr;
+
 	DPRINT_INFO(VMBUS, "Hypercall page VA=%p, PA=0x%0llx",
 		    gHvContext.HypercallPage,
 		    (u64)hypercallMsr.GuestPhysicalAddress << PAGE_SHIFT);
@@ -273,10 +273,6 @@ int HvInit(void)
 	gHvContext.SignalEventParam->FlagNumber = 0;
 	gHvContext.SignalEventParam->RsvdZ = 0;
 
-	/* DPRINT_DBG(VMBUS, "My id %llu", HvGetCurrentPartitionId()); */
-
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 
 Cleanup:
@@ -289,12 +285,10 @@ Cleanup:
 		vfree(virtAddr);
 	}
 	ret = -1;
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 }
 
-/**
+/*
  * HvCleanup - Cleanup routine.
  *
  * This routine is called normally during driver unloading or exiting.
@@ -303,28 +297,19 @@ void HvCleanup(void)
 {
 	union hv_x64_msr_hypercall_contents hypercallMsr;
 
-	DPRINT_ENTER(VMBUS);
+	kfree(gHvContext.SignalEventBuffer);
+	gHvContext.SignalEventBuffer = NULL;
+	gHvContext.SignalEventParam = NULL;
 
-	if (gHvContext.SignalEventBuffer) {
-		kfree(gHvContext.SignalEventBuffer);
-		gHvContext.SignalEventBuffer = NULL;
-		gHvContext.SignalEventParam = NULL;
-	}
-
-	if (gHvContext.GuestId == HV_LINUX_GUEST_ID) {
-		if (gHvContext.HypercallPage) {
-			hypercallMsr.AsUINT64 = 0;
-			wrmsrl(HV_X64_MSR_HYPERCALL, hypercallMsr.AsUINT64);
-			vfree(gHvContext.HypercallPage);
-			gHvContext.HypercallPage = NULL;
-		}
+	if (gHvContext.HypercallPage) {
+		hypercallMsr.AsUINT64 = 0;
+		wrmsrl(HV_X64_MSR_HYPERCALL, hypercallMsr.AsUINT64);
+		vfree(gHvContext.HypercallPage);
+		gHvContext.HypercallPage = NULL;
 	}
-
-	DPRINT_EXIT(VMBUS);
-
 }
 
-/**
+/*
  * HvPostMessage - Post a message using the hypervisor message IPC.
  *
  * This involves a hypercall.
@@ -365,7 +350,7 @@ u16 HvPostMessage(union hv_connection_id
 }
 
 
-/**
+/*
  * HvSignalEvent - Signal an event on the specified connection using the hypervisor event IPC.
  *
  * This involves a hypercall.
@@ -379,7 +364,7 @@ u16 HvSignalEvent(void)
 	return status;
 }
 
-/**
+/*
  * HvSynicInit - Initialize the Synthethic Interrupt Controller.
  *
  * If it is already initialized by another entity (ie x2v shim), we need to
@@ -393,88 +378,54 @@ void HvSynicInit(void *irqarg)
 	union hv_synic_siefp siefp;
 	union hv_synic_sint sharedSint;
 	union hv_synic_scontrol sctrl;
-	u64 guestID;
+
 	u32 irqVector = *((u32 *)(irqarg));
 	int cpu = smp_processor_id();
 
-	DPRINT_ENTER(VMBUS);
-
-	if (!gHvContext.HypercallPage) {
-		DPRINT_EXIT(VMBUS);
+	if (!gHvContext.HypercallPage)
 		return;
-	}
 
 	/* Check the version */
 	rdmsrl(HV_X64_MSR_SVERSION, version);
 
 	DPRINT_INFO(VMBUS, "SynIC version: %llx", version);
 
-	/* TODO: Handle SMP */
-	if (gHvContext.GuestId == HV_XENLINUX_GUEST_ID) {
-		DPRINT_INFO(VMBUS, "Skipping SIMP and SIEFP setup since "
-				"it is already set.");
-
-		rdmsrl(HV_X64_MSR_SIMP, simp.AsUINT64);
-		rdmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
-
-		DPRINT_DBG(VMBUS, "Simp: %llx, Sifep: %llx",
-			   simp.AsUINT64, siefp.AsUINT64);
-
-		/*
-		 * Determine if we are running on xenlinux (ie x2v shim) or
-		 * native linux
-		 */
-		rdmsrl(HV_X64_MSR_GUEST_OS_ID, guestID);
-		if (guestID == HV_LINUX_GUEST_ID) {
-			gHvContext.synICMessagePage[cpu] =
-				phys_to_virt(simp.BaseSimpGpa << PAGE_SHIFT);
-			gHvContext.synICEventPage[cpu] =
-				phys_to_virt(siefp.BaseSiefpGpa << PAGE_SHIFT);
-		} else {
-			DPRINT_ERR(VMBUS, "unknown guest id!!");
-			goto Cleanup;
-		}
-		DPRINT_DBG(VMBUS, "MAPPED: Simp: %p, Sifep: %p",
-			   gHvContext.synICMessagePage[cpu],
-			   gHvContext.synICEventPage[cpu]);
-	} else {
-		gHvContext.synICMessagePage[cpu] = (void *)get_zeroed_page(GFP_ATOMIC);
-		if (gHvContext.synICMessagePage[cpu] == NULL) {
-			DPRINT_ERR(VMBUS,
-				   "unable to allocate SYNIC message page!!");
-			goto Cleanup;
-		}
-
-		gHvContext.synICEventPage[cpu] = (void *)get_zeroed_page(GFP_ATOMIC);
-		if (gHvContext.synICEventPage[cpu] == NULL) {
-			DPRINT_ERR(VMBUS,
-				   "unable to allocate SYNIC event page!!");
-			goto Cleanup;
-		}
+	gHvContext.synICMessagePage[cpu] = (void *)get_zeroed_page(GFP_ATOMIC);
 
-		/* Setup the Synic's message page */
-		rdmsrl(HV_X64_MSR_SIMP, simp.AsUINT64);
-		simp.SimpEnabled = 1;
-		simp.BaseSimpGpa = virt_to_phys(gHvContext.synICMessagePage[cpu])
-					>> PAGE_SHIFT;
-
-		DPRINT_DBG(VMBUS, "HV_X64_MSR_SIMP msr set to: %llx",
-				simp.AsUINT64);
-
-		wrmsrl(HV_X64_MSR_SIMP, simp.AsUINT64);
-
-		/* Setup the Synic's event page */
-		rdmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
-		siefp.SiefpEnabled = 1;
-		siefp.BaseSiefpGpa = virt_to_phys(gHvContext.synICEventPage[cpu])
-					>> PAGE_SHIFT;
+	if (gHvContext.synICMessagePage[cpu] == NULL) {
+		DPRINT_ERR(VMBUS,
+			   "unable to allocate SYNIC message page!!");
+		goto Cleanup;
+	}
 
-		DPRINT_DBG(VMBUS, "HV_X64_MSR_SIEFP msr set to: %llx",
-				siefp.AsUINT64);
+	gHvContext.synICEventPage[cpu] = (void *)get_zeroed_page(GFP_ATOMIC);
 
-		wrmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
+	if (gHvContext.synICEventPage[cpu] == NULL) {
+		DPRINT_ERR(VMBUS,
+			   "unable to allocate SYNIC event page!!");
+		goto Cleanup;
 	}
 
+	/* Setup the Synic's message page */
+	rdmsrl(HV_X64_MSR_SIMP, simp.AsUINT64);
+	simp.SimpEnabled = 1;
+	simp.BaseSimpGpa = virt_to_phys(gHvContext.synICMessagePage[cpu])
+		>> PAGE_SHIFT;
+
+	DPRINT_DBG(VMBUS, "HV_X64_MSR_SIMP msr set to: %llx", simp.AsUINT64);
+
+	wrmsrl(HV_X64_MSR_SIMP, simp.AsUINT64);
+
+	/* Setup the Synic's event page */
+	rdmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
+	siefp.SiefpEnabled = 1;
+	siefp.BaseSiefpGpa = virt_to_phys(gHvContext.synICEventPage[cpu])
+		>> PAGE_SHIFT;
+
+	DPRINT_DBG(VMBUS, "HV_X64_MSR_SIEFP msr set to: %llx", siefp.AsUINT64);
+
+	wrmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
+
 	/* Setup the interception SINT. */
 	/* wrmsrl((HV_X64_MSR_SINT0 + HV_SYNIC_INTERCEPTION_SINT_INDEX), */
 	/*	  interceptionSint.AsUINT64); */
@@ -499,25 +450,18 @@ void HvSynicInit(void *irqarg)
 	wrmsrl(HV_X64_MSR_SCONTROL, sctrl.AsUINT64);
 
 	gHvContext.SynICInitialized = true;
-
-	DPRINT_EXIT(VMBUS);
-
 	return;
 
 Cleanup:
-	if (gHvContext.GuestId == HV_LINUX_GUEST_ID) {
-		if (gHvContext.synICEventPage[cpu])
-			osd_PageFree(gHvContext.synICEventPage[cpu], 1);
-
-		if (gHvContext.synICMessagePage[cpu])
-			osd_PageFree(gHvContext.synICMessagePage[cpu], 1);
-	}
+	if (gHvContext.synICEventPage[cpu])
+		osd_PageFree(gHvContext.synICEventPage[cpu], 1);
 
-	DPRINT_EXIT(VMBUS);
+	if (gHvContext.synICMessagePage[cpu])
+		osd_PageFree(gHvContext.synICMessagePage[cpu], 1);
 	return;
 }
 
-/**
+/*
  * HvSynicCleanup - Cleanup routine for HvSynicInit().
  */
 void HvSynicCleanup(void *arg)
@@ -527,12 +471,8 @@ void HvSynicCleanup(void *arg)
 	union hv_synic_siefp siefp;
 	int cpu = smp_processor_id();
 
-	DPRINT_ENTER(VMBUS);
-
-	if (!gHvContext.SynICInitialized) {
-		DPRINT_EXIT(VMBUS);
+	if (!gHvContext.SynICInitialized)
 		return;
-	}
 
 	rdmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, sharedSint.AsUINT64);
 
@@ -542,27 +482,18 @@ void HvSynicCleanup(void *arg)
 	/* Disable the interrupt */
 	wrmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, sharedSint.AsUINT64);
 
-	/*
-	 * Disable and free the resources only if we are running as
-	 * native linux since in xenlinux, we are sharing the
-	 * resources with the x2v shim
-	 */
-	if (gHvContext.GuestId == HV_LINUX_GUEST_ID) {
-		rdmsrl(HV_X64_MSR_SIMP, simp.AsUINT64);
-		simp.SimpEnabled = 0;
-		simp.BaseSimpGpa = 0;
-
-		wrmsrl(HV_X64_MSR_SIMP, simp.AsUINT64);
-
-		rdmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
-		siefp.SiefpEnabled = 0;
-		siefp.BaseSiefpGpa = 0;
+	rdmsrl(HV_X64_MSR_SIMP, simp.AsUINT64);
+	simp.SimpEnabled = 0;
+	simp.BaseSimpGpa = 0;
 
-		wrmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
+	wrmsrl(HV_X64_MSR_SIMP, simp.AsUINT64);
 
-		osd_PageFree(gHvContext.synICMessagePage[cpu], 1);
-		osd_PageFree(gHvContext.synICEventPage[cpu], 1);
-	}
+	rdmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
+	siefp.SiefpEnabled = 0;
+	siefp.BaseSiefpGpa = 0;
+
+	wrmsrl(HV_X64_MSR_SIEFP, siefp.AsUINT64);
 
-	DPRINT_EXIT(VMBUS);
+	osd_PageFree(gHvContext.synICMessagePage[cpu], 1);
+	osd_PageFree(gHvContext.synICEventPage[cpu], 1);
 }
--- a/drivers/staging/hv/Hv.h
+++ b/drivers/staging/hv/Hv.h
@@ -41,11 +41,6 @@ enum {
 
 #define HV_PRESENT_BIT			0x80000000
 
-#define HV_XENLINUX_GUEST_ID_LO		0x00000000
-#define HV_XENLINUX_GUEST_ID_HI		0x0B00B135
-#define HV_XENLINUX_GUEST_ID		(((u64)HV_XENLINUX_GUEST_ID_HI << 32) \
-					  | HV_XENLINUX_GUEST_ID_LO)
-
 #define HV_LINUX_GUEST_ID_LO		0x00000000
 #define HV_LINUX_GUEST_ID_HI		0xB16B00B5
 #define HV_LINUX_GUEST_ID		(((u64)HV_LINUX_GUEST_ID_HI << 32) | \
@@ -102,8 +97,9 @@ struct hv_input_signal_event_buffer {
 };
 
 struct hv_context {
-	/* XenLinux or native Linux. If XenLinux, the hypercall and synic pages
-	 * has already been initialized */
+	/* We only support running on top of Hyper-V
+	* So at this point this really can only contain the Hyper-V ID
+	*/
 	u64 GuestId;
 
 	void *HypercallPage;
--- a/drivers/staging/hv/NetVsc.c
+++ b/drivers/staging/hv/NetVsc.c
@@ -22,6 +22,7 @@
 #include <linux/mm.h>
 #include <linux/delay.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 #include "osd.h"
 #include "logging.h"
 #include "NetVsc.h"
@@ -91,7 +92,7 @@ static struct netvsc_device *AllocNetDev
 
 static void FreeNetDevice(struct netvsc_device *Device)
 {
-	ASSERT(atomic_read(&Device->RefCount) == 0);
+	WARN_ON(atomic_read(&Device->RefCount) == 0);
 	Device->Device->Extension = NULL;
 	kfree(Device);
 }
@@ -130,7 +131,7 @@ static void PutNetDevice(struct hv_devic
 	struct netvsc_device *netDevice;
 
 	netDevice = Device->Extension;
-	ASSERT(netDevice);
+	/* ASSERT(netDevice); */
 
 	atomic_dec(&netDevice->RefCount);
 }
@@ -166,15 +167,13 @@ static struct netvsc_device *ReleaseInbo
 	return netDevice;
 }
 
-/**
+/*
  * NetVscInitialize - Main entry point
  */
 int NetVscInitialize(struct hv_driver *drv)
 {
 	struct netvsc_driver *driver = (struct netvsc_driver *)drv;
 
-	DPRINT_ENTER(NETVSC);
-
 	DPRINT_DBG(NETVSC, "sizeof(struct hv_netvsc_packet)=%zd, "
 		   "sizeof(struct nvsp_message)=%zd, "
 		   "sizeof(struct vmtransfer_page_packet_header)=%zd",
@@ -183,14 +182,15 @@ int NetVscInitialize(struct hv_driver *d
 		   sizeof(struct vmtransfer_page_packet_header));
 
 	/* Make sure we are at least 2 pages since 1 page is used for control */
-	ASSERT(driver->RingBufferSize >= (PAGE_SIZE << 1));
+	/* ASSERT(driver->RingBufferSize >= (PAGE_SIZE << 1)); */
 
 	drv->name = gDriverName;
 	memcpy(&drv->deviceType, &gNetVscDeviceType, sizeof(struct hv_guid));
 
 	/* Make sure it is set by the caller */
-	ASSERT(driver->OnReceiveCallback);
-	ASSERT(driver->OnLinkStatusChanged);
+	/* FIXME: These probably should still be tested in some way */
+	/* ASSERT(driver->OnReceiveCallback); */
+	/* ASSERT(driver->OnLinkStatusChanged); */
 
 	/* Setup the dispatch table */
 	driver->Base.OnDeviceAdd	= NetVscOnDeviceAdd;
@@ -200,9 +200,6 @@ int NetVscInitialize(struct hv_driver *d
 	driver->OnSend			= NetVscOnSend;
 
 	RndisFilterInit(driver);
-
-	DPRINT_EXIT(NETVSC);
-
 	return 0;
 }
 
@@ -212,18 +209,15 @@ static int NetVscInitializeReceiveBuffer
 	struct netvsc_device *netDevice;
 	struct nvsp_message *initPacket;
 
-	DPRINT_ENTER(NETVSC);
-
 	netDevice = GetOutboundNetDevice(Device);
 	if (!netDevice) {
 		DPRINT_ERR(NETVSC, "unable to get net device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(NETVSC);
 		return -1;
 	}
-	ASSERT(netDevice->ReceiveBufferSize > 0);
+	/* ASSERT(netDevice->ReceiveBufferSize > 0); */
 	/* page-size grandularity */
-	ASSERT((netDevice->ReceiveBufferSize & (PAGE_SIZE - 1)) == 0);
+	/* ASSERT((netDevice->ReceiveBufferSize & (PAGE_SIZE - 1)) == 0); */
 
 	netDevice->ReceiveBuffer =
 		osd_PageAlloc(netDevice->ReceiveBufferSize >> PAGE_SHIFT);
@@ -235,8 +229,8 @@ static int NetVscInitializeReceiveBuffer
 		goto Cleanup;
 	}
 	/* page-aligned buffer */
-	ASSERT(((unsigned long)netDevice->ReceiveBuffer & (PAGE_SIZE - 1)) ==
-		0);
+	/* ASSERT(((unsigned long)netDevice->ReceiveBuffer & (PAGE_SIZE - 1)) == */
+	/* 	0); */
 
 	DPRINT_INFO(NETVSC, "Establishing receive buffer's GPADL...");
 
@@ -293,8 +287,8 @@ static int NetVscInitializeReceiveBuffer
 	}
 
 	/* Parse the response */
-	ASSERT(netDevice->ReceiveSectionCount == 0);
-	ASSERT(netDevice->ReceiveSections == NULL);
+	/* ASSERT(netDevice->ReceiveSectionCount == 0); */
+	/* ASSERT(netDevice->ReceiveSections == NULL); */
 
 	netDevice->ReceiveSectionCount = initPacket->Messages.Version1Messages.SendReceiveBufferComplete.NumSections;
 
@@ -333,7 +327,6 @@ Cleanup:
 
 Exit:
 	PutNetDevice(Device);
-	DPRINT_EXIT(NETVSC);
 	return ret;
 }
 
@@ -343,18 +336,19 @@ static int NetVscInitializeSendBufferWit
 	struct netvsc_device *netDevice;
 	struct nvsp_message *initPacket;
 
-	DPRINT_ENTER(NETVSC);
-
 	netDevice = GetOutboundNetDevice(Device);
 	if (!netDevice) {
 		DPRINT_ERR(NETVSC, "unable to get net device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(NETVSC);
 		return -1;
 	}
-	ASSERT(netDevice->SendBufferSize > 0);
+	if (netDevice->SendBufferSize <= 0) {
+		ret = -EINVAL;
+		goto Cleanup;
+	}
+
 	/* page-size grandularity */
-	ASSERT((netDevice->SendBufferSize & (PAGE_SIZE - 1)) == 0);
+	/* ASSERT((netDevice->SendBufferSize & (PAGE_SIZE - 1)) == 0); */
 
 	netDevice->SendBuffer =
 		osd_PageAlloc(netDevice->SendBufferSize >> PAGE_SHIFT);
@@ -365,7 +359,7 @@ static int NetVscInitializeSendBufferWit
 		goto Cleanup;
 	}
 	/* page-aligned buffer */
-	ASSERT(((unsigned long)netDevice->SendBuffer & (PAGE_SIZE - 1)) == 0);
+	/* ASSERT(((unsigned long)netDevice->SendBuffer & (PAGE_SIZE - 1)) == 0); */
 
 	DPRINT_INFO(NETVSC, "Establishing send buffer's GPADL...");
 
@@ -428,7 +422,6 @@ Cleanup:
 
 Exit:
 	PutNetDevice(Device);
-	DPRINT_EXIT(NETVSC);
 	return ret;
 }
 
@@ -437,8 +430,6 @@ static int NetVscDestroyReceiveBuffer(st
 	struct nvsp_message *revokePacket;
 	int ret = 0;
 
-	DPRINT_ENTER(NETVSC);
-
 	/*
 	 * If we got a section count, it means we received a
 	 * SendReceiveBufferComplete msg (ie sent
@@ -469,7 +460,6 @@ static int NetVscDestroyReceiveBuffer(st
 		if (ret != 0) {
 			DPRINT_ERR(NETVSC, "unable to send revoke receive "
 				   "buffer to netvsp");
-			DPRINT_EXIT(NETVSC);
 			return -1;
 		}
 	}
@@ -486,7 +476,6 @@ static int NetVscDestroyReceiveBuffer(st
 		if (ret != 0) {
 			DPRINT_ERR(NETVSC,
 				   "unable to teardown receive buffer's gpadl");
-			DPRINT_EXIT(NETVSC);
 			return -1;
 		}
 		NetDevice->ReceiveBufferGpadlHandle = 0;
@@ -507,8 +496,6 @@ static int NetVscDestroyReceiveBuffer(st
 		NetDevice->ReceiveSections = NULL;
 	}
 
-	DPRINT_EXIT(NETVSC);
-
 	return ret;
 }
 
@@ -517,8 +504,6 @@ static int NetVscDestroySendBuffer(struc
 	struct nvsp_message *revokePacket;
 	int ret = 0;
 
-	DPRINT_ENTER(NETVSC);
-
 	/*
 	 * If we got a section count, it means we received a
 	 *  SendReceiveBufferComplete msg (ie sent
@@ -548,7 +533,6 @@ static int NetVscDestroySendBuffer(struc
 		if (ret != 0) {
 			DPRINT_ERR(NETVSC, "unable to send revoke send buffer "
 				   "to netvsp");
-			DPRINT_EXIT(NETVSC);
 			return -1;
 		}
 	}
@@ -566,7 +550,6 @@ static int NetVscDestroySendBuffer(struc
 		if (ret != 0) {
 			DPRINT_ERR(NETVSC, "unable to teardown send buffer's "
 				   "gpadl");
-			DPRINT_EXIT(NETVSC);
 			return -1;
 		}
 		NetDevice->SendBufferGpadlHandle = 0;
@@ -581,8 +564,6 @@ static int NetVscDestroySendBuffer(struc
 		NetDevice->SendBuffer = NULL;
 	}
 
-	DPRINT_EXIT(NETVSC);
-
 	return ret;
 }
 
@@ -594,13 +575,10 @@ static int NetVscConnectToVsp(struct hv_
 	struct nvsp_message *initPacket;
 	int ndisVersion;
 
-	DPRINT_ENTER(NETVSC);
-
 	netDevice = GetOutboundNetDevice(Device);
 	if (!netDevice) {
 		DPRINT_ERR(NETVSC, "unable to get net device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(NETVSC);
 		return -1;
 	}
 
@@ -690,21 +668,16 @@ static int NetVscConnectToVsp(struct hv_
 
 Cleanup:
 	PutNetDevice(Device);
-	DPRINT_EXIT(NETVSC);
 	return ret;
 }
 
 static void NetVscDisconnectFromVsp(struct netvsc_device *NetDevice)
 {
-	DPRINT_ENTER(NETVSC);
-
 	NetVscDestroyReceiveBuffer(NetDevice);
 	NetVscDestroySendBuffer(NetDevice);
-
-	DPRINT_EXIT(NETVSC);
 }
 
-/**
+/*
  * NetVscOnDeviceAdd - Callback when the device belonging to this driver is added
  */
 static int NetVscOnDeviceAdd(struct hv_device *Device, void *AdditionalInfo)
@@ -716,8 +689,6 @@ static int NetVscOnDeviceAdd(struct hv_d
 	struct netvsc_driver *netDriver =
 				(struct netvsc_driver *)Device->Driver;
 
-	DPRINT_ENTER(NETVSC);
-
 	netDevice = AllocNetDevice(Device);
 	if (!netDevice) {
 		ret = -1;
@@ -748,6 +719,10 @@ static int NetVscOnDeviceAdd(struct hv_d
 			      &netDevice->ReceivePacketList);
 	}
 	netDevice->ChannelInitEvent = osd_WaitEventCreate();
+	if (!netDevice->ChannelInitEvent) {
+		ret = -ENOMEM;
+		goto Cleanup;
+	}
 
 	/* Open the channel */
 	ret = Device->Driver->VmbusChannelInterface.Open(Device,
@@ -777,7 +752,6 @@ static int NetVscOnDeviceAdd(struct hv_d
 	DPRINT_INFO(NETVSC, "*** NetVSC channel handshake result - %d ***",
 		    ret);
 
-	DPRINT_EXIT(NETVSC);
 	return ret;
 
 Close:
@@ -802,11 +776,10 @@ Cleanup:
 		FreeNetDevice(netDevice);
 	}
 
-	DPRINT_EXIT(NETVSC);
 	return ret;
 }
 
-/**
+/*
  * NetVscOnDeviceRemove - Callback when the root bus device is removed
  */
 static int NetVscOnDeviceRemove(struct hv_device *Device)
@@ -814,8 +787,6 @@ static int NetVscOnDeviceRemove(struct h
 	struct netvsc_device *netDevice;
 	struct hv_netvsc_packet *netvscPacket, *pos;
 
-	DPRINT_ENTER(NETVSC);
-
 	DPRINT_INFO(NETVSC, "Disabling outbound traffic on net device (%p)...",
 		    Device->Extension);
 
@@ -858,18 +829,14 @@ static int NetVscOnDeviceRemove(struct h
 
 	kfree(netDevice->ChannelInitEvent);
 	FreeNetDevice(netDevice);
-
-	DPRINT_EXIT(NETVSC);
 	return 0;
 }
 
-/**
+/*
  * NetVscOnCleanup - Perform any cleanup when the driver is removed
  */
 static void NetVscOnCleanup(struct hv_driver *drv)
 {
-	DPRINT_ENTER(NETVSC);
-	DPRINT_EXIT(NETVSC);
 }
 
 static void NetVscOnSendCompletion(struct hv_device *Device,
@@ -879,13 +846,10 @@ static void NetVscOnSendCompletion(struc
 	struct nvsp_message *nvspPacket;
 	struct hv_netvsc_packet *nvscPacket;
 
-	DPRINT_ENTER(NETVSC);
-
 	netDevice = GetInboundNetDevice(Device);
 	if (!netDevice) {
 		DPRINT_ERR(NETVSC, "unable to get net device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(NETVSC);
 		return;
 	}
 
@@ -907,7 +871,7 @@ static void NetVscOnSendCompletion(struc
 		   NvspMessage1TypeSendRNDISPacketComplete) {
 		/* Get the send context */
 		nvscPacket = (struct hv_netvsc_packet *)(unsigned long)Packet->TransactionId;
-		ASSERT(nvscPacket);
+		/* ASSERT(nvscPacket); */
 
 		/* Notify the layer above us */
 		nvscPacket->Completion.Send.OnSendCompletion(nvscPacket->Completion.Send.SendCompletionContext);
@@ -919,7 +883,6 @@ static void NetVscOnSendCompletion(struc
 	}
 
 	PutNetDevice(Device);
-	DPRINT_EXIT(NETVSC);
 }
 
 static int NetVscOnSend(struct hv_device *Device,
@@ -930,13 +893,10 @@ static int NetVscOnSend(struct hv_device
 
 	struct nvsp_message sendMessage;
 
-	DPRINT_ENTER(NETVSC);
-
 	netDevice = GetOutboundNetDevice(Device);
 	if (!netDevice) {
 		DPRINT_ERR(NETVSC, "net device (%p) shutting down..."
 			   "ignoring outbound packets", netDevice);
-		DPRINT_EXIT(NETVSC);
 		return -2;
 	}
 
@@ -976,8 +936,6 @@ static int NetVscOnSend(struct hv_device
 
 	atomic_inc(&netDevice->NumOutstandingSends);
 	PutNetDevice(Device);
-
-	DPRINT_EXIT(NETVSC);
 	return ret;
 }
 
@@ -997,13 +955,10 @@ static void NetVscOnReceive(struct hv_de
 	unsigned long flags;
 	LIST_HEAD(listHead);
 
-	DPRINT_ENTER(NETVSC);
-
 	netDevice = GetInboundNetDevice(Device);
 	if (!netDevice) {
 		DPRINT_ERR(NETVSC, "unable to get net device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(NETVSC);
 		return;
 	}
 
@@ -1086,13 +1041,13 @@ static void NetVscOnReceive(struct hv_de
 	}
 
 	/* Remove the 1st packet to represent the xfer page packet itself */
-	xferpagePacket = (struct xferpage_packet*)listHead.next;
+	xferpagePacket = (struct xferpage_packet *)listHead.next;
 	list_del(&xferpagePacket->ListEntry);
 
 	/* This is how much we can satisfy */
 	xferpagePacket->Count = count - 1;
-	ASSERT(xferpagePacket->Count > 0 && xferpagePacket->Count <=
-		vmxferpagePacket->RangeCount);
+	/* ASSERT(xferpagePacket->Count > 0 && xferpagePacket->Count <= */
+	/* 	vmxferpagePacket->RangeCount); */
 
 	if (xferpagePacket->Count != vmxferpagePacket->RangeCount) {
 		DPRINT_INFO(NETVSC, "Needed %d netvsc pkts to satisy this xfer "
@@ -1102,7 +1057,7 @@ static void NetVscOnReceive(struct hv_de
 
 	/* Each range represents 1 RNDIS pkt that contains 1 ethernet frame */
 	for (i = 0; i < (count - 1); i++) {
-		netvscPacket = (struct hv_netvsc_packet*)listHead.next;
+		netvscPacket = (struct hv_netvsc_packet *)listHead.next;
 		list_del(&netvscPacket->ListEntry);
 
 		/* Initialize the netvsc packet */
@@ -1120,9 +1075,9 @@ static void NetVscOnReceive(struct hv_de
 					vmxferpagePacket->Ranges[i].ByteCount;
 		netvscPacket->PageBufferCount = 1;
 
-		ASSERT(vmxferpagePacket->Ranges[i].ByteOffset +
-			vmxferpagePacket->Ranges[i].ByteCount <
-			netDevice->ReceiveBufferSize);
+		/* ASSERT(vmxferpagePacket->Ranges[i].ByteOffset + */
+		/* 	vmxferpagePacket->Ranges[i].ByteCount < */
+		/* 	netDevice->ReceiveBufferSize); */
 
 		netvscPacket->PageBuffers[0].Length =
 					vmxferpagePacket->Ranges[i].ByteCount;
@@ -1160,7 +1115,7 @@ static void NetVscOnReceive(struct hv_de
 				if (bytesRemain == 0)
 					break;
 			}
-			ASSERT(bytesRemain == 0);
+			/* ASSERT(bytesRemain == 0); */
 		}
 		DPRINT_DBG(NETVSC, "[%d] - (abs offset %u len %u) => "
 			   "(pfn %llx, offset %u, len %u)", i,
@@ -1176,10 +1131,9 @@ static void NetVscOnReceive(struct hv_de
 		NetVscOnReceiveCompletion(netvscPacket->Completion.Recv.ReceiveCompletionContext);
 	}
 
-	ASSERT(list_empty(&listHead));
+	/* ASSERT(list_empty(&listHead)); */
 
 	PutNetDevice(Device);
-	DPRINT_EXIT(NETVSC);
 }
 
 static void NetVscSendReceiveCompletion(struct hv_device *Device,
@@ -1238,9 +1192,7 @@ static void NetVscOnReceiveCompletion(vo
 	bool fSendReceiveComp = false;
 	unsigned long flags;
 
-	DPRINT_ENTER(NETVSC);
-
-	ASSERT(packet->XferPagePacket);
+	/* ASSERT(packet->XferPagePacket); */
 
 	/*
 	 * Even though it seems logical to do a GetOutboundNetDevice() here to
@@ -1251,14 +1203,13 @@ static void NetVscOnReceiveCompletion(vo
 	if (!netDevice) {
 		DPRINT_ERR(NETVSC, "unable to get net device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(NETVSC);
 		return;
 	}
 
 	/* Overloading use of the lock. */
 	spin_lock_irqsave(&netDevice->receive_packet_list_lock, flags);
 
-	ASSERT(packet->XferPagePacket->Count > 0);
+	/* ASSERT(packet->XferPagePacket->Count > 0); */
 	packet->XferPagePacket->Count--;
 
 	/*
@@ -1282,33 +1233,33 @@ static void NetVscOnReceiveCompletion(vo
 		NetVscSendReceiveCompletion(device, transactionId);
 
 	PutNetDevice(device);
-	DPRINT_EXIT(NETVSC);
 }
 
-void NetVscOnChannelCallback(void *Context)
+static void NetVscOnChannelCallback(void *Context)
 {
-	const int netPacketSize = 2048;
 	int ret;
 	struct hv_device *device = Context;
 	struct netvsc_device *netDevice;
 	u32 bytesRecvd;
 	u64 requestId;
-	unsigned char packet[netPacketSize];
+	unsigned char *packet;
 	struct vmpacket_descriptor *desc;
-	unsigned char *buffer = packet;
-	int bufferlen = netPacketSize;
-
+	unsigned char *buffer;
+	int bufferlen = NETVSC_PACKET_SIZE;
 
-	DPRINT_ENTER(NETVSC);
+	/* ASSERT(device); */
 
-	ASSERT(device);
+	packet = kzalloc(NETVSC_PACKET_SIZE * sizeof(unsigned char),
+			 GFP_KERNEL);
+	if (!packet)
+		return;
+	buffer = packet;
 
 	netDevice = GetInboundNetDevice(device);
 	if (!netDevice) {
 		DPRINT_ERR(NETVSC, "net device (%p) shutting down..."
 			   "ignoring inbound packets", netDevice);
-		DPRINT_EXIT(NETVSC);
-		return;
+		goto out;
 	}
 
 	do {
@@ -1340,17 +1291,17 @@ void NetVscOnChannelCallback(void *Conte
 				}
 
 				/* reset */
-				if (bufferlen > netPacketSize) {
+				if (bufferlen > NETVSC_PACKET_SIZE) {
 					kfree(buffer);
 					buffer = packet;
-					bufferlen = netPacketSize;
+					bufferlen = NETVSC_PACKET_SIZE;
 				}
 			} else {
 				/* reset */
-				if (bufferlen > netPacketSize) {
+				if (bufferlen > NETVSC_PACKET_SIZE) {
 					kfree(buffer);
 					buffer = packet;
-					bufferlen = netPacketSize;
+					bufferlen = NETVSC_PACKET_SIZE;
 				}
 
 				break;
@@ -1367,12 +1318,11 @@ void NetVscOnChannelCallback(void *Conte
 			}
 
 			bufferlen = bytesRecvd;
-		} else {
-			ASSERT(0);
 		}
 	} while (1);
 
 	PutNetDevice(device);
-	DPRINT_EXIT(NETVSC);
+out:
+	kfree(buffer);
 	return;
 }
--- a/drivers/staging/hv/NetVsc.h
+++ b/drivers/staging/hv/NetVsc.h
@@ -289,6 +289,7 @@ struct nvsp_message {
 /* Preallocated receive packets */
 #define NETVSC_RECEIVE_PACKETLIST_COUNT		256
 
+#define NETVSC_PACKET_SIZE                      2048
 
 /* Per netvsc channel-specific */
 struct netvsc_device {
--- a/drivers/staging/hv/NetVscApi.h
+++ b/drivers/staging/hv/NetVscApi.h
@@ -27,10 +27,6 @@
 
 #include "VmbusApi.h"
 
-/* Defines */
-#define NETVSC_DEVICE_RING_BUFFER_SIZE	(64*PAGE_SIZE)
-#define HW_MACADDR_LEN			6
-
 /* Fwd declaration */
 struct hv_netvsc_packet;
 
@@ -93,9 +89,6 @@ struct netvsc_driver {
 	u32 RingBufferSize;
 	u32 RequestExtSize;
 
-	/* Additional num  of page buffers to allocate */
-	u32 AdditionalRequestPageBufferCount;
-
 	/*
 	 * This is set by the caller to allow us to callback when we
 	 * receive a packet from the "wire"
@@ -105,8 +98,6 @@ struct netvsc_driver {
 	void (*OnLinkStatusChanged)(struct hv_device *dev, u32 Status);
 
 	/* Specific to this driver */
-	int (*OnOpen)(struct hv_device *dev);
-	int (*OnClose)(struct hv_device *dev);
 	int (*OnSend)(struct hv_device *dev, struct hv_netvsc_packet *packet);
 
 	void *Context;
@@ -119,5 +110,7 @@ struct netvsc_device_info {
 
 /* Interface */
 int NetVscInitialize(struct hv_driver *drv);
+int RndisFilterOnOpen(struct hv_device *Device);
+int RndisFilterOnClose(struct hv_device *Device);
 
 #endif /* _NETVSC_API_H_ */
--- a/drivers/staging/hv/RingBuffer.c
+++ b/drivers/staging/hv/RingBuffer.c
@@ -32,7 +32,7 @@
 
 
 /* Amount of space to write to */
-#define BYTES_AVAIL_TO_WRITE(r, w, z) ((w) >= (r))?((z) - ((w) - (r))):((r) - (w))
+#define BYTES_AVAIL_TO_WRITE(r, w, z) ((w) >= (r)) ? ((z) - ((w) - (r))) : ((r) - (w))
 
 
 /*++
@@ -46,9 +46,9 @@ Description:
 
 --*/
 static inline void
-GetRingBufferAvailBytes(RING_BUFFER_INFO *rbi, u32 *read, u32 *write)
+GetRingBufferAvailBytes(struct hv_ring_buffer_info *rbi, u32 *read, u32 *write)
 {
-	u32 read_loc,write_loc;
+	u32 read_loc, write_loc;
 
 	/* Capture the read/write indices before they changed */
 	read_loc = rbi->RingBuffer->ReadIndex;
@@ -68,11 +68,11 @@ Description:
 
 --*/
 static inline u32
-GetNextWriteLocation(RING_BUFFER_INFO* RingInfo)
+GetNextWriteLocation(struct hv_ring_buffer_info *RingInfo)
 {
 	u32 next = RingInfo->RingBuffer->WriteIndex;
 
-	ASSERT(next < RingInfo->RingDataSize);
+	/* ASSERT(next < RingInfo->RingDataSize); */
 
 	return next;
 }
@@ -87,7 +87,8 @@ Description:
 
 --*/
 static inline void
-SetNextWriteLocation(RING_BUFFER_INFO* RingInfo, u32 NextWriteLocation)
+SetNextWriteLocation(struct hv_ring_buffer_info *RingInfo,
+		     u32 NextWriteLocation)
 {
 	RingInfo->RingBuffer->WriteIndex = NextWriteLocation;
 }
@@ -102,11 +103,11 @@ Description:
 
 --*/
 static inline u32
-GetNextReadLocation(RING_BUFFER_INFO* RingInfo)
+GetNextReadLocation(struct hv_ring_buffer_info *RingInfo)
 {
 	u32 next = RingInfo->RingBuffer->ReadIndex;
 
-	ASSERT(next < RingInfo->RingDataSize);
+	/* ASSERT(next < RingInfo->RingDataSize); */
 
 	return next;
 }
@@ -122,11 +123,11 @@ Description:
 
 --*/
 static inline u32
-GetNextReadLocationWithOffset(RING_BUFFER_INFO* RingInfo, u32 Offset)
+GetNextReadLocationWithOffset(struct hv_ring_buffer_info *RingInfo, u32 Offset)
 {
 	u32 next = RingInfo->RingBuffer->ReadIndex;
 
-	ASSERT(next < RingInfo->RingDataSize);
+	/* ASSERT(next < RingInfo->RingDataSize); */
 	next += Offset;
 	next %= RingInfo->RingDataSize;
 
@@ -143,7 +144,7 @@ Description:
 
 --*/
 static inline void
-SetNextReadLocation(RING_BUFFER_INFO* RingInfo, u32 NextReadLocation)
+SetNextReadLocation(struct hv_ring_buffer_info *RingInfo, u32 NextReadLocation)
 {
 	RingInfo->RingBuffer->ReadIndex = NextReadLocation;
 }
@@ -159,7 +160,7 @@ Description:
 
 --*/
 static inline void *
-GetRingBuffer(RING_BUFFER_INFO* RingInfo)
+GetRingBuffer(struct hv_ring_buffer_info *RingInfo)
 {
 	return (void *)RingInfo->RingBuffer->Buffer;
 }
@@ -175,7 +176,7 @@ Description:
 
 --*/
 static inline u32
-GetRingBufferSize(RING_BUFFER_INFO* RingInfo)
+GetRingBufferSize(struct hv_ring_buffer_info *RingInfo)
 {
 	return RingInfo->RingDataSize;
 }
@@ -190,7 +191,7 @@ Description:
 
 --*/
 static inline u64
-GetRingBufferIndices(RING_BUFFER_INFO* RingInfo)
+GetRingBufferIndices(struct hv_ring_buffer_info *RingInfo)
 {
 	return (u64)RingInfo->RingBuffer->WriteIndex << 32;
 }
@@ -205,14 +206,19 @@ Description:
 	Dump out to console the ring buffer info
 
 --*/
-void DumpRingInfo(RING_BUFFER_INFO *RingInfo, char *Prefix)
+void DumpRingInfo(struct hv_ring_buffer_info *RingInfo, char *Prefix)
 {
 	u32 bytesAvailToWrite;
 	u32 bytesAvailToRead;
 
-	GetRingBufferAvailBytes(RingInfo, &bytesAvailToRead, &bytesAvailToWrite);
-
-	DPRINT(VMBUS, DEBUG_RING_LVL, "%s <<ringinfo %p buffer %p avail write %u avail read %u read idx %u write idx %u>>",
+	GetRingBufferAvailBytes(RingInfo,
+	&bytesAvailToRead,
+	&bytesAvailToWrite);
+
+	DPRINT(VMBUS,
+		DEBUG_RING_LVL,
+		"%s <<ringinfo %p buffer %p avail write %u "
+		"avail read %u read idx %u write idx %u>>",
 		Prefix,
 		RingInfo,
 		RingInfo->RingBuffer->Buffer,
@@ -227,15 +233,15 @@ void DumpRingInfo(RING_BUFFER_INFO *Ring
 
 static u32
 CopyToRingBuffer(
-	RING_BUFFER_INFO	*RingInfo,
+	struct hv_ring_buffer_info	*RingInfo,
 	u32				StartWriteOffset,
-	void *				Src,
+	void				*Src,
 	u32				SrcLen);
 
 static u32
 CopyFromRingBuffer(
-	RING_BUFFER_INFO	*RingInfo,
-	void *				Dest,
+	struct hv_ring_buffer_info	*RingInfo,
+	void				*Dest,
 	u32				DestLen,
 	u32				StartReadOffset);
 
@@ -250,22 +256,22 @@ Description:
 	Get various debug metrics for the specified ring buffer
 
 --*/
-void RingBufferGetDebugInfo(RING_BUFFER_INFO *RingInfo,
-			    RING_BUFFER_DEBUG_INFO *DebugInfo)
+void RingBufferGetDebugInfo(struct hv_ring_buffer_info *RingInfo,
+			    struct hv_ring_buffer_debug_info *debug_info)
 {
 	u32 bytesAvailToWrite;
 	u32 bytesAvailToRead;
 
-	if (RingInfo->RingBuffer)
-	{
-		GetRingBufferAvailBytes(RingInfo, &bytesAvailToRead, &bytesAvailToWrite);
-
-		DebugInfo->BytesAvailToRead = bytesAvailToRead;
-		DebugInfo->BytesAvailToWrite = bytesAvailToWrite;
-		DebugInfo->CurrentReadIndex = RingInfo->RingBuffer->ReadIndex;
-		DebugInfo->CurrentWriteIndex = RingInfo->RingBuffer->WriteIndex;
-
-		DebugInfo->CurrentInterruptMask = RingInfo->RingBuffer->InterruptMask;
+	if (RingInfo->RingBuffer) {
+		GetRingBufferAvailBytes(RingInfo,
+					&bytesAvailToRead,
+					&bytesAvailToWrite);
+
+		debug_info->BytesAvailToRead = bytesAvailToRead;
+		debug_info->BytesAvailToWrite = bytesAvailToWrite;
+		debug_info->CurrentReadIndex = RingInfo->RingBuffer->ReadIndex;
+		debug_info->CurrentWriteIndex = RingInfo->RingBuffer->WriteIndex;
+		debug_info->CurrentInterruptMask = RingInfo->RingBuffer->InterruptMask;
 	}
 }
 
@@ -279,7 +285,7 @@ Description:
 	Get the interrupt mask for the specified ring buffer
 
 --*/
-u32 GetRingBufferInterruptMask(RING_BUFFER_INFO *rbi)
+u32 GetRingBufferInterruptMask(struct hv_ring_buffer_info *rbi)
 {
 	return rbi->RingBuffer->InterruptMask;
 }
@@ -293,17 +299,18 @@ Description:
 	Initialize the ring buffer
 
 --*/
-int RingBufferInit(RING_BUFFER_INFO *RingInfo, void *Buffer, u32 BufferLen)
+int RingBufferInit(struct hv_ring_buffer_info *RingInfo, void *Buffer, u32 BufferLen)
 {
-	ASSERT(sizeof(RING_BUFFER) == PAGE_SIZE);
+	if (sizeof(struct hv_ring_buffer) != PAGE_SIZE)
+		return -EINVAL;
 
-	memset(RingInfo, 0, sizeof(RING_BUFFER_INFO));
+	memset(RingInfo, 0, sizeof(struct hv_ring_buffer_info));
 
-	RingInfo->RingBuffer = (RING_BUFFER*)Buffer;
+	RingInfo->RingBuffer = (struct hv_ring_buffer *)Buffer;
 	RingInfo->RingBuffer->ReadIndex = RingInfo->RingBuffer->WriteIndex = 0;
 
 	RingInfo->RingSize = BufferLen;
-	RingInfo->RingDataSize = BufferLen - sizeof(RING_BUFFER);
+	RingInfo->RingDataSize = BufferLen - sizeof(struct hv_ring_buffer);
 
 	spin_lock_init(&RingInfo->ring_lock);
 
@@ -319,7 +326,7 @@ Description:
 	Cleanup the ring buffer
 
 --*/
-void RingBufferCleanup(RING_BUFFER_INFO* RingInfo)
+void RingBufferCleanup(struct hv_ring_buffer_info *RingInfo)
 {
 }
 
@@ -332,21 +339,19 @@ Description:
 	Write to the ring buffer
 
 --*/
-int RingBufferWrite(RING_BUFFER_INFO *OutRingInfo,
+int RingBufferWrite(struct hv_ring_buffer_info *OutRingInfo,
 		    struct scatterlist *sglist, u32 sgcount)
 {
-	int i=0;
+	int i = 0;
 	u32 byteAvailToWrite;
 	u32 byteAvailToRead;
-	u32 totalBytesToWrite=0;
+	u32 totalBytesToWrite = 0;
 
 	struct scatterlist *sg;
 	volatile u32 nextWriteLocation;
-	u64 prevIndices=0;
+	u64 prevIndices = 0;
 	unsigned long flags;
 
-	DPRINT_ENTER(VMBUS);
-
 	for_each_sg(sglist, sg, sgcount, i)
 	{
 		totalBytesToWrite += sg->length;
@@ -356,22 +361,25 @@ int RingBufferWrite(RING_BUFFER_INFO *Ou
 
 	spin_lock_irqsave(&OutRingInfo->ring_lock, flags);
 
-	GetRingBufferAvailBytes(OutRingInfo, &byteAvailToRead, &byteAvailToWrite);
+	GetRingBufferAvailBytes(OutRingInfo,
+				&byteAvailToRead,
+				&byteAvailToWrite);
 
 	DPRINT_DBG(VMBUS, "Writing %u bytes...", totalBytesToWrite);
 
 	/* DumpRingInfo(OutRingInfo, "BEFORE "); */
 
-	/* If there is only room for the packet, assume it is full. Otherwise, the next time around, we think the ring buffer */
+	/* If there is only room for the packet, assume it is full. */
+	/* Otherwise, the next time around, we think the ring buffer */
 	/* is empty since the read index == write index */
-	if (byteAvailToWrite <= totalBytesToWrite)
-	{
-		DPRINT_DBG(VMBUS, "No more space left on outbound ring buffer (needed %u, avail %u)", totalBytesToWrite, byteAvailToWrite);
+	if (byteAvailToWrite <= totalBytesToWrite) {
+		DPRINT_DBG(VMBUS,
+			"No more space left on outbound ring buffer "
+			"(needed %u, avail %u)",
+			totalBytesToWrite,
+			byteAvailToWrite);
 
 		spin_unlock_irqrestore(&OutRingInfo->ring_lock, flags);
-
-		DPRINT_EXIT(VMBUS);
-
 		return -1;
 	}
 
@@ -403,9 +411,6 @@ int RingBufferWrite(RING_BUFFER_INFO *Ou
 	/* DumpRingInfo(OutRingInfo, "AFTER "); */
 
 	spin_unlock_irqrestore(&OutRingInfo->ring_lock, flags);
-
-	DPRINT_EXIT(VMBUS);
-
 	return 0;
 }
 
@@ -419,21 +424,26 @@ Description:
 	Read without advancing the read index
 
 --*/
-int RingBufferPeek(RING_BUFFER_INFO *InRingInfo, void *Buffer, u32 BufferLen)
+int RingBufferPeek(struct hv_ring_buffer_info *InRingInfo, void *Buffer, u32 BufferLen)
 {
 	u32 bytesAvailToWrite;
 	u32 bytesAvailToRead;
-	u32 nextReadLocation=0;
+	u32 nextReadLocation = 0;
 	unsigned long flags;
 
 	spin_lock_irqsave(&InRingInfo->ring_lock, flags);
 
-	GetRingBufferAvailBytes(InRingInfo, &bytesAvailToRead, &bytesAvailToWrite);
+	GetRingBufferAvailBytes(InRingInfo,
+				&bytesAvailToRead,
+				&bytesAvailToWrite);
 
 	/* Make sure there is something to read */
-	if (bytesAvailToRead < BufferLen )
-	{
-		/* DPRINT_DBG(VMBUS, "got callback but not enough to read <avail to read %d read size %d>!!", bytesAvailToRead, BufferLen); */
+	if (bytesAvailToRead < BufferLen) {
+		/* DPRINT_DBG(VMBUS,
+			"got callback but not enough to read "
+			"<avail to read %d read size %d>!!",
+			bytesAvailToRead,
+			BufferLen); */
 
 		spin_unlock_irqrestore(&InRingInfo->ring_lock, flags);
 
@@ -444,9 +454,9 @@ int RingBufferPeek(RING_BUFFER_INFO *InR
 	nextReadLocation = GetNextReadLocation(InRingInfo);
 
 	nextReadLocation = CopyFromRingBuffer(InRingInfo,
-											Buffer,
-											BufferLen,
-											nextReadLocation);
+						Buffer,
+						BufferLen,
+						nextReadLocation);
 
 	spin_unlock_irqrestore(&InRingInfo->ring_lock, flags);
 
@@ -463,29 +473,35 @@ Description:
 	Read and advance the read index
 
 --*/
-int RingBufferRead(RING_BUFFER_INFO *InRingInfo, void *Buffer,
+int RingBufferRead(struct hv_ring_buffer_info *InRingInfo, void *Buffer,
 		   u32 BufferLen, u32 Offset)
 {
 	u32 bytesAvailToWrite;
 	u32 bytesAvailToRead;
-	u32 nextReadLocation=0;
-	u64 prevIndices=0;
+	u32 nextReadLocation = 0;
+	u64 prevIndices = 0;
 	unsigned long flags;
 
-	ASSERT(BufferLen > 0);
+	if (BufferLen <= 0)
+		return -EINVAL;
 
 	spin_lock_irqsave(&InRingInfo->ring_lock, flags);
 
-	GetRingBufferAvailBytes(InRingInfo, &bytesAvailToRead, &bytesAvailToWrite);
+	GetRingBufferAvailBytes(InRingInfo,
+				&bytesAvailToRead,
+				&bytesAvailToWrite);
 
 	DPRINT_DBG(VMBUS, "Reading %u bytes...", BufferLen);
 
 	/* DumpRingInfo(InRingInfo, "BEFORE "); */
 
 	/* Make sure there is something to read */
-	if (bytesAvailToRead < BufferLen )
-	{
-		DPRINT_DBG(VMBUS, "got callback but not enough to read <avail to read %d read size %d>!!", bytesAvailToRead, BufferLen);
+	if (bytesAvailToRead < BufferLen) {
+		DPRINT_DBG(VMBUS,
+			"got callback but not enough to read "
+			"<avail to read %d read size %d>!!",
+			bytesAvailToRead,
+			BufferLen);
 
 		spin_unlock_irqrestore(&InRingInfo->ring_lock, flags);
 
@@ -495,17 +511,18 @@ int RingBufferRead(RING_BUFFER_INFO *InR
 	nextReadLocation = GetNextReadLocationWithOffset(InRingInfo, Offset);
 
 	nextReadLocation = CopyFromRingBuffer(InRingInfo,
-											Buffer,
-											BufferLen,
-											nextReadLocation);
+						Buffer,
+						BufferLen,
+						nextReadLocation);
 
 	nextReadLocation = CopyFromRingBuffer(InRingInfo,
-											&prevIndices,
-											sizeof(u64),
-											nextReadLocation);
+						&prevIndices,
+						sizeof(u64),
+						nextReadLocation);
 
 	/* Make sure all reads are done before we update the read index since */
-	/* the writer may start writing to the read area once the read index is updated */
+	/* the writer may start writing to the read area once the read index */
+	/*is updated */
 	mb();
 
 	/* Update the read index */
@@ -531,27 +548,24 @@ Description:
 --*/
 static u32
 CopyToRingBuffer(
-	RING_BUFFER_INFO	*RingInfo,
+	struct hv_ring_buffer_info	*RingInfo,
 	u32				StartWriteOffset,
-	void *				Src,
+	void				*Src,
 	u32				SrcLen)
 {
-	void * ringBuffer=GetRingBuffer(RingInfo);
-	u32 ringBufferSize=GetRingBufferSize(RingInfo);
+	void *ringBuffer = GetRingBuffer(RingInfo);
+	u32 ringBufferSize = GetRingBufferSize(RingInfo);
 	u32 fragLen;
 
-	if (SrcLen > ringBufferSize - StartWriteOffset) /* wrap-around detected! */
-	{
+	/* wrap-around detected! */
+	if (SrcLen > ringBufferSize - StartWriteOffset) {
 		DPRINT_DBG(VMBUS, "wrap-around detected!");
 
 		fragLen = ringBufferSize - StartWriteOffset;
 		memcpy(ringBuffer + StartWriteOffset, Src, fragLen);
 		memcpy(ringBuffer, Src + fragLen, SrcLen - fragLen);
-	}
-	else
-	{
+	} else
 		memcpy(ringBuffer + StartWriteOffset, Src, SrcLen);
-	}
 
 	StartWriteOffset += SrcLen;
 	StartWriteOffset %= ringBufferSize;
@@ -572,29 +586,28 @@ Description:
 --*/
 static u32
 CopyFromRingBuffer(
-	RING_BUFFER_INFO	*RingInfo,
-	void *				Dest,
+	struct hv_ring_buffer_info	*RingInfo,
+	void				*Dest,
 	u32				DestLen,
 	u32				StartReadOffset)
 {
-	void * ringBuffer=GetRingBuffer(RingInfo);
-	u32 ringBufferSize=GetRingBufferSize(RingInfo);
+	void *ringBuffer = GetRingBuffer(RingInfo);
+	u32 ringBufferSize = GetRingBufferSize(RingInfo);
 
 	u32 fragLen;
 
-	if (DestLen > ringBufferSize - StartReadOffset) /* wrap-around detected at the src */
-	{
+	/* wrap-around detected at the src */
+	if (DestLen > ringBufferSize - StartReadOffset) {
 		DPRINT_DBG(VMBUS, "src wrap-around detected!");
 
 		fragLen = ringBufferSize - StartReadOffset;
 
 		memcpy(Dest, ringBuffer + StartReadOffset, fragLen);
 		memcpy(Dest + fragLen, ringBuffer, DestLen - fragLen);
-	}
-	else
-	{
+	} else
+
 		memcpy(Dest, ringBuffer + StartReadOffset, DestLen);
-	}
+
 
 	StartReadOffset += DestLen;
 	StartReadOffset %= ringBufferSize;
--- a/drivers/staging/hv/RingBuffer.h
+++ b/drivers/staging/hv/RingBuffer.h
@@ -27,7 +27,7 @@
 
 #include <linux/scatterlist.h>
 
-typedef struct _RING_BUFFER {
+struct hv_ring_buffer {
 	/* Offset in bytes from the start of ring data below */
 	volatile u32 WriteIndex;
 
@@ -51,51 +51,52 @@ typedef struct _RING_BUFFER {
 	 * !!! DO NOT place any fields below this !!!
 	 */
 	u8 Buffer[0];
-} __attribute__((packed)) RING_BUFFER;
+} __attribute__((packed));
 
-typedef struct _RING_BUFFER_INFO {
-	RING_BUFFER *RingBuffer;
+struct hv_ring_buffer_info {
+	struct hv_ring_buffer *RingBuffer;
 	u32 RingSize;			/* Include the shared header */
 	spinlock_t ring_lock;
 
 	u32 RingDataSize;		/* < ringSize */
 	u32 RingDataStartOffset;
+};
 
-} RING_BUFFER_INFO;
-
-typedef struct _RING_BUFFER_DEBUG_INFO {
+struct hv_ring_buffer_debug_info {
 	u32 CurrentInterruptMask;
 	u32 CurrentReadIndex;
 	u32 CurrentWriteIndex;
 	u32 BytesAvailToRead;
 	u32 BytesAvailToWrite;
-} RING_BUFFER_DEBUG_INFO;
+};
 
 
 
 /* Interface */
 
 
-int RingBufferInit(RING_BUFFER_INFO *RingInfo, void *Buffer, u32 BufferLen);
+int RingBufferInit(struct hv_ring_buffer_info *RingInfo, void *Buffer,
+		   u32 BufferLen);
 
-void RingBufferCleanup(RING_BUFFER_INFO *RingInfo);
+void RingBufferCleanup(struct hv_ring_buffer_info *RingInfo);
 
-int RingBufferWrite(RING_BUFFER_INFO *RingInfo,
+int RingBufferWrite(struct hv_ring_buffer_info *RingInfo,
 		    struct scatterlist *sglist,
 		    u32 sgcount);
 
-int RingBufferPeek(RING_BUFFER_INFO *RingInfo, void *Buffer, u32 BufferLen);
+int RingBufferPeek(struct hv_ring_buffer_info *RingInfo, void *Buffer,
+		   u32 BufferLen);
 
-int RingBufferRead(RING_BUFFER_INFO *RingInfo,
+int RingBufferRead(struct hv_ring_buffer_info *RingInfo,
 		   void *Buffer,
 		   u32 BufferLen,
 		   u32 Offset);
 
-u32 GetRingBufferInterruptMask(RING_BUFFER_INFO *RingInfo);
+u32 GetRingBufferInterruptMask(struct hv_ring_buffer_info *RingInfo);
 
-void DumpRingInfo(RING_BUFFER_INFO *RingInfo, char *Prefix);
+void DumpRingInfo(struct hv_ring_buffer_info *RingInfo, char *Prefix);
 
-void RingBufferGetDebugInfo(RING_BUFFER_INFO *RingInfo,
-			    RING_BUFFER_DEBUG_INFO *DebugInfo);
+void RingBufferGetDebugInfo(struct hv_ring_buffer_info *RingInfo,
+			    struct hv_ring_buffer_debug_info *debug_info);
 
 #endif /* _RING_BUFFER_H_ */
--- a/drivers/staging/hv/RndisFilter.c
+++ b/drivers/staging/hv/RndisFilter.c
@@ -20,7 +20,10 @@
  */
 #include <linux/kernel.h>
 #include <linux/highmem.h>
+#include <linux/slab.h>
 #include <linux/io.h>
+#include <linux/if_ether.h>
+
 #include "osd.h"
 #include "logging.h"
 #include "NetVscApi.h"
@@ -49,7 +52,7 @@ struct rndis_device {
 	spinlock_t request_lock;
 	struct list_head RequestList;
 
-	unsigned char HwMacAddr[HW_MACADDR_LEN];
+	unsigned char HwMacAddr[ETH_ALEN];
 };
 
 struct rndis_request {
@@ -85,10 +88,6 @@ static int RndisFilterOnDeviceRemove(str
 
 static void RndisFilterOnCleanup(struct hv_driver *Driver);
 
-static int RndisFilterOnOpen(struct hv_device *Device);
-
-static int RndisFilterOnClose(struct hv_device *Device);
-
 static int RndisFilterOnSend(struct hv_device *Device,
 			     struct hv_netvsc_packet *Packet);
 
@@ -245,8 +244,6 @@ static int RndisFilterSendRequest(struct
 	int ret;
 	struct hv_netvsc_packet *packet;
 
-	DPRINT_ENTER(NETVSC);
-
 	/* Setup the packet to send it */
 	packet = &Request->Packet;
 
@@ -266,7 +263,6 @@ static int RndisFilterSendRequest(struct
 	packet->Completion.Send.SendCompletionTid = (unsigned long)Device;
 
 	ret = gRndisFilter.InnerDriver.OnSend(Device->NetDevice->Device, packet);
-	DPRINT_EXIT(NETVSC);
 	return ret;
 }
 
@@ -277,8 +273,6 @@ static void RndisFilterReceiveResponse(s
 	bool found = false;
 	unsigned long flags;
 
-	DPRINT_ENTER(NETVSC);
-
 	spin_lock_irqsave(&Device->request_lock, flags);
 	list_for_each_entry(request, &Device->RequestList, ListEntry) {
 		/*
@@ -326,8 +320,6 @@ static void RndisFilterReceiveResponse(s
 			   Response->Message.InitializeComplete.RequestId,
 			   Response->NdisMessageType);
 	}
-
-	DPRINT_EXIT(NETVSC);
 }
 
 static void RndisFilterReceiveIndicateStatus(struct rndis_device *Device,
@@ -354,11 +346,9 @@ static void RndisFilterReceiveData(struc
 	struct rndis_packet *rndisPacket;
 	u32 dataOffset;
 
-	DPRINT_ENTER(NETVSC);
-
 	/* empty ethernet frame ?? */
-	ASSERT(Packet->PageBuffers[0].Length >
-		RNDIS_MESSAGE_SIZE(struct rndis_packet));
+	/* ASSERT(Packet->PageBuffers[0].Length > */
+	/* 	RNDIS_MESSAGE_SIZE(struct rndis_packet)); */
 
 	rndisPacket = &Message->Message.Packet;
 
@@ -378,8 +368,6 @@ static void RndisFilterReceiveData(struc
 
 	gRndisFilter.InnerDriver.OnReceiveCallback(Device->NetDevice->Device,
 						   Packet);
-
-	DPRINT_EXIT(NETVSC);
 }
 
 static int RndisFilterOnReceive(struct hv_device *Device,
@@ -390,14 +378,13 @@ static int RndisFilterOnReceive(struct h
 	struct rndis_message rndisMessage;
 	struct rndis_message *rndisHeader;
 
-	DPRINT_ENTER(NETVSC);
+	if (!netDevice)
+		return -EINVAL;
 
-	ASSERT(netDevice);
 	/* Make sure the rndis device state is initialized */
 	if (!netDevice->Extension) {
 		DPRINT_ERR(NETVSC, "got rndis message but no rndis device..."
 			  "dropping this message!");
-		DPRINT_EXIT(NETVSC);
 		return -1;
 	}
 
@@ -405,7 +392,6 @@ static int RndisFilterOnReceive(struct h
 	if (rndisDevice->State == RNDIS_DEV_UNINITIALIZED) {
 		DPRINT_ERR(NETVSC, "got rndis message but rndis device "
 			   "uninitialized...dropping this message!");
-		DPRINT_EXIT(NETVSC);
 		return -1;
 	}
 
@@ -430,7 +416,6 @@ static int RndisFilterOnReceive(struct h
 			   "bytes got %u)...dropping this message!",
 			   rndisHeader->MessageLength,
 			   Packet->TotalDataBufferLength);
-		DPRINT_EXIT(NETVSC);
 		return -1;
 	}
 #endif
@@ -478,7 +463,6 @@ static int RndisFilterOnReceive(struct h
 		break;
 	}
 
-	DPRINT_EXIT(NETVSC);
 	return 0;
 }
 
@@ -491,9 +475,8 @@ static int RndisFilterQueryDevice(struct
 	struct rndis_query_complete *queryComplete;
 	int ret = 0;
 
-	DPRINT_ENTER(NETVSC);
-
-	ASSERT(Result);
+	if (!Result)
+		return -EINVAL;
 
 	*ResultSize = 0;
 	request = GetRndisRequest(Device, REMOTE_NDIS_QUERY_MSG,
@@ -534,14 +517,13 @@ static int RndisFilterQueryDevice(struct
 Cleanup:
 	if (request)
 		PutRndisRequest(Device, request);
-	DPRINT_EXIT(NETVSC);
 
 	return ret;
 }
 
 static int RndisFilterQueryDeviceMac(struct rndis_device *Device)
 {
-	u32 size = HW_MACADDR_LEN;
+	u32 size = ETH_ALEN;
 
 	return RndisFilterQueryDevice(Device,
 				      RNDIS_OID_802_3_PERMANENT_ADDRESS,
@@ -566,10 +548,8 @@ static int RndisFilterSetPacketFilter(st
 	u32 status;
 	int ret;
 
-	DPRINT_ENTER(NETVSC);
-
-	ASSERT(RNDIS_MESSAGE_SIZE(struct rndis_set_request) + sizeof(u32) <=
-		sizeof(struct rndis_message));
+	/* ASSERT(RNDIS_MESSAGE_SIZE(struct rndis_set_request) + sizeof(u32) <= */
+	/* 	sizeof(struct rndis_message)); */
 
 	request = GetRndisRequest(Device, REMOTE_NDIS_SET_MSG,
 			RNDIS_MESSAGE_SIZE(struct rndis_set_request) +
@@ -612,20 +592,15 @@ Cleanup:
 	if (request)
 		PutRndisRequest(Device, request);
 Exit:
-	DPRINT_EXIT(NETVSC);
-
 	return ret;
 }
 
 int RndisFilterInit(struct netvsc_driver *Driver)
 {
-	DPRINT_ENTER(NETVSC);
-
 	DPRINT_DBG(NETVSC, "sizeof(struct rndis_filter_packet) == %zd",
 		   sizeof(struct rndis_filter_packet));
 
 	Driver->RequestExtSize = sizeof(struct rndis_filter_packet);
-	Driver->AdditionalRequestPageBufferCount = 1; /* For rndis header */
 
 	/* Driver->Context = rndisDriver; */
 
@@ -642,8 +617,8 @@ int RndisFilterInit(struct netvsc_driver
 					Driver->Base.OnDeviceRemove;
 	gRndisFilter.InnerDriver.Base.OnCleanup = Driver->Base.OnCleanup;
 
-	ASSERT(Driver->OnSend);
-	ASSERT(Driver->OnReceiveCallback);
+	/* ASSERT(Driver->OnSend); */
+	/* ASSERT(Driver->OnReceiveCallback); */
 	gRndisFilter.InnerDriver.OnSend = Driver->OnSend;
 	gRndisFilter.InnerDriver.OnReceiveCallback = Driver->OnReceiveCallback;
 	gRndisFilter.InnerDriver.OnLinkStatusChanged =
@@ -654,13 +629,9 @@ int RndisFilterInit(struct netvsc_driver
 	Driver->Base.OnDeviceRemove = RndisFilterOnDeviceRemove;
 	Driver->Base.OnCleanup = RndisFilterOnCleanup;
 	Driver->OnSend = RndisFilterOnSend;
-	Driver->OnOpen = RndisFilterOnOpen;
-	Driver->OnClose = RndisFilterOnClose;
 	/* Driver->QueryLinkStatus = RndisFilterQueryDeviceLinkStatus; */
 	Driver->OnReceiveCallback = RndisFilterOnReceive;
 
-	DPRINT_EXIT(NETVSC);
-
 	return 0;
 }
 
@@ -672,8 +643,6 @@ static int RndisFilterInitDevice(struct
 	u32 status;
 	int ret;
 
-	DPRINT_ENTER(NETVSC);
-
 	request = GetRndisRequest(Device, REMOTE_NDIS_INITIALIZE_MSG,
 			RNDIS_MESSAGE_SIZE(struct rndis_initialize_request));
 	if (!request) {
@@ -711,7 +680,6 @@ static int RndisFilterInitDevice(struct
 Cleanup:
 	if (request)
 		PutRndisRequest(Device, request);
-	DPRINT_EXIT(NETVSC);
 
 	return ret;
 }
@@ -721,8 +689,6 @@ static void RndisFilterHaltDevice(struct
 	struct rndis_request *request;
 	struct rndis_halt_request *halt;
 
-	DPRINT_ENTER(NETVSC);
-
 	/* Attempt to do a rndis device halt */
 	request = GetRndisRequest(Device, REMOTE_NDIS_HALT_MSG,
 				RNDIS_MESSAGE_SIZE(struct rndis_halt_request));
@@ -741,7 +707,6 @@ static void RndisFilterHaltDevice(struct
 Cleanup:
 	if (request)
 		PutRndisRequest(Device, request);
-	DPRINT_EXIT(NETVSC);
 	return;
 }
 
@@ -749,8 +714,6 @@ static int RndisFilterOpenDevice(struct
 {
 	int ret;
 
-	DPRINT_ENTER(NETVSC);
-
 	if (Device->State != RNDIS_DEV_INITIALIZED)
 		return 0;
 
@@ -761,7 +724,6 @@ static int RndisFilterOpenDevice(struct
 	if (ret == 0)
 		Device->State = RNDIS_DEV_DATAINITIALIZED;
 
-	DPRINT_EXIT(NETVSC);
 	return ret;
 }
 
@@ -769,8 +731,6 @@ static int RndisFilterCloseDevice(struct
 {
 	int ret;
 
-	DPRINT_ENTER(NETVSC);
-
 	if (Device->State != RNDIS_DEV_DATAINITIALIZED)
 		return 0;
 
@@ -778,8 +738,6 @@ static int RndisFilterCloseDevice(struct
 	if (ret == 0)
 		Device->State = RNDIS_DEV_INITIALIZED;
 
-	DPRINT_EXIT(NETVSC);
-
 	return ret;
 }
 
@@ -791,13 +749,9 @@ static int RndisFilterOnDeviceAdd(struct
 	struct rndis_device *rndisDevice;
 	struct netvsc_device_info *deviceInfo = AdditionalInfo;
 
-	DPRINT_ENTER(NETVSC);
-
 	rndisDevice = GetRndisDevice();
-	if (!rndisDevice) {
-		DPRINT_EXIT(NETVSC);
+	if (!rndisDevice)
 		return -1;
-	}
 
 	DPRINT_DBG(NETVSC, "rndis device object allocated - %p", rndisDevice);
 
@@ -809,15 +763,14 @@ static int RndisFilterOnDeviceAdd(struct
 	ret = gRndisFilter.InnerDriver.Base.OnDeviceAdd(Device, AdditionalInfo);
 	if (ret != 0) {
 		kfree(rndisDevice);
-		DPRINT_EXIT(NETVSC);
 		return ret;
 	}
 
 
 	/* Initialize the rndis device */
 	netDevice = Device->Extension;
-	ASSERT(netDevice);
-	ASSERT(netDevice->Device);
+	/* ASSERT(netDevice); */
+	/* ASSERT(netDevice->Device); */
 
 	netDevice->Extension = rndisDevice;
 	rndisDevice->NetDevice = netDevice;
@@ -839,16 +792,10 @@ static int RndisFilterOnDeviceAdd(struct
 		 */
 	}
 
-	DPRINT_INFO(NETVSC, "Device 0x%p mac addr %02x%02x%02x%02x%02x%02x",
-		    rndisDevice,
-		    rndisDevice->HwMacAddr[0],
-		    rndisDevice->HwMacAddr[1],
-		    rndisDevice->HwMacAddr[2],
-		    rndisDevice->HwMacAddr[3],
-		    rndisDevice->HwMacAddr[4],
-		    rndisDevice->HwMacAddr[5]);
+	DPRINT_INFO(NETVSC, "Device 0x%p mac addr %pM",
+		    rndisDevice, rndisDevice->HwMacAddr);
 
-	memcpy(deviceInfo->MacAddr, rndisDevice->HwMacAddr, HW_MACADDR_LEN);
+	memcpy(deviceInfo->MacAddr, rndisDevice->HwMacAddr, ETH_ALEN);
 
 	RndisFilterQueryDeviceLinkStatus(rndisDevice);
 
@@ -856,8 +803,6 @@ static int RndisFilterOnDeviceAdd(struct
 	DPRINT_INFO(NETVSC, "Device 0x%p link state %s", rndisDevice,
 		    ((deviceInfo->LinkState) ? ("down") : ("up")));
 
-	DPRINT_EXIT(NETVSC);
-
 	return ret;
 }
 
@@ -866,8 +811,6 @@ static int RndisFilterOnDeviceRemove(str
 	struct netvsc_device *netDevice = Device->Extension;
 	struct rndis_device *rndisDevice = netDevice->Extension;
 
-	DPRINT_ENTER(NETVSC);
-
 	/* Halt and release the rndis device */
 	RndisFilterHaltDevice(rndisDevice);
 
@@ -877,46 +820,31 @@ static int RndisFilterOnDeviceRemove(str
 	/* Pass control to inner driver to remove the device */
 	gRndisFilter.InnerDriver.Base.OnDeviceRemove(Device);
 
-	DPRINT_EXIT(NETVSC);
-
 	return 0;
 }
 
 static void RndisFilterOnCleanup(struct hv_driver *Driver)
 {
-	DPRINT_ENTER(NETVSC);
-
-	DPRINT_EXIT(NETVSC);
 }
 
-static int RndisFilterOnOpen(struct hv_device *Device)
+int RndisFilterOnOpen(struct hv_device *Device)
 {
-	int ret;
 	struct netvsc_device *netDevice = Device->Extension;
 
-	DPRINT_ENTER(NETVSC);
-
-	ASSERT(netDevice);
-	ret = RndisFilterOpenDevice(netDevice->Extension);
+	if (!netDevice)
+		return -EINVAL;
 
-	DPRINT_EXIT(NETVSC);
-
-	return ret;
+	return RndisFilterOpenDevice(netDevice->Extension);
 }
 
-static int RndisFilterOnClose(struct hv_device *Device)
+int RndisFilterOnClose(struct hv_device *Device)
 {
-	int ret;
 	struct netvsc_device *netDevice = Device->Extension;
 
-	DPRINT_ENTER(NETVSC);
-
-	ASSERT(netDevice);
-	ret = RndisFilterCloseDevice(netDevice->Extension);
-
-	DPRINT_EXIT(NETVSC);
+	if (!netDevice)
+		return -EINVAL;
 
-	return ret;
+	return RndisFilterCloseDevice(netDevice->Extension);
 }
 
 static int RndisFilterOnSend(struct hv_device *Device,
@@ -928,11 +856,9 @@ static int RndisFilterOnSend(struct hv_d
 	struct rndis_packet *rndisPacket;
 	u32 rndisMessageSize;
 
-	DPRINT_ENTER(NETVSC);
-
 	/* Add the rndis header */
 	filterPacket = (struct rndis_filter_packet *)Packet->Extension;
-	ASSERT(filterPacket);
+	/* ASSERT(filterPacket); */
 
 	memset(filterPacket, 0, sizeof(struct rndis_filter_packet));
 
@@ -974,8 +900,6 @@ static int RndisFilterOnSend(struct hv_d
 				filterPacket->CompletionContext;
 	}
 
-	DPRINT_EXIT(NETVSC);
-
 	return ret;
 }
 
@@ -983,19 +907,12 @@ static void RndisFilterOnSendCompletion(
 {
 	struct rndis_filter_packet *filterPacket = Context;
 
-	DPRINT_ENTER(NETVSC);
-
 	/* Pass it back to the original handler */
 	filterPacket->OnCompletion(filterPacket->CompletionContext);
-
-	DPRINT_EXIT(NETVSC);
 }
 
 
 static void RndisFilterOnSendRequestCompletion(void *Context)
 {
-	DPRINT_ENTER(NETVSC);
-
 	/* Noop */
-	DPRINT_EXIT(NETVSC);
 }
--- a/drivers/staging/hv/StorVsc.c
+++ b/drivers/staging/hv/StorVsc.c
@@ -20,6 +20,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/string.h>
+#include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/delay.h>
 #include "osd.h"
@@ -48,6 +49,8 @@ struct storvsc_device {
 	/* 0 indicates the device is being destroyed */
 	atomic_t RefCount;
 
+	int reset;
+	spinlock_t lock;
 	atomic_t NumOutstandingRequests;
 
 	/*
@@ -92,6 +95,9 @@ static inline struct storvsc_device *All
 	atomic_cmpxchg(&storDevice->RefCount, 0, 2);
 
 	storDevice->Device = Device;
+	storDevice->reset  = 0;
+	spin_lock_init(&storDevice->lock);
+
 	Device->Extension = storDevice;
 
 	return storDevice;
@@ -99,7 +105,8 @@ static inline struct storvsc_device *All
 
 static inline void FreeStorDevice(struct storvsc_device *Device)
 {
-	ASSERT(atomic_read(&Device->RefCount) == 0);
+	/* ASSERT(atomic_read(&Device->RefCount) == 0); */
+	/*kfree(Device->lock);*/
 	kfree(Device);
 }
 
@@ -107,13 +114,24 @@ static inline void FreeStorDevice(struct
 static inline struct storvsc_device *GetStorDevice(struct hv_device *Device)
 {
 	struct storvsc_device *storDevice;
+	unsigned long flags;
 
 	storDevice = (struct storvsc_device *)Device->Extension;
+
+	spin_lock_irqsave(&storDevice->lock, flags);
+
+	if (storDevice->reset == 1) {
+		spin_unlock_irqrestore(&storDevice->lock, flags);
+		return NULL;
+	}
+
 	if (storDevice && atomic_read(&storDevice->RefCount) > 1)
 		atomic_inc(&storDevice->RefCount);
 	else
 		storDevice = NULL;
 
+	spin_unlock_irqrestore(&storDevice->lock, flags);
+
 	return storDevice;
 }
 
@@ -121,13 +139,19 @@ static inline struct storvsc_device *Get
 static inline struct storvsc_device *MustGetStorDevice(struct hv_device *Device)
 {
 	struct storvsc_device *storDevice;
+	unsigned long flags;
 
 	storDevice = (struct storvsc_device *)Device->Extension;
+
+	spin_lock_irqsave(&storDevice->lock, flags);
+
 	if (storDevice && atomic_read(&storDevice->RefCount))
 		atomic_inc(&storDevice->RefCount);
 	else
 		storDevice = NULL;
 
+	spin_unlock_irqrestore(&storDevice->lock, flags);
+
 	return storDevice;
 }
 
@@ -136,10 +160,10 @@ static inline void PutStorDevice(struct
 	struct storvsc_device *storDevice;
 
 	storDevice = (struct storvsc_device *)Device->Extension;
-	ASSERT(storDevice);
+	/* ASSERT(storDevice); */
 
 	atomic_dec(&storDevice->RefCount);
-	ASSERT(atomic_read(&storDevice->RefCount));
+	/* ASSERT(atomic_read(&storDevice->RefCount)); */
 }
 
 /* Drop ref count to 1 to effectively disable GetStorDevice() */
@@ -148,7 +172,7 @@ static inline struct storvsc_device *Rel
 	struct storvsc_device *storDevice;
 
 	storDevice = (struct storvsc_device *)Device->Extension;
-	ASSERT(storDevice);
+	/* ASSERT(storDevice); */
 
 	/* Busy wait until the ref drop to 2, then set it to 1 */
 	while (atomic_cmpxchg(&storDevice->RefCount, 2, 1) != 2)
@@ -164,7 +188,7 @@ static inline struct storvsc_device *Fin
 	struct storvsc_device *storDevice;
 
 	storDevice = (struct storvsc_device *)Device->Extension;
-	ASSERT(storDevice);
+	/* ASSERT(storDevice); */
 
 	/* Busy wait until the ref drop to 1, then set it to 0 */
 	while (atomic_cmpxchg(&storDevice->RefCount, 1, 0) != 1)
@@ -185,7 +209,6 @@ static int StorVscChannelInit(struct hv_
 	if (!storDevice) {
 		DPRINT_ERR(STORVSC, "unable to get stor device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(STORVSC);
 		return -1;
 	}
 
@@ -198,6 +221,10 @@ static int StorVscChannelInit(struct hv_
 	 */
 	memset(request, 0, sizeof(struct storvsc_request_extension));
 	request->WaitEvent = osd_WaitEventCreate();
+	if (!request->WaitEvent) {
+		ret = -ENOMEM;
+		goto nomem;
+	}
 
 	vstorPacket->Operation = VStorOperationBeginInitialization;
 	vstorPacket->Flags = REQUEST_COMPLETION_FLAG;
@@ -337,10 +364,8 @@ static int StorVscChannelInit(struct hv_
 Cleanup:
 	kfree(request->WaitEvent);
 	request->WaitEvent = NULL;
-
+nomem:
 	PutStorDevice(Device);
-
-	DPRINT_EXIT(STORVSC);
 	return ret;
 }
 
@@ -351,13 +376,10 @@ static void StorVscOnIOCompletion(struct
 	struct hv_storvsc_request *request;
 	struct storvsc_device *storDevice;
 
-	DPRINT_ENTER(STORVSC);
-
 	storDevice = MustGetStorDevice(Device);
 	if (!storDevice) {
 		DPRINT_ERR(STORVSC, "unable to get stor device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(STORVSC);
 		return;
 	}
 
@@ -365,12 +387,12 @@ static void StorVscOnIOCompletion(struct
 		   "completed bytes xfer %u", RequestExt,
 		   VStorPacket->VmSrb.DataTransferLength);
 
-	ASSERT(RequestExt != NULL);
-	ASSERT(RequestExt->Request != NULL);
+	/* ASSERT(RequestExt != NULL); */
+	/* ASSERT(RequestExt->Request != NULL); */
 
 	request = RequestExt->Request;
 
-	ASSERT(request->OnIOCompletion != NULL);
+	/* ASSERT(request->OnIOCompletion != NULL); */
 
 	/* Copy over the status...etc */
 	request->Status = VStorPacket->VmSrb.ScsiStatus;
@@ -390,8 +412,8 @@ static void StorVscOnIOCompletion(struct
 				    "valid - len %d\n", RequestExt,
 				    VStorPacket->VmSrb.SenseInfoLength);
 
-			ASSERT(VStorPacket->VmSrb.SenseInfoLength <=
-				request->SenseBufferSize);
+			/* ASSERT(VStorPacket->VmSrb.SenseInfoLength <= */
+			/* 	request->SenseBufferSize); */
 			memcpy(request->SenseBuffer,
 			       VStorPacket->VmSrb.SenseData,
 			       VStorPacket->VmSrb.SenseInfoLength);
@@ -409,8 +431,6 @@ static void StorVscOnIOCompletion(struct
 	atomic_dec(&storDevice->NumOutstandingRequests);
 
 	PutStorDevice(Device);
-
-	DPRINT_EXIT(STORVSC);
 }
 
 static void StorVscOnReceive(struct hv_device *Device,
@@ -444,15 +464,12 @@ static void StorVscOnChannelCallback(voi
 	struct storvsc_request_extension *request;
 	int ret;
 
-	DPRINT_ENTER(STORVSC);
-
-	ASSERT(device);
+	/* ASSERT(device); */
 
 	storDevice = MustGetStorDevice(device);
 	if (!storDevice) {
 		DPRINT_ERR(STORVSC, "unable to get stor device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(STORVSC);
 		return;
 	}
 
@@ -469,7 +486,7 @@ static void StorVscOnChannelCallback(voi
 
 			request = (struct storvsc_request_extension *)
 					(unsigned long)requestId;
-			ASSERT(request);
+			/* ASSERT(request);c */
 
 			/* if (vstorPacket.Flags & SYNTHETIC_FLAG) */
 			if ((request == &storDevice->InitRequest) ||
@@ -496,8 +513,6 @@ static void StorVscOnChannelCallback(voi
 	} while (1);
 
 	PutStorDevice(device);
-
-	DPRINT_EXIT(STORVSC);
 	return;
 }
 
@@ -532,7 +547,7 @@ static int StorVscConnectToVsp(struct hv
 	return ret;
 }
 
-/**
+/*
  * StorVscOnDeviceAdd - Callback when the device belonging to this driver is added
  */
 static int StorVscOnDeviceAdd(struct hv_device *Device, void *AdditionalInfo)
@@ -542,8 +557,6 @@ static int StorVscOnDeviceAdd(struct hv_
 	struct storvsc_device_info *deviceInfo;
 	int ret = 0;
 
-	DPRINT_ENTER(STORVSC);
-
 	deviceInfo = (struct storvsc_device_info *)AdditionalInfo;
 	storDevice = AllocStorDevice(Device);
 	if (!storDevice) {
@@ -553,7 +566,7 @@ static int StorVscOnDeviceAdd(struct hv_
 
 	/* Save the channel properties to our storvsc channel */
 	/* props = (struct vmstorage_channel_properties *)
-	 * 		channel->offerMsg.Offer.u.Standard.UserDefined; */
+	 *		channel->offerMsg.Offer.u.Standard.UserDefined; */
 
 	/* FIXME: */
 	/*
@@ -579,20 +592,16 @@ static int StorVscOnDeviceAdd(struct hv_
 		   storDevice->TargetId);
 
 Cleanup:
-	DPRINT_EXIT(STORVSC);
-
 	return ret;
 }
 
-/**
+/*
  * StorVscOnDeviceRemove - Callback when the our device is being removed
  */
 static int StorVscOnDeviceRemove(struct hv_device *Device)
 {
 	struct storvsc_device *storDevice;
 
-	DPRINT_ENTER(STORVSC);
-
 	DPRINT_INFO(STORVSC, "disabling storage device (%p)...",
 		    Device->Extension);
 
@@ -620,34 +629,44 @@ static int StorVscOnDeviceRemove(struct
 	Device->Driver->VmbusChannelInterface.Close(Device);
 
 	FreeStorDevice(storDevice);
-
-	DPRINT_EXIT(STORVSC);
 	return 0;
 }
 
-static int StorVscOnHostReset(struct hv_device *Device)
+int StorVscOnHostReset(struct hv_device *Device)
 {
 	struct storvsc_device *storDevice;
 	struct storvsc_request_extension *request;
 	struct vstor_packet *vstorPacket;
+	unsigned long flags;
 	int ret;
 
-	DPRINT_ENTER(STORVSC);
-
 	DPRINT_INFO(STORVSC, "resetting host adapter...");
 
 	storDevice = GetStorDevice(Device);
 	if (!storDevice) {
 		DPRINT_ERR(STORVSC, "unable to get stor device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(STORVSC);
 		return -1;
 	}
 
+	spin_lock_irqsave(&storDevice->lock, flags);
+	storDevice->reset = 1;
+	spin_unlock_irqrestore(&storDevice->lock, flags);
+
+	/*
+	 * Wait for traffic in transit to complete
+	 */
+	while (atomic_read(&storDevice->NumOutstandingRequests))
+		udelay(1000);
+
 	request = &storDevice->ResetRequest;
 	vstorPacket = &request->VStorPacket;
 
 	request->WaitEvent = osd_WaitEventCreate();
+	if (!request->WaitEvent) {
+		ret = -ENOMEM;
+		goto Cleanup;
+	}
 
 	vstorPacket->Operation = VStorOperationResetBus;
 	vstorPacket->Flags = REQUEST_COMPLETION_FLAG;
@@ -678,11 +697,10 @@ static int StorVscOnHostReset(struct hv_
 
 Cleanup:
 	PutStorDevice(Device);
-	DPRINT_EXIT(STORVSC);
 	return ret;
 }
 
-/**
+/*
  * StorVscOnIORequest - Callback to initiate an I/O request
  */
 static int StorVscOnIORequest(struct hv_device *Device,
@@ -693,8 +711,6 @@ static int StorVscOnIORequest(struct hv_
 	struct vstor_packet *vstorPacket;
 	int ret = 0;
 
-	DPRINT_ENTER(STORVSC);
-
 	requestExtension =
 		(struct storvsc_request_extension *)Request->Extension;
 	vstorPacket = &requestExtension->VStorPacket;
@@ -711,12 +727,11 @@ static int StorVscOnIORequest(struct hv_
 	if (!storDevice) {
 		DPRINT_ERR(STORVSC, "unable to get stor device..."
 			   "device being destroyed?");
-		DPRINT_EXIT(STORVSC);
 		return -2;
 	}
 
 	/* print_hex_dump_bytes("", DUMP_PREFIX_NONE, Request->Cdb,
-	 * 			Request->CdbLen); */
+	 *			Request->CdbLen); */
 
 	requestExtension->Request = Request;
 	requestExtension->Device  = Device;
@@ -777,29 +792,23 @@ static int StorVscOnIORequest(struct hv_
 	atomic_inc(&storDevice->NumOutstandingRequests);
 
 	PutStorDevice(Device);
-
-	DPRINT_EXIT(STORVSC);
 	return ret;
 }
 
-/**
+/*
  * StorVscOnCleanup - Perform any cleanup when the driver is removed
  */
 static void StorVscOnCleanup(struct hv_driver *Driver)
 {
-	DPRINT_ENTER(STORVSC);
-	DPRINT_EXIT(STORVSC);
 }
 
-/**
+/*
  * StorVscInitialize - Main entry point
  */
 int StorVscInitialize(struct hv_driver *Driver)
 {
 	struct storvsc_driver_object *storDriver;
 
-	DPRINT_ENTER(STORVSC);
-
 	storDriver = (struct storvsc_driver_object *)Driver;
 
 	DPRINT_DBG(STORVSC, "sizeof(STORVSC_REQUEST)=%zd "
@@ -812,7 +821,7 @@ int StorVscInitialize(struct hv_driver *
 		   sizeof(struct vmscsi_request));
 
 	/* Make sure we are at least 2 pages since 1 page is used for control */
-	ASSERT(storDriver->RingBufferSize >= (PAGE_SIZE << 1));
+	/* ASSERT(storDriver->RingBufferSize >= (PAGE_SIZE << 1)); */
 
 	Driver->name = gDriverName;
 	memcpy(&Driver->deviceType, &gStorVscDeviceType,
@@ -842,9 +851,6 @@ int StorVscInitialize(struct hv_driver *
 	storDriver->Base.OnCleanup	= StorVscOnCleanup;
 
 	storDriver->OnIORequest		= StorVscOnIORequest;
-	storDriver->OnHostReset		= StorVscOnHostReset;
-
-	DPRINT_EXIT(STORVSC);
 
 	return 0;
 }
--- a/drivers/staging/hv/StorVscApi.h
+++ b/drivers/staging/hv/StorVscApi.h
@@ -91,13 +91,9 @@ struct storvsc_driver_object {
 	/* Maximum # of requests in flight per channel/device */
 	u32 MaxOutstandingRequestsPerChannel;
 
-	/* Set by the caller to allow us to re-enumerate the bus on the host */
-	void (*OnHostRescan)(struct hv_device *Device);
-
 	/* Specific to this driver */
 	int (*OnIORequest)(struct hv_device *Device,
 			   struct hv_storvsc_request *Request);
-	int (*OnHostReset)(struct hv_device *Device);
 };
 
 struct storvsc_device_info {
@@ -108,6 +104,7 @@ struct storvsc_device_info {
 
 /* Interface */
 int StorVscInitialize(struct hv_driver *driver);
+int StorVscOnHostReset(struct hv_device *Device);
 int BlkVscInitialize(struct hv_driver *driver);
 
 #endif /* _STORVSC_API_H_ */
--- a/drivers/staging/hv/VersionInfo.h
+++ b/drivers/staging/hv/VersionInfo.h
@@ -24,8 +24,25 @@
 #ifndef __HV_VERSION_INFO
 #define __HV_VERSION_INFO
 
-static const char VersionDate[] = __DATE__;
-static const char VersionTime[] = __TIME__;
-static const char VersionDesc[] = "Version 2.0";
+/*
+ * We use the same version numbering for all Hyper-V modules.
+ *
+ * Definition of versioning is as follows;
+ *
+ *	Major Number	Changes for these scenarios;
+ *			1.	When a new version of Windows Hyper-V
+ *				is released.
+ *			2.	A Major change has occurred in the
+ *				Linux IC's.
+ *			(For example the merge for the first time
+ *			into the kernel) Every time the Major Number
+ *			changes, the Revision number is reset to 0.
+ *	Minor Number	Changes when new functionality is added
+ *			to the Linux IC's that is not a bug fix.
+ *
+ * 3.1 - Added completed hv_utils driver. Shutdown/Heartbeat/Timesync
+ */
+#define HV_DRV_VERSION           "3.1"
+
 
 #endif
--- a/drivers/staging/hv/Vmbus.c
+++ b/drivers/staging/hv/Vmbus.c
@@ -21,6 +21,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/slab.h>
 #include "osd.h"
 #include "logging.h"
 #include "VersionInfo.h"
@@ -51,17 +52,15 @@ static const struct hv_guid gVmbusDevice
 static struct hv_driver *gDriver; /* vmbus driver object */
 static struct hv_device *gDevice; /* vmbus root device */
 
-/**
+/*
  * VmbusGetChannelOffers - Retrieve the channel offers from the parent partition
  */
 static void VmbusGetChannelOffers(void)
 {
-	DPRINT_ENTER(VMBUS);
 	VmbusChannelRequestOffers();
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusGetChannelInterface - Get the channel interface
  */
 static void VmbusGetChannelInterface(struct vmbus_channel_interface *Interface)
@@ -69,7 +68,7 @@ static void VmbusGetChannelInterface(str
 	GetChannelInterface(Interface);
 }
 
-/**
+/*
  * VmbusGetChannelInfo - Get the device info for the specified device object
  */
 static void VmbusGetChannelInfo(struct hv_device *DeviceObject,
@@ -78,7 +77,7 @@ static void VmbusGetChannelInfo(struct h
 	GetChannelInfo(DeviceObject, DeviceInfo);
 }
 
-/**
+/*
  * VmbusCreateChildDevice - Creates the child device on the bus that represents the channel offer
  */
 struct hv_device *VmbusChildDeviceCreate(struct hv_guid *DeviceType,
@@ -91,7 +90,7 @@ struct hv_device *VmbusChildDeviceCreate
 						Context);
 }
 
-/**
+/*
  * VmbusChildDeviceAdd - Registers the child device with the vmbus
  */
 int VmbusChildDeviceAdd(struct hv_device *ChildDevice)
@@ -101,7 +100,7 @@ int VmbusChildDeviceAdd(struct hv_device
 	return vmbusDriver->OnChildDeviceAdd(gDevice, ChildDevice);
 }
 
-/**
+/*
  * VmbusChildDeviceRemove Unregisters the child device from the vmbus
  */
 void VmbusChildDeviceRemove(struct hv_device *ChildDevice)
@@ -111,7 +110,7 @@ void VmbusChildDeviceRemove(struct hv_de
 	vmbusDriver->OnChildDeviceRemove(ChildDevice);
 }
 
-/**
+/*
  * VmbusOnDeviceAdd - Callback when the root bus device is added
  */
 static int VmbusOnDeviceAdd(struct hv_device *dev, void *AdditionalInfo)
@@ -119,8 +118,6 @@ static int VmbusOnDeviceAdd(struct hv_de
 	u32 *irqvector = AdditionalInfo;
 	int ret;
 
-	DPRINT_ENTER(VMBUS);
-
 	gDevice = dev;
 
 	memcpy(&gDevice->deviceType, &gVmbusDeviceType, sizeof(struct hv_guid));
@@ -135,40 +132,33 @@ static int VmbusOnDeviceAdd(struct hv_de
 	ret = VmbusConnect();
 
 	/* VmbusSendEvent(device->localPortId+1); */
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 }
 
-/**
+/*
  * VmbusOnDeviceRemove - Callback when the root bus device is removed
  */
 static int VmbusOnDeviceRemove(struct hv_device *dev)
 {
 	int ret = 0;
 
-	DPRINT_ENTER(VMBUS);
 	VmbusChannelReleaseUnattachedChannels();
 	VmbusDisconnect();
 	on_each_cpu(HvSynicCleanup, NULL, 1);
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 }
 
-/**
+/*
  * VmbusOnCleanup - Perform any cleanup when the driver is removed
  */
 static void VmbusOnCleanup(struct hv_driver *drv)
 {
 	/* struct vmbus_driver *driver = (struct vmbus_driver *)drv; */
 
-	DPRINT_ENTER(VMBUS);
 	HvCleanup();
-	DPRINT_EXIT(VMBUS);
 }
 
-/**
+/*
  * VmbusOnMsgDPC - DPC routine to handle messages from the hypervisior
  */
 static void VmbusOnMsgDPC(struct hv_driver *drv)
@@ -184,11 +174,10 @@ static void VmbusOnMsgDPC(struct hv_driv
 			/* no msg */
 			break;
 		} else {
-			copied = kmalloc(sizeof(*copied), GFP_ATOMIC);
+			copied = kmemdup(msg, sizeof(*copied), GFP_ATOMIC);
 			if (copied == NULL)
 				continue;
 
-			memcpy(copied, msg, sizeof(*copied));
 			osd_schedule_callback(gVmbusConnection.WorkQueue,
 					      VmbusOnChannelMessage,
 					      (void *)copied);
@@ -216,7 +205,7 @@ static void VmbusOnMsgDPC(struct hv_driv
 	}
 }
 
-/**
+/*
  * VmbusOnEventDPC - DPC routine to handle events from the hypervisior
  */
 static void VmbusOnEventDPC(struct hv_driver *drv)
@@ -225,7 +214,7 @@ static void VmbusOnEventDPC(struct hv_dr
 	VmbusOnEvents();
 }
 
-/**
+/*
  * VmbusOnISR - ISR routine
  */
 static int VmbusOnISR(struct hv_driver *drv)
@@ -239,8 +228,6 @@ static int VmbusOnISR(struct hv_driver *
 	page_addr = gHvContext.synICMessagePage[cpu];
 	msg = (struct hv_message *)page_addr + VMBUS_MESSAGE_SINT;
 
-	DPRINT_ENTER(VMBUS);
-
 	/* Check if there are actual msgs to be process */
 	if (msg->Header.MessageType != HvMessageTypeNone) {
 		DPRINT_DBG(VMBUS, "received msg type %d size %d",
@@ -259,11 +246,10 @@ static int VmbusOnISR(struct hv_driver *
 		ret |= 0x2;
 	}
 
-	DPRINT_EXIT(VMBUS);
 	return ret;
 }
 
-/**
+/*
  * VmbusInitialize - Main entry point
  */
 int VmbusInitialize(struct hv_driver *drv)
@@ -271,12 +257,8 @@ int VmbusInitialize(struct hv_driver *dr
 	struct vmbus_driver *driver = (struct vmbus_driver *)drv;
 	int ret;
 
-	DPRINT_ENTER(VMBUS);
-
-	DPRINT_INFO(VMBUS, "+++++++ Build Date=%s %s +++++++",
-			VersionDate, VersionTime);
-	DPRINT_INFO(VMBUS, "+++++++ Build Description=%s +++++++",
-			VersionDesc);
+	DPRINT_INFO(VMBUS, "+++++++ HV Driver version = %s +++++++",
+		    HV_DRV_VERSION);
 	DPRINT_INFO(VMBUS, "+++++++ Vmbus supported version = %d +++++++",
 			VMBUS_REVISION_NUMBER);
 	DPRINT_INFO(VMBUS, "+++++++ Vmbus using SINT %d +++++++",
@@ -307,7 +289,5 @@ int VmbusInitialize(struct hv_driver *dr
 				ret);
 	gDriver = drv;
 
-	DPRINT_EXIT(VMBUS);
-
 	return ret;
 }
--- a/drivers/staging/hv/VmbusApi.h
+++ b/drivers/staging/hv/VmbusApi.h
@@ -84,6 +84,24 @@ struct hv_device_info {
 	struct hv_dev_port_info Outbound;
 };
 
+/**
+ * struct vmbus_channel_interface - Contains member functions for vmbus channel
+ * @Open:      Open the channel
+ * @Close:     Close the channel
+ * @SendPacket:        Send a packet over the channel
+ * @SendPacketPageBuffer:      Send a single page buffer over the channel
+ * @SendPacketMultiPageBuffer: Send a multiple page buffers
+ * @RecvPacket:        Receive packet
+ * @RecvPacketRaw:     Receive Raw packet
+ * @EstablishGpadl:    Set up GPADL for ringbuffer
+ * @TeardownGpadl:     Teardown GPADL for ringbuffer
+ * @GetInfo:   Get info about the channel
+ *
+ * This structure contains function pointer to control vmbus channel
+ * behavior. None of these functions is externally callable, but they
+ * are used for normal vmbus channel internal behavior.
+ * Only used by Hyper-V drivers.
+ */
 struct vmbus_channel_interface {
 	int (*Open)(struct hv_device *Device, u32 SendBufferSize,
 		    u32 RecvRingBufferSize, void *UserData, u32 UserDataLen,
--- a/drivers/staging/hv/blkvsc_drv.c
+++ b/drivers/staging/hv/blkvsc_drv.c
@@ -25,12 +25,14 @@
 #include <linux/major.h>
 #include <linux/delay.h>
 #include <linux/hdreg.h>
+#include <linux/slab.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_eh.h>
 #include <scsi/scsi_dbg.h>
 #include "osd.h"
 #include "logging.h"
+#include "VersionInfo.h"
 #include "vmbus.h"
 #include "StorVscApi.h"
 
@@ -92,7 +94,7 @@ struct blkvsc_request {
 /* Per device structure */
 struct block_device_context {
 	/* point back to our device context */
-	struct device_context *device_ctx;
+	struct vm_device *device_ctx;
 	struct kmem_cache *request_pool;
 	spinlock_t lock;
 	struct gendisk *gd;
@@ -147,13 +149,14 @@ static int blkvsc_do_flush(struct block_
 static int blkvsc_cancel_pending_reqs(struct block_device_context *blkdev);
 static int blkvsc_do_pending_reqs(struct block_device_context *blkdev);
 
-
 static int blkvsc_ringbuffer_size = BLKVSC_RING_BUFFER_SIZE;
+module_param(blkvsc_ringbuffer_size, int, S_IRUGO);
+MODULE_PARM_DESC(ring_size, "Ring buffer size (in bytes)");
 
 /* The one and only one */
 static struct blkvsc_driver_context g_blkvsc_drv;
 
-static struct block_device_operations block_ops = {
+static const struct block_device_operations block_ops = {
 	.owner = THIS_MODULE,
 	.open = blkvsc_open,
 	.release = blkvsc_release,
@@ -163,7 +166,7 @@ static struct block_device_operations bl
 	.ioctl  = blkvsc_ioctl,
 };
 
-/**
+/*
  * blkvsc_drv_init -  BlkVsc driver initialization.
  */
 static int blkvsc_drv_init(int (*drv_init)(struct hv_driver *drv))
@@ -172,8 +175,6 @@ static int blkvsc_drv_init(int (*drv_ini
 	struct driver_context *drv_ctx = &g_blkvsc_drv.drv_ctx;
 	int ret;
 
-	DPRINT_ENTER(BLKVSC_DRV);
-
 	vmbus_get_interface(&storvsc_drv_obj->Base.VmbusChannelInterface);
 
 	storvsc_drv_obj->RingBufferSize = blkvsc_ringbuffer_size;
@@ -192,8 +193,6 @@ static int blkvsc_drv_init(int (*drv_ini
 	/* The driver belongs to vmbus */
 	ret = vmbus_child_driver_register(drv_ctx);
 
-	DPRINT_EXIT(BLKVSC_DRV);
-
 	return ret;
 }
 
@@ -211,8 +210,6 @@ static void blkvsc_drv_exit(void)
 	struct device *current_dev;
 	int ret;
 
-	DPRINT_ENTER(BLKVSC_DRV);
-
 	while (1) {
 		current_dev = NULL;
 
@@ -238,12 +235,10 @@ static void blkvsc_drv_exit(void)
 
 	vmbus_child_driver_unregister(drv_ctx);
 
-	DPRINT_EXIT(BLKVSC_DRV);
-
 	return;
 }
 
-/**
+/*
  * blkvsc_probe - Add a new device for this driver
  */
 static int blkvsc_probe(struct device *device)
@@ -254,7 +249,7 @@ static int blkvsc_probe(struct device *d
 				(struct blkvsc_driver_context *)driver_ctx;
 	struct storvsc_driver_object *storvsc_drv_obj =
 				&blkvsc_drv_ctx->drv_obj;
-	struct device_context *device_ctx = device_to_device_context(device);
+	struct vm_device *device_ctx = device_to_vm_device(device);
 	struct hv_device *device_obj = &device_ctx->device_obj;
 
 	struct block_device_context *blkdev = NULL;
@@ -265,8 +260,6 @@ static int blkvsc_probe(struct device *d
 	static int ide0_registered;
 	static int ide1_registered;
 
-	DPRINT_ENTER(BLKVSC_DRV);
-
 	DPRINT_DBG(BLKVSC_DRV, "blkvsc_probe - enter");
 
 	if (!storvsc_drv_obj->Base.OnDeviceAdd) {
@@ -286,8 +279,8 @@ static int blkvsc_probe(struct device *d
 	/* Initialize what we can here */
 	spin_lock_init(&blkdev->lock);
 
-	ASSERT(sizeof(struct blkvsc_request_group) <=
-		sizeof(struct blkvsc_request));
+	/* ASSERT(sizeof(struct blkvsc_request_group) <= */
+	/* 	sizeof(struct blkvsc_request)); */
 
 	blkdev->request_pool = kmem_cache_create(dev_name(&device_ctx->device),
 					sizeof(struct blkvsc_request) +
@@ -363,10 +356,7 @@ static int blkvsc_probe(struct device *device)
 	blkdev->gd->queue = blk_init_queue(blkvsc_request, &blkdev->lock);
 
 	blk_queue_max_segment_size(blkdev->gd->queue, PAGE_SIZE);
-	blk_queue_max_phys_segments(blkdev->gd->queue,
-				    MAX_MULTIPAGE_BUFFER_COUNT);
-	blk_queue_max_hw_segments(blkdev->gd->queue,
-				  MAX_MULTIPAGE_BUFFER_COUNT);
+	blk_queue_max_segments(blkdev->gd->queue, MAX_MULTIPAGE_BUFFER_COUNT);
 	blk_queue_segment_boundary(blkdev->gd->queue, PAGE_SIZE-1);
 	blk_queue_bounce_limit(blkdev->gd->queue, BLK_BOUNCE_ANY);
 	blk_queue_dma_alignment(blkdev->gd->queue, 511);
@@ -414,8 +408,6 @@ Cleanup:
 		blkdev = NULL;
 	}
 
-	DPRINT_EXIT(BLKVSC_DRV);
-
 	return ret;
 }
 
@@ -557,7 +549,7 @@ static int blkvsc_do_inquiry(struct bloc
 		blkdev->device_type = UNKNOWN_DEV_TYPE;
 	}
 
-	DPRINT_DBG(BLKVSC_DRV, "device type %d \n", device_type);
+	DPRINT_DBG(BLKVSC_DRV, "device type %d\n", device_type);
 
 	blkdev->device_id_len = buf[7];
 	if (blkdev->device_id_len > 64)
@@ -735,7 +727,7 @@ static int blkvsc_do_read_capacity16(str
 	return 0;
 }
 
-/**
+/*
  * blkvsc_remove() - Callback when our device is removed
  */
 static int blkvsc_remove(struct device *device)
@@ -746,20 +738,16 @@ static int blkvsc_remove(struct device *
 				(struct blkvsc_driver_context *)driver_ctx;
 	struct storvsc_driver_object *storvsc_drv_obj =
 				&blkvsc_drv_ctx->drv_obj;
-	struct device_context *device_ctx = device_to_device_context(device);
+	struct vm_device *device_ctx = device_to_vm_device(device);
 	struct hv_device *device_obj = &device_ctx->device_obj;
 	struct block_device_context *blkdev = dev_get_drvdata(device);
 	unsigned long flags;
 	int ret;
 
-	DPRINT_ENTER(BLKVSC_DRV);
-
 	DPRINT_DBG(BLKVSC_DRV, "blkvsc_remove()\n");
 
-	if (!storvsc_drv_obj->Base.OnDeviceRemove) {
-		DPRINT_EXIT(BLKVSC_DRV);
+	if (!storvsc_drv_obj->Base.OnDeviceRemove)
 		return -1;
-	}
 
 	/*
 	 * Call to the vsc driver to let it know that the device is being
@@ -803,15 +791,13 @@ static int blkvsc_remove(struct device *
 
 	kfree(blkdev);
 
-	DPRINT_EXIT(BLKVSC_DRV);
-
 	return ret;
 }
 
 static void blkvsc_init_rw(struct blkvsc_request *blkvsc_req)
 {
-	ASSERT(blkvsc_req->req);
-	ASSERT(blkvsc_req->sector_count <= (MAX_MULTIPAGE_BUFFER_COUNT*8));
+	/* ASSERT(blkvsc_req->req); */
+	/* ASSERT(blkvsc_req->sector_count <= (MAX_MULTIPAGE_BUFFER_COUNT*8)); */
 
 	blkvsc_req->cmd_len = 16;
 
@@ -866,7 +852,7 @@ static int blkvsc_submit_request(struct
 			void (*request_completion)(struct hv_storvsc_request *))
 {
 	struct block_device_context *blkdev = blkvsc_req->dev;
-	struct device_context *device_ctx = blkdev->device_ctx;
+	struct vm_device *device_ctx = blkdev->device_ctx;
 	struct driver_context *driver_ctx =
 			driver_to_driver_context(device_ctx->device.driver);
 	struct blkvsc_driver_context *blkvsc_drv_ctx =
@@ -942,7 +928,7 @@ static int blkvsc_do_request(struct bloc
 	int pending = 0;
 	struct blkvsc_request_group *group = NULL;
 
-	DPRINT_DBG(BLKVSC_DRV, "blkdev %p req %p sect %lu \n", blkdev, req,
+	DPRINT_DBG(BLKVSC_DRV, "blkdev %p req %p sect %lu\n", blkdev, req,
 		  (unsigned long)blk_rq_pos(req));
 
 	/* Create a group to tie req to list of blkvsc_reqs */
@@ -1118,7 +1104,7 @@ static void blkvsc_request_completion(st
 	unsigned long flags;
 	struct blkvsc_request *comp_req, *tmp;
 
-	ASSERT(blkvsc_req->group);
+	/* ASSERT(blkvsc_req->group); */
 
 	DPRINT_DBG(BLKVSC_DRV, "blkdev %p blkvsc_req %p group %p type %s "
 		   "sect_start %lu sect_count %ld len %d group outstd %d "
@@ -1146,7 +1132,7 @@ static void blkvsc_request_completion(st
 					 &blkvsc_req->group->blkvsc_req_list,
 					 req_entry) {
 			DPRINT_DBG(BLKVSC_DRV, "completing blkvsc_req %p "
-				   "sect_start %lu sect_count %ld \n",
+				   "sect_start %lu sect_count %ld\n",
 				   comp_req,
 				   (unsigned long)comp_req->sector_start,
 				   comp_req->sector_count);
@@ -1200,7 +1186,7 @@ static int blkvsc_cancel_pending_reqs(st
 					 &pend_req->group->blkvsc_req_list,
 					 req_entry) {
 			DPRINT_DBG(BLKVSC_DRV, "completing blkvsc_req %p "
-				   "sect_start %lu sect_count %ld \n",
+				   "sect_start %lu sect_count %ld\n",
 				   comp_req,
 				   (unsigned long) comp_req->sector_start,
 				   comp_req->sector_count);
@@ -1215,7 +1201,10 @@ static int blkvsc_cancel_pending_reqs(st
 					(!comp_req->request.Status ? 0 : -EIO),
 					comp_req->sector_count *
 					blkdev->sector_size);
-				ASSERT(ret != 0);
+
+				/* FIXME: shouldn't this do more than return? */
+				if (ret)
+					goto out;
 			}
 
 			kmem_cache_free(blkdev->request_pool, comp_req);
@@ -1247,6 +1236,7 @@ static int blkvsc_cancel_pending_reqs(st
 		kmem_cache_free(blkdev->request_pool, pend_req);
 	}
 
+out:
 	return ret;
 }
 
@@ -1278,7 +1268,7 @@ static void blkvsc_request(struct reques
 	struct request *req;
 	int ret = 0;
 
-	DPRINT_DBG(BLKVSC_DRV, "- enter \n");
+	DPRINT_DBG(BLKVSC_DRV, "- enter\n");
 	while ((req = blk_peek_request(queue)) != NULL) {
 		DPRINT_DBG(BLKVSC_DRV, "- req %p\n", req);
 
@@ -1487,27 +1477,22 @@ static int __init blkvsc_init(void)
 {
 	int ret;
 
-	ASSERT(sizeof(sector_t) == 8); /* Make sure CONFIG_LBD is set */
-
-	DPRINT_ENTER(BLKVSC_DRV);
+	BUILD_BUG_ON(sizeof(sector_t) != 8);
 
 	DPRINT_INFO(BLKVSC_DRV, "Blkvsc initializing....");
 
 	ret = blkvsc_drv_init(BlkVscInitialize);
 
-	DPRINT_EXIT(BLKVSC_DRV);
-
 	return ret;
 }
 
 static void __exit blkvsc_exit(void)
 {
-	DPRINT_ENTER(BLKVSC_DRV);
 	blkvsc_drv_exit();
-	DPRINT_ENTER(BLKVSC_DRV);
 }
 
 MODULE_LICENSE("GPL");
-module_param(blkvsc_ringbuffer_size, int, S_IRUGO);
+MODULE_VERSION(HV_DRV_VERSION);
+MODULE_DESCRIPTION("Microsoft Hyper-V virtual block driver");
 module_init(blkvsc_init);
 module_exit(blkvsc_exit);
--- a/drivers/staging/hv/hv_api.h
+++ b/drivers/staging/hv/hv_api.h
@@ -316,13 +316,13 @@
 
 /*
  * HV_STATUS_VMX_INSTRUCTION_FAILED
- * The requested VMX instruction failed to complete succesfully.
+ * The requested VMX instruction failed to complete successfully.
  */
 #define HV_STATUS_VMX_INSTRUCTION_FAILED		((u16)0x1011)
 
 /*
  * HV_STATUS_VMX_INSTRUCTION_FAILED_WITH_STATUS
- * The requested VMX instruction failed to complete succesfully indicating
+ * The requested VMX instruction failed to complete successfully indicating
  * status.
  */
 #define HV_STATUS_VMX_INSTRUCTION_FAILED_WITH_STATUS	((u16)0x1012)
--- a/drivers/staging/hv/hyperv_utils.c
+++ b/drivers/staging/hv/hyperv_utils.c
@@ -23,7 +23,7 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/sysctl.h>
-#include <linux/version.h>
+#include <linux/reboot.h>
 
 #include "logging.h"
 #include "osd.h"
@@ -37,7 +37,7 @@
 #include "utils.h"
 
 
-void shutdown_onchannelcallback(void *context)
+static void shutdown_onchannelcallback(void *context)
 {
 	struct vmbus_channel *channel = context;
 	u8 *buf;
@@ -50,8 +50,6 @@ void shutdown_onchannelcallback(void *co
 	struct icmsg_hdr *icmsghdrp;
 	struct icmsg_negotiate *negop = NULL;
 
-	DPRINT_ENTER(VMBUS);
-
 	buflen = PAGE_SIZE;
 	buf = kmalloc(buflen, GFP_ATOMIC);
 
@@ -100,10 +98,145 @@ void shutdown_onchannelcallback(void *co
 
 	kfree(buf);
 
-	DPRINT_EXIT(VMBUS);
-
 	if (execute_shutdown == true)
-		shutdown_linux_system();
+		orderly_poweroff(false);
+}
+
+/*
+ * Set guest time to host UTC time.
+ */
+static inline void do_adj_guesttime(u64 hosttime)
+{
+	s64 host_tns;
+	struct timespec host_ts;
+
+	host_tns = (hosttime - WLTIMEDELTA) * 100;
+	host_ts = ns_to_timespec(host_tns);
+
+	do_settimeofday(&host_ts);
+}
+
+/*
+ * Synchronize time with host after reboot, restore, etc.
+ *
+ * ICTIMESYNCFLAG_SYNC flag bit indicates reboot, restore events of the VM.
+ * After reboot the flag ICTIMESYNCFLAG_SYNC is included in the first time
+ * message after the timesync channel is opened. Since the hv_utils module is
+ * loaded after hv_vmbus, the first message is usually missed. The other
+ * thing is, systime is automatically set to emulated hardware clock which may
+ * not be UTC time or in the same time zone. So, to override these effects, we
+ * use the first 50 time samples for initial system time setting.
+ */
+static inline void adj_guesttime(u64 hosttime, u8 flags)
+{
+	static s32 scnt = 50;
+
+	if ((flags & ICTIMESYNCFLAG_SYNC) != 0) {
+		do_adj_guesttime(hosttime);
+		return;
+	}
+
+	if ((flags & ICTIMESYNCFLAG_SAMPLE) != 0 && scnt > 0) {
+		scnt--;
+		do_adj_guesttime(hosttime);
+	}
+}
+
+/*
+ * Time Sync Channel message handler.
+ */
+static void timesync_onchannelcallback(void *context)
+{
+	struct vmbus_channel *channel = context;
+	u8 *buf;
+	u32 buflen, recvlen;
+	u64 requestid;
+	struct icmsg_hdr *icmsghdrp;
+	struct ictimesync_data *timedatap;
+
+	buflen = PAGE_SIZE;
+	buf = kmalloc(buflen, GFP_ATOMIC);
+
+	VmbusChannelRecvPacket(channel, buf, buflen, &recvlen, &requestid);
+
+	if (recvlen > 0) {
+		DPRINT_DBG(VMBUS, "timesync packet: recvlen=%d, requestid=%lld",
+			recvlen, requestid);
+
+		icmsghdrp = (struct icmsg_hdr *)&buf[
+				sizeof(struct vmbuspipe_hdr)];
+
+		if (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {
+			prep_negotiate_resp(icmsghdrp, NULL, buf);
+		} else {
+			timedatap = (struct ictimesync_data *)&buf[
+				sizeof(struct vmbuspipe_hdr) +
+				sizeof(struct icmsg_hdr)];
+			adj_guesttime(timedatap->parenttime, timedatap->flags);
+		}
+
+		icmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION
+			| ICMSGHDRFLAG_RESPONSE;
+
+		VmbusChannelSendPacket(channel, buf,
+				recvlen, requestid,
+				VmbusPacketTypeDataInBand, 0);
+	}
+
+	kfree(buf);
+}
+
+/*
+ * Heartbeat functionality.
+ * Every two seconds, Hyper-V send us a heartbeat request message.
+ * we respond to this message, and Hyper-V knows we are alive.
+ */
+static void heartbeat_onchannelcallback(void *context)
+{
+	struct vmbus_channel *channel = context;
+	u8 *buf;
+	u32 buflen, recvlen;
+	u64 requestid;
+	struct icmsg_hdr *icmsghdrp;
+	struct heartbeat_msg_data *heartbeat_msg;
+
+	buflen = PAGE_SIZE;
+	buf = kmalloc(buflen, GFP_ATOMIC);
+
+	VmbusChannelRecvPacket(channel, buf, buflen, &recvlen, &requestid);
+
+	if (recvlen > 0) {
+		DPRINT_DBG(VMBUS, "heartbeat packet: len=%d, requestid=%lld",
+			   recvlen, requestid);
+
+		icmsghdrp = (struct icmsg_hdr *)&buf[
+			sizeof(struct vmbuspipe_hdr)];
+
+		icmsghdrp = (struct icmsg_hdr *)&buf[
+				sizeof(struct vmbuspipe_hdr)];
+
+		if (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {
+			prep_negotiate_resp(icmsghdrp, NULL, buf);
+		} else {
+			heartbeat_msg = (struct heartbeat_msg_data *)&buf[
+				sizeof(struct vmbuspipe_hdr) +
+				sizeof(struct icmsg_hdr)];
+
+			DPRINT_DBG(VMBUS, "heartbeat seq = %lld",
+				   heartbeat_msg->seq_num);
+
+			heartbeat_msg->seq_num += 1;
+		}
+
+		icmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION
+			| ICMSGHDRFLAG_RESPONSE;
+
+		VmbusChannelSendPacket(channel, buf,
+				       recvlen, requestid,
+				       VmbusPacketTypeDataInBand, 0);
+	}
+
+	kfree(buf);
 }
 
 static int __init init_hyperv_utils(void)
@@ -114,6 +247,14 @@ static int __init init_hyperv_utils(void
 		&shutdown_onchannelcallback;
 	hv_cb_utils[HV_SHUTDOWN_MSG].callback = &shutdown_onchannelcallback;
 
+	hv_cb_utils[HV_TIMESYNC_MSG].channel->OnChannelCallback =
+		&timesync_onchannelcallback;
+	hv_cb_utils[HV_TIMESYNC_MSG].callback = &timesync_onchannelcallback;
+
+	hv_cb_utils[HV_HEARTBEAT_MSG].channel->OnChannelCallback =
+		&heartbeat_onchannelcallback;
+	hv_cb_utils[HV_HEARTBEAT_MSG].callback = &heartbeat_onchannelcallback;
+
 	return 0;
 }
 
@@ -124,11 +265,19 @@ static void exit_hyperv_utils(void)
 	hv_cb_utils[HV_SHUTDOWN_MSG].channel->OnChannelCallback =
 		&chn_cb_negotiate;
 	hv_cb_utils[HV_SHUTDOWN_MSG].callback = &chn_cb_negotiate;
+
+	hv_cb_utils[HV_TIMESYNC_MSG].channel->OnChannelCallback =
+		&chn_cb_negotiate;
+	hv_cb_utils[HV_TIMESYNC_MSG].callback = &chn_cb_negotiate;
+
+	hv_cb_utils[HV_HEARTBEAT_MSG].channel->OnChannelCallback =
+		&chn_cb_negotiate;
+	hv_cb_utils[HV_HEARTBEAT_MSG].callback = &chn_cb_negotiate;
 }
 
 module_init(init_hyperv_utils);
 module_exit(exit_hyperv_utils);
 
 MODULE_DESCRIPTION("Hyper-V Utilities");
-//MODULE_VERSION(VersionDesc);
+MODULE_VERSION(HV_DRV_VERSION);
 MODULE_LICENSE("GPL");
--- a/drivers/staging/hv/logging.h
+++ b/drivers/staging/hv/logging.h
@@ -61,13 +61,6 @@
 
 extern unsigned int vmbus_loglevel;
 
-#define ASSERT(expr)	\
-	if (!(expr)) {	\
-		printk(KERN_CRIT "Assertion failed! %s,%s,%s,line=%d\n", \
-		       #expr, __FILE__, __func__, __LINE__);	\
-		__asm__ __volatile__("int3");	\
-	}
-
 #define DPRINT(mod, lvl, fmt, args...) do {\
 	if ((mod & (HIWORD(vmbus_loglevel))) &&	\
 	    (lvl <= LOWORD(vmbus_loglevel)))	\
@@ -99,21 +92,4 @@ extern unsigned int vmbus_loglevel;
 		       __func__, ## args);\
 	} while (0)
 
-#ifdef DEBUG
-#define DPRINT_ENTER(mod) do {\
-	if ((mod & (HIWORD(vmbus_loglevel))) && \
-	    (DEBUG_LVL_ENTEREXIT <= LOWORD(vmbus_loglevel)))	\
-		printk(KERN_DEBUG "["#mod"]: %s() enter\n", __func__);\
-	} while (0)
-
-#define DPRINT_EXIT(mod) do {\
-	if ((mod & (HIWORD(vmbus_loglevel))) && \
-	    (DEBUG_LVL_ENTEREXIT <= LOWORD(vmbus_loglevel)))	\
-		printk(KERN_DEBUG "["#mod"]: %s() exit\n", __func__);\
-	} while (0)
-#else
-#define DPRINT_ENTER(mod)
-#define DPRINT_EXIT(mod)
-#endif
-
 #endif /* _LOGGING_H_ */
--- a/drivers/staging/hv/netvsc_drv.c
+++ b/drivers/staging/hv/netvsc_drv.c
@@ -29,6 +29,7 @@
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
 #include <linux/in.h>
+#include <linux/slab.h>
 #include <linux/dmi.h>
 #include <linux/pci.h>
 #include <net/arp.h>
@@ -37,15 +38,14 @@
 #include <net/pkt_sched.h>
 #include "osd.h"
 #include "logging.h"
+#include "VersionInfo.h"
 #include "vmbus.h"
 #include "NetVscApi.h"
 
-MODULE_LICENSE("GPL");
-
 struct net_device_context {
 	/* point back to our device context */
-	struct device_context *device_ctx;
-	struct net_device_stats stats;
+	struct vm_device *device_ctx;
+	unsigned long avail;
 	struct work_struct work;
 };
 
@@ -56,18 +56,17 @@ struct netvsc_driver_context {
 	struct netvsc_driver drv_obj;
 };
 
-static int netvsc_ringbuffer_size = NETVSC_DEVICE_RING_BUFFER_SIZE;
+#define PACKET_PAGES_LOWATER  8
+/* Need this many pages to handle worst case fragmented packet */
+#define PACKET_PAGES_HIWATER  (MAX_SKB_FRAGS + 2)
+
+static int ring_size = roundup_pow_of_two(2*MAX_SKB_FRAGS+1);
+module_param(ring_size, int, S_IRUGO);
+MODULE_PARM_DESC(ring_size, "Ring buffer size (# of pages)");
 
 /* The one and only one */
 static struct netvsc_driver_context g_netvsc_drv;
 
-static struct net_device_stats *netvsc_get_stats(struct net_device *net)
-{
-	struct net_device_context *net_device_ctx = netdev_priv(net);
-
-	return &net_device_ctx->stats;
-}
-
 static void netvsc_set_multicast_list(struct net_device *net)
 {
 }
@@ -75,22 +74,12 @@ static void netvsc_set_multicast_list(st
 static int netvsc_open(struct net_device *net)
 {
 	struct net_device_context *net_device_ctx = netdev_priv(net);
-	struct driver_context *driver_ctx =
-	    driver_to_driver_context(net_device_ctx->device_ctx->device.driver);
-	struct netvsc_driver_context *net_drv_ctx =
-		(struct netvsc_driver_context *)driver_ctx;
-	struct netvsc_driver *net_drv_obj = &net_drv_ctx->drv_obj;
 	struct hv_device *device_obj = &net_device_ctx->device_ctx->device_obj;
 	int ret = 0;
 
-	DPRINT_ENTER(NETVSC_DRV);
-
 	if (netif_carrier_ok(net)) {
-		memset(&net_device_ctx->stats, 0,
-		       sizeof(struct net_device_stats));
-
 		/* Open up the device */
-		ret = net_drv_obj->OnOpen(device_obj);
+		ret = RndisFilterOnOpen(device_obj);
 		if (ret != 0) {
 			DPRINT_ERR(NETVSC_DRV,
 				   "unable to open device (ret %d).", ret);
@@ -102,31 +91,21 @@ static int netvsc_open(struct net_device
 		DPRINT_ERR(NETVSC_DRV, "unable to open device...link is down.");
 	}
 
-	DPRINT_EXIT(NETVSC_DRV);
 	return ret;
 }
 
 static int netvsc_close(struct net_device *net)
 {
 	struct net_device_context *net_device_ctx = netdev_priv(net);
-	struct driver_context *driver_ctx =
-	    driver_to_driver_context(net_device_ctx->device_ctx->device.driver);
-	struct netvsc_driver_context *net_drv_ctx =
-		(struct netvsc_driver_context *)driver_ctx;
-	struct netvsc_driver *net_drv_obj = &net_drv_ctx->drv_obj;
 	struct hv_device *device_obj = &net_device_ctx->device_ctx->device_obj;
 	int ret;
 
-	DPRINT_ENTER(NETVSC_DRV);
-
 	netif_stop_queue(net);
 
-	ret = net_drv_obj->OnClose(device_obj);
+	ret = RndisFilterOnClose(device_obj);
 	if (ret != 0)
 		DPRINT_ERR(NETVSC_DRV, "unable to close device (ret %d).", ret);
 
-	DPRINT_EXIT(NETVSC_DRV);
-
 	return ret;
 }
 
@@ -135,25 +114,19 @@ static void netvsc_xmit_completion(void
 	struct hv_netvsc_packet *packet = (struct hv_netvsc_packet *)context;
 	struct sk_buff *skb = (struct sk_buff *)
 		(unsigned long)packet->Completion.Send.SendCompletionTid;
-	struct net_device *net;
-
-	DPRINT_ENTER(NETVSC_DRV);
 
 	kfree(packet);
 
 	if (skb) {
-		net = skb->dev;
-		dev_kfree_skb_any(skb);
+		struct net_device *net = skb->dev;
+		struct net_device_context *net_device_ctx = netdev_priv(net);
+		unsigned int num_pages = skb_shinfo(skb)->nr_frags + 2;
 
-		if (netif_queue_stopped(net)) {
-			DPRINT_INFO(NETVSC_DRV, "net device (%p) waking up...",
-				    net);
+		dev_kfree_skb_any(skb);
 
-			netif_wake_queue(net);
-		}
+		if ((net_device_ctx->avail += num_pages) >= PACKET_PAGES_HIWATER)
+ 			netif_wake_queue(net);
 	}
-
-	DPRINT_EXIT(NETVSC_DRV);
 }
 
 static int netvsc_start_xmit(struct sk_buff *skb, struct net_device *net)
@@ -165,65 +138,56 @@ static int netvsc_start_xmit(struct sk_b
 		(struct netvsc_driver_context *)driver_ctx;
 	struct netvsc_driver *net_drv_obj = &net_drv_ctx->drv_obj;
 	struct hv_netvsc_packet *packet;
-	int i;
 	int ret;
-	int num_frags;
-	int retries = 0;
-
-	DPRINT_ENTER(NETVSC_DRV);
-
-	/* Support only 1 chain of frags */
-	ASSERT(skb_shinfo(skb)->frag_list == NULL);
-	ASSERT(skb->dev == net);
+	unsigned int i, num_pages;
 
 	DPRINT_DBG(NETVSC_DRV, "xmit packet - len %d data_len %d",
 		   skb->len, skb->data_len);
 
-	/* Add 1 for skb->data and any additional ones requested */
-	num_frags = skb_shinfo(skb)->nr_frags + 1 +
-		    net_drv_obj->AdditionalRequestPageBufferCount;
+	/* Add 1 for skb->data and additional one for RNDIS */
+	num_pages = skb_shinfo(skb)->nr_frags + 1 + 1;
+	if (num_pages > net_device_ctx->avail)
+		return NETDEV_TX_BUSY;
 
 	/* Allocate a netvsc packet based on # of frags. */
 	packet = kzalloc(sizeof(struct hv_netvsc_packet) +
-			 (num_frags * sizeof(struct hv_page_buffer)) +
+			 (num_pages * sizeof(struct hv_page_buffer)) +
 			 net_drv_obj->RequestExtSize, GFP_ATOMIC);
 	if (!packet) {
+		/* out of memory, silently drop packet */
 		DPRINT_ERR(NETVSC_DRV, "unable to allocate hv_netvsc_packet");
-		return -1;
+
+		dev_kfree_skb(skb);
+		net->stats.tx_dropped++;
+		return NETDEV_TX_OK;
 	}
 
 	packet->Extension = (void *)(unsigned long)packet +
 				sizeof(struct hv_netvsc_packet) +
-				    (num_frags * sizeof(struct hv_page_buffer));
+				    (num_pages * sizeof(struct hv_page_buffer));
 
 	/* Setup the rndis header */
-	packet->PageBufferCount = num_frags;
+	packet->PageBufferCount = num_pages;
 
 	/* TODO: Flush all write buffers/ memory fence ??? */
 	/* wmb(); */
 
 	/* Initialize it from the skb */
-	ASSERT(skb->data);
 	packet->TotalDataBufferLength	= skb->len;
 
-	/*
-	 * Start filling in the page buffers starting at
-	 * AdditionalRequestPageBufferCount offset
-	 */
-	packet->PageBuffers[net_drv_obj->AdditionalRequestPageBufferCount].Pfn = virt_to_phys(skb->data) >> PAGE_SHIFT;
-	packet->PageBuffers[net_drv_obj->AdditionalRequestPageBufferCount].Offset = (unsigned long)skb->data & (PAGE_SIZE - 1);
-	packet->PageBuffers[net_drv_obj->AdditionalRequestPageBufferCount].Length = skb->len - skb->data_len;
-
-	ASSERT((skb->len - skb->data_len) <= PAGE_SIZE);
-
-	for (i = net_drv_obj->AdditionalRequestPageBufferCount + 1;
-	     i < num_frags; i++) {
-		packet->PageBuffers[i].Pfn =
-			page_to_pfn(skb_shinfo(skb)->frags[i-(net_drv_obj->AdditionalRequestPageBufferCount+1)].page);
-		packet->PageBuffers[i].Offset =
-			skb_shinfo(skb)->frags[i-(net_drv_obj->AdditionalRequestPageBufferCount+1)].page_offset;
-		packet->PageBuffers[i].Length =
-			skb_shinfo(skb)->frags[i-(net_drv_obj->AdditionalRequestPageBufferCount+1)].size;
+	/* Start filling in the page buffers starting after RNDIS buffer. */
+	packet->PageBuffers[1].Pfn = virt_to_phys(skb->data) >> PAGE_SHIFT;
+	packet->PageBuffers[1].Offset
+		= (unsigned long)skb->data & (PAGE_SIZE - 1);
+	packet->PageBuffers[1].Length = skb_headlen(skb);
+
+	/* Additional fragments are after SKB data */
+	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+		skb_frag_t *f = &skb_shinfo(skb)->frags[i];
+
+		packet->PageBuffers[i+2].Pfn = page_to_pfn(f->page);
+		packet->PageBuffers[i+2].Offset = f->page_offset;
+		packet->PageBuffers[i+2].Length = f->size;
 	}
 
 	/* Set the completion routine */
@@ -231,66 +195,37 @@ static int netvsc_start_xmit(struct sk_b
 	packet->Completion.Send.SendCompletionContext = packet;
 	packet->Completion.Send.SendCompletionTid = (unsigned long)skb;
 
-retry_send:
 	ret = net_drv_obj->OnSend(&net_device_ctx->device_ctx->device_obj,
 				  packet);
-
 	if (ret == 0) {
-		ret = NETDEV_TX_OK;
-		net_device_ctx->stats.tx_bytes += skb->len;
-		net_device_ctx->stats.tx_packets++;
-	} else {
-		retries++;
-		if (retries < 4) {
-			DPRINT_ERR(NETVSC_DRV, "unable to send..."
-					"retrying %d...", retries);
-			udelay(100);
-			goto retry_send;
-		}
+		net->stats.tx_bytes += skb->len;
+		net->stats.tx_packets++;
 
-		/* no more room or we are shutting down */
-		DPRINT_ERR(NETVSC_DRV, "unable to send (%d)..."
-			   "marking net device (%p) busy", ret, net);
-		DPRINT_INFO(NETVSC_DRV, "net device (%p) stopping", net);
+		DPRINT_DBG(NETVSC_DRV, "# of xmits %lu total size %lu",
+			   net->stats.tx_packets,
+			   net->stats.tx_bytes);
 
-		ret = NETDEV_TX_BUSY;
-		net_device_ctx->stats.tx_dropped++;
-
-		netif_stop_queue(net);
-
-		/*
-		 * Null it since the caller will free it instead of the
-		 * completion routine
-		 */
-		packet->Completion.Send.SendCompletionTid = 0;
-
-		/*
-		 * Release the resources since we will not get any send
-		 * completion
-		 */
-		netvsc_xmit_completion((void *)packet);
-	}
-
-	DPRINT_DBG(NETVSC_DRV, "# of xmits %lu total size %lu",
-		   net_device_ctx->stats.tx_packets,
-		   net_device_ctx->stats.tx_bytes);
+		if ((net_device_ctx->avail -= num_pages) < PACKET_PAGES_LOWATER)
+			netif_stop_queue(net);
+	} else {
+		/* we are shutting down or bus overloaded, just drop packet */
+		net->stats.tx_dropped++;
+		netvsc_xmit_completion(packet);
+	}
 
-	DPRINT_EXIT(NETVSC_DRV);
-	return ret;
+	return NETDEV_TX_OK;
 }
 
-/**
+/*
  * netvsc_linkstatus_callback - Link up/down notification
  */
 static void netvsc_linkstatus_callback(struct hv_device *device_obj,
 				       unsigned int status)
 {
-	struct device_context *device_ctx = to_device_context(device_obj);
+	struct vm_device *device_ctx = to_vm_device(device_obj);
 	struct net_device *net = dev_get_drvdata(&device_ctx->device);
 	struct net_device_context *ndev_ctx;
 
-	DPRINT_ENTER(NETVSC_DRV);
-
 	if (!net) {
 		DPRINT_ERR(NETVSC_DRV, "got link status but net device "
 				"not initialized yet");
@@ -307,40 +242,34 @@ static void netvsc_linkstatus_callback(s
 		netif_carrier_off(net);
 		netif_stop_queue(net);
 	}
-	DPRINT_EXIT(NETVSC_DRV);
 }
 
-/**
- * netvsc_recv_callback -  Callback when we receive a packet from the "wire" on the specified device.
+/*
+ * netvsc_recv_callback -  Callback when we receive a packet from the
+ * "wire" on the specified device.
  */
 static int netvsc_recv_callback(struct hv_device *device_obj,
 				struct hv_netvsc_packet *packet)
 {
-	struct device_context *device_ctx = to_device_context(device_obj);
+	struct vm_device *device_ctx = to_vm_device(device_obj);
 	struct net_device *net = dev_get_drvdata(&device_ctx->device);
-	struct net_device_context *net_device_ctx;
 	struct sk_buff *skb;
 	void *data;
-	int ret;
 	int i;
 	unsigned long flags;
 
-	DPRINT_ENTER(NETVSC_DRV);
-
 	if (!net) {
 		DPRINT_ERR(NETVSC_DRV, "got receive callback but net device "
 				"not initialized yet");
 		return 0;
 	}
 
-	net_device_ctx = netdev_priv(net);
-
-	/* Allocate a skb - TODO preallocate this */
-	/* Pad 2-bytes to align IP header to 16 bytes */
-	skb = dev_alloc_skb(packet->TotalDataBufferLength + 2);
-	ASSERT(skb);
-	skb_reserve(skb, 2);
-	skb->dev = net;
+	/* Allocate a skb - TODO direct I/O to pages? */
+	skb = netdev_alloc_skb_ip_align(net, packet->TotalDataBufferLength);
+	if (unlikely(!skb)) {
+		++net->stats.rx_dropped;
+		return 0;
+	}
 
 	/* for kmap_atomic */
 	local_irq_save(flags);
@@ -365,39 +294,43 @@ static int netvsc_recv_callback(struct h
 	local_irq_restore(flags);
 
 	skb->protocol = eth_type_trans(skb, net);
-
 	skb->ip_summed = CHECKSUM_NONE;
 
+	net->stats.rx_packets++;
+	net->stats.rx_bytes += skb->len;
+
 	/*
 	 * Pass the skb back up. Network stack will deallocate the skb when it
-	 * is done
+	 * is done.
+	 * TODO - use NAPI?
 	 */
-	ret = netif_rx(skb);
-
-	switch (ret) {
-	case NET_RX_DROP:
-		net_device_ctx->stats.rx_dropped++;
-		break;
-	default:
-		net_device_ctx->stats.rx_packets++;
-		net_device_ctx->stats.rx_bytes += skb->len;
-		break;
+	netif_rx(skb);
 
-	}
 	DPRINT_DBG(NETVSC_DRV, "# of recvs %lu total size %lu",
-		   net_device_ctx->stats.rx_packets,
-		   net_device_ctx->stats.rx_bytes);
-
-	DPRINT_EXIT(NETVSC_DRV);
+		   net->stats.rx_packets, net->stats.rx_bytes);
 
 	return 0;
 }
 
+static void netvsc_get_drvinfo(struct net_device *net,
+			       struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, "hv_netvsc");
+	strcpy(info->version, HV_DRV_VERSION);
+	strcpy(info->fw_version, "N/A");
+}
+
+static const struct ethtool_ops ethtool_ops = {
+	.get_drvinfo	= netvsc_get_drvinfo,
+	.get_sg		= ethtool_op_get_sg,
+	.set_sg		= ethtool_op_set_sg,
+	.get_link	= ethtool_op_get_link,
+};
+
 static const struct net_device_ops device_ops = {
 	.ndo_open =			netvsc_open,
 	.ndo_stop =			netvsc_close,
 	.ndo_start_xmit =		netvsc_start_xmit,
-	.ndo_get_stats =		netvsc_get_stats,
 	.ndo_set_multicast_list =	netvsc_set_multicast_list,
 	.ndo_change_mtu =		eth_change_mtu,
 	.ndo_validate_addr =		eth_validate_addr,
@@ -430,15 +363,13 @@ static int netvsc_probe(struct device *d
 	struct netvsc_driver_context *net_drv_ctx =
 		(struct netvsc_driver_context *)driver_ctx;
 	struct netvsc_driver *net_drv_obj = &net_drv_ctx->drv_obj;
-	struct device_context *device_ctx = device_to_device_context(device);
+	struct vm_device *device_ctx = device_to_vm_device(device);
 	struct hv_device *device_obj = &device_ctx->device_obj;
 	struct net_device *net = NULL;
 	struct net_device_context *net_device_ctx;
 	struct netvsc_device_info device_info;
 	int ret;
 
-	DPRINT_ENTER(NETVSC_DRV);
-
 	if (!net_drv_obj->Base.OnDeviceAdd)
 		return -1;
 
@@ -452,6 +383,7 @@ static int netvsc_probe(struct device *d
 
 	net_device_ctx = netdev_priv(net);
 	net_device_ctx->device_ctx = device_ctx;
+	net_device_ctx->avail = ring_size;
 	dev_set_drvdata(device, net);
 	INIT_WORK(&net_device_ctx->work, netvsc_send_garp);
 
@@ -482,6 +414,10 @@ static int netvsc_probe(struct device *d
 
 	net->netdev_ops = &device_ops;
 
+	/* TODO: Add GSO and Checksum offload */
+	net->features = NETIF_F_SG;
+
+	SET_ETHTOOL_OPS(net, &ethtool_ops);
 	SET_NETDEV_DEV(net, device);
 
 	ret = register_netdev(net);
@@ -491,7 +427,6 @@ static int netvsc_probe(struct device *d
 		free_netdev(net);
 	}
 
-	DPRINT_EXIT(NETVSC_DRV);
 	return ret;
 }
 
@@ -502,23 +437,18 @@ static int netvsc_remove(struct device *
 	struct netvsc_driver_context *net_drv_ctx =
 		(struct netvsc_driver_context *)driver_ctx;
 	struct netvsc_driver *net_drv_obj = &net_drv_ctx->drv_obj;
-	struct device_context *device_ctx = device_to_device_context(device);
+	struct vm_device *device_ctx = device_to_vm_device(device);
 	struct net_device *net = dev_get_drvdata(&device_ctx->device);
 	struct hv_device *device_obj = &device_ctx->device_obj;
 	int ret;
 
-	DPRINT_ENTER(NETVSC_DRV);
-
 	if (net == NULL) {
 		DPRINT_INFO(NETVSC, "no net device to remove");
-		DPRINT_EXIT(NETVSC_DRV);
 		return 0;
 	}
 
-	if (!net_drv_obj->Base.OnDeviceRemove) {
-		DPRINT_EXIT(NETVSC_DRV);
+	if (!net_drv_obj->Base.OnDeviceRemove)
 		return -1;
-	}
 
 	/* Stop outbound asap */
 	netif_stop_queue(net);
@@ -537,7 +467,6 @@ static int netvsc_remove(struct device *
 	}
 
 	free_netdev(net);
-	DPRINT_EXIT(NETVSC_DRV);
 	return ret;
 }
 
@@ -557,8 +486,6 @@ static void netvsc_drv_exit(void)
 	struct device *current_dev;
 	int ret;
 
-	DPRINT_ENTER(NETVSC_DRV);
-
 	while (1) {
 		current_dev = NULL;
 
@@ -584,8 +511,6 @@ static void netvsc_drv_exit(void)
 
 	vmbus_child_driver_unregister(drv_ctx);
 
-	DPRINT_EXIT(NETVSC_DRV);
-
 	return;
 }
 
@@ -595,11 +520,9 @@ static int netvsc_drv_init(int (*drv_ini
 	struct driver_context *drv_ctx = &g_netvsc_drv.drv_ctx;
 	int ret;
 
-	DPRINT_ENTER(NETVSC_DRV);
-
 	vmbus_get_interface(&net_drv_obj->Base.VmbusChannelInterface);
 
-	net_drv_obj->RingBufferSize = netvsc_ringbuffer_size;
+	net_drv_obj->RingBufferSize = ring_size * PAGE_SIZE;
 	net_drv_obj->OnReceiveCallback = netvsc_recv_callback;
 	net_drv_obj->OnLinkStatusChanged = netvsc_linkstatus_callback;
 
@@ -616,8 +539,6 @@ static int netvsc_drv_init(int (*drv_ini
 	/* The driver belongs to vmbus */
 	ret = vmbus_child_driver_register(drv_ctx);
 
-	DPRINT_EXIT(NETVSC_DRV);
-
 	return ret;
 }
 
@@ -637,26 +558,17 @@ MODULE_DEVICE_TABLE(dmi, hv_netvsc_dmi_t
 
 static int __init netvsc_init(void)
 {
-	int ret;
-
-	DPRINT_ENTER(NETVSC_DRV);
 	DPRINT_INFO(NETVSC_DRV, "Netvsc initializing....");
 
 	if (!dmi_check_system(hv_netvsc_dmi_table))
 		return -ENODEV;
 
-	ret = netvsc_drv_init(NetVscInitialize);
-
-	DPRINT_EXIT(NETVSC_DRV);
-
-	return ret;
+	return netvsc_drv_init(NetVscInitialize);
 }
 
 static void __exit netvsc_exit(void)
 {
-	DPRINT_ENTER(NETVSC_DRV);
 	netvsc_drv_exit();
-	DPRINT_EXIT(NETVSC_DRV);
 }
 
 static const struct pci_device_id __initconst
@@ -666,7 +578,9 @@ hv_netvsc_pci_table[] __maybe_unused = {
 };
 MODULE_DEVICE_TABLE(pci, hv_netvsc_pci_table);
 
-module_param(netvsc_ringbuffer_size, int, S_IRUGO);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(HV_DRV_VERSION);
+MODULE_DESCRIPTION("Microsoft Hyper-V network driver");
 
 module_init(netvsc_init);
 module_exit(netvsc_exit);
--- a/drivers/staging/hv/osd.c
+++ b/drivers/staging/hv/osd.c
@@ -40,6 +40,7 @@
 #include <linux/time.h>
 #include <linux/io.h>
 #include <linux/bitops.h>
+#include <linux/slab.h>
 #include "osd.h"
 
 struct osd_callback_struct {
@@ -58,6 +59,15 @@ void *osd_VirtualAllocExec(unsigned int
 #endif
 }
 
+/**
+ * osd_PageAlloc() - Allocate pages
+ * @count:      Total number of Kernel pages you want to allocate
+ *
+ * Tries to allocate @count number of consecutive free kernel pages.
+ * And if successful, it will set the pages to 0 before returning.
+ * If successfull it will return pointer to the @count pages.
+ * Mainly used by Hyper-V drivers.
+ */
 void *osd_PageAlloc(unsigned int count)
 {
 	void *p;
@@ -77,6 +87,14 @@ void *osd_PageAlloc(unsigned int count)
 }
 EXPORT_SYMBOL_GPL(osd_PageAlloc);
 
+/**
+ * osd_PageFree() - Free pages
+ * @page:       Pointer to the first page to be freed
+ * @count:      Total number of Kernel pages you free
+ *
+ * Frees the pages allocated by osd_PageAlloc()
+ * Mainly used by Hyper-V drivers.
+ */
 void osd_PageFree(void *page, unsigned int count)
 {
 	free_pages((unsigned long)page, get_order(count * PAGE_SIZE));
@@ -85,6 +103,17 @@ void osd_PageFree(void *page, unsigned i
 }
 EXPORT_SYMBOL_GPL(osd_PageFree);
 
+/**
+ * osd_WaitEventCreate() - Create the event queue
+ *
+ * Allocates memory for a &struct osd_waitevent. And then calls
+ * init_waitqueue_head to set up the wait queue for the event.
+ * This structure is usually part of a another structure that contains
+ * the actual Hyper-V device driver structure.
+ *
+ * Returns pointer to &struct osd_waitevent
+ * Mainly used by Hyper-V drivers.
+ */
 struct osd_waitevent *osd_WaitEventCreate(void)
 {
 	struct osd_waitevent *wait = kmalloc(sizeof(struct osd_waitevent),
@@ -98,6 +127,19 @@ struct osd_waitevent *osd_WaitEventCreat
 }
 EXPORT_SYMBOL_GPL(osd_WaitEventCreate);
 
+
+/**
+ * osd_WaitEventSet() - Wake up the process
+ * @waitEvent: Structure to event to be woken up
+ *
+ * @waitevent is of type &struct osd_waitevent
+ *
+ * Wake up the sleeping process so it can do some work.
+ * And set condition indicator in &struct osd_waitevent to indicate
+ * the process is in a woken state.
+ *
+ * Only used by Network and Storage Hyper-V drivers.
+ */
 void osd_WaitEventSet(struct osd_waitevent *waitEvent)
 {
 	waitEvent->condition = 1;
@@ -105,6 +147,20 @@ void osd_WaitEventSet(struct osd_waiteve
 }
 EXPORT_SYMBOL_GPL(osd_WaitEventSet);
 
+/**
+ * osd_WaitEventWait() - Wait for event till condition is true
+ * @waitEvent: Structure to event to be put to sleep
+ *
+ * @waitevent is of type &struct osd_waitevent
+ *
+ * Set up the process to sleep until waitEvent->condition get true.
+ * And set condition indicator in &struct osd_waitevent to indicate
+ * the process is in a sleeping state.
+ *
+ * Returns the status of 'wait_event_interruptible()' system call
+ *
+ * Mainly used by Hyper-V drivers.
+ */
 int osd_WaitEventWait(struct osd_waitevent *waitEvent)
 {
 	int ret = 0;
@@ -116,6 +172,21 @@ int osd_WaitEventWait(struct osd_waiteve
 }
 EXPORT_SYMBOL_GPL(osd_WaitEventWait);
 
+/**
+ * osd_WaitEventWaitEx() - Wait for event or timeout for process wakeup
+ * @waitEvent: Structure to event to be put to sleep
+ * @TimeoutInMs:       Total number of Milliseconds to wait before waking up
+ *
+ * @waitevent is of type &struct osd_waitevent
+ * Set up the process to sleep until @waitEvent->condition get true or
+ * @TimeoutInMs (Time out in Milliseconds) has been reached.
+ * And set condition indicator in &struct osd_waitevent to indicate
+ * the process is in a sleeping state.
+ *
+ * Returns the status of 'wait_event_interruptible_timeout()' system call
+ *
+ * Mainly used by Hyper-V drivers.
+ */
 int osd_WaitEventWaitEx(struct osd_waitevent *waitEvent, u32 TimeoutInMs)
 {
 	int ret = 0;
--- a/drivers/staging/hv/rndis.h
+++ b/drivers/staging/hv/rndis.h
@@ -622,7 +622,7 @@ struct rndis_message {
 /* get the size of an RNDIS message. Pass in the message type, */
 /* struct rndis_set_request, struct rndis_packet for example */
 #define RNDIS_MESSAGE_SIZE(Message)				\
-	(sizeof(Message) + (sizeof(struct rndis_message) - 	\
+	(sizeof(Message) + (sizeof(struct rndis_message) -	\
 	 sizeof(union rndis_message_container)))
 
 /* get pointer to info buffer with message pointer */
--- a/drivers/staging/hv/storvsc_drv.c
+++ b/drivers/staging/hv/storvsc_drv.c
@@ -19,6 +19,7 @@
  *   Hank Janssen  <hjanssen@microsoft.com>
  */
 #include <linux/init.h>
+#include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/blkdev.h>
@@ -32,6 +33,7 @@
 #include <scsi/scsi_dbg.h>
 #include "osd.h"
 #include "logging.h"
+#include "VersionInfo.h"
 #include "vmbus.h"
 #include "StorVscApi.h"
 
@@ -39,10 +41,8 @@
 struct host_device_context {
 	/* must be 1st field
 	 * FIXME this is a bug */
-	struct work_struct host_rescan_work;
-
 	/* point back to our device context */
-	struct device_context *device_ctx;
+	struct vm_device *device_ctx;
 	struct kmem_cache *request_pool;
 	unsigned int port;
 	unsigned char path;
@@ -77,8 +77,6 @@ static int storvsc_queuecommand(struct s
 static int storvsc_device_alloc(struct scsi_device *);
 static int storvsc_device_configure(struct scsi_device *);
 static int storvsc_host_reset_handler(struct scsi_cmnd *scmnd);
-static void storvsc_host_rescan_callback(struct work_struct *work);
-static void storvsc_host_rescan(struct hv_device *device_obj);
 static int storvsc_remove(struct device *dev);
 
 static struct scatterlist *create_bounce_buffer(struct scatterlist *sgl,
@@ -94,13 +92,13 @@ static unsigned int copy_to_bounce_buffe
 					  struct scatterlist *bounce_sgl,
 					  unsigned int orig_sgl_count);
 
-static int storvsc_report_luns(struct scsi_device *sdev, unsigned int luns[],
-			       unsigned int *lun_count);
 static int storvsc_get_chs(struct scsi_device *sdev, struct block_device *bdev,
 			   sector_t capacity, int *info);
 
 
 static int storvsc_ringbuffer_size = STORVSC_RING_BUFFER_SIZE;
+module_param(storvsc_ringbuffer_size, int, S_IRUGO);
+MODULE_PARM_DESC(storvsc_ringbuffer_size, "Ring buffer size (bytes)");
 
 /* The one and only one */
 static struct storvsc_driver_context g_storvsc_drv;
@@ -116,7 +114,7 @@ static struct scsi_host_template scsi_dr
 	.slave_configure =	storvsc_device_configure,
 	.cmd_per_lun =		1,
 	/* 64 max_queue * 1 target */
-	.can_queue = 		STORVSC_MAX_IO_REQUESTS*STORVSC_MAX_TARGETS,
+	.can_queue =		STORVSC_MAX_IO_REQUESTS*STORVSC_MAX_TARGETS,
 	.this_id =		-1,
 	/* no use setting to 0 since ll_blk_rw reset it to 1 */
 	/* currently 32 */
@@ -134,7 +132,7 @@ static struct scsi_host_template scsi_dr
 };
 
 
-/**
+/*
  * storvsc_drv_init - StorVsc driver initialization.
  */
 static int storvsc_drv_init(int (*drv_init)(struct hv_driver *drv))
@@ -143,12 +141,9 @@ static int storvsc_drv_init(int (*drv_in
 	struct storvsc_driver_object *storvsc_drv_obj = &g_storvsc_drv.drv_obj;
 	struct driver_context *drv_ctx = &g_storvsc_drv.drv_ctx;
 
-	DPRINT_ENTER(STORVSC_DRV);
-
 	vmbus_get_interface(&storvsc_drv_obj->Base.VmbusChannelInterface);
 
 	storvsc_drv_obj->RingBufferSize = storvsc_ringbuffer_size;
-	storvsc_drv_obj->OnHostRescan = storvsc_host_rescan;
 
 	/* Callback to client driver to complete the initialization */
 	drv_init(&storvsc_drv_obj->Base);
@@ -178,8 +173,6 @@ static int storvsc_drv_init(int (*drv_in
 	/* The driver belongs to vmbus */
 	ret = vmbus_child_driver_register(drv_ctx);
 
-	DPRINT_EXIT(STORVSC_DRV);
-
 	return ret;
 }
 
@@ -197,8 +190,6 @@ static void storvsc_drv_exit(void)
 	struct device *current_dev = NULL;
 	int ret;
 
-	DPRINT_ENTER(STORVSC_DRV);
-
 	while (1) {
 		current_dev = NULL;
 
@@ -222,13 +213,10 @@ static void storvsc_drv_exit(void)
 		storvsc_drv_obj->Base.OnCleanup(&storvsc_drv_obj->Base);
 
 	vmbus_child_driver_unregister(drv_ctx);
-
-	DPRINT_EXIT(STORVSC_DRV);
-
 	return;
 }
 
-/**
+/*
  * storvsc_probe - Add a new device for this driver
  */
 static int storvsc_probe(struct device *device)
@@ -240,14 +228,12 @@ static int storvsc_probe(struct device *
 				(struct storvsc_driver_context *)driver_ctx;
 	struct storvsc_driver_object *storvsc_drv_obj =
 				&storvsc_drv_ctx->drv_obj;
-	struct device_context *device_ctx = device_to_device_context(device);
+	struct vm_device *device_ctx = device_to_vm_device(device);
 	struct hv_device *device_obj = &device_ctx->device_obj;
 	struct Scsi_Host *host;
 	struct host_device_context *host_device_ctx;
 	struct storvsc_device_info device_info;
 
-	DPRINT_ENTER(STORVSC_DRV);
-
 	if (!storvsc_drv_obj->Base.OnDeviceAdd)
 		return -1;
 
@@ -266,9 +252,6 @@ static int storvsc_probe(struct device *
 	host_device_ctx->port = host->host_no;
 	host_device_ctx->device_ctx = device_ctx;
 
-	INIT_WORK(&host_device_ctx->host_rescan_work,
-		  storvsc_host_rescan_callback);
-
 	host_device_ctx->request_pool =
 				kmem_cache_create(dev_name(&device_ctx->device),
 					sizeof(struct storvsc_cmd_request) +
@@ -277,8 +260,6 @@ static int storvsc_probe(struct device *
 
 	if (!host_device_ctx->request_pool) {
 		scsi_host_put(host);
-		DPRINT_EXIT(STORVSC_DRV);
-
 		return -ENOMEM;
 	}
 
@@ -290,8 +271,6 @@ static int storvsc_probe(struct device *
 		DPRINT_ERR(STORVSC_DRV, "unable to add scsi vsc device");
 		kmem_cache_destroy(host_device_ctx->request_pool);
 		scsi_host_put(host);
-		DPRINT_EXIT(STORVSC_DRV);
-
 		return -1;
 	}
 
@@ -315,19 +294,14 @@ static int storvsc_probe(struct device *
 
 		kmem_cache_destroy(host_device_ctx->request_pool);
 		scsi_host_put(host);
-		DPRINT_EXIT(STORVSC_DRV);
-
 		return -1;
 	}
 
 	scsi_scan_host(host);
-
-	DPRINT_EXIT(STORVSC_DRV);
-
 	return ret;
 }
 
-/**
+/*
  * storvsc_remove - Callback when our device is removed
  */
 static int storvsc_remove(struct device *device)
@@ -339,19 +313,15 @@ static int storvsc_remove(struct device
 			(struct storvsc_driver_context *)driver_ctx;
 	struct storvsc_driver_object *storvsc_drv_obj =
 			&storvsc_drv_ctx->drv_obj;
-	struct device_context *device_ctx = device_to_device_context(device);
+	struct vm_device *device_ctx = device_to_vm_device(device);
 	struct hv_device *device_obj = &device_ctx->device_obj;
 	struct Scsi_Host *host = dev_get_drvdata(device);
 	struct host_device_context *host_device_ctx =
 			(struct host_device_context *)host->hostdata;
 
 
-	DPRINT_ENTER(STORVSC_DRV);
-
-	if (!storvsc_drv_obj->Base.OnDeviceRemove) {
-		DPRINT_EXIT(STORVSC_DRV);
+	if (!storvsc_drv_obj->Base.OnDeviceRemove)
 		return -1;
-	}
 
 	/*
 	 * Call to the vsc driver to let it know that the device is being
@@ -374,13 +344,10 @@ static int storvsc_remove(struct device
 
 	DPRINT_INFO(STORVSC, "releasing host adapter (%p)...", host);
 	scsi_host_put(host);
-
-	DPRINT_EXIT(STORVSC_DRV);
-
 	return ret;
 }
 
-/**
+/*
  * storvsc_commmand_completion - Command completion processing
  */
 static void storvsc_commmand_completion(struct hv_storvsc_request *request)
@@ -393,13 +360,11 @@ static void storvsc_commmand_completion(
 	void (*scsi_done_fn)(struct scsi_cmnd *);
 	struct scsi_sense_hdr sense_hdr;
 
-	ASSERT(request == &cmd_request->request);
-	ASSERT((unsigned long)scmnd->host_scribble ==
-		(unsigned long)cmd_request);
-	ASSERT(scmnd);
-	ASSERT(scmnd->scsi_done);
-
-	DPRINT_ENTER(STORVSC_DRV);
+	/* ASSERT(request == &cmd_request->request); */
+	/* ASSERT(scmnd); */
+	/* ASSERT((unsigned long)scmnd->host_scribble == */
+	/*        (unsigned long)cmd_request); */
+	/* ASSERT(scmnd->scsi_done); */
 
 	if (cmd_request->bounce_sgl_count) {
 		/* using bounce buffer */
@@ -421,7 +386,7 @@ static void storvsc_commmand_completion(
 			scsi_print_sense_hdr("storvsc", &sense_hdr);
 	}
 
-	ASSERT(request->BytesXfer <= request->DataBuffer.Length);
+	/* ASSERT(request->BytesXfer <= request->DataBuffer.Length); */
 	scsi_set_resid(scmnd, request->DataBuffer.Length - request->BytesXfer);
 
 	scsi_done_fn = scmnd->scsi_done;
@@ -433,8 +398,6 @@ static void storvsc_commmand_completion(
 	scsi_done_fn(scmnd);
 
 	kmem_cache_free(host_device_ctx->request_pool, cmd_request);
-
-	DPRINT_EXIT(STORVSC_DRV);
 }
 
 static int do_bounce_buffer(struct scatterlist *sgl, unsigned int sg_count)
@@ -530,7 +493,7 @@ static unsigned int copy_to_bounce_buffe
 		src = src_addr;
 		srclen = orig_sgl[i].length;
 
-		ASSERT(orig_sgl[i].offset + orig_sgl[i].length <= PAGE_SIZE);
+		/* ASSERT(orig_sgl[i].offset + orig_sgl[i].length <= PAGE_SIZE); */
 
 		if (bounce_addr == 0)
 			bounce_addr = (unsigned long)kmap_atomic(sg_page((&bounce_sgl[j])), KM_IRQ0);
@@ -591,7 +554,7 @@ static unsigned int copy_from_bounce_buf
 					KM_IRQ0) + orig_sgl[i].offset;
 		dest = dest_addr;
 		destlen = orig_sgl[i].length;
-		ASSERT(orig_sgl[i].offset + orig_sgl[i].length <= PAGE_SIZE);
+		/* ASSERT(orig_sgl[i].offset + orig_sgl[i].length <= PAGE_SIZE); */
 
 		if (bounce_addr == 0)
 			bounce_addr = (unsigned long)kmap_atomic(sg_page((&bounce_sgl[j])), KM_IRQ0);
@@ -631,7 +594,7 @@ static unsigned int copy_from_bounce_buf
 	return total_copied;
 }
 
-/**
+/*
  * storvsc_queuecommand - Initiate command processing
  */
 static int storvsc_queuecommand(struct scsi_cmnd *scmnd,
@@ -640,7 +603,7 @@ static int storvsc_queuecommand(struct s
 	int ret;
 	struct host_device_context *host_device_ctx =
 		(struct host_device_context *)scmnd->device->host->hostdata;
-	struct device_context *device_ctx = host_device_ctx->device_ctx;
+	struct vm_device *device_ctx = host_device_ctx->device_ctx;
 	struct driver_context *driver_ctx =
 		driver_to_driver_context(device_ctx->device.driver);
 	struct storvsc_driver_context *storvsc_drv_ctx =
@@ -654,8 +617,6 @@ static int storvsc_queuecommand(struct s
 	struct scatterlist *sgl;
 	unsigned int sg_count = 0;
 
-	DPRINT_ENTER(STORVSC_DRV);
-
 	DPRINT_DBG(STORVSC_DRV, "scmnd %p dir %d, use_sg %d buf %p len %d "
 		   "queue depth %d tagged %d", scmnd, scmnd->sc_data_direction,
 		   scsi_sg_count(scmnd), scsi_sglist(scmnd),
@@ -664,7 +625,7 @@ static int storvsc_queuecommand(struct s
 
 	/* If retrying, no need to prep the cmd */
 	if (scmnd->host_scribble) {
-		ASSERT(scmnd->scsi_done != NULL);
+		/* ASSERT(scmnd->scsi_done != NULL); */
 
 		cmd_request =
 			(struct storvsc_cmd_request *)scmnd->host_scribble;
@@ -674,8 +635,8 @@ static int storvsc_queuecommand(struct s
 		goto retry_request;
 	}
 
-	ASSERT(scmnd->scsi_done == NULL);
-	ASSERT(scmnd->host_scribble == NULL);
+	/* ASSERT(scmnd->scsi_done == NULL); */
+	/* ASSERT(scmnd->host_scribble == NULL); */
 
 	scmnd->scsi_done = done;
 
@@ -726,7 +687,7 @@ static int storvsc_queuecommand(struct s
 	request->TargetId = scmnd->device->id;
 	request->LunId = scmnd->device->lun;
 
-	ASSERT(scmnd->cmd_len <= 16);
+	/* ASSERT(scmnd->cmd_len <= 16); */
 	request->CdbLen = scmnd->cmd_len;
 	request->Cdb = scmnd->cmnd;
 
@@ -778,19 +739,17 @@ static int storvsc_queuecommand(struct s
 		request->DataBuffer.Offset = sgl[0].offset;
 
 		for (i = 0; i < sg_count; i++) {
-			DPRINT_DBG(STORVSC_DRV, "sgl[%d] len %d offset %d \n",
+			DPRINT_DBG(STORVSC_DRV, "sgl[%d] len %d offset %d\n",
 				   i, sgl[i].length, sgl[i].offset);
 			request->DataBuffer.PfnArray[i] =
-					page_to_pfn(sg_page((&sgl[i])));
+				page_to_pfn(sg_page((&sgl[i])));
 		}
 	} else if (scsi_sglist(scmnd)) {
-		ASSERT(scsi_bufflen(scmnd) <= PAGE_SIZE);
+		/* ASSERT(scsi_bufflen(scmnd) <= PAGE_SIZE); */
 		request->DataBuffer.Offset =
 			virt_to_phys(scsi_sglist(scmnd)) & (PAGE_SIZE-1);
 		request->DataBuffer.PfnArray[0] =
 			virt_to_phys(scsi_sglist(scmnd)) >> PAGE_SHIFT;
-	} else {
-		ASSERT(scsi_bufflen(scmnd) == 0);
 	}
 
 retry_request:
@@ -823,8 +782,6 @@ retry_request:
 		ret = SCSI_MLQUEUE_DEVICE_BUSY;
 	}
 
-	DPRINT_EXIT(STORVSC_DRV);
-
 	return ret;
 }
 
@@ -835,7 +792,7 @@ static int storvsc_merge_bvec(struct req
 	return bvec->bv_len;
 }
 
-/**
+/*
  * storvsc_device_configure - Configure the specified scsi device
  */
 static int storvsc_device_alloc(struct scsi_device *sdevice)
@@ -874,7 +831,7 @@ static int storvsc_device_configure(stru
 	return 0;
 }
 
-/**
+/*
  * storvsc_host_reset_handler - Reset the scsi HBA
  */
 static int storvsc_host_reset_handler(struct scsi_cmnd *scmnd)
@@ -882,231 +839,22 @@ static int storvsc_host_reset_handler(st
 	int ret;
 	struct host_device_context *host_device_ctx =
 		(struct host_device_context *)scmnd->device->host->hostdata;
-	struct device_context *device_ctx = host_device_ctx->device_ctx;
-	struct driver_context *driver_ctx =
-			driver_to_driver_context(device_ctx->device.driver);
-	struct storvsc_driver_context *storvsc_drv_ctx =
-			(struct storvsc_driver_context *)driver_ctx;
-
-	struct storvsc_driver_object *storvsc_drv_obj =
-			&storvsc_drv_ctx->drv_obj;
-
-	DPRINT_ENTER(STORVSC_DRV);
+	struct vm_device *device_ctx = host_device_ctx->device_ctx;
 
 	DPRINT_INFO(STORVSC_DRV, "sdev (%p) dev obj (%p) - host resetting...",
 		    scmnd->device, &device_ctx->device_obj);
 
 	/* Invokes the vsc to reset the host/bus */
-	ASSERT(storvsc_drv_obj->OnHostReset);
-	ret = storvsc_drv_obj->OnHostReset(&device_ctx->device_obj);
-	if (ret != 0) {
-		DPRINT_EXIT(STORVSC_DRV);
+	ret = StorVscOnHostReset(&device_ctx->device_obj);
+	if (ret != 0)
 		return ret;
-	}
 
 	DPRINT_INFO(STORVSC_DRV, "sdev (%p) dev obj (%p) - host reseted",
 		    scmnd->device, &device_ctx->device_obj);
 
-	DPRINT_EXIT(STORVSC_DRV);
-
 	return ret;
 }
 
-/**
- * storvsc_host_rescan - Rescan the scsi HBA
- */
-static void storvsc_host_rescan_callback(struct work_struct *work)
-{
-	struct hv_device *device_obj =
-	    &((struct host_device_context *)work)->device_ctx->device_obj;
-	struct device_context *device_ctx = to_device_context(device_obj);
-	struct Scsi_Host *host = dev_get_drvdata(&device_ctx->device);
-	struct scsi_device *sdev;
-	struct host_device_context *host_device_ctx;
-	struct scsi_device **sdevs_remove_list;
-	unsigned int sdevs_count = 0;
-	unsigned int found;
-	unsigned int i;
-	unsigned int lun_count = 0;
-	unsigned int *lun_list;
-
-	DPRINT_ENTER(STORVSC_DRV);
-
-	host_device_ctx = (struct host_device_context *)host->hostdata;
-	lun_list = kcalloc(STORVSC_MAX_LUNS_PER_TARGET, sizeof(unsigned int),
-			   GFP_ATOMIC);
-	if (!lun_list) {
-		DPRINT_ERR(STORVSC_DRV, "unable to allocate lun list");
-		return;
-	}
-
-	sdevs_remove_list = kcalloc(STORVSC_MAX_LUNS_PER_TARGET,
-				    sizeof(void *), GFP_ATOMIC);
-	if (!sdevs_remove_list) {
-		kfree(lun_list);
-		DPRINT_ERR(STORVSC_DRV, "unable to allocate lun remove list");
-		return;
-	}
-
-	DPRINT_INFO(STORVSC_DRV, "rescanning host for new scsi devices...");
-
-	/* Rescan for new device */
-	scsi_scan_target(&host->shost_gendev, host_device_ctx->path,
-			 host_device_ctx->target, SCAN_WILD_CARD, 1);
-
-	DPRINT_INFO(STORVSC_DRV, "rescanning host for removed scsi device...");
-
-	/* Use the 1st device to send the report luns cmd */
-	shost_for_each_device(sdev, host) {
-		lun_count = STORVSC_MAX_LUNS_PER_TARGET;
-		storvsc_report_luns(sdev, lun_list, &lun_count);
-
-		DPRINT_INFO(STORVSC_DRV,
-			    "report luns on scsi device (%p) found %u luns ",
-			    sdev, lun_count);
-		DPRINT_INFO(STORVSC_DRV,
-			    "existing luns on scsi device (%p) host (%d)",
-			    sdev, host->host_no);
-
-		scsi_device_put(sdev);
-		break;
-	}
-
-	for (i = 0; i < lun_count; i++)
-		DPRINT_INFO(STORVSC_DRV, "%d) lun %u", i, lun_list[i]);
-
-	/* Rescan for devices that may have been removed.
-	 * We do not have to worry that new devices may have been added since
-	 * this callback is serialized by the workqueue ie add/remove are done
-	 * here.
-	 */
-	shost_for_each_device(sdev, host) {
-		/* See if this device is still here */
-		found = 0;
-		for (i = 0; i < lun_count; i++) {
-			if (sdev->lun == lun_list[i]) {
-				found = 1;
-				break;
-			}
-		}
-		if (!found) {
-			DPRINT_INFO(STORVSC_DRV, "lun (%u) does not exists",
-				    sdev->lun);
-			sdevs_remove_list[sdevs_count++] = sdev;
-		}
-	}
-
-	/* Now remove the devices */
-	for (i = 0; i < sdevs_count; i++) {
-		DPRINT_INFO(STORVSC_DRV,
-			    "removing scsi device (%p) lun (%u)...",
-			    sdevs_remove_list[i], sdevs_remove_list[i]->lun);
-
-		/* make sure it is not removed from underneath us */
-		if (!scsi_device_get(sdevs_remove_list[i])) {
-			scsi_remove_device(sdevs_remove_list[i]);
-			scsi_device_put(sdevs_remove_list[i]);
-		}
-	}
-
-	DPRINT_INFO(STORVSC_DRV, "rescan completed on dev obj (%p) "
-		    "target (%u) bus (%u)", device_obj,
-		    host_device_ctx->target, host_device_ctx->path);
-
-	kfree(lun_list);
-	kfree(sdevs_remove_list);
-
-	DPRINT_EXIT(STORVSC_DRV);
-}
-
-static int storvsc_report_luns(struct scsi_device *sdev, unsigned int luns[],
-			       unsigned int *lun_count)
-{
-	int i, j;
-	unsigned int lun = 0;
-	unsigned int num_luns;
-	int result;
-	unsigned char *data;
-	struct scsi_sense_hdr sshdr;
-	unsigned char cmd[16] = {0};
-	/* Add 1 to cover the report_lun header */
-	unsigned int report_len = 8 * (STORVSC_MAX_LUNS_PER_TARGET+1);
-	unsigned long long *report_luns;
-	const unsigned int in_lun_count = *lun_count;
-
-	*lun_count = 0;
-
-	report_luns = kzalloc(report_len, GFP_ATOMIC);
-	if (!report_luns)
-		return -ENOMEM;
-
-	cmd[0] = REPORT_LUNS;
-
-	/* cmd length */
-	*(unsigned int *)&cmd[6] = cpu_to_be32(report_len);
-
-	result = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE,
-				  (unsigned char *)report_luns, report_len,
-				  &sshdr, 30 * HZ, 3, NULL);
-	if (result != 0) {
-		kfree(report_luns);
-		return -EBUSY;
-	}
-
-	/* get the length from the first four bytes */
-	report_len = be32_to_cpu(*(unsigned int *)&report_luns[0]);
-
-	num_luns = (report_len / sizeof(unsigned long long));
-	if (num_luns > in_lun_count) {
-		kfree(report_luns);
-		return -EINVAL;
-	}
-
-	*lun_count = num_luns;
-
-	DPRINT_DBG(STORVSC_DRV,
-		   "report luns on scsi device (%p) found %u luns ",
-		   sdev, num_luns);
-
-	/* lun id starts at 1 */
-	for (i = 1; i < num_luns + 1; i++) {
-		lun = 0;
-		data = (unsigned char *)&report_luns[i];
-		for (j = 0; j < sizeof(lun); j += 2) {
-			lun = lun | (((data[j] << 8) | data[j + 1]) <<
-				(j * 8));
-		}
-
-		luns[i-1] = lun;
-	}
-
-	kfree(report_luns);
-	return 0;
-}
-
-static void storvsc_host_rescan(struct hv_device *device_obj)
-{
-	struct device_context *device_ctx = to_device_context(device_obj);
-	struct Scsi_Host *host = dev_get_drvdata(&device_ctx->device);
-	struct host_device_context *host_device_ctx;
-
-	DPRINT_ENTER(STORVSC_DRV);
-
-	host_device_ctx = (struct host_device_context *)host->hostdata;
-
-	DPRINT_INFO(STORVSC_DRV, "initiating rescan on dev obj (%p) "
-		    "target (%u) bus (%u)...", device_obj,
-		    host_device_ctx->target, host_device_ctx->path);
-
-	/*
-	 * We need to queue this since the scanning may block and the caller
-	 * may be in an intr context
-	 */
-	/* scsi_queue_work(host, &host_device_ctx->host_rescan_work); */
-	schedule_work(&host_device_ctx->host_rescan_work);
-	DPRINT_EXIT(STORVSC_DRV);
-}
-
 static int storvsc_get_chs(struct scsi_device *sdev, struct block_device * bdev,
 			   sector_t capacity, int *info)
 {
@@ -1191,21 +939,18 @@ static int __init storvsc_init(void)
 {
 	int ret;
 
-	DPRINT_ENTER(STORVSC_DRV);
 	DPRINT_INFO(STORVSC_DRV, "Storvsc initializing....");
 	ret = storvsc_drv_init(StorVscInitialize);
-	DPRINT_EXIT(STORVSC_DRV);
 	return ret;
 }
 
 static void __exit storvsc_exit(void)
 {
-	DPRINT_ENTER(STORVSC_DRV);
 	storvsc_drv_exit();
-	DPRINT_ENTER(STORVSC_DRV);
 }
 
 MODULE_LICENSE("GPL");
-module_param(storvsc_ringbuffer_size, int, S_IRUGO);
+MODULE_VERSION(HV_DRV_VERSION);
+MODULE_DESCRIPTION("Microsoft Hyper-V virtual storage driver");
 module_init(storvsc_init);
 module_exit(storvsc_exit);
--- a/drivers/staging/hv/utils.h
+++ b/drivers/staging/hv/utils.h
@@ -18,54 +18,54 @@
  *   Haiyang Zhang <haiyangz@microsoft.com>
  *   Hank Janssen  <hjanssen@microsoft.com>
  */
-#ifndef _UTILS_H_
-#define _UTILS_H_
+#ifndef __HV_UTILS_H_
+#define __HV_UTILS_H_
 
 /*
  * Common header for Hyper-V ICs
  */
-#define ICMSGTYPE_NEGOTIATE   0
-#define ICMSGTYPE_HEARTBEAT   1
-#define ICMSGTYPE_KVPEXCHANGE 2
-#define ICMSGTYPE_SHUTDOWN    3
-#define ICMSGTYPE_TIMESYNC    4
-#define ICMSGTYPE_VSS         5
-
-#define ICMSGHDRFLAG_TRANSACTION 1
-#define ICMSGHDRFLAG_REQUEST     2
-#define ICMSGHDRFLAG_RESPONSE    4
-
-#define HV_S_OK                   0x00000000
-#define HV_E_FAIL                 0x80004005
-#define HV_ERROR_NOT_SUPPORTED    0x80070032
-#define HV_ERROR_MACHINE_LOCKED   0x800704F7
+#define ICMSGTYPE_NEGOTIATE		0
+#define ICMSGTYPE_HEARTBEAT		1
+#define ICMSGTYPE_KVPEXCHANGE		2
+#define ICMSGTYPE_SHUTDOWN		3
+#define ICMSGTYPE_TIMESYNC		4
+#define ICMSGTYPE_VSS			5
+
+#define ICMSGHDRFLAG_TRANSACTION	1
+#define ICMSGHDRFLAG_REQUEST		2
+#define ICMSGHDRFLAG_RESPONSE		4
+
+#define HV_S_OK				0x00000000
+#define HV_E_FAIL			0x80004005
+#define HV_ERROR_NOT_SUPPORTED		0x80070032
+#define HV_ERROR_MACHINE_LOCKED		0x800704F7
 
 struct vmbuspipe_hdr {
-    u32 flags;
-    u32 msgsize;
+	u32 flags;
+	u32 msgsize;
 } __attribute__((packed));
 
 struct ic_version {
-    u16 major;
-    u16 minor;
+	u16 major;
+	u16 minor;
 } __attribute__((packed));
 
 struct icmsg_hdr {
-    struct ic_version icverframe;
-    u16 icmsgtype;
-    struct ic_version icvermsg;
-    u16 icmsgsize;
-    u32 status;
-    u8 ictransaction_id;
-    u8 icflags;
-    u8 reserved[2];
+	struct ic_version icverframe;
+	u16 icmsgtype;
+	struct ic_version icvermsg;
+	u16 icmsgsize;
+	u32 status;
+	u8 ictransaction_id;
+	u8 icflags;
+	u8 reserved[2];
 } __attribute__((packed));
 
 struct icmsg_negotiate {
-    u16 icframe_vercnt;
-    u16 icmsg_vercnt;
-    u32 reserved;
-    struct ic_version icversion_data[1]; /* any size array */
+	u16 icframe_vercnt;
+	u16 icmsg_vercnt;
+	u32 reserved;
+	struct ic_version icversion_data[1]; /* any size array */
 } __attribute__((packed));
 
 struct shutdown_msg_data {
@@ -75,7 +75,33 @@ struct shutdown_msg_data {
 	u8  display_message[2048];
 } __attribute__((packed));
 
-#define HV_SHUTDOWN_MSG             0
+struct heartbeat_msg_data {
+	u64 seq_num;
+	u32 reserved[8];
+} __attribute__((packed));
+
+/* Time Sync IC defs */
+#define ICTIMESYNCFLAG_PROBE	0
+#define ICTIMESYNCFLAG_SYNC	1
+#define ICTIMESYNCFLAG_SAMPLE	2
+
+#ifdef __x86_64__
+#define WLTIMEDELTA	116444736000000000L	/* in 100ns unit */
+#else
+#define WLTIMEDELTA	116444736000000000LL
+#endif
+
+struct ictimesync_data{
+	u64 parenttime;
+	u64 childtime;
+	u64 roundtriptime;
+	u8 flags;
+} __attribute__((packed));
+
+/* Index for each IC struct in array hv_cb_utils[] */
+#define HV_SHUTDOWN_MSG		0
+#define HV_TIMESYNC_MSG		1
+#define HV_HEARTBEAT_MSG	2
 
 struct hyperv_service_callback {
 	u8 msg_type;
@@ -86,9 +112,8 @@ struct hyperv_service_callback {
 };
 
 extern void prep_negotiate_resp(struct icmsg_hdr *,
-				    struct icmsg_negotiate *, u8 *);
-extern void shutdown_linux_system(void);
+				struct icmsg_negotiate *, u8 *);
 extern void chn_cb_negotiate(void *);
 extern struct hyperv_service_callback hv_cb_utils[];
 
-#endif /* _UTILS_H_ */
+#endif /* __HV_UTILS_H_ */
--- a/drivers/staging/hv/vmbus.h
+++ b/drivers/staging/hv/vmbus.h
@@ -43,23 +43,23 @@ struct driver_context {
 	void (*shutdown)(struct device *);
 };
 
-struct device_context {
+struct vm_device {
 	struct work_struct probe_failed_work_item;
 	struct hv_guid class_id;
 	struct hv_guid device_id;
 	int probe_error;
-	struct device device;
 	struct hv_device device_obj;
+	struct device device;
 };
 
-static inline struct device_context *to_device_context(struct hv_device *d)
+static inline struct vm_device *to_vm_device(struct hv_device *d)
 {
-	return container_of(d, struct device_context, device_obj);
+	return container_of(d, struct vm_device, device_obj);
 }
 
-static inline struct device_context *device_to_device_context(struct device *d)
+static inline struct vm_device *device_to_vm_device(struct device *d)
 {
-	return container_of(d, struct device_context, device);
+	return container_of(d, struct vm_device, device);
 }
 
 static inline struct driver_context *driver_to_driver_context(struct device_driver *d)
--- a/drivers/staging/hv/vmbus_drv.c
+++ b/drivers/staging/hv/vmbus_drv.c
@@ -26,6 +26,8 @@
 #include <linux/sysctl.h>
 #include <linux/pci.h>
 #include <linux/dmi.h>
+#include <linux/slab.h>
+#include "VersionInfo.h"
 #include "osd.h"
 #include "logging.h"
 #include "vmbus.h"
@@ -49,7 +51,7 @@ struct vmbus_driver_context {
 	struct tasklet_struct event_dpc;
 
 	/* The bus root device */
-	struct device_context device_ctx;
+	struct vm_device device_ctx;
 };
 
 static int vmbus_match(struct device *device, struct device_driver *driver);
@@ -127,7 +129,7 @@ static struct vmbus_driver_context g_vmb
 	.bus.dev_attrs =	vmbus_device_attrs,
 };
 
-/**
+/*
  * vmbus_show_device_attr - Show the device attribute in sysfs.
  *
  * This is invoked when user does a
@@ -137,7 +139,7 @@ static ssize_t vmbus_show_device_attr(st
 				      struct device_attribute *dev_attr,
 				      char *buf)
 {
-	struct device_context *device_ctx = device_to_device_context(dev);
+	struct vm_device *device_ctx = device_to_vm_device(dev);
 	struct hv_device_info device_info;
 
 	memset(&device_info, 0, sizeof(struct hv_device_info));
@@ -231,28 +233,26 @@ static ssize_t vmbus_show_device_attr(st
 	}
 }
 
-/**
+/*
  * vmbus_bus_init -Main vmbus driver initialization routine.
  *
  * Here, we
- * 	- initialize the vmbus driver context
- * 	- setup various driver entry points
- * 	- invoke the vmbus hv main init routine
- * 	- get the irq resource
- * 	- invoke the vmbus to add the vmbus root device
- * 	- setup the vmbus root device
- * 	- retrieve the channel offers
+ *	- initialize the vmbus driver context
+ *	- setup various driver entry points
+ *	- invoke the vmbus hv main init routine
+ *	- get the irq resource
+ *	- invoke the vmbus to add the vmbus root device
+ *	- setup the vmbus root device
+ *	- retrieve the channel offers
  */
 static int vmbus_bus_init(int (*drv_init)(struct hv_driver *drv))
 {
 	struct vmbus_driver_context *vmbus_drv_ctx = &g_vmbus_drv;
 	struct vmbus_driver *vmbus_drv_obj = &g_vmbus_drv.drv_obj;
-	struct device_context *dev_ctx = &g_vmbus_drv.device_ctx;
+	struct vm_device *dev_ctx = &g_vmbus_drv.device_ctx;
 	int ret;
 	unsigned int vector;
 
-	DPRINT_ENTER(VMBUS_DRV);
-
 	/*
 	 * Set this up to allow lower layer to callback to add/remove child
 	 * devices on the bus
@@ -309,7 +309,7 @@ static int vmbus_bus_init(int (*drv_init
 	DPRINT_INFO(VMBUS_DRV, "irq 0x%x vector 0x%x", vmbus_irq, vector);
 
 	/* Call to bus driver to add the root device */
-	memset(dev_ctx, 0, sizeof(struct device_context));
+	memset(dev_ctx, 0, sizeof(struct vm_device));
 
 	ret = vmbus_drv_obj->Base.OnDeviceAdd(&dev_ctx->device_obj, &vector);
 	if (ret != 0) {
@@ -355,12 +355,10 @@ static int vmbus_bus_init(int (*drv_init
 	vmbus_drv_obj->GetChannelOffers();
 
 cleanup:
-	DPRINT_EXIT(VMBUS_DRV);
-
 	return ret;
 }
 
-/**
+/*
  * vmbus_bus_exit - Terminate the vmbus driver.
  *
  * This routine is opposite of vmbus_bus_init()
@@ -370,9 +368,7 @@ static void vmbus_bus_exit(void)
 	struct vmbus_driver *vmbus_drv_obj = &g_vmbus_drv.drv_obj;
 	struct vmbus_driver_context *vmbus_drv_ctx = &g_vmbus_drv;
 
-	struct device_context *dev_ctx = &g_vmbus_drv.device_ctx;
-
-	DPRINT_ENTER(VMBUS_DRV);
+	struct vm_device *dev_ctx = &g_vmbus_drv.device_ctx;
 
 	/* Remove the root device */
 	if (vmbus_drv_obj->Base.OnDeviceRemove)
@@ -390,22 +386,26 @@ static void vmbus_bus_exit(void)
 
 	tasklet_kill(&vmbus_drv_ctx->msg_dpc);
 	tasklet_kill(&vmbus_drv_ctx->event_dpc);
-
-	DPRINT_EXIT(VMBUS_DRV);
-
-	return;
 }
 
+
 /**
- * vmbus_child_driver_register - Register a vmbus's child driver
+ * vmbus_child_driver_register() - Register a vmbus's child driver
+ * @driver_ctx:        Pointer to driver structure you want to register
+ *
+ * @driver_ctx is of type &struct driver_context
+ *
+ * Registers the given driver with Linux through the 'driver_register()' call
+ * And sets up the hyper-v vmbus handling for this driver.
+ * It will return the state of the 'driver_register()' call.
+ *
+ * Mainly used by Hyper-V drivers.
  */
 int vmbus_child_driver_register(struct driver_context *driver_ctx)
 {
 	struct vmbus_driver *vmbus_drv_obj = &g_vmbus_drv.drv_obj;
 	int ret;
 
-	DPRINT_ENTER(VMBUS_DRV);
-
 	DPRINT_INFO(VMBUS_DRV, "child driver (%p) registering - name %s",
 		    driver_ctx, driver_ctx->driver.name);
 
@@ -416,34 +416,42 @@ int vmbus_child_driver_register(struct d
 
 	vmbus_drv_obj->GetChannelOffers();
 
-	DPRINT_EXIT(VMBUS_DRV);
-
 	return ret;
 }
 EXPORT_SYMBOL(vmbus_child_driver_register);
 
 /**
- * vmbus_child_driver_unregister Unregister a vmbus's child driver
+ * vmbus_child_driver_unregister() - Unregister a vmbus's child driver
+ * @driver_ctx:        Pointer to driver structure you want to un-register
+ *
+ * @driver_ctx is of type &struct driver_context
+ *
+ * Un-register the given driver with Linux through the 'driver_unregister()'
+ * call. And ungegisters the driver from the Hyper-V vmbus handler.
+ *
+ * Mainly used by Hyper-V drivers.
  */
 void vmbus_child_driver_unregister(struct driver_context *driver_ctx)
 {
-	DPRINT_ENTER(VMBUS_DRV);
-
 	DPRINT_INFO(VMBUS_DRV, "child driver (%p) unregistering - name %s",
 		    driver_ctx, driver_ctx->driver.name);
 
 	driver_unregister(&driver_ctx->driver);
 
 	driver_ctx->driver.bus = NULL;
-
-	DPRINT_EXIT(VMBUS_DRV);
 }
 EXPORT_SYMBOL(vmbus_child_driver_unregister);
 
 /**
- * vmbus_get_interface - Get the vmbus channel interface.
+ * vmbus_get_interface() - Get the vmbus channel interface.
+ * @interface: Pointer to channel interface structure
  *
- * This is invoked by child/client driver that sits above vmbus
+ * Get the Hyper-V channel used for the driver.
+ *
+ * @interface is of type &struct vmbus_channel_interface
+ * This is invoked by child/client driver that sits above vmbus.
+ *
+ * Mainly used by Hyper-V drivers.
  */
 void vmbus_get_interface(struct vmbus_channel_interface *interface)
 {
@@ -453,7 +461,7 @@ void vmbus_get_interface(struct vmbus_ch
 }
 EXPORT_SYMBOL(vmbus_get_interface);
 
-/**
+/*
  * vmbus_child_device_get_info - Get the vmbus child device info.
  *
  * This is invoked to display various device attributes in sysfs.
@@ -466,25 +474,22 @@ static void vmbus_child_device_get_info(
 	vmbus_drv_obj->GetChannelInfo(device_obj, device_info);
 }
 
-/**
- * vmbus_child_device_create - Creates and registers a new child device on the vmbus.
+/*
+ * vmbus_child_device_create - Creates and registers a new child device
+ * on the vmbus.
  */
 static struct hv_device *vmbus_child_device_create(struct hv_guid *type,
 						   struct hv_guid *instance,
 						   void *context)
 {
-	struct device_context *child_device_ctx;
+	struct vm_device *child_device_ctx;
 	struct hv_device *child_device_obj;
 
-	DPRINT_ENTER(VMBUS_DRV);
-
 	/* Allocate the new child device */
-	child_device_ctx = kzalloc(sizeof(struct device_context), GFP_KERNEL);
+	child_device_ctx = kzalloc(sizeof(struct vm_device), GFP_KERNEL);
 	if (!child_device_ctx) {
 		DPRINT_ERR(VMBUS_DRV,
 			"unable to allocate device_context for child device");
-		DPRINT_EXIT(VMBUS_DRV);
-
 		return NULL;
 	}
 
@@ -516,26 +521,22 @@ static struct hv_device *vmbus_child_dev
 	memcpy(&child_device_ctx->class_id, type, sizeof(struct hv_guid));
 	memcpy(&child_device_ctx->device_id, instance, sizeof(struct hv_guid));
 
-	DPRINT_EXIT(VMBUS_DRV);
-
 	return child_device_obj;
 }
 
-/**
+/*
  * vmbus_child_device_register - Register the child device on the specified bus
  */
 static int vmbus_child_device_register(struct hv_device *root_device_obj,
 				       struct hv_device *child_device_obj)
 {
 	int ret = 0;
-	struct device_context *root_device_ctx =
-				to_device_context(root_device_obj);
-	struct device_context *child_device_ctx =
-				to_device_context(child_device_obj);
+	struct vm_device *root_device_ctx =
+				to_vm_device(root_device_obj);
+	struct vm_device *child_device_ctx =
+				to_vm_device(child_device_obj);
 	static atomic_t device_num = ATOMIC_INIT(0);
 
-	DPRINT_ENTER(VMBUS_DRV);
-
 	DPRINT_DBG(VMBUS_DRV, "child device (%p) registering",
 		   child_device_ctx);
 
@@ -564,19 +565,16 @@ static int vmbus_child_device_register(s
 		DPRINT_INFO(VMBUS_DRV, "child device (%p) registered",
 			    &child_device_ctx->device);
 
-	DPRINT_EXIT(VMBUS_DRV);
-
 	return ret;
 }
 
-/**
- * vmbus_child_device_unregister - Remove the specified child device from the vmbus.
+/*
+ * vmbus_child_device_unregister - Remove the specified child device
+ * from the vmbus.
  */
 static void vmbus_child_device_unregister(struct hv_device *device_obj)
 {
-	struct device_context *device_ctx = to_device_context(device_obj);
-
-	DPRINT_ENTER(VMBUS_DRV);
+	struct vm_device *device_ctx = to_vm_device(device_obj);
 
 	DPRINT_INFO(VMBUS_DRV, "unregistering child device (%p)",
 		    &device_ctx->device);
@@ -589,21 +587,16 @@ static void vmbus_child_device_unregiste
 
 	DPRINT_INFO(VMBUS_DRV, "child device (%p) unregistered",
 		    &device_ctx->device);
-
-	DPRINT_EXIT(VMBUS_DRV);
 }
 
-/**
+/*
  * vmbus_child_device_destroy - Destroy the specified child device on the vmbus.
  */
 static void vmbus_child_device_destroy(struct hv_device *device_obj)
 {
-	DPRINT_ENTER(VMBUS_DRV);
-
-	DPRINT_EXIT(VMBUS_DRV);
 }
 
-/**
+/*
  * vmbus_uevent - add uevent for our device
  *
  * This routine is invoked when a device is added or removed on the vmbus to
@@ -612,11 +605,9 @@ static void vmbus_child_device_destroy(s
  */
 static int vmbus_uevent(struct device *device, struct kobj_uevent_env *env)
 {
-	struct device_context *device_ctx = device_to_device_context(device);
+	struct vm_device *device_ctx = device_to_vm_device(device);
 	int ret;
 
-	DPRINT_ENTER(VMBUS_DRV);
-
 	DPRINT_INFO(VMBUS_DRV, "generating uevent - VMBUS_DEVICE_CLASS_GUID={"
 		    "%02x%02x%02x%02x-%02x%02x-%02x%02x-"
 		    "%02x%02x%02x%02x%02x%02x%02x%02x}",
@@ -677,21 +668,17 @@ static int vmbus_uevent(struct device *d
 	if (ret)
 		return ret;
 
-	DPRINT_EXIT(VMBUS_DRV);
-
 	return 0;
 }
 
-/**
+/*
  * vmbus_match - Attempt to match the specified device to the specified driver
  */
 static int vmbus_match(struct device *device, struct device_driver *driver)
 {
 	int match = 0;
 	struct driver_context *driver_ctx = driver_to_driver_context(driver);
-	struct device_context *device_ctx = device_to_device_context(device);
-
-	DPRINT_ENTER(VMBUS_DRV);
+	struct vm_device *device_ctx = device_to_vm_device(device);
 
 	/* We found our driver ? */
 	if (memcmp(&device_ctx->class_id, &driver_ctx->class_id,
@@ -711,13 +698,10 @@ static int vmbus_match(struct device *de
 
 		match = 1;
 	}
-
-	DPRINT_EXIT(VMBUS_DRV);
-
 	return match;
 }
 
-/**
+/*
  * vmbus_probe_failed_cb - Callback when a driver probe failed in vmbus_probe()
  *
  * We need a callback because we cannot invoked device_unregister() inside
@@ -726,9 +710,7 @@ static int vmbus_match(struct device *de
  */
 static void vmbus_probe_failed_cb(struct work_struct *context)
 {
-	struct device_context *device_ctx = (struct device_context *)context;
-
-	DPRINT_ENTER(VMBUS_DRV);
+	struct vm_device *device_ctx = (struct vm_device *)context;
 
 	/*
 	 * Kick off the process of unregistering the device.
@@ -737,10 +719,9 @@ static void vmbus_probe_failed_cb(struct
 	device_unregister(&device_ctx->device);
 
 	/* put_device(&device_ctx->device); */
-	DPRINT_EXIT(VMBUS_DRV);
 }
 
-/**
+/*
  * vmbus_probe - Add the new vmbus's child device
  */
 static int vmbus_probe(struct device *child_device)
@@ -748,10 +729,8 @@ static int vmbus_probe(struct device *ch
 	int ret = 0;
 	struct driver_context *driver_ctx =
 			driver_to_driver_context(child_device->driver);
-	struct device_context *device_ctx =
-			device_to_device_context(child_device);
-
-	DPRINT_ENTER(VMBUS_DRV);
+	struct vm_device *device_ctx =
+			device_to_vm_device(child_device);
 
 	/* Let the specific open-source driver handles the probe if it can */
 	if (driver_ctx->probe) {
@@ -771,12 +750,10 @@ static int vmbus_probe(struct device *ch
 			   child_device->driver->name);
 		ret = -1;
 	}
-
-	DPRINT_EXIT(VMBUS_DRV);
 	return ret;
 }
 
-/**
+/*
  * vmbus_remove - Remove a vmbus device
  */
 static int vmbus_remove(struct device *child_device)
@@ -784,15 +761,12 @@ static int vmbus_remove(struct device *c
 	int ret;
 	struct driver_context *driver_ctx;
 
-	DPRINT_ENTER(VMBUS_DRV);
-
 	/* Special case root bus device */
 	if (child_device->parent == NULL) {
 		/*
 		 * No-op since it is statically defined and handle in
 		 * vmbus_bus_exit()
 		 */
-		DPRINT_EXIT(VMBUS_DRV);
 		return 0;
 	}
 
@@ -813,35 +787,28 @@ static int vmbus_remove(struct device *c
 		}
 	}
 
-	DPRINT_EXIT(VMBUS_DRV);
-
 	return 0;
 }
 
-/**
+/*
  * vmbus_shutdown - Shutdown a vmbus device
  */
 static void vmbus_shutdown(struct device *child_device)
 {
 	struct driver_context *driver_ctx;
 
-	DPRINT_ENTER(VMBUS_DRV);
-
 	/* Special case root bus device */
 	if (child_device->parent == NULL) {
 		/*
 		 * No-op since it is statically defined and handle in
 		 * vmbus_bus_exit()
 		 */
-		DPRINT_EXIT(VMBUS_DRV);
 		return;
 	}
 
 	/* The device may not be attached yet */
-	if (!child_device->driver) {
-		DPRINT_EXIT(VMBUS_DRV);
+	if (!child_device->driver)
 		return;
-	}
 
 	driver_ctx = driver_to_driver_context(child_device->driver);
 
@@ -849,75 +816,58 @@ static void vmbus_shutdown(struct device
 	if (driver_ctx->shutdown)
 		driver_ctx->shutdown(child_device);
 
-	DPRINT_EXIT(VMBUS_DRV);
-
 	return;
 }
 
-/**
+/*
  * vmbus_bus_release - Final callback release of the vmbus root device
  */
 static void vmbus_bus_release(struct device *device)
 {
-	DPRINT_ENTER(VMBUS_DRV);
 	/* FIXME */
 	/* Empty release functions are a bug, or a major sign
 	 * of a problem design, this MUST BE FIXED! */
 	dev_err(device, "%s needs to be fixed!\n", __func__);
 	WARN_ON(1);
-	DPRINT_EXIT(VMBUS_DRV);
 }
 
-/**
+/*
  * vmbus_device_release - Final callback release of the vmbus child device
  */
 static void vmbus_device_release(struct device *device)
 {
-	struct device_context *device_ctx = device_to_device_context(device);
-
-	DPRINT_ENTER(VMBUS_DRV);
+	struct vm_device *device_ctx = device_to_vm_device(device);
 
 	/* vmbus_child_device_destroy(&device_ctx->device_obj); */
 	kfree(device_ctx);
 
 	/* !!DO NOT REFERENCE device_ctx anymore at this point!! */
-	DPRINT_EXIT(VMBUS_DRV);
-
-	return;
 }
 
-/**
+/*
  * vmbus_msg_dpc - Tasklet routine to handle hypervisor messages
  */
 static void vmbus_msg_dpc(unsigned long data)
 {
 	struct vmbus_driver *vmbus_drv_obj = (struct vmbus_driver *)data;
 
-	DPRINT_ENTER(VMBUS_DRV);
-
-	ASSERT(vmbus_drv_obj->OnMsgDpc != NULL);
+	/* ASSERT(vmbus_drv_obj->OnMsgDpc != NULL); */
 
 	/* Call to bus driver to handle interrupt */
 	vmbus_drv_obj->OnMsgDpc(&vmbus_drv_obj->Base);
-
-	DPRINT_EXIT(VMBUS_DRV);
 }
 
-/**
+/*
  * vmbus_msg_dpc - Tasklet routine to handle hypervisor events
  */
 static void vmbus_event_dpc(unsigned long data)
 {
 	struct vmbus_driver *vmbus_drv_obj = (struct vmbus_driver *)data;
 
-	DPRINT_ENTER(VMBUS_DRV);
-
-	ASSERT(vmbus_drv_obj->OnEventDpc != NULL);
+	/* ASSERT(vmbus_drv_obj->OnEventDpc != NULL); */
 
 	/* Call to bus driver to handle interrupt */
 	vmbus_drv_obj->OnEventDpc(&vmbus_drv_obj->Base);
-
-	DPRINT_EXIT(VMBUS_DRV);
 }
 
 static irqreturn_t vmbus_isr(int irq, void *dev_id)
@@ -925,9 +875,7 @@ static irqreturn_t vmbus_isr(int irq, vo
 	struct vmbus_driver *vmbus_driver_obj = &g_vmbus_drv.drv_obj;
 	int ret;
 
-	DPRINT_ENTER(VMBUS_DRV);
-
-	ASSERT(vmbus_driver_obj->OnIsr != NULL);
+	/* ASSERT(vmbus_driver_obj->OnIsr != NULL); */
 
 	/* Call to bus driver to handle interrupt */
 	ret = vmbus_driver_obj->OnIsr(&vmbus_driver_obj->Base);
@@ -940,10 +888,8 @@ static irqreturn_t vmbus_isr(int irq, vo
 		if (test_bit(1, (unsigned long *)&ret))
 			tasklet_schedule(&g_vmbus_drv.event_dpc);
 
-		DPRINT_EXIT(VMBUS_DRV);
 		return IRQ_HANDLED;
 	} else {
-		DPRINT_EXIT(VMBUS_DRV);
 		return IRQ_NONE;
 	}
 }
@@ -963,10 +909,6 @@ MODULE_DEVICE_TABLE(dmi, microsoft_hv_dm
 
 static int __init vmbus_init(void)
 {
-	int ret = 0;
-
-	DPRINT_ENTER(VMBUS_DRV);
-
 	DPRINT_INFO(VMBUS_DRV,
 		"Vmbus initializing.... current log level 0x%x (%x,%x)",
 		vmbus_loglevel, HIWORD(vmbus_loglevel), LOWORD(vmbus_loglevel));
@@ -975,20 +917,13 @@ static int __init vmbus_init(void)
 	if (!dmi_check_system(microsoft_hv_dmi_table))
 		return -ENODEV;
 
-	ret = vmbus_bus_init(VmbusInitialize);
-
-	DPRINT_EXIT(VMBUS_DRV);
-	return ret;
+	return vmbus_bus_init(VmbusInitialize);
 }
 
 static void __exit vmbus_exit(void)
 {
-	DPRINT_ENTER(VMBUS_DRV);
-
 	vmbus_bus_exit();
 	/* Todo: it is used for loglevel, to be ported to new kernel. */
-	DPRINT_EXIT(VMBUS_DRV);
-	return;
 }
 
 /*
@@ -997,13 +932,14 @@ static void __exit vmbus_exit(void)
  * installed and/or configured.  We don't do anything else with the table, but
  * it needs to be present.
  */
-const static struct pci_device_id microsoft_hv_pci_table[] = {
+static const struct pci_device_id microsoft_hv_pci_table[] = {
 	{ PCI_DEVICE(0x1414, 0x5353) },	/* VGA compatible controller */
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, microsoft_hv_pci_table);
 
 MODULE_LICENSE("GPL");
+MODULE_VERSION(HV_DRV_VERSION);
 module_param(vmbus_irq, int, S_IRUGO);
 module_param(vmbus_loglevel, int, S_IRUGO);
 
--- a/drivers/staging/hv/vstorage.h
+++ b/drivers/staging/hv/vstorage.h
@@ -28,7 +28,7 @@
 #define REVISION_STRING(REVISION_) #REVISION_
 #define FILL_VMSTOR_REVISION(RESULT_LVALUE_)				\
 {									\
-	char *revisionString = REVISION_STRING($Revision: 6 $) + 11;	\
+	char *revisionString = REVISION_STRING($Revision : 6 $) + 11;	\
 	RESULT_LVALUE_ = 0;						\
 	while (*revisionString >= '0' && *revisionString <= '9') {	\
 		RESULT_LVALUE_ *= 10;					\
