From: NeilBrown <neilb@suse.de>
Subject: Allow re-adding to a failed RAID10 array
Patch-mainline: not for a while I expect
References: bnc#750995

This patch is still under-development.

It contains some fixes that should be folded into earlier md patches
The important part is in raid10.c.
This allows a drive to be successfully recovered if there is no
in-sync device to read the data from from, providing that the
device was recently in-sync itself.
This isn't guaranteed to only allow data into the array that
genuinely was valid, but it allows user-space to re-integrate
a device that it has reason to believe was valid recently enough.


Signed-off-by: Neil Brown <neilb@suse.de>

---
 drivers/md/md.c     |   30 ++++++++++++++++++------------
 drivers/md/raid10.c |    8 ++++++++
 2 files changed, 26 insertions(+), 12 deletions(-)

--- linux-3.0-SLE11-SP2.orig/drivers/md/md.c
+++ linux-3.0-SLE11-SP2/drivers/md/md.c
@@ -770,8 +770,6 @@ static void free_disk_sb(mdk_rdev_t * rd
 	}
 }
 
-static void md_error_force(mddev_t *mddev, mdk_rdev_t *rdev);
-
 static void super_written(struct bio *bio, int error)
 {
 	mdk_rdev_t *rdev = bio->bi_private;
@@ -781,13 +779,14 @@ static void super_written(struct bio *bi
 		printk("md: super_written gets error=%d, uptodate=%d\n",
 		       error, test_bit(BIO_UPTODATE, &bio->bi_flags));
 		WARN_ON(test_bit(BIO_UPTODATE, &bio->bi_flags));
-		md_error_force(mddev, rdev);
+		md_error(mddev, rdev);
 		if (!test_bit(Faulty, &rdev->flags)
 		    && (bio->bi_rw & REQ_FAILFAST_DEV)) {
 			set_bit(MD_NEED_REWRITE, &mddev->flags);
 			set_bit(LastDev, &rdev->flags);
 		}
-	}
+	} else
+		clear_bit(LastDev, &rdev->flags);
 
 	if (atomic_dec_and_test(&mddev->pending_writes))
 		wake_up(&mddev->sb_wait);
@@ -818,7 +817,7 @@ void md_super_write(mddev_t *mddev, mdk_
 	bio->bi_end_io = super_written;
 
 	if (test_bit(FailFast, &rdev->flags) &&
-	    !test_and_clear_bit(LastDev, &rdev->flags))
+	    !test_bit(LastDev, &rdev->flags))
 		ff = REQ_FAILFAST_DEV;
 
 	atomic_inc(&mddev->pending_writes);
@@ -2396,6 +2395,7 @@ repeat:
 		"md: updating %s RAID superblock on device (in sync %d)\n",
 		mdname(mddev),mddev->in_sync);
 
+rewrite:
 	bitmap_update_sb(mddev->bitmap);
 	list_for_each_entry(rdev, &mddev->disks, same_set) {
 		char b[BDEVNAME_SIZE];
@@ -2422,10 +2422,10 @@ repeat:
 			break;
 	}
 	if (md_super_wait(mddev) < 0)
-		goto repeat;
-	/* if there was a failure, MD_CHANGE_DEVS was set, and we re-write super */
+		goto rewrite;
 
 	spin_lock_irq(&mddev->write_lock);
+	/* if there was a failure, MD_CHANGE_DEVS was set, and we re-write super */
 	if (mddev->in_sync != sync_req ||
 	    test_bit(MD_CHANGE_DEVS, &mddev->flags)) {
 		/* have to write it out again */
@@ -2500,6 +2500,8 @@ state_show(mdk_rdev_t *rdev, char *page)
 	return len+sprintf(page+len, "\n");
 }
 
+static void md_error_force(mddev_t *mddev, mdk_rdev_t *rdev);
+
 static ssize_t
 state_store(mdk_rdev_t *rdev, const char *buf, size_t len)
 {
@@ -4897,7 +4899,8 @@ int md_run(mddev_t *mddev)
 	
 	set_bit(MD_RECOVERY_NEEDED, &mddev->recovery);
 	
-	if (mddev->flags)
+	if (test_bit(MD_CHANGE_DEVS, &mddev->flags) ||
+	    test_bit(MD_CHANGE_CLEAN, &mddev->flags))
 		md_update_sb(mddev, 0);
 
 	md_new_event(mddev);
@@ -5041,7 +5044,9 @@ static void __md_stop_writes(mddev_t *md
 		bitmap_flush(mddev);
 	while (md_super_wait(mddev) < 0);
 
-	if (!mddev->in_sync || mddev->flags) {
+	if (!mddev->in_sync ||
+	    test_bit(MD_CHANGE_DEVS, &mddev->flags) ||
+	    test_bit(MD_CHANGE_CLEAN, &mddev->flags)) {
 		/* mark array as shutdown cleanly */
 		mddev->in_sync = 1;
 		md_update_sb(mddev, 1);
@@ -7505,8 +7510,8 @@ void md_check_recovery(mddev_t *mddev)
 
 	if (mddev->ro && !test_bit(MD_RECOVERY_NEEDED, &mddev->recovery))
 		return;
-	if ( ! (
-		(mddev->flags & ~ (1<<MD_CHANGE_PENDING)) ||
+	if ( ! (test_bit(MD_CHANGE_DEVS, &mddev->flags) ||
+		test_bit(MD_CHANGE_CLEAN, &mddev->flags) ||
 		test_bit(MD_RECOVERY_NEEDED, &mddev->recovery) ||
 		test_bit(MD_RECOVERY_DONE, &mddev->recovery) ||
 		(mddev->external == 0 && mddev->safemode == 1) ||
@@ -7558,7 +7563,8 @@ void md_check_recovery(mddev_t *mddev)
 				sysfs_notify_dirent_safe(mddev->sysfs_state);
 		}
 
-		if (mddev->flags)
+		if (test_bit(MD_CHANGE_DEVS, &mddev->flags) ||
+		    test_bit(MD_CHANGE_CLEAN, &mddev->flags))
 			md_update_sb(mddev, 0);
 
 		if (test_bit(MD_RECOVERY_RUNNING, &mddev->recovery) &&
--- linux-3.0-SLE11-SP2.orig/drivers/md/raid10.c
+++ linux-3.0-SLE11-SP2/drivers/md/raid10.c
@@ -2236,6 +2236,14 @@ static sector_t sync_request(mddev_t *md
 				if (rb2)
 					atomic_dec(&rb2->remaining);
 				r10_bio = rb2;
+				if (!conf->fullsync)
+					/* This device is a re-add, so it
+					 * might have fairly recent data -
+					 * better to keep it than discard
+					 * the whole array.
+					 */
+					continue;
+
 				if (!test_and_set_bit(MD_RECOVERY_INTR,
 						      &mddev->recovery))
 					printk(KERN_INFO "md/raid10:%s: insufficient "
