From 986c6c923499efbf44f5b1f3249e6eac85c4920f Mon Sep 17 00:00:00 2001
From: Mel Gorman <mgorman@suse.de>
Date: Fri, 7 Mar 2014 15:50:51 +0000
Subject: [PATCH] mm: vmscan: Update rotated and scanned when force reclaimed

References: High memory utilisation performance (bnc#859225)
Patch-mainline: No (Requries posting and review)

When force reclaiming anon and file, the rotate and scanned figures are
not updated which confuses the prioritisation of anon/file aging for a
duration. This patch always updates the rotated and scanned figures when
necessary.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/vmscan.c |   66 +++++++++++++++++++++++++++++++++++-------------------------
 1 file changed, 39 insertions(+), 27 deletions(-)

--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -1870,6 +1870,7 @@
 	enum lru_list l;
 	int noswap = 0;
 	bool force_scan = false;
+	bool lru_locked = false;
 
 	/*
 	 * If the zone or memcg is small, nr[l] can be 0.  This
@@ -1896,6 +1897,33 @@
 		goto out;
 	}
 
+	anon  = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_ANON) +
+		zone_nr_lru_pages(zone, sc, LRU_INACTIVE_ANON);
+	file  = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_FILE) +
+		zone_nr_lru_pages(zone, sc, LRU_INACTIVE_FILE);
+
+	/*
+	 * Because workloads change over time (and to avoid overflow)
+	 * we keep these statistics as a floating average, which ends
+	 * up weighing recent references more than old ones.
+	 *
+	 * anon in [0], file in [1]
+	 */
+	if (unlikely(reclaim_stat->recent_scanned[0] > anon / 4) ||
+	    unlikely(reclaim_stat->recent_scanned[1] > file / 4)) {
+		spin_lock_irq(&zone->lru_lock);
+		lru_locked = true;
+		if (reclaim_stat->recent_scanned[0] > anon / 4) {
+			reclaim_stat->recent_scanned[0] /= 2;
+			reclaim_stat->recent_rotated[0] /= 2;
+		}
+
+		if (reclaim_stat->recent_scanned[1] > file / 4) {
+			reclaim_stat->recent_scanned[1] /= 2;
+			reclaim_stat->recent_rotated[1] /= 2;
+		}
+	}
+
 	if (scanning_global_lru(sc)) {
 		unsigned long zonefile;
 		unsigned long zonefree;
@@ -1912,7 +1940,7 @@
 			fraction[0] = 1;
 			fraction[1] = 0;
 			denominator = 1;
-			goto out;
+			goto out_unlock;
 		} else if (!inactive_file_is_low_global(zone)) {
 			/*
 			 * There is enough inactive page cache, do not
@@ -1921,7 +1949,7 @@
 			fraction[0] = 0;
 			fraction[1] = 1;
 			denominator = 1;
-			goto out;
+			goto out_unlock;
 		}
 	}
 
@@ -1932,35 +1960,17 @@
 	anon_prio = sc->swappiness;
 	file_prio = 200 - sc->swappiness;
 
+	/* lock only acquired if we updated rotation stats */
+	if (!lru_locked) {
+		spin_lock_irq(&zone->lru_lock);
+		lru_locked = true;
+	}
+
 	/*
 	 * OK, so we have swap space and a fair amount of page cache
 	 * pages.  We use the recently rotated / recently scanned
 	 * ratios to determine how valuable each cache is.
 	 *
-	 * Because workloads change over time (and to avoid overflow)
-	 * we keep these statistics as a floating average, which ends
-	 * up weighing recent references more than old ones.
-	 *
-	 * anon in [0], file in [1]
-	 */
-
-	anon  = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_ANON) +
-		zone_nr_lru_pages(zone, sc, LRU_INACTIVE_ANON);
-	file  = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_FILE) +
-		zone_nr_lru_pages(zone, sc, LRU_INACTIVE_FILE);
-
-	spin_lock_irq(&zone->lru_lock);
-	if (unlikely(reclaim_stat->recent_scanned[0] > anon / 4)) {
-		reclaim_stat->recent_scanned[0] /= 2;
-		reclaim_stat->recent_rotated[0] /= 2;
-	}
-
-	if (unlikely(reclaim_stat->recent_scanned[1] > file / 4)) {
-		reclaim_stat->recent_scanned[1] /= 2;
-		reclaim_stat->recent_rotated[1] /= 2;
-	}
-
-	/*
 	 * The amount of pressure on anon vs file pages is inversely
 	 * proportional to the fraction of recently scanned pages on
 	 * each list that were recently referenced and in active use.
@@ -1970,11 +1980,13 @@
 
 	fp = file_prio * (reclaim_stat->recent_scanned[1] + 1);
 	fp /= reclaim_stat->recent_rotated[1] + 1;
-	spin_unlock_irq(&zone->lru_lock);
 
 	fraction[0] = ap;
 	fraction[1] = fp;
 	denominator = ap + fp + 1;
+out_unlock:
+	if (lru_locked)
+		spin_unlock_irq(&zone->lru_lock);
 out:
 	for_each_evictable_lru(l) {
 		int file = is_file_lru(l);
