From: Petr Mladek <pmladek@suse.cz>
Date: Wed, 30 Jul 2014 11:34:13 +0200
Subject: kgr: handle patched modules that are being removed
Patch-mainline: submitted for review
References: fate#313296

kGraft allows to patch kernel modules. Such functions typically have disabled
the flag "abort_on_error". It allows to load the patch even before the affected
module.

This commit solves the situation when a patched module is being removed.
The patch might stay but the obsolete ftrace filters must be removed and
the status must be updated.

Everything has to be ready to patch the module when it is eventually loaded
back again.

The error handling is not ideal and will be improved in the future.

Also the support for handling the patch in progress will be added later. It will
need more tweaking.

Finally, the support for more patches against the same function will be added
later.

js: make kgr_module_exit_nb static (reported by Fengguang Wu
    <fengguang.wu@intel.com>)
js: fix !MODULES builds

Signed-off-by: Petr Mladek <pmladek@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 kernel/kgraft.c | 124 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 124 insertions(+)

diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 6bbe69523baa..fcc5e3d16663 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -634,8 +634,128 @@ void kgr_module_init(const struct module *mod)
 	mutex_unlock(&kgr_in_progress_lock);
 }
 
+/*
+ * Disable the patch immediately. It does not matter in which state it is.
+ *
+ * This function is used when a module is being removed and the code is
+ * no longer called.
+ */
+static int kgr_forced_code_patch_removal(struct kgr_patch_fun *patch_fun)
+{
+	struct ftrace_ops *ops;
+	int err;
+
+	switch (patch_fun->state) {
+	case KGR_PATCH_INIT:
+	case KGR_PATCH_SKIPPED:
+		return 0;
+	case KGR_PATCH_SLOW:
+	case KGR_PATCH_REVERT_SLOW:
+		ops = &patch_fun->ftrace_ops_slow;
+		break;
+	case KGR_PATCH_APPLIED:
+		ops = &patch_fun->ftrace_ops_fast;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = kgr_ftrace_disable(patch_fun, ops);
+	if (err) {
+		pr_warn("kgr: forced disabling of ftrace function for %s failed with %d\n",
+			patch_fun->name, err);
+		return err;
+	}
+
+	patch_fun->state = KGR_PATCH_SKIPPED;
+	pr_debug("kgr: forced disabling for %s done\n", patch_fun->name);
+	return 0;
+}
+
+/*
+ * Check the given patch and disable pieces related to the module
+ * that is being removed.
+ */
+static int kgr_handle_patch_for_going_module(struct kgr_patch *patch,
+					     const struct module *mod)
+{
+	struct kgr_patch_fun *patch_fun;
+	unsigned long addr;
+	int err = 0;
+
+	kgr_for_each_patch_fun(patch, patch_fun) {
+		addr = kallsyms_lookup_name(patch_fun->name);
+		if (!within_module(addr, mod))
+			continue;
+		/*
+		 * FIXME: It should schedule the patch removal or block
+		 *	  the module removal or taint kernel or so.
+		 */
+		if (patch_fun->abort_if_missing) {
+			pr_err("kgr: removing function %s that is required for the patch %s\n",
+			       patch_fun->name, patch->name);
+			err |= -EPERM;
+		}
+
+		err |= kgr_forced_code_patch_removal(patch_fun);
+	}
+
+	return err;
+}
+
+/*
+ * Disable patches for the module that is being removed.
+ *
+ * FIXME: The module removal cannot be stopped at this stage. All affected
+ * patches have to be removed. Therefore, the operation continues even in
+ * case of errors.
+ */
+static int kgr_handle_going_module(const struct module *mod)
+{
+	struct kgr_patch *p;
+	int err = 0;
+
+	/* Nope when kGraft has not been initialized yet */
+	if (!kgr_initialized)
+		return 0;
+
+	mutex_lock(&kgr_in_progress_lock);
+
+	list_for_each_entry(p, &patches, list)
+		err |= kgr_handle_patch_for_going_module(p, mod);
+
+	mutex_unlock(&kgr_in_progress_lock);
+
+	return err;
+}
+
+static int kgr_module_notify_exit(struct notifier_block *self,
+				  unsigned long val, void *data)
+{
+	const struct module *mod = data;
+	int err = 0;
+
+	if (val == MODULE_STATE_GOING)
+		err = kgr_handle_going_module(mod);
+
+	return err;
+}
+
+#else
+
+static int kgr_module_notify_exit(struct notifier_block *self,
+		unsigned long val, void *data)
+{
+	return 0;
+}
+
 #endif /* CONFIG_MODULES */
 
+static struct notifier_block kgr_module_exit_nb = {
+	.notifier_call = kgr_module_notify_exit,
+	.priority = 0,
+};
+
 static int __init kgr_init(void)
 {
 	int ret;
@@ -656,6 +776,10 @@ static int __init kgr_init(void)
 		goto err_remove_files;
 	}
 
+	ret = register_module_notifier(&kgr_module_exit_nb);
+	if (ret)
+		pr_warn("Failed to register kGraft module exit notifier\n");
+
 	kgr_initialized = true;
 	pr_info("kgr: successfully initialized\n");
 
-- 
2.0.4

