From: Hannes Reinecke <hare@suse.de>
Subject: DM-MPIO fails to tresspass LUNs on CLARiiON arrays
Reference: bnc#484529
Patch-mainline: not-yet

On Clariion arrays we fail to send the trespass command correctly.
We're trying to send the trespass command to via an disabled path,
causing the device handler to loop trying to send the command on
an invalid path.

Signed-off-by: Hannes Reinecke <hare@suse.de>

Index: linux-2.6.32-SLE11-SP1/drivers/md/dm-mpath.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/md/dm-mpath.c
+++ linux-2.6.32-SLE11-SP1/drivers/md/dm-mpath.c
@@ -462,6 +462,9 @@ static void process_queued_ios(struct wo
 		m->pg_init_count++;
 		m->pg_init_required = 0;
 		list_for_each_entry(tmp, &pgpath->pg->pgpaths, list) {
+			/* Skip disabled paths or failed paths */
+			if (!tmp->path.dev || !tmp->is_active)
+				continue;
 			if (queue_work(kmpath_handlerd, &tmp->activate_path))
 				m->pg_init_in_progress++;
 		}
@@ -1184,8 +1187,8 @@ static void pg_init_done(void *data, int
 			errors = 0;
 			break;
 		}
-		DMERR("Cannot failover device because scsi_dh_%s was not "
-		      "loaded.", m->hw_handler_name);
+		DMERR("Cannot failover device %s because scsi_dh_%s was not "
+		      "loaded.", pgpath->path.pdev, m->hw_handler_name);
 		/*
 		 * Fail path for now, so we do not ping pong
 		 */
@@ -1198,6 +1201,10 @@ static void pg_init_done(void *data, int
 		 */
 		bypass_pg(m, pg, 1);
 		break;
+	case SCSI_DH_DEV_OFFLINED:
+		DMWARN("Device %s offlined.", pgpath->path.pdev);
+		errors = 0;
+		break;
 	/* TODO: For SCSI_DH_RETRY we should wait a couple seconds */
 	case SCSI_DH_RETRY:
 	case SCSI_DH_IMM_RETRY:
@@ -1218,7 +1225,8 @@ static void pg_init_done(void *data, int
 	spin_lock_irqsave(&m->lock, flags);
 	if (errors) {
 		if (pgpath == m->current_pgpath) {
-			DMERR("Could not failover device. Error %d.", errors);
+			DMERR("Could not failover device %s, error %d.",
+			      pgpath->path.pdev, errors);
 			m->current_pgpath = NULL;
 			m->current_pg = NULL;
 		}
Index: linux-2.6.32-SLE11-SP1/drivers/md/dm-table.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/md/dm-table.c
+++ linux-2.6.32-SLE11-SP1/drivers/md/dm-table.c
@@ -407,14 +407,18 @@ static int upgrade_mode(struct dm_dev_in
 
 	dd_new = dd_old = *dd;
 
-	dd_new.dm_dev.mode |= new_mode;
+	dd_new.dm_dev.mode = new_mode;
 	dd_new.dm_dev.bdev = NULL;
 
 	r = open_dev(&dd_new, dd->dm_dev.bdev->bd_dev, md);
+	if (r == -EROFS) {
+		dd_new.dm_dev.mode &= ~FMODE_WRITE;
+		r = open_dev(&dd_new, dd->dm_dev.bdev->bd_dev, md);
+	}
 	if (r)
 		return r;
 
-	dd->dm_dev.mode |= new_mode;
+	dd->dm_dev.mode = new_mode;
 	close_dev(&dd_old, md);
 
 	return 0;
@@ -477,7 +481,7 @@ static int __table_get_device(struct dm_
 		atomic_set(&dd->count, 0);
 		list_add(&dd->list, &t->devices);
 
-	} else if (dd->dm_dev.mode != (mode | dd->dm_dev.mode)) {
+	} else if (dd->dm_dev.mode != mode) {
 		r = upgrade_mode(dd, mode, t->md);
 		if (r)
 			return r;
