From fb0527bd5ea99bfeb2dd91e3c1433ecf745d6b99 Mon Sep 17 00:00:00 2001
From: Peter Zijlstra <peterz@infradead.org>
Date: Wed, 29 Jan 2014 12:51:42 +0100
Subject: [PATCH] locking/mutexes: Introduce cancelable MCS lock for adaptive
 spinning
Patch-mainline: v3.15-rc1
Git-commit: fb0527bd5ea99bfeb2dd91e3c1433ecf745d6b99
References: FATE#317271

Since we want a task waiting for a mutex_lock() to go to sleep and
reschedule on need_resched() we must be able to abort the
mcs_spin_lock() around the adaptive spin.

Therefore implement a cancelable mcs lock.

Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Cc: chegu_vinod@hp.com
Cc: paulmck@linux.vnet.ibm.com
Cc: Waiman.Long@hp.com
Cc: torvalds@linux-foundation.org
Cc: tglx@linutronix.de
Cc: riel@redhat.com
Cc: akpm@linux-foundation.org
Cc: davidlohr@hp.com
Cc: hpa@zytor.com
Cc: andi@firstfloor.org
Cc: aswin@hp.com
Cc: scott.norton@hp.com
Cc: Jason Low <jason.low2@hp.com>
Link: http://lkml.kernel.org/n/tip-62hcl5wxydmjzd182zhvk89m@git.kernel.org
Signed-off-by: Ingo Molnar <mingo@kernel.org>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 kernel/mutex.c |  222 +++++++++++++++++++++++++++++++++++++++++++++------------
 1 file changed, 179 insertions(+), 43 deletions(-)

--- a/kernel/mutex.c
+++ b/kernel/mutex.c
@@ -23,6 +23,7 @@
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/debug_locks.h>
+#include <linux/percpu.h>
 
 /*
  * In the DEBUG case we are using the "NULL fastpath" for mutexes,
@@ -108,61 +109,197 @@ EXPORT_SYMBOL(mutex_lock);
  * In order to avoid a stampede of mutex spinners from acquiring the mutex
  * more or less simultaneously, the spinners need to acquire a MCS lock
  * first before spinning on the owner field.
- *
- * We don't inline mspin_lock() so that perf can correctly account for the
- * time spent in this lock function.
  */
 struct mspin_node {
 	struct mspin_node *next ;
 	int		  locked;	/* 1 if lock acquired */
 };
-#define	MLOCK(mutex)	((struct mspin_node **)&((mutex)->spin_mlock))
 
-static noinline
-void mspin_lock(struct mutex *mutex, struct mspin_node *node)
+/*
+ * Cancellable version of the MCS lock above.
+ *
+ * Intended for adaptive spinning of sleeping locks:
+ * mutex_lock()/rwsem_down_{read,write}() etc.
+ */
+struct optimistic_spin_queue {
+	struct optimistic_spin_queue *next, *prev;
+	int locked; /* 1 if lock acquired */
+};
+#define OSQ_LOCK(mutex)	((struct optimistic_spin_queue **)&((mutex)->spin_mlock))
+
+/*
+ * An MCS like lock especially tailored for optimistic spinning for sleeping
+ * lock implementations (mutex, rwsem, etc).
+ *
+ * Using a single mcs node per CPU is safe because sleeping locks should not be
+ * called from interrupt context and we have preemption disabled while
+ * spinning.
+ */
+static DEFINE_PER_CPU_SHARED_ALIGNED(struct optimistic_spin_queue, osq_node);
+
+/*
+ * Get a stable @node->next pointer, either for unlock() or unqueue() purposes.
+ * Can return NULL in case we were the last queued and we updated @lock instead.
+ */
+static inline struct optimistic_spin_queue *
+osq_wait_next(struct optimistic_spin_queue **lock,
+	      struct optimistic_spin_queue *node,
+	      struct optimistic_spin_queue *prev)
+{
+	struct optimistic_spin_queue *next = NULL;
+
+	for (;;) {
+		if (*lock == node && cmpxchg(lock, node, prev) == node) {
+			/*
+			 * We were the last queued, we moved @lock back. @prev
+			 * will now observe @lock and will complete its
+			 * unlock()/unqueue().
+			 */
+			break;
+		}
+
+		/*
+		 * We must xchg() the @node->next value, because if we were to
+		 * leave it in, a concurrent unlock()/unqueue() from
+		 * @node->next might complete Step-A and think its @prev is
+		 * still valid.
+		 *
+		 * If the concurrent unlock()/unqueue() wins the race, we'll
+		 * wait for either @lock to point to us, through its Step-B, or
+		 * wait for a new @node->next from its Step-C.
+		 */
+		if (node->next) {
+			next = xchg(&node->next, NULL);
+			if (next)
+				break;
+		}
+
+		arch_mutex_cpu_relax();
+	}
+
+	return next;
+}
+
+bool osq_lock(struct mutex *mutex, struct optimistic_spin_queue **lock)
 {
-	struct mspin_node *prev;
+	struct optimistic_spin_queue *node = this_cpu_ptr(&osq_node);
+	struct optimistic_spin_queue *prev, *next;
 
-	/* Init node */
 	node->locked = 0;
-	node->next   = NULL;
+	node->next = NULL;
 
-	prev = xchg(MLOCK(mutex), node);
+	prev = xchg(lock, node);
 	/*
-	 * An external kernel module may have a statically allocated mutex
-	 * initialized with the old initializer. As a result, a pointer to
-	 * wait_list should be treated as NULL.
+	 * In case the mutex is initialized with the DEFINE_MUTEX() macro,
+	 * the check below will correctly handle that initial value.
 	 */
-	if (unlikely(prev == (struct mspin_node *)&mutex->wait_list))
+	if (unlikely(prev == (struct optimistic_spin_queue *)&mutex->wait_list))
 		prev = NULL;
-	if (likely(prev == NULL)) {
-		/* Lock acquired */
-		node->locked = 1;
-		return;
-	}
+	node->prev = prev;
+	if (likely(prev == NULL))
+		return true;
+
 	ACCESS_ONCE(prev->next) = node;
-	smp_wmb();
-	/* Wait until the lock holder passes the lock down */
-	while (!ACCESS_ONCE(node->locked))
+
+	/*
+	 * Normally @prev is untouchable after the above store; because at that
+	 * moment unlock can proceed and wipe the node element from stack.
+	 *
+	 * However, since our nodes are static per-cpu storage, we're
+	 * guaranteed their existence -- this allows us to apply
+	 * cmpxchg in an attempt to undo our queueing.
+	 */
+
+	while (!node->locked) {
+		/*
+		 * If we need to reschedule bail... so we can block.
+		 */
+		if (need_resched())
+			goto unqueue;
+
 		arch_mutex_cpu_relax();
-}
+	}
+	return true;
 
-static void mspin_unlock(struct mutex *mutex, struct mspin_node *node)
-{
-	struct mspin_node *next = ACCESS_ONCE(node->next);
+unqueue:
+	/*
+	 * Step - A  -- stabilize @prev
+	 *
+	 * Undo our @prev->next assignment; this will make @prev's
+	 * unlock()/unqueue() wait for a next pointer since @lock points to us
+	 * (or later).
+	 */
+
+	for (;;) {
+		if (prev->next == node &&
+		    cmpxchg(&prev->next, node, NULL) == node)
+			break;
+
+		/*
+		 * We can only fail the cmpxchg() racing against an unlock(),
+		 * in which case we should observe @node->locked becomming
+		 * true.
+		 */
+		if (node->locked)
+			return true;
+
+		arch_mutex_cpu_relax();
 
-	if (likely(!next)) {
 		/*
-		 * Release the lock by setting it to NULL
+		 * Or we race against a concurrent unqueue()'s step-B, in which
+		 * case its step-C will write us a new @node->prev pointer.
 		 */
-		if (cmpxchg(MLOCK(mutex), node, NULL) == node)
-			return;
-		/* Wait until the next pointer is set */
-		while (!(next = ACCESS_ONCE(node->next)))
-			arch_mutex_cpu_relax();
+		prev = ACCESS_ONCE(node->prev);
+	}
+
+	/*
+	 * Step - B -- stabilize @next
+	 *
+	 * Similar to unlock(), wait for @node->next or move @lock from @node
+	 * back to @prev.
+	 */
+
+	next = osq_wait_next(lock, node, prev);
+	if (!next)
+		return false;
+
+	/*
+	 * Step - C -- unlink
+	 *
+	 * @prev is stable because its still waiting for a new @prev->next
+	 * pointer, @next is stable because our @node->next pointer is NULL and
+	 * it will wait in Step-A.
+	 */
+
+	ACCESS_ONCE(next->prev) = prev;
+	ACCESS_ONCE(prev->next) = next;
+
+	return false;
+}
+
+void osq_unlock(struct optimistic_spin_queue **lock)
+{
+	struct optimistic_spin_queue *node = this_cpu_ptr(&osq_node);
+	struct optimistic_spin_queue *next;
+
+	/*
+	 * Fast path for the uncontended case.
+	 */
+	if (likely(cmpxchg(lock, node, NULL) == node))
+		return;
+
+	/*
+	 * Second most likely case.
+	 */
+	next = xchg(&node->next, NULL);
+	if (next) {
+		ACCESS_ONCE(next->locked) = 1;
+		return;
 	}
-	ACCESS_ONCE(next->locked) = 1;
-	smp_wmb();
+
+	next = osq_wait_next(lock, node, NULL);
+	if (next)
+		ACCESS_ONCE(next->locked) = 1;
 }
 
 /**
@@ -188,8 +325,8 @@ static inline int mutex_can_spin_on_owne
 }
 #else /* CONFIG_MUTEX_SPIN_USE_MCS_QUEUE */
 
-#define mspin_lock(mutex, node) do { } while(0)
-#define mspin_unlock(mutex, node) do { } while(0)
+#define osq_lock(mutex, node) (1)
+#define osq_unlock(mutex) do { } while(0)
 #define mutex_can_spin_on_owner(a) (1)
 
 #endif /* CONFIG_MUTEX_SPIN_USE_MCS_QUEUE */
@@ -236,9 +373,6 @@ __mutex_lock_common(struct mutex *lock,
 	struct task_struct *task = current;
 	struct mutex_waiter waiter;
 	unsigned long flags;
-#ifdef CONFIG_MUTEX_SPIN_USE_MCS_QUEUE
-	struct mspin_node node;
-#endif
 
 	preempt_disable();
 	mutex_acquire_nest(&lock->dep_map, subclass, 0, nest_lock, ip);
@@ -270,7 +404,9 @@ __mutex_lock_common(struct mutex *lock,
 	if (!mutex_can_spin_on_owner(lock))
 		goto slowpath;
 
-	mspin_lock(lock, &node);
+	if (!osq_lock(lock, OSQ_LOCK(lock)))
+		goto slowpath;
+
 	for (;;) {
 		struct task_struct *owner;
 
@@ -286,7 +422,7 @@ __mutex_lock_common(struct mutex *lock,
 		    (atomic_cmpxchg(&lock->count, 1, 0) == 1)) {
 			lock_acquired(&lock->dep_map, ip);
 			mutex_set_owner(lock);
-			mspin_unlock(lock, &node);
+			osq_unlock(OSQ_LOCK(lock));
 			preempt_enable();
 			return 0;
 		}
@@ -308,7 +444,7 @@ __mutex_lock_common(struct mutex *lock,
 		 */
 		arch_mutex_cpu_relax();
 	}
-	mspin_unlock(lock, &node);
+	osq_unlock(OSQ_LOCK(lock));
 slowpath:
 #endif
 	spin_lock_mutex(&lock->wait_lock, flags);
