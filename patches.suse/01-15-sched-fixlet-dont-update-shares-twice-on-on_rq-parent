Subject: [patch 01/15] sched: (fixlet) dont update shares twice on on_rq
From: Paul Turner <pjt@google.com>
Date: Tue, 03 May 2011 02:28:47 -0700
Patch-mainline: no
References:

In dequeue_task_fair() we bail on dequeue when we encounter a parenting entity
with additional weight.  However, we perform a double shares update on this
entity since we continue the shares update traversal from that point, despite
dequeue_entity() having already updated its queuing cfs_rq.

Avoid this by starting from the parent when we resume.

Signed-off-by: Paul Turner <pjt@google.com>
Acked-by: Mike Galbraith <mgalbraith@suse.de>
---
 kernel/sched_fair.c |    7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

Index: linux-2.6.32-SLE11-SP2/kernel/sched_fair.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/kernel/sched_fair.c
+++ linux-2.6.32-SLE11-SP2/kernel/sched_fair.c
@@ -1309,12 +1309,15 @@ static void dequeue_task_fair(struct rq
 
 		/* Don't dequeue parent if it has other entities besides us */
 		if (cfs_rq->load.weight) {
+			/* Avoid pointless double update below. */
+			se = parent_entity(se);
+
 			/*
 			 * Bias pick_next to pick a task from this cfs_rq, as
 			 * p is sleeping when it is within its sched_slice.
 			 */
-			if (task_sleep && parent_entity(se))
-				set_next_buddy(parent_entity(se));
+			if (task_sleep && se)
+				set_next_buddy(se);
 			break;
 		}
 		flags |= DEQUEUE_SLEEP;
