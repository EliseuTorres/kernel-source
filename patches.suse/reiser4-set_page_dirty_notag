From: ReiserFS Development <reiserfs-devel@vger.namesys.com>
Subject: [PATCH] mm: Add set_page_dirty_notag() helper for reiser4

This patch adds a set_page_dirty_notag() helper which is like
set_page_dirty but doesn't add the pages to the radix tree.

Currently the only user is reiser4.

Acked-by: Jeff Mahoney <jeffm@suse.com>
---

 include/linux/mm.h  |    1 +
 mm/page-writeback.c |   26 ++++++++++++++++++++++++++
 2 files changed, 27 insertions(+)

--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -835,6 +835,7 @@ int redirty_page_for_writepage(struct wr
 void account_page_dirtied(struct page *page, struct address_space *mapping);
 int set_page_dirty(struct page *page);
 int set_page_dirty_lock(struct page *page);
+int set_page_dirty_notag(struct page *page);
 int clear_page_dirty_for_io(struct page *page);
 
 extern unsigned long move_page_tables(struct vm_area_struct *vma,
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -1142,6 +1142,32 @@ int __set_page_dirty_nobuffers(struct pa
 EXPORT_SYMBOL(__set_page_dirty_nobuffers);
 
 /*
+ * set_page_dirty_notag() -- similar to __set_page_dirty_nobuffers()
+ * except it doesn't tag the page dirty in the page-cache radix tree.
+ * This means that the address space using this cannot use the regular
+ * filemap ->writepages() helpers and must provide its own means of
+ * tracking and finding non-tagged dirty pages.
+ *
+ * NOTE: furthermore, this version also doesn't handle truncate races.
+ */
+int set_page_dirty_notag(struct page *page)
+{
+	struct address_space *mapping = page->mapping;
+
+	if (!TestSetPageDirty(page)) {
+		unsigned long flags;
+		WARN_ON_ONCE(!PagePrivate(page) && !PageUptodate(page));
+		local_irq_save(flags);
+		account_page_dirtied(page, mapping);
+		local_irq_restore(flags);
+		__mark_inode_dirty(mapping->host, I_DIRTY_PAGES);
+		return 1;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(set_page_dirty_notag);
+
+/*
  * When a writepage implementation decides that it doesn't want to write this
  * page for some reason, it should redirty the locked page via
  * redirty_page_for_writepage() and it should then unlock the page and return 0
