From: Rajashekhara, Mahesh <Mahesh_Rajashekhara@adaptec.com>
Date: Mon, 10 May 2010 04:17:57 -0700
Subject: [PATCH] [SCSI] aacraid: add support for handling ATA pass-through commands.
X-Git: 1fc8010a5d9a27391db2be103b13f4ac80990cfc
References: FATE#311692
Patch-Mainline: 2.6.34

There are two conditions for ATA pass thru command that falls into
'SRB_STATUS_ERROR' condition.

1. When the "CC" bit is set by the host in ATA pass-through CDB

   - Even for the successful completion, SCSI target shall generate
     check condition.

   - Driver returns a result code of SAM_STAT_CHECK_CONDITION, with a
     driver byte of DID_OK to the mid layer.

     Below is the snippet of existing code which fills a result code
     of SAM_STAT_CHECK_CONDITION:

	***********************************
	        if (le32_to_cpu(srbreply->scsi_status) == SAM_STAT_CHECK_CONDITION) {
                		int len;
	               		scsicmd->result |= SAM_STAT_CHECK_CONDITION;
			..........
	************************************

2. When the "CC" bit is reset by the host and if SCSI target generates
   a check condition when an error occurs.

   - Driver returns a result code of SAM_STAT_CHECK_CONDITION, with a
     driver byte of DID_ERROR to the mid layer.

Signed-off-by: Mahesh Rajashekhara <aacraid@adaptec.com>
Signed-off-by: James Bottomley <James.Bottomley@suse.de>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/aacraid/aachba.c |   18 ++++++++++++++++--
 1 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/drivers/scsi/aacraid/aachba.c b/drivers/scsi/aacraid/aachba.c
index 37e6fdc..a6ef2a6 100644
--- a/drivers/scsi/aacraid/aachba.c
+++ b/drivers/scsi/aacraid/aachba.c
@@ -2738,8 +2738,22 @@ static void aac_srb_callback(void *context, struct fib * fibptr)
 			scsicmd->cmnd[0],
 			le32_to_cpu(srbreply->scsi_status));
 #endif
-		scsicmd->result = DID_ERROR << 16 | COMMAND_COMPLETE << 8;
-		break;
+		if ((scsicmd->cmnd[0] == ATA_12)
+		  || (scsicmd->cmnd[0] == ATA_16)) {
+			if (scsicmd->cmnd[2] & (0x01 << 5)) {
+				scsicmd->result = DID_OK << 16
+						| COMMAND_COMPLETE << 8;
+				break;
+			} else {
+				scsicmd->result = DID_ERROR << 16
+						| COMMAND_COMPLETE << 8;
+				break;
+			}
+		} else {
+			scsicmd->result = DID_ERROR << 16
+					| COMMAND_COMPLETE << 8;
+			break;
+		}
 	}
 	if (le32_to_cpu(srbreply->scsi_status) == SAM_STAT_CHECK_CONDITION) {
 		int len;
-- 
1.6.0.2

