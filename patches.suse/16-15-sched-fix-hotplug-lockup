Subject: Re: Test for CFS Bandwidth Control V6 ([patch 16/16] fix hotplug lockup)
From: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date: Tue, 24 May 2011 09:53:45 +0900
Patch-mainline: no
References:

Hi Paul and Xiao,

Please check/test a fix at the foot of this mail.

(2011/05/20 11:12), Xiao Guangrong wrote:
> Hi Paul,
> 
> I'm so sorry for sending this mail in the new thread, since i didn't
> receive your V6 patchset from LKML.
> 
> It seams the patchset can not be applied, since it's conflict between
> patch 3 and patch 5:
> 
> ========Quote========
(snip)
> ========End quote========

Maybe I've fixed it by hand, or git-am is so wonderful.

I believe Paul will do it right for next time.

> 
> I downloaded the patchset from Internet, i missed the newer version?
> 
> I have done some test after fixed the conflict by handle, below test can cause
> box crash:
> 
> ========Quote　cpu_hotlpug.sh ========
(snip)
> ======== End quote　cpu_hotlpug.sh ========
> 
> Sorry to disturb you if the bug is know.
> 
> Thanks!

Thank you for reporting it, Xiao!

I confirmed that running your test cause hung-up on my box.
And after some investigation, I found that this is an infinite loop
in migrate_task() due to miscalculation of rq->nr_running; when a
task is queued to throttled entity the nr_running is incremented at
the queuing and also the unthrottling.

I made a fix for this bug and it seems works well for me.
Could you try this patch and give us your feedback, Xiao?

Acked-by: Mike Galbraith <mgalbraith@suse.de>

---
 kernel/sched_fair.c |   28 +++++++++++++---------------
 1 file changed, 13 insertions(+), 15 deletions(-)

Index: linux-2.6.32-SLE11-SP2/kernel/sched_fair.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/kernel/sched_fair.c
+++ linux-2.6.32-SLE11-SP2/kernel/sched_fair.c
@@ -1482,7 +1482,7 @@ static void unthrottle_cfs_rq(struct cfs
 	walk_tg_tree_from(cfs_rq->tg, tg_unthrottle_down, tg_nop,
 			  (void *)&udd);
 
-	if (!cfs_rq->load.weight)
+	if (!cfs_rq->h_nr_running)
 		return;
 
 	task_delta = cfs_rq->h_nr_running;
@@ -1787,10 +1787,9 @@ enqueue_task_fair(struct rq *rq, struct
 		cfs_rq->h_nr_running++;
 
 		/* end evaluation on throttled cfs_rq */
-		if (cfs_rq_throttled(cfs_rq)) {
-			se = NULL;
-			break;
-		}
+		if (cfs_rq_throttled(cfs_rq))
+			goto done;
+
 		flags = ENQUEUE_WAKEUP;
 	}
 
@@ -1799,14 +1798,14 @@ enqueue_task_fair(struct rq *rq, struct
 		cfs_rq->h_nr_running++;
 
 		if (cfs_rq_throttled(cfs_rq))
-			break;
+			goto done;
 
 		update_cfs_load(cfs_rq, 0);
 		update_cfs_shares(cfs_rq);
 	}
 
-	if (!se)
-		inc_nr_running(rq);
+	inc_nr_running(rq);
+done:
 	hrtick_update(rq);
 }
 
@@ -1829,10 +1828,9 @@ static void dequeue_task_fair(struct rq
 		cfs_rq->h_nr_running--;
 
 		/* end evaluation on throttled cfs_rq */
-		if (cfs_rq_throttled(cfs_rq)) {
-			se = NULL;
-			break;
-		}
+		if (cfs_rq_throttled(cfs_rq))
+			goto done;
+
 		/* Don't dequeue parent if it has other entities besides us */
 		if (cfs_rq->load.weight) {
 			/* Avoid pointless double update below. */
@@ -1854,14 +1852,14 @@ static void dequeue_task_fair(struct rq
 		cfs_rq->h_nr_running--;
 
 		if (cfs_rq_throttled(cfs_rq))
-			break;
+			goto done;
 
 		update_cfs_load(cfs_rq, 0);
 		update_cfs_shares(cfs_rq);
 	}
 
-	if (!se)
-		dec_nr_running(rq);
+	dec_nr_running(rq);
+done:
 	hrtick_update(rq);
 }
 
