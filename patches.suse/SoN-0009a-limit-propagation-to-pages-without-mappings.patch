From: Mel Gorman <mgorman@suse.de>
Date: Thu, 13 Oct 2011 12:05:52 +0100
Subject: [PATCH] netvm: Limit propagation of page->pfmemalloc to pages without mappings
References: Swap over NFS (fate#304949, bnc#718352)
Patch-mainline: Not yet, merging efforts ongoing

Pages with mappings can page->index set overwriting page->pfmemalloc.
Avoid this as it can cause skbs to be improperly marked pfmemalloc causing
them to be filtered later and the packets lost. The patch also checks for
the unlikely situation that the page has been invalided has been truncated
but has clean buffers. It is never expected that such a page would be the
target for RX receive so the check may be excessively paranoid.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 include/linux/skbuff.h |   14 ++++++++++++--
 1 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 9f44101..b945cb8 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -1124,8 +1124,21 @@ static inline void skb_fill_page_desc(struct sk_buff *skb, int i,
 {
 	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
 
-	if (page->pfmemalloc)
-		skb->pfmemalloc	  = true;
+	/*
+	 * Propagate page->pfmemalloc to the skb if we can. The problem is
+	 * that not all callers have unique ownership of the page. If
+	 * pfmemalloc is set, we check the mapping to see if it could be
+	 * because page->index is set (index and pfmemalloc share space).
+	 * If it's a valid mapping, we cannot use page->pfmemalloc but we
+	 * do not lose pfmemalloc information as the pages would not be
+	 * allocated using __GFP_MEMALLOC. We also have to check if the
+	 * outside possibility that the page has buffers (PagePrivate)
+	 * with a NULL mapping. This normally happens for invalidated
+	 * pages that should never be used for network RX but there is
+	 * no harm is guarding against the possibility.
+	 */
+	if (page->pfmemalloc && !page->mapping && !PagePrivate(page))
+		skb->pfmemalloc	= true;
 	frag->page		  = page;
 	frag->page_offset	  = off;
 	frag->size		  = size;
