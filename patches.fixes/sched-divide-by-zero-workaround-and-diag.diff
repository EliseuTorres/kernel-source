From: Mike Galbraith <mgalbraith@suse.de>
Date: Mon Dec  6 11:25:16 CET 2010
Subject: sched: debug divide by zero bug in find_busiest_group()
Patch-mainline: never
References: bnc#630970, bnc#661605

Based on patchlet from PeterZ.

Code inspection reveals nothing, the bug is not repeatable, yet some
customer boxen are exploding at random intervals varying from weeks to
months between events.  This has also been reported against mainline.

Let's not explode, and try to get some useful info.

Signed-off-by: Mike Galbraith <mgalbraith@suse.de>
---
 kernel/sched.c |   61 +++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 59 insertions(+), 2 deletions(-)

Index: linux-2.6.32-SLE11-SP1/kernel/sched.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/kernel/sched.c
+++ linux-2.6.32-SLE11-SP1/kernel/sched.c
@@ -3805,6 +3805,7 @@ static void update_cpu_power(struct sche
 	unsigned long weight = sd->span_weight;
 	unsigned long power = SCHED_LOAD_SCALE;
 	struct sched_group *sdg = sd->groups;
+	unsigned long scale_rt;
 
 	if (sched_feat(ARCH_POWER))
 		power *= arch_scale_freq_power(sd, cpu);
@@ -3822,12 +3823,22 @@ static void update_cpu_power(struct sche
 		power >>= SCHED_LOAD_SHIFT;
 	}
 
-	power *= scale_rt_power(cpu);
+	scale_rt = scale_rt_power(cpu);
+	power *= scale_rt;
 	power >>= SCHED_LOAD_SHIFT;
 
 	if (!power)
 		power = 1;
 
+	if ((int)power <= 0) {
+		if (printk_ratelimit()) {
+			WARN_ON_ONCE(1);
+			printk(KERN_ERR "update_cpu_power: cpu_power = %lu; scale_rt = %lu\n",
+					power, scale_rt);
+		}
+		power = 1;
+	}
+
 	cpu_rq(cpu)->cpu_power = power;
 	sdg->cpu_power = power;
 }
@@ -3851,6 +3862,12 @@ static void update_group_power(struct sc
 		group = group->next;
 	} while (group != child->groups);
 
+	if ((int)power <= 0) {
+		WARN_ON_ONCE(1);
+		printk(KERN_ERR "update_group_power: cpu_power = %lu\n", power);
+		power = 1;
+	}
+
 	sdg->cpu_power = power;
 }
 
@@ -3932,6 +3949,14 @@ static inline void update_sg_lb_stats(st
 		return;
 	}
 
+	if ((int)group->cpu_power <= 0) {
+		if (printk_ratelimit()) {
+			WARN_ON_ONCE(1);
+			printk(KERN_ERR "update_sg_lb_stats: group->cpu_power = %d\n", group->cpu_power);
+		}
+		return;
+	}
+
 	/* Adjust by relative CPU power of the group */
 	sgs->avg_load = (sgs->group_load * SCHED_LOAD_SCALE) / group->cpu_power;
 
@@ -3986,6 +4011,12 @@ static inline void update_sd_lb_stats(st
 	do {
 		int local_group;
 
+		/* this has been observed to happen during 'init 0' power down */
+		if (!group) {
+			WARN_ON_ONCE(1);
+			return;
+		}
+
 		local_group = cpumask_test_cpu(this_cpu,
 					       sched_group_cpus(group));
 		memset(&sgs, 0, sizeof(sgs));
@@ -4063,6 +4094,16 @@ static inline void fix_small_imbalance(s
 
 	scaled_busy_load_per_task = sds->busiest_load_per_task
 						 * SCHED_LOAD_SCALE;
+
+	if ((int)sds->busiest->cpu_power <= 0) {
+		if (printk_ratelimit()) {
+			WARN_ON_ONCE(1);
+			printk(KERN_ERR "fix_small_imbalance: sds->busiest->cpu_power = %d\n",
+				sds->busiest->cpu_power);
+		}
+		return;
+	}
+
 	scaled_busy_load_per_task /= sds->busiest->cpu_power;
 
 	if (sds->max_load - sds->this_load + scaled_busy_load_per_task >=
@@ -4119,7 +4160,9 @@ static inline void calculate_imbalance(s
 {
 	unsigned long max_pull, load_above_capacity = ~0UL;
 
-	sds->busiest_load_per_task /= sds->busiest_nr_running;
+	WARN_ON_ONCE(!sds->busiest_nr_running);
+
+	sds->busiest_load_per_task /= (sds->busiest_nr_running?: 1);
 	if (sds->group_imb) {
 		sds->busiest_load_per_task =
 			min(sds->busiest_load_per_task, sds->avg_load);
@@ -4144,6 +4187,15 @@ static inline void calculate_imbalance(s
 
 		load_above_capacity *= (SCHED_LOAD_SCALE * SCHED_LOAD_SCALE);
 
+		if ((int)sds->busiest->cpu_power <= 0) {
+			if (printk_ratelimit()) {
+				WARN_ON_ONCE(1);
+				printk(KERN_ERR "calculate_imbalance: sds->busiest->cpu_power = %d\n",
+						sds->busiest->cpu_power);
+			}
+			return;
+		}
+
 		load_above_capacity /= sds->busiest->cpu_power;
 	}
 
@@ -4246,6 +4298,11 @@ find_busiest_group(struct sched_domain *
 	if (sds.this_load >= sds.max_load)
 		goto out_balanced;
 
+	if (unlikely(sds.total_pwr == 0)) {
+		sds.total_pwr = 1;
+		WARN_ON_ONCE(1);
+	}
+
 	sds.avg_load = (SCHED_LOAD_SCALE * sds.total_load) / sds.total_pwr;
 
 	if (sds.this_load >= sds.avg_load)
