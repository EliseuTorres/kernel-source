From: Trond Myklebust <Trond.Myklebust@netapp.com>
Date: Sun, 6 May 2012 19:46:30 -0400
Subject:  NFSv4: nfs_client_return_marked_delegations can't flush data
Git-commit: dc327ed4cd320be689596365372a3683208c3ba0
Patch-mainline: v3.5
References: bnc#864404

Since even filemap_flush() needs to lock pages that are dirty, we
cannot risk calling it from the state manager context. Therefore,
we need to move the call to filemap_flush() to
nfs_async_inode_return_delegation().

Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/nfs/delegation.c |   10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

--- linux-3.0-SLE11-SP3.orig/fs/nfs/delegation.c
+++ linux-3.0-SLE11-SP3/fs/nfs/delegation.c
@@ -315,6 +315,10 @@ out:
  * nfs_client_return_marked_delegations - return previously marked delegations
  * @clp: nfs_client to process
  *
+ * Note that this function is designed to be called by the state
+ * manager thread. For this reason, it cannot flush the dirty data,
+ * since that could deadlock in case of a state recovery error.
+ *
  * Returns zero on success, or a negative errno value.
  */
 int nfs_client_return_marked_delegations(struct nfs_client *clp)
@@ -339,11 +343,9 @@ restart:
 								server);
 			rcu_read_unlock();
 
-			if (delegation != NULL) {
-				filemap_flush(inode->i_mapping);
+			if (delegation != NULL)
 				err = __nfs_inode_return_delegation(inode,
 								delegation, 0);
-			}
 			iput(inode);
 			if (!err)
 				goto restart;
@@ -553,6 +555,8 @@ int nfs_async_inode_return_delegation(st
 	struct nfs_client *clp = server->nfs_client;
 	struct nfs_delegation *delegation;
 
+	filemap_flush(inode->i_mapping);
+
 	rcu_read_lock();
 	delegation = rcu_dereference(NFS_I(inode)->delegation);
 
