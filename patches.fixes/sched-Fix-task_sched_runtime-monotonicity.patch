Subject: sched: Fix clock_gettime(CLOCK_[PROCESS/THREAD]_CPUTIME_ID) monotonicity
From: Mike Galbraith <mgalbraith@suse.de>
Date: Mon Jun 16 11:01:34 CEST 2014
Patch-mainline: not yet, submitted
References: bnc#880357

If a task has been dequeued, it has been accounted.  Do not project
cycles that may or may not ever be accounted to a dequeued task, as
that may make clock_gettime() both inaccurate and non-monotonic.

Protect update_rq_clock() from slight TSC skew while at it.

Signed-off-by:  Mike Galbraith <mgalbraith@suse.de>
---
 kernel/sched.c |    9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -819,6 +819,8 @@ static void update_rq_clock(struct rq *r
 		return;
 
 	delta = sched_clock_cpu(cpu_of(rq)) - rq->clock;
+	if (delta < 0)
+		return;
 	rq->clock += delta;
 	update_rq_clock_task(rq, delta);
 }
@@ -3897,7 +3899,12 @@ static u64 do_task_delta_exec(struct tas
 {
 	u64 ns = 0;
 
-	if (task_current(rq, p)) {
+	/*
+	 * Must be ->curr, ->on_cpu _and_ ->on_rq.  If dequeued, we
+	 * would project cycles that may never be accounted to this
+	 * thread, breaking clock_gettime().
+	 */
+	if (task_current(rq, p) && p->on_cpu && p->on_rq) {
 		update_rq_clock(rq);
 		ns = rq->clock_task - p->se.exec_start;
 		if ((s64)ns < 0)
