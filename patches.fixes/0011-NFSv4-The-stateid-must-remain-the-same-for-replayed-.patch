From: Trond Myklebust <Trond.Myklebust@netapp.com>
Date: Sun, 17 Mar 2013 15:52:00 -0400
Subject: [PATCH] NFSv4: The stateid must remain the same for replayed RPC
 calls
Git-commit: 9b20614988199fb03580b335a28250922e902098
Patch-mainline: v3.10
References: bnc#888968

If we replay a READ or WRITE call, we should not be changing the
stateid. Currently, we may end up doing so, because the stateid
is only selected at xdr encode time.

This patch ensures that we select the stateid after we get an NFSv4.1
session slot, and that we keep that same stateid across retries.

Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/nfs/nfs4_fs.h        |    4 ++++
 fs/nfs/nfs4filelayout.c |    4 ++++
 fs/nfs/nfs4proc.c       |   17 +++++++++++++++++
 fs/nfs/nfs4xdr.c        |   28 ++--------------------------
 fs/nfs/read.c           |    3 +++
 fs/nfs/write.c          |    3 +++
 include/linux/nfs_xdr.h |    2 ++
 7 files changed, 35 insertions(+), 26 deletions(-)

--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4_fs.h
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4_fs.h
@@ -257,6 +257,10 @@ extern int nfs4_proc_fs_locations(struct
 		struct nfs4_fs_locations *fs_locations, struct page *page);
 extern void nfs4_release_lockowner(const struct nfs4_lock_state *);
 extern const struct xattr_handler *nfs4_xattr_handlers[];
+extern void nfs4_set_rw_stateid(nfs4_stateid *stateid,
+		const struct nfs_open_context *ctx,
+		const struct nfs_lock_context *l_ctx,
+		fmode_t fmode);
 
 #if defined(CONFIG_NFS_V4_1)
 static inline struct nfs4_session *nfs4_get_session(const struct nfs_server *server)
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4filelayout.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4filelayout.c
@@ -190,6 +190,8 @@ static void filelayout_read_prepare(stru
 		return;
 
 	rpc_call_start(task);
+	nfs4_set_rw_stateid(&rdata->args.stateid, rdata->args.context,
+			rdata->args.lock_context, FMODE_READ);
 }
 
 static void filelayout_read_call_done(struct rpc_task *task, void *data)
@@ -275,6 +277,8 @@ static void filelayout_write_prepare(str
 		return;
 
 	rpc_call_start(task);
+	nfs4_set_rw_stateid(&wdata->args.stateid, wdata->args.context,
+			wdata->args.lock_context, FMODE_WRITE);
 }
 
 static void filelayout_write_call_done(struct rpc_task *task, void *data)
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4proc.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4proc.c
@@ -3288,6 +3288,23 @@ static int nfs4_proc_pathconf(struct nfs
 	return err;
 }
 
+void nfs4_set_rw_stateid(nfs4_stateid *stateid,
+		const struct nfs_open_context *ctx,
+		const struct nfs_lock_context *l_ctx,
+		fmode_t fmode)
+{
+	const struct nfs_lockowner *lockowner = NULL;
+
+	if (ctx->state == NULL) {
+		nfs4_stateid_copy(stateid, &zero_stateid);
+		return;
+	}
+	if (l_ctx != NULL)
+		lockowner = &l_ctx->lockowner;
+	nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);
+}
+EXPORT_SYMBOL_GPL(nfs4_set_rw_stateid);
+
 void __nfs4_read_done_cb(struct nfs_read_data *data)
 {
 	nfs_invalidate_atime(data->inode);
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4xdr.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4xdr.c
@@ -1446,28 +1446,6 @@ static void encode_putrootfh(struct xdr_
 	hdr->replen += decode_putrootfh_maxsz;
 }
 
-static void encode_stateid(struct xdr_stream *xdr,
-		const struct nfs_open_context *ctx,
-		const struct nfs_lock_context *l_ctx,
-		fmode_t fmode,
-		int zero_seqid)
-{
-	nfs4_stateid stateid;
-
-	if (ctx->state != NULL) {
-		const struct nfs_lockowner *lockowner = NULL;
-
-		if (l_ctx != NULL)
-			lockowner = &l_ctx->lockowner;
-		nfs4_select_rw_stateid(&stateid, ctx->state,
-				fmode, lockowner);
-		if (zero_seqid)
-			stateid.seqid = 0;
-		encode_nfs4_stateid(xdr, &stateid);
-	} else
-		encode_nfs4_stateid(xdr, &zero_stateid);
-}
-
 static void encode_read(struct xdr_stream *xdr, const struct nfs_readargs *args, struct compound_hdr *hdr)
 {
 	__be32 *p;
@@ -1475,8 +1453,7 @@ static void encode_read(struct xdr_strea
 	p = reserve_space(xdr, 4);
 	*p = cpu_to_be32(OP_READ);
 
-	encode_stateid(xdr, args->context, args->lock_context,
-			FMODE_READ, hdr->minorversion);
+	encode_nfs4_stateid(xdr, &args->stateid);
 
 	p = reserve_space(xdr, 12);
 	p = xdr_encode_hyper(p, args->offset);
@@ -1663,8 +1640,7 @@ static void encode_write(struct xdr_stre
 	p = reserve_space(xdr, 4);
 	*p = cpu_to_be32(OP_WRITE);
 
-	encode_stateid(xdr, args->context, args->lock_context,
-			FMODE_WRITE, hdr->minorversion);
+	encode_nfs4_stateid(xdr, &args->stateid);
 
 	p = reserve_space(xdr, 16);
 	p = xdr_encode_hyper(p, args->offset);
--- linux-3.0-SLE11-SP3.orig/fs/nfs/read.c
+++ linux-3.0-SLE11-SP3/fs/nfs/read.c
@@ -459,6 +459,9 @@ void nfs_read_prepare(struct rpc_task *t
 #if defined(CONFIG_NFS_V4)
 	if (nfs4_lock_lost(data->args.context, data->args.lock_context))
 		rpc_exit(task, -EIO);
+	else
+		nfs4_set_rw_stateid(&data->args.stateid, data->args.context,
+				    data->args.lock_context, FMODE_READ);
 #endif
 }
 
--- linux-3.0-SLE11-SP3.orig/fs/nfs/write.c
+++ linux-3.0-SLE11-SP3/fs/nfs/write.c
@@ -1123,6 +1123,9 @@ void nfs_write_prepare(struct rpc_task *
 #if defined(CONFIG_NFS_V4)
 	if (nfs4_lock_lost(data->args.context, data->args.lock_context))
 		rpc_exit(task, -EIO);
+	else
+		nfs4_set_rw_stateid(&data->args.stateid, data->args.context,
+				    data->args.lock_context, FMODE_WRITE);
 #endif
 }
 
--- linux-3.0-SLE11-SP3.orig/include/linux/nfs_xdr.h
+++ linux-3.0-SLE11-SP3/include/linux/nfs_xdr.h
@@ -448,6 +448,7 @@ struct nfs_readargs {
 	struct nfs_fh *		fh;
 	struct nfs_open_context *context;
 	struct nfs_lock_context *lock_context;
+	nfs4_stateid		stateid;
 	__u64			offset;
 	__u32			count;
 	unsigned int		pgbase;
@@ -469,6 +470,7 @@ struct nfs_writeargs {
 	struct nfs_fh *		fh;
 	struct nfs_open_context *context;
 	struct nfs_lock_context *lock_context;
+	nfs4_stateid		stateid;
 	__u64			offset;
 	__u32			count;
 	enum nfs3_stable_how	stable;
