From 39552ea8120a699dbd0360848c4d949f9f0e6deb Mon Sep 17 00:00:00 2001
From: Sachin Prabhu <sprabhu@redhat.com>
Date: Tue, 13 May 2014 00:48:12 +0100
Subject: [PATCH 1/2] cifs: Set client guid on per connection basis
Patch-mainline: v3.16-rc1
Git-commit: 39552ea8120a699dbd0360848c4d949f9f0e6deb

When mounting from a Windows 2012R2 server, we hit the following
problem:
1) Mount with any of the following versions - 2.0, 2.1 or 3.0
2) unmount
3) Attempt a mount again using a different SMB version >= 2.0.

You end up with the following failure:
Status code returned 0xc0000203 STATUS_USER_SESSION_DELETED
CIFS VFS: Send error in SessSetup = -5
CIFS VFS: cifs_mount failed w/return code = -5

I cannot reproduce this issue using a Windows 2008 R2 server.

This appears to be caused because we use the same client guid for the
connection on first mount which we then disconnect and attempt to mount
again using a different protocol version. By generating a new guid each
time a new connection is Negotiated, we avoid hitting this problem.

Signed-off-by: Sachin Prabhu <sprabhu@redhat.com>
Signed-off-by: Steve French <smfrench@gmail.com>
Acked-by: David Disseldorp <ddiss@suse.de>
---
 fs/cifs/cifsfs.c   | 8 --------
 fs/cifs/cifsglob.h | 1 +
 fs/cifs/connect.c  | 3 +++
 fs/cifs/smb2pdu.c  | 5 +++--
 fs/cifs/smb2pdu.h  | 2 --
 5 files changed, 7 insertions(+), 12 deletions(-)

Index: linux-3.12-fate317480_cifs_smb2/fs/cifs/cifsfs.c
===================================================================
--- linux-3.12-fate317480_cifs_smb2.orig/fs/cifs/cifsfs.c
+++ linux-3.12-fate317480_cifs_smb2/fs/cifs/cifsfs.c
@@ -87,10 +87,6 @@ extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
 
-#ifdef CONFIG_CIFS_SMB2
-__u8 cifs_client_guid[SMB2_CLIENT_GUID_SIZE];
-#endif
-
 /*
  * Bumps refcount for cifs super block.
  * Note that it should be only called if a referece to VFS super block is
@@ -1180,10 +1176,6 @@ init_cifs(void)
 	spin_lock_init(&cifs_file_list_lock);
 	spin_lock_init(&GlobalMid_Lock);
 
-#ifdef CONFIG_CIFS_SMB2
-	get_random_bytes(cifs_client_guid, SMB2_CLIENT_GUID_SIZE);
-#endif
-
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
 		cifs_dbg(FYI, "cifs_max_pending set to min of 2\n");
Index: linux-3.12-fate317480_cifs_smb2/fs/cifs/cifsglob.h
===================================================================
--- linux-3.12-fate317480_cifs_smb2.orig/fs/cifs/cifsglob.h
+++ linux-3.12-fate317480_cifs_smb2/fs/cifs/cifsglob.h
@@ -545,6 +545,7 @@ struct TCP_Server_Info {
 	int echo_credits;  /* echo reserved slots */
 	int oplock_credits;  /* oplock break reserved slots */
 	bool echoes:1; /* enable echoes */
+	__u8 client_guid[SMB2_CLIENT_GUID_SIZE]; /* Client GUID */
 #endif
 	u16 dialect; /* dialect index that server chose */
 	bool oplocks:1; /* enable oplocks */
Index: linux-3.12-fate317480_cifs_smb2/fs/cifs/connect.c
===================================================================
--- linux-3.12-fate317480_cifs_smb2.orig/fs/cifs/connect.c
+++ linux-3.12-fate317480_cifs_smb2/fs/cifs/connect.c
@@ -2144,6 +2144,9 @@ cifs_get_tcp_session(struct smb_vol *vol
 	       sizeof(tcp_ses->srcaddr));
 	memcpy(&tcp_ses->dstaddr, &volume_info->dstaddr,
 		sizeof(tcp_ses->dstaddr));
+#ifdef CONFIG_CIFS_SMB2
+	get_random_bytes(tcp_ses->client_guid, SMB2_CLIENT_GUID_SIZE);
+#endif
 	/*
 	 * at this point we are the only ones with the pointer
 	 * to the struct since the kernel thread not created yet
Index: linux-3.12-fate317480_cifs_smb2/fs/cifs/smb2pdu.c
===================================================================
--- linux-3.12-fate317480_cifs_smb2.orig/fs/cifs/smb2pdu.c
+++ linux-3.12-fate317480_cifs_smb2/fs/cifs/smb2pdu.c
@@ -375,7 +375,7 @@ SMB2_negotiate(const unsigned int xid, s
 
 	req->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);
 
-	memcpy(req->ClientGUID, cifs_client_guid, SMB2_CLIENT_GUID_SIZE);
+	memcpy(req->ClientGUID, server->client_guid, SMB2_CLIENT_GUID_SIZE);
 
 	iov[0].iov_base = (char *)req;
 	/* 4 for rfc1002 length field */
@@ -478,7 +478,8 @@ int smb3_validate_negotiate(const unsign
 
 	vneg_inbuf.Capabilities =
 			cpu_to_le32(tcon->ses->server->vals->req_capabilities);
-	memcpy(vneg_inbuf.Guid, cifs_client_guid, SMB2_CLIENT_GUID_SIZE);
+	memcpy(vneg_inbuf.Guid, tcon->ses->server->client_guid,
+					SMB2_CLIENT_GUID_SIZE);
 
 	if (tcon->ses->sign)
 		vneg_inbuf.SecurityMode =
Index: linux-3.12-fate317480_cifs_smb2/fs/cifs/smb2pdu.h
===================================================================
--- linux-3.12-fate317480_cifs_smb2.orig/fs/cifs/smb2pdu.h
+++ linux-3.12-fate317480_cifs_smb2/fs/cifs/smb2pdu.h
@@ -166,8 +166,6 @@ struct smb2_symlink_err_rsp {
 
 #define SMB2_CLIENT_GUID_SIZE 16
 
-extern __u8 cifs_client_guid[SMB2_CLIENT_GUID_SIZE];
-
 struct smb2_negotiate_req {
 	struct smb2_hdr hdr;
 	__le16 StructureSize; /* Must be 36 */
