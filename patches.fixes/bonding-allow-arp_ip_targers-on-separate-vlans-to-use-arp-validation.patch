From: Andy Gospodarek <andy@greyhouse.net>
Date: Mon, 14 Dec 2009 10:48:58 +0000
Subject: [PATCH] bonding: allow arp_ip_targets on separate vlans to use arp validation
Git-commit: 1f3c8804acba841b5573b953f5560d2683d2db0d
Patch-mainline: 2.6.34
Acked-by: Jiri Bohac <jbohac@suse.cz>
References: bnc#648701, bnc#665480

The original 1f3c8804 patch introduced two bugs, fixed by ca8d9ea30bc7 and
2df4a0fa1540c. The fixes are already included here, the latter one in response
to bnc#665480. -jbohac

This allows a bond device to specify an arp_ip_target as a host that is
not on the same vlan as the base bond device and still use arp
validation.  A configuration like this, now works:

BONDING_OPTS="mode=active-backup arp_interval=1000 arp_ip_target=10.0.100.1 arp_validate=3"

1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth1: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master bond0 qlen 1000
    link/ether 00:13:21:be:33:e9 brd ff:ff:ff:ff:ff:ff
3: eth0: <BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master bond0 qlen 1000
    link/ether 00:13:21:be:33:e9 brd ff:ff:ff:ff:ff:ff
8: bond0: <BROADCAST,MULTICAST,MASTER,UP,LOWER_UP> mtu 1500 qdisc noqueue
    link/ether 00:13:21:be:33:e9 brd ff:ff:ff:ff:ff:ff
    inet6 fe80::213:21ff:febe:33e9/64 scope link
       valid_lft forever preferred_lft forever
9: bond0.100@bond0: <BROADCAST,MULTICAST,MASTER,UP,LOWER_UP> mtu 1500 qdisc noqueue
    link/ether 00:13:21:be:33:e9 brd ff:ff:ff:ff:ff:ff
    inet 10.0.100.2/24 brd 10.0.100.255 scope global bond0.100
    inet6 fe80::213:21ff:febe:33e9/64 scope link
       valid_lft forever preferred_lft forever

Ethernet Channel Bonding Driver: v3.6.0 (September 26, 2009)

Bonding Mode: fault-tolerance (active-backup)
Primary Slave: None
Currently Active Slave: eth1
MII Status: up
MII Polling Interval (ms): 0
Up Delay (ms): 0
Down Delay (ms): 0
ARP Polling Interval (ms): 1000
ARP IP target/s (n.n.n.n form): 10.0.100.1

Slave Interface: eth1
MII Status: up
Link Failure Count: 1
Permanent HW addr: 00:40:05:30:ff:30

Slave Interface: eth0
MII Status: up
Link Failure Count: 0
Permanent HW addr: 00:13:21:be:33:e9

Signed-off-by: Andy Gospodarek <andy@greyhouse.net>
Signed-off-by: Jay Vosburgh <fubar@us.ibm.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 drivers/net/bonding/bond_main.c |   11 +++++++++++
 net/8021q/vlan_core.c           |    2 ++
 net/core/dev.c                  |   20 +++++++++++++++++---
 3 files changed, 30 insertions(+), 3 deletions(-)

Index: work/drivers/net/bonding/bond_main.c
===================================================================
--- work.orig/drivers/net/bonding/bond_main.c	2010-12-10 19:13:03.000000000 +0100
+++ work/drivers/net/bonding/bond_main.c	2010-12-10 19:13:44.000000000 +0100
@@ -2674,6 +2674,19 @@ static void bond_handle_arp(struct sk_bu
 	struct net_device *dev = skb->dev->master, *orig_dev = skb->dev;
 	unsigned char *arp_ptr;
 	__be32 sip, tip;
+	int put_orig_dev = 0;
+
+	if (dev->priv_flags & IFF_802_1Q_VLAN) {
+		/*
+		 * When using VLANS and bonding, dev and oriv_dev may be
+		 * incorrect if the physical interface supports VLAN
+		 * acceleration.  With this change ARP validation now
+		 * works for hosts only reachable on the VLAN interface.
+		 */
+		dev = vlan_dev_real_dev(dev);
+		orig_dev = dev_get_by_index(dev_net(skb->dev),skb->iif);
+		put_orig_dev = 1;
+	}
 
 	if (dev_net(dev) != &init_net)
 		goto out;
@@ -2730,6 +2743,8 @@ static void bond_handle_arp(struct sk_bu
 out_unlock:
 	read_unlock(&bond->lock);
 out:
+	if (put_orig_dev)
+		dev_put(orig_dev);
 	return;
 }
 
Index: work/net/8021q/vlan_core.c
===================================================================
--- work.orig/net/8021q/vlan_core.c	2010-12-10 19:13:03.000000000 +0100
+++ work/net/8021q/vlan_core.c	2010-12-10 19:13:44.000000000 +0100
@@ -14,6 +14,7 @@ int __vlan_hwaccel_rx(struct sk_buff *sk
 	if (skb_bond_should_drop(skb))
 		goto drop;
 
+	skb->iif = skb->dev->ifindex;
 	skb->vlan_tci = vlan_tci;
 	skb->dev = vlan_group_get_device(grp, vlan_tci & VLAN_VID_MASK);
 
@@ -82,6 +83,7 @@ static int vlan_gro_common(struct napi_s
 	if (skb_bond_should_drop(skb))
 		goto drop;
 
+	skb->iif = skb->dev->ifindex;
 	skb->vlan_tci = vlan_tci;
 	skb->dev = vlan_group_get_device(grp, vlan_tci & VLAN_VID_MASK);
 
Index: work/net/core/dev.c
===================================================================
--- work.orig/net/core/dev.c	2010-12-10 19:13:03.000000000 +0100
+++ work/net/core/dev.c	2010-12-10 19:13:44.000000000 +0100
@@ -2318,6 +2318,7 @@ int netif_receive_skb(struct sk_buff *sk
 	struct packet_type *ptype, *pt_prev;
 	struct net_device *orig_dev;
 	struct net_device *null_or_orig;
+	struct net_device *orig_or_bond;
 	int ret = NET_RX_DROP;
 	__be16 type;
 	unsigned long pflags = current->flags;
@@ -2403,12 +2404,24 @@ ncls:
 	if (!skb)
 		goto unlock;
 
+	/*
+	 * Make sure frames received on VLAN interfaces stacked on
+	 * bonding interfaces still make their way to any base bonding
+	 * device that may have registered for a specific ptype.  The
+	 * handler may have to adjust skb->dev and orig_dev.
+	 */
+	orig_or_bond = orig_dev;
+	if ((skb->dev->priv_flags & IFF_802_1Q_VLAN) &&
+	    (vlan_dev_real_dev(skb->dev)->priv_flags & IFF_BONDING)) {
+		orig_or_bond = vlan_dev_real_dev(skb->dev);
+	}
+
 	type = skb->protocol;
 	list_for_each_entry_rcu(ptype,
 			&ptype_base[ntohs(type) & PTYPE_HASH_MASK], list) {
 		if (ptype->type == type &&
 		    (ptype->dev == null_or_orig || ptype->dev == skb->dev ||
-		     ptype->dev == orig_dev)) {
+		     ptype->dev == orig_dev || ptype->dev == orig_or_bond)) {
 			if (pt_prev)
 				ret = deliver_skb(skb, pt_prev, orig_dev);
 			pt_prev = ptype;
