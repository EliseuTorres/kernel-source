From: Jan Kara <jack@suse.cz>
Subject: [PATCH] writeback: integrated background writeback work
Patch-mainline: yes
Git-commit-commit-id: 6585027a5e8cb490e3a761b2f3f3c3acf722aff2
References: bnc#649000

Check whether background writeback is needed after finishing each work.

When bdi flusher thread finishes doing some work check whether any kind of
background writeback needs to be done (either because
dirty_background_ratio is exceeded or because we need to start flushing
old inodes).  If so, just do background write back.

This way, bdi_start_background_writeback() just needs to wake up the
flusher thread.  It will do background writeback as soon as there is no
other work.

This is a preparatory patch for the next patch which stops background
writeback as soon as there is other work to do.

Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
Cc: Johannes Weiner <hannes@cmpxchg.org>
Cc: Dave Chinner <david@fromorbit.com>
Cc: Christoph Hellwig <hch@lst.de>
Cc: Jan Engelhardt <jengelh@medozas.de>
Cc: Jens Axboe <axboe@kernel.dk>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 fs/fs-writeback.c |   59 +++++++++++++++++++++++++++++++++++++++---------------
 1 file changed, 43 insertions(+), 16 deletions(-)

diff -rupX /crypted/home/jack/.kerndiffexclude linux-2.6.32-writeback-SLE11-SP1/fs/fs-writeback.c linux-2.6.32-writeback-SLE11-SP1-2-check_background/fs/fs-writeback.c
--- linux-2.6.32-writeback-SLE11-SP1/fs/fs-writeback.c	2011-03-03 12:20:55.981669807 +0100
+++ linux-2.6.32-writeback-SLE11-SP1-2-check_background/fs/fs-writeback.c	2011-03-03 12:35:30.226430406 +0100
@@ -159,6 +159,23 @@ static void wb_clear_pending(struct bdi_
 	}
 }
 
+/* Wakeup flusher thread or forker thread to fork it. */
+static void bdi_wakeup_flusher(struct backing_dev_info *bdi)
+{
+	/*
+	 * If the default thread isn't there, make sure we add it. When
+	 * it gets created and wakes up, we'll run this work.
+	 */
+	if (unlikely(list_empty_careful(&bdi->wb_list)))
+		wake_up_process(default_backing_dev_info.wb.task);
+	else {
+		struct bdi_writeback *wb = &bdi->wb;
+
+		if (wb->task)
+			wake_up_process(wb->task);
+	}
+}
+
 static void bdi_queue_work(struct backing_dev_info *bdi, struct bdi_work *work)
 {
 	work->seen = bdi->wb_mask;
@@ -174,19 +191,7 @@ static void bdi_queue_work(struct backin
 	spin_lock(&bdi->wb_lock);
 	list_add_tail_rcu(&work->list, &bdi->work_list);
 	spin_unlock(&bdi->wb_lock);
-
-	/*
-	 * If the default thread isn't there, make sure we add it. When
-	 * it gets created and wakes up, we'll run this work.
-	 */
-	if (unlikely(list_empty_careful(&bdi->wb_list)))
-		wake_up_process(default_backing_dev_info.wb.task);
-	else {
-		struct bdi_writeback *wb = &bdi->wb;
-
-		if (wb->task)
-			wake_up_process(wb->task);
-	}
+	bdi_wakeup_flusher(bdi);
 }
 
 /*
@@ -276,8 +281,13 @@ void bdi_start_writeback(struct backing_
 	 * ie. to sync pages until the background dirty threshold is reached.
 	 */
 	if (!nr_pages) {
-		args.nr_pages = LONG_MAX;
-		args.for_background = 1;
+		/*
+		 * We just wake up the flusher thread. It will perform
+		 * background writeback as soon as there is no other work to
+		 * do.
+		 */
+		bdi_wakeup_flusher(bdi);
+		return;
 	}
 
 	if (locked) {
@@ -908,6 +918,22 @@ static long wb_check_old_data_flush(stru
 	return 0;
 }
 
+static long wb_check_background_flush(struct bdi_writeback *wb)
+{
+	if (over_bground_thresh()) {
+		struct wb_writeback_args args = {
+			.nr_pages	= LONG_MAX,
+			.sync_mode	= WB_SYNC_NONE,
+			.for_background	= 1,
+			.range_cyclic	= 1,
+		};
+
+		return wb_writeback(wb, &args);
+	}
+
+	return 0;
+}
+
 /*
  * Retrieve work items and do the writeback they describe
  */
@@ -944,9 +970,10 @@ long wb_do_writeback(struct bdi_writebac
 	}
 
 	/*
-	 * Check for periodic writeback, kupdated() style
+	 * Check for periodic writeback, kupdated()+pdflush() style
 	 */
 	wrote += wb_check_old_data_flush(wb);
+	wrote += wb_check_background_flush(wb);
 
 	return wrote;
 }

