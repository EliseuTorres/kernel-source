From: Jiri Bohac <jbohac@suse.cz>
Subject: ipv6, xfrm: use conntrack-reassembled packet for policy lookup
References: bnc#780216
Patch-mainline: not yet

If an IPsec policy is specified using L4 information, IPv6 fragments don't
contain the information needed to look up the policy.

In case conntrack has already done the reassembly, use the information from
the reassembled packet to look up the policy.

Signed-off-by: Jiri Bohac <jbohac@suse.cz>

diff -Naurp lotc-linux-3.0.34/net/ipv6/xfrm6_policy.c lotc-linux-3.0.34.fixed/net/ipv6/xfrm6_policy.c
--- lotc-linux-3.0.34/net/ipv6/xfrm6_policy.c	2012-06-19 11:56:30.000000000 +0200
+++ lotc-linux-3.0.34.fixed/net/ipv6/xfrm6_policy.c	2012-08-23 17:36:01.980926313 +0200
@@ -124,11 +124,13 @@ _decode_session6(struct sk_buff *skb, st
 {
 	struct flowi6 *fl6 = &fl->u.ip6;
 	int onlyproto = 0;
-	u16 offset = skb_network_header_len(skb);
-	const struct ipv6hdr *hdr = ipv6_hdr(skb);
+	/* use the reassembled packet if conntrack has done the reassembly */
+	struct sk_buff *whole_skb = (skb->nfct_reasm) ? skb->nfct_reasm : skb;
+	u16 offset = skb_network_header_len(whole_skb);
+	const struct ipv6hdr *hdr = ipv6_hdr(whole_skb);
 	struct ipv6_opt_hdr *exthdr;
-	const unsigned char *nh = skb_network_header(skb);
-	u8 nexthdr = nh[IP6CB(skb)->nhoff];
+	const unsigned char *nh = skb_network_header(whole_skb);
+	u8 nexthdr = nh[IP6CB(whole_skb)->nhoff];
 
 	memset(fl6, 0, sizeof(struct flowi6));
 	fl6->flowi6_mark = skb->mark;
@@ -136,9 +137,9 @@ _decode_session6(struct sk_buff *skb, st
 	ipv6_addr_copy(&fl6->daddr, reverse ? &hdr->saddr : &hdr->daddr);
 	ipv6_addr_copy(&fl6->saddr, reverse ? &hdr->daddr : &hdr->saddr);
 
-	while (nh + offset + 1 < skb->data ||
-	       pskb_may_pull(skb, nh + offset + 1 - skb->data)) {
-		nh = skb_network_header(skb);
+	while (nh + offset + 1 < whole_skb->data ||
+	       pskb_may_pull(whole_skb, nh + offset + 1 - whole_skb->data)) {
+		nh = skb_network_header(whole_skb);
 		exthdr = (struct ipv6_opt_hdr *)(nh + offset);
 
 		switch (nexthdr) {
@@ -157,8 +158,8 @@ _decode_session6(struct sk_buff *skb, st
 		case IPPROTO_TCP:
 		case IPPROTO_SCTP:
 		case IPPROTO_DCCP:
-			if (!onlyproto && (nh + offset + 4 < skb->data ||
-			     pskb_may_pull(skb, nh + offset + 4 - skb->data))) {
+			if (!onlyproto && (nh + offset + 4 < whole_skb->data ||
+			     pskb_may_pull(whole_skb, nh + offset + 4 - whole_skb->data))) {
 				__be16 *ports = (__be16 *)exthdr;
 
 				fl6->fl6_sport = ports[!!reverse];
