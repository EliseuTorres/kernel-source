From: Jiri Bohac <jbohac@suse.cz>
Subject: ipv6, xfrm: use conntrack-reassembled packet for policy lookup
References: bnc#780216
Patch-mainline: not yet

If an IPsec policy is specified using L4 information, IPv6 fragments don't
contain the information needed to look up the policy.

In case conntrack has already done the reassembly, use the information from
the reassembled packet to look up the policy.

Signed-off-by: Jiri Bohac <jbohac@suse.cz>

--- a/net/ipv6/xfrm6_policy.c	2012-06-19 11:56:30.000000000 +0200
+++ b/net/ipv6/xfrm6_policy.c	2012-08-23 17:36:01.980926313 +0200
@@ -130,11 +130,13 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 {
 	struct flowi6 *fl6 = &fl->u.ip6;
 	int onlyproto = 0;
-	u16 offset = skb_network_header_len(skb);
-	const struct ipv6hdr *hdr = ipv6_hdr(skb);
+	/* use the reassembled packet if conntrack has done the reassembly */
+	struct sk_buff *whole_skb = (skb->nfct_reasm) ? skb->nfct_reasm : skb;
+	u16 offset = skb_network_header_len(whole_skb);
+	const struct ipv6hdr *hdr = ipv6_hdr(whole_skb);
 	struct ipv6_opt_hdr *exthdr;
-	const unsigned char *nh = skb_network_header(skb);
-	u8 nexthdr = nh[IP6CB(skb)->nhoff];
+	const unsigned char *nh = skb_network_header(whole_skb);
+	u8 nexthdr = nh[IP6CB(whole_skb)->nhoff];
 	int oif = 0;
 
 	if (skb_dst(skb))
@@ -147,9 +149,9 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 	fl6->daddr = reverse ? hdr->saddr : hdr->daddr;
 	fl6->saddr = reverse ? hdr->daddr : hdr->saddr;
 
-	while (nh + offset + 1 < skb->data ||
-	       pskb_may_pull(skb, nh + offset + 1 - skb->data)) {
-		nh = skb_network_header(skb);
+	while (nh + offset + 1 < whole_skb->data ||
+	       pskb_may_pull(whole_skb, nh + offset + 1 - whole_skb->data)) {
+		nh = skb_network_header(whole_skb);
 		exthdr = (struct ipv6_opt_hdr *)(nh + offset);
 
 		switch (nexthdr) {
@@ -168,8 +170,8 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 		case IPPROTO_TCP:
 		case IPPROTO_SCTP:
 		case IPPROTO_DCCP:
-			if (!onlyproto && (nh + offset + 4 < skb->data ||
-			     pskb_may_pull(skb, nh + offset + 4 - skb->data))) {
+			if (!onlyproto && (nh + offset + 4 < whole_skb->data ||
+			     pskb_may_pull(whole_skb, nh + offset + 4 - whole_skb->data))) {
 				__be16 *ports = (__be16 *)exthdr;
 
 				fl6->fl6_sport = ports[!!reverse];
@@ -179,7 +181,7 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 			return;
 
 		case IPPROTO_ICMPV6:
-			if (!onlyproto && pskb_may_pull(skb, nh + offset + 2 - skb->data)) {
+			if (!onlyproto && pskb_may_pull(whole_skb, nh + offset + 2 - whole_skb->data)) {
 				u8 *icmp = (u8 *)exthdr;
 
 				fl6->fl6_icmp_type = icmp[0];
@@ -190,7 +192,7 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 
 #if IS_ENABLED(CONFIG_IPV6_MIP6)
 		case IPPROTO_MH:
-			if (!onlyproto && pskb_may_pull(skb, nh + offset + 3 - skb->data)) {
+			if (!onlyproto && pskb_may_pull(whole_skb, nh + offset + 3 - whole_skb->data)) {
 				struct ip6_mh *mh;
 				mh = (struct ip6_mh *)exthdr;
 
