From: Nick Piggin <npiggin@suse.de>
Subject: cpuset: fix cpuset mem spreading returning offline node
References: bnc#575923
Patch-mainline: not yet

Commit 58568d2a8215cb6f55caf2332017d7bdff954e1c "cpuset,mm: update tasks'
mems_allowed in time" caused a regression.

Here's an example of a failure while running sles11sp1 beta1 kernel aka
2.6.32-0.6.8-default:

kernel BUG at
/usr/src/packages/BUILD/kernel-default-2.6.32/linux-2.6.32/mm/slab.c:3271!
bash[6885]: bugcheck! 0 [1]                                                     

Modules linked in: autofs4 ipv6 af_packet binfmt_misc fuse nls_iso8859_1 loop
dm_mod tg3 ide_cd_mod sg button cdrom sd_mod crc_t10dif qla2xxx qla1280 xfs
                   exportfs fan thermal processor thermal_sys hwmon ide_generic
mptfc scsi_transport_fc scsi_tgt mptspi scsi_transport_spi mptsas mptscsih
                   mptbase scsi_transport_sas sata_vsc libata scsi_mod sgiioc4
ide_core ioc4                                                              
Supported: Yes                                                                  

Pid: 6885, CPU 5, comm:                 bash
psr : 00001010095a2010 ifs : 800000000000038b ip  : [<a00000010020cf00>]
Tainted: G        W    (2.6.32-0.6.8-default)
ip is at ____cache_alloc_node+0x440/0x500                                       

unat: 0000000000000000 pfs : 000000000000038b rsc : 0000000000000003
rnat: 0000000000283d85 bsps: 0000000000000001 pr  : 99596aaa69aa6999
ldrs: 0000000000000000 ccv : 0000000000000018 fpsr: 0009804c0270033f
csd : 0000000000000000 ssd : 0000000000000000                       
b0  : a00000010020cf00 b6  : a0000001004962c0 b7  : a000000100493240
f6  : 000000000000000000000 f7  : 000000000000000000000             
f8  : 000000000000000000000 f9  : 000000000000000000000             
f10 : 000000000000000000000 f11 : 000000000000000000000
r1  : a0000001015c6fc0 r2  : 000000000000e662 r3  : 000000000000fffe
r8  : 000000000000005c r9  : 0000000000000000 r10 : 0000000000004000
r11 : 0000000000000000 r12 : e000003c3904fcc0 r13 : e000003c39040000
r14 : 000000000000e662 r15 : a00000010138ed88 r16 : ffffffffffff65c8
r17 : a00000010138ed80 r18 : a0000001013c7ad0 r19 : a0000001013d3b60
r20 : e00001b03afdfe18 r21 : 0000000000000001 r22 : e0000130030365c8
r23 : e000013003040000 r24 : ffffffffffff0400 r25 : 00000000000068ef
r26 : 00000000000068ef r27 : a0000001029621d0 r28 : 00000000000068f0
r29 : 00000000000068f0 r30 : 00000000000068f0 r31 : 000000000000000a

Call Trace:
[<a000000100017a80>] show_stack+0x80/0xa0
[<a0000001000180e0>] show_regs+0x640/0x920
[<a000000100029a90>] die+0x190/0x2e0
[<a000000100029c30>] die_if_kernel+0x50/0x80
[<a000000100904af0>] ia64_bad_break+0x470/0x760
[<a00000010000cb60>] ia64_native_leave_kernel+0x0/0x270
[<a00000010020cf00>] ____cache_alloc_node+0x440/0x500
[<a00000010020ffa0>] kmem_cache_alloc+0x360/0x660
[<a000000100258450>] d_alloc+0x30/0x480
[<a00000010023ab20>] real_lookup+0x1e0/0x2e0
[<a00000010023ad90>] do_lookup+0x170/0x260
[<a000000100241810>] __link_path_walk+0x1130/0x29c0
[<a000000100243590>] path_walk+0x70/0x140
[<a0000001002438b0>] do_path_lookup+0xb0/0x180
[<a000000100245690>] user_path_at+0xb0/0x160
[<a00000010022ed80>] vfs_fstatat+0x60/0x100
[<a00000010022f030>] vfs_stat+0x30/0x60
[<a00000010022f090>] sys_newstat+0x30/0xc0
[<a00000010000c9c0>] ia64_ret_from_syscall+0x0/0x20
[<a000000000010720>] __kernel_syscall_via_break+0x0/0x20

3261 static void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,
3262                                 int nodeid)                              
3263 {                                                                        
..                                                                           
3270         l3 = cachep->nodelists[nodeid];                                  
3271         BUG_ON(!l3);                                                     

How to reproduce:

        - mkdir /dev/cpuset
        - mount cpuset -t cpuset /dev/cpuset
        - echo 1 > /dev/cpuset/memory_spread_slab

The problem is that cpuset_mem_spread_node can return an offline node
to the slab code, which it isn't expecting. Fix this by iterating over
offline nodes.

Signed-off-by: Nick Piggin <npiggin@suse.de>
--
---
 kernel/cpuset.c |   12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

--- a/kernel/cpuset.c
+++ b/kernel/cpuset.c
@@ -2396,12 +2396,16 @@ void cpuset_unlock(void)
 
 int cpuset_mem_spread_node(void)
 {
-	int node;
+	int node = current->cpuset_mem_spread_rotor;
+
+	do {
+		node = next_node(node, current->mems_allowed);
+		if (node == MAX_NUMNODES)
+			node = first_node(current->mems_allowed);
+	} while (!node_state(node, N_NORMAL_MEMORY));
 
-	node = next_node(current->cpuset_mem_spread_rotor, current->mems_allowed);
-	if (node == MAX_NUMNODES)
-		node = first_node(current->mems_allowed);
 	current->cpuset_mem_spread_rotor = node;
+
 	return node;
 }
 EXPORT_SYMBOL_GPL(cpuset_mem_spread_node);
