From c30d29655c706e7e790d0e4c78c2e056c21a4839 Mon Sep 17 00:00:00 2001
From: Mel Gorman <mgorman@suse.de>
Date: Mon, 9 Dec 2013 08:58:41 +0000
Subject: [PATCH] mm: reschedule to avoid RCU stall triggering during boot of large machines

Patch-mainline: No, never (Upstream addresses this in a fashion that breaks KABI)
References: bnc#820434,bnc#852153

Customer reported soft lockups during boot that look like this

[   85.003611] INFO: rcu_sched_state detected stall on CPU 0 (t=15000 jiffies)
[   85.011458] sending NMI to all CPUs:
[   85.015473] NMI backtrace for cpu 0
[   85.015477] CPU 0
[   85.015478] Modules linked in:
[   85.015481] Supported: Yes
[   85.015482]
[   85.015488] Pid: 1, comm: swapper Not tainted 3.0.93-0.8-default #1 FUJITSU PRIMEQUEST 2800E/SB
[   85.015500] RIP: 0010:[<ffffffff81009e12>]  [<ffffffff81009e12>] native_read_tsc+0x2/0x20
[   85.015521] RSP: 0018:ffff89009fa03e58  EFLAGS: 00000046
[   85.015523] RAX: 00000000446ae4c9 RBX: 000000000003c8c8 RCX: 00000000446ae491
[   85.015526] RDX: 0000000000000861 RSI: 00000000446ae491 RDI: 000000000003c8c8
[   85.015529] RBP: 0000000000001000 R08: 0000000000000100 R09: ffffffff81bd3240
[   85.015531] R10: 0000000000000001 R11: ffffffff8125db40 R12: 0000000000000000
[   85.015532] R13: 0000000000000000 R14: 0000000000000000 R15: 00000000446ae439
[   85.015534] FS:  0000000000000000(0000) GS:ffff89009fa00000(0000) knlGS:0000000000000000
[   85.015536] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
[   85.015537] CR2: 0000000000000000 CR3: 0000000001a09000 CR4: 00000000001407f0
[   85.015538] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   85.015539] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
[   85.015541] Process swapper (pid: 1, threadinfo ffff88fabebba000, task ffff88fabebb8040)
[   85.015551] Stack:
[   85.015553]  ffffffff8125db8b 0000000000000000 0000000000001000 0000000000000002
[   85.015809]  000000000000cc00 0000000000000002 ffffffff81bd3240 ffffffff810265fa
[   85.016052]  ffff88fa00000008 0000000000000001 0000000000000002 ffffffff81026a9d
[   85.016279] Call Trace:
[   85.016379]  [<ffffffff8125db8b>] delay_tsc+0x4b/0x80
[   85.016442]  [<ffffffff810265fa>] native_safe_apic_wait_icr_idle+0x1a/0x50
[   85.016481]  [<ffffffff81026a9d>] default_send_IPI_mask_sequence_phys+0xcd/0x100
[   85.016519]  [<ffffffff81026b4a>] arch_trigger_all_cpu_backtrace+0x5a/0xa0
[   85.016552]  [<ffffffff810cd645>] check_cpu_stall+0xa5/0x100
[   85.016636]  [<ffffffff810cd6c9>] __rcu_pending+0x29/0x180
[   85.016702]  [<ffffffff810cd87f>] rcu_check_callbacks+0x5f/0x110
[   85.016754]  [<ffffffff8106fdcf>] update_process_times+0x3f/0x80
[   85.016789]  [<ffffffff81092437>] tick_periodic+0x27/0xa0
[   85.016812]  [<ffffffff810924c8>] tick_handle_periodic+0x18/0x70
[   85.016832]  [<ffffffff81026593>] smp_apic_timer_interrupt+0x63/0xa0
[   85.016863]  [<ffffffff814669f3>] apic_timer_interrupt+0x13/0x20
[   85.016915]  [<ffffffff81259f3c>] strcmp+0xc/0x30
[   85.017011]  [<ffffffff811cace0>] sysfs_find_dirent+0x40/0x50
[   85.017074]  [<ffffffff811cafcc>] __sysfs_add_one+0x1c/0xc0
[   85.017123]  [<ffffffff811cb0f3>] sysfs_add_one+0x23/0xe0
[   85.017174]  [<ffffffff811cbcdb>] create_dir+0x7b/0xe0
[   85.017229]  [<ffffffff811cbdcf>] sysfs_create_dir+0x8f/0xb0
[   85.017258]  [<ffffffff812555ff>] kobject_add_internal+0xff/0x250
[   85.017304]  [<ffffffff812558f7>] kobject_init_and_add+0x57/0x70
[   85.017363]  [<ffffffff8132d758>] sysdev_register+0x78/0x140
[   85.017436]  [<ffffffff8133f169>] init_memory_block+0xc9/0x150
[   85.017537]  [<ffffffff8133f547>] add_memory_section+0xf7/0x160
[   85.017599]  [<ffffffff81c2f206>] memory_dev_init+0xa6/0x15c
[   85.017630]  [<ffffffff81bef86f>] kernel_init+0x21d/0x2d0
[   85.017672]  [<ffffffff81467164>] kernel_thread_helper+0x4/0x10

The stall is harmless but alarming. Older bugs dealt with the NMI watchdog
triggering but similarly the RCU stall detector can fire. This patch works
around the problem by rescheduling if necessary.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 drivers/base/memory.c | 1 +
 drivers/base/node.c   | 1 +
 2 files changed, 2 insertions(+)

diff --git a/drivers/base/memory.c b/drivers/base/memory.c
index 243b987..e4f0e0f 100644
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@ -702,6 +702,7 @@ int __init memory_dev_init(void)
 					 MEM_ONLINE,
 					 BOOT);
 		touch_nmi_watchdog();
+		cond_resched();
 		if (!ret)
 			ret = err;
 	}
diff --git a/drivers/base/node.c b/drivers/base/node.c
index e5a787f..04c16d3 100644
--- a/drivers/base/node.c
+++ b/drivers/base/node.c
@@ -476,6 +476,7 @@ static int link_mem_sections(int nid)
 		/* discard ref obtained in find_memory_block() */
 
 		touch_nmi_watchdog();
+		cond_resched();
 	}
 
 	if (mem_blk)
