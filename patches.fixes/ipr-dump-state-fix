From: Brian King <brking@linux.vnet.ibm.com>
Subject: ipr: Stop reading adapter dump prematurely
Patch-mainline: pending
References: bnc#721042

When the ipr driver decides to dump the adapter, it changes the
sdt_state to GET_DUMP, then prepares the adapter so that the dump
can be read. However, if the ipr worker thread wakes up for some
reason before the driver has put the adapter in a state where it
can succesfully dump the adapter, the driver will start dumping
the adapter too early, causing issues. Fix this by adding a new
sdt_state to differentiate between the ipr driver wanting to dump
the adapter in the near future and wanting to dump the adapter now.

Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
Acked-by: Torsten Duwe <duwe@suse.de>

---

 drivers/scsi/ipr.c |   15 +++++++++++----
 drivers/scsi/ipr.h |    1 +
 2 files changed, 12 insertions(+), 4 deletions(-)

diff -puN drivers/scsi/ipr.h~ipr_dump_state_fix drivers/scsi/ipr.h
--- linux-2.6/drivers/scsi/ipr.h~ipr_dump_state_fix	2011-08-26 09:01:42.000000000 -0500
+++ linux-2.6-bjking1/drivers/scsi/ipr.h	2011-08-26 09:26:38.000000000 -0500
@@ -1360,6 +1360,7 @@ enum ipr_sdt_state {
 	INACTIVE,
 	WAIT_FOR_DUMP,
 	GET_DUMP,
+	READ_DUMP,
 	ABORT_DUMP,
 	DUMP_OBTAINED
 };
diff -puN drivers/scsi/ipr.c~ipr_dump_state_fix drivers/scsi/ipr.c
--- linux-2.6/drivers/scsi/ipr.c~ipr_dump_state_fix	2011-08-26 09:02:11.000000000 -0500
+++ linux-2.6-bjking1/drivers/scsi/ipr.c	2011-08-26 10:21:02.000000000 -0500
@@ -2901,7 +2901,7 @@ static void ipr_get_ioa_dump(struct ipr_
 
 	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
 
-	if (ioa_cfg->sdt_state != GET_DUMP) {
+	if (ioa_cfg->sdt_state != READ_DUMP) {
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
 		return;
 	}
@@ -3097,7 +3097,7 @@ static void ipr_worker_thread(struct wor
 	ENTER;
 	spin_lock_irqsave(ioa_cfg->host->host_lock, lock_flags);
 
-	if (ioa_cfg->sdt_state == GET_DUMP) {
+	if (ioa_cfg->sdt_state == READ_DUMP) {
 		dump = ioa_cfg->dump;
 		if (!dump) {
 			spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
@@ -7449,6 +7449,8 @@ static int ipr_reset_wait_for_dump(struc
 	struct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;
 
 	if (ioa_cfg->sdt_state == GET_DUMP)
+		ioa_cfg->sdt_state = WAIT_FOR_DUMP;
+	else if (ioa_cfg->sdt_state == READ_DUMP)
 		ioa_cfg->sdt_state = ABORT_DUMP;
 
 	ipr_cmd->job_step = ipr_reset_alert;
@@ -7614,6 +7616,7 @@ static int ipr_reset_restore_cfg_space(s
 		ipr_cmd->job_step = ipr_reset_enable_ioa;
 
 		if (GET_DUMP == ioa_cfg->sdt_state) {
+			ioa_cfg->sdt_state = READ_DUMP;
 			if (ioa_cfg->sis64)
 				ipr_reset_start_timer(ipr_cmd, IPR_SIS64_DUMP_TIMEOUT);
 			else
@@ -8003,8 +8006,12 @@ static void ipr_initiate_ioa_reset(struc
 	if (ioa_cfg->ioa_is_dead)
 		return;
 
-	if (ioa_cfg->in_reset_reload && ioa_cfg->sdt_state == GET_DUMP)
-		ioa_cfg->sdt_state = ABORT_DUMP;
+	if (ioa_cfg->in_reset_reload) {
+		if (ioa_cfg->sdt_state == GET_DUMP)
+			ioa_cfg->sdt_state = WAIT_FOR_DUMP;
+		else if (ioa_cfg->sdt_state == READ_DUMP)
+			ioa_cfg->sdt_state = ABORT_DUMP;
+	}
 
 	if (ioa_cfg->reset_retries++ >= IPR_NUM_RESET_RELOAD_RETRIES) {
 		dev_err(&ioa_cfg->pdev->dev,
_
