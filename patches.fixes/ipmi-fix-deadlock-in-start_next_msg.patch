From: Jean Delvare <jdelvare@suse.de>
Subject: ipmi: Fix deadlock in start_next_msg()
References: bnc#730749
Patch-mainline: Not yet (sent to Corey Minyard on November 29th, 2011)

When a problem happens in start_next_msg() it will call
return_hosed_msg() with si_lock and msg_lock held, which in turn will
call deliver_recv_msg(), which ultimately will temporarily release
si_lock. When reacquiring it, the code is taking si_lock with msg_lock
already held, which is opposite to the correct order (take si_lock
first and then msg_lock.) This can deadlock with other threads which
follow the correct order.

Releasing msg_lock before calling return_hosed_msg() fixes the issue.

Signed-off-by: Jean Delvare <jdelvare@suse.de>
Cc: Corey Minyard <minyard@acm.org>
---
 drivers/char/ipmi/ipmi_si_intf.c |   21 +++++++++++----------
 1 file changed, 11 insertions(+), 10 deletions(-)

--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@ -376,35 +376,36 @@ static enum si_sm_result start_next_msg(
 		smi_info->curr_msg = NULL;
 		rv = SI_SM_IDLE;
 	} else {
-		int err;
-
 		list_del(entry);
 		smi_info->curr_msg = list_entry(entry,
 						struct ipmi_smi_msg,
 						link);
+		rv = SI_SM_CALL_WITHOUT_DELAY;
+	}
+
+	if (!smi_info->run_to_completion)
+		spin_unlock(&(smi_info->msg_lock));
+
+	if (smi_info->curr_msg) {
+		int err;
+
 #ifdef DEBUG_TIMING
 		do_gettimeofday(&t);
 		printk(KERN_DEBUG "**Start2: %d.%9.9d\n", t.tv_sec, t.tv_usec);
 #endif
 		err = atomic_notifier_call_chain(&xaction_notifier_list,
 				0, smi_info);
-		if (err & NOTIFY_STOP_MASK) {
-			rv = SI_SM_CALL_WITHOUT_DELAY;
+		if (err & NOTIFY_STOP_MASK)
 			goto out;
-		}
+
 		err = smi_info->handlers->start_transaction(
 			smi_info->si_sm,
 			smi_info->curr_msg->data,
 			smi_info->curr_msg->data_size);
 		if (err)
 			return_hosed_msg(smi_info, err);
-
-		rv = SI_SM_CALL_WITHOUT_DELAY;
 	}
  out:
-	if (!smi_info->run_to_completion)
-		spin_unlock(&(smi_info->msg_lock));
-
 	return rv;
 }
 
