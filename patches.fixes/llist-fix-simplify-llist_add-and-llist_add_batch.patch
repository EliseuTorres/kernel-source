From: Oleg Nesterov <oleg@redhat.com>
Date: Mon, 8 Jul 2013 14:24:18 -0700
Subject: llist: fix/simplify llist_add() and llist_add_batch()
References: bnc#913030,FATE#317455
Patch-Mainline: v3.12
Git-commit: fb4214db50b00558cc6e274c88b3f7325068e942

1. This is mostly theoretical, but llist_add*() need ACCESS_ONCE().

   Otherwise it is not guaranteed that the first cmpxchg() uses the
   same value for old_entry and new_last->next.

2. These helpers cache the result of cmpxchg() and read the initial
   value of head->first before the main loop. I do not think this
   makes sense. In the likely case cmpxchg() succeeds, otherwise
   it doesn't hurt to reload head->first.

   I think it would be better to simplify the code and simply read
   ->first before cmpxchg().

Signed-off-by: Oleg Nesterov <oleg@redhat.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Andrey Vagin <avagin@openvz.org>
Cc: "Eric W. Biederman" <ebiederm@xmission.com>
Cc: David Howells <dhowells@redhat.com>
Cc: Huang Ying <ying.huang@intel.com>
Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 include/linux/llist.h | 15 +++++----------
 lib/llist.c           | 15 +++++----------
 2 files changed, 10 insertions(+), 20 deletions(-)

diff --git a/include/linux/llist.h b/include/linux/llist.h
index 8295946..aef5f3c 100644
--- a/include/linux/llist.h
+++ b/include/linux/llist.h
@@ -147,18 +147,13 @@ static inline bool llist_empty(const struct llist_head *head)
  */
 static inline bool llist_add(struct llist_node *new, struct llist_head *head)
 {
-	struct llist_node *entry, *old_entry;
+	struct llist_node *first;
 
-	entry = head->first;
-	for (;;) {
-		old_entry = entry;
-		new->next = entry;
-		entry = cmpxchg(&head->first, old_entry, new);
-		if (entry == old_entry)
-			break;
-	}
+	do {
+		new->next = first = ACCESS_ONCE(head->first);
+	} while (cmpxchg(&head->first, first, new) != first);
 
-	return old_entry == NULL;
+	return !first;
 }
 
 /**
diff --git a/lib/llist.c b/lib/llist.c
index 700cff7..d562158 100644
--- a/lib/llist.c
+++ b/lib/llist.c
@@ -40,18 +40,13 @@
 bool llist_add_batch(struct llist_node *new_first, struct llist_node *new_last,
 		     struct llist_head *head)
 {
-	struct llist_node *entry, *old_entry;
+	struct llist_node *first;
 
-	entry = head->first;
-	for (;;) {
-		old_entry = entry;
-		new_last->next = entry;
-		entry = cmpxchg(&head->first, old_entry, new_first);
-		if (entry == old_entry)
-			break;
-	}
+	do {
+		new_last->next = first = ACCESS_ONCE(head->first);
+	} while (cmpxchg(&head->first, first, new_first) != first);
 
-	return old_entry == NULL;
+	return !first;
 }
 EXPORT_SYMBOL_GPL(llist_add_batch);
 
-- 
1.8.5.2

