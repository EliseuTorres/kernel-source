From: Jiri Kosina <jkosina@suse.cz>
Subject: [PATCH] HID: fix data access in implement()
Patch-mainline: 27ce40503 in hid.git, queued for 3.12
References: bnc#783475

implement() is setting bytes in LE data stream. In case the data is not
aligned to 64bits, it reads past the allocated buffer. It doesn't really
change any value there (it's properly bitmasked), but in case that this
read past the boundary hits a page boundary, pagefault happens when
accessing 64bits of 'x' in implement(), and kernel oopses.

This happens much more often when numbered reports are in use, as the
initial 8bit skip in the buffer makes the whole process work on values
which are not aligned to 64bits.

This problem dates back to attempts in 2005 and 2006 to make implement()
and extract() as generic as possible, and even back then the problem
was realized by Adam Kroperlin, but falsely assumed to be impossible
to cause any harm:

http://www.mail-archive.com/linux-usb-devel@lists.sourceforge.net/msg47690.html

I have made several attempts at fixing it "on the spot" directly in
implement(), but the results were horrible; the special casing for processing
last 64bit chunk and switching to different math makes it unreadable mess.

I therefore took a path to allocate a few bytes more which will never make
it into final report, but are there as a cushion for all the 64bit math
operations happening in implement() and extract().

All callers of hid_output_report() are converted at the same time to allocate
the buffer by newly introduced hid_alloc_report_buf() helper.

Bruno noticed that the whole raw_size test can be dropped as well, as
hid_alloc_report_buf() makes sure that the buffer is always of a proper
size.

Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
Acked-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>
---
 drivers/hid/hid-core.c            |    8 ++++++++
 drivers/hid/hid-logitech-dj.c     |   12 ++++++++++--
 drivers/hid/hid-picolcd_debugfs.c |   10 +++++++++-
 drivers/hid/usbhid/hid-core.c     |    4 ++--
 include/linux/hid.h               |    1 +
 net/bluetooth/hidp/core.c         |   14 +++++++++-----
 6 files changed, 39 insertions(+), 10 deletions(-)

Index: linux-3.0-SLE11-SP2-bnc783475/drivers/hid/hid-core.c
===================================================================
--- linux-3.0-SLE11-SP2-bnc783475.orig/drivers/hid/hid-core.c
+++ linux-3.0-SLE11-SP2-bnc783475/drivers/hid/hid-core.c
@@ -981,6 +981,14 @@ void hid_output_report(struct hid_report
 }
 EXPORT_SYMBOL_GPL(hid_output_report);
 
+u8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags)
+{
+	int len = ((report->size - 1) >> 3) + 1 + (report->id > 0) + 7;
+
+	return kmalloc(len, flags);
+}
+EXPORT_SYMBOL_GPL(hid_alloc_report_buf);
+
 /*
  * Set a field value. The report this field belongs to has to be
  * created and transferred to the device, to set this value in the
Index: linux-3.0-SLE11-SP2-bnc783475/drivers/hid/usbhid/hid-core.c
===================================================================
--- linux-3.0-SLE11-SP2-bnc783475.orig/drivers/hid/usbhid/hid-core.c
+++ linux-3.0-SLE11-SP2-bnc783475/drivers/hid/usbhid/hid-core.c
@@ -513,7 +513,7 @@ static void __usbhid_submit_report(struc
 			return;
 		}
 
-		usbhid->out[usbhid->outhead].raw_report = kmalloc(len, GFP_ATOMIC);
+		usbhid->out[usbhid->outhead].raw_report = hid_alloc_report_buf(report, GFP_ATOMIC);
 		if (!usbhid->out[usbhid->outhead].raw_report) {
 			hid_warn(hid, "output queueing failed\n");
 			return;
@@ -545,7 +545,7 @@ static void __usbhid_submit_report(struc
 	}
 
 	if (dir == USB_DIR_OUT) {
-		usbhid->ctrl[usbhid->ctrlhead].raw_report = kmalloc(len, GFP_ATOMIC);
+		usbhid->ctrl[usbhid->ctrlhead].raw_report = hid_alloc_report_buf(report, GFP_ATOMIC);
 		if (!usbhid->ctrl[usbhid->ctrlhead].raw_report) {
 			hid_warn(hid, "control queueing failed\n");
 			return;
Index: linux-3.0-SLE11-SP2-bnc783475/include/linux/hid.h
===================================================================
--- linux-3.0-SLE11-SP2-bnc783475.orig/include/linux/hid.h
+++ linux-3.0-SLE11-SP2-bnc783475/include/linux/hid.h
@@ -708,6 +708,7 @@ int hid_set_field(struct hid_field *, un
 int hid_input_report(struct hid_device *, int type, u8 *, int, int);
 int hidinput_find_field(struct hid_device *hid, unsigned int type, unsigned int code, struct hid_field **field);
 void hid_output_report(struct hid_report *report, __u8 *data);
+u8 *hid_alloc_report_buf(struct hid_report *report, gfp_t flags);
 struct hid_device *hid_allocate_device(void);
 struct hid_report *hid_register_report(struct hid_device *device, unsigned type, unsigned id);
 int hid_parse_report(struct hid_device *hid, __u8 *start, unsigned size);
Index: linux-3.0-SLE11-SP2-bnc783475/net/bluetooth/hidp/core.c
===================================================================
--- linux-3.0-SLE11-SP2-bnc783475.orig/net/bluetooth/hidp/core.c
+++ linux-3.0-SLE11-SP2-bnc783475/net/bluetooth/hidp/core.c
@@ -308,16 +308,19 @@ static int hidp_queue_report(struct hidp
 
 static int hidp_send_report(struct hidp_session *session, struct hid_report *report)
 {
-	unsigned char buf[32];
-	int rsize;
+	u8 *buf;
+	int rsize, ret;
 
-	rsize = ((report->size - 1) >> 3) + 1 + (report->id > 0);
-	if (rsize > sizeof(buf))
+ 	buf = hid_alloc_report_buf(report, GFP_ATOMIC);
+ 	if (!buf)
 		return -EIO;
 
 	hid_output_report(report, buf);
 
-	return hidp_queue_report(session, buf, rsize);
+	ret = hidp_queue_report(session, buf, rsize);
+	
+	kfree(buf);
+	return ret;
 }
 
 static int hidp_get_raw_report(struct hid_device *hid,
Index: linux-3.0-SLE11-SP2-bnc783475/drivers/hid/hid-picolcd.c
===================================================================
--- linux-3.0-SLE11-SP2-bnc783475.orig/drivers/hid/hid-picolcd.c
+++ linux-3.0-SLE11-SP2-bnc783475/drivers/hid/hid-picolcd.c
@@ -1851,7 +1851,7 @@ static void dump_buff_as_hex(char *dst,
 static void picolcd_debug_out_report(struct picolcd_data *data,
 		struct hid_device *hdev, struct hid_report *report)
 {
-	u8 raw_data[70];
+	u8 *raw_data;
 	int raw_size = (report->size >> 3) + 1;
 	char *buff;
 #define BUFF_SZ 256
@@ -1864,11 +1864,18 @@ static void picolcd_debug_out_report(str
 	if (!buff)
 		return;
 
+	raw_data = hid_alloc_report_buf(report, GFP_ATOMIC);
+	if (!raw_data) {
+		kfree(buff);
+		return;
+	}
+
 	snprintf(buff, BUFF_SZ, "\nout report %d (size %d) =  ",
 			report->id, raw_size);
 	hid_debug_event(hdev, buff);
 	if (raw_size + 5 > sizeof(raw_data)) {
 		kfree(buff);
+		kfree(raw_data);
 		hid_debug_event(hdev, " TOO BIG\n");
 		return;
 	} else {
@@ -2101,6 +2108,7 @@ static void picolcd_debug_out_report(str
 		break;
 	}
 	wake_up_interruptible(&hdev->debug_wait);
+	kfree(raw_data);
 	kfree(buff);
 }
 
