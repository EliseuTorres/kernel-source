From: Michal Hocko <mhocko@suse.cz>
Subject: printk: Make NMI ringbuffer size independent on log_buf_len
Patch-mainline: not yet
References: bnc#831949

Having NMI ring buffer same size as regular ring buffer might be considered as
a waste of memory. Especially when the regular ring buffer is increased to a
big value. So create a separate kernel parameters to set nmi_log_buf_len.

Signed-off-by: Michal Hocko <mhocko@suse.cz>

---
 kernel/printk.c |   47 ++++++++++++++++++++++++++++++++++-------------
 1 file changed, 34 insertions(+), 13 deletions(-)

--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -112,8 +112,8 @@ static DEFINE_SPINLOCK(logbuf_lock);
 static DEFINE_SPINLOCK(nmi_logbuf_lock);
 
 #define LOG_BUF_MASK (log_buf_len-1)
-#define __LOG_BUF(buf, idx) (buf[(idx) & LOG_BUF_MASK])
-#define LOG_BUF(idx) (__LOG_BUF(log_buf, idx))
+#define __LOG_BUF(buf, len, idx) (buf[(idx) & ((len)-1)])
+#define LOG_BUF(idx) (__LOG_BUF(log_buf, log_buf_len, idx))
 
 /*
  * The indices into log_buf are not constrained to log_buf_len - they
@@ -161,6 +161,7 @@ static char __log_buf[__LOG_BUF_LEN];
 static char *log_buf = __log_buf;
 static char *nmi_log_buf = NULL;
 static int log_buf_len = __LOG_BUF_LEN;
+static int nmi_log_buf_len = __LOG_BUF_LEN;
 static unsigned logged_chars; /* Number of chars produced since last read+clear operation */
 static int saved_console_loglevel = -1;
 
@@ -184,6 +185,7 @@ void log_buf_kexec_setup(void)
 
 /* requested log_buf_len from kernel cmdline */
 static unsigned long __initdata new_log_buf_len;
+static unsigned long __initdata new_nmi_log_buf_len;
 
 /* save requested log_buf_len since it's too early to process it */
 static int __init log_buf_len_setup(char *str)
@@ -199,6 +201,19 @@ static int __init log_buf_len_setup(char
 }
 early_param("log_buf_len", log_buf_len_setup);
 
+static int __init nmi_log_buf_len_setup(char *str)
+{
+	unsigned size = memparse(str, &str);
+
+	if (size)
+		size = roundup_pow_of_two(size);
+	if (size > nmi_log_buf_len)
+		new_nmi_log_buf_len = size;
+
+	return 0;
+}
+early_param("nmi_log_buf_len", nmi_log_buf_len_setup);
+
 char * __init alloc_log_buf(int early, unsigned len)
 {
 	if (early) {
@@ -221,13 +236,19 @@ void __init setup_log_buf(int early)
 	int free;
 
 	if (!nmi_log_buf) {
-		unsigned len = (new_log_buf_len > log_buf_len) ? new_log_buf_len : log_buf_len;
-		nmi_log_buf = alloc_log_buf(early, len);
-		if (!nmi_log_buf)
-			pr_err("%ld bytes not available for nmi ring buffer\n",
-				new_log_buf_len);
-		else
-			pr_info("nmi ring buffer: %d\n", len);
+		unsigned len = (nmi_log_buf_len > new_nmi_log_buf_len) ?
+			nmi_log_buf_len: new_nmi_log_buf_len;
+
+		if (len) {
+			nmi_log_buf = alloc_log_buf(early, len);
+			if (!nmi_log_buf)
+				pr_err("%ld bytes not available for nmi ring buffer\n",
+					len);
+			else {
+				nmi_log_buf_len = len;
+				pr_info("nmi ring buffer: %d\n", len);
+			}
+		}
 	}
 
 	if (!new_log_buf_len)
@@ -709,7 +730,7 @@ static void emit_log_char(char c)
 
 static void emit_nmi_log_char(char c)
 {
-	__LOG_BUF(nmi_log_buf, nmi_log_end) = c;
+	__LOG_BUF(nmi_log_buf, nmi_log_buf_len, nmi_log_end) = c;
 	/*
 	 * Make sure that the buffer content is visible before nmi_log_end
 	 * for out of lock access so that we can be sure that the content
@@ -897,11 +918,11 @@ static void handle_nmi_delayed_printk(vo
 			break;
 
 		/* Make sure the ring buffer doesn't overflow */
-		if (end_idx - idx > log_buf_len)
-			idx = end_idx - log_buf_len;
+		if (end_idx - idx > nmi_log_buf_len)
+			idx = end_idx - nmi_log_buf_len;
 
 		smp_rmb();
-		emit_log_char(__LOG_BUF(nmi_log_buf, idx));
+		emit_log_char(__LOG_BUF(nmi_log_buf, nmi_log_buf_len, idx));
 	}
 	/* Nobody touches nmi_log_buf except for us and we are locked */
 	nmi_log_start = idx;
