From: David Howells <dhowells@redhat.com>
Date: Fri, 10 May 2013 19:50:26 +0100
Subject: [PATCH] FS-Cache: Wrap checks on object state
Git-commit: 493f7bc11457bc1f6fbf25a4b2bdf215ebaf050f
Patch-mainline: v3.11
References: bnc#880344

Wrap checks on object state (mostly outside of fs/fscache/object.c) with
inline functions so that the mechanism can be replaced.

Some of the state checks within object.c are left as-is as they will be
replaced.

Signed-off-by: David Howells <dhowells@redhat.com>
Tested-by: Milosz Tanski <milosz@adfin.com>
Acked-by: Jeff Layton <jlayton@redhat.com>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/cachefiles/namei.c         |    4 ++--
 fs/fscache/cache.c            |    2 +-
 fs/fscache/cookie.c           |    8 ++++----
 fs/fscache/object.c           |    8 ++++----
 fs/fscache/operation.c        |    2 +-
 include/linux/fscache-cache.h |   37 ++++++++++++++++++++++++++++---------
 6 files changed, 40 insertions(+), 21 deletions(-)

--- linux-3.0-SLE11-SP3.orig/fs/cachefiles/namei.c
+++ linux-3.0-SLE11-SP3/fs/cachefiles/namei.c
@@ -131,7 +131,7 @@ found_dentry:
 	       fscache_object_states[object->fscache.state],
 	       dentry);
 
-	if (object->fscache.state < FSCACHE_OBJECT_DYING) {
+	if (fscache_object_is_live(&object->fscache)) {
 		printk(KERN_ERR "\n");
 		printk(KERN_ERR "CacheFiles: Error:"
 		       " Can't preemptively bury live object\n");
@@ -193,7 +193,7 @@ try_again:
 	/* an old object from a previous incarnation is hogging the slot - we
 	 * need to wait for it to be destroyed */
 wait_for_old_object:
-	if (xobject->fscache.state < FSCACHE_OBJECT_DYING) {
+	if (fscache_object_is_live(&object->fscache)) {
 		printk(KERN_ERR "\n");
 		printk(KERN_ERR "CacheFiles: Error:"
 		       " Unexpected object collision\n");
--- linux-3.0-SLE11-SP3.orig/fs/fscache/cache.c
+++ linux-3.0-SLE11-SP3/fs/fscache/cache.c
@@ -115,7 +115,7 @@ struct fscache_cache *fscache_select_cac
 				     struct fscache_object, cookie_link);
 
 		cache = object->cache;
-		if (object->state >= FSCACHE_OBJECT_DYING ||
+		if (fscache_object_is_dying(object) ||
 		    test_bit(FSCACHE_IOERROR, &cache->flags))
 			cache = NULL;
 
--- linux-3.0-SLE11-SP3.orig/fs/fscache/cookie.c
+++ linux-3.0-SLE11-SP3/fs/fscache/cookie.c
@@ -286,7 +286,7 @@ static int fscache_alloc_object(struct f
 
 object_already_extant:
 	ret = -ENOBUFS;
-	if (object->state >= FSCACHE_OBJECT_DYING) {
+	if (fscache_object_is_dead(object)) {
 		spin_unlock(&cookie->lock);
 		goto error;
 	}
@@ -323,7 +323,7 @@ static int fscache_attach_object(struct
 	ret = -EEXIST;
 	hlist_for_each_entry(p, _n, &cookie->backing_objects, cookie_link) {
 		if (p->cache == object->cache) {
-			if (p->state >= FSCACHE_OBJECT_DYING)
+			if (fscache_object_is_dying(p))
 				ret = -ENOBUFS;
 			goto cant_attach_object;
 		}
@@ -334,7 +334,7 @@ static int fscache_attach_object(struct
 	hlist_for_each_entry(p, _n, &cookie->parent->backing_objects,
 			     cookie_link) {
 		if (p->cache == object->cache) {
-			if (p->state >= FSCACHE_OBJECT_DYING) {
+			if (fscache_object_is_dying(p)) {
 				ret = -ENOBUFS;
 				spin_unlock(&cookie->parent->lock);
 				goto cant_attach_object;
@@ -402,7 +402,7 @@ void __fscache_invalidate(struct fscache
 			object = hlist_entry(cookie->backing_objects.first,
 					     struct fscache_object,
 					     cookie_link);
-			if (object->state < FSCACHE_OBJECT_DYING)
+			if (fscache_object_is_live(object))
 				fscache_raise_event(
 					object, FSCACHE_OBJECT_EV_INVALIDATE);
 		}
--- linux-3.0-SLE11-SP3.orig/fs/fscache/object.c
+++ linux-3.0-SLE11-SP3/fs/fscache/object.c
@@ -460,10 +460,10 @@ static void fscache_initialise_object(st
 		spin_lock_nested(&parent->lock, 1);
 		_debug("parent %s", fscache_object_states[parent->state]);
 
-		if (parent->state >= FSCACHE_OBJECT_DYING) {
+		if (fscache_object_is_dying(parent)) {
 			_debug("bad parent");
 			set_bit(FSCACHE_OBJECT_EV_WITHDRAW, &object->events);
-		} else if (parent->state < FSCACHE_OBJECT_AVAILABLE) {
+		} else if (!fscache_object_is_available(parent)) {
 			_debug("wait");
 
 			/* we may get woken up in this state by child objects
@@ -520,9 +520,9 @@ static void fscache_lookup_object(struct
 	ASSERTCMP(parent->n_obj_ops, >, 0);
 
 	/* make sure the parent is still available */
-	ASSERTCMP(parent->state, >=, FSCACHE_OBJECT_AVAILABLE);
+	ASSERT(fscache_object_is_available(parent));
 
-	if (parent->state >= FSCACHE_OBJECT_DYING ||
+	if (fscache_object_is_dying(parent) ||
 	    test_bit(FSCACHE_IOERROR, &object->cache->flags)) {
 		_debug("unavailable");
 		set_bit(FSCACHE_OBJECT_EV_WITHDRAW, &object->events);
--- linux-3.0-SLE11-SP3.orig/fs/fscache/operation.c
+++ linux-3.0-SLE11-SP3/fs/fscache/operation.c
@@ -35,7 +35,7 @@ void fscache_enqueue_operation(struct fs
 
 	ASSERT(list_empty(&op->pend_link));
 	ASSERT(op->processor != NULL);
-	ASSERTCMP(op->object->state, >=, FSCACHE_OBJECT_AVAILABLE);
+	ASSERT(fscache_object_is_available(op->object));
 	ASSERTCMP(atomic_read(&op->usage), >, 0);
 	ASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);
 
--- linux-3.0-SLE11-SP3.orig/include/linux/fscache-cache.h
+++ linux-3.0-SLE11-SP3/include/linux/fscache-cache.h
@@ -417,15 +417,6 @@ struct fscache_object {
 
 extern const char *fscache_object_states[];
 
-#define fscache_object_is_active(obj)			      \
-	(!test_bit(FSCACHE_IOERROR, &(obj)->cache->flags) &&  \
-	 (obj)->state >= FSCACHE_OBJECT_AVAILABLE &&	      \
-	 (obj)->state < FSCACHE_OBJECT_DYING)
-
-#define fscache_object_is_dead(obj)				\
-	(test_bit(FSCACHE_IOERROR, &(obj)->cache->flags) &&	\
-	 (obj)->state >= FSCACHE_OBJECT_DYING)
-
 extern void fscache_object_init(struct fscache_object *, struct fscache_cookie *,
 				struct fscache_cache *);
 
@@ -438,6 +429,34 @@ extern void fscache_object_destroy(struc
 #define fscache_object_destroy(object) do {} while(0)
 #endif
 
+static inline bool fscache_object_is_live(struct fscache_object *object)
+{
+	return object->state < FSCACHE_OBJECT_DYING;
+}
+
+static inline bool fscache_object_is_dying(struct fscache_object *object)
+{
+	return !fscache_object_is_live(object);
+}
+
+static inline bool fscache_object_is_available(struct fscache_object *object)
+{
+	return object->state >= FSCACHE_OBJECT_AVAILABLE;
+}
+
+static inline bool fscache_object_is_active(struct fscache_object *object)
+{
+	return fscache_object_is_available(object) &&
+		fscache_object_is_live(object) &&
+		!test_bit(FSCACHE_IOERROR, &object->cache->flags);
+}
+
+static inline bool fscache_object_is_dead(struct fscache_object *object)
+{
+	return fscache_object_is_dying(object) &&
+		test_bit(FSCACHE_IOERROR, &object->cache->flags);
+}
+
 /**
  * fscache_object_destroyed - Note destruction of an object in a cache
  * @cache: The cache from which the object came
