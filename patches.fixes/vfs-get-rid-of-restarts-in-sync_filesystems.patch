From: Al Viro <viro@zeniv.linux.org.uk>
Date: Mon, 22 Mar 2010 19:56:42 -0400
Subject: get rid of restarts in sync_filesystems()
Git-commit: 8edd64bd6089e21f47dcdebb14b598b713213ddc
References: bnc#649000, fate#312304
Patch-mainline: v2.6.35-rc1

At the same time we can kill s_need_restart and local mutex in there.
__put_super() made public for a while; will be gone later.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Acked-by: Jan Kara <jack@suse.cz>
---
 fs/super.c         |    2 +-
 fs/sync.c          |   28 +++-------------------------
 include/linux/fs.h |    2 +-
 3 files changed, 5 insertions(+), 27 deletions(-)

Index: linux-2.6.32-writeback-SLE11-SP1/fs/super.c
===================================================================
--- linux-2.6.32-writeback-SLE11-SP1.orig/fs/super.c
+++ linux-2.6.32-writeback-SLE11-SP1/fs/super.c
@@ -129,7 +129,7 @@ static inline void destroy_super(struct
  * Drop a superblock's refcount.  Returns non-zero if the superblock was
  * destroyed.  The caller must hold sb_lock.
  */
-static int __put_super(struct super_block *sb)
+int __put_super(struct super_block *sb)
 {
 	int ret = 0;
 
Index: linux-2.6.32-writeback-SLE11-SP1/fs/sync.c
===================================================================
--- linux-2.6.32-writeback-SLE11-SP1.orig/fs/sync.c
+++ linux-2.6.32-writeback-SLE11-SP1/fs/sync.c
@@ -78,35 +78,15 @@ EXPORT_SYMBOL_GPL(sync_filesystem);
 /*
  * Sync all the data for all the filesystems (called by sys_sync() and
  * emergency sync)
- *
- * This operation is careful to avoid the livelock which could easily happen
- * if two or more filesystems are being continuously dirtied.  s_need_sync
- * is used only here.  We set it against all filesystems and then clear it as
- * we sync them.  So redirtied filesystems are skipped.
- *
- * But if process A is currently running sync_filesystems and then process B
- * calls sync_filesystems as well, process B will set all the s_need_sync
- * flags again, which will cause process A to resync everything.  Fix that with
- * a local mutex.
  */
 static void sync_filesystems(int wait)
 {
-	struct super_block *sb;
-	static DEFINE_MUTEX(mutex);
+	struct super_block *sb, *p = NULL;
 
-	mutex_lock(&mutex);		/* Could be down_interruptible */
 	spin_lock(&sb_lock);
-	list_for_each_entry(sb, &super_blocks, s_list)
-		if (!list_empty(&sb->s_instances))
-			sb->s_need_sync = 1;
-
-restart:
 	list_for_each_entry(sb, &super_blocks, s_list) {
 		if (list_empty(&sb->s_instances))
 			continue;
-		if (!sb->s_need_sync)
-			continue;
-		sb->s_need_sync = 0;
 		sb->s_count++;
 		spin_unlock(&sb_lock);
 
@@ -117,11 +97,13 @@ restart:
 
 		/* restart only when sb is no longer on the list */
 		spin_lock(&sb_lock);
-		if (__put_super_and_need_restart(sb))
-			goto restart;
+		if (p)
+			__put_super(sb);
+		p = sb;
 	}
+	if (p)
+		__put_super(p);
 	spin_unlock(&sb_lock);
-	mutex_unlock(&mutex);
 }
 
 /*
Index: linux-2.6.32-writeback-SLE11-SP1/include/linux/fs.h
===================================================================
--- linux-2.6.32-writeback-SLE11-SP1.orig/include/linux/fs.h
+++ linux-2.6.32-writeback-SLE11-SP1/include/linux/fs.h
@@ -1340,7 +1340,6 @@ struct super_block {
 	struct rw_semaphore	s_umount;
 	struct mutex		s_lock;
 	int			s_count;
-	int			s_need_sync;
 	atomic_t		s_active;
 #ifdef CONFIG_SECURITY
 	void                    *s_security;
@@ -1799,6 +1798,7 @@ extern int get_sb_pseudo(struct file_sys
 	struct vfsmount *mnt);
 extern void simple_set_mnt(struct vfsmount *mnt, struct super_block *sb);
 int __put_super_and_need_restart(struct super_block *sb);
+int __put_super(struct super_block *sb);
 void put_super(struct super_block *sb);
 
 /* Alas, no aliases. Too much hassle with bringing module.h everywhere */
