From: Michal Hocko <mhocko@suse.cz>
Subject: printk: Add NMI ringbuffer
Patch-mainline: not yet
References: bnc#831949

This is a preparatory patch for the NMI safe printk implementation.  It adds a
new ring buffer which will keep messages printed from NMI context which cannot
access the regular ring buffer because logbuf_lock is already held.

The ringbuffer is allocated during early initialization same as log_buf and it
shares the same lenght.

Signed-off-by: Michal Hocko <mhocko@suse.cz>

---
 kernel/printk.c |   43 +++++++++++++++++++++++++++++++------------
 1 file changed, 31 insertions(+), 12 deletions(-)

--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -103,7 +103,8 @@ static int console_locked, console_suspe
 static DEFINE_SPINLOCK(logbuf_lock);
 
 #define LOG_BUF_MASK (log_buf_len-1)
-#define LOG_BUF(idx) (log_buf[(idx) & LOG_BUF_MASK])
+#define __LOG_BUF(buf, idx) (buf[(idx) & LOG_BUF_MASK])
+#define LOG_BUF(idx) (__LOG_BUF(log_buf, idx))
 
 /*
  * The indices into log_buf are not constrained to log_buf_len - they
@@ -113,6 +114,9 @@ static unsigned log_start;	/* Index into
 static unsigned con_start;	/* Index into log_buf: next char to be sent to consoles */
 static unsigned log_end;	/* Index into log_buf: most-recently-written-char + 1 */
 
+static unsigned nmi_log_start;	/* Index into nmi_log_buf: next char to be copied to printk ringbuf */
+static unsigned nmi_log_end;	/* Index into nmi_log_buf: most-recently-written-char + 1 */
+
 /*
  * If exclusive_console is non-NULL then only this console is to be printed to.
  */
@@ -146,6 +150,7 @@ static int console_may_schedule;
 
 static char __log_buf[__LOG_BUF_LEN];
 static char *log_buf = __log_buf;
+static char *nmi_log_buf = NULL;
 static int log_buf_len = __LOG_BUF_LEN;
 static unsigned logged_chars; /* Number of chars produced since last read+clear operation */
 static int saved_console_loglevel = -1;
@@ -185,6 +190,20 @@ static int __init log_buf_len_setup(char
 }
 early_param("log_buf_len", log_buf_len_setup);
 
+char * __init alloc_log_buf(int early, unsigned len)
+{
+	if (early) {
+		unsigned long mem;
+
+		mem = memblock_alloc(len, PAGE_SIZE);
+		if (mem == MEMBLOCK_ERROR)
+			return NULL;
+		return __va(mem);
+	}
+
+	return alloc_bootmem_nopanic(len);
+}
+
 void __init setup_log_buf(int early)
 {
 	unsigned long flags;
@@ -192,20 +211,20 @@ void __init setup_log_buf(int early)
 	char *new_log_buf;
 	int free;
 
+	if (!nmi_log_buf) {
+		unsigned len = (new_log_buf_len > log_buf_len) ? new_log_buf_len : log_buf_len;
+		nmi_log_buf = alloc_log_buf(early, len);
+		if (!nmi_log_buf)
+			pr_err("%ld bytes not available for nmi ring buffer\n",
+				new_log_buf_len);
+		else
+			pr_info("nmi ring buffer: %d\n", len);
+	}
+
 	if (!new_log_buf_len)
 		return;
 
-	if (early) {
-		unsigned long mem;
-
-		mem = memblock_alloc(new_log_buf_len, PAGE_SIZE);
-		if (mem == MEMBLOCK_ERROR)
-			return;
-		new_log_buf = __va(mem);
-	} else {
-		new_log_buf = alloc_bootmem_nopanic(new_log_buf_len);
-	}
-
+	new_log_buf = alloc_log_buf(early, new_log_buf_len);
 	if (unlikely(!new_log_buf)) {
 		pr_err("log_buf_len: %ld bytes not available\n",
 			new_log_buf_len);
