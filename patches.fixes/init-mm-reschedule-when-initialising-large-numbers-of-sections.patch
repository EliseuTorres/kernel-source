From: Mel Gorman <mgorman@suse.de>
Date: Mon, 2 Jul 2012 11:15:32 +0100
Subject: [PATCH] init: mm: Reschedule when initialising large numbers of

References: bnc#755620
Patch-mainline: No, should be

When initialising memory on machines with memory sizes in the terabyte
range the following warning is sometimes visible during boot.

[   33.982120] BUG: soft lockup - CPU#0 stuck for 22s! [swapper:1]
[   33.982123] Modules linked in:
[   33.982123] Supported: Yes
[   33.982123] CPU 0
[   33.982123] Modules linked in:
[   33.982123] Supported: Yes
[   33.982123]
[   33.982123] Pid: 1, comm: swapper Not tainted 3.0.13-0.27-default #1 IBM -[7145AC1]-/Node 1, Processor Card
[   33.982123] RIP: 0010:[<ffffffff811c1adc>]  [<ffffffff811c1adc>] __sysfs_add_one+0x6c/0xc0
[   33.982123] RSP: 0018:ffff8a4c9eb99c50  EFLAGS: 00000216
[   33.982123] RAX: ffff8a4c9d5365a0 RBX: ffff8a4c9eb99c64 RCX: ffff8cdc4e41dab0
[   33.982123] RDX: 0000000000024b69 RSI: ffff8cec3e1ba500 RDI: ffff8cdc4ec911e0
[   33.982123] RBP: ffff8a4c9eb99cb0 R08: 00000000000003c0 R09: ffff8a4c9eb99b90
[   33.982123] R10: 000000000000000a R11: 0000000000000000 R12: ffffffff8144a06e
[   33.982123] R13: 0000000000000000 R14: 0000000000000000 R15: ffff8a7c8f275f40
[   33.982123] FS:  0000000000000000(0000) GS:ffff8a506f800000(0000) knlGS:0000000000000000
[   33.982123] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
[   33.982123] CR2: 0000000000000000 CR3: 0000000001a03000 CR4: 00000000000006f0
[   33.982123] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[   33.982123] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
[   33.982123] Process swapper (pid: 1, threadinfo ffff8a4c9eb98000, task ffff8a4c9eb96040)
[   33.982123] Stack:
[   33.982123]  ffffffff81787c83 ffff8cfc2d8e9b40 ffff8a4c9eb99cb0 ffffffff811c1ba7
[   33.982123]  ffff8a4c9eb99cb0 ffff8cfc2d8e9b40 00000000fffffff4 0000000000000000
[   33.982123]  ffff8ccc5e1c2ee8 ffffffff811c276b ffffffffff0a0210 ffff8a4c9eb99d10
[   33.982123] Call Trace:
[   33.982123]  [<ffffffff811c1ba7>] sysfs_add_one+0x27/0xe0
[   33.982123]  [<ffffffff811c276b>] create_dir+0x7b/0xe0
[   33.982123]  [<ffffffff811c285f>] sysfs_create_dir+0x8f/0xb0
[   33.982123]  [<ffffffff81247c7f>] kobject_add_internal+0xff/0x250
[   33.982123]  [<ffffffff81247f77>] kobject_init_and_add+0x57/0x70
[   33.982123]  [<ffffffff81319cf8>] sysdev_register+0x78/0x140
[   33.982123]  [<ffffffff81329c29>] init_memory_block+0xc9/0x150
[   33.982123]  [<ffffffff81329fc8>] add_memory_section+0xb8/0xc0
[   33.982123]  [<ffffffff81c39177>] memory_dev_init+0x77/0x11b
[   33.982123]  [<ffffffff81bfb85a>] kernel_init+0x208/0x2ba
[   33.982123]  [<ffffffff8144a7c4>] kernel_thread_helper+0x4/0x10
[   33.982123] DWARF2 unwinder stuck at kernel_thread_helper+0x4/0x10

This is harmless but annoying. The following patch adds a cond_resched()
in memory_dev_init(), link_mem_sections() and swsusp_free() as each of them
walk either all memory sections or all PFNs without rescheduling. This should
be safe as the CPU subsystem should already be up and process management
working. This will slow boot slightly but generate fewer bug reports.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 drivers/base/memory.c   |    9 +++++++++
 drivers/base/node.c     |    8 ++++++++
 kernel/power/snapshot.c |    6 +++++-
 3 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/drivers/base/memory.c b/drivers/base/memory.c
index 5fb6aae..f11a5ba 100644
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@ -23,6 +23,7 @@
 #include <linux/mutex.h>
 #include <linux/stat.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 
 #include <asm/atomic.h>
 #include <asm/uaccess.h>
@@ -673,6 +674,14 @@ int __init memory_dev_init(void)
 	 * during boot and have been initialized
 	 */
 	for (i = 0; i < NR_MEM_SECTIONS; i++) {
+		/*
+		 * On machines with large amounts of memory it can take
+		 * a considerable amount of time to create all the sysfs
+		 * entries. Rescheduling actually slows boot slightly but
+		 * suppresses a soft lockup warning
+		 */
+		cond_resched();
+
 		if (!present_section_nr(i))
 			continue;
 		err = add_memory_section(0, __nr_to_section(i), MEM_ONLINE,
diff --git a/drivers/base/node.c b/drivers/base/node.c
index 5693ece..d5ed5a9 100644
--- a/drivers/base/node.c
+++ b/drivers/base/node.c
@@ -456,6 +456,14 @@ static int link_mem_sections(int nid)
 		struct mem_section *mem_sect;
 		int ret;
 
+		/*
+		 * On machines with large amounts of memory it can take
+		 * a considerable amount of time to create all the sysfs
+		 * entries. Rescheduling actually slows boot slightly but
+		 * suppresses a soft lockup warning
+		 */
+		cond_resched();
+
 		if (!present_section_nr(section_nr))
 			continue;
 		mem_sect = __nr_to_section(section_nr);
diff --git a/kernel/power/snapshot.c b/kernel/power/snapshot.c
index 06efa54..c1b8286 100644
--- a/kernel/power/snapshot.c
+++ b/kernel/power/snapshot.c
@@ -1085,7 +1085,10 @@ void swsusp_free(void)
 
 	for_each_populated_zone(zone) {
 		max_zone_pfn = zone->zone_start_pfn + zone->spanned_pages;
-		for (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++)
+		for (pfn = zone->zone_start_pfn; pfn < max_zone_pfn; pfn++) {
+			/* PFN walker on large machines can take a long time */
+			cond_resched();
+
 			if (pfn_valid(pfn)) {
 				struct page *page = pfn_to_page(pfn);
 
@@ -1096,6 +1099,7 @@ void swsusp_free(void)
 					__free_page(page);
 				}
 			}
+		}
 	}
 	nr_copy_pages = 0;
 	nr_meta_pages = 0;
