From: Michal Kubecek <mkubecek@suse.cz>
Date: Wed, 12 Nov 2014 09:45:08 +0100
Subject: bonding: propagate LRO disabling down to slaves
Patch-mainline: Submitted, v3.19-rc1
Git-commit: fbe168ba91f7c327856f205699404284c2f09e36 (partial)
References: bnc#829110 bnc#891277 bnc#904053

Large receive offloading is known to cause problems if received packets
are passed to other host. Therefore the kernel disables it by calling
dev_disable_lro() whenever a network device is enslaved in a bridge or
forwarding is enabled for it (or globally). For virtual devices we need
to disable LRO on the underlying physical device (which is actually
receiving the packets).

The propagation already works for vlan and macvlan devices, this patch
adds propagation from bond device to its slaves. Unlike mainline, 3.0
kernel does not have generic upper/lower relationship so that iterating
through slaves needs to be done inside the bonding driver.

We also need to make sure that once LRO is disabled for a bond, it is
disabled for any slave added to it afterwards.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 drivers/net/bonding/bond_main.c | 23 +++++++++++++++++++++++
 include/linux/netdevice.h       |  7 +++++++
 net/core/dev.c                  | 11 +++++++++++
 3 files changed, 41 insertions(+)

diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c
index d123a4b..15a2ef8 100644
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@ -1977,6 +1977,9 @@ int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)
 	if (res)
 		goto err_detach;
 
+	if (!(bond_dev->features & NETIF_F_LRO))
+		dev_disable_lro(slave_dev);
+
 	res = netdev_rx_handler_register(slave_dev, bond_handle_frame,
 					 new_slave);
 	if (res) {
@@ -4343,6 +4346,17 @@ static netdev_tx_t bond_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	return ret;
 }
 
+/* only called from dev_disable_lro() under RTNL */
+static void bond_dev_disable_lro(struct net_device *dev)
+{
+	struct bonding *bond = netdev_priv(dev);
+	struct slave *slave;
+	int i;
+
+	bond_for_each_slave(bond, slave, i)
+		dev_disable_lro(slave->dev);
+}
+
 /*
  * set bond mode specific net device operations
  */
@@ -5029,6 +5043,10 @@ static int __init bonding_init(void)
 
 	bond_create_debugfs();
 
+	rtnl_lock();
+	bond_dev_disable_lro_cb = bond_dev_disable_lro;
+	rtnl_unlock();
+
 	for (i = 0; i < max_bonds; i++) {
 		res = bond_create(&init_net, NULL);
 		if (res)
@@ -5043,6 +5061,7 @@ static int __init bonding_init(void)
 out:
 	return res;
 err:
+	bond_dev_disable_lro_cb = NULL;
 	rtnl_link_unregister(&bond_link_ops);
 err_link:
 	unregister_pernet_subsys(&bond_net_ops);
@@ -5057,6 +5076,10 @@ static void __exit bonding_exit(void)
 	bond_destroy_sysfs();
 	bond_destroy_debugfs();
 
+	rtnl_lock();
+	bond_dev_disable_lro_cb = NULL;
+	rtnl_unlock();
+
 	rtnl_link_unregister(&bond_link_ops);
 	unregister_pernet_subsys(&bond_net_ops);
 
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index f078d04..e464096 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -2700,6 +2700,11 @@ static inline bool netif_is_macvlan(struct net_device *dev)
 	return dev->priv_flags & IFF_MACVLAN;
 }
 
+static inline bool netif_is_bond_master(struct net_device *dev)
+{
+	return dev->flags & IFF_MASTER && dev->priv_flags & IFF_BONDING;
+}
+
 static inline int netif_is_bond_slave(struct net_device *dev)
 {
 	return dev->flags & IFF_SLAVE && dev->priv_flags & IFF_BONDING;
@@ -2731,6 +2736,8 @@ static inline u32 dev_ethtool_get_flags(struct net_device *dev)
 	return dev->ethtool_ops->get_flags(dev);
 }
 
+extern void (*bond_dev_disable_lro_cb)(struct net_device *);
+
 /* Logging, debugging and troubleshooting/diagnostic helpers. */
 
 /* netdev_printk helpers, similar to dev_printk */
diff --git a/net/core/dev.c b/net/core/dev.c
index 17fd28b..cfee281 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -270,6 +270,9 @@ static RAW_NOTIFIER_HEAD(netdev_chain);
 DEFINE_PER_CPU_ALIGNED(struct softnet_data, softnet_data);
 EXPORT_PER_CPU_SYMBOL(softnet_data);
 
+void (*bond_dev_disable_lro_cb)(struct net_device *);
+EXPORT_SYMBOL(bond_dev_disable_lro_cb);
+
 #ifdef CONFIG_LOCKDEP
 /*
  * register_netdevice() inits txq->_xmit_lock and sets lockdep class
@@ -1344,6 +1347,14 @@ void dev_disable_lro(struct net_device *dev)
 	__ethtool_set_flags(dev, flags & ~ETH_FLAG_LRO);
 	if (unlikely(dev->features & NETIF_F_LRO))
 		netdev_WARN(dev, "failed to disable LRO!\n");
+
+	if (netif_is_bond_master(dev)) {
+		if (bond_dev_disable_lro_cb)
+			bond_dev_disable_lro_cb(dev);
+		else
+			WARN(1, "bond callback null but device %s exists",
+			     dev->name);
+	}
 }
 EXPORT_SYMBOL(dev_disable_lro);
 
-- 
1.8.4.5

