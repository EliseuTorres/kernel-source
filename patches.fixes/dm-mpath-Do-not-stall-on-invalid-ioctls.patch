From: Hannes Reinecke <hare@suse.de>
Date: Mon, 17 Feb 2014 14:33:57 +0100
Subject: dm-multipath: Do not stall on invalid ioctls
Patch-Mainline: Not yet
References: bnc#865342

An invalid ioctl is an invalid ioctl, irrespective on whether
we have valid paths. So always return a correct error code
for invalid ioctls.
This resolves an I/O stall where an uevent triggers blkid,
which will hang on an ioctl, which stalls udev, which in
turn stalls multipath waiting for the said uevent to
reinstate the failed path.

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/md/dm-mpath.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index de5944b..6f7e3dc 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -1666,8 +1666,20 @@ static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,
 	/*
 	 * Only pass ioctls through if the device sizes match exactly.
 	 */
-	if (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)
-		r = scsi_verify_blk_ioctl(NULL, cmd);
+	if (bdev &&
+	    ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)
+		r = -ENOTTY;
+
+	/*
+	 * Check if the ioctl is supported.
+	 */
+	if (!r || r == -ENOTCONN) {
+		int s;
+
+		s = scsi_verify_blk_ioctl(NULL, cmd);
+		if (s)
+			r = s;
+	}
 
 	if (r == -ENOTCONN && !fatal_signal_pending(current))
 		queue_work(kmultipathd, &m->process_queued_ios);
-- 
1.7.12.4

