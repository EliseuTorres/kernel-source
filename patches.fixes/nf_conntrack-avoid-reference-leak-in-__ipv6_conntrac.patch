From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 24 Mar 2014 10:00:04 +0100
Subject: nf_conntrack: avoid reference leak in __ipv6_conntrack_in()
Patch-mainline: Never, code rewritten
References: bnc#865419

When ipvs uses tunneling encapsulation and IPv6 fragments are
passed, __ipv6_conntrack_in() can be called twice for the same
skb (once for NF_INET_PRE_ROUTING, once for NF_INET_LOCAL_OUT).
In __ipv6_conntrack_in(), a reference to nf_conntrack is taken
twice in such situation but it is released only once.

Avoid this by putting the old value (if set - nf_conntrack_put()
takes care of the check).

The buggy code was removed by 6aafeef03 ("netfilter: push reasm
skb through instead of original frag skbs"). As this commit was
picked for stable-3.12, SLE12 doesn't need this patch.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c b/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
index 514000c..086886b 100644
--- a/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
@@ -142,6 +142,7 @@ static unsigned int __ipv6_conntrack_in(struct net *net,
 					int (*okfn)(struct sk_buff *))
 {
 	struct sk_buff *reasm = skb->nfct_reasm;
+	struct nf_conntrack *old_nfct;
 
 	/* This packet is fragmented and has reassembled packet. */
 	if (reasm) {
@@ -154,7 +155,8 @@ static unsigned int __ipv6_conntrack_in(struct net *net,
 				return ret;
 		}
 		nf_conntrack_get(reasm->nfct);
-		skb->nfct = reasm->nfct;
+		old_nfct = xchg(&skb->nfct, reasm->nfct);
+		nf_conntrack_put(old_nfct);
 		skb->nfctinfo = reasm->nfctinfo;
 		return NF_ACCEPT;
 	}
-- 
1.8.4.5

