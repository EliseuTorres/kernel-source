From: Trond Myklebust <Trond.Myklebust@netapp.com>
Date: Mon, 13 Aug 2012 18:54:45 -0400
Subject: [PATCH] NFS: Clean up helper function nfs4_select_rw_stateid()
Git-commit: 2a369153c82e0c83621b3e71d8f0c53394705bda
Patch-mainline: v3.7
References: bnc#888968

We want to be able to pass on the information that the page was not
dirtied under a lock. Instead of adding a flag parameter, do this
by passing a pointer to a 'struct nfs_lock_owner' that may be NULL.

Also reuse this structure in struct nfs_lock_context to carry the
fl_owner_t and pid_t.

Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/nfs/inode.c         |    8 ++++----
 fs/nfs/nfs4_fs.h       |    2 +-
 fs/nfs/nfs4proc.c      |    6 +++++-
 fs/nfs/nfs4state.c     |   16 ++++++++++++----
 fs/nfs/nfs4xdr.c       |    6 +++++-
 fs/nfs/pagelist.c      |    4 +++-
 fs/nfs/write.c         |   11 ++++++-----
 include/linux/nfs_fs.h |    8 ++++++--
 8 files changed, 42 insertions(+), 19 deletions(-)

--- linux-3.0-SLE11-SP3.orig/fs/nfs/inode.c
+++ linux-3.0-SLE11-SP3/fs/nfs/inode.c
@@ -543,8 +543,8 @@ out:
 static void nfs_init_lock_context(struct nfs_lock_context *l_ctx)
 {
 	atomic_set(&l_ctx->count, 1);
-	l_ctx->lockowner = current->files;
-	l_ctx->pid = current->tgid;
+	l_ctx->lockowner.l_owner = current->files;
+	l_ctx->lockowner.l_pid = current->tgid;
 	INIT_LIST_HEAD(&l_ctx->list);
 }
 
@@ -553,9 +553,9 @@ static struct nfs_lock_context *__nfs_fi
 	struct nfs_lock_context *pos;
 
 	list_for_each_entry(pos, &ctx->lock_context.list, list) {
-		if (pos->lockowner != current->files)
+		if (pos->lockowner.l_owner != current->files)
 			continue;
-		if (pos->pid != current->tgid)
+		if (pos->lockowner.l_pid != current->tgid)
 			continue;
 		atomic_inc(&pos->count);
 		return pos;
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4_fs.h
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4_fs.h
@@ -367,7 +367,7 @@ extern void nfs41_handle_recall_slot(str
 extern void nfs4_put_lock_state(struct nfs4_lock_state *lsp);
 extern int nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl);
 extern void nfs4_select_rw_stateid(nfs4_stateid *, struct nfs4_state *,
-		fmode_t, fl_owner_t, pid_t);
+		fmode_t, const struct nfs_lockowner *);
 extern int nfs4_lock_lost(const struct nfs_open_context *ctx,
 			  const struct nfs_lock_context *l_ctx);
 
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4proc.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4proc.c
@@ -1947,8 +1947,12 @@ static int _nfs4_do_setattr(struct inode
 	nfs_fattr_init(fattr);
 
 	if (state != NULL) {
+		struct nfs_lockowner lockowner = {
+			.l_owner = current->files,
+			.l_pid = current->tgid,
+		};
 		nfs4_select_rw_stateid(&arg.stateid, state, FMODE_WRITE,
-				current->files, current->tgid);
+				&lockowner);
 	} else if (nfs4_copy_delegation_stateid(&arg.stateid, inode,
 				FMODE_WRITE)) {
 		/* Use that stateid */
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4state.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4state.c
@@ -872,14 +872,22 @@ int nfs4_set_lock_state(struct nfs4_stat
 }
 
 static int nfs4_copy_lock_stateid(nfs4_stateid *dst, struct nfs4_state *state,
-		fl_owner_t fl_owner, pid_t fl_pid)
+		const struct nfs_lockowner *lockowner)
 {
 	struct nfs4_lock_state *lsp;
+	fl_owner_t fl_owner;
+	pid_t fl_pid;
 	int ret = -ENOENT;
 
+
+	if (lockowner == NULL)
+		goto out;
+
 	if (test_bit(LK_STATE_IN_USE, &state->flags) == 0)
 		goto out;
 
+	fl_owner = lockowner->l_owner;
+	fl_pid = lockowner->l_pid;
 	spin_lock(&state->state_lock);
 	lsp = __nfs4_find_lock_state(state, fl_owner, fl_pid, NFS4_ANY_LOCK_TYPE);
 	if (lsp && (lsp->ls_flags & NFS_LOCK_LOST))
@@ -910,9 +918,9 @@ static void nfs4_copy_open_stateid(nfs4_
  * requests.
  */
 void nfs4_select_rw_stateid(nfs4_stateid *dst, struct nfs4_state *state,
-		fmode_t fmode, fl_owner_t fl_owner, pid_t fl_pid)
+		fmode_t fmode, const struct nfs_lockowner *lockowner)
 {
-	int ret = nfs4_copy_lock_stateid(dst, state, fl_owner, fl_pid);
+	int ret = nfs4_copy_lock_stateid(dst, state, lockowner);
 	if (ret == -EIO)
 		/* A lost lock - don't even consider delegations */
 		goto out;
@@ -937,7 +945,7 @@ int nfs4_lock_lost(const struct nfs_open
 	    !test_bit(LK_STATE_LOST, &state->flags))
 		return 0;
 	spin_lock(&state->state_lock);
-	lsp = __nfs4_find_lock_state(state, l_ctx->lockowner, l_ctx->pid, NFS4_ANY_LOCK_TYPE);
+	lsp = __nfs4_find_lock_state(state, l_ctx->lockowner.l_owner, l_ctx->lockowner.l_pid, NFS4_ANY_LOCK_TYPE);
 	if (lsp != NULL && (lsp->ls_flags & NFS_LOCK_LOST) != 0)
 		ret = 1;
 	spin_unlock(&state->state_lock);
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4xdr.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4xdr.c
@@ -1455,8 +1455,12 @@ static void encode_stateid(struct xdr_st
 	nfs4_stateid stateid;
 
 	if (ctx->state != NULL) {
+		const struct nfs_lockowner *lockowner = NULL;
+
+		if (l_ctx != NULL)
+			lockowner = &l_ctx->lockowner;
 		nfs4_select_rw_stateid(&stateid, ctx->state,
-				fmode, l_ctx->lockowner, l_ctx->pid);
+				fmode, lockowner);
 		if (zero_seqid)
 			stateid.seqid = 0;
 		encode_nfs4_stateid(xdr, &stateid);
--- linux-3.0-SLE11-SP3.orig/fs/nfs/pagelist.c
+++ linux-3.0-SLE11-SP3/fs/nfs/pagelist.c
@@ -266,7 +266,9 @@ static bool nfs_can_coalesce_requests(st
 {
 	if (req->wb_context->cred != prev->wb_context->cred)
 		return false;
-	if (req->wb_lock_context->lockowner != prev->wb_lock_context->lockowner)
+	if (req->wb_lock_context->lockowner.l_owner != prev->wb_lock_context->lockowner.l_owner)
+		return false;
+	if (req->wb_lock_context->lockowner.l_pid != prev->wb_lock_context->lockowner.l_pid)
 		return false;
 	if (req->wb_context->state != prev->wb_context->state)
 		return false;
--- linux-3.0-SLE11-SP3.orig/fs/nfs/write.c
+++ linux-3.0-SLE11-SP3/fs/nfs/write.c
@@ -690,6 +690,7 @@ static int nfs_writepage_setup(struct nf
 int nfs_flush_incompatible(struct file *file, struct page *page)
 {
 	struct nfs_open_context *ctx = nfs_file_open_context(file);
+	struct nfs_lock_context *l_ctx;
 	struct nfs_page	*req;
 	int do_flush, status;
 	/*
@@ -704,17 +705,17 @@ int nfs_flush_incompatible(struct file *
 		req = nfs_page_find_request(page);
 		if (req == NULL)
 			return 0;
+		l_ctx = req->wb_lock_context;
 		do_flush = req->wb_page != page;
 		if (req->wb_context != ctx)
 			do_flush |=
 				(req->wb_context->path.mnt != ctx->path.mnt ||
 				 req->wb_context->path.dentry != ctx->path.dentry ||
 				 req->wb_context->cred != ctx->cred );
-		if (req->wb_context->state || ctx->state)
-			do_flush |=
-				(req->wb_lock_context->lockowner != current->files ||
-				 req->wb_lock_context->pid != current->tgid);
-
+		if (l_ctx) {
+			do_flush |= l_ctx->lockowner.l_owner != current->files
+				|| l_ctx->lockowner.l_pid != current->tgid;
+		}
 		nfs_release_request(req);
 		if (!do_flush)
 			return 0;
--- linux-3.0-SLE11-SP3.orig/include/linux/nfs_fs.h
+++ linux-3.0-SLE11-SP3/include/linux/nfs_fs.h
@@ -81,12 +81,16 @@ struct nfs_access_entry {
 #endif
 };
 
+struct nfs_lockowner {
+	fl_owner_t l_owner;
+	pid_t l_pid;
+};
+
 struct nfs_lock_context {
 	atomic_t count;
 	struct list_head list;
 	struct nfs_open_context *open_context;
-	fl_owner_t lockowner;
-	pid_t pid;
+	struct nfs_lockowner lockowner;
 };
 
 struct nfs4_state;
