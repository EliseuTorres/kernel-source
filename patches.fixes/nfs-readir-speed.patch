From: NeilBrown <neilb@suse.de>
Subject: NFS: avoid excessive GETATTR request when attributes expired but cached directory is valid
Patch-mainline: v3.13 (by totally different patch 311324ad1713666a6e80)
References: bnc#857926

If a large directory is accessed over NFS by "ls -l" both the
filenames and the inode attributes will be cached.
A little later after the cache timeout the validity of the filenames
can be re-establised by a single GETATTR of the directory.  However
the validity of the inode attributes need to be revalidated individually.

So a subsequent "ls -l" will not perform a READDIR or READDIRPLUS, but will
perform many GETATTR requests, which is slow.
We would rather it performed READDIRPLUS even though the directory names
don't need to be fetched.

So the first time we do GETATTR for a directory we are reading, we
flush the directory and ensure that READDIRPLUS will be used.


Acked-by: NeilBrown <neilb@suse.de>
Signed-off-by: Neil Brown <neilb@suse.de>

---
 fs/nfs/dir.c           |   11 +++++++++++
 fs/nfs/inode.c         |    2 +-
 include/linux/nfs_fs.h |    2 ++
 3 files changed, 14 insertions(+), 1 deletion(-)

--- linux-3.0-SLE11-SP3.orig/fs/nfs/dir.c
+++ linux-3.0-SLE11-SP3/fs/nfs/dir.c
@@ -897,6 +897,8 @@ static int nfs_readdir(struct file *filp
 	desc->dir_cookie = &dir_ctx->dir_cookie;
 	desc->decode = NFS_PROTO(inode)->decode_dirent;
 	desc->plus = nfs_use_readdirplus(inode, filp) ? 1 : 0;
+	if (desc->plus && filp->f_pos == 0)
+		clear_bit(NFS_INO_DID_FLUSH, &NFS_I(inode)->flags);
 
 	nfs_block_sillyrename(dentry);
 	res = nfs_revalidate_mapping(inode, filp->f_mapping);
@@ -1157,6 +1159,15 @@ static int nfs_lookup_revalidate(struct
 
 	/* Force a full look up iff the parent directory has changed */
 	if (!nfs_is_exclusive_create(dir, nd) && nfs_check_verifier(dir, dentry)) {
+		if (nfs_server_capable(dir, NFS_CAP_READDIRPLUS)
+		    && ((NFS_I(inode)->cache_validity & NFS_INO_INVALID_ATTR)
+			|| nfs_attribute_cache_expired(inode))
+		    && !test_and_set_bit(NFS_INO_DID_FLUSH, &NFS_I(dir)->flags)
+			) {
+			nfs_advise_use_readdirplus(dir);
+			goto out_zap_parent;
+		}
+
 		if (nfs_lookup_verify_inode(inode, nd))
 			goto out_zap_parent;
 		goto out_valid;
--- linux-3.0-SLE11-SP3.orig/fs/nfs/inode.c
+++ linux-3.0-SLE11-SP3/fs/nfs/inode.c
@@ -821,7 +821,7 @@ int nfs_attribute_timeout(struct inode *
 	return !time_in_range_open(jiffies, nfsi->read_cache_jiffies, nfsi->read_cache_jiffies + nfsi->attrtimeo);
 }
 
-static int nfs_attribute_cache_expired(struct inode *inode)
+int nfs_attribute_cache_expired(struct inode *inode)
 {
 	if (nfs_have_delegated_attributes(inode))
 		return 0;
--- linux-3.0-SLE11-SP3.orig/include/linux/nfs_fs.h
+++ linux-3.0-SLE11-SP3/include/linux/nfs_fs.h
@@ -230,6 +230,7 @@ struct nfs_inode {
 #define NFS_INO_COMMIT		(7)		/* inode is committing unstable writes */
 #define NFS_INO_PNFS_COMMIT	(8)		/* use pnfs code for commit */
 #define NFS_INO_LAYOUTCOMMIT	(9)		/* layoutcommit required */
+#define NFS_INO_DID_FLUSH	(11)
 
 static inline struct nfs_inode *NFS_I(const struct inode *inode)
 {
@@ -357,6 +358,7 @@ extern int nfs_permission(struct inode *
 extern int nfs_open(struct inode *, struct file *);
 extern int nfs_release(struct inode *, struct file *);
 extern int nfs_attribute_timeout(struct inode *inode);
+extern int nfs_attribute_cache_expired(struct inode *inode);
 extern int nfs_revalidate_inode(struct nfs_server *server, struct inode *inode);
 extern int __nfs_revalidate_inode(struct nfs_server *, struct inode *);
 extern int nfs_revalidate_mapping(struct inode *inode, struct address_space *mapping);
