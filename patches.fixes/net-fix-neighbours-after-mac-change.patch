From: Jiri Bohac <jbohac@suse.cz>
Subject: net: fix neighbours after MAC change
References: bnc#905299
Patch-mainline: never

[This problem was fixed in a different way in 3.9 by 7ff74a596b..6fd6ce2056.]

When the MAC address of a device changes, we need to recreate the cached
hardware headers. The current code tries to do this by destroying the
neighbours using neigh_flush_dev(). However, if the neighbours are referenced
by dst entries, they cannot be simply removed. Instead their output function is
set to neigh_blackhole. While IPv4 easily copes with this after a call to
rt_cache_flush(), I found no easy way to force IPv6 routes to invalidate their
cached neighbours.

Instead of trying to kill the neighbours, this patch:
- makes them NUD_STALE and calls neigh_suspect() to properly restart NUD after
  the change
- updates all the cached hardware headers
- sends unsolicited NA after the MAC change just as IPv4 sends its gratuitous ARP to
  notify other hosts.

Signed-off-by: Jiri Bohac <jbohac@suse.cz>

---
 net/core/neighbour.c |   45 ++++++++++++++++++++++++++++++++++++++++++++-
 net/ipv6/ndisc.c     |    1 +
 2 files changed, 45 insertions(+), 1 deletion(-)

--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -56,6 +56,7 @@
 #define PNEIGH_HASHMASK		0xF
 
 static void neigh_timer_handler(unsigned long arg);
+static void neigh_suspect(struct neighbour *neigh);
 static void __neigh_notify(struct neighbour *n, int type, int flags);
 static void neigh_update_notify(struct neighbour *neigh);
 static int pneigh_ifdown(struct neigh_table *tbl, struct net_device *dev);
@@ -251,10 +252,52 @@ static void neigh_flush_dev(struct neigh
 	}
 }
 
+/*
+ * ensure that all cached hardware headers of all neighbours
+ * are updated after the hardware address of dev has been changed
+ */
 void neigh_changeaddr(struct neigh_table *tbl, struct net_device *dev)
 {
+	int i;
+	struct neigh_hash_table *nht;
+
 	write_lock_bh(&tbl->lock);
-	neigh_flush_dev(tbl, dev);
+	nht = rcu_dereference_protected(tbl->nht,
+					lockdep_is_held(&tbl->lock));
+
+	for (i = 0; i <= nht->hash_mask; i++) {
+		struct neighbour *n;
+
+		n = rcu_dereference_protected(nht->hash_buckets[i],
+					      lockdep_is_held(&tbl->lock));
+
+		while (n) {
+			struct neighbour *next;
+			struct hh_cache *hh;
+			next = rcu_dereference_protected(n->next,
+						lockdep_is_held(&tbl->lock));
+
+			if (dev && n->dev != dev) {
+				n = next;
+				continue;
+			}
+			write_lock(&n->lock);
+
+			neigh_del_timer(n);
+			n->nud_state = NUD_STALE;
+
+			if (n->dev->header_ops && n->dev->header_ops->cache)
+			for (hh = n->hh; hh; hh = hh->hh_next) {
+				write_seqlock_bh(&hh->hh_lock);
+				n->dev->header_ops->cache(n, hh);
+				write_sequnlock_bh(&hh->hh_lock);
+			}
+			neigh_suspect(n);
+
+			write_unlock(&n->lock);
+			n = next;
+		}
+	}
 	write_unlock_bh(&tbl->lock);
 }
 EXPORT_SYMBOL(neigh_changeaddr);
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -1743,6 +1743,7 @@ static int ndisc_netdev_event(struct not
 	case NETDEV_CHANGEADDR:
 		neigh_changeaddr(&nd_tbl, dev);
 		fib6_run_gc(0, net, false);
+		ndisc_send_unsol_na(dev);
 		break;
 	case NETDEV_DOWN:
 		neigh_ifdown(&nd_tbl, dev);
