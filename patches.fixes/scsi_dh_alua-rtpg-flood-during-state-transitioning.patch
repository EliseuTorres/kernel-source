From: Hannes Reinecke <hare@suse.de>
Date: Thu, 25 Aug 2011 15:19:41 +0200
Subject: scsi_dh_alua: rtpg flood during state transitioning
References: bnc#708296
Patch-Mainline: Not yet

The SCSI ALUA handler currently retries the submit_rtpg
continuously in a loop (in the alua_rtpg routine) during
the entire ALUA transitioning period i.e.  during the time
when the target replies with a NOT READY status - ASYMMETRIC
ACCESS STATE TRANSITION as shown below:

err = alua_check_sense(sdev, &sense_hdr);
if (err == ADD_TO_MLQUEUE && time_before(jiffies, expiry))
        goto retry;

This causes the host to flood the target with RTPG commands
during this transitioning window (till ALUA_FAILOVER_TIMEOUT
fires).

This may cause targets to be overwhelmed during this ALUA
transitioning period, leading to performance degradation.

With this patch the retry is delayed with an exponential
backoff, reducing the amount of rtpgs sent.

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/device_handler/scsi_dh_alua.c |   12 ++++++++++--
 1 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/drivers/scsi/device_handler/scsi_dh_alua.c b/drivers/scsi/device_handler/scsi_dh_alua.c
index 916caf9..02c54ea 100644
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@ -239,7 +239,7 @@ static void stpg_endio(struct request *req, int error)
 			goto done;
 		}
 		err = alua_check_sense(h->sdev, &sense_hdr);
-		if (err == ADD_TO_MLQUEUE) {
+		if (err == ADD_TO_MLQUEUE || err == NEEDS_RETRY) {
 			err = SCSI_DH_RETRY;
 			goto done;
 		}
@@ -451,7 +451,7 @@ static int alua_check_sense(struct scsi_device *sdev,
 			/*
 			 * LUN Not Accessible - ALUA state transition
 			 */
-			return ADD_TO_MLQUEUE;
+			return NEEDS_RETRY;
 		if (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x0b)
 			/*
 			 * LUN Not Accessible -- Target port in standby state
@@ -531,6 +531,11 @@ static int alua_rtpg(struct scsi_device *sdev, struct alua_dh_data *h)
 			return SCSI_DH_IO;
 
 		err = alua_check_sense(sdev, &sense_hdr);
+		if (err == NEEDS_RETRY && time_before(jiffies, expiry)) {
+			interval *= 2;
+			msleep(interval);
+			goto retry;
+		}
 		if (err == ADD_TO_MLQUEUE && time_before(jiffies, expiry))
 			goto retry;
 		if (sense_hdr.sense_key == ILLEGAL_REQUEST &&
@@ -658,6 +663,7 @@ static int alua_activate(struct scsi_device *sdev,
 	struct alua_dh_data *h = get_alua_data(sdev);
 	int err = SCSI_DH_OK;
 
+retry:
 	err = alua_rtpg(sdev, h);
 	if (err != SCSI_DH_OK)
 		goto out;
@@ -671,6 +677,8 @@ static int alua_activate(struct scsi_device *sdev,
 		if (err == SCSI_DH_OK)
 			return 0;
 		h->callback_fn = h->callback_data = NULL;
+		if (err == SCSI_DH_RETRY)
+			goto retry;
 	}
 
 out:
-- 
1.6.0.2

