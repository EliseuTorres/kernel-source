From: Hannes Reinecke <hare@suse.de>
Date: Thu, 25 Aug 2011 15:19:41 +0200
Subject: scsi_dh_alua: rtpg flood during state transitioning
References: bnc#708296
Patch-Mainline: Not yet

The SCSI ALUA handler currently retries the submit_rtpg
continuously in a loop (in the alua_rtpg routine) during
the entire ALUA transitioning period i.e.  during the time
when the target replies with a NOT READY status - ASYMMETRIC
ACCESS STATE TRANSITION as shown below:

err = alua_check_sense(sdev, &sense_hdr);
if (err == ADD_TO_MLQUEUE && time_before(jiffies, expiry))
        goto retry;

This causes the host to flood the target with RTPG commands
during this transitioning window (till ALUA_FAILOVER_TIMEOUT
fires).

This may cause targets to be overwhelmed during this ALUA
transitioning period, leading to performance degradation.

To solve this issue we should re-send RTPG commands with
exponential backoff, and we should delay other commands
by a certain time.

Signed-off-by: Rob Evers <revers@redhat.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/device_handler/scsi_dh_alua.c b/drivers/scsi/device_handler/scsi_dh_alua.c
index 916caf9..e8c622b 100644
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@ -239,7 +239,7 @@ static void stpg_endio(struct request *req, int error)
 			goto done;
 		}
 		err = alua_check_sense(h->sdev, &sense_hdr);
-		if (err == ADD_TO_MLQUEUE) {
+		if (err == ADD_TO_MLQUEUE || err == ADD_TO_MLQUEUE_DELAY) {
 			err = SCSI_DH_RETRY;
 			goto done;
 		}
@@ -451,7 +451,7 @@ static int alua_check_sense(struct scsi_device *sdev,
 			/*
 			 * LUN Not Accessible - ALUA state transition
 			 */
-			return ADD_TO_MLQUEUE;
+			return ADD_TO_MLQUEUE_DELAY;
 		if (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x0b)
 			/*
 			 * LUN Not Accessible -- Target port in standby state
@@ -531,6 +531,12 @@ static int alua_rtpg(struct scsi_device *sdev, struct alua_dh_data *h)
 			return SCSI_DH_IO;
 
 		err = alua_check_sense(sdev, &sense_hdr);
+		if (err == ADD_TO_MLQUEUE_DELAY &&
+		    time_before(jiffies, expiry)) {
+			interval *= 2;
+			msleep(interval);
+			goto retry;
+		}
 		if (err == ADD_TO_MLQUEUE && time_before(jiffies, expiry))
 			goto retry;
 		if (sense_hdr.sense_key == ILLEGAL_REQUEST &&
@@ -658,6 +664,7 @@ static int alua_activate(struct scsi_device *sdev,
 	struct alua_dh_data *h = get_alua_data(sdev);
 	int err = SCSI_DH_OK;
 
+retry:
 	err = alua_rtpg(sdev, h);
 	if (err != SCSI_DH_OK)
 		goto out;
@@ -671,6 +678,8 @@ static int alua_activate(struct scsi_device *sdev,
 		if (err == SCSI_DH_OK)
 			return 0;
 		h->callback_fn = h->callback_data = NULL;
+		if (err == SCSI_DH_RETRY)
+			goto retry;
 	}
 
 out:
diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
index 2aeb2e9..ced0085 100644
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@ -600,6 +600,9 @@ void scsi_log_completion(struct scsi_cmnd *cmd, int disposition)
 			case ADD_TO_MLQUEUE:
 				printk("MLQUEUE\n");
 				break;
+			case ADD_TO_MLQUEUE_DELAY:
+				printk("MLQUEUE_DELAY\n");
+				break;
 			case FAILED:
 				printk("FAILED\n");
 				break;
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index b022148..3f63f74 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -902,6 +902,7 @@ static int scsi_send_eh_cmnd(struct scsi_cmnd *scmd, unsigned char *cmnd,
 		case TARGET_ERROR:
 			break;
 		case ADD_TO_MLQUEUE:
+		case ADD_TO_MLQUEUE_DELAY:
 			rtn = NEEDS_RETRY;
 			break;
 		default:
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 7cbe8d7..640dab0 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -138,6 +138,7 @@ static int __scsi_queue_insert(struct scsi_cmnd *cmd, int reason, int unbusy)
 		break;
 	case SCSI_MLQUEUE_DEVICE_BUSY:
 	case SCSI_MLQUEUE_EH_RETRY:
+	case SCSI_MLQUEUE_DELAYED_RETRY:
 		device->device_blocked = device->max_device_blocked;
 		break;
 	case SCSI_MLQUEUE_TARGET_BUSY:
@@ -160,7 +161,10 @@ static int __scsi_queue_insert(struct scsi_cmnd *cmd, int reason, int unbusy)
 	blk_requeue_request(q, cmd->request);
 	spin_unlock_irqrestore(q->queue_lock, flags);
 
-	kblockd_schedule_work(q, &device->requeue_work);
+	if (reason == SCSI_MLQUEUE_DELAYED_RETRY)
+		blk_delay_queue(q, 2000);
+	else
+		kblockd_schedule_work(q, &device->requeue_work);
 
 	return 0;
 }
@@ -1466,6 +1470,9 @@ static void scsi_softirq_done(struct request *rq)
 		case ADD_TO_MLQUEUE:
 			scsi_queue_insert(cmd, SCSI_MLQUEUE_DEVICE_BUSY);
 			break;
+		case ADD_TO_MLQUEUE_DELAY:
+			scsi_queue_insert(cmd, SCSI_MLQUEUE_DELAYED_RETRY);
+			break;
 		default:
 			if (!scsi_eh_scmd_add(cmd, 0))
 				scsi_finish_command(cmd);
diff --git a/include/scsi/scsi.h b/include/scsi/scsi.h
index 3668903..eaa1992 100644
--- a/include/scsi/scsi.h
+++ b/include/scsi/scsi.h
@@ -469,6 +469,7 @@ static inline int scsi_is_wlun(unsigned int lun)
 #define SCSI_RETURN_NOT_HANDLED   0x2008
 #define FAST_IO_FAIL	0x2009
 #define TARGET_ERROR    0x200A
+#define ADD_TO_MLQUEUE_DELAY	0x200B
 
 /*
  * Midlevel queue return values.
@@ -477,6 +478,7 @@ static inline int scsi_is_wlun(unsigned int lun)
 #define SCSI_MLQUEUE_DEVICE_BUSY 0x1056
 #define SCSI_MLQUEUE_EH_RETRY    0x1057
 #define SCSI_MLQUEUE_TARGET_BUSY 0x1058
+#define SCSI_MLQUEUE_DELAYED_RETRY 0x1059
 
 /*
  *  Use these to separate status msg and our bytes
