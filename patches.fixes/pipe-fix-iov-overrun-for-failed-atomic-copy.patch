From: Miklos Szeredi <mszeredi@suse.cz>
Subject: pipe: fix iov overrun for failed atomic copy
Patch-mainline: v3.16
References: bsc#933429 CVE-2015-1805

Only update the iov if the copy was successful.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
---
 fs/pipe.c |   48 +++++++++++++++++++++++++++++++-----------------
 1 file changed, 31 insertions(+), 17 deletions(-)

--- a/fs/pipe.c
+++ b/fs/pipe.c
@@ -117,54 +117,68 @@ void pipe_wait(struct pipe_inode_info *p
 }
 
 static int
-pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
+pipe_iov_copy_from_user(void *to, struct iovec **iovp, unsigned long len,
 			int atomic)
 {
 	unsigned long copy;
+	struct iovec *iov = *iovp;
+	struct iovec this = *iov;
 
 	while (len > 0) {
-		while (!iov->iov_len)
+		while (!this.iov_len) {
 			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
+			this = *iov;
+		}
+		copy = min_t(unsigned long, len, this.iov_len);
 
 		if (atomic) {
-			if (__copy_from_user_inatomic(to, iov->iov_base, copy))
+			if (__copy_from_user_inatomic(to, this.iov_base, copy))
 				return -EFAULT;
 		} else {
-			if (copy_from_user(to, iov->iov_base, copy))
+			if (copy_from_user(to, this.iov_base, copy))
 				return -EFAULT;
 		}
 		to += copy;
 		len -= copy;
-		iov->iov_base += copy;
-		iov->iov_len -= copy;
+		this.iov_base += copy;
+		this.iov_len -= copy;
 	}
+	*iov = this;
+	*iovp = iov;
+
 	return 0;
 }
 
 static int
-pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
+pipe_iov_copy_to_user(struct iovec **iovp, const void *from, unsigned long len,
 		      int atomic)
 {
 	unsigned long copy;
+	struct iovec *iov = *iovp;
+	struct iovec this = *iov;
 
 	while (len > 0) {
-		while (!iov->iov_len)
+		while (!this.iov_len) {
 			iov++;
-		copy = min_t(unsigned long, len, iov->iov_len);
+			this = *iov;
+		}
+		copy = min_t(unsigned long, len, this.iov_len);
 
 		if (atomic) {
-			if (__copy_to_user_inatomic(iov->iov_base, from, copy))
+			if (__copy_to_user_inatomic(this.iov_base, from, copy))
 				return -EFAULT;
 		} else {
-			if (copy_to_user(iov->iov_base, from, copy))
+			if (copy_to_user(this.iov_base, from, copy))
 				return -EFAULT;
 		}
 		from += copy;
 		len -= copy;
-		iov->iov_base += copy;
-		iov->iov_len -= copy;
+		this.iov_base += copy;
+		this.iov_len -= copy;
 	}
+	*iov = this;
+	*iovp = iov;
+
 	return 0;
 }
 
@@ -411,7 +425,7 @@ pipe_read(struct kiocb *iocb, const stru
 			atomic = !iov_fault_in_pages_write(iov, chars);
 redo:
 			addr = ops->map(pipe, buf, atomic);
-			error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);
+			error = pipe_iov_copy_to_user(&iov, addr + buf->offset, chars, atomic);
 			ops->unmap(pipe, buf, addr);
 			if (unlikely(error)) {
 				/*
@@ -539,7 +553,7 @@ pipe_write(struct kiocb *iocb, const str
 			iov_fault_in_pages_read(iov, chars);
 redo1:
 			addr = ops->map(pipe, buf, atomic);
-			error = pipe_iov_copy_from_user(offset + addr, iov,
+			error = pipe_iov_copy_from_user(offset + addr, &iov,
 							chars, atomic);
 			ops->unmap(pipe, buf, addr);
 			ret = error;
@@ -601,7 +615,7 @@ pipe_write(struct kiocb *iocb, const str
 			else
 				src = kmap(page);
 
-			error = pipe_iov_copy_from_user(src, iov, chars,
+			error = pipe_iov_copy_from_user(src, &iov, chars,
 							atomic);
 			if (atomic)
 				kunmap_atomic(src);
