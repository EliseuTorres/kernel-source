From: Mel Gorman <mgorman@suse.de>
Date: Wed, 22 May 2013 10:32:51 +0100
Subject: [PATCH] mm: vmscan: mm: vmscan: Have kswapd writeback pages based on
 dirty pages encountered, not priority -fix

References:  Limit reclaim in the preserve of IO (bnc#754690)
Patch-mainline: No, needs to be evaluated for mainline

If a zone is marked "reclaim dirty" then kswapd starts writing back pages
but this situation is flagged too easily and flushers are not given the
opportunity to catch up. This patch causes kswapd to only start writing back
pages if all dirty pages scanned at the tail of the LRU are unqueued. If
a zone is flagged as "reclaim dirty", the reclaiming process will stall to
give flushers a chance to clean up. It also renames nr_dirty to nr_unqueued
dirty in shrink_inactive_list() to clarify.

This could be treated as a fix to the patch
mm-vmscan-have-kswapd-writeback-pages-based-on-dirty-pages-encountered-not-priority.patch

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/vmscan.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/mm/vmscan.c b/mm/vmscan.c
index 41d1ef6..f86c013 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -1485,11 +1485,13 @@ shrink_inactive_list(unsigned long nr_to_scan, struct zone *zone,
 	/*
 	 * Similarly, if many dirty pages are encountered that are not
 	 * currently being written then flag that kswapd should start
-	 * writing back pages.
+	 * writing back pages and stall to give a chance for flushers
+	 * to catch up.
 	 */
-	if (scanning_global_lru(sc) && nr_dirty &&
-			nr_dirty >= (nr_taken >> (DEF_PRIORITY - sc->priority)))
+	if (scanning_global_lru(sc) && nr_dirty == nr_taken) {
+		congestion_wait(BLK_RW_ASYNC, HZ/10);
 		zone_set_flag(zone, ZONE_TAIL_LRU_DIRTY);
+	}
 
 	trace_mm_vmscan_lru_shrink_inactive(zone->zone_pgdat->node_id,
 		zone_idx(zone),
