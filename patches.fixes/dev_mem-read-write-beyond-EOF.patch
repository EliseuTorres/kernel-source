From: Petr Tesarik <ptesarik@suse.cz>
Subject: /dev/mem: handle out-of-bounds read/write
Patch-Mainline: Submitted to linux-kernel, 30 Jan 2014
References: FATE#310031

The loff_t type may be wider than phys_addr_t (e.g. on 32-bit systems).
Consequently, the file offset may be truncated in the assignment.
Currently, /dev/mem wraps around, which may cause applications to read
or write incorrect regions of memory by accident.

Let's follow POSIX file semantics here and return 0 when reading from
and -EFBIG when writing to an offset that cannot be represented by a
phys_addr_t.

Note that the conditional is optimized out by the compiler if loff_t
has the same size as phys_addr_t.

Signed-off-by: Petr Tesarik <ptesarik@suse.cz>
---
 drivers/char/mem.c |    6 ++++++
 1 file changed, 6 insertions(+)

--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@ -134,6 +134,9 @@ static ssize_t read_mem(struct file * fi
 	ssize_t read, sz;
 	char *ptr;
 
+	if (p != *ppos)
+		return 0;
+
 	if (!valid_phys_addr_range(p, count))
 		return -EFAULT;
 	read = 0;
@@ -202,6 +205,9 @@ static ssize_t write_mem(struct file * f
 	unsigned long copied;
 	void *ptr;
 
+	if (p != *ppos)
+		return -EFBIG;
+
 	if (!valid_phys_addr_range(p, count))
 		return -EFAULT;
 
