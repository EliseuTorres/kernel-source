From: Michal Hocko <mhocko@suse.cz>
Subject: watchdog: make watchdog_{disable,enable}_all_cpus hotplug and preemption safe
Patch-mainline: no, code is different
References: bnc#829357

Although this hasn't been reported yet and we use non-preemptible kernel in
SLES so the preemption part shouldn't be a big deal let's be cautious when all
per-cpus watchdogs are touched from proc_dowatchdog.

First we has to make sure that no CPU will be onlined/offlined while we are
fiddling with watchdog_{enable,disable}.

Then the preemption should rather be disabled while touching remote cpu's per
cpu data in case some subroutine calls cond_resched.

Signed-off-by: Michal Hocko <mhocko@suse.cz>

---
 kernel/watchdog.c |   12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

--- a/kernel/watchdog.c
+++ b/kernel/watchdog.c
@@ -514,11 +514,14 @@ static void watchdog_enable_all_cpus(voi
 
 	watchdog_enabled = 0;
 
-	for_each_online_cpu(cpu)
+	for_each_online_cpu(cpu) {
+		preempt_disable();
 		if (!watchdog_enable(cpu))
 			/* if any cpu succeeds, watchdog is considered
 			   enabled for the system */
 			watchdog_enabled = 1;
+		preempt_enable();
+	}
 
 	if (!watchdog_enabled)
 		printk(KERN_ERR "watchdog: failed to be enabled on some cpus\n");
@@ -529,8 +532,11 @@ static void watchdog_disable_all_cpus(vo
 {
 	int cpu;
 
-	for_each_online_cpu(cpu)
+	for_each_online_cpu(cpu) {
+		preempt_disable();
 		watchdog_disable(cpu);
+		preempt_enable();
+	}
 
 	/* if all watchdogs are disabled, then they are disabled for the system */
 	watchdog_enabled = 0;
@@ -554,10 +560,12 @@ int proc_dowatchdog(struct ctl_table *ta
 	if (ret || !write)
 		goto out;
 
+	get_online_cpus();
 	if (watchdog_enabled && watchdog_thresh)
 		watchdog_enable_all_cpus();
 	else
 		watchdog_disable_all_cpus();
+	put_online_cpus();
 
 out:
 	mutex_unlock(&watchdog_thresh_mutex);
