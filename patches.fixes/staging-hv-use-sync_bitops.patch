From: Olaf Hering <olaf@aepfle.de>
Subject: [PATCH] staging: hv: use sync_bitops when interacting with the hypervisor
References: bnc#675963
Patch-mainline: in Greg's tree, on its way to mainline

Locking is required when tweaking bits located in a shared page, use the
sync_ version of bitops. Without this change vmbus_on_event() will miss
events and as a result, vmbus_isr() will not schedule the receive tasklet.

Signed-off-by: Olaf Hering <olaf@aepfle.de>
Cc: stable <stable@kernel.org>
Acked-by: Haiyang Zhang <haiyangz@microsoft.com>
Acked-by: Hank Janssen <hjanssen@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/staging/hv/Channel.c    |    4 ++--
 drivers/staging/hv/Connection.c |    4 ++--
 drivers/staging/hv/Vmbus.c      |    2 +-
 drivers/staging/hv/osd.h        |    1 +
 4 files changed, 6 insertions(+), 5 deletions(-)

Index: linux-2.6.32.29-0.3-bug675963/drivers/staging/hv/Channel.c
===================================================================
--- linux-2.6.32.29-0.3-bug675963.orig/drivers/staging/hv/Channel.c
+++ linux-2.6.32.29-0.3-bug675963/drivers/staging/hv/Channel.c
@@ -76,14 +76,14 @@ static void VmbusChannelSetEvent(struct
 
 	if (Channel->OfferMsg.MonitorAllocated) {
 		/* Each u32 represents 32 channels */
-		set_bit(Channel->OfferMsg.ChildRelId & 31,
+		sync_set_bit(Channel->OfferMsg.ChildRelId & 31,
 			(unsigned long *) gVmbusConnection.SendInterruptPage +
 			(Channel->OfferMsg.ChildRelId >> 5));
 
 		monitorPage = gVmbusConnection.MonitorPages;
 		monitorPage++; /* Get the child to parent monitor page */
 
-		set_bit(Channel->MonitorBit,
+		sync_set_bit(Channel->MonitorBit,
 			(unsigned long *)&monitorPage->TriggerGroup
 					[Channel->MonitorGroup].Pending);
 
Index: linux-2.6.32.29-0.3-bug675963/drivers/staging/hv/Connection.c
===================================================================
--- linux-2.6.32.29-0.3-bug675963.orig/drivers/staging/hv/Connection.c
+++ linux-2.6.32.29-0.3-bug675963/drivers/staging/hv/Connection.c
@@ -281,7 +281,7 @@ void VmbusOnEvents(void)
 		for (dword = 0; dword < maxdword; dword++) {
 			if (recvInterruptPage[dword]) {
 				for (bit = 0; bit < 32; bit++) {
-					if (test_and_clear_bit(bit, (unsigned long *)&recvInterruptPage[dword])) {
+					if (sync_test_and_clear_bit(bit, (unsigned long *)&recvInterruptPage[dword])) {
 						relid = (dword << 5) + bit;
 						DPRINT_DBG(VMBUS, "event detected for relid - %d", relid);
 
@@ -320,7 +320,7 @@ int VmbusPostMessage(void *buffer, size_
 int VmbusSetEvent(u32 childRelId)
 {
 	/* Each u32 represents 32 channels */
-	set_bit(childRelId & 31,
+	sync_set_bit(childRelId & 31,
 		(unsigned long *)gVmbusConnection.SendInterruptPage +
 		(childRelId >> 5));
 
Index: linux-2.6.32.29-0.3-bug675963/drivers/staging/hv/Vmbus.c
===================================================================
--- linux-2.6.32.29-0.3-bug675963.orig/drivers/staging/hv/Vmbus.c
+++ linux-2.6.32.29-0.3-bug675963/drivers/staging/hv/Vmbus.c
@@ -241,7 +241,7 @@ static int VmbusOnISR(struct hv_driver *
 	event = (union hv_synic_event_flags *)page_addr + VMBUS_MESSAGE_SINT;
 
 	/* Since we are a child, we only need to check bit 0 */
-	if (test_and_clear_bit(0, (unsigned long *) &event->Flags32[0])) {
+	if (sync_test_and_clear_bit(0, (unsigned long *) &event->Flags32[0])) {
 		DPRINT_DBG(VMBUS, "received event %d", event->Flags32[0]);
 		ret |= 0x2;
 	}
Index: linux-2.6.32.29-0.3-bug675963/drivers/staging/hv/osd.h
===================================================================
--- linux-2.6.32.29-0.3-bug675963.orig/drivers/staging/hv/osd.h
+++ linux-2.6.32.29-0.3-bug675963/drivers/staging/hv/osd.h
@@ -26,6 +26,7 @@
 #define _OSD_H_
 
 #include <linux/workqueue.h>
+#include <asm/sync_bitops.h>
 
 /* Defines */
 #define ALIGN_UP(value, align)	(((value) & (align-1)) ?		\
