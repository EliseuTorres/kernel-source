From: Al Viro <viro@zeniv.linux.org.uk>
Date: Mon, 22 Mar 2010 19:36:35 -0400
Subject: Leave superblocks on s_list until the end
Git-commit: 551de6f34dfeefbeeadb32909c387d393114ecc8
References: bnc#649000, fate#312304
Patch-mainline: v2.6.35-rc1

We used to remove from s_list and s_instances at the same
time.  So let's *not* do the former and skip superblocks
that have empty s_instances in the loops over s_list.

The next step, of course, will be to get rid of rescan logics
in those loops.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Acked-by: Jan Kara <jack@suse.cz>
---
 fs/buffer.c      |    2 ++
 fs/dcache.c      |    2 ++
 fs/drop_caches.c |    2 ++
 fs/quota/quota.c |    2 ++
 fs/super.c       |   16 +++++++++++++---
 fs/sync.c        |    5 ++++-
 6 files changed, 25 insertions(+), 4 deletions(-)

Index: linux-2.6.32-writeback-SLE11-SP1/fs/buffer.c
===================================================================
--- linux-2.6.32-writeback-SLE11-SP1.orig/fs/buffer.c
+++ linux-2.6.32-writeback-SLE11-SP1/fs/buffer.c
@@ -568,6 +568,8 @@ static void do_thaw_all(struct work_stru
 	spin_lock(&sb_lock);
 restart:
 	list_for_each_entry(sb, &super_blocks, s_list) {
+		if (list_empty(&sb->s_instances))
+			continue;
 		sb->s_count++;
 		spin_unlock(&sb_lock);
 		down_read(&sb->s_umount);
Index: linux-2.6.32-writeback-SLE11-SP1/fs/dcache.c
===================================================================
--- linux-2.6.32-writeback-SLE11-SP1.orig/fs/dcache.c
+++ linux-2.6.32-writeback-SLE11-SP1/fs/dcache.c
@@ -547,6 +547,8 @@ restart:
 		prune_ratio = unused / count;
 	spin_lock(&sb_lock);
 	list_for_each_entry(sb, &super_blocks, s_list) {
+		if (list_empty(&sb->s_instances))
+			continue;
 		if (sb->s_nr_dentry_unused == 0)
 			continue;
 		sb->s_count++;
Index: linux-2.6.32-writeback-SLE11-SP1/fs/drop_caches.c
===================================================================
--- linux-2.6.32-writeback-SLE11-SP1.orig/fs/drop_caches.c
+++ linux-2.6.32-writeback-SLE11-SP1/fs/drop_caches.c
@@ -40,6 +40,8 @@ static void drop_pagecache(void)
 	spin_lock(&sb_lock);
 restart:
 	list_for_each_entry(sb, &super_blocks, s_list) {
+		if (list_empty(&sb->s_instances))
+			continue;
 		sb->s_count++;
 		spin_unlock(&sb_lock);
 		down_read(&sb->s_umount);
Index: linux-2.6.32-writeback-SLE11-SP1/fs/quota/quota.c
===================================================================
--- linux-2.6.32-writeback-SLE11-SP1.orig/fs/quota/quota.c
+++ linux-2.6.32-writeback-SLE11-SP1/fs/quota/quota.c
@@ -205,6 +205,8 @@ static void sync_dquots(int type)
 	spin_lock(&sb_lock);
 restart:
 	list_for_each_entry(sb, &super_blocks, s_list) {
+		if (list_empty(&sb->s_instances))
+			continue;
 		/* This test just improves performance so it needn't be
 		 * reliable... */
 		for (cnt = 0; cnt < MAXQUOTAS; cnt++) {
Index: linux-2.6.32-writeback-SLE11-SP1/fs/super.c
===================================================================
--- linux-2.6.32-writeback-SLE11-SP1.orig/fs/super.c
+++ linux-2.6.32-writeback-SLE11-SP1/fs/super.c
@@ -134,6 +134,7 @@ static int __put_super(struct super_bloc
 	int ret = 0;
 
 	if (!--sb->s_count) {
+		list_del_init(&sb->s_list);
 		destroy_super(sb);
 		ret = 1;
 	}
@@ -150,7 +151,7 @@ static int __put_super(struct super_bloc
 int __put_super_and_need_restart(struct super_block *sb)
 {
 	/* check for race with generic_shutdown_super() */
-	if (list_empty(&sb->s_list)) {
+	if (list_empty(&sb->s_instances)) {
 		/* super block is removed, need to restart... */
 		__put_super(sb);
 		return 1;
@@ -320,8 +321,7 @@ void generic_shutdown_super(struct super
 	}
 	spin_lock(&sb_lock);
 	/* should be initialized for __put_super_and_need_restart() */
-	list_del_init(&sb->s_list);
-	list_del(&sb->s_instances);
+	list_del_init(&sb->s_instances);
 	spin_unlock(&sb_lock);
 	up_write(&sb->s_umount);
 }
@@ -412,6 +412,8 @@ void sync_supers(void)
 	spin_lock(&sb_lock);
 restart:
 	list_for_each_entry(sb, &super_blocks, s_list) {
+		if (list_empty(&sb->s_instances))
+			continue;
 		if (sb->s_op->write_super && sb->s_dirt) {
 			sb->s_count++;
 			spin_unlock(&sb_lock);
@@ -447,6 +449,8 @@ struct super_block * get_super(struct bl
 	spin_lock(&sb_lock);
 rescan:
 	list_for_each_entry(sb, &super_blocks, s_list) {
+		if (list_empty(&sb->s_instances))
+			continue;
 		if (sb->s_bdev == bdev) {
 			sb->s_count++;
 			spin_unlock(&sb_lock);
@@ -483,6 +487,8 @@ struct super_block *get_active_super(str
 
 	spin_lock(&sb_lock);
 	list_for_each_entry(sb, &super_blocks, s_list) {
+		if (list_empty(&sb->s_instances))
+			continue;
 		if (sb->s_bdev != bdev)
 			continue;
 
@@ -515,6 +521,8 @@ struct super_block * user_get_super(dev_
 	spin_lock(&sb_lock);
 rescan:
 	list_for_each_entry(sb, &super_blocks, s_list) {
+		if (list_empty(&sb->s_instances))
+			continue;
 		if (sb->s_dev ==  dev) {
 			sb->s_count++;
 			spin_unlock(&sb_lock);
@@ -623,6 +631,8 @@ static void do_emergency_remount(struct
 
 	spin_lock(&sb_lock);
 	list_for_each_entry(sb, &super_blocks, s_list) {
+		if (list_empty(&sb->s_instances))
+			continue;
 		sb->s_count++;
 		spin_unlock(&sb_lock);
 		down_write(&sb->s_umount);
Index: linux-2.6.32-writeback-SLE11-SP1/fs/sync.c
===================================================================
--- linux-2.6.32-writeback-SLE11-SP1.orig/fs/sync.c
+++ linux-2.6.32-writeback-SLE11-SP1/fs/sync.c
@@ -97,10 +97,13 @@ static void sync_filesystems(int wait)
 	mutex_lock(&mutex);		/* Could be down_interruptible */
 	spin_lock(&sb_lock);
 	list_for_each_entry(sb, &super_blocks, s_list)
-		sb->s_need_sync = 1;
+		if (!list_empty(&sb->s_instances))
+			sb->s_need_sync = 1;
 
 restart:
 	list_for_each_entry(sb, &super_blocks, s_list) {
+		if (list_empty(&sb->s_instances))
+			continue;
 		if (!sb->s_need_sync)
 			continue;
 		sb->s_need_sync = 0;
