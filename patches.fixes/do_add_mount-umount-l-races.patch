Git-commit: 156cacb1d0d36b0d0582d9e798e58e0044f516b3
From: Al Viro <viro@zeniv.linux.org.uk>
Date: Fri, 21 Sep 2012 08:19:02 -0400
Subject: [PATCH] do_add_mount()/umount -l races
Patch-mainline: 3.6
References: bnc#836801

normally we deal with lock_mount()/umount races by checking that
mountpoint to be is still in our namespace after lock_mount() has
been done.  However, do_add_mount() skips that check when called
with MNT_SHRINKABLE in flags (i.e. from finish_automount()).  The
reason is that ->mnt_ns may be a temporary namespace created exactly
to contain automounts a-la NFS4 referral handling.  It's not the
namespace of the caller, though, so check_mnt() would fail here.
We still need to check that ->mnt_ns is non-NULL in that case,
though.

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/namespace.c |   10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

--- linux-3.0-SLE11-SP2.orig/fs/namespace.c
+++ linux-3.0-SLE11-SP2/fs/namespace.c
@@ -1986,8 +1986,14 @@ static int do_add_mount(struct vfsmount
 		return err;
 
 	err = -EINVAL;
-	if (!(mnt_flags & MNT_SHRINKABLE) && !check_mnt(path->mnt))
-		goto unlock;
+	if (unlikely(!check_mnt(path->mnt))) {
+		/* that's acceptable only for automounts done in private ns */
+		if (!(mnt_flags & MNT_SHRINKABLE))
+			goto unlock;
+		/* ... and for those we'd better have mountpoint still alive */
+		if (!path->mnt->mnt_ns)
+			goto unlock;
+	}
 
 	/* Refuse the same filesystem on the same mount point */
 	err = -EBUSY;
