From: Tristan Ye <tristan.ye@oracle.com>
Date: Mon, 11 Oct 2010 16:46:39 +0800
Subject: ocfs2: Add a mount option "coherency=*" to handle cluster coherency for O_DIRECT writes.
Patch-mainline: v2.6.37

Currently, the default behavior of O_DIRECT writes was allowing
concurrent writing among nodes to the same file, with no cluster
coherency guaranteed (no EX lock held).  This can leave stale data in
the cache for buffered reads on other nodes.

The new mount option introduce a chance to choose two different
behaviors for O_DIRECT writes:

    * coherency=full, as the default value, will disallow
                      concurrent O_DIRECT writes by taking
                      EX locks.

    * coherency=buffered, allow concurrent O_DIRECT writes
                          without EX lock among nodes, which
                          gains high performance at risk of
                          getting stale data on other nodes.

Signed-off-by: Tristan Ye <tristan.ye@oracle.com>
Signed-off-by: Joel Becker <joel.becker@oracle.com>
Signed-off-by: Mark Fasheh <mfasheh@suse.com>
---
 Documentation/filesystems/ocfs2.txt |    7 +++++++
 fs/ocfs2/file.c                     |   29 +++++++++++++++++++++++++++--
 fs/ocfs2/ocfs2.h                    |    3 +++
 fs/ocfs2/super.c                    |   15 +++++++++++++++
 4 files changed, 52 insertions(+), 2 deletions(-)

Index: linux-2.6.32-ocfs2-update-2.6.37-fixes/Documentation/filesystems/ocfs2.txt
===================================================================
--- linux-2.6.32-ocfs2-update-2.6.37-fixes.orig/Documentation/filesystems/ocfs2.txt
+++ linux-2.6.32-ocfs2-update-2.6.37-fixes/Documentation/filesystems/ocfs2.txt
@@ -87,3 +87,10 @@ dir_resv_level=	(*)	By default, director
 			reservations - users should rarely need to change this
 			value. If allocation reservations are turned off, this
 			option will have no effect.
+coherency=full  (*)	Disallow concurrent O_DIRECT writes, cluster inode
+			lock will be taken to force other nodes drop cache,
+			therefore full cluster coherency is guaranteed even
+			for O_DIRECT writes.
+coherency=buffered	Allow concurrent O_DIRECT writes without EX lock among
+			nodes, which gains high performance at risk of getting
+			stale data on other nodes.
Index: linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/file.c
===================================================================
--- linux-2.6.32-ocfs2-update-2.6.37-fixes.orig/fs/ocfs2/file.c
+++ linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/file.c
@@ -2220,6 +2220,8 @@ static ssize_t ocfs2_file_aio_write(stru
 	struct file *file = iocb->ki_filp;
 	struct inode *inode = file->f_path.dentry->d_inode;
 	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	int full_coherency = !(osb->s_mount_opt &
+			       OCFS2_MOUNT_COHERENCY_BUFFERED);
 
 	mlog_entry("(0x%p, %u, '%.*s')\n", file,
 		   (unsigned int)nr_segs,
@@ -2243,14 +2245,37 @@ relock:
 		have_alloc_sem = 1;
 	}
 
-	/* concurrent O_DIRECT writes are allowed */
-	rw_level = !direct_io;
+	/*
+	 * Concurrent O_DIRECT writes are allowed with
+	 * mount_option "coherency=buffered".
+	 */
+	rw_level = (!direct_io || full_coherency);
+
 	ret = ocfs2_rw_lock(inode, rw_level);
 	if (ret < 0) {
 		mlog_errno(ret);
 		goto out_sems;
 	}
 
+	/*
+	 * O_DIRECT writes with "coherency=full" need to take EX cluster
+	 * inode_lock to guarantee coherency.
+	 */
+	if (direct_io && full_coherency) {
+		/*
+		 * We need to take and drop the inode lock to force
+		 * other nodes to drop their caches.  Buffered I/O
+		 * already does this in write_begin().
+		 */
+		ret = ocfs2_inode_lock(inode, NULL, 1);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out_sems;
+		}
+
+		ocfs2_inode_unlock(inode, 1);
+	}
+
 	can_do_direct = direct_io;
 	ret = ocfs2_prepare_inode_for_write(file, ppos,
 					    iocb->ki_left, appending,
Index: linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/ocfs2.h
===================================================================
--- linux-2.6.32-ocfs2-update-2.6.37-fixes.orig/fs/ocfs2/ocfs2.h
+++ linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/ocfs2.h
@@ -265,6 +265,8 @@ enum ocfs2_mount_options
 	OCFS2_MOUNT_GRPQUOTA = 1 << 11, /* We support group quotas */
 	OCFS2_MOUNT_HB_NONE = 1 << 12, /* No heartbeat */
 	OCFS2_MOUNT_HB_GLOBAL = 1 << 13, /* Global heartbeat */
+	OCFS2_MOUNT_COHERENCY_BUFFERED = 1 << 14 /* Allow concurrent O_DIRECT
+						    writes */
 };
 
 #define OCFS2_OSB_SOFT_RO			0x0001
Index: linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/super.c
===================================================================
--- linux-2.6.32-ocfs2-update-2.6.37-fixes.orig/fs/ocfs2/super.c
+++ linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/super.c
@@ -179,6 +179,8 @@ enum {
 	Opt_noacl,
 	Opt_usrquota,
 	Opt_grpquota,
+	Opt_coherency_buffered,
+	Opt_coherency_full,
 	Opt_resv_level,
 	Opt_dir_resv_level,
 	Opt_err,
@@ -208,6 +210,8 @@ static const match_table_t tokens = {
 	{Opt_noacl, "noacl"},
 	{Opt_usrquota, "usrquota"},
 	{Opt_grpquota, "grpquota"},
+	{Opt_coherency_buffered, "coherency=buffered"},
+	{Opt_coherency_full, "coherency=full"},
 	{Opt_resv_level, "resv_level=%u"},
 	{Opt_dir_resv_level, "dir_resv_level=%u"},
 	{Opt_err, NULL}
@@ -1477,6 +1481,12 @@ static int ocfs2_parse_options(struct su
 		case Opt_grpquota:
 			mopt->mount_opt |= OCFS2_MOUNT_GRPQUOTA;
 			break;
+		case Opt_coherency_buffered:
+			mopt->mount_opt |= OCFS2_MOUNT_COHERENCY_BUFFERED;
+			break;
+		case Opt_coherency_full:
+			mopt->mount_opt &= ~OCFS2_MOUNT_COHERENCY_BUFFERED;
+			break;
 		case Opt_acl:
 			mopt->mount_opt |= OCFS2_MOUNT_POSIX_ACL;
 			mopt->mount_opt &= ~OCFS2_MOUNT_NO_POSIX_ACL;
@@ -1588,6 +1598,11 @@ static int ocfs2_show_options(struct seq
 	if (opts & OCFS2_MOUNT_GRPQUOTA)
 		seq_printf(s, ",grpquota");
 
+	if (opts & OCFS2_MOUNT_COHERENCY_BUFFERED)
+		seq_printf(s, ",coherency=buffered");
+	else
+		seq_printf(s, ",coherency=full");
+
 	if (opts & OCFS2_MOUNT_NOUSERXATTR)
 		seq_printf(s, ",nouser_xattr");
 	else
