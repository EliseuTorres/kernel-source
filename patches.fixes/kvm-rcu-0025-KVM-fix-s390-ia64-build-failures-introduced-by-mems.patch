From: Marcelo Tosatti <mtosatti@redhat.com>
Date: Mon, 11 Jan 2010 15:23:09 -0200
Subject: [PATCH] KVM: fix s390/ia64 build failures introduced by memslot changes
Patch-mainline: not yet (probably 2.6.35)
References: bnc#589660
Git-tree: git://git.kernel.org/pub/scm/virt/kvm/kvm.git
Git-commit: ad4894e147f9b52e0031ff42d9fe725452f1c0d1

Fix build failures introduced by memslot changes.

Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
Signed-off-by: Avi Kivity <avi@redhat.com>
Signed-off-by: Alexander Graf <agraf@suse.de>
---
 arch/ia64/kvm/kvm-ia64.c |   11 +++++++----
 arch/s390/kvm/kvm-s390.c |   11 ++++++-----
 arch/s390/kvm/kvm-s390.h |    2 +-
 arch/x86/kvm/x86.c       |    1 +
 include/linux/kvm_host.h |    1 +
 virt/kvm/kvm_main.c      |    2 +-
 6 files changed, 17 insertions(+), 11 deletions(-)

--- a/arch/ia64/kvm/kvm-ia64.c
+++ b/arch/ia64/kvm/kvm-ia64.c
@@ -1372,12 +1372,14 @@ static void free_kvm(struct kvm *kvm)
 
 static void kvm_release_vm_pages(struct kvm *kvm)
 {
+	struct kvm_memslots *slots;
 	struct kvm_memory_slot *memslot;
 	int i, j;
 	unsigned long base_gfn;
 
-	for (i = 0; i < kvm->nmemslots; i++) {
-		memslot = &kvm->memslots[i];
+	slots = rcu_dereference(kvm->memslots);
+	for (i = 0; i < slots->nmemslots; i++) {
+		memslot = &slots->memslots[i];
 		base_gfn = memslot->base_gfn;
 
 		for (j = 0; j < memslot->npages; j++) {
@@ -1575,6 +1577,7 @@ out:
 int kvm_arch_prepare_memory_region(struct kvm *kvm,
 		struct kvm_memory_slot *memslot,
 		struct kvm_memory_slot old,
+		struct kvm_userspace_memory_region *mem,
 		int user_alloc)
 {
 	unsigned long i;
@@ -1806,7 +1809,7 @@ static int kvm_ia64_sync_dirty_log(struc
 	if (log->slot >= KVM_MEMORY_SLOTS)
 		goto out;
 
-	memslot = &kvm->memslots[log->slot];
+	memslot = &kvm->memslots->memslots[log->slot];
 	r = -ENOENT;
 	if (!memslot->dirty_bitmap)
 		goto out;
@@ -1845,7 +1848,7 @@ int kvm_vm_ioctl_get_dirty_log(struct kv
 	/* If nothing is dirty, don't bother messing with page tables. */
 	if (is_dirty) {
 		kvm_flush_remote_tlbs(kvm);
-		memslot = &kvm->memslots[log->slot];
+		memslot = &kvm->memslots->memslots[log->slot];
 		n = kvm_dirty_bitmap_bytes(memslot);
 		memset(memslot->dirty_bitmap, 0, n);
 	}
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@ -690,13 +690,11 @@ long kvm_arch_vcpu_ioctl(struct file *fi
 
 /* Section: memory related */
 int kvm_arch_prepare_memory_region(struct kvm *kvm,
-				   struct kvm_userspace_memory_region *mem,
+				   struct kvm_memory_slot *memslot,
 				   struct kvm_memory_slot old,
+				   struct kvm_userspace_memory_region *mem,
 				   int user_alloc)
 {
-	int i;
-	struct kvm_vcpu *vcpu;
-
 	/* A few sanity checks. We can have exactly one memory slot which has
 	   to start at guest virtual zero and which has to be located at a
 	   page boundary in userland and which has to end at a page boundary.
@@ -722,11 +720,14 @@ int kvm_arch_prepare_memory_region(struc
 	return 0;
 }
 
-int kvm_arch_commit_memory_region(struct kvm *kvm,
+void kvm_arch_commit_memory_region(struct kvm *kvm,
 				struct kvm_userspace_memory_region *mem,
 				struct kvm_memory_slot old,
 				int user_alloc)
 {
+	int i;
+	struct kvm_vcpu *vcpu;
+
 	/* request update of sie control block for all available vcpus */
 	kvm_for_each_vcpu(i, vcpu, kvm) {
 		if (test_and_set_bit(KVM_REQ_MMU_RELOAD, &vcpu->requests))
--- a/arch/s390/kvm/kvm-s390.h
+++ b/arch/s390/kvm/kvm-s390.h
@@ -69,7 +69,7 @@ static inline void kvm_s390_vcpu_set_mem
 {
 	int idx;
 	struct kvm_memory_slot *mem;
-	struct kvm_memory_slots *memslots;
+	struct kvm_memslots *memslots;
 
 	idx = srcu_read_lock(&vcpu->kvm->srcu);
 	memslots = rcu_dereference(vcpu->kvm->memslots);
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -5227,6 +5227,7 @@ void kvm_arch_destroy_vm(struct kvm *kvm
 int kvm_arch_prepare_memory_region(struct kvm *kvm,
 				struct kvm_memory_slot *memslot,
 				struct kvm_memory_slot old,
+				struct kvm_userspace_memory_region *mem,
 				int user_alloc)
 {
 	int npages = memslot->npages;
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -263,6 +263,7 @@ int __kvm_set_memory_region(struct kvm *
 int kvm_arch_prepare_memory_region(struct kvm *kvm,
 				struct kvm_memory_slot *memslot,
 				struct kvm_memory_slot old,
+				struct kvm_userspace_memory_region *mem,
 				int user_alloc);
 void kvm_arch_commit_memory_region(struct kvm *kvm,
 				struct kvm_userspace_memory_region *mem,
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -1305,7 +1305,7 @@ skip_lpage:
 		kfree(old_memslots);
 	}
 
-	r = kvm_arch_prepare_memory_region(kvm, &new, old, user_alloc);
+	r = kvm_arch_prepare_memory_region(kvm, &new, old, mem, user_alloc);
 	if (r)
 		goto out_free;
 
