From: Shan Wei <shanwei@cn.fujitsu.com>
Date: Wed, 10 Oct 2012 18:59:17 +0200
Subject: netfilter: send ICMPv6 message on fragment reassembly timeout
Patch-mainline: Never, upstream solution difficult to backport
References: bnc#773577

An end host with IPv6 connection track enable should send an
ICMP "Fragment Reassembly Timeout" message when defraging timeout
according to the section 4.5 in RFC2460.

This patch supports it and adds counter value of Ip6ReasmTimeout and Ip6ReasmFails.

Quote Begin:
 Section 4.5 in RFC2460.
   If insufficient fragments are received to complete reassembly of a
   packet within 60 seconds of the reception of the first-arriving
   fragment of that packet, reassembly of that packet must be
   abandoned and all the fragments that have been received for that
   packet must be discarded.  If the first fragment (i.e., the one
   with a Fragment Offset of zero) has been received, an ICMP Time
   Exceeded -- Fragment Reassembly Time Exceeded message should be
   sent to the source of that fragment.
Quote End.

Signed-off-by: Shan Wei <shanwei@cn.fujitsu.com>
Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/linux/skbuff.h                  |    5 ++++
 net/ipv6/netfilter/nf_conntrack_reasm.c |   49 ++++++++++++++++++++++++++++++-
 net/ipv6/route.c                        |    1 +
 3 files changed, 54 insertions(+), 1 deletion(-)

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 09c6b92..78eb3b5 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -497,6 +497,11 @@ static inline struct rtable *skb_rtable(const struct sk_buff *skb)
 	return (struct rtable *)skb_dst(skb);
 }
 
+static inline struct rt6_info *skb_r6table(const struct sk_buff *skb)
+{
+	return (struct rt6_info *)skb_dst(skb);
+}
+
 extern void kfree_skb(struct sk_buff *skb);
 extern void consume_skb(struct sk_buff *skb);
 extern void	       __kfree_skb(struct sk_buff *skb);
diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
index 0857272..92d31dc 100644
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
@@ -28,6 +28,7 @@
 #include <linux/icmpv6.h>
 #include <linux/random.h>
 #include <linux/slab.h>
+#include <linux/ipv6_route.h>
 
 #include <net/sock.h>
 #include <net/snmp.h>
@@ -46,6 +47,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <net/netfilter/ipv6/nf_defrag_ipv6.h>
+#include <net/ip6_route.h>
 
 
 struct nf_ct_frag6_skb_cb
@@ -66,6 +68,7 @@ struct nf_ct_frag6_queue
 	struct in6_addr		saddr;
 	struct in6_addr		daddr;
 
+	int			iif;
 	unsigned int		csum;
 	__u16			nhoffset;
 };
@@ -141,6 +144,8 @@ static void nf_ct_frag6_evictor(void)
 static void nf_ct_frag6_expire(unsigned long data)
 {
 	struct nf_ct_frag6_queue *fq;
+	struct net_device *dev = NULL;
+	struct net *net;
 
 	fq = container_of((struct inet_frag_queue *)data,
 			struct nf_ct_frag6_queue, q);
@@ -151,8 +156,46 @@ static void nf_ct_frag6_expire(unsigned long data)
 		goto out;
 
 	fq_kill(fq);
+	net = container_of(fq->q.net, struct net, ipv6.frags);
+	dev = dev_get_by_index(net, fq->iif);
+	if (!dev)
+		goto out;
+
+	rcu_read_lock();
+	IP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMTIMEOUT);
+	IP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);
+	rcu_read_unlock();
+
+	/* Don't send error if the first segment did not arrive. */
+	if (!(fq->q.last_in & INET_FRAG_FIRST_IN) || !fq->q.fragments)
+		goto out;
+
+	/*
+	 * Only search router table for the head fragment,
+	 * when defraging timeout at PRE_ROUTING HOOK.
+	 */
+	if (fq->user == IP6_DEFRAG_CONNTRACK_IN) {
+		struct sk_buff *head = fq->q.fragments;
+
+		head->dev = dev;
+		ip6_route_input(head);
+		if (!skb_dst(head))
+			goto out;
+
+		/*
+		 * Only an end host needs to send an ICMP "Fragment Reassembly
+		 * Timeout" message, per section 4.5 of RFC2460.
+		 */
+		if (!(skb_r6table(head)->rt6i_flags & RTF_LOCAL))
+			goto out;
+
+		/* Send an ICMP "Fragment Reassembly Timeout" message. */
+		icmpv6_send(head, ICMPV6_TIME_EXCEED, ICMPV6_EXC_FRAGTIME, 0);
+	}
 
 out:
+	if (dev)
+		dev_put(dev);
 	spin_unlock(&fq->q.lock);
 	fq_put(fq);
 }
@@ -305,7 +348,11 @@ found:
 	else
 		fq->q.fragments = skb;
 
-	skb->dev = NULL;
+	if (skb->dev) {
+		fq->iif = skb->dev->ifindex;
+		skb->dev = NULL;
+	}
+
 	fq->q.stamp = skb->tstamp;
 	fq->q.meat += skb->len;
 	atomic_add(skb->truesize, &nf_init_frags.mem);
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index fa548ae..e5c6180 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -784,6 +784,7 @@ static struct rt6_info *rt6_alloc_clone(struct rt6_info *ort,
 	}
 	return rt;
 }
+EXPORT_SYMBOL(ip6_route_input);
 
 static struct rt6_info *ip6_pol_route(struct net *net, struct fib6_table *table, int oif,
 				      struct flowi6 *fl6, int flags)
-- 
1.7.10.4

