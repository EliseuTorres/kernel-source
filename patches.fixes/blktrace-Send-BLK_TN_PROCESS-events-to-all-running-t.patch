From: Jan Kara <jack@suse.cz>
Date: Tue, 17 Sep 2013 19:40:27 +0200
Subject: [PATCH] blktrace: Send BLK_TN_PROCESS events to all running traces
References: bnc#838623
Patch-mainline: 3.13
Git-commit: a404d5576bbe586a1097a8bc2f32c5f22651b0aa

Currently each task sends BLK_TN_PROCESS event to the first traced
device it interacts with after a new trace is started. When there are
several traced devices and the task accesses more devices, this logic
can result in BLK_TN_PROCESS being sent several times to some devices
while it is never sent to other devices. Thus blkparse doesn't display
command name when parsing some blktrace files.

Fix the problem by sending BLK_TN_PROCESS event to all traced devices
when a task interacts with any of them.

Signed-off-by: Jan Kara <jack@suse.cz>
---
 include/linux/blktrace_api.h |  2 ++
 kernel/trace/blktrace.c      | 33 +++++++++++++++++++++++++++------
 2 files changed, 29 insertions(+), 6 deletions(-)

Index: linux-3.0-SLE11-SP2/include/linux/blktrace_api.h
===================================================================
--- linux-3.0-SLE11-SP2.orig/include/linux/blktrace_api.h
+++ linux-3.0-SLE11-SP2/include/linux/blktrace_api.h
@@ -7,6 +7,7 @@
 #include <linux/relay.h>
 #include <linux/compat.h>
 #include <linux/kref.h>
+#include <linux/list.h>
 #endif
 
 /*
@@ -164,6 +165,7 @@ struct blk_trace {
 	struct dentry *msg_file;
 	atomic_t dropped;
 #ifndef __GENKSYMS__
+	struct list_head running_list;
 	struct kref kref;
 #endif
 };
Index: linux-3.0-SLE11-SP2/kernel/trace/blktrace.c
===================================================================
--- linux-3.0-SLE11-SP2.orig/kernel/trace/blktrace.c
+++ linux-3.0-SLE11-SP2/kernel/trace/blktrace.c
@@ -25,6 +25,7 @@
 #include <linux/debugfs.h>
 #include <linux/time.h>
 #include <linux/uaccess.h>
+#include <linux/list.h>
 
 #include <trace/events/block.h>
 
@@ -37,6 +38,9 @@ static unsigned int blktrace_seq __read_
 static struct trace_array *blk_tr;
 static bool blk_tracer_enabled __read_mostly;
 
+static LIST_HEAD(running_trace_list);
+static __cacheline_aligned_in_smp DEFINE_SPINLOCK(running_trace_lock);
+
 /* Select an alternative, minimalistic output than the original one */
 #define TRACE_BLK_OPT_CLASSIC	0x1
 
@@ -106,10 +110,18 @@ record_it:
  * Send out a notify for this process, if we haven't done so since a trace
  * started
  */
-static void trace_note_tsk(struct blk_trace *bt, struct task_struct *tsk)
+static void trace_note_tsk(struct task_struct *tsk)
 {
+	unsigned long flags;
+	struct blk_trace *bt;
+
 	tsk->btrace_seq = blktrace_seq;
-	trace_note(bt, tsk->pid, BLK_TN_PROCESS, tsk->comm, sizeof(tsk->comm));
+	spin_lock_irqsave(&running_trace_lock, flags);
+	list_for_each_entry(bt, &running_trace_list, running_list) {
+		trace_note(bt, tsk->pid, BLK_TN_PROCESS, tsk->comm,
+			   sizeof(tsk->comm));
+	}
+	spin_unlock_irqrestore(&running_trace_lock, flags);
 }
 
 static void trace_note_time(struct blk_trace *bt)
@@ -226,16 +238,15 @@ static void __blk_add_trace(struct blk_t
 		goto record_it;
 	}
 
+	if (unlikely(tsk->btrace_seq != blktrace_seq))
+		trace_note_tsk(tsk);
+
 	/*
 	 * A word about the locking here - we disable interrupts to reserve
 	 * some space in the relay per-cpu buffer, to prevent an irq
 	 * from coming in and stepping on our toes.
 	 */
 	local_irq_save(flags);
-
-	if (unlikely(tsk->btrace_seq != blktrace_seq))
-		trace_note_tsk(bt, tsk);
-
 	t = relay_reserve(bt->rchan, sizeof(*t) + pdu_len);
 	if (t) {
 		sequence = per_cpu_ptr(bt->sequence, cpu);
@@ -518,6 +529,7 @@ int do_blk_trace_setup(struct request_qu
 	bt->dir = dir;
 	bt->dev = dev;
 	atomic_set(&bt->dropped, 0);
+	INIT_LIST_HEAD(&bt->running_list);
 
 	ret = -EIO;
 	bt->dropped_file = debugfs_create_file("dropped", 0444, dir, bt,
@@ -642,6 +654,9 @@ int blk_trace_startstop(struct request_q
 			blktrace_seq++;
 			smp_mb();
 			bt->trace_state = Blktrace_running;
+			spin_lock_irq(&running_trace_lock);
+			list_add(&bt->running_list, &running_trace_list);
+			spin_unlock_irq(&running_trace_lock);
 
 			trace_note_time(bt);
 			ret = 0;
@@ -649,6 +664,9 @@ int blk_trace_startstop(struct request_q
 	} else {
 		if (bt->trace_state == Blktrace_running) {
 			bt->trace_state = Blktrace_stopped;
+			spin_lock_irq(&running_trace_lock);
+			list_del_init(&bt->running_list);
+			spin_unlock_irq(&running_trace_lock);
 			relay_flush(bt->rchan);
 			ret = 0;
 		}
@@ -1508,6 +1526,9 @@ static int blk_trace_remove_queue(struct
 	if (atomic_dec_and_test(&blk_probes_ref))
 		blk_unregister_tracepoints();
 
+	spin_lock_irq(&running_trace_lock);
+	list_del(&bt->running_list);
+	spin_unlock_irq(&running_trace_lock);
 	blk_trace_free(bt);
 	return 0;
 }
