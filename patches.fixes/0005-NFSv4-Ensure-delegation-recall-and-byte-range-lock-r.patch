From: Trond Myklebust <Trond.Myklebust@netapp.com>
Date: Thu, 7 Feb 2013 10:54:07 -0500
Subject: NFSv4: Ensure delegation recall and byte range lock removal don't conflict
Git-commit: 65b62a29f719e937b5be1df472287f4c61e53ac6
Patch-mainline: v3.9
References: bnc#864404

Add a mutex to the struct nfs4_state_owner to ensure that delegation
recall doesn't conflict with byte range lock removal.

Note that we nest the new mutex _outside_ the state manager reclaim
protection (nfsi->rwsem) in order to avoid deadlocks.

Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/nfs/delegation.c |    7 ++++++-
 fs/nfs/nfs4_fs.h    |    1 +
 fs/nfs/nfs4proc.c   |    9 ++++++++-
 fs/nfs/nfs4state.c  |    1 +
 4 files changed, 16 insertions(+), 2 deletions(-)

--- linux-3.0-SLE11-SP3.orig/fs/nfs/delegation.c
+++ linux-3.0-SLE11-SP3/fs/nfs/delegation.c
@@ -71,8 +71,10 @@ static int nfs_delegation_claim_locks(st
 	int status = 0;
 
 	if (inode->i_flock == NULL)
-		goto out;
+		return 0;
 
+	if (inode->i_flock == NULL)
+		goto out;
 	/* Protect inode->i_flock using the file locks lock */
 	lock_flocks();
 	for (fl = inode->i_flock; fl != NULL; fl = fl->fl_next) {
@@ -113,12 +115,15 @@ again:
 		get_nfs_open_context(ctx);
 		spin_unlock(&inode->i_lock);
 		sp = state->owner;
+		/* Block nfs4_proc_unlck */
+		mutex_lock(&sp->so_delegreturn_mutex);
 		seq = raw_seqcount_begin(&sp->so_reclaim_seqcount);
 		err = nfs4_open_delegation_recall(ctx, state, stateid);
 		if (!err)
 			err = nfs_delegation_claim_locks(ctx, state);
 		if (!err && read_seqcount_retry(&sp->so_reclaim_seqcount, seq))
 			err = -EAGAIN;
+		mutex_unlock(&sp->so_delegreturn_mutex);
 		put_nfs_open_context(ctx);
 		if (err != 0)
 			return err;
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4_fs.h
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4_fs.h
@@ -128,6 +128,7 @@ struct nfs4_state_owner {
 	struct nfs_seqid_counter so_seqid;
 	struct rpc_sequence  so_sequence;
 	seqcount_t	     so_reclaim_seqcount;
+	struct mutex	     so_delegreturn_mutex;
 };
 
 enum {
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4proc.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4proc.c
@@ -4259,7 +4259,9 @@ static struct rpc_task *nfs4_do_unlck(st
 
 static int nfs4_proc_unlck(struct nfs4_state *state, int cmd, struct file_lock *request)
 {
-	struct nfs_inode *nfsi = NFS_I(state->inode);
+	struct inode *inode = state->inode;
+	struct nfs4_state_owner *sp = state->owner;
+	struct nfs_inode *nfsi = NFS_I(inode);
 	struct nfs_seqid *seqid;
 	struct nfs4_lock_state *lsp;
 	struct rpc_task *task;
@@ -4269,12 +4271,17 @@ static int nfs4_proc_unlck(struct nfs4_s
 	status = nfs4_set_lock_state(state, request);
 	/* Unlock _before_ we do the RPC call */
 	request->fl_flags |= FL_EXISTS;
+	/* Exclude nfs_delegation_claim_locks() */
+	mutex_lock(&sp->so_delegreturn_mutex);
+	/* Exclude nfs4_reclaim_open_stateid() - note nesting! */
 	down_read(&nfsi->rwsem);
 	if (do_vfs_lock(request->fl_file, request) == -ENOENT) {
 		up_read(&nfsi->rwsem);
+		mutex_unlock(&sp->so_delegreturn_mutex);
 		goto out;
 	}
 	up_read(&nfsi->rwsem);
+	mutex_unlock(&sp->so_delegreturn_mutex);
 	if (status != 0)
 		goto out;
 	/* Is this a delegated lock? */
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4state.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4state.c
@@ -462,6 +462,7 @@ nfs4_alloc_state_owner(void)
 	INIT_LIST_HEAD(&sp->so_sequence.list);
 	atomic_set(&sp->so_count, 1);
 	seqcount_init(&sp->so_reclaim_seqcount);
+	mutex_init(&sp->so_delegreturn_mutex);
 	return sp;
 }
 
