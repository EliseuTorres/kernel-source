From: Oleg Nesterov <oleg@redhat.com>
Date: Wed Jun 12 14:04:46 2013 -0700
Subject: audit: wait_for_auditd() should use TASK_UNINTERRUPTIBLE
Git-commit: f000cfdde5de4fc15dead5ccf524359c07eadf2b
Patch-mainline: v3.10-rc6
References: bnc#908393
Signed-off-by: Tony Jones <tonyj@suse.de>

    audit: wait_for_auditd() should use TASK_UNINTERRUPTIBLE
    
    audit_log_start() does wait_for_auditd() in a loop until
    audit_backlog_wait_time passes or audit_skb_queue has a room.
    
    If signal_pending() is true this becomes a busy-wait loop, schedule() in
    TASK_INTERRUPTIBLE won't block.
    
    Thanks to Guy for fully investigating and explaining the problem.
    
    (akpm: that'll cause the system to lock up on a non-preemptible
    uniprocessor kernel)
    
    (Guy: "Our customer was in fact running a uniprocessor machine, and they
    reported a system hang.")
    
    Signed-off-by: Oleg Nesterov <oleg@redhat.com>
    Reported-by: Guy Streeter <streeter@redhat.com>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/kernel/audit.c b/kernel/audit.c
index 21c7fa6..91e53d0 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -1056,7 +1056,7 @@ static inline void audit_get_stamp(struct audit_context *ctx,
 static void wait_for_auditd(unsigned long sleep_time)
 {
 	DECLARE_WAITQUEUE(wait, current);
-	set_current_state(TASK_INTERRUPTIBLE);
+	set_current_state(TASK_UNINTERRUPTIBLE);
 	add_wait_queue(&audit_backlog_wait, &wait);
 
 	if (audit_backlog_limit &&
