From: Hannes Reinecke <hare@suse.de>
Date: Wed, 24 Aug 2011 13:16:37 +0200
Subject: Return 'SUCCESS' for fc_block_scsi_eh() instead of '0'
References: bnc#613330
Patch-Mainline: Submitted to linux-scsi

fc_block_scsi_eh() returns '0' on success instead of the
normal 'SUCCESS'. This introduces a potential source of
errors when the return value is used for further processing.
This patch updates the function to return 'SUCCESS' and
modifies each driver to correctly use the return value.

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/s390/scsi/zfcp_scsi.c    |   11 +++--------
 drivers/scsi/fnic/fnic_scsi.c    |   14 +++++++++-----
 drivers/scsi/ibmvscsi/ibmvfc.c   |   24 +++++++++++++++---------
 drivers/scsi/lpfc/lpfc_scsi.c    |   11 ++++++-----
 drivers/scsi/qla2xxx/qla_os.c    |    9 ++++-----
 drivers/scsi/scsi_transport_fc.c |    4 ++--
 6 files changed, 39 insertions(+), 34 deletions(-)

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 2a4991d..51c0585 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -198,7 +198,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 
 		zfcp_erp_wait(adapter);
 		ret = fc_block_scsi_eh(scpnt);
-		if (ret) {
+		if (ret != SUCCESS) {
 			zfcp_dbf_scsi_abort("abrt_bl", scpnt, NULL);
 			return ret;
 		}
@@ -243,7 +243,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 
 		zfcp_erp_wait(adapter);
 		ret = fc_block_scsi_eh(scpnt);
-		if (ret)
+		if (ret != SUCCESS)
 			return ret;
 
 		if (!(atomic_read(&adapter->status) &
@@ -281,15 +281,10 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
 	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
-	int ret;
 
 	zfcp_erp_adapter_reopen(adapter, 0, "schrh_1");
 	zfcp_erp_wait(adapter);
-	ret = fc_block_scsi_eh(scpnt);
-	if (ret)
-		return ret;
-
-	return SUCCESS;
+	return fc_block_scsi_eh(scpnt);
 }
 
 struct scsi_transport_template *zfcp_scsi_transport_template;
diff --git a/drivers/scsi/fnic/fnic_scsi.c b/drivers/scsi/fnic/fnic_scsi.c
index 538b31c..326fe63 100644
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@ -1236,13 +1236,15 @@ int fnic_abort_cmd(struct scsi_cmnd *sc)
 	struct fc_rport *rport;
 	spinlock_t *io_lock;
 	unsigned long flags;
-	int ret = SUCCESS;
+	int ret;
 	u32 task_req;
 	struct scsi_lun fc_lun;
 	DECLARE_COMPLETION_ONSTACK(tm_done);
 
 	/* Wait for rport to unblock */
-	fc_block_scsi_eh(sc);
+	ret = fc_block_scsi_eh(sc);
+	if (ret != SUCCESS)
+		return ret;
 
 	/* Get local-port, check ready and link up */
 	lp = shost_priv(sc->device->host);
@@ -1514,14 +1516,16 @@ int fnic_device_reset(struct scsi_cmnd *sc)
 	struct fnic_io_req *io_req;
 	struct fc_rport *rport;
 	int status;
-	int ret = FAILED;
+	int ret;
 	spinlock_t *io_lock;
 	unsigned long flags;
 	DECLARE_COMPLETION_ONSTACK(tm_done);
 
 	/* Wait for rport to unblock */
-	fc_block_scsi_eh(sc);
-
+	ret = fc_block_scsi_eh(sc);
+	if (ret != SUCCESS)
+		return ret;
+	ret = FAILED;
 	/* Get local-port, check ready and link up */
 	lp = shost_priv(sc->device->host);
 
diff --git a/drivers/scsi/ibmvscsi/ibmvfc.c b/drivers/scsi/ibmvscsi/ibmvfc.c
index bdfa223..ab0d61e 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.c
+++ b/drivers/scsi/ibmvscsi/ibmvfc.c
@@ -2362,17 +2362,19 @@ static int ibmvfc_eh_abort_handler(struct scsi_cmnd *cmd)
 	struct scsi_device *sdev = cmd->device;
 	struct ibmvfc_host *vhost = shost_priv(sdev->host);
 	int cancel_rc, abort_rc;
-	int rc = FAILED;
+	int rc;
 
 	ENTER;
-	fc_block_scsi_eh(cmd);
+	rc = fc_block_scsi_eh(cmd);
+	if (rc != SUCCESS)
+		goto out;
 	ibmvfc_wait_while_resetting(vhost);
 	cancel_rc = ibmvfc_cancel_all(sdev, IBMVFC_TMF_ABORT_TASK_SET);
 	abort_rc = ibmvfc_abort_task_set(sdev);
 
 	if (!cancel_rc && !abort_rc)
 		rc = ibmvfc_wait_for_ops(vhost, sdev, ibmvfc_match_lun);
-
+out:
 	LEAVE;
 	return rc;
 }
@@ -2389,17 +2391,19 @@ static int ibmvfc_eh_device_reset_handler(struct scsi_cmnd *cmd)
 	struct scsi_device *sdev = cmd->device;
 	struct ibmvfc_host *vhost = shost_priv(sdev->host);
 	int cancel_rc, reset_rc;
-	int rc = FAILED;
+	int rc;
 
 	ENTER;
-	fc_block_scsi_eh(cmd);
+	rc = fc_block_scsi_eh(cmd);
+	if (rc != SUCCESS)
+		goto out;
 	ibmvfc_wait_while_resetting(vhost);
 	cancel_rc = ibmvfc_cancel_all(sdev, IBMVFC_TMF_LUN_RESET);
 	reset_rc = ibmvfc_reset_device(sdev, IBMVFC_LUN_RESET, "LUN");
 
 	if (!cancel_rc && !reset_rc)
 		rc = ibmvfc_wait_for_ops(vhost, sdev, ibmvfc_match_lun);
-
+out:
 	LEAVE;
 	return rc;
 }
@@ -2429,18 +2433,20 @@ static int ibmvfc_eh_target_reset_handler(struct scsi_cmnd *cmd)
 	struct ibmvfc_host *vhost = shost_priv(sdev->host);
 	struct scsi_target *starget = scsi_target(sdev);
 	int reset_rc;
-	int rc = FAILED;
+	int rc;
 	unsigned long cancel_rc = 0;
 
 	ENTER;
-	fc_block_scsi_eh(cmd);
+	rc = fc_block_scsi_eh(cmd);
+	if (rc != SUCCESS)
+		goto out;
 	ibmvfc_wait_while_resetting(vhost);
 	starget_for_each_device(starget, &cancel_rc, ibmvfc_dev_cancel_all_reset);
 	reset_rc = ibmvfc_reset_device(sdev, IBMVFC_TARGET_RESET, "target");
 
 	if (!cancel_rc && !reset_rc)
 		rc = ibmvfc_wait_for_ops(vhost, starget, ibmvfc_match_target);
-
+out:
 	LEAVE;
 	return rc;
 }
diff --git a/drivers/scsi/lpfc/lpfc_scsi.c b/drivers/scsi/lpfc/lpfc_scsi.c
index 3ccc974..664c7cc 100644
--- a/drivers/scsi/lpfc/lpfc_scsi.c
+++ b/drivers/scsi/lpfc/lpfc_scsi.c
@@ -3261,12 +3261,13 @@ lpfc_abort_handler(struct scsi_cmnd *cmnd)
 	struct lpfc_iocbq *abtsiocb;
 	struct lpfc_scsi_buf *lpfc_cmd;
 	IOCB_t *cmd, *icmd;
-	int ret = SUCCESS;
+	int ret;
 	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(waitq);
 
 	ret = fc_block_scsi_eh(cmnd);
-	if (ret)
+	if (ret != SUCCESS)
 		return ret;
+
 	lpfc_cmd = (struct lpfc_scsi_buf *)cmnd->host_scribble;
 	if (!lpfc_cmd) {
 		lpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,
@@ -3594,7 +3595,7 @@ lpfc_device_reset_handler(struct scsi_cmnd *cmnd)
 	}
 	pnode = rdata->pnode;
 	status = fc_block_scsi_eh(cmnd);
-	if (status)
+	if (status != SUCCESS)
 		return status;
 
 	status = lpfc_chk_tgt_mapped(vport, cmnd);
@@ -3661,7 +3662,7 @@ lpfc_target_reset_handler(struct scsi_cmnd *cmnd)
 	}
 	pnode = rdata->pnode;
 	status = fc_block_scsi_eh(cmnd);
-	if (status)
+	if (status != SUCCESS)
 		return status;
 
 	status = lpfc_chk_tgt_mapped(vport, cmnd);
@@ -3729,7 +3730,7 @@ lpfc_bus_reset_handler(struct scsi_cmnd *cmnd)
 		sizeof(scsi_event), (char *)&scsi_event, LPFC_NL_VENDOR_ID);
 
 	ret = fc_block_scsi_eh(cmnd);
-	if (ret)
+	if (ret != SUCCESS)
 		return ret;
 
 	/*
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index f461925..c07fd04 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -835,9 +835,8 @@ qla2xxx_eh_abort(struct scsi_cmnd *cmd)
 		return SUCCESS;
 
 	ret = fc_block_scsi_eh(cmd);
-	if (ret != 0)
+	if (ret != SUCCESS)
 		return ret;
-	ret = SUCCESS;
 
 	id = cmd->device->id;
 	lun = cmd->device->lun;
@@ -951,7 +950,7 @@ __qla2xxx_eh_generic_reset(char *name, enum nexus_wait_type type,
 		return FAILED;
 
 	err = fc_block_scsi_eh(cmd);
-	if (err != 0)
+	if (err != SUCCESS)
 		return err;
 
 	qla_printk(KERN_INFO, vha->hw, "scsi(%ld:%d:%d): %s RESET ISSUED.\n",
@@ -1034,7 +1033,7 @@ qla2xxx_eh_bus_reset(struct scsi_cmnd *cmd)
 		return ret;
 
 	ret = fc_block_scsi_eh(cmd);
-	if (ret != 0)
+	if (ret != SUCCESS)
 		return ret;
 	ret = FAILED;
 
@@ -1097,7 +1096,7 @@ qla2xxx_eh_host_reset(struct scsi_cmnd *cmd)
 		return ret;
 
 	ret = fc_block_scsi_eh(cmd);
-	if (ret != 0)
+	if (ret != SUCCESS)
 		return ret;
 	ret = FAILED;
 
diff --git a/drivers/scsi/scsi_transport_fc.c b/drivers/scsi/scsi_transport_fc.c
index 1b21491..395b3b4 100644
--- a/drivers/scsi/scsi_transport_fc.c
+++ b/drivers/scsi/scsi_transport_fc.c
@@ -3256,7 +3256,7 @@ fc_scsi_scan_rport(struct work_struct *work)
  * necessary to avoid the scsi_eh failing recovery actions for blocked
  * rports which would lead to offlined SCSI devices.
  *
- * Returns: 0 if the fc_rport left the state FC_PORTSTATE_BLOCKED.
+ * Returns: SUCCESS if the fc_rport left the state FC_PORTSTATE_BLOCKED.
  *	    FAST_IO_FAIL if the fast_io_fail_tmo fired, this should be
  *	    passed back to scsi_eh.
  */
@@ -3278,7 +3278,7 @@ int fc_block_scsi_eh(struct scsi_cmnd *cmnd)
 	if (rport->flags & FC_RPORT_FAST_FAIL_TIMEDOUT)
 		return FAST_IO_FAIL;
 
-	return 0;
+	return SUCCESS;
 }
 EXPORT_SYMBOL(fc_block_scsi_eh);
 
-- 
1.6.0.2

