From: Hannes Reinecke <hare@suse.de>
Subject: Root on multipath goes into unresponsive state for a long time
References: bnc#620443
Patch-Mainline: Yes

This is a combined patch of commit
b64e77f70b8c11766e967e3485331a9e6ef01390:
    [SCSI] iscsi_tcp: wake xmit thread when killing session

and
d7d05548a62c87ee55b0c81933669177f885aa8d
    [SCSI] iscsi_tcp: fix relogin/shutdown hang

During controller faults the xmit thread might end up waiting
for a long time in tcp_sendpage. With this patch we're setting
sk_err and wake up the xmit thread so that we can fail quickly.

Signed-off-by: Mike Christie <michealc@cs.wisc.edu>
Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 0204489..310a5a7 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -584,9 +584,10 @@ static void iscsi_sw_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;
+	struct socket *sock = tcp_sw_conn->sock;
 
 	/* userspace may have goofed up and not bound us */
-	if (!tcp_sw_conn->sock)
+	if (!sock)
 		return;
 	/*
 	 * Make sure our recv side is stopped.
@@ -597,6 +598,11 @@ static void iscsi_sw_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);
 	write_unlock_bh(&tcp_sw_conn->sock->sk->sk_callback_lock);
 
+	if (sock->sk->sk_sleep && waitqueue_active(sock->sk->sk_sleep)) {
+		sock->sk->sk_err = EIO;
+		wake_up_interruptible(sock->sk->sk_sleep);
+	}
+
 	iscsi_conn_stop(cls_conn, flag);
 	iscsi_sw_tcp_release_conn(conn);
 }
