From: NeilBrown <neilb@suse.de>
Subject: Throttle number of pending write requests in md/raid1
References: bnc#663678

Currently write requests are added to a queue to be processed later by
the raid1d thread.  This allows an arbitrary number of requests to
queue up which is bad for latency.

So count the number of requests and allow it to be limited.

Currently the limit is virtually infinity and must be set by changing
  /sys/modules/raid1/parameters/max_queued
to be effective.

This is because there is still some uncertainty about the exact
behaviour required.  Once this is resolved the default might be
changed.  For now it is here as a place-holder and subsequent patches
change this code, so we wont to some something in place.

Signed-off-by: NeilBrown <neilb@suse.de>


---
 drivers/md/raid1.c |   19 +++++++++++++++++++
 drivers/md/raid1.h |    1 +
 2 files changed, 20 insertions(+)

--- linux-2.6.32-SLE11-SP1.orig/drivers/md/raid1.c
+++ linux-2.6.32-SLE11-SP1/drivers/md/raid1.c
@@ -570,6 +570,7 @@ static void raid1_unplug(struct request_
 	md_wakeup_thread(mddev->thread);
 }
 
+static int max_queued = INT_MAX;
 static int raid1_congested(void *data, int bits)
 {
 	mddev_t *mddev = data;
@@ -579,6 +580,10 @@ static int raid1_congested(void *data, i
 	if (mddev_congested(mddev, bits))
 		return 1;
 
+	if ((bits & (1 << BDI_async_congested)) &&
+	    conf->pending_count >= max_queued)
+		return 1;
+
 	rcu_read_lock();
 	for (i = 0; i < mddev->raid_disks; i++) {
 		mdk_rdev_t *rdev = rcu_dereference(conf->mirrors[i].rdev);
@@ -613,7 +618,9 @@ static int flush_pending_writes(conf_t *
 		struct bio *bio;
 		bio = bio_list_get(&conf->pending_bio_list);
 		blk_remove_plug(conf->mddev->queue);
+		conf->pending_count = 0;
 		spin_unlock_irq(&conf->device_lock);
+		wake_up(&conf->wait_barrier);
 		/* flush any pending bitmap writes to
 		 * disk before proceeding w/ I/O */
 		bitmap_unplug(conf->mddev->bitmap);
@@ -783,6 +790,7 @@ static int make_request(struct request_q
 	struct bitmap *bitmap;
 	unsigned long flags;
 	struct bio_list bl;
+	int bl_count;
 	struct page **behind_pages = NULL;
 	const int rw = bio_data_dir(bio);
 	const bool do_sync = bio_rw_flagged(bio, BIO_RW_SYNCIO);
@@ -873,6 +881,11 @@ static int make_request(struct request_q
 	/*
 	 * WRITE:
 	 */
+	if (conf->pending_count >= max_queued) {
+		md_wakeup_thread(mddev->thread);
+		wait_event(conf->wait_barrier,
+			   conf->pending_count < max_queued);
+	}
 	/* first select target devices under spinlock and
 	 * inc refcount on their rdev.  Record them by setting
 	 * bios[x] to bio
@@ -949,6 +962,7 @@ static int make_request(struct request_q
 		set_bit(R1BIO_Barrier, &r1_bio->state);
 
 	bio_list_init(&bl);
+	bl_count = 0;
 	for (i = 0; i < disks; i++) {
 		struct bio *mbio;
 		if (!r1_bio->bios[i])
@@ -984,6 +998,7 @@ static int make_request(struct request_q
 		atomic_inc(&r1_bio->remaining);
 
 		bio_list_add(&bl, mbio);
+		bl_count++;
 	}
 	kfree(behind_pages); /* the behind pages are attached to the bios now */
 
@@ -991,6 +1006,7 @@ static int make_request(struct request_q
 				test_bit(R1BIO_BehindIO, &r1_bio->state));
 	spin_lock_irqsave(&conf->device_lock, flags);
 	bio_list_merge(&conf->pending_bio_list, &bl);
+	conf->pending_count += bl_count;
 	bio_list_init(&bl);
 
 	blk_plug_device(mddev->queue);
@@ -2035,6 +2051,7 @@ static int run(mddev_t *mddev)
 	init_waitqueue_head(&conf->wait_barrier);
 
 	bio_list_init(&conf->pending_bio_list);
+	conf->pending_count = 0;
 	bio_list_init(&conf->flushing_bio_list);
 
 
@@ -2330,3 +2347,5 @@ MODULE_LICENSE("GPL");
 MODULE_ALIAS("md-personality-3"); /* RAID1 */
 MODULE_ALIAS("md-raid1");
 MODULE_ALIAS("md-level-1");
+
+module_param(max_queued, int, S_IRUGO|S_IWUSR);
--- linux-2.6.32-SLE11-SP1.orig/drivers/md/raid1.h
+++ linux-2.6.32-SLE11-SP1/drivers/md/raid1.h
@@ -35,6 +35,7 @@ struct r1_private_data_s {
 	struct list_head	retry_list;
 	/* queue pending writes and submit them on unplug */
 	struct bio_list		pending_bio_list;
+	int			pending_count;
 	/* queue of writes that have been unplugged */
 	struct bio_list		flushing_bio_list;
 
