From: Michal Hocko <mhocko@suse.cz>
Subject: printk: Do not call console_unlock from nmi context
Patch-mainline: not yet
References: bnc#831949

console_unlock is tricky piece of code. It re-acquires logbuf_lock and takes
other locks (e.g. from IRQ tracing path) which is a no-go for NMI context.
Make sure we never call this function from nmi context. As a result we have to
live with NMI messages potentially sitting in the NMI ringbuffer until a
non-NMI printk happens. Which might be a lot of time.

Signed-off-by: Michal Hocko <mhocko@suse.cz>
---
 kernel/printk.c |   31 ++++++++++++++++++++-----------
 1 file changed, 20 insertions(+), 11 deletions(-)

--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -868,7 +868,6 @@ static int console_trylock_for_printk(un
 			retval = 0;
 		}
 	}
-	printk_cpu = UINT_MAX;
 	spin_unlock(&logbuf_lock);
 	return retval;
 }
@@ -1095,20 +1094,30 @@ asmlinkage int vprintk(const char *fmt,
 	 * The console_trylock_for_printk() function
 	 * will release 'logbuf_lock' regardless of whether it
 	 * actually gets the semaphore or not.
+	 *
+	 * This whole magic is not allowed from nmi context as
+	 * console_unlock re-takes logbuf_lock and other locks
+	 * from follow-up paths.
 	 */
 	if (!in_nmi_delayed_printk) {
-		if (console_trylock_for_printk(this_cpu))
-			console_unlock();
+		printk_cpu = UINT_MAX;
+		if (in_nmi()) {
+			spin_unlock(&logbuf_lock);
+		} else {
+			if (console_trylock_for_printk(this_cpu))
+				console_unlock();
 
-		/*
-		 * We are calling this outside of the lock just to make sure
-		 * that the printk which raced with NMI had a chance to do
-		 * some progress since it has been interrupted.
-		 * Do not try to handle pending NMI messages from NMI as
-		 * we would need to take logbuf_lock and we could deadlock.
-		 */
-		if (!in_nmi())
+			/*
+			 * We are calling this outside of the lock just to make
+			 * sure that the printk which raced with NMI had a
+			 * chance to do some progress since it has been
+			 * interrupted.
+			 * Do not try to handle pending NMI messages from NMI as
+			 * we would need to take logbuf_lock and we could
+			 * deadlock.
+			 */
 			handle_nmi_delayed_printk();
+		}
 	} else
 		spin_unlock(&nmi_logbuf_lock);
 
