From: Hannes Reinecke <hare@suse.de>
Date: Tue, 12 Nov 2013 10:48:00 +0100
Subject: scsi_dh_alua: fine-grained locking in alua_rtpg_work()
References: bnc#708296
Patch-Mainline: posted to linux-scsi

Move the locking in alua_rtpg_work() down to just before
evaluating callbacks. That will allow us to better queue
outstanding requests.

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/device_handler/scsi_dh_alua.c | 21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)

diff --git a/drivers/scsi/device_handler/scsi_dh_alua.c b/drivers/scsi/device_handler/scsi_dh_alua.c
index f83446c..3d666c0 100644
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@ -914,24 +914,33 @@ static void alua_rtpg_work(struct work_struct *work)
 	struct alua_queue_data *qdata, *tmp;
 	unsigned long flags;
 
-	spin_lock_irqsave(&pg->rtpg_lock, flags);
-	pg->rtpg_sdev = NULL;
-	list_splice_init(&pg->rtpg_list, &qdata_list);
-	spin_unlock_irqrestore(&pg->rtpg_lock, flags);
-
 	err = alua_rtpg(sdev, pg);
-	if (err != SCSI_DH_OK || list_empty(&qdata_list))
+	if (err != SCSI_DH_OK)
 		goto done;
+	spin_lock_irqsave(&pg->rtpg_lock, flags);
+	if (list_empty(&pg->rtpg_list)) {
+		/* Check only, do not call stpg */
+		pg->rtpg_sdev = NULL;
+		spin_unlock_irqrestore(&pg->rtpg_lock, flags);
+		goto out;
+	}
+	spin_unlock_irqrestore(&pg->rtpg_lock, flags);
 	err = alua_stpg(sdev, pg);
 	if (err == SCSI_DH_RETRY)
 		err = alua_rtpg(sdev, pg);
 done:
+	spin_lock_irqsave(&pg->rtpg_lock, flags);
+	list_splice_init(&pg->rtpg_list, &qdata_list);
+	pg->rtpg_sdev = NULL;
+	spin_unlock_irqrestore(&pg->rtpg_lock, flags);
+
 	list_for_each_entry_safe(qdata, tmp, &qdata_list, entry) {
 		list_del(&qdata->entry);
 		if (qdata->callback_fn)
 			qdata->callback_fn(qdata->callback_data, err);
 		kfree(qdata);
 	}
+out:
 	kref_put(&pg->kref, release_port_group);
 	scsi_device_put(sdev);
 }
-- 
1.7.12.4

