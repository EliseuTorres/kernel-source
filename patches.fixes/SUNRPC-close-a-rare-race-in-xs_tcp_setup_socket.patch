Git-commit: 93dc41bdc5c853916610576c6b48a1704959c70d
From: NeilBrown <neilb@suse.de>
Date: Thu, 31 Oct 2013 16:14:36 +1100
Subject: [PATCH] SUNRPC: close a rare race in xs_tcp_setup_socket.
Patch-mainline: 3.13
References: bnc#794824

(patches.fixes/nfs-xs_tcp_setup_socket.fix in SLE11-SP3)

We have one report of a crash in xs_tcp_setup_socket.
The call path to the crash is:

  xs_tcp_setup_socket -> inet_stream_connect -> lock_sock_nested.

The 'sock' passed to that last function is NULL.

The only way I can see this happening is a concurrent call to
Xs_close: 

  xs_close -> xs_reset_transport -> sock_release -> inet_release

inet_release sets:
   sock->sk = NULL;
inet_stream_connect calls
   lock_sock(sock->sk);
which gets NULL.

All calls to xs_close are protected by XPRT_LOCKED as are most
activations of the workqueue which runs xs_tcp_setup_socket.
The exception is xs_tcp_schedule_linger_timeout.

So presumably the timeout queued by the later fires exactly when some
other code runs xs_close().

To protect against this we can move the cancel_delayed_work_sync()
call from xs_destory() to xs_close().

As xs_close is never called from the worker scheduled on
->connect_worker, this can never deadlock.

Signed-off-by: NeilBrown <neilb@suse.de>
[trond: Make it safe to call cancel_delayed_work_sync() on AF_LOCAL sockets]
Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Acked-by: NeilBrown <neilb@suse.de>

---
 net/sunrpc/xprtsock.c |   13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

--- linux-3.12-SLE12.orig/net/sunrpc/xprtsock.c
+++ linux-3.12-SLE12/net/sunrpc/xprtsock.c
@@ -849,6 +849,8 @@ static void xs_close(struct rpc_xprt *xp
 
 	dprintk("RPC:       xs_close xprt %p\n", xprt);
 
+	cancel_delayed_work_sync(&transport->connect_worker);
+
 	xs_reset_transport(transport);
 	xprt->reestablish_timeout = 0;
 
@@ -883,12 +885,8 @@ static void xs_local_destroy(struct rpc_
  */
 static void xs_destroy(struct rpc_xprt *xprt)
 {
-	struct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);
-
 	dprintk("RPC:       xs_destroy xprt %p\n", xprt);
 
-	cancel_delayed_work_sync(&transport->connect_worker);
-
 	xs_local_destroy(xprt);
 }
 
@@ -1830,6 +1828,10 @@ static inline void xs_reclassify_socket(
 }
 #endif
 
+static void xs_dummy_setup_socket(struct work_struct *work)
+{
+}
+
 static struct socket *xs_create_sock(struct rpc_xprt *xprt,
 		struct sock_xprt *transport, int family, int type, int protocol)
 {
@@ -2669,6 +2671,9 @@ static struct rpc_xprt *xs_setup_local(s
 	xprt->ops = &xs_local_ops;
 	xprt->timeout = &xs_local_default_timeout;
 
+	INIT_DELAYED_WORK(&transport->connect_worker,
+			xs_dummy_setup_socket);
+
 	switch (sun->sun_family) {
 	case AF_LOCAL:
 		if (sun->sun_path[0] != '/') {
