From: Jeff Layton <jlayton@redhat.com>
Date: Tue, 11 Dec 2012 12:10:11 -0500
Subject: [PATCH 13/28] vfs: have do_sys_truncate retry once on an ESTALE error
Git-commit: 48f7530d3f722617aa7cfea62b09b0c1a8d0173e
Patch-mainline: v3.8
References: bnc#876463

Signed-off-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/open.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

--- linux-3.0-SLE11-SP3.orig/fs/open.c
+++ linux-3.0-SLE11-SP3/fs/open.c
@@ -66,6 +66,7 @@ int do_truncate(struct dentry *dentry, l
 
 static long do_sys_truncate(const char __user *pathname, loff_t length)
 {
+	unsigned int lookup_flags = LOOKUP_FOLLOW;
 	struct path path;
 	struct inode *inode;
 	int error;
@@ -74,7 +75,8 @@ static long do_sys_truncate(const char _
 	if (length < 0)	/* sorry, but loff_t says... */
 		goto out;
 
-	error = user_path(pathname, &path);
+retry:
+	error = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);
 	if (error)
 		goto out;
 	inode = path.dentry->d_inode;
@@ -125,6 +127,10 @@ mnt_drop_write_and_out:
 dput_and_out:
 	path_put(&path);
 out:
+	if (retry_estale(error, lookup_flags)) {
+		lookup_flags |= LOOKUP_REVAL;
+		goto retry;
+	}
 	return error;
 }
 
