From: Jan Kara <jack@suse.cz>
Subject: xfs: Serialize file-extending direct IO
Patch-mainline: Never (code rewritten)
References: bnc#818371

XFS currently allowed parallel direct IO which is extending a file. Sadly
updates of inode size are racy and so it can happen that some writes get lost.
For example consider two racing AIO DIO writes to 0-length file like:

pwrite(fd, buf, 1024, 0);		pwrite(fd, buf, 1024, 1024);
					  ...
					  xfs_ioend_new_eof()
					    di_size set to 2048
  ...
  xfs_ioend_new_eof()
    returns 0
  ...
  xfs_aio_write_isize_update()
    i_size set to 1024
  xfs_aio_write_newsize_update()
    di_size reset to 1024
					...
					xfs_aio_write_isize_update()
					  i_size set to 2048

We see di_size was left at 1024 although it should have been set to 2048.
There are more races with a similar result in the complex i_size / i_new_size /
i_d.di_size handling. So avoid them by serializing direct IO writes that are
extending inode size.

Signed-off-by: Jan Kara <jack@suse.cz>

diff -rupX /crypted/home/jack/.kerndiffexclude linux-3.0-SLE11-SP2-xfs_isize_update/fs/xfs/linux-2.6/xfs_file.c linux-3.0-SLE11-SP2/fs/xfs/linux-2.6/xfs_file.c
--- linux-3.0-SLE11-SP2-xfs_isize_update/fs/xfs/linux-2.6/xfs_file.c	2013-05-20 16:04:35.763714979 +0200
+++ linux-3.0-SLE11-SP2/fs/xfs/linux-2.6/xfs_file.c	2013-05-22 22:02:28.748266328 +0200
@@ -852,6 +852,7 @@ xfs_file_dio_aio_write(
 	ssize_t			ret = 0;
 	size_t			count = ocount;
 	int			unaligned_io = 0;
+	int			appending_io = 0;
 	struct xfs_buftarg	*target = XFS_IS_REALTIME_INODE(ip) ?
 					mp->m_rtdev_targp : mp->m_ddev_targp;
 
@@ -862,7 +863,10 @@ xfs_file_dio_aio_write(
 	if ((pos & mp->m_blockmask) || ((pos + count) & mp->m_blockmask))
 		unaligned_io = 1;
 
-	if (unaligned_io || mapping->nrpages || pos > ip->i_size)
+	if (pos + count > ip->i_size)
+		appending_io = 1;
+
+	if (unaligned_io || mapping->nrpages || appending_io)
 		*iolock = XFS_IOLOCK_EXCL;
 	else
 		*iolock = XFS_IOLOCK_SHARED;
@@ -896,7 +900,7 @@ xfs_file_dio_aio_write(
 	 */
 	if (unaligned_io)
 		xfs_ioend_wait(ip);
-	else if (*iolock == XFS_IOLOCK_EXCL) {
+	else if (*iolock == XFS_IOLOCK_EXCL && !appending_io) {
 		xfs_rw_ilock_demote(ip, XFS_IOLOCK_EXCL);
 		*iolock = XFS_IOLOCK_SHARED;
 	}
