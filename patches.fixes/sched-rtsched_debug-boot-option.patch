Subject: Add rtsched_debug boot option
From: Mike Galbraith <mgalbraith@suse.de>
Date: Thu Jul 28 13:39:19 CEST 2011
Patch-mainline: never
References: bnc#708730

Provide a boot option which turns off runtime borrowing, turning
the throttle into a strict hard limit per runqueue, so users
can debug their realtime code without killing their box.

Emit notification when the hard limit has been reached, and very
scary warning if the runqueue is approaching 100% CPU.

[  104.949009] RT: throttling CPU2
[  104.949011] RT: Danger!  (mlock) is potential runaway.

Signed-off-by: Mike Galbraith <mgalbraith@suse.de>

---
 Documentation/kernel-parameters.txt |    3 +++
 kernel/sched.c                      |   10 ++++++++++
 kernel/sched_rt.c                   |   29 +++++++++++++++++++++++++----
 3 files changed, 38 insertions(+), 4 deletions(-)

Index: linux-2.6.32-SLE11-SP1/Documentation/kernel-parameters.txt
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/Documentation/kernel-parameters.txt
+++ linux-2.6.32-SLE11-SP1/Documentation/kernel-parameters.txt
@@ -2188,6 +2188,9 @@ and is between 256 and 4096 characters.
 
 	sched_debug	[KNL] Enables verbose scheduler debug messages.
 
+	rtsched_debug	[KNL] Disallows borrowing of excess rt_runtime from neighboring runqueues.
+                        /proc/sys/kernel/sched_rt_runtime_us becomes a hard limit per runqueue.
+
 	sc1200wdt=	[HW,WDT] SC1200 WDT (watchdog) driver
 			Format: <io>[,<timeout>[,<isapnp>]]
 
Index: linux-2.6.32-SLE11-SP1/kernel/sched.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/kernel/sched.c
+++ linux-2.6.32-SLE11-SP1/kernel/sched.c
@@ -837,6 +837,16 @@ static inline u64 global_rt_runtime(void
 	return (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;
 }
 
+int __read_mostly sysctl_sched_rtsched_debug;
+
+static int __init parse_rtsched_debug(char *arg)
+{
+	sysctl_sched_rtsched_debug = 1;
+	return 0;
+}
+early_param("rtsched_debug", parse_rtsched_debug);
+
+
 #ifndef prepare_arch_switch
 # define prepare_arch_switch(next)	do { } while (0)
 #endif
Index: linux-2.6.32-SLE11-SP1/kernel/sched_rt.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/kernel/sched_rt.c
+++ linux-2.6.32-SLE11-SP1/kernel/sched_rt.c
@@ -495,12 +495,33 @@ static int balance_runtime(struct rt_rq
 {
 	int more = 0;
 
-	if (rt_rq->rt_time > rt_rq->rt_runtime) {
-		spin_unlock(&rt_rq->rt_runtime_lock);
-		more = do_balance_runtime(rt_rq);
-		spin_lock(&rt_rq->rt_runtime_lock);
+	if (rt_rq->rt_time <= rt_rq->rt_runtime)
+		return 0;
+
+	if (sysctl_sched_rtsched_debug) {
+		struct rq *rq;
+		u64 period;
+
+		if (!printk_ratelimit())
+			return 0;
+
+		rq = rq_of_rt_rq(rt_rq);
+		period = sched_rt_period(rt_rq);
+		printk(KERN_WARNING "RT: throttling CPU%d\n", rq->cpu);
+
+		if (rt_rq->rt_time > period - (period >> 3)) {
+			struct task_struct *p = rq->curr;
+
+			printk(KERN_WARNING "RT: Danger!  (%s) is potential runaway.\n", p->comm);
+		}
+
+		return 0;
 	}
 
+	spin_unlock(&rt_rq->rt_runtime_lock);
+	more = do_balance_runtime(rt_rq);
+	spin_lock(&rt_rq->rt_runtime_lock);
+
 	return more;
 }
 #else /* !CONFIG_SMP */
