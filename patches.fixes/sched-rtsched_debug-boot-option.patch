Subject: Add rtsched_debug boot option
From: Mike Galbraith <mgalbraith@suse.de>
Date: Thu Jul 28 13:39:19 CEST 2011
Patch-mainline: never
References: bnc#708730

Provide a boot option which turns off runtime borrowing, turning
the throttle into a strict hard limit per runqueue, so users
can debug their realtime code without killing their box.

Emit notification when the hard limit has been reached, and very
scary warning if the runqueue is approaching 100% CPU.

[  104.949009] RT: throttling CPU2
[  104.949011] RT: Danger!  (mlock) is potential runaway.

Signed-off-by: Mike Galbraith <mgalbraith@suse.de>

---
 Documentation/kernel-parameters.txt |    3 +++
 kernel/sched.c                      |   10 ++++++++++
 kernel/sched_rt.c                   |   32 ++++++++++++++++++++++++++++----
 3 files changed, 41 insertions(+), 4 deletions(-)

Index: linux-3.0-SLE11-SP2-3.0/Documentation/kernel-parameters.txt
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/Documentation/kernel-parameters.txt
+++ linux-3.0-SLE11-SP2-3.0/Documentation/kernel-parameters.txt
@@ -2259,6 +2259,9 @@ bytes respectively. Such letter suffixes
 
 	sched_debug	[KNL] Enables verbose scheduler debug messages.
 
+	rtsched_debug   [KNL] Disallows borrowing of excess rt_runtime from neighboring runqueues.
+			  /proc/sys/kernel/sched_rt_runtime_us becomes a hard limit per runqueue.
+
 	security=	[SECURITY] Choose a security module to enable at boot.
 			If this boot parameter is not specified, only the first
 			security module asking for security registration will be
Index: linux-3.0-SLE11-SP2-3.0/kernel/sched.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/kernel/sched.c
+++ linux-3.0-SLE11-SP2-3.0/kernel/sched.c
@@ -971,6 +971,16 @@ static inline u64 global_rt_runtime(void
 	return (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;
 }
 
+int __read_mostly sysctl_sched_rtsched_debug;
+
+static int __init parse_rtsched_debug(char *arg)
+{
+	sysctl_sched_rtsched_debug = 1;
+	return 0;
+}
+early_param("rtsched_debug", parse_rtsched_debug);
+
+
 #ifndef prepare_arch_switch
 # define prepare_arch_switch(next)	do { } while (0)
 #endif
Index: linux-3.0-SLE11-SP2-3.0/kernel/sched_rt.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/kernel/sched_rt.c
+++ linux-3.0-SLE11-SP2-3.0/kernel/sched_rt.c
@@ -536,12 +536,36 @@ static int balance_runtime(struct rt_rq
 {
 	int more = 0;
 
-	if (rt_rq->rt_time > rt_rq->rt_runtime) {
-		raw_spin_unlock(&rt_rq->rt_runtime_lock);
-		more = do_balance_runtime(rt_rq);
-		raw_spin_lock(&rt_rq->rt_runtime_lock);
+	if (rt_rq->rt_time <= rt_rq->rt_runtime)
+		return 0;
+
+	if (sysctl_sched_rtsched_debug) {
+		struct rq *rq;
+		struct task_struct *p;
+		u64 period;
+
+		if (!printk_ratelimit())
+			return 0;
+
+		rq = rq_of_rt_rq(rt_rq);
+		printk(KERN_WARNING "RT: throttling CPU%d\n", rq->cpu);
+
+		if (!rt_task(rq->curr))
+			return 0;
+
+		period = sched_rt_period(rt_rq);
+		p = rq->curr;
+
+		if (rt_rq->rt_time > period - (period >> 3))
+			printk(KERN_WARNING "RT: Danger!  (%s) is potential runaway.\n", p->comm);
+
+		return 0;
 	}
 
+	raw_spin_unlock(&rt_rq->rt_runtime_lock);
+	more = do_balance_runtime(rt_rq);
+	raw_spin_lock(&rt_rq->rt_runtime_lock);
+
 	return more;
 }
 #else /* !CONFIG_SMP */
