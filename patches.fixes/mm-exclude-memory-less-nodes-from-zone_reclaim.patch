From: Michal Hocko <mhocko@suse.cz>
Subject: mm: exclude memory less nodes from zone_reclaim
Patch-mainline: no, will be different
References: bnc#863526

We had a report about strange OOM killer strikes on a PPC machine
although there was a lot of swap free and a tons of anonymous memory
which could be swapped out. In the end it turned out that the OOM was
a side effect of zone reclaim which wasn't doesn't unmap and swapp out
and so the system was pushed to the OOM. Although this sounds like a bug
somewhere in the kswapd vs. zone reclaim vs. direct reclaim interaction
numactl on the said hardware suggests that the zone reclaim should
have been set in the first place:
node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
node 0 size: 0 MB
node 0 free: 0 MB
node 2 cpus:
node 2 size: 7168 MB
node 2 free: 6019 MB
node distances:
node   0   2
0:  10  40
2:  40  10

So all the CPUs are associated with Node0 which doesn't have any memory
while Node2 contains all the available memory. Node distances cause an
automatic zone_reclaim_mode enabling.

Zone reclaim is intended to keep the allocations local but this doesn't
make any sense on the memory less nodes. So let's exclude such nodes
when the distance is evaluated in build_zonelists.

[jkosina@suse.cz: SLE11-SPx doesn't have zupport for ZONE_MOVABLE yet,
 therefore checking whether the nove has high or regular memory is
 sufficient]

Signed-off-by: Michal Hocko <mhock@suse.cz>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/page_alloc.c |    8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -3150,6 +3150,7 @@ static void build_zonelists(pg_data_t *p
 	int local_node, prev_node;
 	struct zonelist *zonelist;
 	int order = current_zonelist_order;
+	bool memory_less;
 
 	/* initialize zonelists */
 	for (i = 0; i < MAX_ZONELISTS; i++) {
@@ -3163,6 +3164,7 @@ static void build_zonelists(pg_data_t *p
 	load = nr_online_nodes;
 	prev_node = local_node;
 	nodes_clear(used_mask);
+	memory_less = !node_state(local_node, N_HIGH_MEMORY);
 
 	memset(node_order, 0, sizeof(node_order));
 	j = 0;
@@ -3172,9 +3174,11 @@ static void build_zonelists(pg_data_t *p
 
 		/*
 		 * If another node is sufficiently far away then it is better
-		 * to reclaim pages in a zone before going off node.
+		 * to reclaim pages in a zone before going off node but do
+		 * not enable zone_reclaim_mode if the local_node is memory
+		 * less.
 		 */
-		if (distance > RECLAIM_DISTANCE)
+		if (!memory_less && distance > RECLAIM_DISTANCE)
 			zone_reclaim_mode = 1;
 
 		/*
