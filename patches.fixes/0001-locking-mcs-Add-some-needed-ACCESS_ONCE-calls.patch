From ce9ead46f6fcf2d8f761266361045299d9229e9d Mon Sep 17 00:00:00 2001
From: Davidlohr Bueso <dbueso@suse.de>
Date: Wed, 4 Mar 2015 11:10:56 -0800
Subject: [PATCH] locking/mcs: Add some needed ACCESS_ONCE calls
Git-commit: 
Patch-mainline: None, not upstream.
References: 

Both node->locked (osq) and lock->owner (spinning) are entirely
speculative pointers, thus prevent the compiler from seeing
a stale value - wrap for volatile loads around ACCESS_ONCE.

Signed-off-by: Davidlohr Bueso <dbueso@suse.de>

---
 kernel/mutex.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/kernel/mutex.c b/kernel/mutex.c
index fd05060..5a94529 100644
--- a/kernel/mutex.c
+++ b/kernel/mutex.c
@@ -217,7 +217,7 @@ bool osq_lock(struct mutex *mutex, struct optimistic_spin_queue **lock)
 	 * cmpxchg in an attempt to undo our queueing.
 	 */
 
-	while (!node->locked) {
+	while (!ACCESS_ONCE(node->locked)) {
 		/*
 		 * If we need to reschedule bail... so we can block.
 		 */
@@ -316,12 +316,14 @@ void osq_unlock(struct optimistic_spin_queue **lock)
 static inline int mutex_can_spin_on_owner(struct mutex *lock)
 {
 	int retval = 1;
+	struct task_struct *owner;
 
 	if (need_resched())
 		return 0;
 
 	rcu_read_lock();
-	if (lock->owner)
+	owner = ACCESS_ONCE(lock->owner);
+	if (owner)
 		retval = lock->owner->on_cpu;
 	rcu_read_unlock();
 	/*
-- 
2.1.4

