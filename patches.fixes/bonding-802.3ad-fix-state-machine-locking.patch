From: Nils Carlson <nils.carlson@ericsson.com>
Date: Thu, 3 Mar 2011 22:09:11 +0000
Subject: bonding 802.3ad: Fix the state machine locking
References: bnc#672453
Patch-mainline: 2.6.38

Mainline commit: 16d79d7dc98e56d4700054b9b785a92102d8998c

The ad_rx_machine, ad_periodic_machine and ad_port_selection_logic
functions all inspect and alter common fields within the port structure.
Previous to this patch, only the ad_rx_machines were mutexed, and the
periodic and port_selection could run unmutexed against an ad_rx_machine
trigged by an arriving LACPDU.

This patch remedies the situation by protecting all the state machines
from concurrency. This is accomplished by locking around all the state
machines for a given port, which are executed at regular intervals; and
the ad_rx_machine when handling an incoming LACPDU.

Signed-off-by: Nils Carlson <nils.carlson@ericsson.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Jean Delvare <jdelvare@suse.de>
---
 drivers/net/bonding/bond_3ad.c |   16 +++++++++++-----
 1 file changed, 11 insertions(+), 5 deletions(-)

--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@ -1024,9 +1024,6 @@ static void ad_rx_machine(struct lacpdu
 {
 	rx_states_t last_state;
 
-	// Lock to prevent 2 instances of this function to run simultaneously(rx interrupt and periodic machine callback)
-	__get_rx_machine_lock(port);
-
 	// keep current State Machine state to compare later if it was changed
 	last_state = port->sm_rx_state;
 
@@ -1128,7 +1125,6 @@ static void ad_rx_machine(struct lacpdu
 				       "adapter (%s). Check the configuration to verify that all "
 				       "Adapters are connected to 802.3ad compliant switch ports\n",
 				       port->slave->dev->master->name, port->slave->dev->name);
-				__release_rx_machine_lock(port);
 				return;
 			}
 			__update_selected(lacpdu, port);
@@ -1148,7 +1144,6 @@ static void ad_rx_machine(struct lacpdu
 			break;
 		}
 	}
-	__release_rx_machine_lock(port);
 }
 
 /**
@@ -2133,6 +2128,12 @@ void bond_3ad_state_machine_handler(stru
 			goto re_arm;
 		}
 
+		/* Lock around state machines to protect data accessed
+		 * by all (e.g., port->sm_vars).  ad_rx_machine may run
+		 * concurrently due to incoming LACPDU.
+		 */
+		__get_rx_machine_lock(port);
+
 		ad_rx_machine(NULL, port);
 		ad_periodic_machine(port);
 		ad_port_selection_logic(port);
@@ -2143,6 +2144,8 @@ void bond_3ad_state_machine_handler(stru
 		if (port->sm_vars & AD_PORT_BEGIN) {
 			port->sm_vars &= ~AD_PORT_BEGIN;
 		}
+
+		__release_rx_machine_lock(port);
 	}
 
 re_arm:
@@ -2179,7 +2182,10 @@ static void bond_3ad_rx_indication(struc
 		switch (lacpdu->subtype) {
 		case AD_TYPE_LACPDU:
 			pr_debug("Received LACPDU on port %d\n", port->actor_port_number);
+			/* Protect against concurrent state machines */
+			__get_rx_machine_lock(port);
 			ad_rx_machine(lacpdu, port);
+			__release_rx_machine_lock(port);
 			break;
 
 		case AD_TYPE_MARKER:
