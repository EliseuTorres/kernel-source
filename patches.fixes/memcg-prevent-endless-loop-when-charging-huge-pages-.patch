From 19942822df65ee4a47c2e6d6d70cace1b7f01710 Mon Sep 17 00:00:00 2001
From: Johannes Weiner <hannes@cmpxchg.org>
Date: Tue, 1 Feb 2011 15:52:43 -0800
Subject: [PATCH] memcg: prevent endless loop when charging huge pages to near-limit group
Patch-mainline: 19942822df65ee4a47c2e6d6d70cace1b7f01710
References: bnc#704592

Mhocko: 
We already have patches.suse/memcg-unify-charge-uncharge-quantities-to-units-of-pages.patch
which unifies units to nr_pages so I have changed the function signature
accordingly.

Original patch description:
If reclaim after a failed charging was unsuccessful, the limits are
checked again, just in case they settled by means of other tasks.

This is all fine as long as every charge is of size PAGE_SIZE, because in
that case, being below the limit means having at least PAGE_SIZE bytes
available.

But with transparent huge pages, we may end up in an endless loop where
charging and reclaim fail, but we keep going because the limits are not
yet exceeded, although not allowing for a huge page.

Fix this up by explicitely checking for enough room, not just whether we
are within limits.

Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
Acked-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Reviewed-by: Minchan Kim <minchan.kim@gmail.com>
Cc: Balbir Singh <balbir@linux.vnet.ibm.com>
Cc: Daisuke Nishimura <nishimura@mxp.nes.nec.co.jp>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Michal Hocko <mhocko@suse.cz>

---
 include/linux/res_counter.h |   20 ++++++++++++++++++++
 mm/memcontrol.c             |   33 ++++++++++++++++++++++++++-------
 2 files changed, 46 insertions(+), 7 deletions(-)
Index: linux-2.6.32-memcg-backports/include/linux/res_counter.h
===================================================================
--- linux-2.6.32-memcg-backports.orig/include/linux/res_counter.h
+++ linux-2.6.32-memcg-backports/include/linux/res_counter.h
@@ -182,6 +182,26 @@ static inline bool res_counter_check_und
 	return ret;
 }
 
+/**
+ * res_counter_check_margin - check if the counter allows charging
+ * @cnt: the resource counter to check
+ * @bytes: the number of bytes to check the remaining space against
+ *
+ * Returns a boolean value on whether the counter can be charged
+ * @bytes or whether this would exceed the limit.
+ */
+static inline bool res_counter_check_margin(struct res_counter *cnt,
+					    unsigned long bytes)
+{
+	bool ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cnt->lock, flags);
+	ret = cnt->limit - cnt->usage >= bytes;
+	spin_unlock_irqrestore(&cnt->lock, flags);
+	return ret;
+}
+
 static inline bool res_counter_check_within_soft_limit(struct res_counter *cnt)
 {
 	bool ret;
Index: linux-2.6.32-memcg-backports/mm/memcontrol.c
===================================================================
--- linux-2.6.32-memcg-backports.orig/mm/memcontrol.c
+++ linux-2.6.32-memcg-backports/mm/memcontrol.c
@@ -1000,6 +1000,24 @@ static bool mem_cgroup_check_under_limit
 	return false;
 }
 
+/**
+ * mem_cgroup_check_margin - check if the memory cgroup allows charging
+ * @mem: memory cgroup to check
+ * @nr_pages: the number of pages the caller intends to charge
+ *
+ * Returns a boolean value on whether @mem can be charged @nr_pages or
+ * whether this would exceed the limit.
+ */
+static bool mem_cgroup_check_margin(struct mem_cgroup *mem, unsigned long nr_pages)
+{
+	unsigned long bytes = nr_pages << PAGE_SHIFT;
+	if (!res_counter_check_margin(&mem->res, bytes))
+		return false;
+	if (do_swap_account && !res_counter_check_margin(&mem->memsw, bytes))
+		return false;
+	return true;
+}
+
 static unsigned int get_swappiness(struct mem_cgroup *memcg)
 {
 	struct cgroup *cgrp = memcg->css.cgroup;
@@ -1601,18 +1619,19 @@ static int __mem_cgroup_try_charge(struc
 
 		ret = mem_cgroup_hierarchical_reclaim(mem_over_limit, NULL,
 						gfp_mask, flags, NULL);
-		if (ret)
+		if (mem_cgroup_check_margin(mem_over_limit, nr_pages))
 			continue;
 
 		/*
-		 * try_to_free_mem_cgroup_pages() might not give us a full
-		 * picture of reclaim. Some pages are reclaimed and might be
-		 * moved to swap cache or just unmapped from the cgroup.
-		 * Check the limit again to see if the reclaim reduced the
-		 * current usage of the cgroup before giving up
+		 * Even though the limit is exceeded at this point, reclaim
+		 * may have been able to free some pages.  Retry the charge
+		 * before killing the task.
 		 *
+		 * Only for regular pages, though: huge pages are rather
+		 * unlikely to succeed so close to the limit, and we fall back
+		 * to regular pages anyway in case of failure.
 		 */
-		if (mem_cgroup_check_under_limit(mem_over_limit))
+		if (nr_pages == 1 && ret)
 			continue;
 
 		if (!nr_retries--) {
