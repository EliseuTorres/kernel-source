From: Jan Kara <jack@suse.cz>
Subject: writeback: Do not sync data dirtied after sync start
References: bnc#833820
Patch-mainline: No

When there are processes heavily creating small files while sync(2) is running,
it can easily happen that quite some new files are created between WB_SYNC_NONE
and WB_SYNC_ALL pass of sync(2). Because WB_SYNC_ALL pass is slow (e.g. causes
a transaction commit and cache flush for each inode in ext3) it can cause
rather long sync(2) times.

Fix the problem by disregarding inodes dirtied after WB_SYNC_NONE pass has
started in the WB_SYNC_ALL pass. To allow for this, __sync_filesystem() passes
the time stamp when sync started to both syncing works.

Signed-off-by: Jan Kara <jack@suse.cz>

diff -rupX /crypted/home/jack/.kerndiffexclude linux-3.0-SLE11-SP2/fs/fs-writeback.c linux-3.0-SLE11-SP2-1-sync_faster/fs/fs-writeback.c
--- linux-3.0-SLE11-SP2/fs/fs-writeback.c	2013-09-12 18:53:23.689055055 +0200
+++ linux-3.0-SLE11-SP2-1-sync_faster/fs/fs-writeback.c	2013-09-20 14:23:31.622847986 +0200
@@ -35,6 +35,7 @@
 struct wb_writeback_work {
 	long nr_pages;
 	struct super_block *sb;
+	unsigned long start_jif;
 	enum writeback_sync_modes sync_mode;
 	unsigned int tagged_writepages:1;
 	unsigned int for_kupdate:1;
@@ -670,6 +671,7 @@ static long wb_writeback(struct bdi_writ
 		.sync_mode		= work->sync_mode,
 		.tagged_writepages	= work->tagged_writepages,
 		.older_than_this	= NULL,
+		.wb_start		= work->start_jif,
 		.for_kupdate		= work->for_kupdate,
 		.for_background		= work->for_background,
 		.range_cyclic		= work->range_cyclic,
@@ -705,7 +707,8 @@ static long wb_writeback(struct bdi_writ
 	if (wbc.sync_mode == WB_SYNC_ALL || wbc.tagged_writepages)
 		write_chunk = LONG_MAX;
 
-	wbc.wb_start = jiffies; /* livelock avoidance */
+	if (!wbc.wb_start)
+		wbc.wb_start = jiffies; /* livelock avoidance */
 	for (;;) {
 		/*
 		 * Stop writeback when nr_pages has been consumed
@@ -1304,18 +1307,12 @@ int writeback_inodes_sb_nr_if_idle(struc
 }
 EXPORT_SYMBOL(writeback_inodes_sb_nr_if_idle);
 
-/**
- * sync_inodes_sb	-	sync sb inode pages
- * @sb: the superblock
- *
- * This function writes and waits on any dirty inode belonging to this
- * super_block.
- */
-void sync_inodes_sb(struct super_block *sb)
+void sync_inodes_sb_after(struct super_block *sb, unsigned long start)
 {
 	DECLARE_COMPLETION_ONSTACK(done);
 	struct wb_writeback_work work = {
 		.sb		= sb,
+		.start_jif	= start,
 		.sync_mode	= WB_SYNC_ALL,
 		.nr_pages	= LONG_MAX,
 		.range_cyclic	= 0,
@@ -1329,8 +1326,21 @@ void sync_inodes_sb(struct super_block *
 
 	wait_sb_inodes(sb);
 }
+
+/**
+ * sync_inodes_sb	-	sync sb inode pages
+ * @sb: the superblock
+ *
+ * This function writes and waits on any dirty inode belonging to this
+ * super_block.
+ */
+void sync_inodes_sb(struct super_block *sb)
+{
+	sync_inodes_sb_after(sb, jiffies);
+}
 EXPORT_SYMBOL(sync_inodes_sb);
 
+
 /**
  * write_inode_now	-	write an inode to disk
  * @inode: inode to write to disk
diff -rupX /crypted/home/jack/.kerndiffexclude linux-3.0-SLE11-SP2/fs/sync.c linux-3.0-SLE11-SP2-1-sync_faster/fs/sync.c
--- linux-3.0-SLE11-SP2/fs/sync.c	2013-09-12 18:53:22.600053575 +0200
+++ linux-3.0-SLE11-SP2-1-sync_faster/fs/sync.c	2013-09-20 14:30:47.271541418 +0200
@@ -28,7 +28,8 @@
  * wait == 1 case since in that case write_inode() functions do
  * sync_dirty_buffer() and thus effectively write one block at a time.
  */
-static int __sync_filesystem(struct super_block *sb, int wait)
+static int __sync_filesystem(struct super_block *sb, int wait,
+			     unsigned long start)
 {
 	/*
 	 * This should be safe, as we require bdi backing to actually
@@ -41,7 +42,7 @@ static int __sync_filesystem(struct supe
 		sb->s_qcop->quota_sync(sb, -1, wait);
 
 	if (wait)
-		sync_inodes_sb(sb);
+		sync_inodes_sb_after(sb, start);
 	else
 		writeback_inodes_sb(sb);
 
@@ -58,6 +59,7 @@ static int __sync_filesystem(struct supe
 int sync_filesystem(struct super_block *sb)
 {
 	int ret;
+	unsigned long sincejif = jiffies;
 
 	/*
 	 * We need to be protected against the filesystem going from
@@ -71,25 +73,36 @@ int sync_filesystem(struct super_block *
 	if (sb->s_flags & MS_RDONLY)
 		return 0;
 
-	ret = __sync_filesystem(sb, 0);
+	ret = __sync_filesystem(sb, 0, sincejif);
 	if (ret < 0)
 		return ret;
-	return __sync_filesystem(sb, 1);
+	return __sync_filesystem(sb, 1, sincejif);
 }
 EXPORT_SYMBOL_GPL(sync_filesystem);
 
+struct sync_arg {
+	unsigned long sincejif;
+	int wait;
+};
+
 static void sync_one_sb(struct super_block *sb, void *arg)
 {
+	struct sync_arg *sarg = arg;
+
 	if (!(sb->s_flags & MS_RDONLY))
-		__sync_filesystem(sb, *(int *)arg);
+		__sync_filesystem(sb, sarg->wait, sarg->sincejif);
 }
 /*
  * Sync all the data for all the filesystems (called by sys_sync() and
  * emergency sync)
  */
-static void sync_filesystems(int wait)
+static void sync_filesystems(int wait, unsigned long sincejif)
 {
-	iterate_supers(sync_one_sb, &wait);
+	struct sync_arg arg = {
+		.sincejif = sincejif,
+		.wait = wait,
+	};
+	iterate_supers(sync_one_sb, &arg);
 }
 
 /*
@@ -98,9 +111,11 @@ static void sync_filesystems(int wait)
  */
 SYSCALL_DEFINE0(sync)
 {
+	unsigned long sincejif = jiffies;
+
 	wakeup_flusher_threads(0);
-	sync_filesystems(0);
-	sync_filesystems(1);
+	sync_filesystems(0, sincejif);
+	sync_filesystems(1, sincejif);
 	if (unlikely(laptop_mode))
 		laptop_sync_completion();
 	return 0;
@@ -112,8 +127,8 @@ static void do_sync_work(struct work_str
 	 * Sync twice to reduce the possibility we skipped some inodes / pages
 	 * because they were temporarily locked
 	 */
-	sync_filesystems(0);
-	sync_filesystems(0);
+	sync_filesystems(0, jiffies);
+	sync_filesystems(0, jiffies);
 	printk("Emergency Sync complete\n");
 	kfree(work);
 }
diff -rupX /crypted/home/jack/.kerndiffexclude linux-3.0-SLE11-SP2/include/linux/writeback.h linux-3.0-SLE11-SP2-1-sync_faster/include/linux/writeback.h
--- linux-3.0-SLE11-SP2/include/linux/writeback.h	2013-09-12 18:53:23.083054232 +0200
+++ linux-3.0-SLE11-SP2-1-sync_faster/include/linux/writeback.h	2013-09-20 14:31:55.941651394 +0200
@@ -62,6 +62,7 @@ int writeback_inodes_sb_if_idle(struct s
 int writeback_inodes_sb_nr_if_idle(struct super_block *, unsigned long nr);
 int try_to_writeback_inodes_sb_nr(struct super_block *, unsigned long nr);
 void sync_inodes_sb(struct super_block *);
+void sync_inodes_sb_after(struct super_block *, unsigned long);
 void writeback_inodes_wb(struct bdi_writeback *wb,
 		struct writeback_control *wbc);
 long wb_do_writeback(struct bdi_writeback *wb, int force_wait);
