From: Jan Kara <jack@suse.cz>
Subject: writeback: Do not sync data dirtied after sync start
References: bnc#833820
Patch-mainline: No

When there are processes heavily creating small files while sync(2) is running,
it can easily happen that quite some new files are created between WB_SYNC_NONE
and WB_SYNC_ALL pass of sync(2). Because WB_SYNC_ALL pass is slow (e.g. causes
a transaction commit and cache flush for each inode in ext3) it can cause
rather long sync(2) times.

Fix the problem by disregarding inodes dirtied after WB_SYNC_NONE pass has
started in the WB_SYNC_ALL pass. To allow for this, __sync_filesystem() passes
the time stamp when sync started to both syncing works. Things are complicated
a bit more by redirty_tail() updating inode->i_dirtied_when. Thus we have
to keep track when inode was redirtied and allow at least as new inodes
as the latest redirtied ones so that we don't miss any inodes from the syncing
pass.

Signed-off-by: Jan Kara <jack@suse.cz>

Index: linux-3.0-SLE11-SP3/fs/fs-writeback.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/fs/fs-writeback.c
+++ linux-3.0-SLE11-SP3/fs/fs-writeback.c
@@ -35,6 +35,7 @@
 struct wb_writeback_work {
 	long nr_pages;
 	struct super_block *sb;
+	unsigned long start_jif;
 	enum writeback_sync_modes sync_mode;
 	unsigned int tagged_writepages:1;
 	unsigned int for_kupdate:1;
@@ -204,8 +205,10 @@ static void redirty_tail(struct inode *i
 		struct inode *tail;
 
 		tail = wb_inode(wb->b_dirty.next);
-		if (time_before(inode->dirtied_when, tail->dirtied_when))
+		if (time_before(inode->dirtied_when, tail->dirtied_when)) {
+			wb->last_move_tail = jiffies;
 			inode->dirtied_when = jiffies;
+		}
 	}
 	list_move(&inode->i_wb_list, &wb->b_dirty);
 }
@@ -690,6 +693,7 @@ static long wb_writeback(struct bdi_writ
 		.sync_mode		= work->sync_mode,
 		.tagged_writepages	= work->tagged_writepages,
 		.older_than_this	= NULL,
+		.wb_start		= work->start_jif,
 		.for_kupdate		= work->for_kupdate,
 		.for_background		= work->for_background,
 		.range_cyclic		= work->range_cyclic,
@@ -725,7 +729,23 @@ static long wb_writeback(struct bdi_writ
 	if (wbc.sync_mode == WB_SYNC_ALL || wbc.tagged_writepages)
 		write_chunk = LONG_MAX;
 
-	wbc.wb_start = jiffies; /* livelock avoidance */
+	if (!wbc.wb_start)
+		wbc.wb_start = jiffies; /* livelock avoidance */
+	else if (wbc.sync_mode == WB_SYNC_ALL) {
+		/*
+		 * last_move_tail is overflowing? Move it to current
+		 * time.
+		 */
+		if (time_is_after_jiffies(wb->last_move_tail))
+			wb->last_move_tail = jiffies;
+		/*
+		 * If we did redirty_tail() after desired inode start
+		 * time, we have move the start time as well so that
+		 * WB_SYNC_ALL pass doesn't miss any inodes.
+		 */
+		if (time_before(wbc.wb_start, wb->last_move_tail))
+			wbc.wb_start = wb->last_move_tail;
+	}
 	for (;;) {
 		/*
 		 * Stop writeback when nr_pages has been consumed
@@ -1324,18 +1344,12 @@ int writeback_inodes_sb_nr_if_idle(struc
 }
 EXPORT_SYMBOL(writeback_inodes_sb_nr_if_idle);
 
-/**
- * sync_inodes_sb	-	sync sb inode pages
- * @sb: the superblock
- *
- * This function writes and waits on any dirty inode belonging to this
- * super_block.
- */
-void sync_inodes_sb(struct super_block *sb)
+void sync_inodes_sb_after(struct super_block *sb, unsigned long start)
 {
 	DECLARE_COMPLETION_ONSTACK(done);
 	struct wb_writeback_work work = {
 		.sb		= sb,
+		.start_jif	= start,
 		.sync_mode	= WB_SYNC_ALL,
 		.nr_pages	= LONG_MAX,
 		.range_cyclic	= 0,
@@ -1349,8 +1363,21 @@ void sync_inodes_sb(struct super_block *
 
 	wait_sb_inodes(sb);
 }
+
+/**
+ * sync_inodes_sb	-	sync sb inode pages
+ * @sb: the superblock
+ *
+ * This function writes and waits on any dirty inode belonging to this
+ * super_block.
+ */
+void sync_inodes_sb(struct super_block *sb)
+{
+	sync_inodes_sb_after(sb, jiffies);
+}
 EXPORT_SYMBOL(sync_inodes_sb);
 
+
 /**
  * write_inode_now	-	write an inode to disk
  * @inode: inode to write to disk
Index: linux-3.0-SLE11-SP3/fs/sync.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/fs/sync.c
+++ linux-3.0-SLE11-SP3/fs/sync.c
@@ -28,7 +28,8 @@
  * wait == 1 case since in that case write_inode() functions do
  * sync_dirty_buffer() and thus effectively write one block at a time.
  */
-static int __sync_filesystem(struct super_block *sb, int wait)
+static int __sync_filesystem(struct super_block *sb, int wait,
+			     unsigned long start)
 {
 	/*
 	 * This should be safe, as we require bdi backing to actually
@@ -41,7 +42,7 @@ static int __sync_filesystem(struct supe
 		sb->s_qcop->quota_sync(sb, -1, wait);
 
 	if (wait)
-		sync_inodes_sb(sb);
+		sync_inodes_sb_after(sb, start);
 	else
 		writeback_inodes_sb(sb);
 
@@ -58,6 +59,7 @@ static int __sync_filesystem(struct supe
 int sync_filesystem(struct super_block *sb)
 {
 	int ret;
+	unsigned long sincejif = jiffies;
 
 	/*
 	 * We need to be protected against the filesystem going from
@@ -71,25 +73,36 @@ int sync_filesystem(struct super_block *
 	if (sb->s_flags & MS_RDONLY)
 		return 0;
 
-	ret = __sync_filesystem(sb, 0);
+	ret = __sync_filesystem(sb, 0, sincejif);
 	if (ret < 0)
 		return ret;
-	return __sync_filesystem(sb, 1);
+	return __sync_filesystem(sb, 1, sincejif);
 }
 EXPORT_SYMBOL_GPL(sync_filesystem);
 
+struct sync_arg {
+	unsigned long sincejif;
+	int wait;
+};
+
 static void sync_one_sb(struct super_block *sb, void *arg)
 {
+	struct sync_arg *sarg = arg;
+
 	if (!(sb->s_flags & MS_RDONLY))
-		__sync_filesystem(sb, *(int *)arg);
+		__sync_filesystem(sb, sarg->wait, sarg->sincejif);
 }
 /*
  * Sync all the data for all the filesystems (called by sys_sync() and
  * emergency sync)
  */
-static void sync_filesystems(int wait)
+static void sync_filesystems(int wait, unsigned long sincejif)
 {
-	iterate_supers(sync_one_sb, &wait);
+	struct sync_arg arg = {
+		.sincejif = sincejif,
+		.wait = wait,
+	};
+	iterate_supers(sync_one_sb, &arg);
 }
 
 /*
@@ -98,9 +111,11 @@ static void sync_filesystems(int wait)
  */
 SYSCALL_DEFINE0(sync)
 {
+	unsigned long sincejif = jiffies;
+
 	wakeup_flusher_threads(0);
-	sync_filesystems(0);
-	sync_filesystems(1);
+	sync_filesystems(0, sincejif);
+	sync_filesystems(1, sincejif);
 	if (unlikely(laptop_mode))
 		laptop_sync_completion();
 	return 0;
@@ -112,8 +127,8 @@ static void do_sync_work(struct work_str
 	 * Sync twice to reduce the possibility we skipped some inodes / pages
 	 * because they were temporarily locked
 	 */
-	sync_filesystems(0);
-	sync_filesystems(0);
+	sync_filesystems(0, jiffies);
+	sync_filesystems(0, jiffies);
 	printk("Emergency Sync complete\n");
 	kfree(work);
 }
Index: linux-3.0-SLE11-SP3/include/linux/backing-dev.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/include/linux/backing-dev.h
+++ linux-3.0-SLE11-SP3/include/linux/backing-dev.h
@@ -48,8 +48,11 @@ enum bdi_stat_item {
 
 struct bdi_writeback {
 	struct backing_dev_info *bdi;	/* our parent bdi */
-	unsigned int nr;
-
+#ifndef __GENKSYMS__
+	unsigned long last_move_tail;
+#else
+ 	unsigned int nr;
+#endif
 	unsigned long last_old_flush;	/* last old data flush */
 	unsigned long last_active;	/* last time bdi thread was active */
 
Index: linux-3.0-SLE11-SP3/include/linux/writeback.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/include/linux/writeback.h
+++ linux-3.0-SLE11-SP3/include/linux/writeback.h
@@ -62,6 +62,7 @@ int writeback_inodes_sb_if_idle(struct s
 int writeback_inodes_sb_nr_if_idle(struct super_block *, unsigned long nr);
 int try_to_writeback_inodes_sb_nr(struct super_block *, unsigned long nr);
 void sync_inodes_sb(struct super_block *);
+void sync_inodes_sb_after(struct super_block *, unsigned long);
 void writeback_inodes_wb(struct bdi_writeback *wb,
 		struct writeback_control *wbc);
 long wb_do_writeback(struct bdi_writeback *wb, int force_wait);
Index: linux-3.0-SLE11-SP3/mm/backing-dev.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/mm/backing-dev.c
+++ linux-3.0-SLE11-SP3/mm/backing-dev.c
@@ -661,6 +661,7 @@ static void bdi_wb_init(struct bdi_write
 
 	wb->bdi = bdi;
 	wb->last_old_flush = jiffies;
+	wb->last_move_tail = jiffies;
 	INIT_LIST_HEAD(&wb->b_dirty);
 	INIT_LIST_HEAD(&wb->b_io);
 	INIT_LIST_HEAD(&wb->b_more_io);
