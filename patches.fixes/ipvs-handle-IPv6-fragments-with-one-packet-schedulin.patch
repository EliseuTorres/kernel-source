From: Michal Kubecek <mkubecek@suse.cz>
Date: Thu, 13 Mar 2014 13:53:23 +0100
Subject: ipvs: handle IPv6 fragments with one-packet scheduling
Patch-mainline: Never, resolved in a different way
References: bnc#861980

When IPv6 fragments are handled by nf_conntrack, the packet is
reassembled but the original fragments are forwarded on. If IPVS
is configured for one-packet scheduling, we must make sure all
fragments share the same connection so that they are sent to the
same physical server.

To track the connection pointer, use nfct_reasm member of skb.
For replayed fragments, this points to the reassembled packet
but it is unused in the reassembled packet itself. Store the
connection reference into this member which is shared by all
its replayed fragments and clear it again once all fragments are
processed.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/linux/netfilter_ipv6/ip6_tables.h |  1 +
 net/ipv6/netfilter/ip6_tables.c           |  2 ++
 net/netfilter/ipvs/ip_vs_core.c           | 49 +++++++++++++++++++++++++++++++
 3 files changed, 52 insertions(+)

diff --git a/include/linux/netfilter_ipv6/ip6_tables.h b/include/linux/netfilter_ipv6/ip6_tables.h
index 9b7372a..5177a7c 100644
--- a/include/linux/netfilter_ipv6/ip6_tables.h
+++ b/include/linux/netfilter_ipv6/ip6_tables.h
@@ -290,6 +290,7 @@ extern unsigned int ip6t_do_table(struct sk_buff *skb,
 enum {
 	IP6T_FH_F_FRAG	= (1 << 0),
 	IP6T_FH_F_AUTH	= (1 << 1),
+	IP6T_FH_F_FRAG_MORE = (1 << 2)
 };
 
 extern int ip6t_ext_hdr(u8 nexthdr);
diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c
index 115b970..2fb9d17 100644
--- a/net/ipv6/netfilter/ip6_tables.c
+++ b/net/ipv6/netfilter/ip6_tables.c
@@ -2361,6 +2361,8 @@ int ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
 			if (fp == NULL)
 				return -EBADMSG;
 
+			if (flags && ((*fp) & htons(IP6_MF)))
+				*flags |= IP6T_FH_F_FRAG_MORE;
 			_frag_off = ntohs(*fp) & ~0x7;
 			if (_frag_off) {
 				if (target < 0 &&
diff --git a/net/netfilter/ipvs/ip_vs_core.c b/net/netfilter/ipvs/ip_vs_core.c
index a84fa08..989d436 100644
--- a/net/netfilter/ipvs/ip_vs_core.c
+++ b/net/netfilter/ipvs/ip_vs_core.c
@@ -1506,6 +1506,10 @@ ip_vs_in(unsigned int hooknum, struct sk_buff *skb, int af)
 	struct ip_vs_conn *cp;
 	int ret, restart, pkts;
 	struct netns_ipvs *ipvs;
+#ifdef CONFIG_IP_VS_IPV6
+	struct sk_buff *nfct_reasm = skb_is_replayed_fragment(skb) ?
+				     skb_nfct_reasm(skb) : NULL;
+#endif
 
 	/* Already marked as IPVS request or reply? */
 	if (skb->ipvs_property)
@@ -1587,8 +1591,30 @@ ip_vs_in(unsigned int hooknum, struct sk_buff *skb, int af)
 		/* Schedule and create new connection entry into &cp */
 		if (!pp->conn_schedule(af, skb, pd, &v, &cp))
 			return v;
+
+#ifdef CONFIG_IP_VS_IPV6
+		/* If the new connection is for this packet only and this packet
+		 * is the first fragment of a reassembled packet then store the
+		 * connection for the coming replayed fragments
+		 */
+		if (cp && (cp->flags & IP_VS_CONN_F_ONE_PACKET) && nfct_reasm) {
+			/* The reasm packet has no reasm packet so let's use this
+			 * pointer.
+			 */
+			skb_set_ipvs_cp(nfct_reasm, cp);
+		}
+#endif
 	}
 
+#ifdef CONFIG_IP_VS_IPV6
+	/* This is for second fragments of packets with one-packet connections
+	 * For these we read the stored connection from the reasm skb if any
+	 */
+	if (unlikely(!cp) && nfct_reasm && iph.fragoffs &&
+	    skb_nfct_reasm_is_ipvs(nfct_reasm))
+		cp = skb_ipvs_cp(nfct_reasm);
+#endif
+
 	if (unlikely(!cp)) {
 		/* sorry, all this trouble for a no-hit :) */
 		IP_VS_DBG_PKT(12, af, pp, skb, 0,
@@ -1610,6 +1636,11 @@ ip_vs_in(unsigned int hooknum, struct sk_buff *skb, int af)
 	if (cp->dest && !(cp->dest->flags & IP_VS_DEST_F_AVAILABLE)) {
 		/* the destination server is not available */
 
+#ifdef CONFIG_IP_VS_IPV6
+		/* remove reference in the reasm skb to deleted cp if any */
+		if ((cp->flags & IP_VS_CONN_F_ONE_PACKET) && nfct_reasm)
+			skb_set_nfct_reasm(nfct_reasm, NULL);
+#endif
 		if (sysctl_expire_nodest_conn(ipvs)) {
 			/* try to expire the connection immediately */
 			ip_vs_conn_expire_now(cp);
@@ -1673,7 +1704,25 @@ ip_vs_in(unsigned int hooknum, struct sk_buff *skb, int af)
 out:
 	cp->old_state = cp->state;
 
+#ifdef CONFIG_IP_VS_IPV6
+	/* The connection is for this packet only and the packet is fragmented
+	 * and reassembled. We have put the connection pointer in the reasm skb
+	 */
+	if ((cp->flags & IP_VS_CONN_F_ONE_PACKET) && nfct_reasm) {
+		/* If this is the last fragment then we can and should free the
+		 * connection but not earlier
+		 */
+		if (!(iph.flags & IP6T_FH_F_FRAG_MORE)) {
+			skb_set_nfct_reasm(nfct_reasm, NULL);
+			ip_vs_conn_put(cp);
+		}
+	} else {
+		ip_vs_conn_put(cp);
+	}
+#else
 	ip_vs_conn_put(cp);
+#endif
+
 	return ret;
 }
 
-- 
1.8.4.5

