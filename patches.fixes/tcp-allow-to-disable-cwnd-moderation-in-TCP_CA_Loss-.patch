From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 6 Jun 2014 08:14:03 +0200
Subject: tcp: allow to disable cwnd moderation in TCP_CA_Loss state
Patch-mainline: Never, v3.10-rc1 fix not backportable
References: bnc#879921

The logic of tcp_fastretrans_alert() in TCP_CA_Loss is to always
call tcp_moderate_cwnd() to limit packet burst. This means that
if packets are lost, we limit outgoing traffic to (usually)
three packets per roundtrip until all lost packets are
retransmitted and acknowledged. For a "long fat network", this
can substantially limit the throughput and lead to extremely
long recovery (as much as 40 seconds for a full recovery after
a 0.3 s drop has been observed). This moderation was removed in
v3.10-rc1 as part of bigger changes.

Add a sysctl (tcp_bnc879921_hack) to turn the moderation in
TCP_CA_Loss branch of tcp_fastretrans_alert() off with the old
behaviour kept as default.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ip-sysctl.txt | 13 +++++++++++++
 include/net/tcp.h                      |  1 +
 net/ipv4/sysctl_net_ipv4.c             |  7 +++++++
 net/ipv4/tcp_input.c                   |  5 ++++-
 4 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/Documentation/networking/ip-sysctl.txt b/Documentation/networking/ip-sysctl.txt
index 1c911cd..973c0d7 100644
--- a/Documentation/networking/ip-sysctl.txt
+++ b/Documentation/networking/ip-sysctl.txt
@@ -170,6 +170,19 @@ tcp_base_mss - INTEGER
 	Path MTU discovery (MTU probing).  If MTU probing is enabled,
 	this is the initial MSS used by the connection.
 
+tcp_bnc879921_hack - BOOLEAN
+	Disables congestion window moderation when retransmitting lost
+	packets. When set to FALSE (default), cwnd is moderated in TCP_CA_Loss
+	state so that if some packets are lost, transmission is limited to
+	(usually) three packets per roundtrip until all lost packets are
+	retransmitted and acknowledged. In a "long fat network", this can
+	severely throttle the throughput for rather long time: in bnc#879921,
+	a short (0.3 s) drop took up to 40 seconds to recover from. The
+	moderation was removed in 3.10 mainline kernel as part of much bigger
+	change. While the tests show no problems related to cwnd moderation
+	removal, it is sysctl switchable with the original behaviour preserved
+	as default in order to avoid any risk of regressions.
+
 tcp_congestion_control - STRING
 	Set the congestion control algorithm to be used for new
 	connections. The algorithm "reno" is always available, but
diff --git a/include/net/tcp.h b/include/net/tcp.h
index 51a0c2a..4b227c3 100644
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@ -247,6 +247,7 @@ extern int sysctl_tcp_cookie_size;
 extern int sysctl_tcp_thin_linear_timeouts;
 extern int sysctl_tcp_thin_dupack;
 extern int sysctl_tcp_challenge_ack_limit;
+extern int sysctl_tcp_bnc879921_hack;
 
 extern atomic_long_t tcp_memory_allocated;
 extern struct percpu_counter tcp_sockets_allocated;
diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c
index 3a22b1c..d62fa26 100644
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@ -664,6 +664,13 @@ static struct ctl_table ipv4_table[] = {
 		.proc_handler   = proc_dointvec
 	},
 	{
+		.procname	= "tcp_bnc879921_hack",
+		.data		= &sysctl_tcp_bnc879921_hack,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec
+	},
+	{
 		.procname	= "udp_mem",
 		.data		= &sysctl_udp_mem,
 		.maxlen		= sizeof(sysctl_udp_mem),
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 20d4735..d9e2ca5 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -101,6 +101,8 @@ int sysctl_tcp_thin_dupack __read_mostly;
 int sysctl_tcp_moderate_rcvbuf __read_mostly = 1;
 int sysctl_tcp_abc __read_mostly;
 
+int sysctl_tcp_bnc879921_hack __read_mostly = 0;
+
 #define FLAG_DATA		0x01 /* Incoming frame contained data.		*/
 #define FLAG_WIN_UPDATE		0x02 /* Incoming ACK was a window update.	*/
 #define FLAG_DATA_ACKED		0x04 /* This ACK acknowledged new data.		*/
@@ -3068,7 +3070,8 @@ static void tcp_fastretrans_alert(struct sock *sk, int pkts_acked, int flag)
 		if (tcp_is_reno(tp) && flag & FLAG_SND_UNA_ADVANCED)
 			tcp_reset_reno_sack(tp);
 		if (!tcp_try_undo_loss(sk)) {
-			tcp_moderate_cwnd(tp);
+			if (!sysctl_tcp_bnc879921_hack)
+				tcp_moderate_cwnd(tp);
 			tcp_xmit_retransmit_queue(sk);
 			return;
 		}
-- 
1.8.4.5

