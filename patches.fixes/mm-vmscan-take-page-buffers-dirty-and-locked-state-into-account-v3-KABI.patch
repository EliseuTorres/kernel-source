From: Mel Gorman <mgorman@suse.de>
Date: Mon, 10 Jun 2013 11:24:24 +0100
Subject: [PATCH] mm: vmscan: take page buffers dirty and locked state into
 account KABI

References: Limit reclaim in the preserve of IO (bnc#754690)
Patch-mainline: No, expected 3.11

This is a KABI workaround for "mm: vmscan: take page buffers dirty and
locked state into account" that uses aops->writepage to detect if it
is safe to call buffer_check_dirty_writeback() or not.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 fs/block_dev.c     | 3 ++-
 fs/ext3/inode.c    | 5 ++++-
 include/linux/fs.h | 5 ++++-
 mm/vmscan.c        | 9 +++++++--
 4 files changed, 17 insertions(+), 5 deletions(-)

diff --git a/fs/block_dev.c b/fs/block_dev.c
index 9c8ebe4..a738350 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -288,6 +288,8 @@ EXPORT_SYMBOL(thaw_bdev);
 
 static int blkdev_writepage(struct page *page, struct writeback_control *wbc)
 {
+	if (blkdev_aops_writepage != blkdev_writepage)
+		blkdev_aops_writepage = blkdev_writepage;
 	return block_write_full_page(page, blkdev_get_block, wbc);
 }
 
@@ -1583,7 +1585,6 @@ static const struct address_space_operations def_blk_aops = {
 	.writepages	= generic_writepages,
 	.releasepage	= blkdev_releasepage,
 	.direct_IO	= blkdev_direct_IO,
-	.is_dirty_writeback = buffer_check_dirty_writeback,
 };
 
 const struct file_operations def_blk_fops = {
diff --git a/fs/ext3/inode.c b/fs/ext3/inode.c
index 2bd8548..9c5daee 100644
--- a/fs/ext3/inode.c
+++ b/fs/ext3/inode.c
@@ -1619,6 +1619,10 @@ static int ext3_ordered_writepage(struct page *page,
 	int ret = 0;
 	int err;
 
+	/* KABI hack for aops->is_dirty_writepage */
+	if (ext3_aops_writepage != ext3_ordered_writepage)
+		ext3_aops_writepage = ext3_ordered_writepage;
+
 	J_ASSERT(PageLocked(page));
 	/*
 	 * We don't want to warn for emergency remount. The condition is
@@ -1985,7 +1989,6 @@ static const struct address_space_operations ext3_ordered_aops = {
 	.direct_IO		= ext3_direct_IO,
 	.migratepage		= buffer_migrate_page,
 	.is_partially_uptodate  = block_is_partially_uptodate,
-	.is_dirty_writeback	= buffer_check_dirty_writeback,
 	.error_remove_page	= generic_error_remove_page,
 };
 
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 610955f..5a31a29 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -343,6 +343,10 @@ typedef struct {
 typedef int (*read_actor_t)(read_descriptor_t *, struct page *,
 		unsigned long, unsigned long);
 
+/* KABI hack for is_dirty_writepage */
+extern int (*ext3_aops_writepage)(struct page *, struct writeback_control *);
+extern int (*blkdev_aops_writepage)(struct page *, struct writeback_control *);
+
 struct address_space_operations {
 	int (*writepage)(struct page *page, struct writeback_control *wbc);
 	int (*readpage)(struct file *, struct page *);
@@ -381,7 +385,6 @@ struct address_space_operations {
 	int (*launder_page) (struct page *);
 	int (*is_partially_uptodate) (struct page *, read_descriptor_t *,
 					unsigned long);
-	void (*is_dirty_writeback) (struct page *, bool *, bool *);
 	int (*error_remove_page)(struct address_space *, struct page *);
 };
 
diff --git a/mm/vmscan.c b/mm/vmscan.c
index fe73724..344ec65 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -702,6 +702,12 @@ static enum page_references page_check_references(struct page *page,
 	return PAGEREF_RECLAIM;
 }
 
+/* KABI hack for aops->is_dirty_writeback */
+int (*ext3_aops_writepage)(struct page *, struct writeback_control *);
+int (*blkdev_aops_writepage)(struct page *, struct writeback_control *);
+EXPORT_SYMBOL_GPL(ext3_aops_writepage);
+EXPORT_SYMBOL_GPL(blkdev_aops_writepage);
+
 /* Check if a page is dirty or under writeback */
 static void page_check_dirty_writeback(struct page *page,
 				       bool *dirty, bool *writeback)
@@ -727,8 +731,9 @@ static void page_check_dirty_writeback(struct page *page,
 		return;
 
 	mapping = page_mapping(page);
-	if (mapping && mapping->a_ops->is_dirty_writeback)
-		mapping->a_ops->is_dirty_writeback(page, dirty, writeback);
+	if (mapping && (mapping->a_ops->writepage == ext3_aops_writepage ||
+			 mapping->a_ops->writepage == blkdev_aops_writepage))
+		buffer_check_dirty_writeback(page, dirty, writeback);
 }
 
 static noinline_for_stack void free_page_list(struct list_head *free_pages)
