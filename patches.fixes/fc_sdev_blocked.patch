From: Michael Reed <mdr@sgi.com>
Subject: mid-layer unblocks blocked sdev leaving queue stopped
References: bnc#583356
Patch-mainline: Probably 2.6.34 or 2.6.35

The fc_remote_port_delete() will move the sdev state to BLOCKED and stop the
associated request queue. If a scan was initiated prior to the delete call, but
before the some to arrive fc_remote_port_add(), the scan will unconditionally
move the scsi device state to RUNNING, but, as it doesn't use the same
interface to change device state as the fc transport, it fails to restart the
stopped queue. When the fc_remote_port_add() occurs, which would normally move
the device from BLOCKED to RUNNING, the state of the scsi device is already
running and the code to restart the stopped queue is not executed.

Signed-off-by: Michael Reed <mdr@sgi.com>
Acked-by: James Smart <james.smart@emulex.com>
Signed-off-by: Nikanth Karthikesan <knikanth@suse.de>

---

Index: linux-2.6.32-SLE11-SP1/drivers/scsi/scsi_lib.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/scsi/scsi_lib.c
+++ linux-2.6.32-SLE11-SP1/drivers/scsi/scsi_lib.c
@@ -2401,7 +2401,7 @@ EXPORT_SYMBOL(scsi_target_resume);
  *	(which must be a legal transition).  When the device is in this
  *	state, all commands are deferred until the scsi lld reenables
  *	the device with scsi_device_unblock or device_block_tmo fires.
- *	This routine assumes the host_lock is held on entry.
+ *	This routine assumes the host_lock is not held on entry.
  */
 int
 scsi_internal_device_block(struct scsi_device *sdev)
@@ -2445,7 +2445,7 @@ EXPORT_SYMBOL_GPL(scsi_internal_device_b
  *	This routine transitions the device to the SDEV_RUNNING state
  *	(which must be a legal transition) allowing the midlayer to
  *	goose the queue for this device.  This routine assumes the 
- *	host_lock is held upon entry.
+ *	host_lock is not held upon entry.
  */
 int
 scsi_internal_device_unblock(struct scsi_device *sdev)
@@ -2456,15 +2456,23 @@ scsi_internal_device_unblock(struct scsi
 	/* 
 	 * Try to transition the scsi device to SDEV_RUNNING
 	 * and goose the device queue if successful.  
+	 * It's possible that an sdev may be blocked before it is
+	 * completely set up.  scsi_sysfs_add_sdev() and scsi_add_lun()
+	 * will unconditionally attempt to transition the sdev to
+	 * SDEV_RUNNING.  To avoid leaving the queue stopped, we
+	 * allow for the sdev to already be in the SDEV_RUNNING state.
 	 */
+	spin_lock_irqsave(q->queue_lock, flags);
+
 	if (sdev->sdev_state == SDEV_BLOCK)
 		sdev->sdev_state = SDEV_RUNNING;
 	else if (sdev->sdev_state == SDEV_CREATED_BLOCK)
 		sdev->sdev_state = SDEV_CREATED;
-	else
+	else if (sdev->sdev_state != SDEV_RUNNING || !blk_queue_stopped(q)) {
+		spin_unlock_irqrestore(q->queue_lock, flags);
 		return -EINVAL;
+	}
 
-	spin_lock_irqsave(q->queue_lock, flags);
 	blk_start_queue(q);
 	spin_unlock_irqrestore(q->queue_lock, flags);
 
