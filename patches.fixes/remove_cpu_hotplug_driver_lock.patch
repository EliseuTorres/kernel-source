Subject: hotplug, powerpc, x86: Remove cpu_hotplug_driver_lock()
From: Toshi Kani <toshi.kani@hp.com>
Git-commit: 6dedcca610c6d6189b4a54d32118d1654adb73d2
References: bsc#907069
Patch-mainline: v3.13-rc2
    
cpu_hotplug_driver_lock() serializes CPU online/offline operations
when ARCH_CPU_PROBE_RELEASE is set.  This lock interface is no longer
necessary with the following reason:

 - lock_device_hotplug() now protects CPU online/offline operations,
   including the probe & release interfaces enabled by
   ARCH_CPU_PROBE_RELEASE.  The use of cpu_hotplug_driver_lock() is
   redundant.
 - cpu_hotplug_driver_lock() is only valid when ARCH_CPU_PROBE_RELEASE
   is defined, which is misleading and is only enabled on powerpc.

This patch removes the cpu_hotplug_driver_lock() interface.  As
a result, ARCH_CPU_PROBE_RELEASE only enables / disables the cpu
probe & release interface as intended.  There is no functional change
in this patch.

Signed-off-by: Toshi Kani <toshi.kani@hp.com>
Reviewed-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Acked-by: Dinar Valeev <dvaleev@suse.com>

Index: linux-3.12-SLE12/arch/powerpc/kernel/smp.c
===================================================================
--- linux-3.12-SLE12.orig/arch/powerpc/kernel/smp.c
+++ linux-3.12-SLE12/arch/powerpc/kernel/smp.c
@@ -811,18 +811,6 @@ void __cpu_die(unsigned int cpu)
 		smp_ops->cpu_die(cpu);
 }
 
-static DEFINE_MUTEX(powerpc_cpu_hotplug_driver_mutex);
-
-void cpu_hotplug_driver_lock()
-{
-	mutex_lock(&powerpc_cpu_hotplug_driver_mutex);
-}
-
-void cpu_hotplug_driver_unlock()
-{
-	mutex_unlock(&powerpc_cpu_hotplug_driver_mutex);
-}
-
 void cpu_die(void)
 {
 	if (ppc_md.cpu_die)
Index: linux-3.12-SLE12/arch/powerpc/platforms/pseries/dlpar.c
===================================================================
--- linux-3.12-SLE12.orig/arch/powerpc/platforms/pseries/dlpar.c
+++ linux-3.12-SLE12/arch/powerpc/platforms/pseries/dlpar.c
@@ -406,23 +406,19 @@ static ssize_t dlpar_cpu_probe(const cha
 	unsigned long drc_index;
 	int rc;
 
-	cpu_hotplug_driver_lock();
 	rc = strict_strtoul(buf, 0, &drc_index);
 	if (rc) {
-		rc = -EINVAL;
-		goto out;
+		return -EINVAL;
 	}
 
 	parent = of_find_node_by_path("/cpus");
 	if (!parent) {
-		rc = -ENODEV;
-		goto out;
+		return -ENODEV;
 	}
 
 	dn = dlpar_configure_connector(cpu_to_be32(drc_index), parent);
 	if (!dn) {
-		rc = -EINVAL;
-		goto out;
+		return -EINVAL;
 	}
 
 	of_node_put(parent);
@@ -430,22 +426,22 @@ static ssize_t dlpar_cpu_probe(const cha
 	rc = dlpar_acquire_drc(drc_index);
 	if (rc) {
 		dlpar_free_cc_nodes(dn);
-		rc = -EINVAL;
-		goto out;
+		return -EINVAL;
 	}
 
 	rc = dlpar_attach_node(dn);
 	if (rc) {
 		dlpar_release_drc(drc_index);
 		dlpar_free_cc_nodes(dn);
-		goto out;
+		return rc;
 	}
 
 	rc = dlpar_online_cpu(dn);
-out:
-	cpu_hotplug_driver_unlock();
 
-	return rc ? rc : count;
+	if (rc)
+		return rc;
+
+	return count;
 }
 
 static int dlpar_offline_cpu(struct device_node *dn)
@@ -520,30 +516,27 @@ static ssize_t dlpar_cpu_release(const c
 		return -EINVAL;
 	}
 
-	cpu_hotplug_driver_lock();
 	rc = dlpar_offline_cpu(dn);
 	if (rc) {
 		of_node_put(dn);
-		rc = -EINVAL;
-		goto out;
+		return -EINVAL;
 	}
 
 	rc = dlpar_release_drc(drc_index);
 	if (rc) {
 		of_node_put(dn);
-		goto out;
+		return rc;
 	}
 
 	rc = dlpar_detach_node(dn);
 	if (rc) {
 		dlpar_acquire_drc(drc_index);
-		goto out;
+		return rc;
 	}
 
 	of_node_put(dn);
-out:
-	cpu_hotplug_driver_unlock();
-	return rc ? rc : count;
+
+	return rc;
 }
 
 static int __init pseries_dlpar_init(void)
Index: linux-3.12-SLE12/arch/x86/kernel/topology.c
===================================================================
--- linux-3.12-SLE12.orig/arch/x86/kernel/topology.c
+++ linux-3.12-SLE12/arch/x86/kernel/topology.c
@@ -65,8 +65,6 @@ int __ref _debug_hotplug_cpu(int cpu, in
 	if (!cpu_is_hotpluggable(cpu))
 		return -EINVAL;
 
-	cpu_hotplug_driver_lock();
-
 	switch (action) {
 	case 0:
 		ret = cpu_down(cpu);
@@ -87,8 +85,6 @@ int __ref _debug_hotplug_cpu(int cpu, in
 		ret = -EINVAL;
 	}
 
-	cpu_hotplug_driver_unlock();
-
 	return ret;
 }
 
Index: linux-3.12-SLE12/drivers/base/cpu.c
===================================================================
--- linux-3.12-SLE12.orig/drivers/base/cpu.c
+++ linux-3.12-SLE12/drivers/base/cpu.c
@@ -44,13 +44,12 @@ static int __ref cpu_subsys_online(struc
 	struct cpu *cpu = container_of(dev, struct cpu, dev);
 	int cpuid = dev->id;
 	int from_nid, to_nid;
-	int ret = -ENODEV;
 
-	cpu_hotplug_driver_lock();
+	int ret;
 
 	from_nid = cpu_to_node(cpuid);
 	if (from_nid == NUMA_NO_NODE)
-		goto out;
+		return -ENODEV;
 
 	ret = cpu_up(cpuid);
 	/*
@@ -61,19 +60,12 @@ static int __ref cpu_subsys_online(struc
 	if (from_nid != to_nid)
 		change_cpu_under_node(cpu, from_nid, to_nid);
 
- out:
-	cpu_hotplug_driver_unlock();
 	return ret;
 }
 
 static int cpu_subsys_offline(struct device *dev)
 {
-	int ret;
-
-	cpu_hotplug_driver_lock();
-	ret = cpu_down(dev->id);
-	cpu_hotplug_driver_unlock();
-	return ret;
+	return cpu_down(dev->id);
 }
 
 void unregister_cpu(struct cpu *cpu)
Index: linux-3.12-SLE12/include/linux/cpu.h
===================================================================
--- linux-3.12-SLE12.orig/include/linux/cpu.h
+++ linux-3.12-SLE12/include/linux/cpu.h
@@ -185,19 +185,6 @@ extern void cpu_hotplug_enable(void);
 void clear_tasks_mm_cpumask(int cpu);
 int cpu_down(unsigned int cpu);
 
-#ifdef CONFIG_ARCH_CPU_PROBE_RELEASE
-extern void cpu_hotplug_driver_lock(void);
-extern void cpu_hotplug_driver_unlock(void);
-#else
-static inline void cpu_hotplug_driver_lock(void)
-{
-}
-
-static inline void cpu_hotplug_driver_unlock(void)
-{
-}
-#endif
-
 #else		/* CONFIG_HOTPLUG_CPU */
 
 static inline void cpu_hotplug_begin(void) {}
