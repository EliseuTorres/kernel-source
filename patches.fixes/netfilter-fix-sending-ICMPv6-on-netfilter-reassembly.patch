From: Michal Kubecek <mkubecek@suse.cz>
Date: Wed, 10 Oct 2012 19:35:34 +0200
Subject: netfilter: fix sending ICMPv6 on netfilter reassembly timeout
Patch-mainline: Never, upstream solution difficult to backport
References: bnc#773577

Commit "netfilter: send ICMPv6 message on fragment reassembly
timeout" assumes struct netns_frags is embedded into struct net
but this is not true for (standalone) nf_init_frags.

Fix this an easy way by keeping a reference to struct net in
struct nf_ct_frag6_queue. This is not a nice solution but a
proper one would be too intrusive for an LTSS branch.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/inet_frag.h                 |    7 ++--
 net/ipv6/netfilter/nf_conntrack_reasm.c |   59 +++++++++++++++++++++++++------
 2 files changed, 53 insertions(+), 13 deletions(-)

diff --git a/include/net/inet_frag.h b/include/net/inet_frag.h
index 16ff29a..19cc9a5 100644
--- a/include/net/inet_frag.h
+++ b/include/net/inet_frag.h
@@ -65,10 +65,13 @@ struct inet_frag_queue *inet_frag_find(struct netns_frags *nf,
 		struct inet_frags *f, void *key, unsigned int hash)
 	__releases(&f->lock);
 
-static inline void inet_frag_put(struct inet_frag_queue *q, struct inet_frags *f)
+static inline bool inet_frag_put(struct inet_frag_queue *q, struct inet_frags *f)
 {
-	if (atomic_dec_and_test(&q->refcnt))
+	if (atomic_dec_and_test(&q->refcnt)) {
 		inet_frag_destroy(q, f, NULL);
+		return true;
+	}
+	return false;
 }
 
 #endif
diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
index 92d31dc..374fc94 100644
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
@@ -68,6 +68,7 @@ struct nf_ct_frag6_queue
 	struct in6_addr		saddr;
 	struct in6_addr		daddr;
 
+	struct net		*net;
 	int			iif;
 	unsigned int		csum;
 	__u16			nhoffset;
@@ -76,6 +77,15 @@ struct nf_ct_frag6_queue
 static struct inet_frags nf_frags;
 static struct netns_frags nf_init_frags;
 
+struct nf_ct_frag6_arg
+{
+	__be32 id;
+	u32 user;
+	struct net *net;
+	const struct in6_addr *src;
+	const struct in6_addr *dst;
+};
+
 #ifdef CONFIG_SYSCTL
 static struct ctl_table nf_ct_frag6_sysctl_table[] = {
 	{
@@ -119,11 +129,37 @@ static void nf_skb_free(struct sk_buff *skb)
 		kfree_skb(NFCT_FRAG6_CB(skb)->orig);
 }
 
+static int nf_ct_frag6_match(struct inet_frag_queue *q, void *a)
+{
+	struct nf_ct_frag6_queue *fq;
+	struct nf_ct_frag6_arg *arg = a;
+
+	fq = container_of(q, struct nf_ct_frag6_queue, q);
+	return (fq->id == arg->id && fq->user == arg->user &&
+		fq->net == arg->net &&
+		ipv6_addr_equal(&fq->saddr, arg->src) &&
+		ipv6_addr_equal(&fq->daddr, arg->dst));
+}
+
+static void nf_ct_frag6_init_fq(struct inet_frag_queue *q, void *a)
+{
+	struct nf_ct_frag6_queue *fq = container_of(q, struct nf_ct_frag6_queue, q);
+	struct nf_ct_frag6_arg *arg = a;
+
+	fq->id = arg->id;
+	fq->user = arg->user;
+	fq->net = get_net(arg->net);
+	ipv6_addr_copy(&fq->saddr, arg->src);
+	ipv6_addr_copy(&fq->daddr, arg->dst);
+}
+
 /* Destruction primitives. */
 
 static __inline__ void fq_put(struct nf_ct_frag6_queue *fq)
 {
-	inet_frag_put(&fq->q, &nf_frags);
+	struct net *net = fq->net;
+	if (inet_frag_put(&fq->q, &nf_frags))
+		put_net(net);
 }
 
 /* Kill fq entry. It is not destroyed immediately,
@@ -145,7 +181,6 @@ static void nf_ct_frag6_expire(unsigned long data)
 {
 	struct nf_ct_frag6_queue *fq;
 	struct net_device *dev = NULL;
-	struct net *net;
 
 	fq = container_of((struct inet_frag_queue *)data,
 			struct nf_ct_frag6_queue, q);
@@ -156,14 +191,13 @@ static void nf_ct_frag6_expire(unsigned long data)
 		goto out;
 
 	fq_kill(fq);
-	net = container_of(fq->q.net, struct net, ipv6.frags);
-	dev = dev_get_by_index(net, fq->iif);
+	dev = dev_get_by_index(fq->net, fq->iif);
 	if (!dev)
 		goto out;
 
 	rcu_read_lock();
-	IP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMTIMEOUT);
-	IP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);
+	IP6_INC_STATS_BH(fq->net, __in6_dev_get(dev), IPSTATS_MIB_REASMTIMEOUT);
+	IP6_INC_STATS_BH(fq->net, __in6_dev_get(dev), IPSTATS_MIB_REASMFAILS);
 	rcu_read_unlock();
 
 	/* Don't send error if the first segment did not arrive. */
@@ -203,14 +237,16 @@ out:
 /* Creation primitives. */
 
 static __inline__ struct nf_ct_frag6_queue *
-fq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst)
+fq_find(__be32 id, u32 user, struct net_device *dev, struct in6_addr *src, struct
+	in6_addr *dst)
 {
 	struct inet_frag_queue *q;
-	struct ip6_create_arg arg;
+	struct nf_ct_frag6_arg arg;
 	unsigned int hash;
 
 	arg.id = id;
 	arg.user = user;
+	arg.net = dev_net(dev);
 	arg.src = src;
 	arg.dst = dst;
 
@@ -605,7 +641,8 @@ struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)
 	if (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)
 		nf_ct_frag6_evictor();
 
-	fq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr);
+	fq = fq_find(fhdr->identification, user, dev, &hdr->saddr,
+		     &hdr->daddr);
 	if (fq == NULL) {
 		pr_debug("Can't find and can't create new queue\n");
 		goto ret_orig;
@@ -660,11 +697,11 @@ void nf_ct_frag6_output(unsigned int hooknum, struct sk_buff *skb,
 int nf_ct_frag6_init(void)
 {
 	nf_frags.hashfn = nf_hashfn;
-	nf_frags.constructor = ip6_frag_init;
+	nf_frags.constructor = nf_ct_frag6_init_fq;
 	nf_frags.destructor = NULL;
 	nf_frags.skb_free = nf_skb_free;
 	nf_frags.qsize = sizeof(struct nf_ct_frag6_queue);
-	nf_frags.match = ip6_frag_match;
+	nf_frags.match = nf_ct_frag6_match;
 	nf_frags.frag_expire = nf_ct_frag6_expire;
 	nf_frags.secret_interval = 10 * 60 * HZ;
 	nf_init_frags.timeout = IPV6_FRAG_TIMEOUT;
-- 
1.7.10.4

