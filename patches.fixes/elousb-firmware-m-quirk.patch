Date: Thu Sep 2 13:14:21 2010 +0200
From: Libor Pechacek <lpechacek@suse.cz>
Subject: Elo touchscreen firmware M workaround
References: bnc#633593
Patch-mainline: not yet

This patch adds periodic polling of the Elo USB touchscreens. Needed as a
workaround for devices with M-level firmware, otherwise these devices are known
to misbehave (as reported by Elo developers).

Signed-off-by: Libor Pechacek <lpechacek@suse.cz>
Acked-by: Jiri Kosina <jkosina@suse.cz>

Index: linux-2.6.32-SLE11-SP1/drivers/input/touchscreen/elousb.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/input/touchscreen/elousb.c
+++ linux-2.6.32-SLE11-SP1/drivers/input/touchscreen/elousb.c
@@ -31,6 +31,8 @@
 #include <linux/usb/input.h>
 #include <linux/hid.h>
 #include <linux/input.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
 
 /*
  * Version Information
@@ -44,6 +46,19 @@ MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE(DRIVER_LICENSE);
 
+/* timing constants */
+#define PERIODIC_READ_INTERVAL (HZ)
+#define SMARTSET_CMD_TIMEOUT 2000 /* msec */
+
+/* Elo SmartSet commands */
+#define USB_FLUSH_SMARTSET_RESPONSES	0x02 /* Flush all pending smartset responses */
+#define USB_SEND_SMARTSET_COMMAND	0x05 /* Send a smartset command */
+#define USB_GET_SMARTSET_RESPONSE	0x06 /* Get a smartset response */
+#define ELO_DIAG			0x64 /* Diagnostics command */
+#define ELO_SMARTSET_PACKET_SIZE	8
+
+struct workqueue_struct *elo_wq;
+
 struct elousb {
 	char name[128];
 	char phys[64];
@@ -53,6 +68,8 @@ struct elousb {
 
 	unsigned char *data;
 	dma_addr_t data_dma;
+	struct timer_list timer;
+	struct work_struct workaround_work;
 };
 
 static void elousb_irq(struct urb *urb)
@@ -94,6 +111,9 @@ static void elousb_irq(struct urb *urb)
 
 	input_sync(dev);
 
+	if (elo->timer.function)
+		mod_timer(&elo->timer, jiffies + PERIODIC_READ_INTERVAL);
+
 resubmit:
 	status = usb_submit_urb (urb, GFP_ATOMIC);
 	if (status)
@@ -102,6 +122,78 @@ resubmit:
 				elo->usbdev->devpath, status);
 }
 
+/* timer function, schedule the device query to be run in process context */
+static void elousb_timer(unsigned long data)
+{
+	struct elousb *elo = (struct elousb *) data;
+
+	if (!work_pending(&elo->workaround_work))
+		queue_work(elo_wq, &elo->workaround_work);
+}
+
+static int flush_smartset_responses(struct usb_device *dev)
+{
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				USB_FLUSH_SMARTSET_RESPONSES,
+				USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+				0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);
+}
+
+static int smartset_send_get(struct usb_device *dev, __u8 command, void *data)
+{
+	if (command != USB_SEND_SMARTSET_COMMAND && command != USB_GET_SMARTSET_RESPONSE)
+		return -1;
+
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0), command,
+				(command == USB_GET_SMARTSET_RESPONSE ? USB_DIR_IN : USB_DIR_OUT)
+				| USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+				0, 0, data, ELO_SMARTSET_PACKET_SIZE, SMARTSET_CMD_TIMEOUT);
+}
+
+static void workaround_fn(struct work_struct *work)
+{
+	struct elousb *elo = (struct elousb *) container_of(work, struct elousb, workaround_work);
+	struct usb_device *dev = elo->usbdev;
+	unsigned char *buffer;
+	int io_ret;
+
+	if (!(buffer = kzalloc(ELO_SMARTSET_PACKET_SIZE, GFP_KERNEL)))
+		goto fail;
+
+	if ((io_ret = flush_smartset_responses(dev)) < 0) {
+		err("initial FLUSH_SMARTSET_RESPONSES failed, error %d", io_ret);
+		goto fail;
+	}
+
+	/* send Diagnostics command */
+	*buffer = ELO_DIAG;
+	if ((io_ret = smartset_send_get(dev, USB_SEND_SMARTSET_COMMAND, buffer)) < 0) {
+		err("send Diagnostics Command failed, error %d", io_ret);
+		goto fail;
+	}
+
+	/* get the result */
+	if ((io_ret = smartset_send_get(dev, USB_GET_SMARTSET_RESPONSE, buffer)) < 0) {
+		err("get Diagnostics Command response failed, error %d", io_ret);
+		goto fail;
+	}
+
+	/* read the ack */
+	if (*buffer != 'A') {
+		if ((io_ret = smartset_send_get(dev, USB_GET_SMARTSET_RESPONSE, buffer)) < 0) {
+			err("get acknowledge response failed, error %d", io_ret);
+			goto fail;
+		}
+	}
+
+fail:
+	if ((io_ret = flush_smartset_responses(dev)) < 0)
+		err("final FLUSH_SMARTSET_RESPONSES failed, error %d", io_ret);
+	kfree(buffer);
+	mod_timer(&elo->timer, jiffies + PERIODIC_READ_INTERVAL);
+	return;
+}
+
 static int elousb_open(struct input_dev *dev)
 {
 	struct elousb *elo = input_get_drvdata(dev);
@@ -120,6 +212,12 @@ static void elousb_close(struct input_de
 	usb_kill_urb(elo->irq);
 }
 
+/* not all Elo devices need the periodic HID descriptor reads, only
+ * firmware version M needs this */
+static int has_broken_firmware(struct usb_device *dev) {
+	return le16_to_cpu(dev->descriptor.bcdDevice) == 0x10d;
+}
+
 static int elousb_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
 	struct usb_device *dev = interface_to_usbdev(intf);
@@ -242,7 +340,20 @@ static int elousb_probe(struct usb_inter
 	elo->irq->transfer_dma = elo->data_dma;
 	elo->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
-	input_register_device(elo->dev);
+	if (has_broken_firmware(dev)) {
+		printk(KERN_INFO "elousb: broken firmware found, installing workaround\n");
+		INIT_WORK(&elo->workaround_work, &workaround_fn);
+		init_timer(&elo->timer);
+		elo->timer.data = (unsigned long) elo;
+		elo->timer.function = elousb_timer;
+		elo->timer.expires = jiffies + PERIODIC_READ_INTERVAL;
+		add_timer(&elo->timer);
+	}
+
+	if (input_register_device(elo->dev)) {
+		printk(KERN_ERR "elousb: failed to register input device\n");
+		goto fail4;
+	}
 
 	usb_set_intfdata(intf, elo);
 	return 0;
@@ -269,6 +380,10 @@ static void elousb_disconnect(struct usb
 		input_unregister_device(elo->dev);
 		usb_free_urb(elo->irq);
 		usb_buffer_free(interface_to_usbdev(intf), 8, elo->data, elo->data_dma);
+		if (elo->timer.function) {
+			del_timer_sync(&elo->timer);
+			flush_work(&elo->workaround_work);
+		}
 		kfree(elo);
 	}
 }
@@ -290,7 +405,10 @@ static struct usb_driver elousb_driver =
 
 static int __init elousb_init(void)
 {
-	int retval = usb_register(&elousb_driver);
+	int retval;
+	if (!(elo_wq = create_singlethread_workqueue("elousb")))
+		return -ENOMEM;
+	retval = usb_register(&elousb_driver);
 	if (retval == 0)
 		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":" DRIVER_DESC);
 	return retval;
@@ -299,6 +417,7 @@ static int __init elousb_init(void)
 static void __exit elousb_exit(void)
 {
 	usb_deregister(&elousb_driver);
+	destroy_workqueue(elo_wq);
 }
 
 module_init(elousb_init);
