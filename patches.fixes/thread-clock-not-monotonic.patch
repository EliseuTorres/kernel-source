From: NeilBrown <neilb@suse.de>
Subject: Don't allow scheduler time to go backwards.
References: bnc#880357
Patch-mainline: 3.13

Most places that calculate a delta and then add it to current runtime
check that the delta isn't negative.
update_curr doesn't

To be safe, we need to make delta_exec a u64 to not get false negatives.
All places that delta_exec is used expect a u64 anyway.

Patch is based on 

commit 9dbdb155532395ba000c5d5d187658b0e17e529f
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Nov 18 18:27:06 2013 +0100

    sched/fair: Rework sched_fair time accounting


 From 3.13.

Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: Mike Galbraith <mgalbraith@suse.com>
---
 kernel/sched_fair.c |   12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

--- linux-3.0-SLE11-SP3.orig/kernel/sched_fair.c
+++ linux-3.0-SLE11-SP3/kernel/sched_fair.c
@@ -560,12 +560,12 @@ static void update_cfs_shares(struct cfs
  */
 static inline void
 __update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,
-	      unsigned long delta_exec)
+	      u64 delta_exec)
 {
-	unsigned long delta_exec_weighted;
+	u64 delta_exec_weighted;
 
 	schedstat_set(curr->statistics.exec_max,
-		      max((u64)delta_exec, curr->statistics.exec_max));
+		      max(delta_exec, curr->statistics.exec_max));
 
 	curr->sum_exec_runtime += delta_exec;
 	schedstat_add(cfs_rq, exec_clock, delta_exec);
@@ -583,7 +583,7 @@ static void update_curr(struct cfs_rq *c
 {
 	struct sched_entity *curr = cfs_rq->curr;
 	u64 now = rq_of(cfs_rq)->clock_task;
-	unsigned long delta_exec;
+	u64 delta_exec;
 
 	if (unlikely(!curr))
 		return;
@@ -593,8 +593,8 @@ static void update_curr(struct cfs_rq *c
 	 * since the last time we changed load (this cannot
 	 * overflow on 32 bits):
 	 */
-	delta_exec = (unsigned long)(now - curr->exec_start);
-	if (!delta_exec)
+	delta_exec = now - curr->exec_start;
+	if (unlikely((s64)delta_exec <= 0))
 		return;
 
 	__update_curr(cfs_rq, curr, delta_exec);
