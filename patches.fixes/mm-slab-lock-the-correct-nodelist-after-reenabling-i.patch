From 51cd8e6ff265650e35e46b5bcbe2ee381a7a2877 Mon Sep 17 00:00:00 2001
From: David Rientjes <rientjes@google.com>
Date: Tue, 28 Aug 2012 19:57:21 -0700
Subject: [PATCH] mm, slab: lock the correct nodelist after reenabling irqs
Git-commit: 51cd8e6ff265650e35e46b5bcbe2ee381a7a2877
Patch-mainline: 3.6-rc4
References: bnc#926439

mhocko@suse.cz:
Although we have !CONFIG_PREEMPT so enable IRQ & disable IRQ cannot change to
local CPU (thus Node) cache_grow is calling into the page allocator with __GFP_WAIT
when enabling interrupts and so it might schedule and end up on a different CPU
and node.

cache_grow() can reenable irqs so the cpu (and node) can change, so ensure
that we take list_lock on the correct nodelist.

This fixes an issue with commit 072bb0aa5e06 ("mm: sl[au]b: add
knowledge of PFMEMALLOC reserve pages") where list_lock for the wrong
node was taken after growing the cache.

Reported-and-tested-by: Haggai Eran <haggaie@mellanox.com>
Signed-off-by: David Rientjes <rientjes@google.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Michal Hocko <mhocko@suse.cz>

---
 mm/slab.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/mm/slab.c b/mm/slab.c
index f8b0d539b482..811af03a14ef 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -3260,6 +3260,7 @@ force_grow:
 
 		/* cache_grow can reenable interrupts, then ac could change. */
 		ac = cpu_cache_get(cachep);
+		node = numa_mem_id();
 
 		/* no objects in sight? abort */
 		if (!x && (ac->avail == 0 || force_refill))
-- 
1.8.5.6

