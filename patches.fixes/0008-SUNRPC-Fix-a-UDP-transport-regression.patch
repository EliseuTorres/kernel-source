Git-commit: f39c1bfb5a03e2d255451bff05be0d7255298fa4
From: Trond Myklebust <Trond.Myklebust@netapp.com>
Date: Fri, 7 Sep 2012 11:08:50 -0400
Subject: [PATCH] SUNRPC: Fix a UDP transport regression
Patch-mainline: v3.6
References: bnc#800907

Commit 43cedbf0e8dfb9c5610eb7985d5f21263e313802 (SUNRPC: Ensure that
we grab the XPRT_LOCK before calling xprt_alloc_slot) is causing
hangs in the case of NFS over UDP mounts.

Since neither the UDP or the RDMA transport mechanism use dynamic slot
allocation, we can skip grabbing the socket lock for those transports.
Add a new rpc_xprt_op to allow switching between the TCP and UDP/RDMA
case.

Note that the NFSv4.1 back channel assigns the slot directly
through rpc_run_bc_task, so we can ignore that case.

Reported-by: Dick Streefland <dick.streefland@altium.nl>
Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Cc: stable@vger.kernel.org [>= 3.1]
Acked-by: NeilBrown <neilb@suse.de>

---
 net/sunrpc/xprt.c     |   37 ++++++++++++++++++++++---------------
 net/sunrpc/xprtsock.c |    2 +-
 2 files changed, 23 insertions(+), 16 deletions(-)

--- linux-3.0-SLE11-SP2.orig/net/sunrpc/xprt.c
+++ linux-3.0-SLE11-SP2/net/sunrpc/xprt.c
@@ -957,21 +957,36 @@ void xprt_transmit(struct rpc_task *task
 	spin_unlock_bh(&xprt->transport_lock);
 }
 
-static void xprt_alloc_slot(struct rpc_task *task)
+static void xprt_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task)
 {
-	struct rpc_xprt	*xprt = task->tk_xprt;
 
 	task->tk_status = 0;
+	spin_lock(&xprt->reserve_lock);
 	if (!list_empty(&xprt->free)) {
 		struct rpc_rqst	*req = list_entry(xprt->free.next, struct rpc_rqst, rq_list);
 		list_del_init(&req->rq_list);
 		task->tk_rqstp = req;
 		xprt_request_init(task, xprt);
+		spin_unlock(&xprt->reserve_lock);
 		return;
 	}
 	dprintk("RPC:       waiting for request slot\n");
 	task->tk_status = -EAGAIN;
 	rpc_sleep_on(&xprt->backlog, task, NULL);
+	spin_unlock(&xprt->reserve_lock);
+}
+
+static void xprt_lock_and_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task)
+{
+	/* Note: grabbing the xprt_lock_write() ensures that we throttle
+	 * new slot allocation if the transport is congested (i.e. when
+	 * reconnecting a stream transport or when out of socket write
+	 * buffer space).
+	 */
+	if (xprt_lock_write(xprt, task)) {
+		xprt_alloc_slot(xprt, task);
+		xprt_release_write(xprt, task);
+	}
 }
 
 static void xprt_free_slot(struct rpc_xprt *xprt, struct rpc_rqst *req)
@@ -1023,6 +1038,7 @@ EXPORT_SYMBOL_GPL(xprt_free);
  * If no more slots are available, place the task on the transport's
  * backlog queue.
  */
+extern struct rpc_xprt_ops xs_tcp_ops;
 void xprt_reserve(struct rpc_task *task)
 {
 	struct rpc_xprt	*xprt = task->tk_xprt;
@@ -1031,21 +1047,12 @@ void xprt_reserve(struct rpc_task *task)
 	if (task->tk_rqstp != NULL)
 		return;
 
-	/* Note: grabbing the xprt_lock_write() here is not strictly needed,
-	 * but ensures that we throttle new slot allocation if the transport
-	 * is congested (e.g. if reconnecting or if we're out of socket
-	 * write buffer space).
-	 */
 	task->tk_timeout = 0;
 	task->tk_status = -EAGAIN;
-	if (!xprt_lock_write(xprt, task))
-		return;
-
-	task->tk_status = -EIO;
-	spin_lock(&xprt->reserve_lock);
-	xprt_alloc_slot(task);
-	spin_unlock(&xprt->reserve_lock);
-	xprt_release_write(xprt, task);
+	if (xprt->ops == &xs_tcp_ops)
+		xprt_lock_and_alloc_slot(xprt, task);
+	else
+		xprt_alloc_slot(xprt, task);
 }
 
 static inline __be32 xprt_alloc_xid(struct rpc_xprt *xprt)
--- linux-3.0-SLE11-SP2.orig/net/sunrpc/xprtsock.c
+++ linux-3.0-SLE11-SP2/net/sunrpc/xprtsock.c
@@ -2470,7 +2470,7 @@ static struct rpc_xprt_ops xs_udp_ops =
 	.print_stats		= xs_udp_print_stats,
 };
 
-static struct rpc_xprt_ops xs_tcp_ops = {
+struct rpc_xprt_ops xs_tcp_ops = {
 	.reserve_xprt		= xprt_reserve_xprt,
 	.release_xprt		= xs_tcp_release_xprt,
 	.rpcbind		= rpcb_getport_async,
