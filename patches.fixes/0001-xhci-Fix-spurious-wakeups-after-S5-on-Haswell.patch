From 37d8f22808db9b38b68af7324d0b7798c225b1bd Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Tue, 10 Sep 2013 07:49:04 +0200
Subject: [PATCH v2] xhci: Fix spurious wakeups after S5 on Haswell
Patch-mainline: Submitted
References: bnc#833097

Haswell LynxPoint and LynxPoint-LP with the recent Intel BIOS show
mysterious wakeups after shutdown occasionally.  After discussing with
BIOS engineers, they explained that the new BIOS expects that the
wakeup sources are cleared and set to D3 for all wakeup devices when
the system is going to sleep or power off, but the current xhci driver
doesn't do this properly (partly intentionally).

This patch introduces a new quirk, XHCI_HSW_SPURIOUS_WAKEUP, for
fixing the spurious wakeups at S5 by calling xhci_stop() instead of
its stripped version in the xhci shutdown ops, and setting the device
to PCI D3 at shutdown and remove ops.

The PCI D3 call is based on the initial fix patch by Oliver Neukum.

Cc: Oliver Neukum <oneukum@suse.de>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
v1->v2: forgot to refresh the patch before submission, sorry.

 drivers/usb/host/xhci-pci.c |   14 ++++++++++++++
 drivers/usb/host/xhci.c     |   20 +++++++++++++-------
 drivers/usb/host/xhci.h     |    1 +
 include/linux/pci_ids.h     |    2 ++
 4 files changed, 30 insertions(+), 7 deletions(-)

--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -111,6 +111,15 @@ static void xhci_pci_quirks(struct devic
 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
 		xhci->quirks |= XHCI_AVOID_BEI;
 	}
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+	    (pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI ||
+	     pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI)) {
+		/* Workaround for occasional spurious wakeups from S5 (or
+		 * any other sleep) on Haswell machines with LPT and LPT-LP
+		 * with the new Intel BIOS
+		 */
+		xhci->quirks |= XHCI_HSW_SPURIOUS_WAKEUP;
+	}
 	if (pdev->vendor == PCI_VENDOR_ID_ETRON &&
 			pdev->device == PCI_DEVICE_ID_ASROCK_P67) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
@@ -217,6 +226,11 @@ static void xhci_pci_remove(struct pci_d
 		usb_put_hcd(xhci->shared_hcd);
 	}
 	usb_hcd_pci_remove(dev);
+
+	/* Workaround for spurious wakeups at shutdown with HSW */
+	if (xhci->quirks & XHCI_HSW_SPURIOUS_WAKEUP)
+		pci_set_power_state(dev, PCI_D3cold);
+
 	kfree(xhci);
 }
 
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -762,13 +762,19 @@ void xhci_shutdown(struct usb_hcd *hcd)
 	if (xhci->quirks & XHCI_SPURIOUS_REBOOT)
 		usb_disable_xhci_ports(pdev);
 
-	spin_lock_irq(&xhci->lock);
-	xhci_halt(xhci);
-	spin_unlock_irq(&xhci->lock);
-
-	xhci_cleanup_msix(xhci);
-
-	pci_set_power_state(pdev, PCI_D3cold);
+	if (xhci->quirks & XHCI_HSW_SPURIOUS_WAKEUP) {
+		/* Workaround for spurious wakeups at shutdown with HSW:
+		 * we must call xhci_stop() for clearing all wakeups, and
+		 * set the device to D3.
+		 */
+		xhci_stop(hcd);
+		pci_set_power_state(pdev, PCI_D3cold);
+	} else {
+		spin_lock_irq(&xhci->lock);
+		xhci_halt(xhci);
+		spin_unlock_irq(&xhci->lock);
+		xhci_cleanup_msix(xhci);
+	}
 
 	xhci_dbg(xhci, "xhci_shutdown completed - status = %x\n",
 		    xhci_readl(xhci, &xhci->op_regs->status));
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1505,6 +1505,7 @@ struct xhci_hcd {
 #define XHCI_SPURIOUS_REBOOT	(1 << 13)
 #define XHCI_COMP_MODE_QUIRK	(1 << 14)
 #define XHCI_AVOID_BEI		(1 << 15)
+#define XHCI_HSW_SPURIOUS_WAKEUP (1 << 17)
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2777,7 +2777,9 @@
 #define PCI_DEVICE_ID_INTEL_82454NX     0x84cb
 #define PCI_DEVICE_ID_INTEL_84460GX	0x84ea
 #define PCI_DEVICE_ID_INTEL_IXP4XX	0x8500
+#define PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI	0x8c31
 #define PCI_DEVICE_ID_INTEL_IXP2800	0x9004
+#define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
 #define PCI_DEVICE_ID_INTEL_S21152BB	0xb152
 
 #define PCI_VENDOR_ID_SCALEMP		0x8686
