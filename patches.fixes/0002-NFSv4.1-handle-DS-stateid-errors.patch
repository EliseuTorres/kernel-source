From: Andy Adamson <andros@netapp.com>
Date: Wed, 7 Mar 2012 10:49:41 -0500
Subject: [PATCH] NFSv4.1 handle DS stateid errors
Git-commit: 9cb8196839ab4ec87710526e9c43ac7f5dba69d3
Patch-mainline: v3.4
References: bnc#864401

Handle DS READ and WRITE stateid errors by recovering the stateid on the MDS.

NFS4ERR_OLD_STATEID is ignored as the client always sends a
state sequenceid of zero for DS READ and WRITE stateids.

Signed-off-by: Andy Adamson <andros@netapp.com>
Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/nfs/delegation.c     |    1 +
 fs/nfs/nfs4filelayout.c |   29 ++++++++++++++++++++++++++++-
 fs/nfs/nfs4state.c      |    2 ++
 3 files changed, 31 insertions(+), 1 deletion(-)

--- linux-3.0-SLE11-SP3.orig/fs/nfs/delegation.c
+++ linux-3.0-SLE11-SP3/fs/nfs/delegation.c
@@ -548,6 +548,7 @@ void nfs_remove_bad_delegation(struct in
 		nfs_free_delegation(delegation);
 	}
 }
+EXPORT_SYMBOL_GPL(nfs_remove_bad_delegation);
 
 /**
  * nfs_expire_all_delegation_types
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4filelayout.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4filelayout.c
@@ -33,6 +33,7 @@
 #include <linux/nfs_page.h>
 
 #include "internal.h"
+#include "delegation.h"
 #include "nfs4filelayout.h"
 
 #define NFSDBG_FACILITY         NFSDBG_PNFS_LD
@@ -95,12 +96,31 @@ static int filelayout_async_handle_error
 					 struct nfs_client *clp,
 					 int *reset)
 {
+	struct nfs_server *mds_server = NFS_SERVER(state->inode);
+	struct nfs_client *mds_client = mds_server->nfs_client;
+
 	if (task->tk_status >= 0)
 		return 0;
-
 	*reset = 0;
 
 	switch (task->tk_status) {
+	/* MDS state errors */
+	case -NFS4ERR_DELEG_REVOKED:
+	case -NFS4ERR_ADMIN_REVOKED:
+	case -NFS4ERR_BAD_STATEID:
+		if (state != NULL)
+			nfs_remove_bad_delegation(state->inode);
+	case -NFS4ERR_OPENMODE:
+		if (state == NULL)
+			break;
+		nfs4_schedule_stateid_recovery(mds_server, state);
+		goto wait_on_recovery;
+	case -NFS4ERR_EXPIRED:
+		if (state != NULL)
+			nfs4_schedule_stateid_recovery(mds_server, state);
+		nfs4_schedule_lease_recovery(mds_client);
+		goto wait_on_recovery;
+	/* DS session errors */
 	case -NFS4ERR_BADSESSION:
 	case -NFS4ERR_BADSLOT:
 	case -NFS4ERR_BAD_HIGH_SLOT:
@@ -126,8 +146,15 @@ static int filelayout_async_handle_error
 		*reset = 1;
 		break;
 	}
+out:
 	task->tk_status = 0;
 	return -EAGAIN;
+wait_on_recovery:
+	rpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);
+	if (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)
+		rpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);
+	goto out;
+
 }
 
 /* NFS_PROTO call done callback routines */
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4state.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4state.c
@@ -1070,6 +1070,7 @@ static void nfs4_clear_state_manager_bit
 	wake_up_bit(&clp->cl_state, NFS4CLNT_MANAGER_RUNNING);
 	rpc_wake_up(&clp->cl_rpcwaitq);
 }
+EXPORT_SYMBOL_GPL(nfs4_schedule_lease_recovery);
 
 /*
  * Schedule the nfs_client asynchronous state management routine
@@ -1134,6 +1135,7 @@ void nfs4_schedule_stateid_recovery(cons
 	nfs4_state_mark_reclaim_nograce(clp, state);
 	nfs4_schedule_state_manager(clp);
 }
+EXPORT_SYMBOL_GPL(nfs4_schedule_stateid_recovery);
 
 void nfs_inode_find_state_and_recover(struct inode *inode,
 		const nfs4_stateid *stateid)
