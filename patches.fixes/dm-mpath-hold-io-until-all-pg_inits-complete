From: Kiyoshi Ueda <k-ueda@ct.jp.nec.com>
Date: Sat, 6 Mar 2010 02:30:02 +0000 (+0000)
Subject: dm mpath: hold io until all pg_inits completed
References: bnc#668483
Patch-mainline: v2.6.34-rc1~24^2~9
Git-Commit: d0259bf0eefc503d3c9c9ccda35033c3dd3aac30

dm mpath: hold io until all pg_inits completed

m->queue_io is set to block processing I/Os, and it needs to be kept
while pg-init, which issues multiple path activations, is in progress.
But m->queue is cleared when a path activation completes without error
in pg_init_done(), even while other path activations are in progress.
That may cause undesired -EIO on paths which are not complete activation.

This patch fixes that by not clearing m->queue_io until all path
activations complete.

(Before the hardware handlers were moved into the SCSI layer, pg_init
only used one path.)

Signed-off-by: Kiyoshi Ueda <k-ueda@ct.jp.nec.com>
Signed-off-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
Signed-off-by: Alasdair G Kergon <agk@redhat.com>

Acked-by: Hannes Reinecke <hare@suse.de>
Acked-by: Ankit Jain <jankit@suse.de>
---
 drivers/md/dm-mpath.c |   17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

Index: b/drivers/md/dm-mpath.c
===================================================================
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -1242,14 +1242,19 @@ static void pg_init_done(void *data, int
 			m->current_pgpath = NULL;
 			m->current_pg = NULL;
 		}
-	} else if (!m->pg_init_required) {
-		m->queue_io = 0;
+	} else if (!m->pg_init_required)
 		pg->bypassed = 0;
-	}
 
-	m->pg_init_in_progress--;
-	if (!m->pg_init_in_progress)
-		queue_work(kmultipathd, &m->process_queued_ios);
+	if (--m->pg_init_in_progress)
+		/* Activations of other paths are still on going */
+		goto out;
+
+	if (!m->pg_init_required)
+		m->queue_io = 0;
+
+	queue_work(kmultipathd, &m->process_queued_ios);
+
+out:
 	spin_unlock_irqrestore(&m->lock, flags);
 }
 
