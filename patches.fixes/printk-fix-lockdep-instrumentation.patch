From: Jan Kara <jack@suse.cz>
Subject: printk: fix lockdep instrumentation of console_sem
Patch-mainline: Submitted, expected 3.15, currently in mmotm

Printk calls mutex_acquire() / mutex_release() by hand to instrument
lockdep about console_sem.  However in some corner cases the
instrumentation is missing.  Fix the problem by creating helper functions
for locking / unlocking console_sem which take care of lockdep
instrumentation as well.

Signed-off-by: Jan Kara <jack@suse.cz>
Reported-by: Fabio Estevam <festevam@gmail.com>
Reported-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Tested-by: Fabio Estevam <fabio.estevam@freescale.com>
Tested-By: Valdis Kletnieks <valdis.kletnieks@vt.edu>
Cc: Steven Rostedt <rostedt@goodmis.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Ingo Molnar <mingo@kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

diff -rupX /crypted/home/jack/.kerndiffexclude linux-3.12-SLE12/kernel/printk/printk.c linux-3.12-SLE12-printk_lockdep/kernel/printk/printk.c
--- linux-3.12-SLE12/kernel/printk/printk.c	2014-05-22 19:30:51.195028435 +0200
+++ linux-3.12-SLE12-printk_lockdep/kernel/printk/printk.c	2014-05-30 15:30:42.095771009 +0200
@@ -120,6 +120,29 @@ static struct lockdep_map console_lock_d
 #endif
 
 /*
+ * Helper macros to handle lockdep when locking/unlocking console_sem. We use
+ * macros instead of functions so that _RET_IP_ contains useful information.
+ */
+#define down_console_sem() do { \
+	down(&console_sem);\
+	mutex_acquire(&console_lock_dep_map, 0, 0, _RET_IP_);\
+} while (0)
+
+static int __down_trylock_console_sem(unsigned long ip)
+{
+	if (down_trylock(&console_sem))
+		return 1;
+	mutex_acquire(&console_lock_dep_map, 0, 1, ip);
+	return 0;
+}
+#define down_trylock_console_sem() __down_trylock_console_sem(_RET_IP_)
+
+#define up_console_sem() do { \
+	mutex_release(&console_lock_dep_map, 1, _RET_IP_);\
+	up(&console_sem);\
+} while (0)
+
+/*
  * This is used for debugging the mess that is the VT code by
  * keeping track if we have the console semaphore held. It's
  * definitely not the perfect debug tool (we don't know if _WE_
@@ -1402,7 +1425,7 @@ static int console_trylock_for_printk(vo
 	 */
 	if (!can_use_console(cpu)) {
 		console_locked = 0;
-		up(&console_sem);
+		up_console_sem();
 		return 0;
 	}
 	return 1;
@@ -1941,14 +1964,14 @@ void suspend_console(void)
 	printk("Suspending console(s) (use no_console_suspend to debug)\n");
 	console_lock();
 	console_suspended = 1;
-	up(&console_sem);
+	up_console_sem();
 }
 
 void resume_console(void)
 {
 	if (!console_suspend_enabled)
 		return;
-	down(&console_sem);
+	down_console_sem();
 	console_suspended = 0;
 	console_unlock();
 }
@@ -1990,13 +2013,12 @@ void console_lock(void)
 {
 	might_sleep();
 
-	down(&console_sem);
+	down_console_sem();
 	if (console_suspended)
 		return;
 	console_locked = 1;
 	printk_handover_state = 0;
 	console_may_schedule = 1;
-	mutex_acquire(&console_lock_dep_map, 0, 0, _RET_IP_);
 }
 EXPORT_SYMBOL(console_lock);
 
@@ -2010,16 +2032,15 @@ EXPORT_SYMBOL(console_lock);
  */
 int console_trylock(void)
 {
-	if (down_trylock(&console_sem))
+	if (down_trylock_console_sem())
 		return 0;
 	if (console_suspended) {
-		up(&console_sem);
+		up_console_sem();
 		return 0;
 	}
 	console_locked = 1;
 	printk_handover_state = 0;
 	console_may_schedule = 0;
-	mutex_acquire(&console_lock_dep_map, 0, 1, _RET_IP_);
 	return 1;
 }
 EXPORT_SYMBOL(console_trylock);
@@ -2038,7 +2059,7 @@ static int console_lock_try_spin(void)
 	/* Someone already spinning? Don't waste cpu time... */
 	if (test_and_set_bit(PRINTK_CONSOLE_SPIN_B, &printk_handover_state))
 		return 0;
-	while (down_trylock(&console_sem)) {
+	while (down_trylock_console_sem()) {
 		/* Someone else took console_sem? */
 		if (!test_bit(PRINTK_CONSOLE_SPIN_B, &printk_handover_state))
 			return 0;
@@ -2046,12 +2067,11 @@ static int console_lock_try_spin(void)
 	}
 	printk_handover_state = 0;
 	if (console_suspended) {
-		up(&console_sem);
+		up_console_sem();
 		return 0;
 	}
 	console_locked = 1;
 	console_may_schedule = 0;
-	mutex_acquire(&console_lock_dep_map, 0, 0, _RET_IP_);
 	return 1;
 }
 
@@ -2143,7 +2163,7 @@ void console_unlock(void)
 	int printed_chars = 0;
 
 	if (console_suspended) {
-		up(&console_sem);
+		up_console_sem();
 		return;
 	}
 
@@ -2221,8 +2241,7 @@ skip:
 	if (test_bit(PRINTK_HANDOVER_B, &printk_handover_state))
 		clear_bit(PRINTK_HANDOVER_B, &printk_handover_state);
 	console_locked = 0;
-	mutex_release(&console_lock_dep_map, 1, _RET_IP_);
-	up(&console_sem);
+	up_console_sem();
 
 	/*
 	 * Subtlety: We have interrupts disabled iff hand_over == false (to
@@ -2273,7 +2292,7 @@ void console_unblank(void)
 	 * oops_in_progress is set to 1..
 	 */
 	if (oops_in_progress) {
-		if (down_trylock(&console_sem) != 0)
+		if (down_trylock_console_sem() != 0)
 			return;
 	} else
 		console_lock();
