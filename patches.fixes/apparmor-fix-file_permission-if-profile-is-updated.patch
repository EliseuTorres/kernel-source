From: Miklos Szeredi <mszeredi@suse.cz>
Subject: apparmor: fix file_permission if profile is updated
Patch-mainline: Never
References: bsc#917968

SLE11 fails two test cases that check the following condition:

$APP: open $FILE
$APP: read/write
$APP: sleep...

change profile to deny access to $FILE by $APP

$APP: read/write

The second read/write is expected to fail, but doesn't.

The problem boils down to the following check in common_file_perm():

    if (!unconfined(profile) && !unconfined(fprofile) &&
        ((fprofile != profile) || (mask & ~fcxt->allow)))
        error = aa_file_perm(op, profile, file, mask);

aa_file_perm() is not called because fprofile == profile.  This is
because the profile is updated in both the file and the task and the
latest one is used for both.

The patch closes this hole by not following profile update chain for
fprofile.  This means that aa_file_perm() will always be called when the
profile is updated.

Unfortunately the cached mask in fcxt is not updated, so aa_file_perm()
will be called on each I/O operation until the file is closed.

Also there is a possibility of a false positive: profile not changed during
the lifetime of the file, but f_cred contains an already updated profile,
i.e. non-NULL ->replacedby field.  In this case aa_file_perm() will also be
called for each I/O operation during the lifetime of the file.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
---
 security/apparmor/lsm.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

--- a/security/apparmor/lsm.c
+++ b/security/apparmor/lsm.c
@@ -428,7 +428,8 @@ static void apparmor_file_free_security(
 static int common_file_perm(int op, struct file *file, u32 mask)
 {
 	struct aa_file_cxt *fcxt = file->f_security;
-	struct aa_profile *profile, *fprofile = aa_cred_profile(file->f_cred);
+	struct aa_task_cxt *tmp = file->f_cred->security;
+	struct aa_profile *profile, *fprofile = tmp->profile;
 	int error = 0;
 
 	BUG_ON(!fprofile);
