From 7f0f15464185a92f9d8791ad231bcd7bf6df54e4 Mon Sep 17 00:00:00 2001
From: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date: Tue, 11 May 2010 14:06:58 -0700
Subject: [PATCH] memcg: fix css_id() RCU locking for real
Patch-mainline: 7f0f15464185a92f9d8791ad231bcd7bf6df54e4
References: bnc#704592

Mhocko: 
We do not have RCU lockdep infrastructure so we are not able to check
rcu read side section. Anyway, let's WARN_ON if we see 0 ref count.
If this ever happen we have to check the callers and find out why it
doesn't get a reference before it calls css_{id,depth}. Memory controler
does seem to get a reference everytime before it gets down to this becase
we are mostly in a reclaim code paths where we should never race with
cgroup removal (famous last words?).

Original change log:

Commit ad4ba375373937817404fd92239ef4cadbded23b ("memcg: css_id() must be
called under rcu_read_lock()") modifies memcontol.c for fixing RCU check
message.  But Andrew Morton pointed out that the fix doesn't seems sane
and it was just for hidining lockdep messages.

This is a patch for do proper things.  Checking again, all places,
accessing without rcu_read_lock, that commit fixies was intentional....
all callers of css_id() has reference count on it.  So, it's not necessary
to be under rcu_read_lock().

Considering again, we can use rcu_dereference_check for css_id().  We know
css->id is valid if css->refcnt > 0.  (css->id never changes and freed
after css->refcnt going to be 0.)

This patch makes use of rcu_dereference_check() in css_id/depth and remove
unnecessary rcu-read-lock added by the commit.

Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
Cc: Daisuke Nishimura <nishimura@mxp.nes.nec.co.jp>
Cc: Balbir Singh <balbir@linux.vnet.ibm.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Michal Hocko <mhocko@suse.cz>

---
 kernel/cgroup.c |   15 +++++++++++++--
 mm/memcontrol.c |    2 --
 2 files changed, 13 insertions(+), 4 deletions(-)
Index: linux-2.6.32-memcg-backports/kernel/cgroup.c
===================================================================
--- linux-2.6.32-memcg-backports.orig/kernel/cgroup.c
+++ linux-2.6.32-memcg-backports/kernel/cgroup.c
@@ -4388,19 +4388,35 @@ __setup("cgroup_disable=", cgroup_disabl
  */
 unsigned short css_id(struct cgroup_subsys_state *css)
 {
-	struct css_id *cssid = rcu_dereference(css->id);
+	struct css_id *cssid;
 
-	if (cssid)
+	/*
+	 * This css_id() can return correct value when somone has refcnt
+	 * on this or this is under rcu_read_lock(). Once css->id is allocated,
+	 * it's unchanged until freed.
+	 */
+	cssid = rcu_dereference(css->id);
+
+	if (cssid) {
+		WARN_ON(!atomic_read(&css->refcnt));
 		return cssid->id;
+	}
+
 	return 0;
 }
 
 unsigned short css_depth(struct cgroup_subsys_state *css)
 {
-	struct css_id *cssid = rcu_dereference(css->id);
+	struct css_id *cssid;
 
-	if (cssid)
+	cssid = rcu_dereference(css->id);
+
+	/* check out css_id for css->id validity */
+	if (cssid) {
+		WARN_ON(!atomic_read(&css->refcnt));
 		return cssid->depth;
+	}
+
 	return 0;
 }
 
Index: linux-2.6.32-memcg-backports/mm/memcontrol.c
===================================================================
--- linux-2.6.32-memcg-backports.orig/mm/memcontrol.c
+++ linux-2.6.32-memcg-backports/mm/memcontrol.c
@@ -2364,9 +2364,7 @@ mem_cgroup_uncharge_swapcache(struct pag
 
 	/* record memcg information */
 	if (do_swap_account && swapout && memcg) {
-		rcu_read_lock();
 		swap_cgroup_record(ent, css_id(&memcg->css));
-		rcu_read_unlock();
 		mem_cgroup_get(memcg);
 	}
 	if (swapout && memcg)
