From: Michal Hocko <mhocko@suse.cz>
Subject: mm: call cond_resched in putback_lru_pages
Patch-mainline: never
References: bnc#763968

putback_lru_pages calls __pagevec_release if the pagevector is full.
lru_add_drain is called in this call path and under certain conditions
(e.g.  when ever other page on the per-cpu lists are from different zones)
we could end up with lru-lock bouncing up and down.

This shouldn't be a problem normally but an extreme memory pressure along
with CONFIG_PREEMPT_NONE might lead to soft lockup detection. 

We have seen this happening in bnc#763968. putback_lru_pages was about to
handle SWAP_CLUSTER_MAX pages so we had to call __pagevec_release twice
while all other CPUs were doing the direct reclaim as well fighting for
the lru-lock. This was sufficient to trigger soft lockup warnings so the
last scheduling point in shrink_page_list is not sufficient.

It is worth mentioning that there might be another contribution to this
issue. One of the crashdumps
(https://bugzilla.novell.com/show_bug.cgi?id=763968#c105) shown that all
CPUs were fighting for the same lock but the one which should get it sees
an outdated value of the spinlock ticket (0xdd12 rather than 0xdd18). The
situation is even more interesting because the cpu's instruction pointer
points right after read from memory:

<_raw_spin_lock+21>: movzwl (%rdi),%edx  <<< read ticket 0xdd12
<_raw_spin_lock+24>: jmp    0xffffffff81443a0f <_raw_spin_lock+15> <<<HERE

There are only 2 explanations
a) 6 CPUs released the lock between those two instructions
   This doesn't sound very much probable because the race window is way
   too small (other CPUs would need to acquire the lock, do something and
   release the lock).
   We can also rule out IRQs jumping in between the two instructions as
   they are disabled in this code path
b) CPU sees an outdated value due to some HW malfunctioning

Anyway we can workaround the issue by adding another scheduling point into
putback_lru_pages before call into __pagevec_release. The workaround is
not nice but it should be safe and it helped in the customer's workload.

Signed-off-by: Michal Hocko <mhocko@suse.cz>

---
 mm/vmscan.c |    1 +
 1 file changed, 1 insertion(+)

--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -1406,6 +1406,7 @@ putback_lru_pages(struct zone *zone, str
 		}
 		if (!pagevec_add(&pvec, page)) {
 			spin_unlock_irq(&zone->lru_lock);
+			cond_resched();
 			__pagevec_release(&pvec);
 			spin_lock_irq(&zone->lru_lock);
 		}
