From: Dan Williams <dan.j.williams@intel.com>
Date: Thu, 21 Jun 2012 23:25:42 -0700
Subject: cleanup setting task state in scsi_error_handler()
Git-commit: b9d5c6b7ef570bea0d22746944d7b58fa7f17b13
References: bnc#798050
Patch-Mainline: v3.7

A quick reading of scsi_error_handler() one could come away with the
impression that it does its wakeup event check while the task state is
TASK_RUNNING.  In fact it sets TASK_INTERRUPTIBLE at the bottom of the
loop, but that is ~50 lines down.

Just set TASK_INTERRUPTIBLE at the top of loop and be done.

Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: James Bottomley <JBottomley@Parallels.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/scsi_error.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff -aurp orig/drivers/scsi/scsi_error.c current/drivers/scsi/scsi_error.c
--- orig/drivers/scsi/scsi_error.c	2013-07-30 14:06:59.000000000 -0700
+++ current/drivers/scsi/scsi_error.c	2013-07-30 14:22:34.000000000 -0700
@@ -1925,15 +1925,14 @@ int scsi_error_handler(void *data)
 	 * We never actually get interrupted because kthread_run
 	 * disables signal delivery for the created thread.
 	 */
-	set_current_state(TASK_INTERRUPTIBLE);
 	while (!kthread_should_stop()) {
+		set_current_state(TASK_INTERRUPTIBLE);
 		if ((shost->host_failed == 0 && shost->host_eh_scheduled == 0) ||
 		    shost->host_failed != shost->host_busy) {
 			SCSI_LOG_ERROR_RECOVERY(1,
 				printk("Error handler scsi_eh_%d sleeping\n",
 					shost->host_no));
 			schedule();
-			set_current_state(TASK_INTERRUPTIBLE);
 			continue;
 		}
 
@@ -1969,7 +1968,6 @@ int scsi_error_handler(void *data)
 		 */
 		scsi_restart_operations(shost);
 		scsi_autopm_put_host(shost);
-		set_current_state(TASK_INTERRUPTIBLE);
 	}
 	__set_current_state(TASK_RUNNING);
 
