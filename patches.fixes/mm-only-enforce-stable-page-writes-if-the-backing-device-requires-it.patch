From: "Darrick J. Wong" <darrick.wong@oracle.com>
Date: Thu, 21 Feb 2013 16:42:51 -0800
Subject: [PATCH] mm: only enforce stable page writes if the backing device
 requires it

References: Only enable stable page writes when necessary (bnc#807517)
Patch-mainline: Yes (v3.9)
Git-commit: 1d1d1a767206fbe5d4c69493b7e6d2a8d08cc0a0

Create a helper function to check if a backing device requires stable
page writes and, if so, performs the necessary wait.  Then, make it so
that all points in the memory manager that handle making pages writable
use the helper function.  This should provide stable page write support
to most filesystems, while eliminating unnecessary waiting for devices
that don't require the feature.

Before this patchset, all filesystems would block, regardless of whether
or not it was necessary.  ext3 would wait, but still generate occasional
checksum errors.  The network filesystems were left to do their own
thing, so they'd wait too.

After this patchset, all the disk filesystems except ext3 and btrfs will
wait only if the hardware requires it.  ext3 (if necessary) snapshots
pages instead of blocking, and btrfs provides its own bdi so the mm will
never wait.  Network filesystems haven't been touched, so either they
provide their own stable page guarantees or they don't block at all.
The blocking behavior is back to what it was before 3.0 if you don't
have a disk requiring stable page writes.

Here's the result of using dbench to test latency on ext2:

3.8.0-rc3:
 Operation      Count    AvgLat    MaxLat
 ----------------------------------------
 WriteX        109347     0.028    59.817
 ReadX         347180     0.004     3.391
 Flush          15514    29.828   287.283

Throughput 57.429 MB/sec  4 clients  4 procs  max_latency=287.290 ms

3.8.0-rc3 + patches:
 WriteX        105556     0.029     4.273
 ReadX         335004     0.005     4.112
 Flush          14982    30.540   298.634

Throughput 55.4496 MB/sec  4 clients  4 procs  max_latency=298.650 ms

As you can see, the maximum write latency drops considerably with this
patch enabled.  The other filesystems (ext3/ext4/xfs/btrfs) behave
similarly, but see the cover letter for those results.

Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
Acked-by: Steven Whitehouse <swhiteho@redhat.com>
Reviewed-by: Jan Kara <jack@suse.cz>
Cc: Adrian Hunter <adrian.hunter@intel.com>
Cc: Andy Lutomirski <luto@amacapital.net>
Cc: Artem Bityutskiy <dedekind1@gmail.com>
Cc: Joel Becker <jlbec@evilplan.org>
Cc: Mark Fasheh <mfasheh@suse.com>
Cc: Jens Axboe <axboe@kernel.dk>
Cc: Eric Van Hensbergen <ericvh@gmail.com>
Cc: Ron Minnich <rminnich@sandia.gov>
Cc: Latchesar Ionkov <lucho@ionkov.net>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 fs/buffer.c             |  2 +-
 fs/ext4/inode.c         |  2 +-
 fs/gfs2/file.c          |  2 ++
 fs/nilfs2/file.c        |  2 +-
 include/linux/pagemap.h |  1 +
 mm/filemap.c            |  2 +-
 mm/page-writeback.c     | 20 ++++++++++++++++++++
 7 files changed, 27 insertions(+), 4 deletions(-)

diff --git a/fs/buffer.c b/fs/buffer.c
index 351e474..eeeedf3 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -2393,7 +2393,7 @@ int __block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,
 		ret = -EAGAIN;
 		goto out_unlock;
 	}
-	wait_on_page_writeback(page);
+	wait_for_stable_page(page);
 	return 0;
 out_unlock:
 	unlock_page(page);
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 7e56946..301d136 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -5961,7 +5961,7 @@ int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 	 * happened.
 	 */
 	lock_page(page);
-	wait_on_page_writeback(page);
+	wait_for_stable_page(page);
 	up_read(&inode->i_alloc_sem);
 	return VM_FAULT_LOCKED;
 out_unlock:
diff --git a/fs/gfs2/file.c b/fs/gfs2/file.c
index 83cdb24..237f0f0 100644
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@ -424,6 +424,8 @@ out:
 		ret = VM_FAULT_OOM;
 	else if (ret)
 		ret = VM_FAULT_SIGBUS;
+	else
+		wait_for_stable_page(page);
 	return ret;
 }
 
diff --git a/fs/nilfs2/file.c b/fs/nilfs2/file.c
index 2660152..effe125 100644
--- a/fs/nilfs2/file.c
+++ b/fs/nilfs2/file.c
@@ -119,7 +119,7 @@ static int nilfs_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 	nilfs_transaction_commit(inode->i_sb);
 
  mapped:
-	wait_on_page_writeback(page);
+	wait_for_stable_page(page);
 	return VM_FAULT_LOCKED;
 }
 
diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h
index c792800..d6cc2a6 100644
--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -401,6 +401,7 @@ static inline void wait_on_page_writeback(struct page *page)
 }
 
 extern void end_page_writeback(struct page *page);
+void wait_for_stable_page(struct page *page);
 
 /*
  * Add an arbitrary waiter to a page's wait queue
diff --git a/mm/filemap.c b/mm/filemap.c
index ce19b7c..547e71f 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -2519,7 +2519,7 @@ repeat:
 		return NULL;
 	}
 found:
-	wait_on_page_writeback(page);
+	wait_for_stable_page(page);
 	return page;
 }
 EXPORT_SYMBOL(grab_cache_page_write_begin);
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 461b023..c6c9147 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -1453,3 +1453,23 @@ int mapping_tagged(struct address_space *mapping, int tag)
 	return ret;
 }
 EXPORT_SYMBOL(mapping_tagged);
+
+/**
+ * wait_for_stable_page() - wait for writeback to finish, if necessary.
+ * @page:	The page to wait on.
+ *
+ * This function determines if the given page is related to a backing device
+ * that requires page contents to be held stable during writeback.  If so, then
+ * it will wait for any pending writeback to complete.
+ */
+void wait_for_stable_page(struct page *page)
+{
+	struct address_space *mapping = page_mapping(page);
+	struct backing_dev_info *bdi = mapping->backing_dev_info;
+
+	if (!bdi_cap_stable_pages_required(bdi))
+		return;
+
+	wait_on_page_writeback(page);
+}
+EXPORT_SYMBOL_GPL(wait_for_stable_page);
