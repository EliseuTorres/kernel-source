From: Michal Hocko <mhocko@suse.cz>
Subject: mm: call sleep_on_page_killable from __wait_on_page_locked_killable
Patch-mainline: no
References: bnc#799909

If a thread gets killed while it is waiting on the page lock in
__wait_on_page_locked_killable during page fault it will wake up and it should
retry with VM_FAULT_RETRY returned to the arch specific page fault handler. X86
then calls mm_fault_error which cheks pending fatal signals and fail the fault
accordingly.

This however doesn't work as expected because __wait_on_page_locked_killable
calls sleep_on_page rather than sleep_on_page_killable and so there is no
chance to break out of the loop until the page lock is released. This wouldn't
be noticable normally because pages are not lock for a long time so the lock
would be released eventually - although the other thread would be busy looping
for the remaining time (without cond_reschedule) so it wouldn't let anybody
else run on that CPU. If the holder of the lock has a lower priority and it is
bound to the same CPU then we might deadlock easily as the lock holder will
never run.

The whole heuristic has been introduced by
patches.suse/unlock_page-speedup.patch so this fixes a suse specific issue.

[patch description by mhocko]
Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>

---
 mm/filemap.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -785,9 +785,9 @@ int  __wait_on_page_locked_killable(stru
 		if (!PageWaiters(page))
 			SetPageWaiters(page);
 		if (likely(PageLocked(page)))
-			ret = sleep_on_page(page);
+			ret = sleep_on_page_killable(page);
 		finish_wait(wq, &wait.wait);
-	} while (PageLocked(page));
+	} while (PageLocked(page) && !ret);
 
 	/* Clean up a potentially dangling PG_waiters */
 	if (unlikely(PageWaiters(page)))
