From: Bjorn Helgaas <bjorn.helgaas@hp.com>
Subject: x86/PCI: use host bridge _CRS info by default on 2008 and newer machines
References: bnc#578572
Patch-Mainline: 2.6.34-rc1
Git-commit: 7bc5e3f2be32ae6fb0c74cd0f707f986b3a01a26

Signed-off-by: Thomas Renninger <trenn@suse.de>

The main benefit of using ACPI host bridge window information is that
we can do better resource allocation in systems with multiple host bridges,
e.g., http://bugzilla.kernel.org/show_bug.cgi?id=14183

Sometimes we need _CRS information even if we only have one host bridge,
e.g., https://bugs.launchpad.net/ubuntu/+source/linux/+bug/341681

Most of these systems are relatively new, so this patch turns on
"pci=use_crs" only on machines with a BIOS date of 2008 or newer.

Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

---
 Documentation/kernel-parameters.txt |    8 +++-
 arch/ia64/include/asm/acpi.h        |    1 
 arch/x86/include/asm/pci_x86.h      |    1 
 arch/x86/pci/acpi.c                 |   60 +++++++++++++++++++++++++++++++-----
 arch/x86/pci/common.c               |    3 +
 drivers/acpi/pci_root.c             |    1 
 include/acpi/acpi_drivers.h         |    1 
 7 files changed, 65 insertions(+), 10 deletions(-)

Index: linux-2.6.32-SLE11-SP1/Documentation/kernel-parameters.txt
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/Documentation/kernel-parameters.txt
+++ linux-2.6.32-SLE11-SP1/Documentation/kernel-parameters.txt
@@ -1928,8 +1928,12 @@ and is between 256 and 4096 characters.
 				IRQ routing is enabled.
 		noacpi		[X86] Do not use ACPI for IRQ routing
 				or for PCI scanning.
-		use_crs		[X86] Use _CRS for PCI resource
-				allocation.
+		use_crs		[X86] Use PCI host bridge window information
+				from ACPI.  On BIOSes from 2008 or later, this
+				is enabled by default.  If you need to use this,
+				please report a bug.
+		nocrs		[X86] Ignore PCI host bridge windows from ACPI.
+			        If you need to use this, please report a bug.
 		routeirq	Do IRQ routing for all PCI devices.
 				This is normally done in pci_enable_device(),
 				so this option is a temporary workaround
Index: linux-2.6.32-SLE11-SP1/arch/ia64/include/asm/acpi.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/ia64/include/asm/acpi.h
+++ linux-2.6.32-SLE11-SP1/arch/ia64/include/asm/acpi.h
@@ -97,6 +97,7 @@ ia64_acpi_release_global_lock (unsigned
 #endif
 #define acpi_processor_cstate_check(x) (x) /* no idle limits on IA64 :) */
 static inline void disable_acpi(void) { }
+static inline void pci_acpi_crs_quirks(void) { }
 
 const char *acpi_get_sysname (void);
 int acpi_request_vector (u32 int_type);
Index: linux-2.6.32-SLE11-SP1/arch/x86/include/asm/pci_x86.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/include/asm/pci_x86.h
+++ linux-2.6.32-SLE11-SP1/arch/x86/include/asm/pci_x86.h
@@ -29,6 +29,7 @@
 #define PCI_CHECK_ENABLE_AMD_MMCONF	0x20000
 #define PCI_HAS_IO_ECS		0x40000
 #define PCI_NOASSIGN_ROMS	0x80000
+#define PCI_ROOT_NO_CRS		0x100000
 
 extern unsigned int pci_probe;
 extern unsigned long pirq_table_addr;
Index: linux-2.6.32-SLE11-SP1/arch/x86/pci/acpi.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/pci/acpi.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/pci/acpi.c
@@ -14,6 +14,54 @@ struct pci_root_info {
 	int busnum;
 };
 
+static bool pci_use_crs;
+
+static int __init set_use_crs(const struct dmi_system_id *id)
+{
+	pci_use_crs = true;
+	return 0;
+}
+
+static const struct dmi_system_id pci_use_crs_table[] __initconst = {
+	/* http://bugzilla.kernel.org/show_bug.cgi?id=14183 */
+	{
+		.callback = set_use_crs,
+		.ident = "IBM System x3800",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "IBM"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "x3800"),
+		},
+	},
+	{}
+};
+
+void __init pci_acpi_crs_quirks(void)
+{
+	/* We cannot take this whitelist by date for SLES 11 SP1 or
+	 * customers might see breakage because of a simple BIOS update
+	 *
+	 * int year;
+	 *
+	 * if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) && year < 2008)
+	 *      pci_use_crs = false;
+	*/
+	dmi_check_system(pci_use_crs_table);
+
+	/*
+	 * If the user specifies "pci=use_crs" or "pci=nocrs" explicitly, that
+	 * takes precedence over anything we figured out above.
+	 */
+	if (pci_probe & PCI_ROOT_NO_CRS)
+		pci_use_crs = false;
+	else if (pci_probe & PCI_USE__CRS)
+		pci_use_crs = true;
+
+	printk(KERN_INFO "PCI: %s host bridge windows from ACPI; "
+	       "if necessary, use \"pci=%s\" and report a bug\n",
+	       pci_use_crs ? "Using" : "Ignoring",
+	       pci_use_crs ? "nocrs" : "use_crs");
+}
+
 static acpi_status
 resource_to_addr(struct acpi_resource *resource,
 			struct acpi_resource_address64 *addr)
@@ -98,12 +146,8 @@ get_current_resources(struct acpi_device
 	struct pci_root_info info;
 	size_t size;
 
-	if (pci_probe & PCI_USE__CRS)
-		pci_bus_remove_resources(bus);
-	else
-		dev_info(&device->dev,
-                         "ignoring host bridge windows from ACPI; "
-			 "boot with \"pci=use_crs\" to use them\n");
+	if (pci_use_crs)
+ 		pci_bus_remove_resources(bus);
 
 	info.bus = bus;
 	info.res_num = 0;
@@ -190,9 +234,9 @@ struct pci_bus * __devinit pci_acpi_scan
 	} else {
 		bus = pci_create_bus(NULL, busnum, &pci_root_ops, sd);
 		if (bus) {
-			if (pci_probe & PCI_USE__CRS)
+			if (pci_use_crs)
 				get_current_resources(device, busnum, domain,
-							bus);
+						      bus);
 			bus->subordinate = pci_scan_child_bus(bus);
 		}
 	}
Index: linux-2.6.32-SLE11-SP1/arch/x86/pci/common.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/pci/common.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/pci/common.c
@@ -518,6 +518,9 @@ char * __devinit  pcibios_setup(char *st
 	} else if (!strcmp(str, "use_crs")) {
 		pci_probe |= PCI_USE__CRS;
 		return NULL;
+	} else if (!strcmp(str, "nocrs")) {
+		pci_probe |= PCI_ROOT_NO_CRS;
+		return NULL;
 	} else if (!strcmp(str, "earlydump")) {
 		pci_early_dump_regs = 1;
 		return NULL;
Index: linux-2.6.32-SLE11-SP1/drivers/acpi/pci_root.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/acpi/pci_root.c
+++ linux-2.6.32-SLE11-SP1/drivers/acpi/pci_root.c
@@ -606,6 +606,7 @@ static int __init acpi_pci_root_init(voi
 	if (acpi_pci_disabled)
 		return 0;
 
+	pci_acpi_crs_quirks();
 	if (acpi_bus_register_driver(&acpi_pci_root_driver) < 0)
 		return -ENODEV;
 
Index: linux-2.6.32-SLE11-SP1/include/acpi/acpi_drivers.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/acpi/acpi_drivers.h
+++ linux-2.6.32-SLE11-SP1/include/acpi/acpi_drivers.h
@@ -104,6 +104,7 @@ int acpi_pci_bind_root(struct acpi_devic
 
 struct pci_bus *pci_acpi_scan_root(struct acpi_device *device, int domain,
 				   int bus);
+void pci_acpi_crs_quirks(void);
 
 /* --------------------------------------------------------------------------
                                     Processor

