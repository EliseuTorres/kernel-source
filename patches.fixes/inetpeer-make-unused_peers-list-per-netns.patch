From 39cb1dfb9977b0085c588fb5f0fc1f63c5c8166e Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Wed, 19 Sep 2012 02:14:29 +0200
Subject: inetpeer: make unused_peers list per-netns
Patch-mainline: Never, SLE specific fixup
References: bnc#779969

As we have separate per-netns inet_peer trees now, cleanup of
unused entries needs to be done per namespace as well. Otherwise
cleanup_once() wouldn't know which tree to unlink the entry
from.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/inetpeer.h |   11 ++++++
 net/ipv4/inetpeer.c    |   94 ++++++++++++++++++++++++------------------------
 2 files changed, 58 insertions(+), 47 deletions(-)

diff --git a/include/net/inetpeer.h b/include/net/inetpeer.h
index 9ec42b9..40a569c 100644
--- a/include/net/inetpeer.h
+++ b/include/net/inetpeer.h
@@ -27,12 +27,23 @@ struct inetpeer_addr {
 	__u16				family;
 };
 
+#ifndef __GENKSYMS__
+struct inet_peer_base;
+#endif
+
 struct inet_peer {
 	/* group together avl_left,avl_right,v4daddr to speedup lookups */
 	struct inet_peer __rcu	*avl_left, *avl_right;
 	struct inetpeer_addr	daddr;
 	__u32			avl_height;
+#ifdef __GENKSYMS__
 	struct list_head	unused;
+#else
+	union {
+		struct list_head	unused;
+		struct inet_peer_base	*base;
+	};
+#endif
 	__u32			dtime;		/* the time of last use of not
 						 * referenced entries */
 	atomic_t		refcnt;
diff --git a/net/ipv4/inetpeer.c b/net/ipv4/inetpeer.c
index 8d14a0a..bce6b1c 100644
--- a/net/ipv4/inetpeer.c
+++ b/net/ipv4/inetpeer.c
@@ -85,9 +85,9 @@ static const struct inet_peer peer_fake_node = {
 };
 
 struct inet_peer_base {
-	struct inet_peer __rcu *root;
-	seqlock_t	lock;
-	int		total;
+	struct inet_peer __rcu	*root;
+	seqlock_t		lock;
+	struct list_head	unused_peers_list;
 };
 
 struct netns_inetpeer {
@@ -96,6 +96,8 @@ struct netns_inetpeer {
 };
 
 static int inetpeer_net_id;
+atomic_t peers_total;
+DEFINE_SPINLOCK(unused_peers_lock);
 
 #define PEER_MAXDEPTH 40 /* sufficient for about 2^27 nodes */
 
@@ -107,14 +109,6 @@ int inet_peer_maxttl __read_mostly = 10 * 60 * HZ;	/* usual time to live: 10 min
 int inet_peer_gc_mintime __read_mostly = 10 * HZ;
 int inet_peer_gc_maxtime __read_mostly = 120 * HZ;
 
-static struct {
-	struct list_head	list;
-	spinlock_t		lock;
-} unused_peers = {
-	.list			= LIST_HEAD_INIT(unused_peers.list),
-	.lock			= __SPIN_LOCK_UNLOCKED(unused_peers.lock),
-};
-
 static void peer_check_expire(unsigned long dummy);
 static DEFINE_TIMER(peer_periodic_timer, peer_check_expire, 0, 0);
 
@@ -129,6 +123,7 @@ static int __net_init inetpeer_net_init(struct net *net)
 		return -ENOMEM;
 
 	nsp->ipv4_peers->root = peer_avl_empty_rcu;
+	INIT_LIST_HEAD(&nsp->ipv4_peers->unused_peers_list);
 	seqlock_init(&nsp->ipv4_peers->lock);
 
 	nsp->ipv6_peers = kzalloc(sizeof(struct inet_peer_base),
@@ -137,6 +132,7 @@ static int __net_init inetpeer_net_init(struct net *net)
 		goto out_ipv6;
 
 	nsp->ipv6_peers->root = peer_avl_empty_rcu;
+	INIT_LIST_HEAD(&nsp->ipv6_peers->unused_peers_list);
 	seqlock_init(&nsp->ipv6_peers->lock);
 
 	return 0;
@@ -197,11 +193,13 @@ void __init inet_initpeers(void)
 }
 
 /* Called with or without local BH being disabled. */
-static void unlink_from_unused(struct inet_peer *p)
+static void unlink_from_unused(struct inet_peer_base* base,
+			       struct inet_peer *p)
 {
-	spin_lock_bh(&unused_peers.lock);
-	list_del_init(&p->unused);
-	spin_unlock_bh(&unused_peers.lock);
+	spin_lock_bh(&unused_peers_lock);
+	list_del(&p->unused);
+	p->base = base;
+	spin_unlock_bh(&unused_peers_lock);
 }
 
 static int addr_compare(const struct inetpeer_addr *a,
@@ -451,7 +449,7 @@ static void unlink_from_pool(struct inet_peer *p, struct inet_peer_base *base,
 			delp[1] = &t->avl_left; /* was &p->avl_left */
 		}
 		peer_avl_rebalance(stack, stackptr, base);
-		base->total--;
+		atomic_dec(&peers_total);
 		do_free = 1;
 	}
 	write_sequnlock_bh(&base->lock);
@@ -477,37 +475,35 @@ static struct inet_peer_base *family_to_base(struct net *net,
 	return (family == AF_INET ? nsp->ipv4_peers : nsp->ipv6_peers);
 }
 
-static struct inet_peer_base *peer_to_base(struct inet_peer *p)
-{
-	return family_to_base(p->daddr.family);
-}
-
 /* May be called with local BH enabled. */
-static int cleanup_once(unsigned long ttl, struct inet_peer __rcu **stack[PEER_MAXDEPTH])
+static int cleanup_once(struct inet_peer_base *base,
+			unsigned long ttl,
+			struct inet_peer __rcu **stack[PEER_MAXDEPTH])
 {
 	struct inet_peer *p = NULL;
 
 	/* Remove the first entry from the list of unused nodes. */
-	spin_lock_bh(&unused_peers.lock);
-	if (!list_empty(&unused_peers.list)) {
+	spin_lock_bh(&unused_peers_lock);
+	if (!list_empty(&base->unused_peers_list)) {
 		__u32 delta;
 
-		p = list_first_entry(&unused_peers.list, struct inet_peer, unused);
+		p = list_first_entry(&base->unused_peers_list, struct inet_peer, unused);
 		delta = (__u32)jiffies - p->dtime;
 
 		if (delta < ttl) {
 			/* Do not prune fresh entries. */
-			spin_unlock_bh(&unused_peers.lock);
+			spin_unlock_bh(&unused_peers_lock);
 			return -1;
 		}
 
 		list_del_init(&p->unused);
+		p->base = base;
 
 		/* Grab an extra reference to prevent node disappearing
 		 * before unlink_from_pool() call. */
 		atomic_inc(&p->refcnt);
 	}
-	spin_unlock_bh(&unused_peers.lock);
+	spin_unlock_bh(&unused_peers_lock);
 
 	if (p == NULL)
 		/* It means that the total number of USED entries has
@@ -515,7 +511,7 @@ static int cleanup_once(unsigned long ttl, struct inet_peer __rcu **stack[PEER_M
 		 * happen because of entry limits in route cache. */
 		return -1;
 
-	unlink_from_pool(p, peer_to_base(p), stack);
+	unlink_from_pool(p, base, stack);
 	return 0;
 }
 
@@ -544,7 +540,7 @@ found:		/* The existing node has been found.
 		 * Remove the entry from unused list if it was there.
 		 */
 		if (newrefcnt == 1)
-			unlink_from_unused(p);
+			unlink_from_unused(base, p);
 		return p;
 	}
 
@@ -575,18 +571,17 @@ found:		/* The existing node has been found.
 		p->pmtu_expires = 0;
 		p->pmtu_orig = 0;
 		memset(&p->redirect_learned, 0, sizeof(p->redirect_learned));
-		INIT_LIST_HEAD(&p->unused);
-
+		p->base = base;
 
 		/* Link the node. */
 		link_to_pool(p, base);
-		base->total++;
+		atomic_inc(&peers_total);
 	}
 	write_sequnlock_bh(&base->lock);
 
-	if (base->total >= inet_peer_threshold)
+	if (atomic_read(&peers_total) >= inet_peer_threshold)
 		/* Remove one less-recently-used entry. */
-		cleanup_once(0, stack);
+		cleanup_once(base, 0, stack);
 
 	return p;
 }
@@ -598,34 +593,38 @@ struct inet_peer *inet_getpeer(struct inetpeer_addr *daddr, int create)
 }
 EXPORT_SYMBOL_GPL(inet_getpeer);
 
-static int compute_total(void)
-{
-	return v4_peers.total + v6_peers.total;
-}
-
 /* Called with local BH disabled. */
 static void peer_check_expire(unsigned long dummy)
 {
 	unsigned long now = jiffies;
 	int ttl, total;
 	struct inet_peer __rcu **stack[PEER_MAXDEPTH];
+	struct net *net;
 
-	total = compute_total();
+	total = atomic_read(&peers_total);
 	if (total >= inet_peer_threshold)
 		ttl = inet_peer_minttl;
 	else
 		ttl = inet_peer_maxttl
 				- (inet_peer_maxttl - inet_peer_minttl) / HZ *
 					total / inet_peer_threshold * HZ;
-	while (!cleanup_once(ttl, stack)) {
-		if (jiffies != now)
-			break;
+	for_each_net(net) {
+		struct netns_inetpeer* nsp = net_generic(net, inetpeer_net_id);
+		while (!cleanup_once(nsp->ipv4_peers, ttl, stack)) {
+			if (jiffies != now)
+				goto too_long;
+		}
+		while (!cleanup_once(nsp->ipv6_peers, ttl, stack)) {
+			if (jiffies != now)
+				goto too_long;
+		}
 	}
+too_long:
 
 	/* Trigger the timer after inet_peer_gc_mintime .. inet_peer_gc_maxtime
 	 * interval depending on the total number of entries (more entries,
 	 * less interval). */
-	total = compute_total();
+	total = atomic_read(&peers_total);
 	if (total >= inet_peer_threshold)
 		peer_periodic_timer.expires = jiffies + inet_peer_gc_mintime;
 	else
@@ -640,10 +639,11 @@ void inet_putpeer(struct inet_peer *p)
 {
 	local_bh_disable();
 
-	if (atomic_dec_and_lock(&p->refcnt, &unused_peers.lock)) {
-		list_add_tail(&p->unused, &unused_peers.list);
+	if (atomic_dec_and_lock(&p->refcnt, &unused_peers_lock)) {
+		struct inet_peer_base *base = p->base;
+		list_add_tail(&p->unused, &base->unused_peers_list);
 		p->dtime = (__u32)jiffies;
-		spin_unlock(&unused_peers.lock);
+		spin_unlock(&unused_peers_lock);
 	}
 
 	local_bh_enable();
-- 
1.7.10.4

