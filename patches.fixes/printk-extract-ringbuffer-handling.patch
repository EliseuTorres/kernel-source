From: Michal Hocko <mhocko@suse.cz>
Subject: printk: extract ringbuffer handling from vprintk
Patch-mainline: not yet
References: bnc#831949

This is just a preparator patch which moves ringbuffer handling code from
vprintk into a helper function (finish_printk). This involves new lines
handling, temporary buffer copy into the ring buffer and the log level.

While I am there also do not use printk_buf directly and hide it behind local
variable because later patches will introduce new temporary buffer.

This patch doesn't introduce any functional changes.

Signed-off-by: Michal Hocko <mhocko@suse.cz>

---
 kernel/printk.c |  124 ++++++++++++++++++++++++++++++--------------------------
 1 file changed, 67 insertions(+), 57 deletions(-)

--- a/kernel/printk.c
+++ b/kernel/printk.c
@@ -858,61 +858,20 @@ static inline void printk_delay(void)
 	}
 }
 
-asmlinkage int vprintk(const char *fmt, va_list args)
+static int finish_printk(char *msg, int printed_len)
 {
-	int printed_len = 0;
 	int current_log_level = default_message_loglevel;
-	unsigned long flags;
-	int this_cpu;
-	char *p;
+	char *msg_start = msg;
 	size_t plen;
 	char special;
+	void (*emit_char)(char c) = emit_log_char;
 
-	boot_delay_msec();
-	printk_delay();
-
-	preempt_disable();
-	/* This stops the holder of console_sem just where we want him */
-	raw_local_irq_save(flags);
-	this_cpu = smp_processor_id();
-
-	/*
-	 * Ouch, printk recursed into itself!
-	 */
-	if (unlikely(printk_cpu == this_cpu)) {
-		/*
-		 * If a crash is occurring during printk() on this CPU,
-		 * then try to get the crash message out but make sure
-		 * we can't deadlock. Otherwise just return to avoid the
-		 * recursion and return - but flag the recursion so that
-		 * it can be printed at the next appropriate moment:
-		 */
-		if (!oops_in_progress) {
-			recursion_bug = 1;
-			goto out_restore_irqs;
-		}
-		zap_locks();
-	}
-
-	lockdep_off();
-	spin_lock(&logbuf_lock);
-	printk_cpu = this_cpu;
-
-	if (recursion_bug) {
-		recursion_bug = 0;
-		strcpy(printk_buf, recursion_bug_msg);
-		printed_len = strlen(recursion_bug_msg);
-	}
-	/* Emit the output into the temporary buffer */
-	printed_len += vscnprintf(printk_buf + printed_len,
-				  sizeof(printk_buf) - printed_len, fmt, args);
-
-	p = printk_buf;
+	/* TODO new_text_line needs a special handling for nmi_ring */
 
 	/* Read log level and handle special printk prefix */
-	plen = log_prefix(p, &current_log_level, &special);
+	plen = log_prefix(msg, &current_log_level, &special);
 	if (plen) {
-		p += plen;
+		msg += plen;
 
 		switch (special) {
 		case 'c': /* Strip <c> KERN_CONT, continue line */
@@ -922,7 +881,7 @@ asmlinkage int vprintk(const char *fmt,
 			plen = 0;
 		default:
 			if (!new_text_line) {
-				emit_log_char('\n');
+				emit_char('\n');
 				new_text_line = 1;
 			}
 		}
@@ -932,7 +891,7 @@ asmlinkage int vprintk(const char *fmt,
 	 * Copy the output into log_buf. If the caller didn't provide
 	 * the appropriate log prefix, we insert them here
 	 */
-	for (; *p; p++) {
+	for (; *msg; msg++) {
 		if (new_text_line) {
 			new_text_line = 0;
 
@@ -941,13 +900,13 @@ asmlinkage int vprintk(const char *fmt,
 				int i;
 
 				for (i = 0; i < plen; i++)
-					emit_log_char(printk_buf[i]);
+					emit_char(msg_start[i]);
 				printed_len += plen;
 			} else {
 				/* Add log prefix */
-				emit_log_char('<');
-				emit_log_char(current_log_level + '0');
-				emit_log_char('>');
+				emit_char('<');
+				emit_char(current_log_level + '0');
+				emit_char('>');
 				printed_len += 3;
 			}
 
@@ -965,19 +924,70 @@ asmlinkage int vprintk(const char *fmt,
 						nanosec_rem / 1000);
 
 				for (tp = tbuf; tp < tbuf + tlen; tp++)
-					emit_log_char(*tp);
+					emit_char(*tp);
 				printed_len += tlen;
 			}
 
-			if (!*p)
+			if (!*msg)
 				break;
 		}
 
-		emit_log_char(*p);
-		if (*p == '\n')
+		emit_char(*msg);
+		if (*msg == '\n')
 			new_text_line = 1;
 	}
 
+	return printed_len;
+}
+
+asmlinkage int vprintk(const char *fmt, va_list args)
+{
+	int printed_len = 0;
+	unsigned long flags;
+	int this_cpu;
+	char *buf = printk_buf;
+	unsigned buf_len = sizeof(printk_buf);
+
+	boot_delay_msec();
+	printk_delay();
+
+	preempt_disable();
+	/* This stops the holder of console_sem just where we want him */
+	raw_local_irq_save(flags);
+	this_cpu = smp_processor_id();
+
+	/*
+	 * Ouch, printk recursed into itself!
+	 */
+	if (unlikely(printk_cpu == this_cpu)) {
+		/*
+		 * If a crash is occurring during printk() on this CPU,
+		 * then try to get the crash message out but make sure
+		 * we can't deadlock. Otherwise just return to avoid the
+		 * recursion and return - but flag the recursion so that
+		 * it can be printed at the next appropriate moment:
+		 */
+		if (!oops_in_progress) {
+			recursion_bug = 1;
+			goto out_restore_irqs;
+		}
+		zap_locks();
+	}
+
+	lockdep_off();
+	spin_lock(&logbuf_lock);
+	printk_cpu = this_cpu;
+
+	if (recursion_bug) {
+		recursion_bug = 0;
+		strcpy(printk_buf, recursion_bug_msg);
+		printed_len = strlen(recursion_bug_msg);
+	}
+	/* Emit the output into the temporary buffer */
+	printed_len += vscnprintf(buf + printed_len,
+				  buf_len - printed_len, fmt, args);
+	printed_len = finish_printk(buf, printed_len);
+
 	/*
 	 * Try to acquire and then immediately release the
 	 * console semaphore. The release will do all the
