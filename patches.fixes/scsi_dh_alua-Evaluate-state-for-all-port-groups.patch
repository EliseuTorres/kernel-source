From: Hannes Reinecke <hare@suse.de>
Date: Mon, 8 Oct 2012 10:50:57 +0200
Subject: scsi_dh_alua: Evaluate state for all port groups
References: bnc#708296
Patch-Mainline: submitted to linux scsi

When an RTPG response is received we should be updating the state
of all port groups, not only that one we've sent out the command
to. Otherwise the other port groups might get out of sync after
STPG.

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/device_handler/scsi_dh_alua.c | 22 ++++++++++++++++------
 1 file changed, 16 insertions(+), 6 deletions(-)

diff --git a/drivers/scsi/device_handler/scsi_dh_alua.c b/drivers/scsi/device_handler/scsi_dh_alua.c
index 768fae4..312c874 100644
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@ -695,6 +695,7 @@ static int alua_rtpg(struct scsi_device *sdev, struct alua_port_group *pg)
 {
 	unsigned char sense[SCSI_SENSE_BUFFERSIZE];
 	struct scsi_sense_hdr sense_hdr;
+	struct alua_port_group *tmp_pg;
 	int len, k, off;
 	unsigned char *ucp;
 	unsigned err, retval;
@@ -795,13 +796,22 @@ static int alua_rtpg(struct scsi_device *sdev, struct alua_port_group *pg)
 	     k < len;
 	     k += off, ucp += off) {
 
-		if (pg->group_id == (ucp[2] << 8) + ucp[3]) {
-			spin_lock(&pg->rtpg_lock);
-			pg->state = ucp[0] & 0x0f;
-			pg->pref = ucp[0] >> 7;
-			pg->valid = ucp[1];
-			spin_unlock(&pg->rtpg_lock);
+		spin_lock(&port_group_lock);
+		list_for_each_entry(tmp_pg, &port_group_list, node) {
+			if (tmp_pg->target_id_size != pg->target_id_size)
+				continue;
+			if (memcmp(tmp_pg->target_id, pg->target_id,
+				   pg->target_id_size))
+				continue;
+			if (tmp_pg->group_id == (ucp[2] << 8) + ucp[3]) {
+				spin_lock(&tmp_pg->rtpg_lock);
+				tmp_pg->state = ucp[0] & 0x0f;
+				tmp_pg->pref = ucp[0] >> 7;
+				tmp_pg->valid = ucp[1];
+				spin_unlock(&tmp_pg->rtpg_lock);
+			}
 		}
+		spin_unlock(&port_group_lock);
 		off = 8 + (ucp[7] * 4);
 	}
 	if (pg->state == -1) {
-- 
1.7.12.4

