From: Olaf Kirch <okir@suse.de>
Subject: natsemi: make cable length magic configurable
References: bnc#225091, bnc#704361
Patch-mainline: Never (upstream doesn't like the implementation, see below)

We had a customer report concerning problems with a Natsemi DP83815-D
and long cables. With 100m cables, the network would be essentially dead,
not a single packet would get through either way. We had to apply the
patch below to make it work.

The patch adds a module parameter named "no_cable_magic" that does
two things:

 -	Unconditionally set the DSPCFG register to the
	fixed value. Without this change, the chip apparently
	never completes autonegotiation in the tested configuration.

	This has been an unconditional assignment for a long time,
	until this was changed in 2.6.11 (there's an interesting
	explanation in the ChangeLog, subject is
	"[PATCH] natsemi long cable fix", bk commit is
	5871b81bf2b5cf188deab0d414dce104fcb69ca6, git commit in
	tglx/history tree is c0d51c67f9c398279a95c5a7df387f2d9a586c98.

 -	Skip the bit banging in {,un}do_cable_magic. It seems that
	if we write the DSPCFG register as above, a rev D chip will report
	all cables as "short cables", which do_cable_magic detects, and
	trying to be helpful it will "fix" the attenuation coefficient.

I admit the use of a module parameter is ugly, but I didn't find a sane
way to fix this - especially since the magic registers we're changing
are undocumented.

Signed-off-by: Olaf Kirch <okir@suse.de>
Acked-by: Jean Delvare <jdelvare@suse.de>
---
 drivers/net/natsemi.c |   13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

Patch was sent upstream on November 24th, 2011:
http://marc.info/?l=linux-netdev&m=132214231615721&w=2
It was rejected because upstream doesn't like the implementation:
http://marc.info/?l=linux-netdev&m=134250277517368&w=2

Put in short, they don't want a module parameter, instead they want a
private ethtool flag. No driver implements this today (as of kernel
v3.5) and it is only supported starting with ethtool v3.2. Relevant
ethtool patches are:
http://git.kernel.org/?p=network/ethtool/ethtool.git;a=commit;h=d7c4a37aaaa302315b6f22b2cdbb031d4341f8da
http://git.kernel.org/?p=network/ethtool/ethtool.git;a=commit;h=e1ee596326ae84091056ba7b390b810f607fa412

--- a/drivers/net/natsemi.c
+++ b/drivers/net/natsemi.c
@@ -83,6 +83,9 @@ static int rx_copybreak;
 
 static int dspcfg_workaround = 1;
 
+/* Set to disable cable magic - needed for very long cables on some chips */
+static int no_cable_magic;
+
 /* Used to pass the media type, etc.
    Both 'options[]' and 'full_duplex[]' should exist for driver
    interoperability.
@@ -141,6 +144,7 @@ module_param(mtu, int, 0);
 module_param(debug, int, 0);
 module_param(rx_copybreak, int, 0);
 module_param(dspcfg_workaround, int, 0);
+module_param(no_cable_magic, int, 0);
 module_param_array(options, int, NULL, 0);
 module_param_array(full_duplex, int, NULL, 0);
 MODULE_PARM_DESC(mtu, "DP8381x MTU (all boards)");
@@ -148,6 +152,9 @@ MODULE_PARM_DESC(debug, "DP8381x default
 MODULE_PARM_DESC(rx_copybreak,
 	"DP8381x copy breakpoint for copy-only-tiny-frames");
 MODULE_PARM_DESC(dspcfg_workaround, "DP8381x: control DspCfg workaround");
+MODULE_PARM_DESC(no_cable_magic,
+	"DP8381x: set to 1 to disable magic workaround for short cables "
+	"(may help with long cables");
 MODULE_PARM_DESC(options,
 	"DP8381x: Bits 0-3: media type, bit 17: full duplex");
 MODULE_PARM_DESC(full_duplex, "DP8381x full duplex setting(s) (1)");
@@ -1219,7 +1226,7 @@ static void init_phy_fixup(struct net_de
 		writew(1, ioaddr + PGSEL);
 		writew(PMDCSR_VAL, ioaddr + PMDCSR);
 		writew(TSTDAT_VAL, ioaddr + TSTDAT);
-		np->dspcfg = (np->srr <= SRR_DP83815_C)?
+		np->dspcfg = (np->srr <= SRR_DP83815_C || no_cable_magic)?
 			DSPCFG_VAL : (DSPCFG_COEF | readw(ioaddr + DSPCFG));
 		writew(np->dspcfg, ioaddr + DSPCFG);
 		writew(SDCFG_VAL, ioaddr + SDCFG);
@@ -1585,7 +1592,7 @@ static void do_cable_magic(struct net_de
 	if (dev->if_port != PORT_TP)
 		return;
 
-	if (np->srr >= SRR_DP83816_A5)
+	if (np->srr >= SRR_DP83816_A5 || no_cable_magic)
 		return;
 
 	/*
@@ -1630,7 +1637,7 @@ static void undo_cable_magic(struct net_
 	if (dev->if_port != PORT_TP)
 		return;
 
-	if (np->srr >= SRR_DP83816_A5)
+	if (np->srr >= SRR_DP83816_A5 || no_cable_magic)
 		return;
 
 	writew(1, ioaddr + PGSEL);
