From: Tao Ma <tao.ma@oracle.com>
Date: Thu, 12 Aug 2010 10:25:28 +0800
Subject: ocfs2: pass struct file* to ocfs2_write_begin_nolock.
Patch-mainline: v2.6.37

struct file * has file_ra_state to store the readahead state
and data. So pass this to ocfs2_write_begin_nolock so that
it can be used in ocfs2_refcount_cow.

Signed-off-by: Tao Ma <tao.ma@oracle.com>
Signed-off-by: Mark Fasheh <mfasheh@suse.com>
---
 fs/ocfs2/aops.c |    5 +++--
 fs/ocfs2/aops.h |    3 ++-
 fs/ocfs2/mmap.c |    7 ++++---
 3 files changed, 9 insertions(+), 6 deletions(-)

Index: linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/aops.c
===================================================================
--- linux-2.6.32-ocfs2-update-2.6.37-fixes.orig/fs/ocfs2/aops.c
+++ linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/aops.c
@@ -1664,7 +1664,8 @@ static int ocfs2_zero_tail(struct inode
 	return ret;
 }
 
-int ocfs2_write_begin_nolock(struct address_space *mapping,
+int ocfs2_write_begin_nolock(struct file *filp,
+			     struct address_space *mapping,
 			     loff_t pos, unsigned len, unsigned flags,
 			     struct page **pagep, void **fsdata,
 			     struct buffer_head *di_bh, struct page *mmap_page)
@@ -1875,7 +1876,7 @@ static int ocfs2_write_begin(struct file
 	 */
 	down_write(&OCFS2_I(inode)->ip_alloc_sem);
 
-	ret = ocfs2_write_begin_nolock(mapping, pos, len, flags, pagep,
+	ret = ocfs2_write_begin_nolock(file, mapping, pos, len, flags, pagep,
 				       fsdata, di_bh, NULL);
 	if (ret) {
 		mlog_errno(ret);
Index: linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/aops.h
===================================================================
--- linux-2.6.32-ocfs2-update-2.6.37-fixes.orig/fs/ocfs2/aops.h
+++ linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/aops.h
@@ -48,7 +48,8 @@ int ocfs2_write_end_nolock(struct addres
 			   loff_t pos, unsigned len, unsigned copied,
 			   struct page *page, void *fsdata);
 
-int ocfs2_write_begin_nolock(struct address_space *mapping,
+int ocfs2_write_begin_nolock(struct file *filp,
+			     struct address_space *mapping,
 			     loff_t pos, unsigned len, unsigned flags,
 			     struct page **pagep, void **fsdata,
 			     struct buffer_head *di_bh, struct page *mmap_page);
Index: linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/mmap.c
===================================================================
--- linux-2.6.32-ocfs2-update-2.6.37-fixes.orig/fs/ocfs2/mmap.c
+++ linux-2.6.32-ocfs2-update-2.6.37-fixes/fs/ocfs2/mmap.c
@@ -59,10 +59,11 @@ static int ocfs2_fault(struct vm_area_st
 	return ret;
 }
 
-static int __ocfs2_page_mkwrite(struct inode *inode, struct buffer_head *di_bh,
+static int __ocfs2_page_mkwrite(struct file *file, struct buffer_head *di_bh,
 				struct page *page)
 {
 	int ret;
+	struct inode *inode = file->f_path.dentry->d_inode;
 	struct address_space *mapping = inode->i_mapping;
 	loff_t pos = page_offset(page);
 	unsigned int len = PAGE_CACHE_SIZE;
@@ -111,7 +112,7 @@ static int __ocfs2_page_mkwrite(struct i
 	if (page->index == last_index)
 		len = ((size - 1) & ~PAGE_CACHE_MASK) + 1;
 
-	ret = ocfs2_write_begin_nolock(mapping, pos, len, 0, &locked_page,
+	ret = ocfs2_write_begin_nolock(file, mapping, pos, len, 0, &locked_page,
 				       &fsdata, di_bh, page);
 	if (ret) {
 		if (ret != -ENOSPC)
@@ -159,7 +160,7 @@ static int ocfs2_page_mkwrite(struct vm_
 	 */
 	down_write(&OCFS2_I(inode)->ip_alloc_sem);
 
-	ret = __ocfs2_page_mkwrite(inode, di_bh, page);
+	ret = __ocfs2_page_mkwrite(vma->vm_file, di_bh, page);
 
 	up_write(&OCFS2_I(inode)->ip_alloc_sem);
 
