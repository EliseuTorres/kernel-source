From: Ales Novak <alnovak@suse.cz>
Date: Thu, 27 Nov 2014 17:38:08 +0100
Subject: [PATCH 2/2] xfs: recheck buffer pinned status after push trylock
 failure
References: bnc#907338
Git-commit: 5337fe9b108d602c483fe9d62ffef9227acf3a74
Patch-mainline: v3.9-rc1

The buffer pinned check and trylock sequence in xfs_buf_item_push()
can race with an active transaction on marking the buffer pinned.
This can result in the buffer becoming pinned and stale after the
initial check and the trylock failure, but before the check in
xfs_buf_trylock() that issues a log force. If the log force is
issued from this context, a spinlock recursion occurs on xa_lock.

Prepare xfs_buf_item_push() to handle the race by detecting a
pinned buffer after the trylock failure so xfsaild issues a log
force from a safe context. This, along with various previous fixes,
renders the log force in xfs_buf_trylock() redundant.

Signed-off-by: Brian Foster <bfoster@redhat.com>
Reviewed-by: Dave Chinner <dchinner@redhat.com>
Signed-off-by: Ben Myers <bpm@sgi.com>
Acked-by: Jan Kara <jack@suse.cz>

---
 fs/xfs/xfs_buf_item.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/fs/xfs/xfs_buf_item.c b/fs/xfs/xfs_buf_item.c
index 7888a75..1b68aed 100644
--- a/fs/xfs/xfs_buf_item.c
+++ b/fs/xfs/xfs_buf_item.c
@@ -483,8 +483,19 @@ xfs_buf_item_trylock(
 
 	if (XFS_BUF_ISPINNED(bp))
 		return XFS_ITEM_PINNED;
-	if (!XFS_BUF_CPSEMA(bp))
+	if (!XFS_BUF_CPSEMA(bp)) {
+		/*
+		 * If we have just raced with a buffer being pinned and it has
+		 * been marked stale, we could end up stalling until someone else
+		 * issues a log force to unpin the stale buffer. Check for the
+		 * race condition here so xfsaild recognizes the buffer is pinned
+		 * and queues a log force to move it along.
+		 */
+		if (XFS_BUF_ISPINNED(bp))
+			return XFS_ITEM_PINNED;
+
 		return XFS_ITEM_LOCKED;
+	}
 
 	/* take a reference to the buffer.  */
 	XFS_BUF_HOLD(bp);
-- 
1.8.1.4

