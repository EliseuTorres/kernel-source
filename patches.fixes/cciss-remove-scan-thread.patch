From: Mike Miller <mike.miller@hp.com>
Subject: cciss: remove scan thread
References: bnc#578429
Patch-mainline: no

Since it seems a useless feature this patch removes the scan thread.

Although the thread concept was simple, i.e., add a new volume to the
driver's view of the world for the MSA2012, it's implementation never
really worked.  There were too many corner cases of unit attention
storms, a scan starting in the middle of an already running scan, etc.

The scan thread was intended to make life easier for those managing
MSA2x12 or MSA2x24 enclosures.  Those boxes have no method of
notifying the driver that the configuration has changed. So the scan
thread would run periodically to check for changes. One of the
problems we encountered was the thread firing 10,000 times a second.
IMO, it's best to be rid of the thread.

Signed-off-by: Mike Miller <mike.miller@hp.com>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---
 drivers/block/cciss.c |  166 ++------------------------------------------------
 drivers/block/cciss.h |    3 
 2 files changed, 8 insertions(+), 161 deletions(-)

Index: linux-2.6.32-SLE11-SP1/drivers/block/cciss.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/block/cciss.c
+++ linux-2.6.32-SLE11-SP1/drivers/block/cciss.c
@@ -53,7 +53,6 @@
 #include <scsi/scsi_ioctl.h>
 #include <linux/cdrom.h>
 #include <linux/scatterlist.h>
-#include <linux/kthread.h>
 
 #define CCISS_DRIVER_VERSION(maj,min,submin) ((maj<<16)|(min<<8)|(submin))
 #define DRIVER_NAME "HP CISS Driver (v 3.6.20)"
@@ -161,11 +160,6 @@ static struct board_type products[] = {
 #define MAX_CTLR_ORIG 	8
 
 static ctlr_info_t *hba[MAX_CTLR];
-
-static struct task_struct *cciss_scan_thread;
-static DEFINE_MUTEX(scan_mutex);
-static LIST_HEAD(scan_q);
-
 static void do_cciss_request(struct request_queue *q);
 static irqreturn_t do_cciss_intr(int irq, void *dev_id);
 static int cciss_open(struct block_device *bdev, fmode_t mode);
@@ -200,8 +194,6 @@ static int sendcmd_withirq_core(ctlr_inf
 static int process_sendcmd_error(ctlr_info_t *h, CommandList_struct *c);
 
 static void fail_all_cmds(unsigned long ctlr);
-static int add_to_scan_list(struct ctlr_info *h);
-static int scan_thread(void *data);
 static int check_for_unit_attention(ctlr_info_t *h, CommandList_struct *c);
 static void cciss_hba_release(struct device *dev);
 static void cciss_device_release(struct device *dev);
@@ -474,14 +466,15 @@ static void __devinit cciss_procinit(int
 #define to_drv(n) container_of(n, drive_info_struct, dev)
 
 static ssize_t host_store_rescan(struct device *dev,
-				 struct device_attribute *attr,
-				 const char *buf, size_t count)
+					struct device_attribute *attr,
+					const char *buf, size_t count)
 {
 	struct ctlr_info *h = to_hba(dev);
+	unsigned long flags;
 
-	add_to_scan_list(h);
-	wake_up_process(cciss_scan_thread);
-	wait_for_completion_interruptible(&h->scan_wait);
+	spin_lock_irqsave(CCISS_LOCK(h->ctlr), flags);
+	rebuild_lun_table(h, 0, 0);
+	spin_unlock_irqrestore(CCISS_LOCK(h->ctlr), flags);
 
 	return count;
 }
@@ -656,20 +649,11 @@ static ssize_t cciss_show_usage_count(st
 }
 static DEVICE_ATTR(usage_count, S_IRUGO, cciss_show_usage_count, NULL);
 
-static struct attribute *cciss_host_attrs[] = {
+static struct attribute_group *cciss_host_attr_groups[] = {
 	&dev_attr_rescan.attr,
 	NULL
 };
 
-static struct attribute_group cciss_host_attr_group = {
-	.attrs = cciss_host_attrs,
-};
-
-static const struct attribute_group *cciss_host_attr_groups[] = {
-	&cciss_host_attr_group,
-	NULL
-};
-
 static struct device_type cciss_host_type = {
 	.name		= "cciss_host",
 	.groups		= cciss_host_attr_groups,
@@ -3471,124 +3455,6 @@ static irqreturn_t do_cciss_intr(int irq
 	return IRQ_HANDLED;
 }
 
-/**
- * add_to_scan_list() - add controller to rescan queue
- * @h:		      Pointer to the controller.
- *
- * Adds the controller to the rescan queue if not already on the queue.
- *
- * returns 1 if added to the queue, 0 if skipped (could be on the
- * queue already, or the controller could be initializing or shutting
- * down).
- **/
-static int add_to_scan_list(struct ctlr_info *h)
-{
-	struct ctlr_info *test_h;
-	int found = 0;
-	int ret = 0;
-
-	if (h->busy_initializing)
-		return 0;
-
-	if (!mutex_trylock(&h->busy_shutting_down))
-		return 0;
-
-	mutex_lock(&scan_mutex);
-	list_for_each_entry(test_h, &scan_q, scan_list) {
-		if (test_h == h) {
-			found = 1;
-			break;
-		}
-	}
-	if (!found && !h->busy_scanning) {
-		INIT_COMPLETION(h->scan_wait);
-		list_add_tail(&h->scan_list, &scan_q);
-		ret = 1;
-	}
-	mutex_unlock(&scan_mutex);
-	mutex_unlock(&h->busy_shutting_down);
-
-	return ret;
-}
-
-/**
- * remove_from_scan_list() - remove controller from rescan queue
- * @h:			   Pointer to the controller.
- *
- * Removes the controller from the rescan queue if present. Blocks if
- * the controller is currently conducting a rescan.
- **/
-static void remove_from_scan_list(struct ctlr_info *h)
-{
-	struct ctlr_info *test_h, *tmp_h;
-	int scanning = 0;
-
-	mutex_lock(&scan_mutex);
-	list_for_each_entry_safe(test_h, tmp_h, &scan_q, scan_list) {
-		if (test_h == h) {
-			list_del(&h->scan_list);
-			complete_all(&h->scan_wait);
-			mutex_unlock(&scan_mutex);
-			return;
-		}
-	}
-	if (&h->busy_scanning)
-		scanning = 0;
-	mutex_unlock(&scan_mutex);
-
-	if (scanning)
-		wait_for_completion(&h->scan_wait);
-}
-
-/**
- * scan_thread() - kernel thread used to rescan controllers
- * @data:	 Ignored.
- *
- * A kernel thread used scan for drive topology changes on
- * controllers. The thread processes only one controller at a time
- * using a queue.  Controllers are added to the queue using
- * add_to_scan_list() and removed from the queue either after done
- * processing or using remove_from_scan_list().
- *
- * returns 0.
- **/
-static int scan_thread(void *data)
-{
-	struct ctlr_info *h;
-
-	while (1) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule();
-		if (kthread_should_stop())
-			break;
-
-		while (1) {
-			mutex_lock(&scan_mutex);
-			if (list_empty(&scan_q)) {
-				mutex_unlock(&scan_mutex);
-				break;
-			}
-
-			h = list_entry(scan_q.next,
-				       struct ctlr_info,
-				       scan_list);
-			list_del(&h->scan_list);
-			h->busy_scanning = 1;
-			mutex_unlock(&scan_mutex);
-
-			if (h) {
-				rebuild_lun_table(h, 0, 0);
-				complete_all(&h->scan_wait);
-				mutex_lock(&scan_mutex);
-				h->busy_scanning = 0;
-				mutex_unlock(&scan_mutex);
-			}
-		}
-	}
-
-	return 0;
-}
-
 static int check_for_unit_attention(ctlr_info_t *h, CommandList_struct *c)
 {
 	if (c->err_info->SenseInfo[2] != UNIT_ATTENTION)
@@ -3608,8 +3474,6 @@ static int check_for_unit_attention(ctlr
 	case REPORT_LUNS_CHANGED:
 		printk(KERN_WARNING "cciss%d: report LUN data "
 			"changed\n", h->ctlr);
-		add_to_scan_list(h);
-		wake_up_process(cciss_scan_thread);
 		return 1;
 	break;
 	case POWER_OR_RESET:
@@ -4257,8 +4121,6 @@ static int __devinit cciss_init_one(stru
 	hba[i]->ctlr = i;
 	hba[i]->pdev = pdev;
 
-	init_completion(&hba[i]->scan_wait);
-
 	if (cciss_create_hba_sysfs_entry(hba[i]))
 		goto clean0;
 
@@ -4449,7 +4311,6 @@ static void __devexit cciss_remove_one(s
 
 	mutex_lock(&hba[i]->busy_shutting_down);
 
-	remove_from_scan_list(hba[i]);
 	remove_proc_entry(hba[i]->devname, proc_cciss);
 	unregister_blkdev(hba[i]->major, hba[i]->devname);
 
@@ -4528,25 +4389,15 @@ static int __init cciss_init(void)
 	if (err)
 		return err;
 
-	/* Start the scan thread */
-	cciss_scan_thread = kthread_run(scan_thread, NULL, "cciss_scan");
-	if (IS_ERR(cciss_scan_thread)) {
-		err = PTR_ERR(cciss_scan_thread);
-		goto err_bus_unregister;
-	}
-
 	/* Register for our PCI devices */
 	err = pci_register_driver(&cciss_pci_driver);
 	if (err)
-		goto err_thread_stop;
+		goto err_bus_unregister;
 
 	return err;
 
-err_thread_stop:
-	kthread_stop(cciss_scan_thread);
 err_bus_unregister:
 	bus_unregister(&cciss_bus_type);
-
 	return err;
 }
 
@@ -4563,7 +4414,6 @@ static void __exit cciss_cleanup(void)
 			cciss_remove_one(hba[i]->pdev);
 		}
 	}
-	kthread_stop(cciss_scan_thread);
 	remove_proc_entry("driver/cciss", NULL);
 	bus_unregister(&cciss_bus_type);
 }
Index: linux-2.6.32-SLE11-SP1/drivers/block/cciss.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/block/cciss.h
+++ linux-2.6.32-SLE11-SP1/drivers/block/cciss.h
@@ -110,7 +110,6 @@ struct ctlr_info 
 	int			nr_frees; 
 	int			busy_configuring;
 	int			busy_initializing;
-	int			busy_scanning;
 	struct mutex		busy_shutting_down;
 
 	/* This element holds the zero based queue number of the last
@@ -126,8 +125,6 @@ struct ctlr_info 
 	/* and saved for later processing */
 #endif
 	unsigned char alive;
-	struct list_head scan_list;
-	struct completion scan_wait;
 	struct device dev;
 };
 
