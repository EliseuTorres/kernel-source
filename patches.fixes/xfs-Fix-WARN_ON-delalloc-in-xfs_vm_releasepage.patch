From: Jan Kara <jack@suse.cz>
Date: Thu, 14 Mar 2013 12:10:49 +0100
Subject: [PATCH] xfs: Fix WARN_ON(delalloc) in xfs_vm_releasepage()
Patch-mainline: 3.9 (submitted)
References: bnc#806631

When a dirty page is truncated from a file but reclaim gets to it before
truncate_inode_pages(), we hit WARN_ON(delalloc) in
xfs_vm_releasepage(). This is because reclaim tries to write the page,
xfs_vm_writepage() just bails out (leaving page clean) and thus reclaim
thinks it can continue and calls xfs_vm_releasepage() on page with dirty
buffers.

Fix the issue by redirtying the page in xfs_vm_writepage(). This makes
reclaim stop reclaiming the page and also logically it keeps page in a
more consistent state where page with dirty buffers has PageDirty set.

Signed-off-by: Jan Kara <jack@suse.cz>
---
 fs/xfs/xfs_aops.c |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)

Index: linux-3.0-SLE11-SP2/fs/xfs/linux-2.6/xfs_aops.c
===================================================================
--- linux-3.0-SLE11-SP2.orig/fs/xfs/linux-2.6/xfs_aops.c
+++ linux-3.0-SLE11-SP2/fs/xfs/linux-2.6/xfs_aops.c
@@ -949,16 +949,20 @@ xfs_vm_writepage(
 	if ((current->flags & PF_FSTRANS) && (delalloc || unwritten))
 		goto redirty;
 
-	/* Is this page beyond the end of the file? */
+	/*
+	 * Is this page beyond the end of the file?  Skip the page if it is
+	 * fully outside i_size, e.g. due to a truncate operation that is in
+	 * progress. We must redirty the page so that reclaim stops reclaiming
+	 * it. Otherwise xfs_vm_releasepage() is called on it and gets
+	 * confused.
+	 */
 	offset = i_size_read(inode);
 	end_index = offset >> PAGE_CACHE_SHIFT;
 	last_index = (offset - 1) >> PAGE_CACHE_SHIFT;
 	if (page->index >= end_index) {
 		if ((page->index >= end_index + 1) ||
-		    !(i_size_read(inode) & (PAGE_CACHE_SIZE - 1))) {
-			unlock_page(page);
-			return 0;
-		}
+		    !(i_size_read(inode) & (PAGE_CACHE_SIZE - 1)))
+			goto redirty;
 	}
 
 	end_offset = min_t(unsigned long long,
