From: Michal Kubecek <mkubecek@suse.cz>
Subject: novfs: fix some DirCache locking issues
References: bnc#669378
Patch-mainline: no

- prevent double unlock in verify_dentry()
- add locks where missing
- add missing checks of novfs_lock_inode_cache() return value

Reported-by: Jeremy Meldrum <jmeldrum@novell.com>
Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
Acked-by: Jan Kara <jack@suse.cz>
---
 fs/novfs/inode.c |  178 +++++++++++++++++++++++++++++++-----------------------
 1 files changed, 103 insertions(+), 75 deletions(-)

diff --git a/fs/novfs/inode.c b/fs/novfs/inode.c
index f1770fa..a549560 100644
--- a/fs/novfs/inode.c
+++ b/fs/novfs/inode.c
@@ -346,9 +346,10 @@ int novfs_remove_from_root(char *RemoveName)
 
 	dir = novfs_root->d_inode;
 
-	novfs_lock_inode_cache(dir);
-	novfs_remove_inode_entry(dir, &name, 0);
-	novfs_unlock_inode_cache(dir);
+	if (novfs_lock_inode_cache(dir)) {
+		novfs_remove_inode_entry(dir, &name, 0);
+		novfs_unlock_inode_cache(dir);
+	}
 
 	return (0);
 }
@@ -368,21 +369,21 @@ int novfs_add_to_root(char *AddName)
 
 	dir = novfs_root->d_inode;
 
-	novfs_lock_inode_cache(dir);
+	if (novfs_lock_inode_cache(dir)) {
+		ino = 0;
 
-	ino = 0;
+		if (!novfs_lookup_inode_cache(dir, &name, 0)) {
+			info.mode = S_IFDIR | 0700;
+			info.size = 0;
+			info.atime = info.ctime = info.mtime = CURRENT_TIME;
 
-	if (!novfs_lookup_inode_cache(dir, &name, 0)) {
-		info.mode = S_IFDIR | 0700;
-		info.size = 0;
-		info.atime = info.ctime = info.mtime = CURRENT_TIME;
+			ino = (ino_t) atomic_inc_return(&novfs_Inode_Number);
+			novfs_add_inode_entry(dir, &name, ino, &info);
+		}
 
-		ino = (ino_t) atomic_inc_return(&novfs_Inode_Number);
-		novfs_add_inode_entry(dir, &name, ino, &info);
+		novfs_unlock_inode_cache(dir);
 	}
 
-	novfs_unlock_inode_cache(dir);
-
 	return (0);
 }
 
@@ -519,6 +520,7 @@ int verify_dentry(struct dentry *dentry, int Flags)
 					}
 				}
 				novfs_unlock_inode_cache(dir);
+				iLock = 0;
 			}
 
 			if (IS_ROOT(dentry->d_parent)) {
@@ -539,26 +541,28 @@ int verify_dentry(struct dentry *dentry, int Flags)
 				list = novfs_get_scopeusers();
 
 				iLock = novfs_lock_inode_cache(dir);
-				novfs_invalidate_inode_cache(dir);
-
-				if (list) {
-					cp = list;
-					while (*cp) {
-						name.name = cp;
-						name.len = strlen(cp);
-						name.hash = novfs_internal_hash(&name);
-						cp += (name.len + 1);
-						ino = 0;
-						if (novfs_get_entry(dir, &name, &ino, info)) {
-							info->mode = S_IFDIR | 0700;
-							info->size = 0;
-							info->atime = info->ctime = info->mtime = CURRENT_TIME;
-							ino = (ino_t) atomic_inc_return(&novfs_Inode_Number);
-							novfs_add_inode_entry(dir, &name, ino, info);
+				if (iLock) {
+					novfs_invalidate_inode_cache(dir);
+
+					if (list) {
+						cp = list;
+						while (*cp) {
+							name.name = cp;
+							name.len = strlen(cp);
+							name.hash = novfs_internal_hash(&name);
+							cp += (name.len + 1);
+							ino = 0;
+							if (novfs_get_entry(dir, &name, &ino, info)) {
+								info->mode = S_IFDIR | 0700;
+								info->size = 0;
+								info->atime = info->ctime = info->mtime = CURRENT_TIME;
+								ino = (ino_t) atomic_inc_return(&novfs_Inode_Number);
+								novfs_add_inode_entry(dir, &name, ino, info);
+							}
 						}
 					}
+					novfs_free_invalid_entries(dir);
 				}
-				novfs_free_invalid_entries(dir);
 			} else {
 
 				path = novfs_dget_path(dentry, info->name, PATH_LENGTH_BUFFER);
@@ -572,13 +576,15 @@ int verify_dentry(struct dentry *dentry, int Flags)
 						if (0 == retVal) {
 							dentry->d_time = jiffies + (novfs_update_timeout * HZ);
 							iLock = novfs_lock_inode_cache(dir);
-							if (novfs_update_entry(dir, &name, 0, info)) {
-								if (dentry->d_inode) {
-									ino = dentry->d_inode->i_ino;
-								} else {
-									ino = (ino_t) atomic_inc_return(&novfs_Inode_Number);
+							if (iLock) {
+								if (novfs_update_entry(dir, &name, 0, info)) {
+									if (dentry->d_inode) {
+										ino = dentry->d_inode->i_ino;
+									} else {
+										ino = (ino_t) atomic_inc_return(&novfs_Inode_Number);
+									}
+									novfs_add_inode_entry(dir, &name, ino, info);
 								}
-								novfs_add_inode_entry(dir, &name, ino, info);
 							}
 							if (dentry->d_inode) {
 								update_inode(dentry->d_inode, info);
@@ -593,18 +599,20 @@ int verify_dentry(struct dentry *dentry, int Flags)
 						} else if (-EINTR != retVal) {
 							retVal = 0;
 							iLock = novfs_lock_inode_cache(dir);
-							novfs_remove_inode_entry(dir, &name, 0);
-							if (dentry->d_inode && !(dentry->d_inode->i_flags & S_DEAD)) {
-								dentry->d_inode->i_flags |= S_DEAD;
-								dentry->d_inode->i_size = 0;
-								dentry->d_inode->i_atime.tv_sec =
-								    dentry->d_inode->i_atime.tv_nsec =
-								    dentry->d_inode->i_ctime.tv_sec =
-								    dentry->d_inode->i_ctime.tv_nsec =
-								    dentry->d_inode->i_mtime.tv_sec =
-								    dentry->d_inode->i_mtime.tv_nsec = 0;
-								dentry->d_inode->i_blocks = 0;
-								d_delete(dentry);	/* Remove from cache */
+							if (iLock) {
+								novfs_remove_inode_entry(dir, &name, 0);
+								if (dentry->d_inode && !(dentry->d_inode->i_flags & S_DEAD)) {
+									dentry->d_inode->i_flags |= S_DEAD;
+									dentry->d_inode->i_size = 0;
+									dentry->d_inode->i_atime.tv_sec =
+									    dentry->d_inode->i_atime.tv_nsec =
+									    dentry->d_inode->i_ctime.tv_sec =
+									    dentry->d_inode->i_ctime.tv_nsec =
+									    dentry->d_inode->i_mtime.tv_sec =
+									    dentry->d_inode->i_mtime.tv_nsec = 0;
+									dentry->d_inode->i_blocks = 0;
+									d_delete(dentry);	/* Remove from cache */
+								}
 							}
 						}
 					} else {
@@ -1363,13 +1371,13 @@ int novfs_f_open(struct inode *inode, struct file *file)
 
 					if (parent && parent->d_inode) {
 						struct inode *dir = parent->d_inode;
-						novfs_lock_inode_cache(dir);
-						ino = 0;
-						if (novfs_get_entry(dir, &file->f_dentry->d_name, &ino, info)) {
-							((struct inode_data *)inode->i_private)->Flags |= UPDATE_INODE;
+						if (novfs_lock_inode_cache(dir)) {
+							ino = 0;
+							if (novfs_get_entry(dir, &file->f_dentry->d_name, &ino, info)) {
+								((struct inode_data *)inode->i_private)->Flags |= UPDATE_INODE;
+							}
+							novfs_unlock_inode_cache(dir);
 						}
-
-						novfs_unlock_inode_cache(dir);
 					}
 					dput(parent);
 				}
@@ -2539,7 +2547,10 @@ int novfs_i_unlink(struct inode *dir, struct dentry *dentry)
 						}
 					}
 					if (!retCode || IS_DEADDIR(inode)) {
-						novfs_remove_inode_entry(dir, &dentry->d_name, 0);
+						if (novfs_lock_inode_cache(dir)) {
+							novfs_remove_inode_entry(dir, &dentry->d_name, 0);
+							novfs_unlock_inode_cache(dir);
+						}
 						dentry->d_time = 0;
 						t64 = 0;
 						novfs_scope_set_userspace(&t64, &t64, &t64, &t64);
@@ -2601,11 +2612,12 @@ int novfs_i_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 
 							dentry->d_time = jiffies + (novfs_update_timeout * HZ);
 
-							novfs_lock_inode_cache(dir);
-							if (novfs_update_entry(dir, &dentry->d_name, 0, &info)) {
-								novfs_add_inode_entry(dir, &dentry->d_name, inode->i_ino, &info);
+							if (novfs_lock_inode_cache(dir)) {
+								if (novfs_update_entry(dir, &dentry->d_name, 0, &info)) {
+									novfs_add_inode_entry(dir, &dentry->d_name, inode->i_ino, &info);
+								}
+								novfs_unlock_inode_cache(dir);
 							}
-							novfs_unlock_inode_cache(dir);
 						}
 
 					}
@@ -2651,9 +2663,10 @@ int novfs_i_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
 		novfs_d_add(parent, dentry, inode, 0);
 		memset(&info, 0, sizeof(info));
 		info.mode = inode->i_mode;
-		novfs_lock_inode_cache(dir);
-		novfs_add_inode_entry(dir, &dentry->d_name, inode->i_ino, &info);
-		novfs_unlock_inode_cache(dir);
+		if (novfs_lock_inode_cache(dir)) {
+			novfs_add_inode_entry(dir, &dentry->d_name, inode->i_ino, &info);
+			novfs_unlock_inode_cache(dir);
+		}
 
 		dput(parent);
 
@@ -2768,17 +2781,23 @@ int novfs_i_rename(struct inode *odir, struct dentry *od, struct inode *ndir, st
 							if (!retCode) {
 								info = (struct novfs_entry_info *)oldbuf;
 								od->d_time = 0;
-								novfs_remove_inode_entry(odir, &od->d_name, 0);
-								novfs_remove_inode_entry(ndir, &nd->d_name, 0);
-								novfs_get_file_info(newpath, info, session);
-								nd->d_time = jiffies + (novfs_update_timeout * HZ);
-
-								if (od->d_inode && od->d_inode->i_ino) {
-									ino = od->d_inode->i_ino;
-								} else {
-									ino = (ino_t) atomic_inc_return(&novfs_Inode_Number);
+								if (novfs_lock_inode_cache(odir)) {
+									novfs_remove_inode_entry(odir, &od->d_name, 0);
+									novfs_unlock_inode_cache(odir);
+								}
+								if (novfs_lock_inode_cache(ndir)) {
+									novfs_remove_inode_entry(ndir, &nd->d_name, 0);
+									novfs_get_file_info(newpath, info, session);
+									nd->d_time = jiffies + (novfs_update_timeout * HZ);
+
+									if (od->d_inode && od->d_inode->i_ino) {
+										ino = od->d_inode->i_ino;
+									} else {
+										ino = (ino_t) atomic_inc_return(&novfs_Inode_Number);
+									}
+									novfs_add_inode_entry(ndir, &nd->d_name, ino, info);
+									novfs_unlock_inode_cache(ndir);
 								}
-								novfs_add_inode_entry(ndir, &nd->d_name, ino, info);
 							}
 						}
 					}
@@ -3175,7 +3194,10 @@ void novfs_clear_inode(struct inode *inode)
 
 		DbgPrint("inode=0x%p ino=%d Scope=0x%p Name=%s", inode, inode->i_ino, id->Scope, id->Name);
 
-		novfs_free_inode_cache(inode);
+		if (novfs_lock_inode_cache(inode)) {
+			novfs_free_inode_cache(inode);
+			novfs_unlock_inode_cache(inode);
+		}
 
 		down(&InodeList_lock);
 		list_del(&id->IList);
@@ -3420,7 +3442,10 @@ int novfs_fill_super(struct super_block *SB, void *Data, int Silent)
 				server->d_time = 0xffffffff;
 				d_add(server, inode);
 				DbgPrint("d_add %s 0x%p", SERVER_DIRECTORY_NAME, server);
-				novfs_add_inode_entry(novfs_root->d_inode, &name, inode->i_ino, &info);
+				if (novfs_lock_inode_cache(novfs_root->d_inode)) {
+					novfs_add_inode_entry(novfs_root->d_inode, &name, inode->i_ino, &info);
+					novfs_unlock_inode_cache(novfs_root->d_inode);
+				}
 			}
 		}
 
@@ -3443,7 +3468,10 @@ int novfs_fill_super(struct super_block *SB, void *Data, int Silent)
 
 				d_add(tree, inode);
 				DbgPrint("d_add %s 0x%p", TREE_DIRECTORY_NAME, tree);
-				novfs_add_inode_entry(novfs_root->d_inode, &name, inode->i_ino, &info);
+				if (novfs_lock_inode_cache(novfs_root->d_inode)) {
+					novfs_add_inode_entry(novfs_root->d_inode, &name, inode->i_ino, &info);
+					novfs_unlock_inode_cache(novfs_root->d_inode);
+				}
 			}
 		}
 	}
-- 
1.7.3.4

