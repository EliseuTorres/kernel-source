From 778d3b0ff0654ad7092bf823fd32010066b12365 Mon Sep 17 00:00:00 2001
From: Michal Hocko <mhocko@suse.cz>
Date: Tue, 26 Jul 2011 16:08:30 -0700
Subject: [PATCH] cpusets: randomize node rotor used in cpuset_mem_spread_node()
Patch-mainline: 778d3b0ff0654ad7092bf823fd32010066b12365
References: bnc#602150

mhocko@suse.cz:
We also have to move NUMA_NO_NODE to include/linux/numa.h because we need
it for all arch not just x86_64

Original patch:

[ This patch has already been accepted as commit 0ac0c0d0f837 but later
  reverted (commit 35926ff5fba8) because it itroduced arch specific
  __node_random which was defined only for x86 code so it broke other
  archs.  This is a followup without any arch specific code.  Other than
  that there are no functional changes.]

Some workloads that create a large number of small files tend to assign
too many pages to node 0 (multi-node systems).  Part of the reason is
that the rotor (in cpuset_mem_spread_node()) used to assign nodes starts
at node 0 for newly created tasks.

This patch changes the rotor to be initialized to a random node number
of the cpuset.

[akpm@linux-foundation.org: fix layout]
[lee.schermerhorn@hp.com: Define stub numa_random() for !NUMA configuration]
[mhocko@suse.cz: Make it arch independent]
[akpm@linux-foundation.org: fix CONFIG_NUMA=y, MAX_NUMNODES>1 build]
Signed-off-by: Jack Steiner <steiner@sgi.com>
Signed-off-by: Lee Schermerhorn <lee.schermerhorn@hp.com>
Signed-off-by: Michal Hocko <mhocko@suse.cz>
Reviewed-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Cc: Christoph Lameter <cl@linux-foundation.org>
Cc: Pekka Enberg <penberg@cs.helsinki.fi>
Cc: Paul Menage <menage@google.com>
Cc: Jack Steiner <steiner@sgi.com>
Cc: Robin Holt <holt@sgi.com>
Cc: David Rientjes <rientjes@google.com>
Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
Cc: Lee Schermerhorn <lee.schermerhorn@hp.com>
Cc: Michal Hocko <mhocko@suse.cz>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

---
 include/linux/bitmap.h   |    1 +
 include/linux/nodemask.h |   13 +++++++++++++
 kernel/cpuset.c          |    8 ++++++++
 kernel/fork.c            |    4 ++++
 lib/bitmap.c             |    2 +-
 mm/mempolicy.c           |   16 ++++++++++++++++
 6 files changed, 43 insertions(+), 1 deletions(-)

Index: linux-2.6.32-SLE11-SP1/include/linux/bitmap.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/bitmap.h
+++ linux-2.6.32-SLE11-SP1/include/linux/bitmap.h
@@ -130,6 +130,7 @@ extern int bitmap_find_free_region(unsig
 extern void bitmap_release_region(unsigned long *bitmap, int pos, int order);
 extern int bitmap_allocate_region(unsigned long *bitmap, int pos, int order);
 extern void bitmap_copy_le(void *dst, const unsigned long *src, int nbits);
+extern int bitmap_ord_to_pos(const unsigned long *bitmap, int n, int bits);
 
 #define BITMAP_LAST_WORD_MASK(nbits)					\
 (									\
Index: linux-2.6.32-SLE11-SP1/include/linux/nodemask.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/nodemask.h
+++ linux-2.6.32-SLE11-SP1/include/linux/nodemask.h
@@ -66,6 +66,8 @@
  * int num_online_nodes()		Number of online Nodes
  * int num_possible_nodes()		Number of all possible Nodes
  *
+ * int node_random(mask)		Random node with set bit in mask
+ *
  * int node_online(node)		Is some node online?
  * int node_possible(node)		Is some node possible?
  *
@@ -427,6 +429,7 @@ static inline void node_set_offline(int
 	node_clear_state(nid, N_ONLINE);
 	nr_online_nodes = num_node_state(N_ONLINE);
 }
+
 #else
 
 static inline int node_state(int node, enum node_states state)
@@ -457,6 +460,16 @@ static inline int num_node_state(enum no
 
 #define node_set_online(node)	   node_set_state((node), N_ONLINE)
 #define node_set_offline(node)	   node_clear_state((node), N_ONLINE)
+
+#endif
+
+#if defined(CONFIG_NUMA) && (MAX_NUMNODES > 1)
+extern int node_random(const nodemask_t *maskp);
+#else
+static inline int node_random(const nodemask_t *mask)
+{
+	return 0;
+}
 #endif
 
 #define node_online_map 	node_states[N_ONLINE]
Index: linux-2.6.32-SLE11-SP1/kernel/cpuset.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/kernel/cpuset.c
+++ linux-2.6.32-SLE11-SP1/kernel/cpuset.c
@@ -2431,8 +2431,12 @@ static int cpuset_spread_node(int rotor)
 
 int cpuset_mem_spread_node(void)
 {
-	int rotor = current->cpuset_mem_spread_rotor & 0xffff;
+	/* we have to cast to short because NUMA_NO_NODE is -1 */
+	int rotor = (short)(current->cpuset_mem_spread_rotor & 0xffff);
 	int rem = current->cpuset_mem_spread_rotor & 0xffff0000;
+	if (rotor == NUMA_NO_NODE)
+		rotor = node_random(&current->mems_allowed);
+
 	rotor = cpuset_spread_node(rotor);
 	current->cpuset_mem_spread_rotor = rotor | rem;
 	return rotor;
@@ -2440,9 +2444,15 @@ int cpuset_mem_spread_node(void)
 
 int cpuset_slab_spread_node(void)
 {
-	/* use the top half of rotor for slab rotor */
-	int rotor = (current->cpuset_mem_spread_rotor >> 16) & 0xffff;
+	/* use the top half of rotor for slab rotor
+	 * we have to cast to short because NUMA_NO_NODE is -1
+	 */
+	int rotor = (short) ((current->cpuset_mem_spread_rotor >> 16) & 0xffff);
 	int rem = current->cpuset_mem_spread_rotor & 0xffff;
+
+	if (rotor == NUMA_NO_NODE)
+		rotor = node_random(&current->mems_allowed);
+
 	rotor = cpuset_spread_node(rotor);
 	current->cpuset_mem_spread_rotor = (rotor << 16) | rem;
 	return rotor;
Index: linux-2.6.32-SLE11-SP1/kernel/fork.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/kernel/fork.c
+++ linux-2.6.32-SLE11-SP1/kernel/fork.c
@@ -1100,6 +1100,10 @@ static struct task_struct *copy_process(
  	}
 	mpol_fix_fork_child_flag(p);
 #endif
+#ifdef CONFIG_CPUSETS
+	/* slab rotor is embeded in the top 2 bytes */
+	p->cpuset_mem_spread_rotor = NUMA_NO_NODE | (NUMA_NO_NODE << 16);
+#endif
 #ifdef CONFIG_TRACE_IRQFLAGS
 	p->irq_events = 0;
 #ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW
Index: linux-2.6.32-SLE11-SP1/lib/bitmap.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/lib/bitmap.c
+++ linux-2.6.32-SLE11-SP1/lib/bitmap.c
@@ -591,7 +591,7 @@ static int bitmap_pos_to_ord(const unsig
  *
  * The bit positions 0 through @bits are valid positions in @buf.
  */
-static int bitmap_ord_to_pos(const unsigned long *buf, int ord, int bits)
+int bitmap_ord_to_pos(const unsigned long *buf, int ord, int bits)
 {
 	int pos = 0;
 
Index: linux-2.6.32-SLE11-SP1/mm/mempolicy.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/mm/mempolicy.c
+++ linux-2.6.32-SLE11-SP1/mm/mempolicy.c
@@ -92,6 +92,7 @@
 
 #include <asm/tlbflush.h>
 #include <asm/uaccess.h>
+#include <linux/random.h>
 
 #include "internal.h"
 
@@ -1536,6 +1537,21 @@ static inline unsigned interleave_nid(st
 		return interleave_nodes(pol);
 }
 
+/*
+ * Return the bit number of a random bit set in the nodemask.
+ * (returns -1 if nodemask is empty)
+ */
+int node_random(const nodemask_t *maskp)
+{
+	int w, bit = -1;
+
+	w = nodes_weight(*maskp);
+	if (w)
+		bit = bitmap_ord_to_pos(maskp->bits,
+			get_random_int() % w, MAX_NUMNODES);
+	return bit;
+}
+
 #ifdef CONFIG_HUGETLBFS
 /*
  * huge_zonelist(@vma, @addr, @gfp_flags, @mpol)
Index: linux-2.6.32-SLE11-SP1/arch/x86/include/asm/topology.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/include/asm/topology.h
+++ linux-2.6.32-SLE11-SP1/arch/x86/include/asm/topology.h
@@ -35,9 +35,6 @@
 # endif
 #endif
 
-/* Node not present */
-#define NUMA_NO_NODE	(-1)
-
 #ifdef CONFIG_NUMA
 #include <linux/cpumask.h>
 #include <asm/mpspec.h>
Index: linux-2.6.32-SLE11-SP1/include/linux/numa.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/numa.h
+++ linux-2.6.32-SLE11-SP1/include/linux/numa.h
@@ -10,4 +10,6 @@
 
 #define MAX_NUMNODES    (1 << NODES_SHIFT)
 
+#define NUMA_NO_NODE	(-1)
+
 #endif /* _LINUX_NUMA_H */
