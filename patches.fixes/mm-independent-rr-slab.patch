From: Jack Steiner <steiner@sgi.com>
Subject: independent rotors for slab and pagecache
References: bnc#600261
Patch-mainline: not yet (as of 2.6.34)

We have observed several workloads running on multi-node systems where
memory is assigned unevenly across the nodes in the system. There are
numerous reasons for this but one is the round-robin rotor in
cpuset_mem_spread_node().

For example, a simple test that writes a multi-page file will allocate pages
on nodes 0 2 4 6 ... Odd nodes are skipped.  (Sometimes it allocates on
odd nodes & skips even nodes).

An example is shown below. The program "lfile" writes a file consisting of
10 pages. The program then mmaps the file & uses get_mempolicy(...,
MPOL_F_NODE) to determine the nodes where the file pages were allocated.
The output is shown below:

	# ./lfile
	 allocated on nodes: 2 4 6 0 1 2 6 0 2



There is a single rotor that is used for allocating both file pages & slab
pages.  Writing the file allocates both a data page & a slab page
(buffer_head).  This advances the RR rotor 2 nodes for each page
allocated.

A quick confirmation seems to confirm this is the cause of the uneven
allocation:

	# echo 0 >/dev/cpuset/memory_spread_slab
	# ./lfile
	 allocated on nodes: 6 7 8 9 0 1 2 3 4 5


This patch introduces a second rotor that is used for slab allocations.


Signed-off-by: Jack Steiner <steiner@sgi.com>

Requires some complication to preserve the kABI -- fit rotors into 16 bits
each.

Acked-by: Nick Piggin <npiggin@suse.de>


---
 include/linux/cpuset.h |    6 ++++++
 include/linux/sched.h  |    1 +
 kernel/cpuset.c        |   20 ++++++++++++++++----
 mm/slab.c              |    2 +-
 4 files changed, 24 insertions(+), 5 deletions(-)

Index: linux-2.6.27/include/linux/cpuset.h
===================================================================
--- linux-2.6.27.orig/include/linux/cpuset.h
+++ linux-2.6.27/include/linux/cpuset.h
@@ -73,6 +73,7 @@ extern void cpuset_lock(void);
 extern void cpuset_unlock(void);
 
 extern int cpuset_mem_spread_node(void);
+extern int cpuset_slab_spread_node(void);
 
 static inline int cpuset_do_page_mem_spread(void)
 {
@@ -164,6 +165,11 @@ static inline int cpuset_mem_spread_node
 {
 	return 0;
 }
+
+static inline int cpuset_slab_spread_node(void)
+{
+	return 0;
+}
 
 static inline int cpuset_do_page_mem_spread(void)
 {
Index: linux-2.6.27/kernel/cpuset.c
===================================================================
--- linux-2.6.27.orig/kernel/cpuset.c
+++ linux-2.6.27/kernel/cpuset.c
@@ -2373,7 +2373,8 @@ void cpuset_unlock(void)
 }
 
 /**
- * cpuset_mem_spread_node() - On which node to begin search for a page
+ * cpuset_mem_spread_node() - On which node to begin search for a file page
+ * cpuset_slab_spread_node() - On which node to begin search for a slab page
  *
  * If a task is marked PF_SPREAD_PAGE or PF_SPREAD_SLAB (as for
  * tasks in a cpuset with is_spread_page or is_spread_slab set),
@@ -2398,16 +2399,35 @@ void cpuset_unlock(void)
  * See kmem_cache_alloc_node().
  */
 
-int cpuset_mem_spread_node(void)
+static int cpuset_spread_node(int rotor)
 {
 	int node;
 
-	node = next_node(current->cpuset_mem_spread_rotor, current->mems_allowed);
+	node = next_node(rotor, current->mems_allowed);
 	if (node == MAX_NUMNODES)
 		node = first_node(current->mems_allowed);
-	current->cpuset_mem_spread_rotor = node;
 	return node;
 }
+
+int cpuset_mem_spread_node(void)
+{
+	int rotor = current->cpuset_mem_spread_rotor & 0xffff;
+	int rem = current->cpuset_mem_spread_rotor & 0xffff0000;
+	rotor = cpuset_spread_node(rotor);
+	current->cpuset_mem_spread_rotor = rotor | rem;
+	return rotor;
+}
+
+int cpuset_slab_spread_node(void)
+{
+	/* use the top half of rotor for slab rotor */
+	int rotor = (current->cpuset_mem_spread_rotor >> 16) & 0xffff0000;
+	int rem = current->cpuset_mem_spread_rotor & 0xffff;
+	rotor = cpuset_spread_node(rotor);
+	current->cpuset_mem_spread_rotor = (rotor << 16) | rem;
+	return rotor;
+}
+
 EXPORT_SYMBOL_GPL(cpuset_mem_spread_node);
 
 /**
Index: linux-2.6.27/mm/slab.c
===================================================================
--- linux-2.6.27.orig/mm/slab.c
+++ linux-2.6.27/mm/slab.c
@@ -3126,7 +3126,7 @@ static void *alternate_node_alloc(struct
 		return NULL;
 	nid_alloc = nid_here = numa_node_id();
 	if (cpuset_do_slab_mem_spread() && (cachep->flags & SLAB_MEM_SPREAD))
-		nid_alloc = cpuset_mem_spread_node();
+		nid_alloc = cpuset_slab_spread_node();
 	else if (current->mempolicy)
 		nid_alloc = slab_node(current->mempolicy);
 	if (nid_alloc != nid_here)
