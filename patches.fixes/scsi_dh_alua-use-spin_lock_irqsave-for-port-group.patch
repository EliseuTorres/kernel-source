From: Hannes Reinecke <hare@suse.de>
Date: Thu, 7 Nov 2013 08:16:17 +0100
Subject: scsi_dh_alua: use spin_lock_irqsave for port group
References: bnc#708296
Patch-Mainline: posted to linux-scsi

The port group structure might be modified from an interrupt
context, so we need to use spin_lock_irqsave.

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/device_handler/scsi_dh_alua.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/drivers/scsi/device_handler/scsi_dh_alua.c b/drivers/scsi/device_handler/scsi_dh_alua.c
index 4df34a9..f83446c 100644
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@ -912,11 +912,12 @@ static void alua_rtpg_work(struct work_struct *work)
 	LIST_HEAD(qdata_list);
 	int err;
 	struct alua_queue_data *qdata, *tmp;
+	unsigned long flags;
 
-	spin_lock(&pg->rtpg_lock);
+	spin_lock_irqsave(&pg->rtpg_lock, flags);
 	pg->rtpg_sdev = NULL;
 	list_splice_init(&pg->rtpg_list, &qdata_list);
-	spin_unlock(&pg->rtpg_lock);
+	spin_unlock_irqrestore(&pg->rtpg_lock, flags);
 
 	err = alua_rtpg(sdev, pg);
 	if (err != SCSI_DH_OK || list_empty(&qdata_list))
@@ -940,12 +941,13 @@ static void alua_rtpg_queue(struct alua_port_group *pg,
 			    struct alua_queue_data *qdata)
 {
 	int start_queue = 0;
+	unsigned long flags;
 
 	if (!pg)
 		return;
 
 	kref_get(&pg->kref);
-	spin_lock(&pg->rtpg_lock);
+	spin_lock_irqsave(&pg->rtpg_lock, flags);
 	if (qdata)
 		list_add_tail(&qdata->entry, &pg->rtpg_list);
 	if (pg->rtpg_sdev == NULL) {
@@ -954,7 +956,7 @@ static void alua_rtpg_queue(struct alua_port_group *pg,
 		scsi_device_get(sdev);
 		start_queue = 1;
 	}
-	spin_unlock(&pg->rtpg_lock);
+	spin_unlock_irqrestore(&pg->rtpg_lock, flags);
 
 	if (start_queue)
 		queue_work(kmpath_aluad, &pg->rtpg_work);
-- 
1.7.12.4

