From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 17 Mar 2014 12:02:23 +0100
Subject: ipv6: fix net reference leak in IPv6 conntrack reassembly
Patch-mainline: Never, SLE11 specific code
References: bnc#865419

Fix for bnc#773577 releases the netns reference in fq_put() if a
frag queue was destroyed. However, a inet_frag_destroy() can be
called by inet_frag_evictor() (called by nf_ct_frag6_evictor())
in which case the netns reference isn't released, blocking the
namespace removal.

Set up a destructor to release the netns reference in all code
paths.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/inet_frag.h                 |  7 ++-----
 net/ipv6/netfilter/nf_conntrack_reasm.c | 14 ++++++++++----
 2 files changed, 12 insertions(+), 9 deletions(-)

diff --git a/include/net/inet_frag.h b/include/net/inet_frag.h
index c7a1711..b289bd2 100644
--- a/include/net/inet_frag.h
+++ b/include/net/inet_frag.h
@@ -74,13 +74,10 @@ struct inet_frag_queue *inet_frag_find(struct netns_frags *nf,
 void inet_frag_maybe_warn_overflow(struct inet_frag_queue *q,
 				   const char *prefix);
 
-static inline bool inet_frag_put(struct inet_frag_queue *q, struct inet_frags *f)
+static inline void inet_frag_put(struct inet_frag_queue *q, struct inet_frags *f)
 {
-	if (atomic_dec_and_test(&q->refcnt)) {
+	if (atomic_dec_and_test(&q->refcnt))
 		inet_frag_destroy(q, f, NULL);
-		return true;
-	}
-	return false;
 }
 
 #endif
diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
index f04ab7c..0278c53 100644
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
@@ -161,9 +161,15 @@ static void nf_ct_frag6_init_fq(struct inet_frag_queue *q, void *a)
 
 static __inline__ void fq_put(struct nf_ct_frag6_queue *fq)
 {
-	struct net *net = fq->net;
-	if (inet_frag_put(&fq->q, &nf_frags))
-		put_net(net);
+	inet_frag_put(&fq->q, &nf_frags);
+}
+
+static void nf_ct_frag6_fq_destructor(struct inet_frag_queue *q)
+{
+	struct nf_ct_frag6_queue *fq;
+
+	fq = container_of(q, struct nf_ct_frag6_queue, q);
+	put_net(fq->net);
 }
 
 /* Kill fq entry. It is not destroyed immediately,
@@ -707,7 +713,7 @@ int nf_ct_frag6_init(void)
 {
 	nf_frags.hashfn = nf_hashfn;
 	nf_frags.constructor = nf_ct_frag6_init_fq;
-	nf_frags.destructor = NULL;
+	nf_frags.destructor = nf_ct_frag6_fq_destructor;
 	nf_frags.skb_free = nf_skb_free;
 	nf_frags.qsize = sizeof(struct nf_ct_frag6_queue);
 	nf_frags.match = nf_ct_frag6_match;
-- 
1.8.4.5

