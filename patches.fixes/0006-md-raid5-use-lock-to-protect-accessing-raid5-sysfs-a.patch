From: NeilBrown <neilb@suse.de>
Date: Mon, 15 Dec 2014 12:56:59 +1100
Subject: md/raid5: use ->lock to protect accessing raid5 sysfs attributes.
References: bnc#912183
Patch-Mainline: v4.0-rc1
Git-commit: 7b1485bab9c49b0d3811d72beb0de60c7b8b337d

It is important that mddev->private isn't freed while
a sysfs attribute function is accessing it.

So use mddev->lock to protect the setting of ->private to NULL, and
take that lock when checking ->private for NULL and de-referencing it
in the sysfs access functions.

This only applies to the read ('show') side of access.  Write
access will be handled separately.

Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/md/raid5.c |   37 ++++++++++++++++++++++++-------------
 1 file changed, 24 insertions(+), 13 deletions(-)

--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -5106,11 +5106,14 @@ static void raid5d(struct md_thread *thr
 static ssize_t
 raid5_show_stripe_cache_size(struct mddev *mddev, char *page)
 {
-	struct r5conf *conf = mddev->private;
+	struct r5conf *conf;
+	int ret = 0;
+	spin_lock(&mddev->write_lock);
+	conf = mddev->private;
 	if (conf)
-		return sprintf(page, "%d\n", conf->max_nr_stripes);
-	else
-		return 0;
+		ret = sprintf(page, "%d\n", conf->max_nr_stripes);
+	spin_unlock(&mddev->write_lock);
+	return ret;
 }
 
 int
@@ -5167,11 +5170,14 @@ raid5_stripecache_size = __ATTR(stripe_c
 static ssize_t
 raid5_show_preread_threshold(struct mddev *mddev, char *page)
 {
-	struct r5conf *conf = mddev->private;
+	struct r5conf *conf;
+	int ret = 0;
+	spin_lock(&mddev->write_lock);
+	conf = mddev->private;
 	if (conf)
-		return sprintf(page, "%d\n", conf->bypass_threshold);
-	else
-		return 0;
+		ret = sprintf(page, "%d\n", conf->bypass_threshold);
+	spin_unlock(&mddev->write_lock);
+	return ret;
 }
 
 static ssize_t
@@ -5214,11 +5220,14 @@ raid5_stripecache_active = __ATTR_RO(str
 static ssize_t
 raid5_show_group_thread_cnt(struct mddev *mddev, char *page)
 {
-	struct r5conf *conf = mddev->private;
+	struct r5conf *conf;
+	int ret = 0;
+	spin_lock(&mddev->write_lock);
+	conf = mddev->private;
 	if (conf)
-		return sprintf(page, "%d\n", conf->worker_cnt_per_group);
-	else
-		return 0;
+		ret = sprintf(page, "%d\n", conf->worker_cnt_per_group);
+	spin_unlock(&mddev->write_lock);
+	return ret;
 }
 
 static int alloc_thread_groups(struct r5conf *conf, int cnt,
@@ -6005,11 +6014,13 @@ static int stop(struct mddev *mddev)
 {
 	struct r5conf *conf = mddev->private;
 
+	spin_lock(&mddev->write_lock);
+	mddev->private = NULL;
+	spin_unlock(&mddev->write_lock);
 	md_unregister_thread(&mddev->thread);
 	if (mddev->queue)
 		mddev->queue->backing_dev_info.congested_fn = NULL;
 	free_conf(conf);
-	mddev->private = NULL;
 	mddev->to_remove = &raid5_attrs_group;
 	return 0;
 }
