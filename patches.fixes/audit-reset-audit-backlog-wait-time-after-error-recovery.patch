From: Richard Guy Briggs <rgb@redhat.com>
Date: Thu Sep 12 23:03:51 2013 -0400
Subject: audit: reset audit backlog wait time after error recovery
Git-commit: e789e561a50de0aaa8c695662d97aaa5eac9d55f
Patch-mainline: v3.15-rc1
References: bnc#908393
Signed-off-by: Tony Jones <tonyj@suse.de>

    audit: reset audit backlog wait time after error recovery
    
    When the audit queue overflows and times out (audit_backlog_wait_time), the
    audit queue overflow timeout is set to zero.  Once the audit queue overflow
    timeout condition recovers, the timeout should be reset to the original value.
    
    See also:
    	https://lkml.org/lkml/2013/9/2/473
    
    Cc: stable@vger.kernel.org # v3.8-rc4+
    Signed-off-by: Luiz Capitulino <lcapitulino@redhat.com>
    Signed-off-by: Dan Duval <dan.duval@oracle.com>
    Signed-off-by: Chuck Anderson <chuck.anderson@oracle.com>
    Signed-off-by: Richard Guy Briggs <rgb@redhat.com>
    Signed-off-by: Eric Paris <eparis@redhat.com>

diff --git a/kernel/audit.c b/kernel/audit.c
index dd18747..6cd2ecc 100644
--- a/kernel/audit.c
+++ b/kernel/audit.c
@@ -103,7 +103,8 @@ static int	audit_rate_limit;
 
 /* Number of outstanding audit_buffers allowed. */
 static int	audit_backlog_limit = 64;
-static int	audit_backlog_wait_time = 60 * HZ;
+#define AUDIT_BACKLOG_WAIT_TIME (60 * HZ)
+static int	audit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;
 static int	audit_backlog_wait_overflow = 0;
 
 /* The identity of the user shutting down the audit system. */
@@ -1282,6 +1283,8 @@ struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,
 		return NULL;
 	}
 
+	audit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;
+
 	ab = audit_buffer_alloc(ctx, gfp_mask, type);
 	if (!ab) {
 		audit_log_lost("out of memory in audit_log_start");
