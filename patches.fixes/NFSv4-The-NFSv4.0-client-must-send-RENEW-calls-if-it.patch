From: Trond Myklebust <Trond.Myklebust@netapp.com>
Date: Wed, 24 Aug 2011 15:07:37 -0400
Subject: NFSv4: The NFSv4.0 client must send RENEW calls if it
 holds a delegation
Git-commit: 2f60ea6b8ceda61ae08bef71a652eac36ec193b3
Patch-mainline: v3.1
References: bnc#863873

RFC3530 states that if the client holds a delegation, then it is obliged
to continue to send RENEW calls once every lease period in order to allow
the server to return NFS4ERR_CB_PATH_DOWN if the callback path is
unreachable.

This is not required for NFSv4.1, since the server can at any time set
the SEQ4_STATUS_CB_PATH_DOWN_SESSION in any SEQUENCE operation.

Patch has been modified to hide necessary kABI change behind __GENKSYMS__.
If a module were to use the old ABI, it would still work.

Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/nfs/nfs4_fs.h    |    6 ++++++
 fs/nfs/nfs4proc.c   |   28 ++++++++++++++++++++++++++--
 fs/nfs/nfs4renewd.c |   19 ++++++++++++++++---
 3 files changed, 48 insertions(+), 5 deletions(-)

--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4_fs.h
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4_fs.h
@@ -55,6 +55,9 @@ enum nfs4_session_state {
 	NFS4_SESSION_DRAINING,
 };
 
+#define NFS4_RENEW_TIMEOUT		0x01
+#define NFS4_RENEW_DELEGATION_CB	0x02
+
 struct nfs4_minor_version_ops {
 	u32	minor_version;
 
@@ -226,6 +229,9 @@ struct nfs4_state_maintenance_ops {
 	int (*sched_state_renewal)(struct nfs_client *, struct rpc_cred *);
 	struct rpc_cred * (*get_state_renewal_cred_locked)(struct nfs_client *);
 	int (*renew_lease)(struct nfs_client *, struct rpc_cred *);
+#ifndef __GENKSYMS__
+	int (*sched_state_renewal_flags)(struct nfs_client *, struct rpc_cred *, unsigned);
+#endif
 };
 
 extern const struct dentry_operations nfs4_dentry_operations;
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4proc.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4proc.c
@@ -3397,7 +3397,7 @@ static const struct rpc_call_ops nfs4_re
 	.rpc_release = nfs4_renew_release,
 };
 
-static int nfs4_proc_async_renew(struct nfs_client *clp, struct rpc_cred *cred)
+static int nfs4_proc_async_renew_flags(struct nfs_client *clp, struct rpc_cred *cred, unsigned renew_flags)
 {
 	struct rpc_message msg = {
 		.rpc_proc	= &nfs4_procedures[NFSPROC4_CLNT_RENEW],
@@ -3406,6 +3406,8 @@ static int nfs4_proc_async_renew(struct
 	};
 	struct nfs4_renewdata *data;
 
+	if (renew_flags == 0)
+		return 0;
 	if (!atomic_inc_not_zero(&clp->cl_count))
 		return -EIO;
 	data = kmalloc(sizeof(*data), GFP_KERNEL);
@@ -3416,6 +3418,12 @@ static int nfs4_proc_async_renew(struct
 	return rpc_call_async(clp->cl_rpcclient, &msg, RPC_TASK_SOFT,
 			&nfs4_renew_ops, data);
 }
+#ifdef __GENKSYMS__
+static int nfs4_proc_async_renew(struct nfs_client *clp, struct rpc_cred *cred)
+{
+	return nfs4_proc_async_renew_flags(clp, cred, NFS4_RENEW_TIMEOUT);
+}
+#endif
 
 static int nfs4_proc_renew(struct nfs_client *clp, struct rpc_cred *cred)
 {
@@ -5514,11 +5522,13 @@ static struct rpc_task *_nfs41_proc_sequ
 	return rpc_run_task(&task_setup_data);
 }
 
-static int nfs41_proc_async_sequence(struct nfs_client *clp, struct rpc_cred *cred)
+static int nfs41_proc_async_sequence_flags(struct nfs_client *clp, struct rpc_cred *cred, unsigned renew_flags)
 {
 	struct rpc_task *task;
 	int ret = 0;
 
+	if ((renew_flags & NFS4_RENEW_TIMEOUT) == 0)
+		return 0;
 	task = _nfs41_proc_sequence(clp, cred);
 	if (IS_ERR(task))
 		ret = PTR_ERR(task);
@@ -5527,6 +5537,12 @@ static int nfs41_proc_async_sequence(str
 	dprintk("<-- %s status=%d\n", __func__, ret);
 	return ret;
 }
+#ifdef __GENKSYMS__
+static int nfs41_proc_async_sequence(struct nfs_client *clp, struct rpc_cred *cred)
+{
+	return nfs41_proc_async_sequence_flags(clp, cred, NFS4_RENEW_TIMEOUT);
+}
+#endif
 
 static int nfs4_proc_sequence(struct nfs_client *clp, struct rpc_cred *cred)
 {
@@ -6022,14 +6038,22 @@ struct nfs4_state_recovery_ops nfs41_nog
 #endif /* CONFIG_NFS_V4_1 */
 
 struct nfs4_state_maintenance_ops nfs40_state_renewal_ops = {
+#ifndef __GENKSYMS__
+	.sched_state_renewal_flags = nfs4_proc_async_renew_flags,
+#else
 	.sched_state_renewal = nfs4_proc_async_renew,
+#endif
 	.get_state_renewal_cred_locked = nfs4_get_renew_cred_locked,
 	.renew_lease = nfs4_proc_renew,
 };
 
 #if defined(CONFIG_NFS_V4_1)
 struct nfs4_state_maintenance_ops nfs41_state_renewal_ops = {
+#ifndef __GENKSYMS__
+	.sched_state_renewal_flags = nfs41_proc_async_sequence_flags,
+#else
 	.sched_state_renewal = nfs41_proc_async_sequence,
+#endif
 	.get_state_renewal_cred_locked = nfs4_get_machine_cred_locked,
 	.renew_lease = nfs4_proc_sequence,
 };
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4renewd.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4renewd.c
@@ -60,6 +60,7 @@ nfs4_renew_state(struct work_struct *wor
 	struct rpc_cred *cred;
 	long lease;
 	unsigned long last, now;
+	unsigned renew_flags = 0;
 
 	ops = clp->cl_mvops->state_renewal_ops;
 	dprintk("%s: start\n", __func__);
@@ -72,18 +73,30 @@ nfs4_renew_state(struct work_struct *wor
 	last = clp->cl_last_renewal;
 	now = jiffies;
 	/* Are we close to a lease timeout? */
-	if (time_after(now, last + lease/3)) {
+	if (time_after(now, last + lease/3))
+		renew_flags |= NFS4_RENEW_TIMEOUT;
+	if (nfs_delegations_present(clp))
+		renew_flags |= NFS4_RENEW_DELEGATION_CB;
+
+	if (renew_flags != 0) {
 		cred = ops->get_state_renewal_cred_locked(clp);
 		spin_unlock(&clp->cl_lock);
 		if (cred == NULL) {
-			if (!nfs_delegations_present(clp)) {
+			if (!(renew_flags & NFS4_RENEW_DELEGATION_CB)) {
 				set_bit(NFS4CLNT_LEASE_EXPIRED, &clp->cl_state);
 				goto out;
 			}
 			nfs_expire_all_delegations(clp);
 		} else {
 			/* Queue an asynchronous RENEW. */
-			ops->sched_state_renewal(clp, cred);
+			if (ops->sched_state_renewal) {
+				if (renew_flags & NFS4_RENEW_TIMEOUT)
+					ops->sched_state_renewal(clp, cred);
+			}
+#ifndef __GENKSYMS__
+			else
+				ops->sched_state_renewal_flags(clp, cred, renew_flags);
+#endif
 			put_rpccred(cred);
 			goto out_exp;
 		}
