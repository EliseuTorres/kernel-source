From: Michal Kubecek <mkubecek@suse.cz>
Date: Wed, 4 Feb 2015 11:33:05 +0100
Subject: netfilter: do not drop packet on insert collision
Patch-mainline: Never, SLE11-SP3 specific
References: bnc#907611

When a collision occurs while inserting a conntrack into hash table, do
not drop the packet, keep the unconfirmed conntrack instead so that it
is dropped once the packet is transmitted.

Insert collisions are rare and harmless but as this can affect
statistics of "NEW" packets, collisions are only ignored if
net.netfilter.nf_conntrack_ignore_collisions sysctl is set.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/netfilter/nf_conntrack_core.h |  2 ++
 net/netfilter/nf_conntrack_core.c         | 11 +++++++++++
 net/netfilter/nf_conntrack_standalone.c   |  7 +++++++
 3 files changed, 20 insertions(+)

diff --git a/include/net/netfilter/nf_conntrack_core.h b/include/net/netfilter/nf_conntrack_core.h
index aced085..3e576f8 100644
--- a/include/net/netfilter/nf_conntrack_core.h
+++ b/include/net/netfilter/nf_conntrack_core.h
@@ -17,6 +17,8 @@
 #include <net/netfilter/nf_conntrack_l4proto.h>
 #include <net/netfilter/nf_conntrack_ecache.h>
 
+extern int nf_ct_ignore_collisions;
+
 /* This header is used to share core functionality between the
    standalone connection tracking module, and the compatibility layer's use
    of connection tracking. */
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index dff164e..b64819f 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -63,6 +63,8 @@ EXPORT_SYMBOL_GPL(nf_conntrack_htable_size);
 unsigned int nf_conntrack_max __read_mostly;
 EXPORT_SYMBOL_GPL(nf_conntrack_max);
 
+int nf_ct_ignore_collisions __read_mostly;
+
 DEFINE_PER_CPU(struct nf_conn, nf_conntrack_untracked);
 EXPORT_PER_CPU_SYMBOL(nf_conntrack_untracked);
 
@@ -527,6 +529,15 @@ __nf_conntrack_confirm(struct sk_buff *skb)
 	return NF_ACCEPT;
 
 out:
+	/* bnc#907611: on (rare and harmless) insert collision, do not drop
+	 * the packet, keep the unconfirmed conntrack instead and free it
+	 * once the packet is transmitted.
+	 */
+	if (unlikely(nf_ct_ignore_collisions)) {
+		spin_unlock_bh(&nf_conntrack_lock);
+		return NF_ACCEPT;
+	}
+
 	NF_CT_STAT_INC(net, insert_failed);
 	spin_unlock_bh(&nf_conntrack_lock);
 	return NF_DROP;
diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
index 05e9feb..5b23ed9 100644
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -452,6 +452,13 @@ static ctl_table nf_ct_sysctl_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+	{
+		.procname	= "nf_conntrack_ignore_collisions",
+		.data		= &nf_ct_ignore_collisions,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
 	{ }
 };
 
-- 
1.8.4.5

