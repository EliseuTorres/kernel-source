From: Hannes Reinecke <hare@suse.de>
Date: Mon, 24 Jun 2013 13:19:39 +0200
Subject: scsi: Warn on invalid command completion
References: bnc#798050
Patch-Mainline: n/a

Whenever a command is issued via ->queuecommand() the completion
is expected to be done via 'scsi_done'. Any completion _not_
initiated via 'scsi_done' is invalid.
Most drivers use the 'host_scribble' pointer to link back to the
(driver-specific) command structure, which will be freed prior
to the call to 'scsi_done'. So if we zero out the host_scribble
pointer in scsi_done() we can use this as a marker that
scsi_done() has been called.
Hence we can easily check for invalid command completion by
just checking for a non-zero value for host_scribble in
scsi_put_command().

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/scsi.c       | 3 +++
 drivers/scsi/scsi_error.c | 1 +
 2 files changed, 4 insertions(+)

diff -aurp orig/drivers/scsi/scsi.c current/drivers/scsi/scsi.c
--- orig/drivers/scsi/scsi.c	2013-07-30 14:42:14.000000000 -0700
+++ current/drivers/scsi/scsi.c	2013-07-30 14:44:30.000000000 -0700
@@ -347,6 +347,8 @@ void scsi_put_command(struct scsi_cmnd *
 	list_del_init(&cmd->list);
 	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
 
+	WARN_ON(cmd->host_scribble);
+
 	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
 }
 EXPORT_SYMBOL(scsi_put_command);
@@ -750,6 +752,7 @@ int scsi_dispatch_cmd(struct scsi_cmnd *
  */
 static void scsi_done(struct scsi_cmnd *cmd)
 {
+	cmd->host_scribble = NULL;
 	trace_scsi_dispatch_cmd_done(cmd);
 	blk_complete_request(cmd->request);
 }
diff -aurp orig/drivers/scsi/scsi_error.c current/drivers/scsi/scsi_error.c
--- orig/drivers/scsi/scsi_error.c	2013-07-30 14:42:14.000000000 -0700
+++ current/drivers/scsi/scsi_error.c	2013-07-30 14:43:24.000000000 -0700
@@ -1943,6 +1943,7 @@ void scsi_eh_flush_done_q(struct list_he
 
 	list_for_each_entry_safe(scmd, next, done_q, eh_entry) {
 		list_del_init(&scmd->eh_entry);
+		scmd->host_scribble = NULL;
 		if (scsi_device_online(scmd->device) &&
 		    !scsi_noretry_cmd(scmd) &&
 		    (++scmd->retries <= scmd->allowed)) {
