From: NeilBrown <neilb@suse.de>
Subject: md: try to remove cause of a spinning md thread.
Patch-mainline: not needed
References: bnc#875386

Received a report that md126_raid1 was  spinning while all other
CPUs were trying to stop_machine().

md126_raid1 was definitely spinning in and out of md_check_recovery and was
taking the mutex, but it is not clear why.

The only cases I can find were md_check_recovery would not clear the setting
that cause it to be entered are if ->ro is non-zero or possibly if ->safemode
is 2 while mddev->external is set.

The former can be fixed by clearing a number of flags.
The latter be ensuring we never set safemode to 2 for externally managed arrays.

However I'd be surprised if the array is set read-only, and while I
think the array probably is externally managed (i.e. by mdmon), ->safemode
can only be set to 2 at shutdown.

Still, these changes definitely don't hurt, and could help.

Acked-by: NeilBrown <neilb@suse.de>
Signed-off-by: Neil Brown <neilb@suse.de>

---
 drivers/md/md.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

--- linux-3.0-SLE11-SP3.orig/drivers/md/md.c
+++ linux-3.0-SLE11-SP3/drivers/md/md.c
@@ -7715,6 +7715,10 @@ void md_check_recovery(mddev_t *mddev)
 					}
 				}
 			clear_bit(MD_RECOVERY_NEEDED, &mddev->recovery);
+			clear_bit(MD_CHANGE_DEVS, &mddev->recovery);
+			clear_bit(MD_CHANGE_CLEAN, &mddev->recovery);
+			mddev->safemode = 0;
+			clear_bit(MD_RECOVERY_DONE, &mddev->recovery);
 			goto unlock;
 		}
 
@@ -7864,7 +7868,7 @@ static int md_notify_reboot(struct notif
 		if (mddev_trylock(mddev)) {
 			if (mddev->pers)
 				__md_stop_writes(mddev);
-			mddev->safemode = 2;
+			mddev->safemode = mddev->external ? 1 : 2;
 			mddev_unlock(mddev);
 		}
 	/*
