From: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date: Mon, 7 Nov 2011 20:56:50 +0900
Subject: PCI: pciehp: Handle push button event asynchronously
Git-commit: 486b10b9f43500741cd63a878d0ef23cd87fc66d
Patch-mainline: v3.3-rc1
References: bnc#898295

Use non-ordered workqueue for attention button events.

Attention button events on each slot can be handled asynchronously. So
we should use non-ordered workqueue. This patch also removes ordered
workqueue in pciehp as a result.

Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
Acked-by: Borislav Petkov <bp@suse.de>
---
 drivers/pci/hotplug/pciehp.h      | 1 -
 drivers/pci/hotplug/pciehp_core.c | 9 ---------
 drivers/pci/hotplug/pciehp_ctrl.c | 4 ++--
 drivers/pci/hotplug/pciehp_hpc.c  | 1 -
 4 files changed, 2 insertions(+), 13 deletions(-)

Index: kernel/drivers/pci/hotplug/pciehp.h
===================================================================
--- kernel.orig/drivers/pci/hotplug/pciehp.h	2014-10-24 15:38:23.384133621 +0200
+++ kernel/drivers/pci/hotplug/pciehp.h	2014-10-24 15:38:43.408133585 +0200
@@ -46,7 +46,6 @@ extern int pciehp_debug;
 extern int pciehp_force;
 extern bool pciehp_surprise;
 extern struct workqueue_struct *pciehp_wq;
-extern struct workqueue_struct *pciehp_ordered_wq;
 
 #define dbg(format, arg...)						\
 do {									\
Index: kernel/drivers/pci/hotplug/pciehp_core.c
===================================================================
--- kernel.orig/drivers/pci/hotplug/pciehp_core.c	2014-10-24 15:38:19.868133627 +0200
+++ kernel/drivers/pci/hotplug/pciehp_core.c	2014-10-24 15:38:56.460133562 +0200
@@ -45,7 +45,6 @@ int pciehp_poll_time;
 int pciehp_force;
 bool pciehp_surprise = false;
 struct workqueue_struct *pciehp_wq;
-struct workqueue_struct *pciehp_ordered_wq;
 
 #define DRIVER_VERSION	"0.4"
 #define DRIVER_AUTHOR	"Dan Zink <dan.zink@compaq.com>, Greg Kroah-Hartman <greg@kroah.com>, Dely Sy <dely.l.sy@intel.com>"
@@ -382,18 +381,11 @@ static int __init pcied_init(void)
 	if (!pciehp_wq)
 		return -ENOMEM;
 
-	pciehp_ordered_wq = alloc_ordered_workqueue("pciehp_ordered", 0);
-	if (!pciehp_ordered_wq) {
-		destroy_workqueue(pciehp_wq);
-		return -ENOMEM;
-	}
-
 	pciehp_firmware_init();
 	retval = pcie_port_service_register(&hpdriver_portdrv);
  	dbg("pcie_port_service_register = %d\n", retval);
   	info(DRIVER_DESC " version: " DRIVER_VERSION "\n");
  	if (retval) {
-		destroy_workqueue(pciehp_ordered_wq);
 		destroy_workqueue(pciehp_wq);
 		dbg("Failure to register service\n");
 	}
@@ -404,7 +396,6 @@ static void __exit pcied_cleanup(void)
 {
 	dbg("unload_pciehpd()\n");
 	pcie_port_service_unregister(&hpdriver_portdrv);
-	destroy_workqueue(pciehp_ordered_wq);
 	destroy_workqueue(pciehp_wq);
 	info(DRIVER_DESC " version: " DRIVER_VERSION " unloaded\n");
 }
Index: kernel/drivers/pci/hotplug/pciehp_ctrl.c
===================================================================
--- kernel.orig/drivers/pci/hotplug/pciehp_ctrl.c	2014-10-24 15:38:19.868133627 +0200
+++ kernel/drivers/pci/hotplug/pciehp_ctrl.c	2014-10-24 15:38:23.388133621 +0200
@@ -344,7 +344,7 @@ void pciehp_queue_pushbutton_work(struct
 		kfree(info);
 		goto out;
 	}
-	queue_work(pciehp_ordered_wq, &info->work);
+	queue_work(pciehp_wq, &info->work);
  out:
 	mutex_unlock(&p_slot->lock);
 }
@@ -439,7 +439,7 @@ static void handle_surprise_event(struct
 	else
 		p_slot->state = POWERON_STATE;
 
-	queue_work(pciehp_ordered_wq, &info->work);
+	queue_work(pciehp_wq, &info->work);
 }
 
 static void interrupt_event_handler(struct work_struct *work)
Index: kernel/drivers/pci/hotplug/pciehp_hpc.c
===================================================================
--- kernel.orig/drivers/pci/hotplug/pciehp_hpc.c	2014-10-24 15:38:19.868133627 +0200
+++ kernel/drivers/pci/hotplug/pciehp_hpc.c	2014-10-24 15:38:23.388133621 +0200
@@ -908,7 +908,6 @@ static void pcie_cleanup_slot(struct con
 	struct slot *slot = ctrl->slot;
 	cancel_delayed_work(&slot->work);
 	flush_workqueue(pciehp_wq);
-	flush_workqueue(pciehp_ordered_wq);
 	kfree(slot);
 }
 
