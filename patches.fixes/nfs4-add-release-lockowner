From: Trond Myklebust <Trond.Myklebust@netapp.com>
Subject: NFSv4: Add support for the RELEASE_LOCKOWNER operation
References: bnc#649548
Patch-mainline: v2.6.36-rc1
Git-commit: d3c7b7ccc199ee564177ee914c04771d6bc00295

    This is needed by NFSv4.0 servers in order to keep the number of locking
    stateids at a manageable level.
    
Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Acked-by: Suresh Jayaraman <sjayaraman@suse.de>
---
 fs/nfs/nfs4_fs.h        |    1 
 fs/nfs/nfs4proc.c       |   28 +++++++++++++++++++
 fs/nfs/nfs4state.c      |    2 +
 fs/nfs/nfs4xdr.c        |   68 ++++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/nfs4.h    |    1 
 include/linux/nfs_xdr.h |    4 ++
 6 files changed, 104 insertions(+)

Index: linux-2.6.32-SLE11-SP1/fs/nfs/nfs4_fs.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/fs/nfs/nfs4_fs.h	2010-11-11 10:46:11.000000000 -0600
+++ linux-2.6.32-SLE11-SP1/fs/nfs/nfs4_fs.h	2010-11-11 10:50:20.000000000 -0600
@@ -210,6 +210,7 @@ extern int nfs4_open_revalidate(struct i
 extern int nfs4_server_capabilities(struct nfs_server *server, struct nfs_fh *fhandle);
 extern int nfs4_proc_fs_locations(struct inode *dir, const struct qstr *name,
 		struct nfs4_fs_locations *fs_locations, struct page *page);
+extern void nfs4_release_lockowner(const struct nfs4_lock_state *);
 
 extern struct nfs4_state_recovery_ops *nfs4_reboot_recovery_ops[];
 extern struct nfs4_state_recovery_ops *nfs4_nograce_recovery_ops[];
Index: linux-2.6.32-SLE11-SP1/fs/nfs/nfs4proc.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/fs/nfs/nfs4proc.c	2010-11-11 10:46:23.000000000 -0600
+++ linux-2.6.32-SLE11-SP1/fs/nfs/nfs4proc.c	2010-11-11 10:54:27.000000000 -0600
@@ -4232,6 +4232,34 @@ out:
 	return err;
 }
 
+static void nfs4_release_lockowner_release(void *calldata)
+{
+	kfree(calldata);
+}
+
+const struct rpc_call_ops nfs4_release_lockowner_ops = {
+	.rpc_release = nfs4_release_lockowner_release,
+};
+
+void nfs4_release_lockowner(const struct nfs4_lock_state *lsp)
+{
+	struct nfs_server *server = lsp->ls_state->owner->so_server;
+	struct nfs_release_lockowner_args *args;
+	struct rpc_message msg = {
+		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_RELEASE_LOCKOWNER],
+	};
+
+	if (server->nfs_client->cl_minorversion != 0)
+		return;
+	args = kmalloc(sizeof(*args), GFP_NOFS);
+	if (!args)
+		return;
+	args->lock_owner.clientid = server->nfs_client->cl_clientid;
+	args->lock_owner.id = lsp->ls_id.id;
+	msg.rpc_argp = args;
+	rpc_call_async(server->client, &msg, 0, &nfs4_release_lockowner_ops, args);
+}
+
 #define XATTR_NAME_NFSV4_ACL "system.nfs4_acl"
 
 int nfs4_setxattr(struct dentry *dentry, const char *key, const void *buf,
Index: linux-2.6.32-SLE11-SP1/fs/nfs/nfs4state.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/fs/nfs/nfs4state.c	2009-12-02 21:51:21.000000000 -0600
+++ linux-2.6.32-SLE11-SP1/fs/nfs/nfs4state.c	2010-11-11 10:50:20.000000000 -0600
@@ -622,6 +622,8 @@ void nfs4_put_lock_state(struct nfs4_loc
 	if (list_empty(&state->lock_states))
 		clear_bit(LK_STATE_IN_USE, &state->flags);
 	spin_unlock(&state->state_lock);
+	if (lsp->ls_flags & NFS_LOCK_INITIALIZED)
+		nfs4_release_lockowner(lsp);
 	nfs4_free_lock_state(lsp);
 }
 
Index: linux-2.6.32-SLE11-SP1/fs/nfs/nfs4xdr.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/fs/nfs/nfs4xdr.c	2010-11-11 10:46:23.000000000 -0600
+++ linux-2.6.32-SLE11-SP1/fs/nfs/nfs4xdr.c	2010-11-11 11:04:00.000000000 -0600
@@ -201,6 +201,7 @@ static int nfs4_stat_to_errno(int);
 #define encode_link_maxsz	(op_encode_hdr_maxsz + \
 				nfs4_name_maxsz)
 #define decode_link_maxsz	(op_decode_hdr_maxsz + decode_change_info_maxsz)
+#define encode_lockowner_maxsz  (7)
 #define encode_lock_maxsz	(op_encode_hdr_maxsz + \
 				 7 + \
 				 1 + encode_stateid_maxsz + 8)
@@ -216,6 +217,11 @@ static int nfs4_stat_to_errno(int);
 				 4)
 #define decode_locku_maxsz	(op_decode_hdr_maxsz + \
 				 decode_stateid_maxsz)
+#define encode_release_lockowner_maxsz \
+				(op_encode_hdr_maxsz + \
+				 encode_lockowner_maxsz)
+#define decode_release_lockowner_maxsz \
+				(op_decode_hdr_maxsz)
 #define encode_access_maxsz	(op_encode_hdr_maxsz + 1)
 #define decode_access_maxsz	(op_decode_hdr_maxsz + 2)
 #define encode_symlink_maxsz	(op_encode_hdr_maxsz + \
@@ -468,6 +474,12 @@ static int nfs4_stat_to_errno(int);
 				decode_sequence_maxsz + \
 				decode_putfh_maxsz + \
 				decode_locku_maxsz)
+#define NFS4_enc_release_lockowner_sz \
+				(compound_encode_hdr_maxsz + \
+				 encode_lockowner_maxsz)
+#define NFS4_dec_release_lockowner_sz \
+				(compound_decode_hdr_maxsz + \
+				 decode_lockowner_maxsz)
 #define NFS4_enc_access_sz	(compound_encode_hdr_maxsz + \
 				encode_sequence_maxsz + \
 				encode_putfh_maxsz + \
@@ -1071,6 +1083,18 @@ static void encode_lockt(struct xdr_stre
 	hdr->replen += decode_lockt_maxsz;
 }
 
+static void encode_lockowner(struct xdr_stream *xdr, const struct nfs_lowner
+*lowner)
+{
+        __be32 *p;
+
+        p = reserve_space(xdr, 28);
+        p = xdr_encode_hyper(p, lowner->clientid);
+        *p++ = cpu_to_be32(16);
+        p = xdr_encode_opaque_fixed(p, "lock id:", 8);
+        xdr_encode_hyper(p, lowner->id);
+}
+
 static void encode_locku(struct xdr_stream *xdr, const struct nfs_locku_args *args, struct compound_hdr *hdr)
 {
 	__be32 *p;
@@ -1086,6 +1110,17 @@ static void encode_locku(struct xdr_stre
 	hdr->replen += decode_locku_maxsz;
 }
 
+static void encode_release_lockowner(struct xdr_stream *xdr, const struct nfs_lowner *lowner, struct compound_hdr *hdr)
+{
+	__be32 *p;
+
+	p = reserve_space(xdr, 4);
+	*p = cpu_to_be32(OP_RELEASE_LOCKOWNER);
+	encode_lockowner(xdr, lowner);
+	hdr->nops++;
+	hdr->replen += decode_release_lockowner_maxsz;
+}
+
 static void encode_lookup(struct xdr_stream *xdr, const struct qstr *name, struct compound_hdr *hdr)
 {
 	int len = name->len;
@@ -1989,6 +2024,20 @@ static int nfs4_xdr_enc_locku(struct rpc
 	return 0;
 }
 
+static int nfs4_xdr_enc_release_lockowner(struct rpc_rqst *req, __be32 *p, struct nfs_release_lockowner_args *args)
+{
+	struct xdr_stream xdr;
+	struct compound_hdr hdr = {
+		.minorversion = 0,
+	};
+
+	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
+	encode_compound_hdr(&xdr, req, &hdr);
+	encode_release_lockowner(&xdr, &args->lock_owner, &hdr);
+	encode_nops(&hdr);
+	return 0;
+}
+
 /*
  * Encode a READLINK request
  */
@@ -3894,6 +3943,11 @@ static int decode_locku(struct xdr_strea
 	return status;
 }
 
+static int decode_release_lockowner(struct xdr_stream *xdr)
+{
+	return decode_op_hdr(xdr, OP_RELEASE_LOCKOWNER);
+}
+
 static int decode_lookup(struct xdr_stream *xdr)
 {
 	return decode_op_hdr(xdr, OP_LOOKUP);
@@ -5175,6 +5229,19 @@ out:
 	return status;
 }
 
+static int nfs4_xdr_dec_release_lockowner(struct rpc_rqst *rqstp, __be32 *p, void *dummy)
+{
+	struct xdr_stream xdr;
+	struct compound_hdr hdr;
+	int status;
+
+	xdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);
+	status = decode_compound_hdr(&xdr, &hdr);
+	if (!status)
+		status = decode_release_lockowner(&xdr);
+	return status;
+}
+
 /*
  * Decode READLINK response
  */
@@ -5763,6 +5830,7 @@ struct rpc_procinfo	nfs4_procedures[] =
   PROC(GETACL,		enc_getacl,	dec_getacl),
   PROC(SETACL,		enc_setacl,	dec_setacl),
   PROC(FS_LOCATIONS,	enc_fs_locations, dec_fs_locations),
+  PROC(RELEASE_LOCKOWNER, enc_release_lockowner, dec_release_lockowner),
 #if defined(CONFIG_NFS_V4_1)
   PROC(EXCHANGE_ID,	enc_exchange_id,	dec_exchange_id),
   PROC(CREATE_SESSION,	enc_create_session,	dec_create_session),
Index: linux-2.6.32-SLE11-SP1/include/linux/nfs4.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/nfs4.h	2009-12-02 21:51:21.000000000 -0600
+++ linux-2.6.32-SLE11-SP1/include/linux/nfs4.h	2010-11-11 10:50:20.000000000 -0600
@@ -521,6 +521,7 @@ enum {
 	NFSPROC4_CLNT_GETACL,
 	NFSPROC4_CLNT_SETACL,
 	NFSPROC4_CLNT_FS_LOCATIONS,
+	NFSPROC4_CLNT_RELEASE_LOCKOWNER,
 
 	/* nfs41 */
 	NFSPROC4_CLNT_EXCHANGE_ID,
Index: linux-2.6.32-SLE11-SP1/include/linux/nfs_xdr.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/nfs_xdr.h	2009-12-02 21:51:21.000000000 -0600
+++ linux-2.6.32-SLE11-SP1/include/linux/nfs_xdr.h	2010-11-11 10:50:20.000000000 -0600
@@ -311,6 +311,10 @@ struct nfs_lockt_res {
 	struct nfs4_sequence_res	seq_res;
 };
 
+struct nfs_release_lockowner_args {
+	struct nfs_lowner	lock_owner;
+};
+
 struct nfs4_delegreturnargs {
 	const struct nfs_fh *fhandle;
 	const nfs4_stateid *stateid;
