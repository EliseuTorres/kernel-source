From: "Paul E. McKenney" <paul.mckenney@linaro.org>
Date: Wed, 9 May 2012 08:45:12 -0700
Subject: rcu: Fix detection of abruptly-ending stall
Git-commit: 285fe29481d865ae381ad3924c80894e6968c2d8
Patch-mainline: v3.6-rc1
References: bnc#816586

The code that attempts to identify stalls that end just as we detect
them is broken by both flavors of initialization failure.  This commit
therefore properly initializes and computes the count of the number
of reasons why the RCU grace period is stalled.

Signed-off-by: Paul E. McKenney <paul.mckenney@linaro.org>
Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Reviewed-by: Josh Triplett <josh@joshtriplett.org>
Acked-by: Mike Galbraith <mgalbraith@suse.de>

---
 kernel/rcutree.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

--- a/kernel/rcutree.c
+++ b/kernel/rcutree.c
@@ -539,7 +539,7 @@ static void print_other_cpu_stall(struct
 	int cpu;
 	long delta;
 	unsigned long flags;
-	int ndetected;
+	int ndetected = 0;
 	struct rcu_node *rnp = rcu_get_root(rsp);
 
 	/* Only let one CPU complain about others per time interval. */
@@ -556,7 +556,7 @@ static void print_other_cpu_stall(struct
 	 * Now rat on any tasks that got kicked up to the root rcu_node
 	 * due to CPU offlining.
 	 */
-	ndetected = rcu_print_task_stall(rnp);
+	ndetected += rcu_print_task_stall(rnp);
 	raw_spin_unlock_irqrestore(&rnp->lock, flags);
 
 	/*
