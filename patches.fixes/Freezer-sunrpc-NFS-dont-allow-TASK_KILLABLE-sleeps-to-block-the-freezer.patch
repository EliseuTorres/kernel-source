From: Jeff Layton <jlayton@redhat.com>
Subject: Freezer / sunrpc / NFS: don't allow TASK_KILLABLE sleeps to block the freezer
Patch-mainline: Yes
Git-commit: d310310cbff18ec385c6ab4d58f33b100192a96a
References: bnc#775182

Allow the freezer to skip wait_on_bit_killable sleeps in the sunrpc
layer. This should allow suspend and hibernate events to proceed, even
when there are RPC's pending on the wire.

Also, wrap the TASK_KILLABLE sleeps in NFS layer in freezer_do_not_count
and freezer_count calls. This allows the freezer to skip tasks that are
sleeping while looping on EJUKEBOX or NFS4ERR_DELAY sorts of errors.

Signed-off-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---
 fs/nfs/inode.c          |    3 ++-
 fs/nfs/nfs3proc.c       |    3 ++-
 fs/nfs/nfs4proc.c       |    5 +++--
 fs/nfs/proc.c           |    3 ++-
 include/linux/freezer.h |   29 +++++++++++++++++++++++++++++
 net/sunrpc/sched.c      |    3 ++-
 6 files changed, 40 insertions(+), 6 deletions(-)


Index: linux-3.0-SLE11-SP2/fs/nfs/inode.c
===================================================================
--- linux-3.0-SLE11-SP2.orig/fs/nfs/inode.c
+++ linux-3.0-SLE11-SP2/fs/nfs/inode.c
@@ -38,6 +38,7 @@
 #include <linux/nfs_xdr.h>
 #include <linux/slab.h>
 #include <linux/compat.h>
+#include <linux/freezer.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -77,7 +78,7 @@ int nfs_wait_bit_killable(void *word)
 {
 	if (fatal_signal_pending(current))
 		return -ERESTARTSYS;
-	schedule();
+	freezable_schedule();
 	return 0;
 }
 
Index: linux-3.0-SLE11-SP2/fs/nfs/nfs3proc.c
===================================================================
--- linux-3.0-SLE11-SP2.orig/fs/nfs/nfs3proc.c
+++ linux-3.0-SLE11-SP2/fs/nfs/nfs3proc.c
@@ -17,6 +17,7 @@
 #include <linux/nfs_page.h>
 #include <linux/lockd/bind.h>
 #include <linux/nfs_mount.h>
+#include <linux/freezer.h>
 
 #include "iostat.h"
 #include "internal.h"
@@ -32,7 +33,7 @@ nfs3_rpc_wrapper(struct rpc_clnt *clnt,
 		res = rpc_call_sync(clnt, msg, flags);
 		if (res != -EJUKEBOX && res != -EKEYEXPIRED)
 			break;
-		schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
+		freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
 		res = -ERESTARTSYS;
 	} while (!fatal_signal_pending(current));
 	return res;
Index: linux-3.0-SLE11-SP2/fs/nfs/nfs4proc.c
===================================================================
--- linux-3.0-SLE11-SP2.orig/fs/nfs/nfs4proc.c
+++ linux-3.0-SLE11-SP2/fs/nfs/nfs4proc.c
@@ -53,6 +53,7 @@
 #include <linux/sunrpc/bc_xprt.h>
 #include <linux/xattr.h>
 #include <linux/utsname.h>
+#include <linux/freezer.h>
 
 #include "nfs4_fs.h"
 #include "delegation.h"
@@ -242,7 +243,7 @@ static int nfs4_delay(struct rpc_clnt *c
 		*timeout = NFS4_POLL_RETRY_MIN;
 	if (*timeout > NFS4_POLL_RETRY_MAX)
 		*timeout = NFS4_POLL_RETRY_MAX;
-	schedule_timeout_killable(*timeout);
+	freezable_schedule_timeout_killable(*timeout);
 	if (fatal_signal_pending(current))
 		res = -ERESTARTSYS;
 	*timeout <<= 1;
@@ -3992,7 +3993,7 @@ int nfs4_proc_delegreturn(struct inode *
 static unsigned long
 nfs4_set_lock_task_retry(unsigned long timeout)
 {
-	schedule_timeout_killable(timeout);
+	freezable_schedule_timeout_killable(timeout);
 	timeout <<= 1;
 	if (timeout > NFS4_LOCK_MAXTIMEOUT)
 		return NFS4_LOCK_MAXTIMEOUT;
Index: linux-3.0-SLE11-SP2/fs/nfs/proc.c
===================================================================
--- linux-3.0-SLE11-SP2.orig/fs/nfs/proc.c
+++ linux-3.0-SLE11-SP2/fs/nfs/proc.c
@@ -41,6 +41,7 @@
 #include <linux/nfs_fs.h>
 #include <linux/nfs_page.h>
 #include <linux/lockd/bind.h>
+#include <linux/freezer.h>
 #include "internal.h"
 
 #define NFSDBG_FACILITY		NFSDBG_PROC
@@ -59,7 +60,7 @@ nfs_rpc_wrapper(struct rpc_clnt *clnt, s
 		res = rpc_call_sync(clnt, msg, flags);
 		if (res != -EKEYEXPIRED)
 			break;
-		schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
+		freezable_schedule_timeout_killable(NFS_JUKEBOX_RETRY_TIME);
 		res = -ERESTARTSYS;
 	} while (!fatal_signal_pending(current));
 	return res;
Index: linux-3.0-SLE11-SP2/include/linux/freezer.h
===================================================================
--- linux-3.0-SLE11-SP2.orig/include/linux/freezer.h
+++ linux-3.0-SLE11-SP2/include/linux/freezer.h
@@ -117,6 +117,30 @@ static inline int freezer_should_skip(st
 }
 
 /*
+ * These macros are intended to be used whenever you want allow a task
+ * that's sleeping in TASK_UNINTERRUPTIBLE or TASK_KILLABLE state to be frozen.
+ * Note that neither return any clear indication of whether a freeze event
+ * happened while in this function.
+ */
+/* Like schedule(), but should not block the freezer. */
+#define freezable_schedule()						\
+({									\
+	freezer_do_not_count();						\
+	schedule();							\
+	freezer_count();						\
+})
+
+/* Like schedule_timeout_killable(), but should not block the freezer. */
+#define freezable_schedule_timeout_killable(timeout)			\
+({									\
+	long __retval;							\
+	freezer_do_not_count();						\
+	__retval = schedule_timeout_killable(timeout);			\
+	freezer_count();						\
+	__retval;							\
+})
+
+/*
  * Tell the freezer that the current task should be frozen by it
  */
 static inline void set_freezable(void)
@@ -182,6 +206,11 @@ static inline int freezer_should_skip(st
 static inline void set_freezable(void) {}
 static inline void set_freezable_with_signal(void) {}
 
+#define freezable_schedule()  schedule()
+
+#define freezable_schedule_timeout_killable(timeout)			\
+	schedule_timeout_killable(timeout)
+
 #define wait_event_freezable(wq, condition)				\
 		wait_event_interruptible(wq, condition)
 
Index: linux-3.0-SLE11-SP2/net/sunrpc/sched.c
===================================================================
--- linux-3.0-SLE11-SP2.orig/net/sunrpc/sched.c
+++ linux-3.0-SLE11-SP2/net/sunrpc/sched.c
@@ -18,6 +18,7 @@
 #include <linux/smp.h>
 #include <linux/spinlock.h>
 #include <linux/mutex.h>
+#include <linux/freezer.h>
 
 #include <linux/sunrpc/clnt.h>
 
@@ -227,7 +228,7 @@ static int rpc_wait_bit_killable(void *w
 {
 	if (fatal_signal_pending(current))
 		return -ERESTARTSYS;
-	schedule();
+	freezable_schedule();
 	return 0;
 }
 
