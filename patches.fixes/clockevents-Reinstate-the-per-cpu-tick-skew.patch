From: Mike Galbraith <mgalbraith@suse.de>
Date: Tue, 03 Jan 2012 07:20:58 +0100
Subject: clockevents: Reinstate the per cpu tick skew
Patch-mainline: submitted
References:

Quoting removal commit af5ab277ded04bd9bc6b048c5a2f0e7d70ef0867
Historically, Linux has tried to make the regular timer tick on the
various CPUs not happen at the same time, to avoid contention on
xtime_lock.
    
Nowadays, with the tickless kernel, this contention no longer happens
since time keeping and updating are done differently. In addition,
this skew is actually hurting power consumption in a measurable way on
many-core systems.
End quote

Contrary to the above, contention does still happen, and can be a
problem for realtime loads whether nohz is active or not, so give
the user the ability to decide whether power consumption or jitter
is the more important consideration.

Signed-off-by: Mike Galbraith <mgalbraith@suse.de>

---
 Documentation/kernel-parameters.txt |    5 +++++
 kernel/time/tick-sched.c            |   19 +++++++++++++++++++
 2 files changed, 24 insertions(+)

--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -2259,6 +2259,11 @@ bytes respectively. Such letter suffixes
 
 	sched_debug	[KNL] Enables verbose scheduler debug messages.
 
+	skew_tick=	[KNL] Offset the periodic timer tick per cpu to mitigate
+			xtime_lock contention on larger systems.  Note: increases
+			power consumption, and should only be enabled if running
+			jitter sensitive (HPC/RT) workloads.
+
 	rtsched_debug   [KNL] Disallows borrowing of excess rt_runtime from neighboring runqueues.
 			  /proc/sys/kernel/sched_rt_runtime_us becomes a hard limit per runqueue.
 
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -765,6 +765,8 @@ static enum hrtimer_restart tick_sched_t
 	return HRTIMER_RESTART;
 }
 
+static int sched_skew_tick;
+
 /**
  * tick_setup_sched_timer - setup the tick emulation timer
  */
@@ -782,6 +784,14 @@ void tick_setup_sched_timer(void)
 	/* Get the next period (per cpu) */
 	hrtimer_set_expires(&ts->sched_timer, tick_init_jiffy_update());
 
+	/* Offset the tick to avert xtime_lock contention. */
+	if (sched_skew_tick) {
+		u64 offset = ktime_to_ns(tick_period) >> 1;
+		do_div(offset, num_possible_cpus());
+		offset *= smp_processor_id();
+		hrtimer_add_expires_ns(&ts->sched_timer, offset);
+	}
+
 	for (;;) {
 		hrtimer_forward(&ts->sched_timer, now, tick_period);
 		hrtimer_start_expires(&ts->sched_timer,
@@ -863,3 +873,12 @@ int tick_check_oneshot_change(int allow_
 	tick_nohz_switch_to_nohz();
 	return 0;
 }
+
+static int __init skew_tick(char *str)
+{
+	get_option(&str, &sched_skew_tick);
+
+	return 0;
+}
+early_param("skew_tick", skew_tick);
+
