From: Andi Kleen <ak@linux.intel.com>
Subject: perf/x86/intel: Move NMI clearing to end of PMI handler
Date: Mon Jun 17 17:36:50 2013 -0700
Git-commit: 72db55964695dcd4aa15950f3b2fb7c09ad79829
Patch-mainline: v3.11-rc1
References: bsc#929142
Signed-off-by: Tony Jones <tonyj@suse.de>

    [SUSE: Per bsc#929142c1 we will not be packporting HSW support for SLE11
     Rework mainline patch; apply late_ack fix only for HSW models where 
     archiectural perfmon is selected (v2)]

    perf/x86/intel: Move NMI clearing to end of PMI handler
    
    This avoids some problems with spurious PMIs on Haswell.
    Haswell seems to behave more like P4 in this regard. Do
    the same thing as the P4 perf handler by unmasking
    the NMI only at the end. Shouldn't make any difference
    for earlier family 6 cores.
    
    (Tested on Haswell, IvyBridge, Westmere, Saltwell (Atom).)
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Andi Kleen <ak@linux.jf.intel.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Link: http://lkml.kernel.org/r/1371515812-9646-5-git-send-email-andi@firstfloor.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

---
 arch/x86/kernel/cpu/perf_event.h       |    1 +
 arch/x86/kernel/cpu/perf_event_intel.c |   29 +++++++++++++++++++++--------
 2 files changed, 22 insertions(+), 8 deletions(-)

--- a/arch/x86/kernel/cpu/perf_event.h
+++ b/arch/x86/kernel/cpu/perf_event.h
@@ -370,6 +370,7 @@ struct x86_pmu {
 	struct event_constraint *event_constraints;
 	struct x86_pmu_quirk *quirks;
 	int		perfctr_second_write;
+	bool		late_ack;
 
 	/*
 	 * sysfs attrs
--- a/arch/x86/kernel/cpu/perf_event_intel.c
+++ b/arch/x86/kernel/cpu/perf_event_intel.c
@@ -1138,15 +1138,11 @@ static int intel_pmu_handle_irq(struct p
 	cpuc = &__get_cpu_var(cpu_hw_events);
 
 	/*
-	 * Some chipsets need to unmask the LVTPC in a particular spot
-	 * inside the nmi handler.  As a result, the unmasking was pushed
-	 * into all the nmi handlers.
-	 *
-	 * This handler doesn't seem to have any issues with the unmasking
-	 * so it was left at the top.
+	 * No known reason to not always do late ACK,
+	 * but just in case do it opt-in.
 	 */
-	apic_write(APIC_LVTPC, APIC_DM_NMI);
-
+	if (!x86_pmu.late_ack)
+		apic_write(APIC_LVTPC, APIC_DM_NMI);
 	intel_pmu_disable_all();
 	handled = intel_pmu_drain_bts_buffer();
 	status = intel_pmu_get_status();
@@ -1206,6 +1202,13 @@ again:
 
 done:
 	intel_pmu_enable_all(0);
+	/*
+	 * Only unmask the NMI after the overflow counters
+	 * have been reset. This avoids spurious NMIs on
+	 * Haswell CPUs.
+	 */
+	if (x86_pmu.late_ack)
+		apic_write(APIC_LVTPC, APIC_DM_NMI);
 	return handled;
 }
 
@@ -2147,6 +2150,16 @@ __init int intel_pmu_init(void)
 			 */
 			x86_pmu.event_constraints = intel_gen_event_constraints;
 			pr_cont("generic architected perfmon, ");
+
+			/* HSW late ack, bsc#929142 */
+			switch (boot_cpu_data.x86_model) {
+	        	case 60: /* 22nm Haswell Core */
+        		case 63: /* 22nm Haswell Server */
+        		case 69: /* 22nm Haswell ULT */
+        		case 70: /* 22nm Haswell + GT3e (Intel Iris Pro graphics) */
+				pr_cont("Haswell pmu late ack, ");
+				x86_pmu.late_ack = true;
+			}
 			break;
 		}
 	}
