Subject: sched: revert 2.6.32-stable commit c6fc81a
From: Mike Galbraith <mgalbraith@suse.de>
Date: Wed Aug 18 05:07:30 CEST 2010
Patch-mainline: no
References: bnc#615557

    sched: revert 2.6.32-stable commit c6fc81a

    This commit does not do what mainline e291200 does, and directly causes
    tasks to run on incorrect CPUs during et al ltp cpusets testcases.  A
    follow-on series containing full mainline e291200 will be needed to properly
    resolve the TASK_WAKING race described below, and other ralated races.

    Signed-off-by: Mike Galbraith <mgalbraith@suse.de>

    Commit c6fc81afa2d7ef2f775e48672693d8a0a8a7325d text:

    sched: Fix a race between ttwu() and migrate_task()
    
    Based on commit e2912009fb7b715728311b0d8fe327a1432b3f79 upstream, but
    done differently as this issue is not present in .33 or .34 kernels due
    to rework in this area.
    
    If a task is in the TASK_WAITING state, then try_to_wake_up() is working
    on it, and it will place it on the correct cpu.
    
    This commit ensures that neither migrate_task() nor __migrate_task()
    calls set_task_cpu(p) while p is in the TASK_WAKING state.  Otherwise,
    there could be two concurrent calls to set_task_cpu(p), resulting in
    the task's cfs_rq being inconsistent with its cpu.
    
    Signed-off-by: John Wright <john.wright@hp.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 kernel/sched.c |    9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

Index: linux-2.6.32-SLE11-SP1/kernel/sched.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/kernel/sched.c
+++ linux-2.6.32-SLE11-SP1/kernel/sched.c
@@ -2124,10 +2124,12 @@ migrate_task(struct task_struct *p, int
 
 	/*
 	 * If the task is not on a runqueue (and not running), then
-	 * the next wake-up will properly place the task.
+	 * it is sufficient to simply update the task's cpu field.
 	 */
-	if (!p->se.on_rq && !task_running(rq, p))
+	if (!p->se.on_rq && !task_running(rq, p)) {
+		set_task_cpu(p, dest_cpu);
 		return 0;
+	}
 
 	init_completion(&req->done);
 	req->task = p;
@@ -7240,9 +7242,6 @@ static int __migrate_task(struct task_st
 	/* Already moved. */
 	if (task_cpu(p) != src_cpu)
 		goto done;
-	/* Waking up, don't get in the way of try_to_wake_up(). */
-	if (p->state == TASK_WAKING)
-		goto fail;
 	/* Affinity changed (again). */
 	if (!cpumask_test_cpu(dest_cpu, &p->cpus_allowed))
 		goto fail;
