From 5748eb8f8e989a9da1ac7c96dc73d68cbdedf7df Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Mon, 10 Nov 2014 11:50:21 +0100
Subject: [PATCH] net: ppp: Don't call bpf_prog_create() in ppp_lock
Git-commit: 5748eb8f8e989a9da1ac7c96dc73d68cbdedf7df
Patch-mainline: 3.18-rc5
References: bnc#930488

In ppp_ioctl(), bpf_prog_create() is called inside ppp_lock, which
eventually calls vmalloc() and hits BUG_ON() in vmalloc.c.  This patch
works around the problem by moving the allocation outside the lock.

The bug was revealed by the recent change in net/core/filter.c, as it
allocates via vmalloc() instead of kmalloc() now.

Reported-and-tested-by: Stefan Seyfried <stefan.seyfried@googlemail.com>
Signed-off-by: Takashi Iwai <tiwai@suse.de>
Signed-off-by: David S. Miller <davem@davemloft.net>

---
 drivers/net/ppp/ppp_generic.c |   39 +++++++++++++++++++++------------------
 1 file changed, 21 insertions(+), 18 deletions(-)

--- a/drivers/net/ppp/ppp_generic.c
+++ b/drivers/net/ppp/ppp_generic.c
@@ -751,23 +751,25 @@ static long ppp_ioctl(struct file *file,
 
 		err = get_filter(argp, &code);
 		if (err >= 0) {
+			struct sk_filter *pass_filter = NULL;
 			struct sock_fprog_kern fprog = {
 				.len = err,
 				.filter = code,
 			};
 
-			ppp_lock(ppp);
-			if (ppp->pass_filter) {
-				sk_unattached_filter_destroy(ppp->pass_filter);
-				ppp->pass_filter = NULL;
-			}
+			err = 0;
 			if (fprog.filter != NULL)
-				err = sk_unattached_filter_create(&ppp->pass_filter,
+				err = sk_unattached_filter_create(&pass_filter,
 								  &fprog);
-			else
-				err = 0;
+			if (!err) {
+				ppp_lock(ppp);
+				if (ppp->pass_filter)
+					sk_unattached_filter_destroy(ppp->pass_filter);
+				ppp->pass_filter = pass_filter;
+				ppp_unlock(ppp);
+
+			}
 			kfree(code);
-			ppp_unlock(ppp);
 		}
 		break;
 	}
@@ -777,23 +779,24 @@ static long ppp_ioctl(struct file *file,
 
 		err = get_filter(argp, &code);
 		if (err >= 0) {
+			struct sk_filter *active_filter = NULL;
 			struct sock_fprog_kern fprog = {
 				.len = err,
 				.filter = code,
 			};
 
-			ppp_lock(ppp);
-			if (ppp->active_filter) {
-				sk_unattached_filter_destroy(ppp->active_filter);
-				ppp->active_filter = NULL;
-			}
+			err = 0;
 			if (fprog.filter != NULL)
-				err = sk_unattached_filter_create(&ppp->active_filter,
+				err = sk_unattached_filter_create(&active_filter,
 								  &fprog);
-			else
-				err = 0;
+			if (!err) {
+				ppp_lock(ppp);
+				if (ppp->active_filter)
+					sk_unattached_filter_destroy(ppp->active_filter);
+				ppp->active_filter = active_filter;
+				ppp_unlock(ppp);
+			}
 			kfree(code);
-			ppp_unlock(ppp);
 		}
 		break;
 	}
