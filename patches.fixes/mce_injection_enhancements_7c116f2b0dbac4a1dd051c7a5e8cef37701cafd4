From: Wu Fengguang <fengguang.wu@intel.com>
Subject: HWPOISON: add fs/device filters
References: Requested by Intel for better MCE/MCA testing
Patch-Mainline: yes (2.6.33)
Git-commit: 7c116f2b0dbac4a1dd051c7a5e8cef37701cafd4

Signed-off-by: Thomas Renninger <trenn@suse.de>

Filesystem data/metadata present the most tricky-to-isolate pages.
It requires careful code review and stress testing to get them right.

The fs/device filter helps to target the stress tests to some specific
filesystem pages. The filter condition is block device's major/minor
numbers:
        - corrupt-filter-dev-major
        - corrupt-filter-dev-minor
When specified (non -1), only page cache pages that belong to that
device will be poisoned.

The filters are checked reliably on the locked and refcounted page.

Haicheng: clear PG_hwpoison and drop bad page count if filter not OK
AK: Add documentation

CC: Haicheng Li <haicheng.li@intel.com>
CC: Nick Piggin <npiggin@suse.de>
Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
Signed-off-by: Andi Kleen <ak@linux.intel.com>

---
 Documentation/vm/hwpoison.txt |    7 +++++
 mm/hwpoison-inject.c          |   11 +++++++++
 mm/internal.h                 |    3 ++
 mm/memory-failure.c           |   51 ++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 72 insertions(+)

Index: linux-2.6.32-SLE11-SP1/Documentation/vm/hwpoison.txt
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/Documentation/vm/hwpoison.txt
+++ linux-2.6.32-SLE11-SP1/Documentation/vm/hwpoison.txt
@@ -115,6 +115,13 @@ memory failures.
 Note these injection interfaces are not stable and might change between
 kernel versions
 
+corrupt-filter-dev-major
+corrupt-filter-dev-minor
+
+Only handle memory failures to pages associated with the file system defined
+by block device major/minor.  -1U is the wildcard value.
+This should be only used for testing with artificial injection.
+
 Architecture specific MCE injector
 
 x86 has mce-inject, mce-test
Index: linux-2.6.32-SLE11-SP1/mm/hwpoison-inject.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/mm/hwpoison-inject.c
+++ linux-2.6.32-SLE11-SP1/mm/hwpoison-inject.c
@@ -3,6 +3,7 @@
 #include <linux/debugfs.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include "internal.h"
 
 static struct dentry *hwpoison_dir;
 
@@ -54,6 +55,16 @@ static int pfn_inject_init(void)
 	if (!dentry)
 		goto fail;
 
+	dentry = debugfs_create_u32("corrupt-filter-dev-major", 0600,
+				    hwpoison_dir, &hwpoison_filter_dev_major);
+	if (!dentry)
+		goto fail;
+
+	dentry = debugfs_create_u32("corrupt-filter-dev-minor", 0600,
+				    hwpoison_dir, &hwpoison_filter_dev_minor);
+	if (!dentry)
+		goto fail;
+
 	return 0;
 fail:
 	pfn_inject_exit();
Index: linux-2.6.32-SLE11-SP1/mm/internal.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/mm/internal.h
+++ linux-2.6.32-SLE11-SP1/mm/internal.h
@@ -264,3 +264,6 @@ int __get_user_pages(struct task_struct
 #define ZONE_RECLAIM_SOME	0
 #define ZONE_RECLAIM_SUCCESS	1
 #endif
+
+extern u32 hwpoison_filter_dev_major;
+extern u32 hwpoison_filter_dev_minor;
Index: linux-2.6.32-SLE11-SP1/mm/memory-failure.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/mm/memory-failure.c
+++ linux-2.6.32-SLE11-SP1/mm/memory-failure.c
@@ -51,6 +51,50 @@ int sysctl_memory_failure_recovery __rea
 
 atomic_long_t mce_bad_pages __read_mostly = ATOMIC_LONG_INIT(0);
 
+u32 hwpoison_filter_dev_major = ~0U;
+u32 hwpoison_filter_dev_minor = ~0U;
+EXPORT_SYMBOL_GPL(hwpoison_filter_dev_major);
+EXPORT_SYMBOL_GPL(hwpoison_filter_dev_minor);
+
+static int hwpoison_filter_dev(struct page *p)
+{
+	struct address_space *mapping;
+	dev_t dev;
+
+	if (hwpoison_filter_dev_major == ~0U &&
+	    hwpoison_filter_dev_minor == ~0U)
+		return 0;
+
+	/*
+	 * page_mapping() does not accept slab page
+	 */
+	if (PageSlab(p))
+		return -EINVAL;
+
+	mapping = page_mapping(p);
+	if (mapping == NULL || mapping->host == NULL)
+		return -EINVAL;
+
+	dev = mapping->host->i_sb->s_dev;
+	if (hwpoison_filter_dev_major != ~0U &&
+	    hwpoison_filter_dev_major != MAJOR(dev))
+		return -EINVAL;
+	if (hwpoison_filter_dev_minor != ~0U &&
+	    hwpoison_filter_dev_minor != MINOR(dev))
+		return -EINVAL;
+
+	return 0;
+}
+
+int hwpoison_filter(struct page *p)
+{
+	if (hwpoison_filter_dev(p))
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(hwpoison_filter);
+
 /*
  * Send all the processes who have the page mapped an ``action optional''
  * signal.
@@ -840,6 +884,13 @@ int __memory_failure(unsigned long pfn,
 		res = 0;
 		goto out;
 	}
+	if (hwpoison_filter(p)) {
+		if (TestClearPageHWPoison(p))
+			atomic_long_dec(&mce_bad_pages);
+		unlock_page(p);
+		put_page(p);
+		return 0;
+	}
 
 	wait_on_page_writeback(p);
 

