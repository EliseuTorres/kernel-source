From: Jeff Mahoney <jeffm@suse.com>
Subject: reiserfs: Force inode evictions before umount to avoid crash
References: bnc#610598 bnc#680073 bnc#684112 bnc#686921
Patch-mainline: Submitted to reiserfs-devel Apr 6 2011

 This patch fixes a crash in reiserfs_delete_xattrs during umount.

 When shrink_dcache_for_umount clears the dcache from
 generic_shutdown_super, delayed evictions are forced to disk. If an
 evicted inode has extended attributes associated with it, it will
 need to walk the xattr tree to locate and remove them.

 But since shrink_dcache_for_umount will BUG if it encounters active
 dentries, the xattr tree must be released before it's called or it will
 crash during every umount.

 This patch forces the evictions to occur before generic_shutdown_super
 by calling shrink_dcache_sb first. The additional evictions caused
 by the removal of each associated xattr file and dir will be automatically
 handled as they're added to the LRU list.

 Unnecessary EXPORT_SYMBOL_GPL(shrink_dcache_for_umount_subtree) to 
 preserve kABI because of deletion of patches.fixes/reiserfs-xattr-crash-fix

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/dcache.c            |    3 ++-
 fs/reiserfs/super.c    |   24 ++++++++++++++----------
 include/linux/dcache.h |    1 +
 3 files changed, 17 insertions(+), 11 deletions(-)

Index: linux-2.6.32-SLE11-SP1/fs/reiserfs/super.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/fs/reiserfs/super.c	2011-04-13 15:12:27.000000000 -0500
+++ linux-2.6.32-SLE11-SP1/fs/reiserfs/super.c	2011-04-13 15:12:50.000000000 -0500
@@ -445,16 +445,20 @@ int remove_save_link(struct inode *inode
 static void reiserfs_kill_sb(struct super_block *s)
 {
 	if (REISERFS_SB(s)) {
-		if (REISERFS_SB(s)->xattr_root) {
-			d_invalidate(REISERFS_SB(s)->xattr_root);
-			dput(REISERFS_SB(s)->xattr_root);
-			REISERFS_SB(s)->xattr_root = NULL;
-		}
-		if (REISERFS_SB(s)->priv_root) {
-			d_invalidate(REISERFS_SB(s)->priv_root);
-			dput(REISERFS_SB(s)->priv_root);
-			REISERFS_SB(s)->priv_root = NULL;
-		}
+		/*
+		 * Force any pending inode evictions to occur now. Any
+		 * inodes to be removed that have extended attributes
+		 * associated with them need to clean them up before
+		 * we can release the extended attribute root dentries.
+		 * shrink_dcache_for_umount will BUG if we don't release
+		 * those before it's called so ->put_super is too late.
+		 */
+		shrink_dcache_sb(s);
+
+		dput(REISERFS_SB(s)->xattr_root);
+		REISERFS_SB(s)->xattr_root = NULL;
+		dput(REISERFS_SB(s)->priv_root);
+		REISERFS_SB(s)->priv_root = NULL;
 	}
 
 	kill_block_super(s);
Index: linux-2.6.32-SLE11-SP1/fs/dcache.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/fs/dcache.c	2011-04-13 15:11:10.000000000 -0500
+++ linux-2.6.32-SLE11-SP1/fs/dcache.c	2011-04-13 15:14:22.000000000 -0500
@@ -616,7 +616,7 @@ void shrink_dcache_sb(struct super_block
  * - see the comments on shrink_dcache_for_umount() for a description of the
  *   locking
  */
-static void shrink_dcache_for_umount_subtree(struct dentry *dentry)
+void shrink_dcache_for_umount_subtree(struct dentry *dentry)
 {
 	struct dentry *parent;
 	unsigned detached = 0;
@@ -2351,3 +2351,4 @@ EXPORT_SYMBOL(have_submounts);
 EXPORT_SYMBOL(names_cachep);
 EXPORT_SYMBOL(shrink_dcache_parent);
 EXPORT_SYMBOL(shrink_dcache_sb);
+EXPORT_SYMBOL_GPL(shrink_dcache_for_umount_subtree);
Index: linux-2.6.32-SLE11-SP1/include/linux/dcache.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/dcache.h	2011-04-13 15:11:10.000000000 -0500
+++ linux-2.6.32-SLE11-SP1/include/linux/dcache.h	2011-04-13 15:16:03.000000000 -0500
@@ -243,6 +243,7 @@ extern struct dentry * d_obtain_alias(st
 extern void shrink_dcache_sb(struct super_block *);
 extern void shrink_dcache_parent(struct dentry *);
 extern void shrink_dcache_for_umount(struct super_block *);
+extern void shrink_dcache_for_umount_subtree(struct dentry *);
 extern int d_invalidate(struct dentry *);
 
 /* only used at mount-time */
