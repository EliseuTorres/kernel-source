From: Mel Gorman <mgorman@suse.de>
Date: Fri, 28 Jun 2013 16:31:54 +0100
Subject: [PATCH] mm: vmscan: Do not continue scanning if reclaim was aborted
 for compaction

References: Limit reclaim in the preserve of IO (bnc#754690)
Patch-mainline: Yes (v3.11)
Git-commit: 5a1c9cbc1550f93335d7c03eb6c271e642deff04

Direct reclaim is not aborting to allow compaction to go ahead properly.
do_try_to_free_pages is told to abort reclaim which is happily ignores
and instead increases priority instead until it reaches 0 and starts
shrinking file/anon equally. This patch corrects the situation by
aborting reclaim when requested instead of raising priority.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/vmscan.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/mm/vmscan.c b/mm/vmscan.c
index c95eaea..96c0eab 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -2294,8 +2294,10 @@ static unsigned long do_try_to_free_pages(struct zonelist *zonelist,
 		aborted_reclaim = shrink_zones(zonelist, sc);
 
 		/*
-		 * Don't shrink slabs when reclaiming memory from
-		 * over limit cgroups
+		 * Don't shrink slabs when reclaiming memory from over limit
+		 * cgroups but do shrink slab at least once when aborting
+		 * reclaim for compaction to avoid unevenly scanning file/anon
+		 * LRU pages over slab pages.
 		 */
 		if (scanning_global_lru(sc)) {
 			unsigned long lru_pages = 0;
@@ -2347,7 +2349,7 @@ static unsigned long do_try_to_free_pages(struct zonelist *zonelist,
 			wakeup_flusher_threads(laptop_mode ? 0 : total_scanned);
 			sc->may_writepage = 1;
 		}
-	} while (--sc->priority >= 0);
+	} while (--sc->priority >= 0 && !aborted_reclaim);
 
 out:
 	delayacct_freepages_end();
