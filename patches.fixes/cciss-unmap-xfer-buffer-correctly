From: Hannes Reinecke <hare@suse.de>
Subject: cciss causes kernel WARNING with intel_iommu=on
References: bnc#590856
Patch-Mainline: Not yet

When booting with 'intel_iommu=on', the cciss driver will hit
a kernel WARNING during multipath startup:

WARNING: at drivers/pci/intel-iommu.c:2746 intel_unmap_page+0x114/0x1e0()
Hardware name: ProLiant DL360 G6
Driver unmaps unmatched page at PFN 0

This warning is from the CCISS_PASSTHRU ioctl; when sending a command
with no data (like TEST_UNIT_READY) the driver tries to unmap a
zero-sized page.

Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/block/cciss.c b/drivers/block/cciss.c
index 1804184..af75445 100644
--- a/drivers/block/cciss.c
+++ b/drivers/block/cciss.c
@@ -1302,6 +1300,7 @@ static int cciss_ioctl(struct block_device *bdev, fmode_t mode,
 			CommandList_struct *c;
 			char *buff = NULL;
 			u64bit temp64;
+			int retval = -EFAULT;
 			unsigned long flags;
 			DECLARE_COMPLETION_ONSTACK(wait);
 
@@ -1335,7 +1334,7 @@ static int cciss_ioctl(struct block_device *bdev, fmode_t mode,
 					kfree(buff);
 					return -EFAULT;
 				}
-			} else {
+			} else if (iocommand.buf_size > 0) {
 				memset(buff, 0, iocommand.buf_size);
 			}
 			if ((c = cmd_alloc(host, 0)) == NULL) {
@@ -1383,35 +1382,34 @@ static int cciss_ioctl(struct block_device *bdev, fmode_t mode,
 			wait_for_completion(&wait);
 
 			/* unlock the buffers from DMA */
-			temp64.val32.lower = c->SG[0].Addr.lower;
-			temp64.val32.upper = c->SG[0].Addr.upper;
-			pci_unmap_single(host->pdev, (dma_addr_t) temp64.val,
-					 iocommand.buf_size,
-					 PCI_DMA_BIDIRECTIONAL);
-
+			if (iocommand.buf_size > 0) {
+				temp64.val32.lower = c->SG[0].Addr.lower;
+				temp64.val32.upper = c->SG[0].Addr.upper;
+				pci_unmap_single(host->pdev,
+						 (dma_addr_t) temp64.val,
+						 iocommand.buf_size,
+						 PCI_DMA_BIDIRECTIONAL);
+			}
 			check_ioctl_unit_attention(host, c);
 
 			/* Copy the error information out */
 			iocommand.error_info = *(c->err_info);
 			if (copy_to_user
-			    (argp, &iocommand, sizeof(IOCTL_Command_struct))) {
-				kfree(buff);
-				cmd_free(host, c, 0);
-				return -EFAULT;
-			}
+			    (argp, &iocommand, sizeof(IOCTL_Command_struct)))
+				goto out_pthru;
 
 			if (iocommand.Request.Type.Direction == XFER_READ) {
 				/* Copy the data out of the buffer we created */
 				if (copy_to_user
-				    (iocommand.buf, buff, iocommand.buf_size)) {
-					kfree(buff);
-					cmd_free(host, c, 0);
-					return -EFAULT;
-				}
+				    (iocommand.buf, buff, iocommand.buf_size))
+					goto out_pthru;
 			}
-			kfree(buff);
+			retval = 0;
+		out_pthru:
+			if (iocommand.buf_size > 0)
+				kfree(buff);
 			cmd_free(host, c, 0);
-			return 0;
+			return retval;
 		}
 	case CCISS_BIG_PASSTHRU:{
 			BIG_IOCTL_Command_struct *ioc;
