From: Tao Ma <boyu.mt@taobao.com>
Date: Mon, 20 Dec 2010 16:21:11 +0800
Subject: [PATCH] ocfs2: Release buffer_head in case of error in
 ocfs2_double_lock.
Patch-mainline: yes
Git-commit: 1e6d9153df27923649976554d034a69ac7b28f95

In ocfs2_double_lock, when ocfs2_inode_lock for inode1 fails, we
just unlock inode2 and return without releasing buffer we get from
inode_lock(inode2). The good thing is that it is freed by the only
caller ocfs2_rename when it exits.

But I don't think this is a right way for error handling. We should
free the buffer_head we get in ocfs2_double_lock before exit so that
the caller doesn't need to take care of it.

Signed-off-by: Tao Ma <boyu.mt@taobao.com>
Signed-off-by: Joel Becker <joel.becker@oracle.com>
Acked-by: David Sterba <dsterba@suse.cz>
---
 fs/ocfs2/namei.c |    5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

--- a/fs/ocfs2/namei.c
+++ b/fs/ocfs2/namei.c
@@ -1020,8 +1020,11 @@ static int ocfs2_double_lock(struct ocfs
 		 * An error return must mean that no cluster locks
 		 * were held on function exit.
 		 */
-		if (oi1->ip_blkno != oi2->ip_blkno)
+		if (oi1->ip_blkno != oi2->ip_blkno) {
 			ocfs2_inode_unlock(inode2, 1);
+			brelse(*bh2);
+			*bh2 = NULL;
+		}
 
 		if (status != -ENOENT)
 			mlog_errno(status);
