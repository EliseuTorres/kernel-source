From: Hannes Reinecke <hare@suse.de>
Date: Thu, 1 Aug 2013 09:38:54 +0200
Subject: dm-mpath: do not detach stale hardware handler
References: bnc#708296
Patch-Mainline: posted to linux-scsi

When switching hardware handlers the hw_handler
setting for the old table will be different from
the currently active one.
But when the old table is dropped it'll call scsi_dh_detach()
which will detach the _current_ hardware handler, not the
one specified in hw_handler_name.
Seeing that the old hardware handler is already detached
in parse_path() we need to check the current hardware
handler name in free_pgpaths() and only detach it if the
names match.

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/md/dm-mpath.c | 21 +++++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)

diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index 999656e..e68a4b8 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -167,8 +167,25 @@ static void free_pgpaths(struct list_head *pgpaths, struct dm_target *ti)
 
 	list_for_each_entry_safe(pgpath, tmp, pgpaths, list) {
 		list_del(&pgpath->list);
-		if (m->hw_handler_name && pgpath->path.dev)
-			scsi_dh_detach(bdev_get_queue(pgpath->path.dev->bdev));
+		if (pgpath->path.dev) {
+			struct request_queue *q;
+			const char *cur_hw_handler;
+
+			q = bdev_get_queue(pgpath->path.dev->bdev);
+			cur_hw_handler = scsi_dh_attached_handler_name(q, GFP_KERNEL);
+			/*
+			 * This is subtle.
+			 * scsi_dh_detach() will detach the currently
+			 * attached one, which might be different from
+			 * the one specified in m->hw_handler_name.
+			 * So if the names are different the hardware
+			 * handler was already detached in parse_path()
+			 * and we can skip this step.
+			 */
+			if (m->hw_handler_name &&
+			    !strcmp(m->hw_handler_name, cur_hw_handler))
+				scsi_dh_detach(q);
+		}
 		dm_put_device(ti, pgpath->path.dev);
 		free_pgpath(pgpath);
 	}
-- 
1.7.12.4

