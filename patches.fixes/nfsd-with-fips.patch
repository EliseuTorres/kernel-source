Subject: Allow nfsdv4 to work when fips=1
Patch-mainline: no, code totally difference
References: bnc#868488
From: NeilBrown <neilb@suse.de>

nfsd needs md5 to calculate a hash of data used to identify
a client.
This is used as a filename when storing client state data
on stable storage.

When kernel is booted with fips=1, md5 is not allowed so this fails.

So copy the md5 code into fs/nfsd/ and use it directly.

FIPS allows md5 to be used in situations like this.

Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/nfsd/Makefile      |    2 
 fs/nfsd/md5.c         |  164 ++++++++++++++++++++++++++++++++++++++++++++++++++
 fs/nfsd/nfs4recover.c |   10 ++-
 fs/nfsd/nfsctl.c      |    2 
 4 files changed, 176 insertions(+), 2 deletions(-)

--- linux-3.0-SLE11-SP3.orig/fs/nfsd/Makefile
+++ linux-3.0-SLE11-SP3/fs/nfsd/Makefile
@@ -10,4 +10,4 @@ nfsd-$(CONFIG_NFSD_V2_ACL) += nfs2acl.o
 nfsd-$(CONFIG_NFSD_V3)	+= nfs3proc.o nfs3xdr.o
 nfsd-$(CONFIG_NFSD_V3_ACL) += nfs3acl.o
 nfsd-$(CONFIG_NFSD_V4)	+= nfs4proc.o nfs4xdr.o nfs4state.o nfs4idmap.o \
-			   nfs4acl.o nfs4callback.o nfs4recover.o
+			   nfs4acl.o nfs4callback.o nfs4recover.o md5.o
--- /dev/null
+++ linux-3.0-SLE11-SP3/fs/nfsd/md5.c
@@ -0,0 +1,164 @@
+/* 
+ * Cryptographic API.
+ *
+ * MD5 Message Digest Algorithm (RFC1321).
+ *
+ * Derived from cryptoapi implementation, originally based on the
+ * public domain implementation written by Colin Plumb in 1993.
+ *
+ * Copyright (c) Cryptoapi developers.
+ * Copyright (c) 2002 James Morris <jmorris@intercode.com.au>
+ * 
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option) 
+ * any later version.
+ *
+ */
+#include <crypto/internal/hash.h>
+#include <crypto/md5.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/cryptohash.h>
+#include <asm/byteorder.h>
+
+/* XXX: this stuff can be optimized */
+static inline void le32_to_cpu_array(u32 *buf, unsigned int words)
+{
+	while (words--) {
+		__le32_to_cpus(buf);
+		buf++;
+	}
+}
+
+static inline void cpu_to_le32_array(u32 *buf, unsigned int words)
+{
+	while (words--) {
+		__cpu_to_le32s(buf);
+		buf++;
+	}
+}
+
+static inline void md5_transform_helper(struct md5_state *ctx)
+{
+	le32_to_cpu_array(ctx->block, sizeof(ctx->block) / sizeof(u32));
+	md5_transform(ctx->hash, ctx->block);
+}
+
+static int md5_init(struct shash_desc *desc)
+{
+	struct md5_state *mctx = shash_desc_ctx(desc);
+
+	mctx->hash[0] = 0x67452301;
+	mctx->hash[1] = 0xefcdab89;
+	mctx->hash[2] = 0x98badcfe;
+	mctx->hash[3] = 0x10325476;
+	mctx->byte_count = 0;
+
+	return 0;
+}
+
+static int md5_update(struct shash_desc *desc, const u8 *data, unsigned int len)
+{
+	struct md5_state *mctx = shash_desc_ctx(desc);
+	const u32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);
+
+	mctx->byte_count += len;
+
+	if (avail > len) {
+		memcpy((char *)mctx->block + (sizeof(mctx->block) - avail),
+		       data, len);
+		return 0;
+	}
+
+	memcpy((char *)mctx->block + (sizeof(mctx->block) - avail),
+	       data, avail);
+
+	md5_transform_helper(mctx);
+	data += avail;
+	len -= avail;
+
+	while (len >= sizeof(mctx->block)) {
+		memcpy(mctx->block, data, sizeof(mctx->block));
+		md5_transform_helper(mctx);
+		data += sizeof(mctx->block);
+		len -= sizeof(mctx->block);
+	}
+
+	memcpy(mctx->block, data, len);
+
+	return 0;
+}
+
+static int md5_final(struct shash_desc *desc, u8 *out)
+{
+	struct md5_state *mctx = shash_desc_ctx(desc);
+	const unsigned int offset = mctx->byte_count & 0x3f;
+	char *p = (char *)mctx->block + offset;
+	int padding = 56 - (offset + 1);
+
+	*p++ = 0x80;
+	if (padding < 0) {
+		memset(p, 0x00, padding + sizeof (u64));
+		md5_transform_helper(mctx);
+		p = (char *)mctx->block;
+		padding = 56;
+	}
+
+	memset(p, 0, padding);
+	mctx->block[14] = mctx->byte_count << 3;
+	mctx->block[15] = mctx->byte_count >> 29;
+	le32_to_cpu_array(mctx->block, (sizeof(mctx->block) -
+	                  sizeof(u64)) / sizeof(u32));
+	md5_transform(mctx->hash, mctx->block);
+	cpu_to_le32_array(mctx->hash, sizeof(mctx->hash) / sizeof(u32));
+	memcpy(out, mctx->hash, sizeof(mctx->hash));
+	memset(mctx, 0, sizeof(*mctx));
+
+	return 0;
+}
+
+static int md5_export(struct shash_desc *desc, void *out)
+{
+	struct md5_state *ctx = shash_desc_ctx(desc);
+
+	memcpy(out, ctx, sizeof(*ctx));
+	return 0;
+}
+
+static int md5_import(struct shash_desc *desc, const void *in)
+{
+	struct md5_state *ctx = shash_desc_ctx(desc);
+
+	memcpy(ctx, in, sizeof(*ctx));
+	return 0;
+}
+
+struct shash_alg md5_alg = {
+	.digestsize	=	MD5_DIGEST_SIZE,
+	.init		=	md5_init,
+	.update		=	md5_update,
+	.final		=	md5_final,
+	.export		=	md5_export,
+	.import		=	md5_import,
+	.descsize	=	sizeof(struct md5_state),
+	.statesize	=	sizeof(struct md5_state),
+	.base		=	{
+		.cra_name	=	"md5-nfsd",
+		.cra_flags	=	CRYPTO_ALG_TYPE_SHASH,
+		.cra_blocksize	=	MD5_HMAC_BLOCK_SIZE,
+		.cra_module	=	THIS_MODULE,
+		.cra_priority	=	-1, /* ensure crypto_register_alg fails
+					     * after crypto_register_shash has
+					     * done the important bit.
+					     */
+	}
+};
+
+int nfsd_md5_mod_init(void)
+{
+	return crypto_register_shash(&md5_alg);
+}
+
--- linux-3.0-SLE11-SP3.orig/fs/nfsd/nfs4recover.c
+++ linux-3.0-SLE11-SP3/fs/nfsd/nfs4recover.c
@@ -82,6 +82,11 @@ md5_to_hex(char *out, char *md5)
 	*out = '\0';
 }
 
+#include <crypto/hash.h>
+extern struct shash_alg md5_alg;
+struct crypto_tfm *__crypto_alloc_tfm(struct crypto_alg *alg, u32 type,
+				      u32 mask);
+
 __be32
 nfs4_make_rec_clidname(char *dname, struct xdr_netobj *clname)
 {
@@ -93,7 +98,10 @@ nfs4_make_rec_clidname(char *dname, stru
 	dprintk("NFSD: nfs4_make_rec_clidname for %.*s\n",
 			clname->len, clname->data);
 	desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;
-	desc.tfm = crypto_alloc_hash("md5", 0, CRYPTO_ALG_ASYNC);
+	desc.tfm = __crypto_hash_cast(
+		__crypto_alloc_tfm(
+			&md5_alg.base, CRYPTO_ALG_TYPE_HASH,
+			CRYPTO_ALG_TYPE_HASH_MASK));
 	if (IS_ERR(desc.tfm))
 		goto out_no_tfm;
 	cksum.len = crypto_hash_digestsize(desc.tfm);
--- linux-3.0-SLE11-SP3.orig/fs/nfsd/nfsctl.c
+++ linux-3.0-SLE11-SP3/fs/nfsd/nfsctl.c
@@ -1466,10 +1466,12 @@ static int create_proc_exports_entry(voi
 }
 #endif
 
+int nfsd_md5_mod_init(void);
 static int __init init_nfsd(void)
 {
 	int retval;
 	printk(KERN_INFO "Installing knfsd (copyright (C) 1996 okir@monad.swb.de).\n");
+	nfsd_md5_mod_init();
 
 	retval = nfs4_state_init(); /* nfs4 locking state */
 	if (retval)
