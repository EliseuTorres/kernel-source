Subject: sched, cgroups: disallow attaching kthreadd
From: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date: Tue Oct 18 07:40:56 CEST 2011
Patch-mainline: not yet - submitted
References: bnc#721840

Allowing kthreadd to be moved to a non-root group makes no sense, it being
a global resource, and needlessly leads unsuspecting users toward trouble.

1. An RT workqueue worker thread spawned in a task group with no rt_runtime
allocated is not schedulable.  Simple user error, but harmful to the box.

2. A worker thread which acquires PF_THREAD_BOUND can never leave a cpuset,
rendering the cpuset immortal.

Save the user some unexpected trouble, just say no.

Peterz suggested making it a global cgroup thing, so he gets the credit.

Signed-off-by: Mike Galbraith <mgalbraith@suse.de>

---
 kernel/cgroup.c |    9 +++++++++
 1 file changed, 9 insertions(+)

Index: linux-3.0-SLE11-SP2/kernel/cgroup.c
===================================================================
--- linux-3.0-SLE11-SP2.orig/kernel/cgroup.c
+++ linux-3.0-SLE11-SP2/kernel/cgroup.c
@@ -58,6 +58,7 @@
 #include <linux/eventfd.h>
 #include <linux/poll.h>
 #include <linux/flex_array.h> /* used in cgroup_attach_proc */
+#include <linux/kthread.h>
 
 #include <asm/atomic.h>
 
@@ -1821,6 +1822,14 @@ int cgroup_attach_task(struct cgroup *cg
 	struct cgroup *oldcgrp;
 	struct cgroupfs_root *root = cgrp->root;
 
+	/*
+	 * Workqueue threads may acquire PF_THREAD_BOUND and become
+	 * trapped in a cpuset, or RT worker may be born in a cgroup
+	 * with no rt_runtime allocated.  Just say no.
+	 */
+	if (tsk == kthreadd_task)
+		return -EINVAL;
+
 	/* Nothing to do if the task is already in that cgroup */
 	oldcgrp = task_cgroup_from_root(tsk, root);
 	if (cgrp == oldcgrp)
