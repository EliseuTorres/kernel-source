From: Al Viro <viro@zeniv.linux.org.uk>
Date: Sun, 26 Oct 2014 19:19:16 -0400
Subject: [PATCH 1/2] move d_rcu from overlapping d_child to overlapping d_alias
Git-commit: 946e51f2bf37f1656916eb75bd0742ba33983c28
Patch-mainline: v3.19-rc1
References: bnc#903640 CVE-2014-8559

Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Acked-by: Miklos Szeredi <mszeredi@suse.cz>
---
 fs/dcache.c            |    8 ++++----
 include/linux/dcache.h |   12 +++++++-----
 2 files changed, 11 insertions(+), 9 deletions(-)

--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -176,9 +176,8 @@ int proc_nr_dentry(ctl_table *table, int
 
 static void __d_free(struct rcu_head *head)
 {
-	struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);
+	struct dentry *dentry = container_of(head, struct dentry, d_rcu);
 
-	WARN_ON(!list_empty(&dentry->d_alias));
 	if (dname_external(dentry))
 		kfree(dentry->d_name.name);
 	kmem_cache_free(dentry_cache, dentry); 
@@ -189,6 +188,7 @@ static void __d_free(struct rcu_head *he
  */
 static void d_free(struct dentry *dentry)
 {
+	WARN_ON(!list_empty(&dentry->d_alias));
 	BUG_ON((int)dentry->d_lockref.count > 0);
 	this_cpu_dec(nr_dentry);
 	if (dentry->d_op && dentry->d_op->d_release)
@@ -196,9 +196,9 @@ static void d_free(struct dentry *dentry
 
 	/* if dentry was never visible to RCU, immediate free is OK */
 	if (!(dentry->d_flags & DCACHE_RCUACCESS))
-		__d_free(&dentry->d_u.d_rcu);
+		__d_free(&dentry->d_rcu);
 	else
-		call_rcu(&dentry->d_u.d_rcu, __d_free);
+		call_rcu(&dentry->d_rcu, __d_free);
 }
 
 /**
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -138,15 +138,17 @@ struct dentry {
 	void *d_fsdata;			/* fs-specific data */
 
 	struct list_head d_lru;		/* LRU list */
-	/*
-	 * d_child and d_rcu can share memory
-	 */
 	union {
 		struct list_head d_child;	/* child of parent list */
-	 	struct rcu_head d_rcu;
 	} d_u;
 	struct list_head d_subdirs;	/* our children */
-	struct list_head d_alias;	/* inode alias list */
+	/*
+	 * d_alias and d_rcu can share memory
+	 */
+	union {
+		struct list_head d_alias;	/* inode alias list */
+	 	struct rcu_head d_rcu;
+	};
 };
 
 #define d_lock	d_lockref.lock
