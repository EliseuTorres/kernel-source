From: Mark Tinguely <tinguely@sgi.com>
Subject: xfs: Move allocation stack switch up to xfs_bmapi
Patch-mainline: No (function structure different upstream)
Git-commit: e04426b9202bccd4cfcbc70b2fa2aeca1c86d8f5
Git-commit: 9e96fe6df44425b69ed89f6ac20352cec1f127d7
References: bnc#815356

This is SGI version of the allocation worker move patches.
I found the AGF buffer hang and this was the initial patch.
It works better for our software and has been customer tested
in our product for several month.

The Community patches:
	commit e04426b9202bccd4cfcbc70b2fa2aeca1c86d8f5
	Author: Dave Chinner <dchinner@redhat.com>
	Date:   Fri Oct 5 11:06:59 2012 +1000
	xfs: move allocation stack switch up to xfs_bmapi_allocate
and
	commit 9e96fe6df44425b69ed89f6ac20352cec1f127d7
	Author: Brian Foster <bfoster@redhat.com>
	Date:   Thu Jan 17 13:11:29 2013 -0500
	xfs: pull up stack_switch check into xfs_bmapi_write

If a thread is using the worker allocation to avoid stack overflow,
make sure it hold the worker until xfs_trans_commit or xfs_trans_cancel.
This avoids a hang on the allocation group freelist buffer.
 
This is uses a bmapi flag (XFS_BMAPI_STACK_SWITCH) to denote the thread
needs an allocation worker. So far only xfs_iomap_write_allocate() uses the
allocation worker.

Signed-off-by: Mark Tinguely <tinguely@sgi.com>
Acked-by: Jan Kara <jack@suse.cz>
---
 fs/xfs/xfs_alloc.c |   42 -------------------------------------
 fs/xfs/xfs_alloc.h |    3 --
 fs/xfs/xfs_bmap.c  |   60 ++++++++++++++++++++++++++++++++++++++++++++++++++++-
 fs/xfs/xfs_bmap.h  |   21 ++++++++++++++++--
 fs/xfs/xfs_iomap.c |    5 ++--
 5 files changed, 82 insertions(+), 49 deletions(-)

Index: linux-3.0-SLE11-SP3-xfs_stack_alloc/fs/xfs/xfs_alloc.c
===================================================================
--- linux-3.0-SLE11-SP3-xfs_stack_alloc.orig/fs/xfs/xfs_alloc.c
+++ linux-3.0-SLE11-SP3-xfs_stack_alloc/fs/xfs/xfs_alloc.c
@@ -2214,7 +2214,7 @@ xfs_alloc_read_agf(
  * group or loop over the allocation groups to find the result.
  */
 int				/* error */
-__xfs_alloc_vextent(
+xfs_alloc_vextent(
 	xfs_alloc_arg_t	*args)	/* allocation argument structure */
 {
 	xfs_agblock_t	agsize;	/* allocation group size */
@@ -2424,46 +2424,6 @@ error0:
 	return error;
 }
 
-static void
-xfs_alloc_vextent_worker(
-	struct work_struct	*work)
-{
-	struct xfs_alloc_arg	*args = container_of(work,
-						struct xfs_alloc_arg, work);
-	unsigned long		pflags;
-
-	/* we are in a transaction context here */
-	current_set_flags_nested(&pflags, PF_FSTRANS);
-
-	args->result = __xfs_alloc_vextent(args);
-	complete(args->done);
-
-	current_restore_flags_nested(&pflags, PF_FSTRANS);
-}
-
-/*
- * Data allocation requests often come in with little stack to work on. Push
- * them off to a worker thread so there is lots of stack to use. Metadata
- * requests, OTOH, are generally from low stack usage paths, so avoid the
- * context switch overhead here.
- */
-int
-xfs_alloc_vextent(
-	struct xfs_alloc_arg	*args)
-{
-	DECLARE_COMPLETION_ONSTACK(done);
-
-	if (!args->stack_switch)
-		return __xfs_alloc_vextent(args);
-
-
-	args->done = &done;
-	INIT_WORK_ONSTACK(&args->work, xfs_alloc_vextent_worker);
-	queue_work(xfs_alloc_wq, &args->work);
-	wait_for_completion(&done);
-	return args->result;
-}
-
 /*
  * Free an extent.
  * Just break up the extent address and hand off to xfs_free_ag_extent
Index: linux-3.0-SLE11-SP3-xfs_stack_alloc/fs/xfs/xfs_alloc.h
===================================================================
--- linux-3.0-SLE11-SP3-xfs_stack_alloc.orig/fs/xfs/xfs_alloc.h
+++ linux-3.0-SLE11-SP3-xfs_stack_alloc/fs/xfs/xfs_alloc.h
@@ -121,10 +121,6 @@ typedef struct xfs_alloc_arg {
 	char		isfl;		/* set if is freelist blocks - !acctg */
 	char		userdata;	/* set if this is user data */
 	xfs_fsblock_t	firstblock;	/* io first block allocated */
-	struct completion *done;
-	struct work_struct work;
-	int		result;
-	char		stack_switch;
 } xfs_alloc_arg_t;
 
 /*
Index: linux-3.0-SLE11-SP3-xfs_stack_alloc/fs/xfs/xfs_bmap.c
===================================================================
--- linux-3.0-SLE11-SP3-xfs_stack_alloc.orig/fs/xfs/xfs_bmap.c
+++ linux-3.0-SLE11-SP3-xfs_stack_alloc/fs/xfs/xfs_bmap.c
@@ -2567,7 +2567,6 @@ xfs_bmap_btalloc(
 	args.tp = ap->tp;
 	args.mp = mp;
 	args.fsbno = ap->rval;
-	args.stack_switch = ap->stack_switch;
 
 	/* Trim the allocation back to the maximum an AG can fit. */
 	args.maxlen = MIN(ap->alen, XFS_ALLOC_AG_MAX_USABLE(mp));
@@ -4306,7 +4305,7 @@ xfs_bmap_validate_ret(
  * blocks then the call will fail (return NULLFSBLOCK in "firstblock").
  */
 int					/* error */
-xfs_bmapi(
+__xfs_bmapi(
 	xfs_trans_t	*tp,		/* transaction pointer */
 	xfs_inode_t	*ip,		/* incore inode */
 	xfs_fileoff_t	bno,		/* starting file offs. mapped */
@@ -4606,9 +4605,6 @@ xfs_bmapi(
 				} else
 					bma.aeof = 0;
 
-				if (flags & XFS_BMAPI_STACK_SWITCH)
-					bma.stack_switch = 1;
-
 				/*
 				 * Call allocator.
 				 */
@@ -4895,6 +4891,64 @@ error0:
 	return error;
 }
 
+static void
+xfs_bmapi_alloc_worker(
+struct work_struct      *work)
+{
+	struct xfs_bmw_wkr	*bw = container_of(work,
+						   struct xfs_bmw_wkr, work);
+	unsigned long		pflags;
+
+	/* we are in a transaction context here */
+	current_set_flags_nested(&pflags, PF_FSTRANS);
+
+	bw->result = __xfs_bmapi(bw->tp, bw->ip, bw->bno, bw->len,
+				       bw->flags, bw->firstblock, bw->total,
+				       bw->mval, bw->nmap, bw->flist);
+	complete(bw->done);
+
+	current_restore_flags_nested(&pflags, PF_FSTRANS);
+}
+
+int
+xfs_bmapi(
+	xfs_trans_t	*tp,		/* transaction pointer */
+	xfs_inode_t	*ip,		/* incore inode */
+	xfs_fileoff_t	bno,		/* starting file offs. mapped */
+	xfs_filblks_t	len,		/* length to map in file */
+	int		flags,		/* XFS_BMAPI_... */
+	xfs_fsblock_t	*firstblock,	/* first allocated block
+					   controls a.g. for allocs */
+	xfs_extlen_t	total,		/* total blocks needed */
+	xfs_bmbt_irec_t	*mval,		/* output: map values */
+	int		*nmap,		/* i/o: mval size/count */
+	xfs_bmap_free_t	*flist)		/* i/o: list extents to free */
+{
+	struct xfs_bmw_wkr	bw;
+	DECLARE_COMPLETION_ONSTACK(done);
+
+	if (!(flags & XFS_BMAPI_STACK_SWITCH)) {
+		return __xfs_bmapi(tp, ip, bno, len, flags, firstblock,
+				   total, mval, nmap, flist);
+	}
+	/* initialize the worker argument list structure */
+	bw.tp = tp;
+	bw.ip = ip;
+	bw.bno = bno;
+	bw.len = len;
+	bw.flags = flags;
+	bw.firstblock = firstblock;
+	bw.total = total;
+	bw.mval = mval;
+	bw.nmap = nmap;
+	bw.flist = flist;
+	bw.done = &done;
+	INIT_WORK_ONSTACK(&bw.work, xfs_bmapi_alloc_worker);
+	queue_work(xfs_alloc_wq, &bw.work);
+	wait_for_completion(&done);
+	return bw.result;
+}
+
 /*
  * Map file blocks to filesystem blocks, simple version.
  * One block (extent) only, read-only.
Index: linux-3.0-SLE11-SP3-xfs_stack_alloc/fs/xfs/xfs_bmap.h
===================================================================
--- linux-3.0-SLE11-SP3-xfs_stack_alloc.orig/fs/xfs/xfs_bmap.h
+++ linux-3.0-SLE11-SP3-xfs_stack_alloc/fs/xfs/xfs_bmap.h
@@ -132,9 +132,24 @@ typedef struct xfs_bmalloca {
 	char			low;	/* low on space, using seq'l ags */
 	char			aeof;	/* allocated space at eof */
 	char			conv;	/* overwriting unwritten extents */
-	char			stack_switch;
 } xfs_bmalloca_t;
 
+struct xfs_bmw_wkr {
+	struct xfs_trans	*tp;		/* transaction pointer */
+	struct xfs_inode	*ip;		/* incore inode */
+	xfs_fileoff_t		bno;		/* starting file offs. mapped */
+	xfs_filblks_t		len;		/* length to map in file */
+	int			flags;		/* XFS_BMAPI_... */
+	xfs_fsblock_t		*firstblock;	/* first allocblock controls */
+	xfs_extlen_t		total;		/* total blocks needed */
+	struct xfs_bmbt_irec	*mval;		/* output: map values */
+	int			*nmap;		/* i/o: mval size/count */
+	struct xfs_bmap_free	*flist;		/* bmap freelist */
+	struct completion	*done;		/* worker completion ptr */
+	struct work_struct	work;		/* worker */
+	int			result;		/* worker function result */
+} ;
+
 /*
  * Flags for xfs_bmap_add_extent*.
  */
