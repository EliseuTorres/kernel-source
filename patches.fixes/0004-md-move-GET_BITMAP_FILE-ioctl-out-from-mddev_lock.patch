From: NeilBrown <neilb@suse.de>
Date: Mon, 15 Dec 2014 12:57:00 +1100
Subject: [PATCH] md: move GET_BITMAP_FILE ioctl out from mddev_lock.
Git-commit: 4af1a04176bdb4688aa14f6c10d1d5131c036a9d
Patch-mainline: v4.0
References: bsc#943270

It makes more sense to report bitmap_info->file, rather than
bitmap->file (the later is only available once the array is
active).

With that change, use mddev->write_lock to protect bitmap_info being
set to NULL, and we can call get_bitmap_file() without taking
the mutex.

Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: NeilBrown <neilb@suse.com>

---
 drivers/md/md.c |   57 +++++++++++++++++++++++++++++++-------------------------
 1 file changed, 32 insertions(+), 25 deletions(-)

--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -5551,8 +5551,11 @@ static int do_md_stop(struct mddev * mdd
 
 		bitmap_destroy(mddev);
 		if (mddev->bitmap_info.file) {
-			fput(mddev->bitmap_info.file);
+			struct file *f = mddev->bitmap_info.file;
+			spin_lock(&mddev->write_lock);
 			mddev->bitmap_info.file = NULL;
+			spin_unlock(&mddev->write_lock);
+			fput(f);
 		}
 		mddev->bitmap_info.offset = 0;
 
@@ -5762,31 +5765,30 @@ static int get_bitmap_file(struct mddev
 {
 	mdu_bitmap_file_t *file = NULL; /* too big for stack allocation */
 	char *ptr;
-	int err = -ENOMEM;
+	int err;
 
 	file = kzalloc(sizeof(*file), GFP_NOIO);
 	if (!file)
-		goto out;
+		return -ENOMEM;
 
+	err = 0;
+	spin_lock(&mddev->write_lock);
 	/* bitmap disabled, zero the first byte and copy out */
-	if (!mddev->bitmap || !mddev->bitmap->storage.file) {
+	if (!mddev->bitmap_info.file)
 		file->pathname[0] = '\0';
-		goto copy_out;
-	}
-
-	ptr = d_path(&mddev->bitmap->storage.file->f_path,
-		     file->pathname, sizeof(file->pathname));
-	if (IS_ERR(ptr))
-		goto out;
-
-	memmove(file->pathname, ptr,
-		sizeof(file->pathname)-(ptr-file->pathname));
+	else if ((ptr = d_path(&mddev->bitmap_info.file->f_path,
+			       file->pathname, sizeof(file->pathname))),
+		 IS_ERR(ptr))
+		err = PTR_ERR(ptr);
+	else
+		memmove(file->pathname, ptr,
+			sizeof(file->pathname)-(ptr-file->pathname));
+	spin_unlock(&mddev->write_lock);
 
-copy_out:
-	err = 0;
-	if (copy_to_user(arg, file, sizeof(*file)))
+	if (err == 0 &&
+	    copy_to_user(arg, file, sizeof(*file)))
 		err = -EFAULT;
-out:
+
 	kfree(file);
 	return err;
 }
@@ -6173,9 +6175,13 @@ static int set_bitmap_file(struct mddev
 		mddev->pers->quiesce(mddev, 0);
 	}
 	if (fd < 0) {
-		if (mddev->bitmap_info.file)
-			fput(mddev->bitmap_info.file);
-		mddev->bitmap_info.file = NULL;
+		struct file *f = mddev->bitmap_info.file;
+		if (f) {
+			spin_lock(&mddev->write_lock);
+			mddev->bitmap_info.file = NULL;
+			spin_unlock(&mddev->write_lock);
+			fput(f);
+		}
 	}
 
 	return err;
@@ -6559,6 +6565,11 @@ static int md_ioctl(struct block_device
 	case SET_DISK_FAULTY:
 		err = set_disk_faulty(mddev, new_decode_dev(arg));
 		goto abort;
+
+	case GET_BITMAP_FILE:
+		err = get_bitmap_file(mddev, argp);
+		goto abort;
+
 	}
 
 	if (cmd == ADD_NEW_DISK)
@@ -6650,10 +6661,6 @@ static int md_ioctl(struct block_device
 	 * Commands even a read-only array can execute:
 	 */
 	switch (cmd) {
-	case GET_BITMAP_FILE:
-		err = get_bitmap_file(mddev, argp);
-		goto done_unlock;
-
 	case RESTART_ARRAY_RW:
 		err = restart_array(mddev);
 		goto done_unlock;
