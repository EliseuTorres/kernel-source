From: John Fastabend <john.r.fastabend@intel.com>
Date: Tue, 26 Nov 2013 06:33:52 +0000
Subject: [PATCH] net: allow netdev_all_upper_get_next_dev_rcu with rtnl lock
 held
Patch-mainline: v3.13-rc7
Git-commit: 85328240c625f322af9f69c7b60e619717101d77
References: bnc#857401 FATE#315668

It is useful to be able to walk all upper devices when bringing
a device online where the RTNL lock is held. In this case it
is safe to walk the all_adj_list because the RTNL lock is used
to protect the write side as well.

This patch adds a check to see if the rtnl lock is held before
throwing a warning in netdev_all_upper_get_next_dev_rcu().

Also because we now have a call site for lockdep_rtnl_is_held()
outside COFIG_LOCK_PROVING an inline definition returning 1 is
needed. Similar to the rcu_read_lock_is_held().

Fixes: 2a47fa45d4df ("ixgbe: enable l2 forwarding acceleration for macvlans")
CC: Veaceslav Falico <vfalico@redhat.com>
Reported-by: Yuanhan Liu <yuanhan.liu@linux.intel.com>
Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: David Chang <dchang@suse.com>
---
 include/linux/rtnetlink.h |    5 +++++
 net/core/dev.c            |    2 +-
 2 files changed, 6 insertions(+), 1 deletion(-)
--- a/include/linux/rtnetlink.h
+++ b/include/linux/rtnetlink.h
@@ -29,6 +29,11 @@ extern struct mutex net_mutex;
 
 #ifdef CONFIG_PROVE_LOCKING
 extern int lockdep_rtnl_is_held(void);
+#else
+static inline int lockdep_rtnl_is_held(void)
+{
+	return 1;
+}
 #endif /* #ifdef CONFIG_PROVE_LOCKING */
 
 /**
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -4483,7 +4483,7 @@ struct net_device *netdev_all_upper_get_
 {
 	struct netdev_adjacent *upper;
 
-	WARN_ON_ONCE(!rcu_read_lock_held());
+	WARN_ON_ONCE(!rcu_read_lock_held() && !lockdep_rtnl_is_held());
 
 	upper = list_entry_rcu((*iter)->next, struct netdev_adjacent, list);
 
