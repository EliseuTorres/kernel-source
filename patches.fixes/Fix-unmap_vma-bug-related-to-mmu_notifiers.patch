From: Jack Steiner <steiner@sgi.com>
Subject: Fix unmap_vma bug related to mmu_notifiers
References: bnc#578046, FATE#306952
Patch-mainline: not yet

unmap_vmas() can fail to correctly flush the TLB if a
callout to mmu_notifier_invalidate_range_start() sleeps.
The mmu_gather list is initialized prior to the callout. If it is reused
while the thread is sleeping, the mm field may be invalid.

If the task migrates to a different cpu, the task may use the wrong
mmu_gather.

The patch changes unmap_vmas() to initialize the mmu_gather
AFTER the mmu_notifier completes.

Signed-off-by: Jack Steiner <steiner@sgi.com>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
Acked-by: Michal Hocko <mhocko@suse.cz>
---
 include/linux/mm.h |    2 +-
 mm/memory.c        |   10 +++++++---
 mm/mmap.c          |    6 ++----
 3 files changed, 10 insertions(+), 8 deletions(-)
Index: linux-3.0-SLE11-SP2-3.0/include/linux/mm.h
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/include/linux/mm.h
+++ linux-3.0-SLE11-SP2-3.0/include/linux/mm.h
@@ -897,7 +897,7 @@ unsigned long zap_page_range(struct vm_a
 unsigned long unmap_vmas(struct mmu_gather *tlb,
 		struct vm_area_struct *start_vma, unsigned long start_addr,
 		unsigned long end_addr, unsigned long *nr_accounted,
-		struct zap_details *);
+		struct zap_details *, int fullmm);
 
 /**
  * mm_walk - callbacks for walk_page_range
Index: linux-3.0-SLE11-SP2-3.0/mm/memory.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/mm/memory.c
+++ linux-3.0-SLE11-SP2-3.0/mm/memory.c
@@ -1326,12 +1326,17 @@ static unsigned long unmap_page_range(st
 unsigned long unmap_vmas(struct mmu_gather *tlb,
 		struct vm_area_struct *vma, unsigned long start_addr,
 		unsigned long end_addr, unsigned long *nr_accounted,
-		struct zap_details *details)
+		struct zap_details *details, int fullmm)
 {
 	unsigned long start = start_addr;
 	struct mm_struct *mm = vma->vm_mm;
 
+	/*
+	 * mmu_notifier_invalidate_range_start can sleep. Don't initialize
+	 * mmu_gather until it completes
+	 */
 	mmu_notifier_invalidate_range_start(mm, start_addr, end_addr);
+	tlb_gather_mmu(tlb, mm, fullmm);
 	for ( ; vma && vma->vm_start < end_addr; vma = vma->vm_next) {
 		unsigned long end;
 
@@ -1390,9 +1395,8 @@ unsigned long zap_page_range(struct vm_a
 	unsigned long nr_accounted = 0;
 
 	lru_add_drain();
-	tlb_gather_mmu(&tlb, mm, 0);
 	update_hiwater_rss(mm);
-	end = unmap_vmas(&tlb, vma, address, end, &nr_accounted, details);
+	end = unmap_vmas(&tlb, vma, address, end, &nr_accounted, details, 0);
 	tlb_finish_mmu(&tlb, address, end);
 	return end;
 }
Index: linux-3.0-SLE11-SP2-3.0/mm/mmap.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/mm/mmap.c
+++ linux-3.0-SLE11-SP2-3.0/mm/mmap.c
@@ -1889,9 +1889,8 @@ static void unmap_region(struct mm_struc
 	unsigned long nr_accounted = 0;
 
 	lru_add_drain();
-	tlb_gather_mmu(&tlb, mm, 0);
 	update_hiwater_rss(mm);
-	unmap_vmas(&tlb, vma, start, end, &nr_accounted, NULL);
+	unmap_vmas(&tlb, vma, start, end, &nr_accounted, NULL, 0);
 	vm_unacct_memory(nr_accounted);
 	free_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,
 				 next ? next->vm_start : 0);
@@ -2263,10 +2262,9 @@ void exit_mmap(struct mm_struct *mm)
 
 	lru_add_drain();
 	flush_cache_mm(mm);
-	tlb_gather_mmu(&tlb, mm, 1);
 	/* update_hiwater_rss(mm) here? but nobody should be looking */
 	/* Use -1 here to ensure all VMAs in the mm are unmapped */
-	end = unmap_vmas(&tlb, vma, 0, -1, &nr_accounted, NULL);
+	end = unmap_vmas(&tlb, vma, 0, -1, &nr_accounted, NULL, 1);
 	vm_unacct_memory(nr_accounted);
 
 	free_pgtables(&tlb, vma, FIRST_USER_ADDRESS, 0);
