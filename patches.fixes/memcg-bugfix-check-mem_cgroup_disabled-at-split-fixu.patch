From 3d37c4a9199920964ffdfaec6335d93b9dcf9ca5 Mon Sep 17 00:00:00 2001
From: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date: Tue, 25 Jan 2011 15:07:28 -0800
Subject: [PATCH] memcg: bugfix check mem_cgroup_disabled() at split fixup
Patch-mainline: 3d37c4a9199920964ffdfaec6335d93b9dcf9ca5
References: bnc#704592

mem_cgroup_disabled() should be checked at splitting.  If disabled, no
heavy work is necesary.

Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Acked-by: Daisuke Nishimura <nishimura@mxp.nes.nec.co.jp>
Reviewed-by: Johannes Weiner <hannes@cmpxchg.org>
Cc: Balbir Singh <balbir@in.ibm.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Michal Hocko <mhocko@suse.cz>

---
 mm/memcontrol.c |   10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)
Index: linux-2.6.32-memcg-backports/mm/memcontrol.c
===================================================================
--- linux-2.6.32-memcg-backports.orig/mm/memcontrol.c
+++ linux-2.6.32-memcg-backports/mm/memcontrol.c
@@ -1768,9 +1768,14 @@ static void __mem_cgroup_commit_charge(s
  */
 void mem_cgroup_split_huge_fixup(struct page *head, struct page *tail)
 {
-	struct page_cgroup *head_pc = lookup_page_cgroup(head);
-	struct page_cgroup *tail_pc = lookup_page_cgroup(tail);
+	struct page_cgroup *head_pc;
+	struct page_cgroup *tail_pc;
 
+	if (mem_cgroup_disabled())
+		return;
+
+	head_pc = lookup_page_cgroup(head);
+	tail_pc = lookup_page_cgroup(tail);
 	tail_pc->mem_cgroup = head_pc->mem_cgroup;
 	smp_wmb(); /* see __commit_charge() */
 	if (PageCgroupAcctLRU(head_pc)) {
@@ -2176,7 +2181,6 @@ static void mem_cgroup_do_uncharge(struc
 
 	if (nr_pages > 1)
 		goto direct_uncharge;
-
 	/*
 	 * do_batch > 0 when unmapping pages or inode invalidate/truncate.
 	 * In those cases, all pages freed continously can be expected to be in
