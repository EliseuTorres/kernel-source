From: Michal Hocko <mhocko@suse.cz>
Subject: deal with deadlock in d_walk fix
Patch-mainline: no, the code is different
References: bnc#929148, bnc#929283

Neil Brown has found out that patches.fixes/deal-with-deadlock-in-d_walk.patch
has introduced a regression resulting in lockups on dentry::d_lock due to double
unlock.
have_submount might jump to `positive' label without taking d_lock on this_parent
and !locked && read_seqretry(&rename_lock, seq) check would then jump to
rename_retry which unlocks this_parent->d_lock unconditionally. One CPU might miss
its lock ticket and wait for it indefinitely as a result:

TAIL HEAD
1    1
	<- lock by A (successful)
2    1
	<- lock by C (has to wait for 2)
3    1
	<- unlock by B (no lock taken previously)
3    2
	<- unlock A before C sees 2
3    3

The vanilla kernel doesn't need this fix but it seems that the backport to
stable/linux-3.2.y is broken in the same way.

[mhocko@suse.cz: changelog]
Signed-off-by: NeilBrown <neilb@suse.de>

---
 fs/dcache.c |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -1151,7 +1151,7 @@ ascend:
 	return 0; /* No mount points found in tree */
 positive:
 	if (!locked && read_seqretry(&rename_lock, seq))
-		goto rename_retry;
+		goto rename_retry_unlocked;
 	if (locked)
 		write_sequnlock(&rename_lock);
 	return 1;
@@ -1161,6 +1161,7 @@ rename_retry:
 	rcu_read_unlock();
 	if (locked)
 		goto again;
+rename_retry_unlocked:
 	locked = 1;
 	write_seqlock(&rename_lock);
 	goto again;
@@ -1225,6 +1226,7 @@ resume:
 		 */
 		if (found && need_resched()) {
 			spin_unlock(&dentry->d_lock);
+			rcu_read_lock();
 			goto out;
 		}
 
