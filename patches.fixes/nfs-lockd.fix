From: NeilBrown <neilb@suse.de>
Date: Thu, 6 Feb 2014 16:00:12 +1100
Subject: [PATCH] lockd: send correct lock when granting a delayed lock.
Patch-mainline: submitted for 3.14
References: bnc#859342

If an NFS client attempts to get a lock (using NLM) and the lock is
not available, the server will remember the request and when the lock
becomes available it will send a GRANT request to the client to
provide the lock.

If the client already held an adjacent lock, the GRANT callback will
report the union of the existing and new locks, which can confuse the
client.

This happens because __posix_lock_file (called by vfs_lock_file)
updates the passed-in file_lock structure when adjacent or
over-lapping locks are found.

To avoid this problem we copy the lock file_lock to a temporary before
calling vfs_lock_file.  This also allows us to avoid the need to clear
the FL_SLEEP flag after the call which was set before the call.

Reported-by: Olaf Kirch <okir@suse.com>
Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/lockd/svclock.c |    7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

--- linux-3.11-openSUSE-13.1.orig/fs/lockd/svclock.c
+++ linux-3.11-openSUSE-13.1/fs/lockd/svclock.c
@@ -779,6 +779,7 @@ nlmsvc_grant_blocked(struct nlm_block *b
 	struct nlm_file		*file = block->b_file;
 	struct nlm_lock		*lock = &block->b_call->a_args.lock;
 	int			error;
+	struct file_lock	flock;
 
 	dprintk("lockd: grant blocked lock %p\n", block);
 
@@ -796,9 +797,9 @@ nlmsvc_grant_blocked(struct nlm_block *b
 	}
 
 	/* Try the lock operation again */
-	lock->fl.fl_flags |= FL_SLEEP;
-	error = vfs_lock_file(file->f_file, F_SETLK, &lock->fl, NULL);
-	lock->fl.fl_flags &= ~FL_SLEEP;
+	__locks_copy_lock(&flock, &lock->fl);
+	flock.fl_flags |= FL_SLEEP;
+	error = vfs_lock_file(file->f_file, F_SETLK, &flock, NULL);
 
 	switch (error) {
 	case 0:
