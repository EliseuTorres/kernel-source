From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 5 May 2014 11:16:26 +0200
Subject: netfilter: reuse skb->nfct_reasm for ipvs conn reference
Patch-mainline: Never, resolved in a different way
References: bnc#861980

As skb->nfct_reasm is not set for the reassembled packet, it can
be reused to reference related ip_vs_conn structure. Use least
significant bit of the field to distinguish between these two
uses and hide all accesses behind helpers to catch potential
conflicts.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/linux/skbuff.h                         | 65 +++++++++++++++++++++++---
 include/net/ip_vs.h                            | 12 +----
 net/core/skbuff.c                              |  3 +-
 net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c |  5 +-
 net/ipv6/netfilter/nf_conntrack_reasm.c        |  5 +-
 net/ipv6/xfrm6_policy.c                        |  3 +-
 net/netfilter/ipvs/ip_vs_core.c                |  9 ++--
 7 files changed, 75 insertions(+), 27 deletions(-)

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 3778c76..668671c 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -412,7 +412,7 @@ struct sk_buff {
 	struct nf_conntrack	*nfct;
 #endif
 #ifdef NET_SKBUFF_NF_DEFRAG_NEEDED
-	struct sk_buff		*nfct_reasm;
+	unsigned long		_nfct_reasm;
 #endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	struct nf_bridge_info	*nf_bridge;
@@ -476,6 +476,57 @@ struct sk_buff {
 #define SKB_ALLOC_FCLONE	0x01
 #define SKB_ALLOC_RX		0x02
 
+#ifdef NET_SKBUFF_NF_DEFRAG_NEEDED
+#define NFCT_REASM_MASK		0x1UL
+
+#define NFCT_REASM_REASM	0x0UL
+#define NFCT_REASM_IPVS		0x1UL
+
+static inline bool skb_nfct_reasm_is_reasm(const struct sk_buff *skb)
+{
+	return (skb->_nfct_reasm & NFCT_REASM_MASK) == NFCT_REASM_REASM;
+}
+
+static inline bool skb_nfct_reasm_is_ipvs(const struct sk_buff *skb)
+{
+	return (skb->_nfct_reasm & NFCT_REASM_MASK) == NFCT_REASM_IPVS;
+}
+
+static inline bool skb_is_replayed_fragment(const struct sk_buff *skb)
+{
+	return skb_nfct_reasm_is_reasm(skb) && skb->_nfct_reasm != 0;
+}
+
+static inline struct sk_buff *skb_nfct_reasm(const struct sk_buff *skb)
+{
+	BUG_ON(!skb_nfct_reasm_is_reasm(skb));
+	return (struct sk_buff *)(skb->_nfct_reasm & ~NFCT_REASM_MASK);
+}
+
+static inline void skb_set_nfct_reasm(struct sk_buff *skb,
+				      struct sk_buff *nfct_reasm)
+{
+	skb->_nfct_reasm = ((unsigned long)nfct_reasm | NFCT_REASM_REASM);
+}
+
+static inline struct ip_vs_conn *skb_ipvs_cp(const struct sk_buff *skb)
+{
+	BUG_ON(!skb_nfct_reasm_is_ipvs(skb));
+	return (struct ip_vs_conn *)(skb->_nfct_reasm & ~NFCT_REASM_MASK);
+}
+
+static inline void skb_set_ipvs_cp(struct sk_buff *skb,
+				   struct ip_vs_conn *cp)
+{
+	skb->_nfct_reasm = ((unsigned long)cp | NFCT_REASM_IPVS);
+}
+#else
+static inline struct sk_buff *skb_nfct_reasm(struct sk_buff *skb)
+{
+	return NULL;
+}
+#endif
+
 /* Returns true if the skb was allocated from PFMEMALLOC reserves */
 static inline bool skb_pfmemalloc(const struct sk_buff *skb)
 {
@@ -2398,8 +2449,9 @@ static inline void nf_reset(struct sk_buff *skb)
 	skb->nfct = NULL;
 #endif
 #ifdef NET_SKBUFF_NF_DEFRAG_NEEDED
-	nf_conntrack_put_reasm(skb->nfct_reasm);
-	skb->nfct_reasm = NULL;
+	if (skb_nfct_reasm_is_reasm(skb))
+		nf_conntrack_put_reasm(skb_nfct_reasm(skb));
+	skb->_nfct_reasm = 0;
 #endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	nf_bridge_put(skb->nf_bridge);
@@ -2424,8 +2476,8 @@ static inline void __nf_copy(struct sk_buff *dst, const struct sk_buff *src)
 	dst->nfctinfo = src->nfctinfo;
 #endif
 #ifdef NET_SKBUFF_NF_DEFRAG_NEEDED
-	dst->nfct_reasm = src->nfct_reasm;
-	nf_conntrack_get_reasm(src->nfct_reasm);
+	dst->_nfct_reasm = src->_nfct_reasm;
+	nf_conntrack_get_reasm(skb_nfct_reasm(src));
 #endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	dst->nf_bridge  = src->nf_bridge;
@@ -2439,7 +2491,8 @@ static inline void nf_copy(struct sk_buff *dst, const struct sk_buff *src)
 	nf_conntrack_put(dst->nfct);
 #endif
 #ifdef NET_SKBUFF_NF_DEFRAG_NEEDED
-	nf_conntrack_put_reasm(dst->nfct_reasm);
+	if (skb_nfct_reasm_is_reasm(dst))
+		nf_conntrack_put_reasm(skb_nfct_reasm(dst));
 #endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	nf_bridge_put(dst->nf_bridge);
diff --git a/include/net/ip_vs.h b/include/net/ip_vs.h
index 3538fd9..10ce6aa 100644
--- a/include/net/ip_vs.h
+++ b/include/net/ip_vs.h
@@ -120,25 +120,17 @@ struct ip_vs_iphdr {
 
 /* Dependency to module: nf_defrag_ipv6 */
 #if defined(CONFIG_NF_DEFRAG_IPV6) || defined(CONFIG_NF_DEFRAG_IPV6_MODULE)
-static inline struct sk_buff *skb_nfct_reasm(const struct sk_buff *skb)
-{
-	return skb->nfct_reasm;
-}
 static inline void *frag_safe_skb_hp(const struct sk_buff *skb, int offset,
 				      int len, void *buffer,
 				      const struct ip_vs_iphdr *ipvsh)
 {
-	if (unlikely(ipvsh->fragoffs && skb_nfct_reasm(skb)))
+	if (unlikely(ipvsh->fragoffs && skb_is_replayed_fragment(skb)))
 		return skb_header_pointer(skb_nfct_reasm(skb),
 					  ipvsh->thoff_reasm, len, buffer);
 
 	return skb_header_pointer(skb, offset, len, buffer);
 }
 #else
-static inline struct sk_buff *skb_nfct_reasm(const struct sk_buff *skb)
-{
-	return NULL;
-}
 static inline void *frag_safe_skb_hp(const struct sk_buff *skb, int offset,
 				      int len, void *buffer,
 				      const struct ip_vs_iphdr *ipvsh)
@@ -180,7 +172,7 @@ ip_vs_fill_iph_skb(int af, const struct sk_buff *skb, struct ip_vs_iphdr *iphdr)
 						 &iphdr->fragoffs,
 						 &iphdr->flags);
 		/* get proto from re-assembled packet and it's offset */
-		if (skb_nfct_reasm(skb))
+		if (skb_is_replayed_fragment(skb))
 			iphdr->protocol = ipv6_find_hdr(skb_nfct_reasm(skb),
 							&iphdr->thoff_reasm,
 							-1, NULL, NULL);
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index dbfdbea..4ec6c1b 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -446,7 +446,8 @@ static void skb_release_head_state(struct sk_buff *skb)
 	nf_conntrack_put(skb->nfct);
 #endif
 #ifdef NET_SKBUFF_NF_DEFRAG_NEEDED
-	nf_conntrack_put_reasm(skb->nfct_reasm);
+	if (skb_nfct_reasm_is_reasm(skb))
+		nf_conntrack_put_reasm(skb_nfct_reasm(skb));
 #endif
 #ifdef CONFIG_BRIDGE_NETFILTER
 	nf_bridge_put(skb->nf_bridge);
diff --git a/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c b/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
index 514000c..36d874e 100644
--- a/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
@@ -141,10 +141,9 @@ static unsigned int __ipv6_conntrack_in(struct net *net,
 					struct sk_buff *skb,
 					int (*okfn)(struct sk_buff *))
 {
-	struct sk_buff *reasm = skb->nfct_reasm;
-
 	/* This packet is fragmented and has reassembled packet. */
-	if (reasm) {
+	if (skb_is_replayed_fragment(skb)) {
+		struct sk_buff *reasm = skb_nfct_reasm(skb);
 		/* Reassembled packet isn't parsed yet ? */
 		if (!reasm->nfct) {
 			unsigned int ret;
diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
index f04ab7c..9c0bfc7 100644
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c
@@ -689,9 +689,10 @@ void nf_ct_frag6_output(unsigned int hooknum, struct sk_buff *skb,
 	struct sk_buff *s, *s2;
 
 	for (s = NFCT_FRAG6_CB(skb)->orig; s;) {
-		nf_conntrack_put_reasm(s->nfct_reasm);
+		if (skb_nfct_reasm_is_reasm(s))
+			nf_conntrack_put_reasm(skb_nfct_reasm(s));
 		nf_conntrack_get_reasm(skb);
-		s->nfct_reasm = skb;
+		skb_set_nfct_reasm(s, skb);
 
 		s2 = s->next;
 		s->next = NULL;
diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c
index 8734314..4fa78da 100644
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -125,7 +125,8 @@ _decode_session6(struct sk_buff *skb, struct flowi *fl, int reverse)
 	struct flowi6 *fl6 = &fl->u.ip6;
 	int onlyproto = 0;
 	/* use the reassembled packet if conntrack has done the reassembly */
-	struct sk_buff *whole_skb = (skb->nfct_reasm) ? skb->nfct_reasm : skb;
+	struct sk_buff *whole_skb = skb_is_replayed_fragment(skb) ?
+				    skb_nfct_reasm(skb) : skb;
 	u16 offset = skb_network_header_len(whole_skb);
 	const struct ipv6hdr *hdr = ipv6_hdr(whole_skb);
 	struct ipv6_opt_hdr *exthdr;
diff --git a/net/netfilter/ipvs/ip_vs_core.c b/net/netfilter/ipvs/ip_vs_core.c
index e7ab9166..a84fa08 100644
--- a/net/netfilter/ipvs/ip_vs_core.c
+++ b/net/netfilter/ipvs/ip_vs_core.c
@@ -1120,7 +1120,7 @@ ip_vs_out(unsigned int hooknum, struct sk_buff *skb, int af)
 	ip_vs_fill_iph_skb(af, skb, &iph);
 #ifdef CONFIG_IP_VS_IPV6
 	if (af == AF_INET6) {
-		if (!iph.fragoffs && skb_nfct_reasm(skb)) {
+		if (!iph.fragoffs && skb_is_replayed_fragment(skb)) {
 			struct sk_buff *reasm = skb_nfct_reasm(skb);
 			/* Save fw mark for coming frags */
 			reasm->ipvs_property = 1;
@@ -1545,7 +1545,7 @@ ip_vs_in(unsigned int hooknum, struct sk_buff *skb, int af)
 
 #ifdef CONFIG_IP_VS_IPV6
 	if (af == AF_INET6) {
-		if (!iph.fragoffs && skb_nfct_reasm(skb)) {
+		if (!iph.fragoffs && skb_is_replayed_fragment(skb)) {
 			struct sk_buff *reasm = skb_nfct_reasm(skb);
 			/* Save fw mark for coming frags. */
 			reasm->ipvs_property = 1;
@@ -1593,7 +1593,7 @@ ip_vs_in(unsigned int hooknum, struct sk_buff *skb, int af)
 		/* sorry, all this trouble for a no-hit :) */
 		IP_VS_DBG_PKT(12, af, pp, skb, 0,
 			      "ip_vs_in: packet continues traversal as normal");
-		if (iph.fragoffs && !skb_nfct_reasm(skb)) {
+		if (iph.fragoffs && !skb_is_replayed_fragment(skb)) {
 			/* Fragment that couldn't be mapped to a conn entry
 			 * and don't have any pointer to a reasm skb
 			 * is missing module nf_defrag_ipv6
@@ -1720,7 +1720,8 @@ ip_vs_preroute_frag6(unsigned int hooknum, struct sk_buff *skb,
 		     const struct net_device *out,
 		     int (*okfn)(struct sk_buff *))
 {
-	struct sk_buff *reasm = skb_nfct_reasm(skb);
+	struct sk_buff *reasm = skb_is_replayed_fragment(skb) ?
+				skb_nfct_reasm(skb) : NULL;
 	struct net *net;
 
 	/* Skip if not a "replay" from nf_ct_frag6_output or first fragment.
-- 
1.8.1.4

