From: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Subject: Fix node_start/end_pfn() definition for mm/page_cgroup.c
References: bnc#708160, bnc#712316
Patch-Mainline: v3.0-rc5
Git-commit: c6830c22603aaecf65405af23f6da2d55892f9cb


Signed-off-by: Thomas Renninger <trenn@suse.de>

commit 21a3c96 uses node_start/end_pfn(nid) for detection start/end
of nodes. But, it's not defined in linux/mmzone.h but defined in
/arch/???/include/mmzone.h which is included only under
CONFIG_NEED_MULTIPLE_NODES=y.

Then, we see
  mm/page_cgroup.c: In function 'page_cgroup_init':
  mm/page_cgroup.c:308: error: implicit declaration of function 'node_start_pfn'
  mm/page_cgroup.c:309: error: implicit declaration of function 'node_end_pfn'

So, fixiing page_cgroup.c is an idea...

But node_start_pfn()/node_end_pfn() is a very generic macro and
should be implemented in the same manner for all archs.
(m32r has different implementation...)

This patch removes definitions of node_start/end_pfn() in each archs
and defines a unified one in linux/mmzone.h. It's not under
CONFIG_NEED_MULTIPLE_NODES, now.

A result of macro expansion is here (mm/page_cgroup.c)

for !NUMA
 start_pfn = ((&contig_page_data)->node_start_pfn);
  end_pfn = ({ pg_data_t *__pgdat = (&contig_page_data); __pgdat->node_start_pfn + __pgdat->node_spanned_pages;});

for NUMA (x86-64)
  start_pfn = ((node_data[nid])->node_start_pfn);
  end_pfn = ({ pg_data_t *__pgdat = (node_data[nid]); __pgdat->node_start_pfn + __pgdat->node_spanned_pages;});

Changelog:
 - fixed to avoid using "nid" twice in node_end_pfn() macro.

Reported-and-acked-by: Randy Dunlap <randy.dunlap@oracle.com>
Reported-and-tested-by: Ingo Molnar <mingo@elte.hu>
Acked-by: Mel Gorman <mgorman@suse.de>
Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

---
 arch/alpha/include/asm/mmzone.h   |    1 -
 arch/m32r/include/asm/mmzone.h    |    8 +-------
 arch/parisc/include/asm/mmzone.h  |    7 -------
 arch/powerpc/include/asm/mmzone.h |    7 -------
 arch/sh/include/asm/mmzone.h      |    4 ----
 arch/sparc/include/asm/mmzone.h   |    2 --
 arch/x86/include/asm/mmzone_32.h  |   11 -----------
 arch/x86/include/asm/mmzone_64.h  |    4 ----
 include/linux/mmzone.h            |    7 +++++++
 9 files changed, 8 insertions(+), 43 deletions(-)

Index: linux-2.6.32-SLE11-SP1/arch/alpha/include/asm/mmzone.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/alpha/include/asm/mmzone.h
+++ linux-2.6.32-SLE11-SP1/arch/alpha/include/asm/mmzone.h
@@ -56,7 +56,6 @@ PLAT_NODE_DATA_LOCALNR(unsigned long p,
  * Given a kernel address, find the home node of the underlying memory.
  */
 #define kvaddr_to_nid(kaddr)	pa_to_nid(__pa(kaddr))
-#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
 
 /*
  * Given a kaddr, LOCAL_BASE_ADDR finds the owning node of the memory
Index: linux-2.6.32-SLE11-SP1/arch/m32r/include/asm/mmzone.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/m32r/include/asm/mmzone.h
+++ linux-2.6.32-SLE11-SP1/arch/m32r/include/asm/mmzone.h
@@ -14,12 +14,6 @@ extern struct pglist_data *node_data[];
 #define NODE_DATA(nid)		(node_data[nid])
 
 #define node_localnr(pfn, nid)	((pfn) - NODE_DATA(nid)->node_start_pfn)
-#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
-#define node_end_pfn(nid)						\
-({									\
-	pg_data_t *__pgdat = NODE_DATA(nid);				\
-	__pgdat->node_start_pfn + __pgdat->node_spanned_pages - 1;	\
-})
 
 #define pmd_page(pmd)		(pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
 /*
@@ -44,7 +38,7 @@ static __inline__ int pfn_to_nid(unsigne
 	int node;
 
 	for (node = 0 ; node < MAX_NUMNODES ; node++)
-		if (pfn >= node_start_pfn(node) && pfn <= node_end_pfn(node))
+		if (pfn >= node_start_pfn(node) && pfn < node_end_pfn(node))
 			break;
 
 	return node;
Index: linux-2.6.32-SLE11-SP1/arch/parisc/include/asm/mmzone.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/parisc/include/asm/mmzone.h
+++ linux-2.6.32-SLE11-SP1/arch/parisc/include/asm/mmzone.h
@@ -14,13 +14,6 @@ extern struct node_map_data node_data[];
 
 #define NODE_DATA(nid)          (&node_data[nid].pg_data)
 
-#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
-#define node_end_pfn(nid)						\
-({									\
-	pg_data_t *__pgdat = NODE_DATA(nid);				\
-	__pgdat->node_start_pfn + __pgdat->node_spanned_pages;		\
-})
-
 /* We have these possible memory map layouts:
  * Astro: 0-3.75, 67.75-68, 4-64
  * zx1: 0-1, 257-260, 4-256
Index: linux-2.6.32-SLE11-SP1/arch/powerpc/include/asm/mmzone.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/powerpc/include/asm/mmzone.h
+++ linux-2.6.32-SLE11-SP1/arch/powerpc/include/asm/mmzone.h
@@ -34,14 +34,6 @@ extern cpumask_t numa_cpumask_lookup_tab
 #ifdef CONFIG_MEMORY_HOTPLUG
 extern unsigned long max_pfn;
 #endif
-
-/*
- * Following are macros that each numa implmentation must define.
- */
-
-#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
-#define node_end_pfn(nid)	(NODE_DATA(nid)->node_end_pfn)
-
 #endif /* CONFIG_NEED_MULTIPLE_NODES */
 
 #endif /* __KERNEL__ */
Index: linux-2.6.32-SLE11-SP1/arch/sh/include/asm/mmzone.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/sh/include/asm/mmzone.h
+++ linux-2.6.32-SLE11-SP1/arch/sh/include/asm/mmzone.h
@@ -9,10 +9,6 @@
 extern struct pglist_data *node_data[];
 #define NODE_DATA(nid)		(node_data[nid])
 
-#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
-#define node_end_pfn(nid)	(NODE_DATA(nid)->node_start_pfn + \
-				 NODE_DATA(nid)->node_spanned_pages)
-
 static inline int pfn_to_nid(unsigned long pfn)
 {
 	int nid;
Index: linux-2.6.32-SLE11-SP1/arch/sparc/include/asm/mmzone.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/sparc/include/asm/mmzone.h
+++ linux-2.6.32-SLE11-SP1/arch/sparc/include/asm/mmzone.h
@@ -8,8 +8,6 @@
 extern struct pglist_data *node_data[];
 
 #define NODE_DATA(nid)		(node_data[nid])
-#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
-#define node_end_pfn(nid)	(NODE_DATA(nid)->node_end_pfn)
 
 extern int numa_cpu_lookup_table[];
 extern cpumask_t numa_cpumask_lookup_table[];
Index: linux-2.6.32-SLE11-SP1/arch/x86/include/asm/mmzone_32.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/include/asm/mmzone_32.h
+++ linux-2.6.32-SLE11-SP1/arch/x86/include/asm/mmzone_32.h
@@ -68,17 +68,6 @@ static inline int pfn_to_nid(unsigned lo
 #endif
 }
 
-/*
- * Following are macros that each numa implmentation must define.
- */
-
-#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
-#define node_end_pfn(nid)						\
-({									\
-	pg_data_t *__pgdat = NODE_DATA(nid);				\
-	__pgdat->node_start_pfn + __pgdat->node_spanned_pages;		\
-})
-
 static inline int pfn_valid(int pfn)
 {
 	int nid = pfn_to_nid(pfn);
Index: linux-2.6.32-SLE11-SP1/include/linux/mmzone.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/mmzone.h
+++ linux-2.6.32-SLE11-SP1/include/linux/mmzone.h
@@ -666,6 +666,13 @@ typedef struct pglist_data {
 #endif
 #define nid_page_nr(nid, pagenr) 	pgdat_page_nr(NODE_DATA(nid),(pagenr))
 
+#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
+
+#define node_end_pfn(nid) ({\
+	pg_data_t *__pgdat = NODE_DATA(nid);\
+	__pgdat->node_start_pfn + __pgdat->node_spanned_pages;\
+})
+
 #include <linux/memory_hotplug.h>
 
 void get_zone_counts(unsigned long *active, unsigned long *inactive,
Index: linux-2.6.32-SLE11-SP1/arch/x86/include/asm/mmzone_64.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/include/asm/mmzone_64.h
+++ linux-2.6.32-SLE11-SP1/arch/x86/include/asm/mmzone_64.h
@@ -36,10 +36,6 @@ static inline __attribute__((pure)) int
 
 #define NODE_DATA(nid)		(node_data[nid])
 
-#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
-#define node_end_pfn(nid)       (NODE_DATA(nid)->node_start_pfn +	\
-				 NODE_DATA(nid)->node_spanned_pages)
-
 #ifdef CONFIG_NUMA_EMU
 #define FAKE_NODE_MIN_SIZE	(64 * 1024 * 1024)
 #define FAKE_NODE_MIN_HASH_MASK	(~(FAKE_NODE_MIN_SIZE - 1UL))
