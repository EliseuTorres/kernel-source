From: Jan Kara <jack@suse.cz>
Subject: ocfs2: Avoid livelock in ocfs2_readpage()
References: bnc#682076
Patch-mainline: Expected 3.1

When someone writes to an inode, readers accessing the same inode via
ocfs2_readpage() just busyloop trying to get ip_alloc_sem because
do_generic_file_read() looks up the page again and retries ->readpage()
when previous attempt failed with AOP_TRUNCATED_PAGE. When there are enough
readers, they can occupy all CPUs and in non-preempt kernel the system is
deadlocked because writer holding ip_alloc_sem is never run to release the
semaphore. Fix the problem by making reader block on ip_alloc_sem to break
the busy loop.

Signed-off-by: Jan Kara <jack@suse.cz>

diff -rupX /crypted/home/jack/.kerndiffexclude linux-2.6.32-SLE11-SP1/fs/ocfs2/aops.c linux-2.6.32-SLE11-SP1-ocfs2-livelock/fs/ocfs2/aops.c
--- linux-2.6.32-SLE11-SP1/fs/ocfs2/aops.c	2011-06-20 15:56:57.940100090 +0200
+++ linux-2.6.32-SLE11-SP1-ocfs2-livelock/fs/ocfs2/aops.c	2011-06-23 00:34:22.516024121 +0200
@@ -289,7 +289,15 @@ static int ocfs2_readpage(struct file *f
 	}
 
 	if (down_read_trylock(&oi->ip_alloc_sem) == 0) {
+		/*
+		 * Unlock the page and cycle ip_alloc_sem so that we don't
+		 * busyloop waiting for ip_alloc_sem to unlock
+		 */
 		ret = AOP_TRUNCATED_PAGE;
+		unlock_page(page);
+		unlock = 0;
+		down_read(&oi->ip_alloc_sem);
+		up_read(&oi->ip_alloc_sem);
 		goto out_inode_unlock;
 	}
 
