From: Suresh Jayaraman <sjayaraman@suse.de>
Subject: cifs: Ensure credentials match when trying to use a existing session
References: bnc#683282
Patch-mainline: yes

The problem seen is due to the fact that cifs_umount (when umount is invoked)
when called for the first time fails with -EBUSY error (as there is a shared
session due to which Tree Disconnect fails) and hence fails to cleanup SMB
Session. When the user tries to mount for the third time, it finds an existing
session checks the username, but didn't check whether password matches or not
and tries to use the credentials from the previous SMB session and hence
succeeds.

Attached is the patch to fix this problem. The patch ensures that when a
matching session is found, the credentials too match, otherwise it tries to
establish a new session.

Note that the upstream has fixed this in a different way mostly due to overhaul
of lot of session handling code and refactoring. However, the essence of the
fix still remains the same.

Signed-off-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Steve French <sfrench@us.ibm.com>
Signed-off-by: Suresh Jayaraman <sjayaraman@suse.de>
---

Index: linux-2.6.32-SLE11-SP1/fs/cifs/connect.c
===================================================================
 fs/cifs/connect.c |   14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

--- linux-2.6.32-SLE11-SP1.orig/fs/cifs/connect.c
+++ linux-2.6.32-SLE11-SP1/fs/cifs/connect.c
@@ -1587,7 +1587,7 @@ out_err:
 }
 
 static struct cifsSesInfo *
-cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)
+cifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)
 {
 	struct list_head *tmp;
 	struct cifsSesInfo *ses;
@@ -1595,7 +1595,15 @@ cifs_find_smb_ses(struct TCP_Server_Info
 	write_lock(&cifs_tcp_ses_lock);
 	list_for_each(tmp, &server->smb_ses_list) {
 		ses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);
-		if (strncmp(ses->userName, username, MAX_USERNAME_SIZE))
+		if (ses->userName == NULL)
+			continue;
+		if (strncmp(ses->userName, vol->username, MAX_USERNAME_SIZE))
+			continue;
+		if (strlen(vol->username) !=0 &&
+		    ses->password != NULL &&
+		    strncmp(ses->password,
+			    vol->password ? vol->password : "",
+			    MAX_PASSWORD_SIZE))
 			continue;
 
 		++ses->ses_count;
@@ -2356,7 +2364,7 @@ try_mount_again:
 		goto out;
 	}
 
-	pSesInfo = cifs_find_smb_ses(srvTcp, volume_info->username);
+	pSesInfo = cifs_find_smb_ses(srvTcp, volume_info);
 	if (pSesInfo) {
 		cFYI(1, ("Existing smb sess found (status=%d)",
 			pSesInfo->status));
