From: Egbert Eich <eich@suse.de>
Date: Wed, Sep 28 2011 12:30:05 +0200
Subject: VGA arb: Back out Commit 3448a19d.
Patch-mainline: to be mainlined

Back out commit 3448a19d from upstream kernel. While the underlying idea is
good this patch has it's logic wrong: when switching from device controls
to bus controls to switch VGA resoures on and off one should leave any device
put under bus control in an enabled state. Vice versa when switching from
bus controlled to device controlled the devices need to be disabled again.
(bnc #711684)

Signed-off-by: Egbert Eich <eich@suse.de>

---
 drivers/gpu/vga/vgaarb.c |  113 +++++------------------------------------------
 drivers/pci/pci.c        |   25 ++++------
 include/linux/pci.h      |    7 --
 3 files changed, 27 insertions(+), 118 deletions(-)

--- linux-3.0-SLE11-SP2-3.0.orig/drivers/gpu/vga/vgaarb.c
+++ linux-3.0-SLE11-SP2-3.0/drivers/gpu/vga/vgaarb.c
@@ -61,7 +61,7 @@ struct vga_device {
 	unsigned int mem_lock_cnt;	/* legacy MEM lock count */
 	unsigned int io_norm_cnt;	/* normal IO count */
 	unsigned int mem_norm_cnt;	/* normal MEM count */
-	bool bridge_has_one_vga;
+
 	/* allow IRQ enable/disable hook */
 	void *cookie;
 	void (*irq_set_state)(void *cookie, bool enable);
@@ -165,8 +165,6 @@ static struct vga_device *__vga_tryget(s
 	unsigned int wants, legacy_wants, match;
 	struct vga_device *conflict;
 	unsigned int pci_bits;
-	u32 flags = 0;
-
 	/* Account for "normal" resources to lock. If we decode the legacy,
 	 * counterpart, we need to request it as well
 	 */
@@ -239,23 +237,16 @@ static struct vga_device *__vga_tryget(s
 		/* looks like he doesn't have a lock, we can steal
 		 * them from him
 		 */
+		vga_irq_set_state(conflict, false);
 
-		flags = 0;
 		pci_bits = 0;
+		if (lwants & (VGA_RSRC_LEGACY_MEM|VGA_RSRC_NORMAL_MEM))
+			pci_bits |= PCI_COMMAND_MEMORY;
+		if (lwants & (VGA_RSRC_LEGACY_IO|VGA_RSRC_NORMAL_IO))
+			pci_bits |= PCI_COMMAND_IO;
 
-		if (!conflict->bridge_has_one_vga) {
-			vga_irq_set_state(conflict, false);
-			flags |= PCI_VGA_STATE_CHANGE_DECODES;
-			if (lwants & (VGA_RSRC_LEGACY_MEM|VGA_RSRC_NORMAL_MEM))
-				pci_bits |= PCI_COMMAND_MEMORY;
-			if (lwants & (VGA_RSRC_LEGACY_IO|VGA_RSRC_NORMAL_IO))
-				pci_bits |= PCI_COMMAND_IO;
-		}
-
-		if (change_bridge)
-			flags |= PCI_VGA_STATE_CHANGE_BRIDGE;
-
-		pci_set_vga_state(conflict->pdev, false, pci_bits, flags);
+		pci_set_vga_state(conflict->pdev, false, pci_bits,
+				  change_bridge);
 		conflict->owns &= ~lwants;
 		/* If he also owned non-legacy, that is no longer the case */
 		if (lwants & VGA_RSRC_LEGACY_MEM)
@@ -270,24 +261,14 @@ enable_them:
 	 * also have in "decodes". We can lock resources we don't decode but
 	 * not own them.
 	 */
-	flags = 0;
 	pci_bits = 0;
+	if (wants & (VGA_RSRC_LEGACY_MEM|VGA_RSRC_NORMAL_MEM))
+		pci_bits |= PCI_COMMAND_MEMORY;
+	if (wants & (VGA_RSRC_LEGACY_IO|VGA_RSRC_NORMAL_IO))
+		pci_bits |= PCI_COMMAND_IO;
+	pci_set_vga_state(vgadev->pdev, true, pci_bits, !!(wants & VGA_RSRC_LEGACY_MASK));
 
-	if (!vgadev->bridge_has_one_vga) {
-		flags |= PCI_VGA_STATE_CHANGE_DECODES;
-		if (wants & (VGA_RSRC_LEGACY_MEM|VGA_RSRC_NORMAL_MEM))
-			pci_bits |= PCI_COMMAND_MEMORY;
-		if (wants & (VGA_RSRC_LEGACY_IO|VGA_RSRC_NORMAL_IO))
-			pci_bits |= PCI_COMMAND_IO;
-	}
-	if (!!(wants & VGA_RSRC_LEGACY_MASK))
-		flags |= PCI_VGA_STATE_CHANGE_BRIDGE;
-
-	pci_set_vga_state(vgadev->pdev, true, pci_bits, flags);
-
-	if (!vgadev->bridge_has_one_vga) {
-		vga_irq_set_state(vgadev, true);
-	}
+	vga_irq_set_state(vgadev, true);
 	vgadev->owns |= (wants & vgadev->decodes);
 lock_them:
 	vgadev->locks |= (rsrc & VGA_RSRC_LEGACY_MASK);
@@ -440,62 +421,6 @@ bail:
 }
 EXPORT_SYMBOL(vga_put);
 
-/* Rules for using a bridge to control a VGA descendant decoding:
-   if a bridge has only one VGA descendant then it can be used
-   to control the VGA routing for that device.
-   It should always use the bridge closest to the device to control it.
-   If a bridge has a direct VGA descendant, but also have a sub-bridge
-   VGA descendant then we cannot use that bridge to control the direct VGA descendant.
-   So for every device we register, we need to iterate all its parent bridges
-   so we can invalidate any devices using them properly.
-*/
-static void vga_arbiter_check_bridge_sharing(struct vga_device *vgadev)
-{
-	struct vga_device *same_bridge_vgadev;
-	struct pci_bus *new_bus, *bus;
-	struct pci_dev *new_bridge, *bridge;
-
-	vgadev->bridge_has_one_vga = true;
-
-	if (list_empty(&vga_list))
-		return;
-
-	/* okay iterate the new devices bridge hierarachy */
-	new_bus = vgadev->pdev->bus;
-	while (new_bus) {
-		new_bridge = new_bus->self;
-
-		if (new_bridge) {
-			/* go through list of devices already registered */
-			list_for_each_entry(same_bridge_vgadev, &vga_list, list) {
-				bus = same_bridge_vgadev->pdev->bus;
-				bridge = bus->self;
-
-				/* see if the share a bridge with this device */
-				if (new_bridge == bridge) {
-					/* if their direct parent bridge is the same
-					   as any bridge of this device then it can't be used
-					   for that device */
-					same_bridge_vgadev->bridge_has_one_vga = false;
-				}
-
-				/* now iterate the previous devices bridge hierarchy */
-				/* if the new devices parent bridge is in the other devices
-				   hierarchy then we can't use it to control this device */
-				while (bus) {
-					bridge = bus->self;
-					if (bridge) {
-						if (bridge == vgadev->pdev->bus->self)
-							vgadev->bridge_has_one_vga = false;
-					}
-					bus = bus->parent;
-				}
-			}
-		}
-		new_bus = new_bus->parent;
-	}
-}
-
 /*
  * Currently, we assume that the "initial" setup of the system is
  * not sane, that is we come up with conflicting devices and let
@@ -575,8 +500,6 @@ static bool vga_arbiter_add_pci_device(s
 		vga_default = pci_dev_get(pdev);
 #endif
 
-	vga_arbiter_check_bridge_sharing(vgadev);
-
 	/* Add to the list */
 	list_add(&vgadev->list, &vga_list);
 	vga_count++;
@@ -1299,7 +1222,6 @@ static int __init vga_arb_device_init(vo
 {
 	int rc;
 	struct pci_dev *pdev;
-	struct vga_device *vgadev;
 
 	rc = misc_register(&vga_arb_device);
 	if (rc < 0)
@@ -1316,13 +1238,6 @@ static int __init vga_arb_device_init(vo
 		vga_arbiter_add_pci_device(pdev);
 
 	pr_info("vgaarb: loaded\n");
-
-	list_for_each_entry(vgadev, &vga_list, list) {
-		if (vgadev->bridge_has_one_vga)
-			pr_info("vgaarb: bridge control possible %s\n", pci_name(vgadev->pdev));
-		else
-			pr_info("vgaarb: no bridge control possible %s\n", pci_name(vgadev->pdev));
-	}
 	return rc;
 }
 subsys_initcall(vga_arb_device_init);
--- linux-3.0-SLE11-SP2-3.0.orig/drivers/pci/pci.c
+++ linux-3.0-SLE11-SP2-3.0/drivers/pci/pci.c
@@ -3352,34 +3352,31 @@ static int pci_set_vga_state_arch(struct
  * @dev: the PCI device
  * @decode: true = enable decoding, false = disable decoding
  * @command_bits: PCI_COMMAND_IO and/or PCI_COMMAND_MEMORY
- * @flags: traverse ancestors and change bridges
- * CHANGE_BRIDGE_ONLY / CHANGE_BRIDGE
+ * @change_bridge: traverse ancestors and change bridges
  */
 int pci_set_vga_state(struct pci_dev *dev, bool decode,
-		      unsigned int command_bits, u32 flags)
+ 		      unsigned int command_bits, bool change_bridge)
 {
 	struct pci_bus *bus;
 	struct pci_dev *bridge;
 	u16 cmd;
 	int rc;
 
-	WARN_ON((flags & PCI_VGA_STATE_CHANGE_DECODES) & (command_bits & ~(PCI_COMMAND_IO|PCI_COMMAND_MEMORY)));
+ 	WARN_ON(command_bits & ~(PCI_COMMAND_IO|PCI_COMMAND_MEMORY));
 
 	/* ARCH specific VGA enables */
-	rc = pci_set_vga_state_arch(dev, decode, command_bits, flags);
+ 	rc = pci_set_vga_state_arch(dev, decode, command_bits, change_bridge);
 	if (rc)
 		return rc;
 
-	if (flags & PCI_VGA_STATE_CHANGE_DECODES) {
-		pci_read_config_word(dev, PCI_COMMAND, &cmd);
-		if (decode == true)
-			cmd |= command_bits;
-		else
-			cmd &= ~command_bits;
-		pci_write_config_word(dev, PCI_COMMAND, cmd);
-	}
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	if (decode == true)
+		cmd |= command_bits;
+	else
+		cmd &= ~command_bits;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
 
-	if (!(flags & PCI_VGA_STATE_CHANGE_BRIDGE))
+ 	if (change_bridge == false)
 		return 0;
 
 	bus = dev->bus;
--- linux-3.0-SLE11-SP2-3.0.orig/include/linux/pci.h
+++ linux-3.0-SLE11-SP2-3.0/include/linux/pci.h
@@ -954,11 +954,8 @@ int pci_cfg_space_size_ext(struct pci_de
 int pci_cfg_space_size(struct pci_dev *dev);
 unsigned char pci_bus_max_busnr(struct pci_bus *bus);
 
-#define PCI_VGA_STATE_CHANGE_BRIDGE (1 << 0)
-#define PCI_VGA_STATE_CHANGE_DECODES (1 << 1)
-
 int pci_set_vga_state(struct pci_dev *pdev, bool decode,
-		      unsigned int command_bits, u32 flags);
+		      unsigned int command_bits, bool change_bridge);
 /* kmem_cache style wrapper around pci_alloc_consistent() */
 
 #include <linux/pci-dma.h>
@@ -1103,7 +1100,7 @@ static inline int pci_proc_domain(struct
 
 /* some architectures require additional setup to direct VGA traffic */
 typedef int (*arch_set_vga_state_t)(struct pci_dev *pdev, bool decode,
-		      unsigned int command_bits, u32 flags);
+		      unsigned int command_bits, bool change_bridge);
 extern void pci_register_set_vga_state(arch_set_vga_state_t func);
 
 #else /* CONFIG_PCI is not enabled */
