From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 31 Mar 2014 11:07:44 +0200
Subject: inet: handle rt{,6}_bind_peer() failure correctly
Patch-mainline: Never, SLE11-SP3 specific regression
References: bnc#870801

The fix for bnc#864833 (suse-commit 0d00fd1e) doesn't check for
rt{,6}_bind_peer() failure correctly and calls rt{,6}_peer_ptr()
right after it. If the former fails, route still refers to a
base pointer and BUG_ON() check in rt{,6}_peer_ptr() is
triggered.

In most places, this is fixed using rt{,6}_peer_ptr_compat()
wrapper returning NULL (which is expected) instead. In others,
check with rt{,6}_has_peer() first.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/ip6_fib.h   |  5 +++++
 include/net/ip6_route.h |  2 +-
 include/net/route.h     |  7 ++++++-
 net/ipv4/icmp.c         |  2 +-
 net/ipv4/route.c        | 29 +++++++++++++----------------
 net/ipv4/tcp_ipv4.c     |  2 +-
 net/ipv6/icmp.c         |  2 +-
 net/ipv6/ip6_output.c   |  2 +-
 net/ipv6/ndisc.c        |  2 +-
 net/ipv6/route.c        |  5 ++---
 net/ipv6/tcp_ipv6.c     |  2 +-
 11 files changed, 33 insertions(+), 27 deletions(-)

diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h
index 66acfa4..ec5a130 100644
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -136,6 +136,11 @@ static inline bool rt6_has_peer(struct rt6_info *rt)
 	return inetpeer_ptr_is_peer(rt->_rt6i_peer);
 }
 
+static inline struct inet_peer *rt6_peer_ptr_compat(struct rt6_info *rt)
+{
+	return rt6_has_peer(rt) ? rt6_peer_ptr(rt) : NULL;
+}
+
 static inline void __rt6_set_peer(struct rt6_info *rt, struct inet_peer *peer)
 {
 	__inetpeer_ptr_set_peer(&rt->_rt6i_peer, peer);
diff --git a/include/net/ip6_route.h b/include/net/ip6_route.h
index a57d68b..3ca0415 100644
--- a/include/net/ip6_route.h
+++ b/include/net/ip6_route.h
@@ -62,7 +62,7 @@ static inline struct inet_peer *rt6_get_peer(struct rt6_info *rt)
 		return rt6_peer_ptr(rt);
 
 	rt6_bind_peer(rt, 0);
-	return rt6_peer_ptr(rt);
+	return rt6_peer_ptr_compat(rt);
 }
 
 extern void			ip6_route_input(struct sk_buff *skb);
diff --git a/include/net/route.h b/include/net/route.h
index 6420d40..a5dae89 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -85,6 +85,11 @@ static inline bool rt_has_peer(struct rtable *rt)
 	return inetpeer_ptr_is_peer(rt->_peer);
 }
 
+static inline struct inet_peer *rt_peer_ptr_compat(struct rtable *rt)
+{
+	return rt_has_peer(rt) ? rt_peer_ptr(rt) : NULL;
+}
+
 static inline void __rt_set_peer(struct rtable *rt, struct inet_peer *peer)
 {
 	__inetpeer_ptr_set_peer(&rt->_peer, peer);
@@ -340,7 +345,7 @@ static inline struct inet_peer *rt_get_peer(struct rtable *rt, __be32 daddr)
 		return rt_peer_ptr(rt);
 
 	rt_bind_peer(rt, daddr, 0);
-	return rt_peer_ptr(rt);
+	return rt_peer_ptr_compat(rt);
 }
 
 static inline int inet_iif(const struct sk_buff *skb)
diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.c
index 100eacf..44f59cc 100644
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@ -254,7 +254,7 @@ static inline bool icmpv4_xrlim_allow(struct net *net, struct rtable *rt,
 	if ((1 << type) & net->ipv4.sysctl_icmp_ratemask) {
 		if (!rt_has_peer(rt))
 			rt_bind_peer(rt, fl4->daddr, 1);
-		rc = inet_peer_xrlim_allow(rt_peer_ptr(rt),
+		rc = inet_peer_xrlim_allow(rt_peer_ptr_compat(rt),
 					   net->ipv4.sysctl_icmp_ratelimit);
 	}
 out:
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 2cadf2a..df8be15 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -157,14 +157,13 @@ static void ipv4_dst_ifdown(struct dst_entry *dst, struct net_device *dev,
 static u32 *ipv4_cow_metrics(struct dst_entry *dst, unsigned long old)
 {
 	struct rtable *rt = (struct rtable *) dst;
-	struct inet_peer *peer;
 	u32 *p = NULL;
 
 	if (!rt_has_peer(rt))
 		rt_bind_peer(rt, rt->rt_dst, 1);
 
-	peer = rt_peer_ptr(rt);
-	if (peer) {
+	if (rt_has_peer(rt)) {
+		struct inet_peer *peer = rt_peer_ptr(rt);
 		u32 *old_p = __DST_METRICS_PTR(old);
 		unsigned long prev, new;
 
@@ -1414,7 +1413,6 @@ void ip_rt_redirect(__be32 old_gw, __be32 daddr, __be32 new_gw,
 	struct in_device *in_dev = __in_dev_get_rcu(dev);
 	__be32 skeys[2] = { saddr, 0 };
 	int    ikeys[2] = { dev->ifindex, 0 };
-	struct inet_peer *peer;
 	struct net *net;
 
 	if (!in_dev)
@@ -1463,8 +1461,9 @@ void ip_rt_redirect(__be32 old_gw, __be32 daddr, __be32 new_gw,
 				if (!rt_has_peer(rt))
 					rt_bind_peer(rt, rt->rt_dst, 1);
 
-				peer = rt_peer_ptr(rt);
-				if (peer) {
+				if (rt_has_peer(rt)) {
+					struct inet_peer *peer = rt_peer_ptr(rt);
+
 					if (peer->redirect_learned.a4 != new_gw) {
 						peer->redirect_learned.a4 = new_gw;
 						atomic_inc(&__rt_peer_genid);
@@ -1562,7 +1561,7 @@ void ip_rt_send_redirect(struct sk_buff *skb)
 
 	if (!rt_has_peer(rt))
 		rt_bind_peer(rt, rt->rt_dst, 1);
-	peer = rt_peer_ptr(rt);
+	peer = rt_peer_ptr_compat(rt);
 	if (!peer) {
 		icmp_send(skb, ICMP_REDIRECT, ICMP_REDIR_HOST, rt->rt_gateway);
 		return;
@@ -1606,7 +1605,6 @@ void ip_rt_send_redirect(struct sk_buff *skb)
 static int ip_error(struct sk_buff *skb)
 {
 	struct rtable *rt = skb_rtable(skb);
-	struct inet_peer *peer;
 	unsigned long now;
 	bool send;
 	int code;
@@ -1630,10 +1628,11 @@ static int ip_error(struct sk_buff *skb)
 
 	if (!rt_has_peer(rt))
 		rt_bind_peer(rt, rt->rt_dst, 1);
-	peer = rt_peer_ptr(rt);
 
 	send = true;
-	if (peer) {
+	if (rt_has_peer(rt)) {
+		struct inet_peer *peer = rt_peer_ptr(rt);
+
 		now = jiffies;
 		peer->rate_tokens += now - peer->rate_last;
 		if (peer->rate_tokens > ip_rt_error_burst)
@@ -1733,14 +1732,13 @@ static void check_peer_pmtu(struct dst_entry *dst, struct inet_peer *peer)
 static void ip_rt_update_pmtu(struct dst_entry *dst, u32 mtu)
 {
 	struct rtable *rt = (struct rtable *) dst;
-	struct inet_peer *peer;
 
 	dst_confirm(dst);
 
 	if (!rt_has_peer(rt))
 		rt_bind_peer(rt, rt->rt_dst, 1);
-	peer = rt_peer_ptr(rt);
-	if (peer) {
+	if (rt_has_peer(rt)) {
+		struct inet_peer *peer = rt_peer_ptr(rt);
 		unsigned long pmtu_expires = ACCESS_ONCE(peer->pmtu_expires);
 
 		if (mtu < ip_rt_min_pmtu)
@@ -1768,13 +1766,12 @@ static struct dst_entry *ipv4_dst_check(struct dst_entry *dst, u32 cookie)
 	if (rt_is_expired(rt))
 		return NULL;
 	if (rt->rt_peer_genid != rt_peer_genid()) {
-		struct inet_peer *peer;
 
 		if (!rt_has_peer(rt))
 			rt_bind_peer(rt, rt->rt_dst, 0);
 
-		peer = rt_peer_ptr(rt);
-		if (peer) {
+		if (rt_has_peer(rt)) {
+			struct inet_peer *peer = rt_peer_ptr(rt);
 			check_peer_pmtu(dst, peer);
 
 			if (peer->redirect_learned.a4 &&
diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c
index 370178b..a9227fc 100644
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@ -1798,7 +1798,7 @@ struct inet_peer *tcp_v4_get_peer(struct sock *sk, bool *release_it)
 	} else {
 		if (!rt_has_peer(rt))
 			rt_bind_peer(rt, inet->inet_daddr, 1);
-		peer = rt_peer_ptr(rt);
+		peer = rt_peer_ptr_compat(rt);
 		*release_it = false;
 	}
 
diff --git a/net/ipv6/icmp.c b/net/ipv6/icmp.c
index a81a800..8f74d9f 100644
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@ -194,7 +194,7 @@ static inline bool icmpv6_xrlim_allow(struct sock *sk, u8 type,
 
 		if (!rt6_has_peer(rt))
 			rt6_bind_peer(rt, 1);
-		res = inet_peer_xrlim_allow(rt6_peer_ptr(rt), tmo);
+		res = inet_peer_xrlim_allow(rt6_peer_ptr_compat(rt), tmo);
 	}
 	dst_release(dst);
 	return res;
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 61d8fa8..80f409b 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -495,7 +495,7 @@ int ip6_forward(struct sk_buff *skb)
 		/* Limit redirects both by destination (here)
 		   and by source (inside ndisc_send_redirect)
 		 */
-		if (inet_peer_xrlim_allow(rt6_peer_ptr(rt), 1*HZ))
+		if (inet_peer_xrlim_allow(rt6_peer_ptr_compat(rt), 1*HZ))
 			ndisc_send_redirect(skb, n, target);
 	} else {
 		int addrtype = ipv6_addr_type(&hdr->saddr);
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index 7de064c..1d86809 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -1583,7 +1583,7 @@ void ndisc_send_redirect(struct sk_buff *skb, struct neighbour *neigh,
 	}
 	if (!rt6_has_peer(rt))
 		rt6_bind_peer(rt, 1);
-	if (inet_peer_xrlim_allow(rt6_peer_ptr(rt), 1*HZ))
+	if (inet_peer_xrlim_allow(rt6_peer_ptr_compat(rt), 1*HZ))
 		goto release;
 
 	if (dev->addr_len) {
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index cd7fc4c..9492906 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -102,7 +102,6 @@ static struct rt6_info *rt6_get_route_info(struct net *net,
 static u32 *ipv6_cow_metrics(struct dst_entry *dst, unsigned long old)
 {
 	struct rt6_info *rt = (struct rt6_info *) dst;
-	struct inet_peer *peer;
 	u32 *p = NULL;
 
 	if (!(rt->dst.flags & DST_HOST))
@@ -111,8 +110,8 @@ static u32 *ipv6_cow_metrics(struct dst_entry *dst, unsigned long old)
 	if (!rt6_has_peer(rt))
 		rt6_bind_peer(rt, 1);
 
-	peer = rt6_peer_ptr(rt);
-	if (peer) {
+	if (rt6_has_peer(rt)) {
+		struct inet_peer *peer = rt6_peer_ptr(rt);
 		u32 *old_p = __DST_METRICS_PTR(old);
 		unsigned long prev, new;
 
diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c
index 547f4a8..6ac9fb5 100644
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@ -1876,7 +1876,7 @@ static struct inet_peer *tcp_v6_get_peer(struct sock *sk, bool *release_it)
 	} else {
 		if (!rt6_has_peer(rt))
 			rt6_bind_peer(rt, 1);
-		peer = rt6_peer_ptr(rt);
+		peer = rt6_peer_ptr_compat(rt);
 		*release_it = false;
 	}
 
-- 
1.8.1.4

