From f9434ad1552427fab49336e1a6e3ef121895b9d1 Mon Sep 17 00:00:00 2001
From: David Rientjes <rientjes@google.com>
Date: Wed, 23 Mar 2011 16:42:44 -0700
Subject: [PATCH] memcg: give current access to memory reserves if it's trying to die
Patch-mainline: f9434ad1552427fab49336e1a6e3ef121895b9d1
References: bnc#704592

When a memcg is oom and current has already received a SIGKILL, then give
it access to memory reserves with a higher scheduling priority so that it
may quickly exit and free its memory.

This is identical to the global oom killer and is done even before
checking for panic_on_oom: a pending SIGKILL here while panic_on_oom is
selected is guaranteed to have come from userspace; the thread only needs
access to memory reserves to exit and thus we don't unnecessarily panic
the machine until the kernel has no last resort to free memory.

Signed-off-by: David Rientjes <rientjes@google.com>
Cc: Balbir Singh <balbir@linux.vnet.ibm.com>
Cc: Daisuke Nishimura <nishimura@mxp.nes.nec.co.jp>
Acked-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Michal Hocko <mhocko@suse.cz>

---
 mm/oom_kill.c |   11 +++++++++++
 1 file changed, 11 insertions(+)
Index: linux-2.6.32-memcg-backports/mm/oom_kill.c
===================================================================
--- linux-2.6.32-memcg-backports.orig/mm/oom_kill.c
+++ linux-2.6.32-memcg-backports/mm/oom_kill.c
@@ -438,6 +438,16 @@ void mem_cgroup_out_of_memory(struct mem
 	unsigned long points = 0;
 	struct task_struct *p;
 
+	/*
+	 * If current has a pending SIGKILL, then automatically select it.  The
+	 * goal is to allow it to allocate so that it may quickly exit and free
+	 * its memory.
+	 */
+	if (fatal_signal_pending(current)) {
+		set_thread_flag(TIF_MEMDIE);
+		return;
+	}
+
 	read_lock(&tasklist_lock);
 retry:
 	p = select_bad_process(&points, mem);
