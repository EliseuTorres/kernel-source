From: Michal Hocko <mhocko@suse.cz>
Subject: fix ipc_rcu_{get,put}ref during destruction
Patch-mainline: no, fixed differently
References: bnc#848321, CVE-2013-4483

ipc reference counting is not atomic and it relies on {sem,msg}_perm spin lock
& RCU combo.most of the time. There are few places where the lock is not held
though. Once of those is newque/newary which are safe as the object is newly
allocated and not visible to others yet.

The destruction part is more tricky though. Consider do_msgsnd vs. freeque as
an example.

do_msgsnd		freeque
			  msg_unlock
 msg_lock_check
 ipc_rcu_getref		  ipc_rcu_putref
   refcount++		    refcount--
 msg_unlock
 schedule
 msg_lock
 ipc_rcu_putref

Which might result in a pending reference in a proper refcount read/write
ordering. This would lead to a mem leak and a potential userspace triggered
memory exhaustion.

The IPC semaphore code seems to suffer from the same race while IPC shmem seems
to be OK because the reference count is not touch between create and destroy.

This patches fixes the issue by moving {msg,sem}_unlock behind last
ipc_rcu_putref which should be safe because
	- no code after msg_unlock takes any locks which would interfere with
	  {msg,sem}_unlock
	- the last putref cleans things up from the deferred call_rcu context
	  so it is safe to be called from ipc_{un}lock context

The upstream has fixed this differently (by 6062a8dc0517 ipc,sem: fine grained
locking for semtimedop) but the locking rework is too invasive for SLE kernels.

Signed-off-by: Michal Hocko <mhocko@suse.cz>

---
 ipc/msg.c |    2 +-
 ipc/sem.c |    2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -284,7 +284,6 @@ static void freeque(struct ipc_namespace
 	expunge_all(msq, -EIDRM);
 	ss_wakeup(&msq->q_senders, 1);
 	msg_rmid(ns, msq);
-	msg_unlock(msq);
 
 	tmp = msq->q_messages.next;
 	while (tmp != &msq->q_messages) {
@@ -297,6 +296,7 @@ static void freeque(struct ipc_namespace
 	atomic_sub(msq->q_cbytes, &ns->msg_bytes);
 	security_msg_queue_free(msq);
 	ipc_rcu_putref(msq);
+	msg_unlock(msq);
 }
 
 /*
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -726,12 +726,12 @@ static void freeary(struct ipc_namespace
 
 	/* Remove the semaphore set from the IDR */
 	sem_rmid(ns, sma);
-	sem_unlock(sma);
 
 	wake_up_sem_queue_do(&tasks);
 	ns->used_sems -= sma->sem_nsems;
 	security_sem_free(sma);
 	ipc_rcu_putref(sma);
+	sem_unlock(sma);
 }
 
 static unsigned long copy_semid_to_user(void __user *buf, struct semid64_ds *in, int version)
