Subject: Provide realtime priority kthread and workqueue boot options
From: Mike Galbraith <mgalbraith@suse.de>
Date: Tue Oct  8 06:27:03 CEST 2013
Patch-mainline: never
References: bnc#836718

Nasty hack to allow users to abuse realtime without starving the kernel,
and reaping the consequences thereof.

Boot box nortsched rtkthreads=N and optionally rtworkqueues=N+1, and the
user can slam a box into the saturation wall without starving the kernel
IFF he restricts userspace to priority < N.

Signed-off-by: Mike Galbraith <mgalbraith@suse.de>

---
 Documentation/kernel-parameters.txt |    4 +++
 kernel/kthread.c                    |   42 +++++++++++++++++++++++++++++++++--
 kernel/workqueue.c                  |   43 +++++++++++++++++++++++++++++++++++-
 3 files changed, 86 insertions(+), 3 deletions(-)

--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -2279,6 +2279,10 @@ bytes respectively. Such letter suffixes
 
 	nortsched       [KNL] Disables realtime task bandwidth control.
 
+	rtkthreads=	[KNL] kernel threads run as SCHED_FIFO at the provided priority (1..99).
+
+	rtworkqueues=	[KNL] kworker threads run as SCHED_FIFO at the provided priority (1..99).
+
 	security=	[SECURITY] Choose a security module to enable at boot.
 			If this boot parameter is not specified, only the first
 			security module asking for security registration will be
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -16,6 +16,9 @@
 #include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/freezer.h>
+#ifndef __GENKSYMS__
+#include <linux/hardirq.h>
+#endif
 #include <trace/events/sched.h>
 
 static DEFINE_SPINLOCK(kthread_create_lock);
@@ -124,6 +127,26 @@ static void create_kthread(struct kthrea
 	}
 }
 
+static struct sched_param fifo_param, normal_param;
+
+static inline void kthread_set_sched_params(struct task_struct *kthread)
+{
+	if (in_interrupt())
+		return;
+	if (!fifo_param.sched_priority) {
+		sched_setscheduler_nocheck(kthread, SCHED_NORMAL, &normal_param);
+		return;
+	}
+	sched_setscheduler_nocheck(kthread, SCHED_FIFO, &fifo_param);
+}
+
+static inline void kthread_clr_sched_params(struct task_struct *kthread)
+{
+	if (in_interrupt() || !rt_task(kthread) || !fifo_param.sched_priority)
+		return;
+	sched_setscheduler_nocheck(kthread, SCHED_NORMAL, &normal_param);
+}
+
 /**
  * kthread_create_on_node - create a kthread.
  * @threadfn: the function to run until signal_pending(current).
@@ -167,7 +190,6 @@ struct task_struct *kthread_create_on_no
 	wait_for_completion(&create.done);
 
 	if (!IS_ERR(create.result)) {
-		static const struct sched_param param = { .sched_priority = 0 };
 		va_list args;
 
 		va_start(args, namefmt);
@@ -178,7 +200,7 @@ struct task_struct *kthread_create_on_no
 		 * root may have changed our (kthreadd's) priority or CPU mask.
 		 * The kernel thread should not inherit these properties.
 		 */
-		sched_setscheduler_nocheck(create.result, SCHED_NORMAL, &param);
+		kthread_set_sched_params(create.result);
 		set_cpus_allowed_ptr(create.result, cpu_all_mask);
 	}
 	return create.result;
@@ -235,6 +257,7 @@ int kthread_stop(struct task_struct *k)
 	barrier(); /* it might have exited */
 	if (k->vfork_done != NULL) {
 		kthread->should_stop = 1;
+		kthread_clr_sched_params(k);
 		wake_up_process(k);
 		wait_for_completion(&kthread->exited);
 	}
@@ -256,6 +279,7 @@ int kthreadd(void *unused)
 	ignore_signals(tsk);
 	set_cpus_allowed_ptr(tsk, cpu_all_mask);
 	set_mems_allowed(node_states[N_HIGH_MEMORY]);
+	kthread_set_sched_params(current);
 
 	current->flags |= PF_NOFREEZE | PF_FREEZER_NOSIG;
 
@@ -441,3 +465,17 @@ void flush_kthread_worker(struct kthread
 	wait_for_completion(&fwork.done);
 }
 EXPORT_SYMBOL_GPL(flush_kthread_worker);
+
+static int __init setup_rtkthreads(char *str)
+{
+	int prio;
+
+	if (kstrtoint(str, 0, &prio) || prio < 1 || prio > 99) {
+		prio = 0;
+		pr_warn("Unable to set kthread default priority\n");
+	}
+	fifo_param.sched_priority = prio;
+
+        return 1;
+}
+__setup("rtkthreads=", setup_rtkthreads);
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -1341,6 +1341,25 @@ static struct worker *alloc_worker(void)
 	return worker;
 }
 
+static struct sched_param fifo_param, normal_param;
+
+static inline void kworker_set_sched_params(struct task_struct *worker)
+{
+	int prio = fifo_param.sched_priority;
+	if (!prio || in_interrupt())
+		return;
+	if (worker->policy == SCHED_FIFO && worker->rt_priority == prio)
+		return;
+	sched_setscheduler_nocheck(worker, SCHED_FIFO, &fifo_param);
+}
+
+static inline void kworker_clr_sched_params(struct task_struct *worker)
+{
+	if (in_interrupt() || !fifo_param.sched_priority || !rt_task(worker))
+		return;
+	sched_setscheduler_nocheck(worker, SCHED_NORMAL, &normal_param);
+}
+
 /**
  * create_worker - create a new workqueue worker
  * @gcwq: gcwq the new worker will belong to
@@ -1402,6 +1421,8 @@ static struct worker *create_worker(stru
 			worker->flags |= WORKER_UNBOUND;
 	}
 
+	kworker_set_sched_params(worker->task);
+
 	return worker;
 fail:
 	if (id >= 0) {
@@ -1458,6 +1479,7 @@ static void destroy_worker(struct worker
 
 	spin_unlock_irq(&gcwq->lock);
 
+	kworker_clr_sched_params(worker->task);
 	kthread_stop(worker->task);
 	kfree(worker);
 
@@ -2982,6 +3004,7 @@ struct workqueue_struct *__alloc_workque
 			goto err;
 
 		rescuer->task->flags |= PF_THREAD_BOUND;
+		kworker_set_sched_params(rescuer->task);
 		wake_up_process(rescuer->task);
 	}
 
@@ -3074,6 +3097,7 @@ void destroy_workqueue(struct workqueue_
 	}
 
 	if (wq->flags & WQ_RESCUER) {
+		kworker_clr_sched_params(wq->rescuer->task);
 		kthread_stop(wq->rescuer->task);
 		free_mayday_mask(wq->mayday_mask);
 		kfree(wq->rescuer);
@@ -3494,13 +3518,16 @@ static int __devinit workqueue_cpu_callb
 		if (IS_ERR(new_trustee))
 			return notifier_from_errno(PTR_ERR(new_trustee));
 		kthread_bind(new_trustee, cpu);
+		kworker_set_sched_params(new_trustee);
 		/* fall through */
 	case CPU_UP_PREPARE:
 		BUG_ON(gcwq->first_idle);
 		new_worker = create_worker(gcwq, false);
 		if (!new_worker) {
-			if (new_trustee)
+			if (new_trustee) {
+				kworker_clr_sched_params(new_trustee);
 				kthread_stop(new_trustee);
+			}
 			return NOTIFY_BAD;
 		}
 	}
@@ -3845,3 +3872,17 @@ static int __init init_workqueues(void)
 	return 0;
 }
 early_initcall(init_workqueues);
+
+static int __init setup_rtworkqueues(char *str)
+{
+	int prio;
+
+	if (kstrtoint(str, 0, &prio) || prio < 1 || prio > 99) {
+		prio = 0;
+		pr_warn("Unable to set kworker default priority\n");
+	}
+	fifo_param.sched_priority = prio;
+
+        return 1;
+}
+__setup("rtworkqueues=", setup_rtworkqueues);
