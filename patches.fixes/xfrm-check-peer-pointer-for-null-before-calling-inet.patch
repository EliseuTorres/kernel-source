From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 16 May 2014 19:17:36 +0200
Subject: xfrm: check peer pointer for null before calling inet_putpeer()
Patch-mainline: Never, SLE11-SP3 specific code
References: bnc#877775

Instances of struct dst_entry embedded into struct xfrm_dst have
_peer initialized to 0, the peer it is later overwritten in
xfrm4_fill_dst() by the value from the source dst_entry. If
this doesn't happen, e.g. because the xfrm state is never
established, xfrm4_dst_destroy() will call inet_putpeer()
on a null pointer (because rt_has_peer() is still true). The
same problem exists also in xfrm6 code.

The only other code not initializing _peer in dst_entry to
inetpeer tree base is decnet but that never acesses it anyway.

We could avoid the problem by initializing the member the way
other IPv4/IPv6 code does but as only xfrm{4,6}_dst_destroy()
uses it, the easiest fix is to add the check there.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 net/ipv4/xfrm4_policy.c | 4 +++-
 net/ipv6/xfrm6_policy.c | 4 +++-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/net/ipv4/xfrm4_policy.c b/net/ipv4/xfrm4_policy.c
index 4856615..df2fb1c 100644
--- a/net/ipv4/xfrm4_policy.c
+++ b/net/ipv4/xfrm4_policy.c
@@ -212,7 +212,9 @@ static void xfrm4_dst_destroy(struct dst_entry *dst)
 
 	if (rt_has_peer(&xdst->u.rt)) {
 		struct inet_peer *peer = rt_peer_ptr(&xdst->u.rt);
-		inet_putpeer(peer);
+
+		if (peer)
+			inet_putpeer(peer);
 	}
 
 	xfrm_dst_destroy(xdst);
diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c
index 8734314..8a743c8 100644
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -228,7 +228,9 @@ static void xfrm6_dst_destroy(struct dst_entry *dst)
 	dst_destroy_metrics_generic(dst);
 	if (rt6_has_peer(&xdst->u.rt6)) {
 		struct inet_peer *peer = rt6_peer_ptr(&xdst->u.rt6);
-		inet_putpeer(peer);
+
+		if (peer)
+			inet_putpeer(peer);
 	}
 	xfrm_dst_destroy(xdst);
 }
-- 
1.8.1.4

