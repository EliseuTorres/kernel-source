From: Trond Myklebust <Trond.Myklebust@netapp.com>
Date: Thu, 8 Mar 2012 17:42:01 -0500
Subject: [PATCH] NFSv4: Clean up nfs4_select_rw_stateid()
Git-commit: 4fc8796d23819da814ec25b7793bde8f104f1a2a
Patch-mainline: v3.4
References: bnc#888968

Ensure that we select delegation stateids first, then
lock stateids and then open stateids.

Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
Acked-by: NeilBrown <neilb@suse.de>

---
 fs/nfs/nfs4_fs.h   |    3 +-
 fs/nfs/nfs4proc.c  |    8 ++++---
 fs/nfs/nfs4state.c |   55 ++++++++++++++++++++++++++++++++++++++---------------
 fs/nfs/nfs4xdr.c   |   13 ++++++++----
 4 files changed, 56 insertions(+), 23 deletions(-)

--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4_fs.h
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4_fs.h
@@ -366,7 +366,8 @@ extern void nfs41_handle_sequence_flag_e
 extern void nfs41_handle_recall_slot(struct nfs_client *clp);
 extern void nfs4_put_lock_state(struct nfs4_lock_state *lsp);
 extern int nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl);
-extern void nfs4_select_rw_stateid(nfs4_stateid *, struct nfs4_state *, fl_owner_t, pid_t);
+extern void nfs4_select_rw_stateid(nfs4_stateid *, struct nfs4_state *,
+		fmode_t, fl_owner_t, pid_t);
 extern int nfs4_lock_lost(const struct nfs_open_context *ctx,
 			  const struct nfs_lock_context *l_ctx);
 
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4proc.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4proc.c
@@ -1946,10 +1946,12 @@ static int _nfs4_do_setattr(struct inode
 
 	nfs_fattr_init(fattr);
 
-	if (nfs4_copy_delegation_stateid(&arg.stateid, inode, FMODE_WRITE)) {
+	if (state != NULL) {
+		nfs4_select_rw_stateid(&arg.stateid, state, FMODE_WRITE,
+				current->files, current->tgid);
+	} else if (nfs4_copy_delegation_stateid(&arg.stateid, inode,
+				FMODE_WRITE)) {
 		/* Use that stateid */
-	} else if (state != NULL) {
-		nfs4_select_rw_stateid(&arg.stateid, state, current->files, current->tgid);
 	} else
 		nfs4_stateid_copy(&arg.stateid, &zero_stateid);
 
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4state.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4state.c
@@ -871,31 +871,56 @@ int nfs4_set_lock_state(struct nfs4_stat
 	return 0;
 }
 
-/*
- * Byte-range lock aware utility to initialize the stateid of read/write
- * requests.
- */
-void nfs4_select_rw_stateid(nfs4_stateid *dst, struct nfs4_state *state, fl_owner_t fl_owner, pid_t fl_pid)
+static int nfs4_copy_lock_stateid(nfs4_stateid *dst, struct nfs4_state *state,
+		fl_owner_t fl_owner, pid_t fl_pid)
 {
 	struct nfs4_lock_state *lsp;
-	int seq;
+	int ret = -ENOENT;
 
-	do {
-		seq = read_seqbegin(&state->seqlock);
-		nfs4_stateid_copy(dst, &state->stateid);
-	} while (read_seqretry(&state->seqlock, seq));
 	if (test_bit(LK_STATE_IN_USE, &state->flags) == 0)
-		return;
-	if (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)
-		return;
+		goto out;
 
 	spin_lock(&state->state_lock);
 	lsp = __nfs4_find_lock_state(state, fl_owner, fl_pid, NFS4_ANY_LOCK_TYPE);
-	if (lsp != NULL &&
-	    (lsp->ls_flags & (NFS_LOCK_INITIALIZED | NFS_LOCK_LOST)) != 0)
+	if (lsp && (lsp->ls_flags & NFS_LOCK_LOST))
+		ret = -EIO;
+	else if (lsp != NULL &&
+	    (lsp->ls_flags & (NFS_LOCK_INITIALIZED | NFS_LOCK_LOST)) != 0) {
 		nfs4_stateid_copy(dst, &lsp->ls_stateid);
+		ret = 0;
+	}
 	spin_unlock(&state->state_lock);
 	nfs4_put_lock_state(lsp);
+out:
+	return ret;
+}
+
+static void nfs4_copy_open_stateid(nfs4_stateid *dst, struct nfs4_state *state)
+{
+	int seq;
+
+	do {
+		seq = read_seqbegin(&state->seqlock);
+		nfs4_stateid_copy(dst, &state->stateid);
+	} while (read_seqretry(&state->seqlock, seq));
+}
+
+/*
+ * Byte-range lock aware utility to initialize the stateid of read/write
+ * requests.
+ */
+void nfs4_select_rw_stateid(nfs4_stateid *dst, struct nfs4_state *state,
+		fmode_t fmode, fl_owner_t fl_owner, pid_t fl_pid)
+{
+	int ret = nfs4_copy_lock_stateid(dst, state, fl_owner, fl_pid);
+	if (ret == -EIO)
+		/* A lost lock - don't even consider delegations */
+		goto out;
+	if (nfs4_copy_delegation_stateid(dst, state->inode, fmode))
+		return;
+out:
+	if (ret)
+		nfs4_copy_open_stateid(dst, state);
 }
 
 /* Check the lock access would try to use a lost lock stateid */
--- linux-3.0-SLE11-SP3.orig/fs/nfs/nfs4xdr.c
+++ linux-3.0-SLE11-SP3/fs/nfs/nfs4xdr.c
@@ -1446,12 +1446,17 @@ static void encode_putrootfh(struct xdr_
 	hdr->replen += decode_putrootfh_maxsz;
 }
 
-static void encode_stateid(struct xdr_stream *xdr, const struct nfs_open_context *ctx, const struct nfs_lock_context *l_ctx, int zero_seqid)
+static void encode_stateid(struct xdr_stream *xdr,
+		const struct nfs_open_context *ctx,
+		const struct nfs_lock_context *l_ctx,
+		fmode_t fmode,
+		int zero_seqid)
 {
 	nfs4_stateid stateid;
 
 	if (ctx->state != NULL) {
-		nfs4_select_rw_stateid(&stateid, ctx->state, l_ctx->lockowner, l_ctx->pid);
+		nfs4_select_rw_stateid(&stateid, ctx->state,
+				fmode, l_ctx->lockowner, l_ctx->pid);
 		if (zero_seqid)
 			stateid.seqid = 0;
 		encode_nfs4_stateid(xdr, &stateid);
@@ -1467,7 +1472,7 @@ static void encode_read(struct xdr_strea
 	*p = cpu_to_be32(OP_READ);
 
 	encode_stateid(xdr, args->context, args->lock_context,
-		       hdr->minorversion);
+			FMODE_READ, hdr->minorversion);
 
 	p = reserve_space(xdr, 12);
 	p = xdr_encode_hyper(p, args->offset);
@@ -1655,7 +1660,7 @@ static void encode_write(struct xdr_stre
 	*p = cpu_to_be32(OP_WRITE);
 
 	encode_stateid(xdr, args->context, args->lock_context,
-		       hdr->minorversion);
+			FMODE_WRITE, hdr->minorversion);
 
 	p = reserve_space(xdr, 16);
 	p = xdr_encode_hyper(p, args->offset);
