From: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Subject: powerpc: Fix memory hotplug with sparse vmemmap
Git-commit: f7e3334a6bcb42e7295a9bd9cb36ca4e6e4e66b4
Patch-mainline: v3.12-rc4
References: bnc#827527 

    Previous commit 46723bfa540... introduced a new config option
    HAVE_BOOTMEM_INFO_NODE that ended up breaking memory hot-remove for ppc
    when sparse vmemmap is not defined.
    
    This patch defines HAVE_BOOTMEM_INFO_NODE for ppc and adds the call to
    register_page_bootmem_info_node. Without this we get a BUG_ON for memory
    hot remove in put_page_bootmem().
    
    This also adds a stub for register_page_bootmem_memmap to allow ppc to build
    with sparse vmemmap defined. Leaving this as a stub is fine since the same
    vmemmap addresses are also handled in vmemmap_populate and as such are
    properly mapped.
    
Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Acked-by: Torsten Duwe <duwe@suse.de>
    CC: <stable@vger.kernel.org> [v3.9+]

 arch/powerpc/mm/init_64.c |    4 ++++
 arch/powerpc/mm/mem.c     |    9 +++++++++
 mm/Kconfig                |    2 +-
 3 files changed, 14 insertions(+), 1 deletion(-)
Index: linux-3.0-SLE11-SP3/arch/powerpc/mm/init_64.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/arch/powerpc/mm/init_64.c
+++ linux-3.0-SLE11-SP3/arch/powerpc/mm/init_64.c
@@ -316,5 +316,10 @@ int __meminit vmemmap_populate(struct pa
 	return 0;
 }
 
+void register_page_bootmem_memmap(unsigned long section_nr,
+				  struct page *start_page, unsigned long size)
+{
+}
+
 #endif /* CONFIG_SPARSEMEM_VMEMMAP */
 
Index: linux-3.0-SLE11-SP3/arch/powerpc/mm/mem.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/arch/powerpc/mm/mem.c
+++ linux-3.0-SLE11-SP3/arch/powerpc/mm/mem.c
@@ -288,6 +288,14 @@ void __init paging_init(void)
 }
 #endif /* ! CONFIG_NEED_MULTIPLE_NODES */
 
+static void __init register_page_bootmem_info(void)
+{
+	int i;
+
+	for_each_online_node(i)
+		register_page_bootmem_info_node(NODE_DATA(i));
+}
+
 void __init mem_init(void)
 {
 #ifdef CONFIG_NEED_MULTIPLE_NODES
@@ -303,6 +311,7 @@ void __init mem_init(void)
 		swiotlb_init(1);
 #endif
 
+	register_page_bootmem_info();
 	num_physpages = memblock_phys_mem_size() >> PAGE_SHIFT;
 	high_memory = (void *) __va(max_low_pfn * PAGE_SIZE);
 
diff --git a/mm/Kconfig b/mm/Kconfig
index 1ff6923..30cb926 100644
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -152,7 +152,7 @@ config MEMORY_HOTPLUG_SPARSE
 config MEMORY_HOTREMOVE
 	bool "Allow for memory hot remove"
 	select MEMORY_ISOLATION
-	select HAVE_BOOTMEM_INFO_NODE if X86_64
+	select HAVE_BOOTMEM_INFO_NODE if (X86_64 || PPC64)
 	depends on MEMORY_HOTPLUG && ARCH_ENABLE_MEMORY_HOTREMOVE
 	depends on MIGRATION
 
