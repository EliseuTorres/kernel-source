From: Darrick J. Wong <djwong@us.ibm.com>
Date: Fri, 1 Oct 2010 13:55:47 -0700
Subject: libsas: Don't issue commands to devices that have been hot-removed
Git-commit: 56dd2c0691a5a387b7b05835fe547dc6fade9407
References: bnc#668898
Patch-mainline: v2.6.37-rc1

sd will get hung up issuing commands to flush write cache if a SAS
device behind the expander is unplugged without warning.  Change libsas
to reject commands to domain devices that have already gone away.

[maciej.trela@intel.com: removed setting ->gone in sas_deform_port() to
 permit sync cache commands at module removal]

Backported to SLES11 SP1.

Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
Tested-by: Haipao Fan <haipao.fan@intel.com>
Signed-off-by: Maciej Trela <maciej.trela@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: James Bottomley <James.Bottomley@suse.de>
Signed-off-by: Hannes Reinecke <hare@suse.de>

---
 drivers/scsi/libsas/sas_ata.c       |    4 ++++
 drivers/scsi/libsas/sas_expander.c  |    3 +++
 drivers/scsi/libsas/sas_scsi_host.c |    7 +++++++
 include/scsi/libsas.h               |    1 +
 4 files changed, 15 insertions(+)

Index: linux-2.6.32-SLE11-SP2/drivers/scsi/libsas/sas_ata.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/drivers/scsi/libsas/sas_ata.c
+++ linux-2.6.32-SLE11-SP2/drivers/scsi/libsas/sas_ata.c
@@ -161,6 +161,10 @@ static unsigned int sas_ata_qc_issue(str
 	unsigned int xfer = 0;
 	unsigned int si;
 
+	/* If the device fell off, no sense in issuing commands */
+	if (dev->gone)
+		return AC_ERR_SYSTEM;
+
 	task = sas_alloc_task(GFP_ATOMIC);
 	if (!task)
 		return AC_ERR_SYSTEM;
Index: linux-2.6.32-SLE11-SP2/drivers/scsi/libsas/sas_expander.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/drivers/scsi/libsas/sas_expander.c
+++ linux-2.6.32-SLE11-SP2/drivers/scsi/libsas/sas_expander.c
@@ -1726,6 +1726,7 @@ static void sas_unregister_ex_tree(struc
 	struct domain_device *child, *n;
 
 	list_for_each_entry_safe(child, n, &ex->children, siblings) {
+		child->gone = 1;
 		if (child->dev_type == EDGE_DEV ||
 		    child->dev_type == FANOUT_DEV)
 			sas_unregister_ex_tree(child);
@@ -1746,6 +1747,7 @@ static void sas_unregister_devs_sas_addr
 			&ex_dev->children, siblings) {
 			if (SAS_ADDR(child->sas_addr) ==
 			    SAS_ADDR(phy->attached_sas_addr)) {
+				child->gone = 1;
 				if (child->dev_type == EDGE_DEV ||
 				    child->dev_type == FANOUT_DEV)
 					sas_unregister_ex_tree(child);
@@ -1754,6 +1756,7 @@ static void sas_unregister_devs_sas_addr
 				break;
 			}
 		}
+		parent->gone = 1;
 		sas_disable_routing(parent, phy->attached_sas_addr);
 	}
 	memset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);
Index: linux-2.6.32-SLE11-SP2/drivers/scsi/libsas/sas_scsi_host.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/drivers/scsi/libsas/sas_scsi_host.c
+++ linux-2.6.32-SLE11-SP2/drivers/scsi/libsas/sas_scsi_host.c
@@ -227,6 +227,13 @@ int sas_queuecommand(struct scsi_cmnd *c
 			goto out;
 		}
 
+		/* If the device fell off, no sense in issuing commands */
+		if (dev->gone) {
+			cmd->result = DID_BAD_TARGET << 16;
+			scsi_done(cmd);
+			goto out;
+		}
+
 		res = -ENOMEM;
 		task = sas_create_task(cmd, dev, GFP_ATOMIC);
 		if (!task)
Index: linux-2.6.32-SLE11-SP2/include/scsi/libsas.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/include/scsi/libsas.h
+++ linux-2.6.32-SLE11-SP2/include/scsi/libsas.h
@@ -204,6 +204,7 @@ struct domain_device {
         };
 
         void *lldd_dev;
+	int gone;
 };
 
 struct sas_discovery_event {

