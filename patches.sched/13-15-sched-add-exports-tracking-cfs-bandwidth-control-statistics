Subject: [patch 13/15] sched: add exports tracking cfs bandwidth control statistics
From: Paul Turner <pjt@google.com>
Date: Tue, 03 May 2011 02:28:59 -0700
Patch-mainline: no
References:

This change introduces statistics exports for the cpu sub-system, these are
added through the use of a stat file similar to that exported by other
subsystems.

The following exports are included:

nr_periods:	number of periods in which execution occurred
nr_throttled:	the number of periods above in which execution was throttle
throttled_time:	cumulative wall-time that any cpus have been throttled for
this group

Signed-off-by: Nikhil Rao <ncrao@google.com>
Signed-off-by: Paul Turner <pjt@google.com>
Signed-off-by: Bharata B Rao <bharata@linux.vnet.ibm.com>
Acked-by: Mike Galbraith <mgalbraith@suse.de>
---
 kernel/sched.c      |   22 ++++++++++++++++++++++
 kernel/sched_fair.c |    9 +++++++++
 2 files changed, 31 insertions(+)

Index: linux-2.6.32-SLE11-SP2-sched/kernel/sched.c
===================================================================
--- linux-2.6.32-SLE11-SP2-sched.orig/kernel/sched.c
+++ linux-2.6.32-SLE11-SP2-sched/kernel/sched.c
@@ -257,6 +257,10 @@ struct cfs_bandwidth {
 	struct hrtimer period_timer;
 	struct list_head throttled_cfs_rq;
 
+	/* statistics */
+	int nr_periods, nr_throttled;
+	u64 throttled_time;
+
 #endif
 };
 
@@ -428,6 +432,7 @@ struct cfs_rq {
 	u64 runtime_expires;
 	s64 runtime_remaining;
 
+	u64 throttled_timestamp;
 	int throttled, throttle_count;
 	struct list_head throttled_list;
 #endif
@@ -8965,6 +8970,19 @@ int sched_cfs_consistent_handler(struct
 
 	return ret;
 }
+
+static int cpu_stats_show(struct cgroup *cgrp, struct cftype *cft,
+		struct cgroup_map_cb *cb)
+{
+	struct task_group *tg = cgroup_tg(cgrp);
+	struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);
+
+	cb->fill(cb, "nr_periods", cfs_b->nr_periods);
+	cb->fill(cb, "nr_throttled", cfs_b->nr_throttled);
+	cb->fill(cb, "throttled_time", cfs_b->throttled_time);
+
+	return 0;
+}
 #endif /* CONFIG_CFS_BANDWIDTH */
 #endif /* CONFIG_FAIR_GROUP_SCHED */
 
@@ -9011,6 +9029,10 @@ static struct cftype cpu_files[] = {
 		.read_u64 = cpu_cfs_period_read_u64,
 		.write_u64 = cpu_cfs_period_write_u64,
 	},
+	{
+		.name = "stat",
+		.read_map = cpu_stats_show,
+	},
 #endif
 #ifdef CONFIG_RT_GROUP_SCHED
 	{
Index: linux-2.6.32-SLE11-SP2-sched/kernel/sched_fair.c
===================================================================
--- linux-2.6.32-SLE11-SP2-sched.orig/kernel/sched_fair.c
+++ linux-2.6.32-SLE11-SP2-sched/kernel/sched_fair.c
@@ -1409,6 +1409,7 @@ static void throttle_cfs_rq(struct cfs_r
 		rq->nr_running += task_delta;
 
 	cfs_rq->throttled = 1;
+	cfs_rq->throttled_timestamp = rq->clock;
 	spin_lock(&cfs_b->lock);
 	list_add_tail_rcu(&cfs_rq->throttled_list, &cfs_b->throttled_cfs_rq);
 	spin_unlock(&cfs_b->lock);
@@ -1464,8 +1465,10 @@ static void unthrottle_cfs_rq(struct cfs
 
 	cfs_rq->throttled = 0;
 	spin_lock(&cfs_b->lock);
+	cfs_b->throttled_time += rq->clock - cfs_rq->throttled_timestamp;
 	list_del_rcu(&cfs_rq->throttled_list);
 	spin_unlock(&cfs_b->lock);
+	cfs_rq->throttled_timestamp = 0;
 
 	update_rq_clock(rq);
 	/* don't include throttled window for load statistics */
@@ -1578,6 +1581,12 @@ retry:
 		spin_unlock(&cfs_b->lock);
 		goto retry;
 	}
+
+	/* update throttled stats */
+	cfs_b->nr_periods += overrun;
+	if (throttled)
+		cfs_b->nr_throttled += overrun;
+
 	cfs_b->runtime = runtime;
 	cfs_b->idle = idle;
 out_unlock:
