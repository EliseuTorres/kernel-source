From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Subject: LTTng instrumentation - ipc
References: none
Upstream: no

Interprocess communication, core events.

Added tracepoints :

ipc_msg_create
ipc_sem_create
ipc_shm_create

Those tracepoints are used by LTTng.

About the performance impact of tracepoints (which is comparable to markers),
even without immediate values optimizations, tests done by Hideo Aoki on ia64
show no regression. His test case was using hackbench on a kernel where
scheduler instrumentation (about 5 events in code scheduler code) was added.
See the "Tracepoints" patch header for performance result detail.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Masami Hiramatsu <mhiramat@redhat.com>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>

Acked-by: Tony Jones <tonyj@suse.de>
---
 include/trace/ipc.h |   18 ++++++++++++++++++
 ipc/msg.c           |    8 +++++++-
 ipc/sem.c           |    8 +++++++-
 ipc/shm.c           |    8 +++++++-
 4 files changed, 39 insertions(+), 3 deletions(-)

--- /dev/null
+++ b/include/trace/ipc.h
@@ -0,0 +1,18 @@
+#ifndef _TRACE_IPC_H
+#define _TRACE_IPC_H
+
+#include <linux/tracepoint.h>
+
+DECLARE_TRACE(ipc_msg_create,
+	TP_PROTO(long id, int flags),
+	TP_ARGS(id, flags));
+DECLARE_TRACE(ipc_sem_create,
+	TP_PROTO(long id, int flags),
+	TP_ARGS(id, flags));
+DECLARE_TRACE(ipc_shm_create,
+	TP_PROTO(long id, int flags),
+	TP_ARGS(id, flags));
+DECLARE_TRACE(ipc_call,
+	TP_PROTO(unsigned int call, unsigned int first),
+	TP_ARGS(call, first));
+#endif
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -38,6 +38,7 @@
 #include <linux/rwsem.h>
 #include <linux/nsproxy.h>
 #include <linux/ipc_namespace.h>
+#include <trace/ipc.h>
 
 #include <asm/current.h>
 #include <asm/uaccess.h>
@@ -72,6 +73,8 @@ struct msg_sender {
 
 #define msg_unlock(msq)		ipc_unlock(&(msq)->q_perm)
 
+DEFINE_TRACE(ipc_msg_create);
+
 static void freeque(struct ipc_namespace *, struct kern_ipc_perm *);
 static int newque(struct ipc_namespace *, struct ipc_params *);
 #ifdef CONFIG_PROC_FS
@@ -315,6 +318,7 @@ SYSCALL_DEFINE2(msgget, key_t, key, int,
 	struct ipc_namespace *ns;
 	struct ipc_ops msg_ops;
 	struct ipc_params msg_params;
+	long ret;
 
 	ns = current->nsproxy->ipc_ns;
 
@@ -325,7 +329,9 @@ SYSCALL_DEFINE2(msgget, key_t, key, int,
 	msg_params.key = key;
 	msg_params.flg = msgflg;
 
-	return ipcget(ns, &msg_ids(ns), &msg_ops, &msg_params);
+	ret = ipcget(ns, &msg_ids(ns), &msg_ops, &msg_params);
+	trace_ipc_msg_create(ret, msgflg);
+	return ret;
 }
 
 static inline unsigned long
--- a/ipc/sem.c
+++ b/ipc/sem.c
@@ -83,6 +83,7 @@
 #include <linux/rwsem.h>
 #include <linux/nsproxy.h>
 #include <linux/ipc_namespace.h>
+#include <trace/ipc.h>
 
 #include <asm/uaccess.h>
 #include "util.h"
@@ -115,6 +116,8 @@ static int sysvipc_sem_proc_show(struct
 #define sc_semopm	sem_ctls[2]
 #define sc_semmni	sem_ctls[3]
 
+DEFINE_TRACE(ipc_sem_create);
+
 void sem_init_ns(struct ipc_namespace *ns)
 {
 	ns->sc_semmsl = SEMMSL;
@@ -320,6 +323,7 @@ SYSCALL_DEFINE3(semget, key_t, key, int,
 	struct ipc_namespace *ns;
 	struct ipc_ops sem_ops;
 	struct ipc_params sem_params;
+	long err;
 
 	ns = current->nsproxy->ipc_ns;
 
@@ -334,7 +338,9 @@ SYSCALL_DEFINE3(semget, key_t, key, int,
 	sem_params.flg = semflg;
 	sem_params.u.nsems = nsems;
 
-	return ipcget(ns, &sem_ids(ns), &sem_ops, &sem_params);
+	err = ipcget(ns, &sem_ids(ns), &sem_ops, &sem_params);
+	trace_ipc_sem_create(err, semflg);
+	return err;
 }
 
 /*
--- a/ipc/shm.c
+++ b/ipc/shm.c
@@ -40,6 +40,7 @@
 #include <linux/mount.h>
 #include <linux/ipc_namespace.h>
 #include <linux/ima.h>
+#include <trace/ipc.h>
 
 #include <asm/uaccess.h>
 
@@ -57,6 +58,8 @@ struct shm_file_data {
 static const struct file_operations shm_file_operations;
 static const struct vm_operations_struct shm_vm_ops;
 
+DEFINE_TRACE(ipc_shm_create);
+
 #define shm_ids(ns)	((ns)->ids[IPC_SHM_IDS])
 
 #define shm_unlock(shp)			\
@@ -451,6 +454,7 @@ SYSCALL_DEFINE3(shmget, key_t, key, size
 	struct ipc_namespace *ns;
 	struct ipc_ops shm_ops;
 	struct ipc_params shm_params;
+	long err;
 
 	ns = current->nsproxy->ipc_ns;
 
@@ -462,7 +466,9 @@ SYSCALL_DEFINE3(shmget, key_t, key, size
 	shm_params.flg = shmflg;
 	shm_params.u.size = size;
 
-	return ipcget(ns, &shm_ids(ns), &shm_ops, &shm_params);
+	err = ipcget(ns, &shm_ids(ns), &shm_ops, &shm_params);
+	trace_ipc_shm_create(err, shmflg);
+	return err;
 }
 
 static inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)
