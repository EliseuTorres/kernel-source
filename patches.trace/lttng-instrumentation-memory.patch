From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Subject: LTTng instrumentation - memory page faults
References: none
Upstream: no

Instrument the page fault entry and exit. Useful to detect delays caused by page
faults and bad memory usage patterns.

Those tracepoints are used by LTTng.

About the performance impact of tracepoints (which is comparable to markers),
even without immediate values optimizations, tests done by Hideo Aoki on ia64
show no regression. His test case was using hackbench on a kernel where
scheduler instrumentation (about 5 events in code scheduler code) was added.
See the "Tracepoints" patch header for performance result detail.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Andi Kleen <andi-suse@firstfloor.org>
CC: linux-mm@kvack.org
CC: Dave Hansen <haveblue@us.ibm.com>
CC: Masami Hiramatsu <mhiramat@redhat.com>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>

Acked-by: Tony Jones <tonyj@suse.de>
---
 include/trace/fault.h |   27 +++++++++++++++++++++++++++
 mm/memory.c           |   11 +++++++++--
 2 files changed, 36 insertions(+), 2 deletions(-)

--- a/mm/memory.c
+++ b/mm/memory.c
@@ -57,6 +57,7 @@
 #include <linux/swapops.h>
 #include <linux/elf.h>
 #include <trace/swap.h>
+#include <trace/fault.h>
 
 #include <asm/io.h>
 #include <asm/pgalloc.h>
@@ -68,6 +69,8 @@
 #include "internal.h"
 
 DEFINE_TRACE(swap_in);
+DEFINE_TRACE(page_fault_get_user_entry);
+DEFINE_TRACE(page_fault_get_user_exit);
 
 #ifndef CONFIG_NEED_MULTIPLE_NODES
 /* use the per-pgdat data instead for discontigmem - mbligh */
@@ -1323,11 +1326,15 @@ int __get_user_pages(struct task_struct
 
 			cond_resched();
 			while (!(page = follow_page(vma, start, foll_flags))) {
-				int ret;
+				int ret, write_access;
 
+				write_access = foll_flags & FOLL_WRITE;
+				trace_page_fault_get_user_entry(mm,
+					vma, start, write_access);
 				ret = handle_mm_fault(mm, vma, start,
-					(foll_flags & FOLL_WRITE) ?
+					write_access ?
 					FAULT_FLAG_WRITE : 0);
+				trace_page_fault_get_user_exit(ret);
 
 				if (ret & VM_FAULT_ERROR) {
 					if (ret & VM_FAULT_OOM)
--- /dev/null
+++ b/include/trace/fault.h
@@ -0,0 +1,27 @@
+#ifndef _TRACE_FAULT_H
+#define _TRACE_FAULT_H
+
+#include <linux/tracepoint.h>
+
+DECLARE_TRACE(page_fault_entry,
+	TP_PROTO(struct pt_regs *regs, int trapnr,
+			struct mm_struct *mm, struct vm_area_struct *vma,
+			unsigned long address, int write_access),
+		TP_ARGS(regs, trapnr, mm, vma, address, write_access));
+DECLARE_TRACE(page_fault_exit,
+	TP_PROTO(int res),
+		TP_ARGS(res));
+DECLARE_TRACE(page_fault_nosem_entry,
+	TP_PROTO(struct pt_regs *regs, int trapnr, unsigned long address),
+		TP_ARGS(regs, trapnr, address));
+DECLARE_TRACE(page_fault_nosem_exit,
+	TP_PROTO(void),
+		TP_ARGS());
+DECLARE_TRACE(page_fault_get_user_entry,
+	TP_PROTO(struct mm_struct *mm, struct vm_area_struct *vma,
+			unsigned long address, int write_access),
+		TP_ARGS(mm, vma, address, write_access));
+DECLARE_TRACE(page_fault_get_user_exit,
+	TP_PROTO(int res),
+		TP_ARGS(res));
+#endif
