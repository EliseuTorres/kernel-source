From: Ben Hutchings <bhutchings@solarflare.com>
Date: Fri, 27 Jul 2012 19:35:39 +0100
Subject: sfc: Hold the RTNL lock for more of the suspend/resume cycle
Patch-mainline: v3.7-rc1
Git-commit: 61da026d86517def727eb67d7cb8ee5657a12dd9
References: bnc#786035 FATE#314299

I don't think these PM functions can race with userland net device
operations, but it's much easier to reason about locking if state is
consistently guarded by the same lock.

Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ethernet/sfc/efx.c |    8 ++++++++
 1 file changed, 8 insertions(+)

--- a/drivers/net/ethernet/sfc/efx.c
+++ b/drivers/net/ethernet/sfc/efx.c
@@ -2723,6 +2723,8 @@ static int efx_pm_freeze(struct device *
 {
 	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
 
+	rtnl_lock();
+
 	efx->state = STATE_UNINIT;
 
 	netif_device_detach(efx->net_dev);
@@ -2730,6 +2732,8 @@ static int efx_pm_freeze(struct device *
 	efx_stop_all(efx);
 	efx_stop_interrupts(efx, false);
 
+	rtnl_unlock();
+
 	return 0;
 }
 
@@ -2737,6 +2741,8 @@ static int efx_pm_thaw(struct device *de
 {
 	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
 
+	rtnl_lock();
+
 	efx_start_interrupts(efx, false);
 
 	mutex_lock(&efx->mac_lock);
@@ -2751,6 +2757,8 @@ static int efx_pm_thaw(struct device *de
 
 	efx->type->resume_wol(efx);
 
+	rtnl_unlock();
+
 	/* Reschedule any quenched resets scheduled during efx_pm_freeze() */
 	queue_work(reset_workqueue, &efx->reset_work);
 
