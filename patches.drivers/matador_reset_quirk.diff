From: Oliver Neukum <oneukum@suse.de>
Subject:  Fix reset with Matador btusb devices
Patch-mainline: submitted for 2.6.37
References:  bnc#626171

This  fixes reset by
- introducing a large initial delay for quirky devices
- testing reset for success
- repeating reset after a small delay if it failed (up to 10 times)

Signed-off-by: Oliver Neukum <oneukum@suse.de>

--- linux/include/net/bluetooth/hci.h.alt	2010-09-02 10:37:47.000000000 +0200
+++ linux/include/net/bluetooth/hci.h	2010-09-02 10:38:29.000000000 +0200
@@ -56,7 +56,8 @@
 enum {
 	HCI_QUIRK_NO_RESET,
 	HCI_QUIRK_RAW_DEVICE,
-	HCI_QUIRK_FIXUP_BUFFER_SIZE
+	HCI_QUIRK_FIXUP_BUFFER_SIZE,
+	HCI_QUIRK_BAD_RESET
 };
 
 /* HCI device flags */
--- linux/net/bluetooth/hci_core.c.alt	2009-12-03 04:51:21.000000000 +0100
+++ linux/net/bluetooth/hci_core.c	2010-09-02 10:33:37.000000000 +0200
@@ -179,11 +179,18 @@ static void hci_reset_req(struct hci_dev
 	hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
 }
 
+static int verify_valid_bdaddr(struct hci_dev *hdev)
+{
+	return bacmp(&hdev->bdaddr, BDADDR_ANY);
+}
+
+#define RESET_RETRIES	10
 static void hci_init_req(struct hci_dev *hdev, unsigned long opt)
 {
 	struct sk_buff *skb;
 	__le16 param;
 	__u8 flt_type;
+	int retries = RESET_RETRIES;
 
 	BT_DBG("%s %ld", hdev->name, opt);
 
@@ -200,42 +207,51 @@ static void hci_init_req(struct hci_dev
 
 	/* Mandatory initialization */
 
-	/* Reset */
-	if (!test_bit(HCI_QUIRK_NO_RESET, &hdev->quirks))
-			hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
+	do {
+		if (retries < RESET_RETRIES)
+			mdelay(500);
+
+		/* Reset */
+		if (!test_bit(HCI_QUIRK_NO_RESET, &hdev->quirks))
+				hci_send_cmd(hdev, HCI_OP_RESET, 0, NULL);
 
-	/* Read Local Supported Features */
-	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_FEATURES, 0, NULL);
+		if (test_bit(HCI_QUIRK_BAD_RESET, &hdev->quirks) && retries == RESET_RETRIES)
+			mdelay(5000);
 
-	/* Read Local Version */
-	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL);
+		/* Read Local Supported Features */
+		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_FEATURES, 0, NULL);
 
-	/* Read Buffer Size (ACL mtu, max pkt, etc.) */
-	hci_send_cmd(hdev, HCI_OP_READ_BUFFER_SIZE, 0, NULL);
+		/* Read Local Version */
+		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL);
+
+		/* Read Buffer Size (ACL mtu, max pkt, etc.) */
+		hci_send_cmd(hdev, HCI_OP_READ_BUFFER_SIZE, 0, NULL);
 
 #if 0
-	/* Host buffer size */
-	{
-		struct hci_cp_host_buffer_size cp;
-		cp.acl_mtu = cpu_to_le16(HCI_MAX_ACL_SIZE);
-		cp.sco_mtu = HCI_MAX_SCO_SIZE;
-		cp.acl_max_pkt = cpu_to_le16(0xffff);
-		cp.sco_max_pkt = cpu_to_le16(0xffff);
-		hci_send_cmd(hdev, HCI_OP_HOST_BUFFER_SIZE, sizeof(cp), &cp);
-	}
+		/* Host buffer size */
+		{
+			struct hci_cp_host_buffer_size cp;
+			cp.acl_mtu = cpu_to_le16(HCI_MAX_ACL_SIZE);
+			cp.sco_mtu = HCI_MAX_SCO_SIZE;
+			cp.acl_max_pkt = cpu_to_le16(0xffff);
+			cp.sco_max_pkt = cpu_to_le16(0xffff);
+			hci_send_cmd(hdev, HCI_OP_HOST_BUFFER_SIZE, sizeof(cp), &cp);
+		}
 #endif
 
-	/* Read BD Address */
-	hci_send_cmd(hdev, HCI_OP_READ_BD_ADDR, 0, NULL);
+		/* Read BD Address */
+		hci_send_cmd(hdev, HCI_OP_READ_BD_ADDR, 0, NULL);			
+
+		/* Read Class of Device */
+		hci_send_cmd(hdev, HCI_OP_READ_CLASS_OF_DEV, 0, NULL);
 
-	/* Read Class of Device */
-	hci_send_cmd(hdev, HCI_OP_READ_CLASS_OF_DEV, 0, NULL);
+		/* Read Local Name */
+		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_NAME, 0, NULL);
 
-	/* Read Local Name */
-	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_NAME, 0, NULL);
+		/* Read Voice Setting */
+		hci_send_cmd(hdev, HCI_OP_READ_VOICE_SETTING, 0, NULL);
 
-	/* Read Voice Setting */
-	hci_send_cmd(hdev, HCI_OP_READ_VOICE_SETTING, 0, NULL);
+	} while(!verify_valid_bdaddr(hdev) && retries--);
 
 	/* Optional initialization */
 
--- linux/drivers/bluetooth/btusb.c.alt	2010-09-02 11:08:39.000000000 +0200
+++ linux/drivers/bluetooth/btusb.c	2010-09-02 11:57:00.000000000 +0200
@@ -54,6 +54,7 @@ static struct usb_driver btusb_driver;
 #define BTUSB_BCM92035		0x10
 #define BTUSB_BROKEN_ISOC	0x20
 #define BTUSB_WRONG_SCO_MTU	0x40
+#define BTUSB_BAD_RESET		0x80
 
 static struct usb_device_id btusb_table[] = {
 	/* Generic Bluetooth USB device */
@@ -103,6 +104,9 @@ static struct usb_device_id blacklist_ta
 	{ USB_DEVICE(0x0a5c, 0x201e), .driver_info = BTUSB_WRONG_SCO_MTU },
 	{ USB_DEVICE(0x0a5c, 0x2110), .driver_info = BTUSB_WRONG_SCO_MTU },
 
+	/* Broadcom Matador */
+	{ USB_DEVICE(0x0a5c, 0x21b4), .driver_info = BTUSB_BAD_RESET },
+
 	/* HP laptop with Broadcom chip */
 	{ USB_DEVICE(0x03f0, 0x171d), .driver_info = BTUSB_WRONG_SCO_MTU },
 
@@ -1006,6 +1010,9 @@ static int btusb_probe(struct usb_interf
 		}
 	}
 
+	if (id->driver_info & BTUSB_BAD_RESET)
+		set_bit(HCI_QUIRK_BAD_RESET, &hdev->quirks);
+
 	if (data->isoc) {
 		err = usb_driver_claim_interface(&btusb_driver,
 							data->isoc, data);
