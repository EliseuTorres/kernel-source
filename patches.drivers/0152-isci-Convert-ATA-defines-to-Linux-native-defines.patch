From: Dave Jiang <dave.jiang@intel.com>
Date: Wed, 4 May 2011 15:02:03 -0700
Subject: [PATCH 152/273] isci: Convert ATA defines to Linux native defines
Git-commit: e76d6180da436edf2cc3538cbed1f5b02b614613
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

* Removing all intel_sata and intel_ata defines
* Removing the usage of SAT_PROTOCOL_*. We can get everything from sas_task
* Moved SATA FIS types to local sas.h. These defines will have to go
  into include/scsi/sas.h eventually.
* Added offsets for SATA FIS header in order to grab the values

Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/core/intel_ata.h            |  554 -------------------------
 drivers/scsi/isci/core/intel_sas.h            |    3 +-
 drivers/scsi/isci/core/intel_sat.h            |   95 -----
 drivers/scsi/isci/core/intel_sata.h           |  224 ----------
 drivers/scsi/isci/core/scic_phy.h             |    1 -
 drivers/scsi/isci/core/scic_sds_phy.c         |   23 +-
 drivers/scsi/isci/core/scic_sds_phy.h         |    1 -
 drivers/scsi/isci/core/scic_sds_request.c     |  131 +++---
 drivers/scsi/isci/core/scic_sds_stp_request.c |  366 ++++++++---------
 drivers/scsi/isci/core/scic_sds_stp_request.h |    8 +-
 drivers/scsi/isci/remote_device.c             |   23 +-
 drivers/scsi/isci/sas.h                       |   72 ++++
 drivers/scsi/isci/sata.c                      |   75 +----
 drivers/scsi/isci/sata.h                      |    4 -
 14 files changed, 340 insertions(+), 1240 deletions(-)
 delete mode 100644 drivers/scsi/isci/core/intel_ata.h
 delete mode 100644 drivers/scsi/isci/core/intel_sat.h
 delete mode 100644 drivers/scsi/isci/core/intel_sata.h
 create mode 100644 drivers/scsi/isci/sas.h

diff --git a/drivers/scsi/isci/core/intel_ata.h b/drivers/scsi/isci/core/intel_ata.h
deleted file mode 100644
index 48b297e..0000000
--- a/drivers/scsi/isci/core/intel_ata.h
+++ /dev/null
@@ -1,554 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * This file defines all of the ATA related constants, enumerations, and types.
- *     Please note that this file does not necessarily contain an exhaustive
- *    list of all constants, commands, sub-commands, etc.
- *
- *
- */
-
-#ifndef _ATA_H_
-#define _ATA_H_
-
-#include <linux/types.h>
-
-/**
- *
- *
- * ATA_COMMAND_CODES These constants depict the various ATA command codes
- * defined in the ATA/ATAPI specification.
- */
-#define ATA_IDENTIFY_DEVICE         0xEC
-#define ATA_CHECK_POWER_MODE        0xE5
-#define ATA_STANDBY                 0xE2
-#define ATA_STANDBY_IMMED           0xE0
-#define ATA_IDLE_IMMED              0xE1
-#define ATA_IDLE                    0xE3
-#define ATA_FLUSH_CACHE             0xE7
-#define ATA_FLUSH_CACHE_EXT         0xEA
-#define ATA_READ_DMA_EXT            0x25
-#define ATA_READ_DMA                0xC8
-#define ATA_READ_SECTORS_EXT        0x24
-#define ATA_READ_SECTORS            0x20
-#define ATA_WRITE_DMA_EXT           0x35
-#define ATA_WRITE_DMA               0xCA
-#define ATA_WRITE_SECTORS_EXT       0x34
-#define ATA_WRITE_SECTORS           0x30
-#define ATA_WRITE_UNCORRECTABLE     0x45
-#define ATA_READ_VERIFY_SECTORS     0x40
-#define ATA_READ_VERIFY_SECTORS_EXT 0x42
-#define ATA_READ_BUFFER             0xE4
-#define ATA_WRITE_BUFFER            0xE8
-#define ATA_EXECUTE_DEVICE_DIAG     0x90
-#define ATA_SET_FEATURES            0xEF
-#define ATA_SMART                   0xB0
-#define ATA_PACKET_IDENTIFY         0xA1
-#define ATA_PACKET                  0xA0
-#define ATA_READ_FPDMA              0x60
-#define ATA_WRITE_FPDMA             0x61
-#define ATA_READ_LOG_EXT            0x2F
-#define ATA_NOP                     0x00
-#define ATA_DEVICE_RESET            0x08
-#define ATA_MEDIA_EJECT             0xED
-
-/**
- *
- *
- * ATA_SMART_SUB_COMMAND_CODES These constants define the ATA SMART command
- * sub-codes that can be executed.
- */
-#define ATA_SMART_SUB_CMD_ENABLE        0xD8
-#define ATA_SMART_SUB_CMD_DISABLE       0xD9
-#define ATA_SMART_SUB_CMD_RETURN_STATUS 0xDA
-#define ATA_SMART_SUB_CMD_READ_LOG      0xD5
-
-/**
- *
- *
- * ATA_SET_FEATURES_SUB_COMMAND_CODES These constants define the ATA SET
- * FEATURES command sub-codes that can be executed.
- */
-#define ATA_SET_FEATURES_SUB_CMD_ENABLE_CACHE       0x02
-#define ATA_SET_FEATURES_SUB_CMD_DISABLE_CACHE      0x82
-#define ATA_SET_FEATURES_SUB_CMD_DISABLE_READ_AHEAD 0x55
-#define ATA_SET_FEATURES_SUB_CMD_ENABLE_READ_AHEAD  0xAA
-#define ATA_SET_FEATURES_SUB_CMD_SET_TRANSFER_MODE  0x3
-
-/**
- *
- *
- * ATA_READ_LOG_EXT_PAGE_CODES This is a list of log page codes available for
- * use.
- */
-#define ATA_LOG_PAGE_NCQ_ERROR                  0x10
-#define ATA_LOG_PAGE_SMART_SELF_TEST            0x06
-#define ATA_LOG_PAGE_EXTENDED_SMART_SELF_TEST   0x07
-
-/**
- *
- *
- * ATA_LOG_PAGE_NCQ_ERROR_CONSTANTS These constants define standard values for
- * use when requesting the NCQ error log page.
- */
-#define ATA_LOG_PAGE_NCQ_ERROR_SECTOR        0
-#define ATA_LOG_PAGE_NCQ_ERROR_SECTOR_COUNT  1
-
-/**
- *
- *
- * ATA_STATUS_REGISTER_BITS The following are status register bit definitions
- * per ATA/ATAPI-7.
- */
-#define ATA_STATUS_REG_BSY_BIT          0x80
-#define ATA_STATUS_REG_DEVICE_FAULT_BIT 0x20
-#define ATA_STATUS_REG_ERROR_BIT        0x01
-
-/**
- *
- *
- * ATA_ERROR_REGISTER_BITS The following are error register bit definitions per
- * ATA/ATAPI-7.
- */
-#define ATA_ERROR_REG_NO_MEDIA_BIT              0x02
-#define ATA_ERROR_REG_ABORT_BIT                 0x04
-#define ATA_ERROR_REG_MEDIA_CHANGE_REQUEST_BIT  0x08
-#define ATA_ERROR_REG_ID_NOT_FOUND_BIT          0x10
-#define ATA_ERROR_REG_MEDIA_CHANGE_BIT          0x20
-#define ATA_ERROR_REG_UNCORRECTABLE_BIT         0x40
-#define ATA_ERROR_REG_WRITE_PROTECTED_BIT       0x40
-#define ATA_ERROR_REG_ICRC_BIT                  0x80
-
-/**
- *
- *
- * ATA_CONTROL_REGISTER_BITS The following are control register bit definitions
- * per ATA/ATAPI-7
- */
-#define ATA_CONTROL_REG_INTERRUPT_ENABLE_BIT 0x02
-#define ATA_CONTROL_REG_SOFT_RESET_BIT       0x04
-#define ATA_CONTROL_REG_HIGH_ORDER_BYTE_BIT  0x80
-
-/**
- *
- *
- * ATA_DEVICE_HEAD_REGISTER_BITS The following are device/head register bit
- * definitions per ATA/ATAPI-7.
- */
-#define ATA_DEV_HEAD_REG_LBA_MODE_ENABLE  0x40
-#define ATA_DEV_HEAD_REG_FUA_ENABLE       0x80
-
-/**
- *
- *
- * ATA_IDENTIFY_DEVICE_FIELD_LENGTHS The following constants define the number
- * of bytes contained in various fields found in the IDENTIFY DEVICE data
- * structure.
- */
-#define ATA_IDENTIFY_SERIAL_NUMBER_LEN        20
-#define ATA_IDENTIFY_MODEL_NUMBER_LEN         40
-#define ATA_IDENTIFY_FW_REVISION_LEN          8
-#define ATA_IDENTIFY_48_LBA_LEN               8
-#define ATA_IDENTIFY_MEDIA_SERIAL_NUMBER_LEN  30
-#define ATA_IDENTIFY_WWN_LEN                  8
-
-/**
- *
- *
- * ATA_IDENTIFY_DEVICE_FIELD_MASKS The following constants define bit masks
- * utilized to determine if a feature is supported/enabled or if a bit is
- * simply set inside of the IDENTIFY DEVICE data structre.
- */
-#define ATA_IDENTIFY_REMOVABLE_MEDIA_ENABLE              0x0080
-#define ATA_IDENTIFY_CAPABILITIES1_NORMAL_DMA_ENABLE     0x0100
-#define ATA_IDENTIFY_CAPABILITIES1_STANDBY_ENABLE        0x2000
-#define ATA_IDENTIFY_COMMAND_SET_SUPPORTED0_SMART_ENABLE 0x0001
-#define ATA_IDENTIFY_COMMAND_SET_SUPPORTED1_48BIT_ENABLE 0x0400
-#define ATA_IDENTIFY_COMMAND_SET_WWN_SUPPORT_ENABLE      0x0100
-#define ATA_IDENTIFY_COMMAND_SET_ENABLED0_SMART_ENABLE   0x0001
-#define ATA_IDENTIFY_SATA_CAPABILITIES_NCQ_ENABLE        0x0100
-#define ATA_IDENTIFY_NCQ_QUEUE_DEPTH_ENABLE              0x001F
-#define ATA_IDENTIFY_SECTOR_LARGER_THEN_512_ENABLE       0x0100
-#define ATA_IDENTIFY_LOGICAL_SECTOR_PER_PHYSICAL_SECTOR_MASK   0x000F
-#define ATA_IDENTIFY_LOGICAL_SECTOR_PER_PHYSICAL_SECTOR_ENABLE 0x2000
-#define ATA_IDENTIFY_WRITE_UNCORRECTABLE_SUPPORT         0x0004
-#define ATA_IDENTIFY_COMMAND_SET_SMART_SELF_TEST_SUPPORTED     0x0002
-
-/**
- *
- *
- * ATAPI_IDENTIFY_DEVICE_FIELD_MASKS These constants define the various bit
- * definitions for the fields in the PACKET IDENTIFY DEVICE data structure.
- */
-#define ATAPI_IDENTIFY_16BYTE_CMD_PCKT_ENABLE       0x01
-
-/**
- *
- *
- * ATA_PACKET_FEATURE_BITS These constants define the various bit definitions
- * for the ATA PACKET feature register.
- */
-#define ATA_PACKET_FEATURE_DMA     0x01
-#define ATA_PACKET_FEATURE_OVL     0x02
-#define ATA_PACKET_FEATURE_DMADIR  0x04
-
-/**
- *
- *
- * ATA_Device_Power_Mode_Values These constants define the power mode values
- * returned by ATA_Check_Power_Mode
- */
-#define ATA_STANDBY_POWER_MODE    0x00
-#define ATA_IDLE_POWER_MODE       0x80
-#define ATA_ACTIVE_POWER_MODE     0xFF
-
-/**
- *
- *
- * ATA_WRITE_UNCORRECTIABLE feature field values These constants define the
- * Write Uncorrectable feature values used with the SATI translation.
- */
-#define ATA_WRITE_UNCORRECTABLE_PSUEDO    0x55
-#define ATA_WRITE_UNCORRECTABLE_FLAGGED   0xAA
-
-
-
-/**
- * struct ATA_IDENTIFY_DEVICE - This structure depicts the ATA IDENTIFY DEVICE
- *    data format.
- *
- *
- */
-struct ata_identify_device_data {
-	u16 general_config_bits;                                                /* word  00 */
-	u16 obsolete0;                                                          /* word  01 (num cylinders) */
-	u16 vendor_specific_config_bits;                                        /* word  02 */
-	u16 obsolete1;                                                          /* word  03 (num heads) */
-	u16 retired1[2];                                                        /* words 04-05 */
-	u16 obsolete2;                                                          /* word  06 (sectors / track) */
-	u16 reserved_for_compact_flash1[2];                                     /* words 07-08 */
-	u16 retired0;                                                           /* word  09 */
-	u8 serial_number[ATA_IDENTIFY_SERIAL_NUMBER_LEN];                       /* word 10-19 */
-	u16 retired2[2];                                                        /* words 20-21 */
-	u16 obsolete4;                                                          /* word  22 */
-	u8 firmware_revision[ATA_IDENTIFY_FW_REVISION_LEN];                     /* words 23-26 */
-	u8 model_number[ATA_IDENTIFY_MODEL_NUMBER_LEN];                         /* words 27-46 */
-	u16 max_sectors_per_multiple;                                           /* word  47 */
-	u16 reserved0;                                                          /* word  48 */
-	u16 capabilities1;                                                      /* word  49 */
-	u16 capabilities2;                                                      /* word  50 */
-	u16 obsolete5[2];                                                       /* words 51-52 */
-	u16 validity_bits;                                                      /* word  53 */
-	u16 obsolete6[5];                                                       /*
-										 * words 54-58 Used to be:
-										 * current cylinders,
-										 * current heads,
-										 * current sectors/Track,
-										 * current capacity */
-	u16 current_max_sectors_per_multiple;                                   /* word  59 */
-	u8 total_num_sectors[4];                                                /* words 60-61 */
-	u16 obsolete7;                                                          /* word  62 */
-	u16 multi_word_dma_mode;                                                /* word  63 */
-	u16 pio_modes_supported;                                                /* word  64 */
-	u16 min_multiword_dma_transfer_cycle;                                   /* word  65 */
-	u16 rec_min_multiword_dma_transfer_cycle;                               /* word  66 */
-	u16 min_pio_transfer_no_flow_ctrl;                                      /* word  67 */
-	u16 min_pio_transfer_with_flow_ctrl;                                    /* word  68 */
-	u16 reserved1[2];                                                       /* words 69-70 */
-	u16 reserved2[4];                                                       /* words 71-74 */
-	u16 queue_depth;                                                        /* word  75 */
-	u16 serial_ata_capabilities;                                            /* word  76 */
-	u16 serial_ata_reserved;                                                /* word  77 */
-	u16 serial_ata_features_supported;                                      /* word  78 */
-	u16 serial_ata_features_enabled;                                        /* word  79 */
-	u16 major_version_number;                                               /* word  80 */
-	u16 minor_version_number;                                               /* word  81 */
-	u16 command_set_supported0;                                             /* word  82 */
-	u16 command_set_supported1;                                             /* word  83 */
-	u16 command_set_supported_extention;                                    /* word  84 */
-	u16 command_set_enabled0;                                               /* word  85 */
-	u16 command_set_enabled1;                                               /* word  86 */
-	u16 command_set_default;                                                /* word  87 */
-	u16 ultra_dma_mode;                                                     /* word  88 */
-	u16 security_erase_completion_time;                                     /* word  89 */
-	u16 enhanced_security_erase_time;                                       /* word  90 */
-	u16 current_power_mgmt_value;                                           /* word  91 */
-	u16 master_password_revision;                                           /* word  92 */
-	u16 hardware_reset_result;                                              /* word  93 */
-	u16 current_acoustic_management_value;                                  /* word  94 */
-	u16 stream_min_request_size;                                            /* word  95 */
-	u16 stream_transfer_time;                                               /* word  96 */
-	u16 stream_access_latency;                                              /* word  97 */
-	u16 stream_performance_granularity[2];                                  /* words 98-99 */
-	u8 max_48bit_lba[ATA_IDENTIFY_48_LBA_LEN];                              /* words 100-103 */
-	u16 streaming_transfer_time;                                            /* word  104 */
-	u16 reserved3;                                                          /* word  105 */
-	u16 physical_logical_sector_info;                                       /* word  106 */
-	u16 acoustic_test_interseek_delay;                                      /* word  107 */
-	u8 world_wide_name[ATA_IDENTIFY_WWN_LEN];                               /* words 108-111 */
-	u8 reserved_for_wwn_extention[ATA_IDENTIFY_WWN_LEN];                    /* words 112-115 */
-	u16 reserved4;                                                          /* word  116 */
-	u8 words_per_logical_sector[4];                                         /* words 117-118 */
-	u16 command_set_supported2;                                             /* word  119 */
-	u16 reserved5[7];                                                       /* words 120-126 */
-	u16 removable_media_status;                                             /* word  127 */
-	u16 security_status;                                                    /* word  128 */
-	u16 vendor_specific1[31];                                               /* words 129-159 */
-	u16 cfa_power_mode1;                                                    /* word  160 */
-	u16 reserved_for_compact_flash2[7];                                     /* words 161-167 */
-	u16 device_nominal_form_factor;                                         /* word 168 */
-	u16 reserved_for_compact_flash3[7];                                     /* words 169-175 */
-	u16 current_media_serial_number[ATA_IDENTIFY_MEDIA_SERIAL_NUMBER_LEN];  /* words 176-205 */
-	u16 reserved6[3];                                                       /* words 206-208 */
-	u16 logical_sector_alignment;                                           /* words 209 */
-	u16 reserved7[7];                                                       /* words 210-216 */
-	u16 nominal_media_rotation_rate;                                        /* word 217 */
-	u16 reserved8[37];                                                      /* words 218-254 */
-	u16 integrity_word;                                                     /* word  255 */
-
-};
-
-#define ATA_IDENTIFY_DEVICE_GET_OFFSET(field_name) \
-	((unsigned long)&(((struct ata_identify_device_data *)0)->field_name))
-#define ATA_IDENTIFY_DEVICE_WCE_ENABLE  0x20
-#define ATA_IDENTIFY_DEVICE_RA_ENABLE   0x40
-
-/**
- * struct ATAPI_IDENTIFY_PACKET_DATA - The following structure depicts the
- *    ATA-ATAPI 7 version of the IDENTIFY PACKET DEVICE data structure.
- *
- *
- */
-struct atapi_identify_packet_device {
-	u16 generalConfigBits;                                  /* word  00 */
-	u16 reserved0;                                          /* word  01 (num cylinders) */
-	u16 uniqueConfigBits;                                   /* word  02 */
-	u16 reserved1[7];                                       /* words 03 - 09 */
-	u8 serialNumber[ATA_IDENTIFY_SERIAL_NUMBER_LEN];        /* word 10-19 */
-	u16 reserved2[3];                                       /* words 20-22 */
-	u8 firmwareRevision[ATA_IDENTIFY_FW_REVISION_LEN];      /* words 23-26 */
-	u8 modelNumber[ATA_IDENTIFY_MODEL_NUMBER_LEN];          /* words 27-46 */
-	u16 reserved4[2];                                       /* words 47-48 */
-	u16 capabilities1;                                      /* word  49 */
-	u16 capabilities2;                                      /* word  50 */
-	u16 obsolete0[2];                                       /* words 51-52 */
-	u16 validityBits;                                       /* word  53 */
-	u16 reserved[8];                                        /* words 54-61 */
-
-	u16 DMADIRBitRequired;                                  /* word  62, page2 */
-	u16 multiWordDmaMode;                                   /* word  63 */
-	u16 pioModesSupported;                                  /* word  64 */
-	u16 minMultiwordDmaTransferCycle;                       /* word  65 */
-	u16 recMinMultiwordDmaTransferCycle;                    /* word  66 */
-	u16 minPioTransferNoFlowCtrl;                           /* word  67 */
-	u16 minPioTransferWithFlowCtrl;                         /* word  68 */
-	u16 reserved6[2];                                       /* words 69-70 */
-	u16 nsFromPACKETReceiptToBusRelease;                    /* word  71 */
-	u16 nsFromSERVICEReceiptToBSYreset;                     /* wore  72 */
-	u16 reserved7[2];                                       /* words 73-74 */
-	u16 queueDepth;                                         /* word  75 */
-	u16 serialAtaCapabilities;                              /* word  76 */
-	u16 serialAtaReserved;                                  /* word  77 */
-	u16 serialAtaFeaturesSupported;                         /* word  78 */
-	u16 serialAtaFeaturesEnabled;                           /* word  79 */
-
-	u16 majorVersionNumber;                                 /* word  80, page3 */
-	u16 minorVersionNumber;                                 /* word  81 */
-	u16 commandSetSupported0;                               /* word  82 */
-	u16 commandSetSupported1;                               /* word  83 */
-
-	u16 commandSetSupportedExtention;                       /* word  84, page4 */
-	u16 commandSetEnabled0;                                 /* word  85 */
-	u16 commandSetEnabled1;                                 /* word  86 */
-	u16 commandSetDefault;                                  /* word  87 */
-
-	u16 ultraDmaMode;                                       /* word  88, page5 */
-	u16 reserved8[4];                                       /* words 89 - 92 */
-
-	u16 hardwareResetResult;                                /* word  93, page6 */
-	u16 currentAcousticManagementValue;                     /* word  94 */
-	u16 reserved9[30];                                      /* words 95-124 */
-	u16 ATAPIByteCount0Behavior;                            /* word  125 */
-	u16 obsolete1;                                          /* word  126 */
-	u16 removableMediaStatus;                               /* word  127, */
-
-	u16 securityStatus;                                     /* word  128, page7 */
-	u16 vendorSpecific1[31];                                /* words 129-159 */
-	u16 reservedForCompactFlash[16];                        /* words 160-175 */
-	u16 reserved10[79];                                     /* words 176-254 */
-	u16 integrityWord;                                      /* word  255 */
-};
-
-/**
- * struct ata_extended_smart_self_test_log - The following structure depicts
- *    the ATA-8 version of the Extended SMART self test log page descriptor
- *    entry.
- *
- *
- */
-union ata_descriptor_entry {
-	struct DESCRIPTOR_ENTRY {
-		u8 lba_field;
-		u8 status_byte;
-		u8 time_stamp_low;
-		u8 time_stamp_high;
-		u8 checkpoint_byte;
-		u8 failing_lba_low;
-		u8 failing_lba_mid;
-		u8 failing_lba_high;
-		u8 failing_lba_low_ext;
-		u8 failing_lba_mid_ext;
-		u8 failing_lba_high_ext;
-
-		u8 vendor_specific1;
-		u8 vendor_specific2;
-		u8 vendor_specific3;
-		u8 vendor_specific4;
-		u8 vendor_specific5;
-		u8 vendor_specific6;
-		u8 vendor_specific7;
-		u8 vendor_specific8;
-		u8 vendor_specific9;
-		u8 vendor_specific10;
-		u8 vendor_specific11;
-		u8 vendor_specific12;
-		u8 vendor_specific13;
-		u8 vendor_specific14;
-		u8 vendor_specific15;
-	} DESCRIPTOR_ENTRY;
-
-	u8 descriptor_entry[26];
-
-};
-
-/**
- * struct ata_extended_smart_self_test_log - The following structure depicts
- *    the ATA-8 version of the SMART self test log page descriptor entry.
- *
- *
- */
-union ata_smart_descriptor_entry {
-	struct SMART_DESCRIPTOR_ENTRY {
-		u8 lba_field;
-		u8 status_byte;
-		u8 time_stamp_low;
-		u8 time_stamp_high;
-		u8 checkpoint_byte;
-		u8 failing_lba_low;
-		u8 failing_lba_mid;
-		u8 failing_lba_high;
-		u8 failing_lba_low_ext;
-
-		u8 vendor_specific1;
-		u8 vendor_specific2;
-		u8 vendor_specific3;
-		u8 vendor_specific4;
-		u8 vendor_specific5;
-		u8 vendor_specific6;
-		u8 vendor_specific7;
-		u8 vendor_specific8;
-		u8 vendor_specific9;
-		u8 vendor_specific10;
-		u8 vendor_specific11;
-		u8 vendor_specific12;
-		u8 vendor_specific13;
-		u8 vendor_specific14;
-		u8 vendor_specific15;
-	} SMART_DESCRIPTOR_ENTRY;
-
-	u8 smart_descriptor_entry[24];
-
-};
-
-/**
- * struct ata_extended_smart_self_test_log - The following structure depicts
- *    the ATA-8 version of the Extended SMART self test log page.
- *
- *
- */
-struct ata_extended_smart_self_test_log {
-	u8 self_test_log_data_structure_revision_number;        /* byte 0 */
-	u8 reserved0;                                           /* byte 1 */
-	u8 self_test_descriptor_index[2];                       /* byte 2-3 */
-
-	union ata_descriptor_entry descriptor_entrys[19];           /* bytes 4-497 */
-
-	u8 vendor_specific[2];                                  /* byte 498-499 */
-	u8 reserved1[11];                                       /* byte 500-510 */
-	u8 data_structure_checksum;                             /* byte 511 */
-
-};
-
-/**
- * struct ata_extended_smart_self_test_log - The following structure depicts
- *    the ATA-8 version of the SMART self test log page.
- *
- *
- */
-struct ata_smart_self_test_log {
-	u8 self_test_log_data_structure_revision_number[2];     /* bytes 0-1 */
-
-	union ata_smart_descriptor_entry descriptor_entrys[21];     /* bytes 2-505 */
-
-	u8 vendor_specific[2];                                  /* byte 506-507 */
-	u8 self_test_index;                                     /* byte 508 */
-	u8 reserved1[2];                                        /* byte 509-510 */
-	u8 data_structure_checksum;                             /* byte 511 */
-
-};
-
-#endif /* _ATA_H_ */
-
diff --git a/drivers/scsi/isci/core/intel_sas.h b/drivers/scsi/isci/core/intel_sas.h
index c12e6d4..119eb5b 100644
--- a/drivers/scsi/isci/core/intel_sas.h
+++ b/drivers/scsi/isci/core/intel_sas.h
@@ -62,8 +62,7 @@
  *
  *
  */
-
-#include "intel_sata.h"
+#include <linux/kernel.h>
 #include "intel_scsi.h"
 
 /**
diff --git a/drivers/scsi/isci/core/intel_sat.h b/drivers/scsi/isci/core/intel_sat.h
deleted file mode 100644
index c4d78ed..0000000
--- a/drivers/scsi/isci/core/intel_sat.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SAT_H_
-#define _SAT_H_
-
-/**
- * This file contains constants and constructs defined in the SCSI to ATA
- *    Translation (SAT) T10 standard.  For more information please refer to
- *    www.t10.org.
- *
- *
- */
-
-/**
- *
- *
- * SAT_PROTOCOLS These constants indicate the various protocol values that can
- * be supported in a SAT translator.
- */
-#define SAT_PROTOCOL_ATA_HARD_RESET       0
-#define SAT_PROTOCOL_SOFT_RESET           1
-#define SAT_PROTOCOL_NON_DATA             3
-#define SAT_PROTOCOL_PIO_DATA_IN          4
-#define SAT_PROTOCOL_PIO_DATA_OUT         5
-#define SAT_PROTOCOL_DMA                  6
-#define SAT_PROTOCOL_DMA_QUEUED           7
-#define SAT_PROTOCOL_DEVICE_DIAGNOSTIC    8
-#define SAT_PROTOCOL_DEVICE_RESET         9
-#define SAT_PROTOCOL_UDMA_DATA_IN         10
-#define SAT_PROTOCOL_UDMA_DATA_OUT        11
-#define SAT_PROTOCOL_FPDMA                12
-#define SAT_PROTOCOL_RETURN_RESPONSE_INFO 15
-
-#define SAT_PROTOCOL_PACKET               0x10
-#define SAT_PROTOCOL_PACKET_NON_DATA      (SAT_PROTOCOL_PACKET | 0x0)
-#define SAT_PROTOCOL_PACKET_DMA_DATA_IN   (SAT_PROTOCOL_PACKET | 0x1)
-#define SAT_PROTOCOL_PACKET_DMA_DATA_OUT  (SAT_PROTOCOL_PACKET | 0x2)
-#define SAT_PROTOCOL_PACKET_PIO_DATA_IN   (SAT_PROTOCOL_PACKET | 0x3)
-#define SAT_PROTOCOL_PACKET_PIO_DATA_OUT  (SAT_PROTOCOL_PACKET | 0x4)
-
-#endif /* _SAT_H_ */
-
diff --git a/drivers/scsi/isci/core/intel_sata.h b/drivers/scsi/isci/core/intel_sata.h
deleted file mode 100644
index 977354d..0000000
--- a/drivers/scsi/isci/core/intel_sata.h
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SATA_H_
-#define _SATA_H_
-
-#include <linux/types.h>
-
-/**
- * This file defines all of the SATA releated constants, enumerations, and
- *    types. Please note that this file does not necessarily contain an
- *    exhaustive list of all contants and commands.
- *
- *
- */
-
-/**
- *
- *
- * SATA FIS Types These constants depict the various SATA FIS types devined in
- * the serial ATA specification.
- */
-#define SATA_FIS_TYPE_REGH2D          0x27
-#define SATA_FIS_TYPE_REGD2H          0x34
-#define SATA_FIS_TYPE_SETDEVBITS      0xA1
-#define SATA_FIS_TYPE_DMA_ACTIVATE    0x39
-#define SATA_FIS_TYPE_DMA_SETUP       0x41
-#define SATA_FIS_TYPE_BIST_ACTIVATE   0x58
-#define SATA_FIS_TYPE_PIO_SETUP       0x5F
-#define SATA_FIS_TYPE_DATA            0x46
-
-#define SATA_REGISTER_FIS_SIZE 0x20
-
-/**
- * struct sata_fis_header - This is the common definition for a SATA FIS Header
- *    word.  A different header word is defined for any FIS type that does not
- *    use the standard header.
- *
- *
- */
-struct sata_fis_header {
-	u32 fis_type:8; /* word 0 */
-	u32 pm_port:4;
-	u32 reserved:1;
-	u32 direction_flag:1;       /* direction */
-	u32 interrupt_flag:1;
-	u32 command_flag:1;       /* command, auto_activate, or notification */
-	u32 status:8;
-	u32 error:8;
-};
-
-/**
- *
- *
- * Status field bit definitions
- */
-#define SATA_FIS_STATUS_DEVBITS_MASK  (0x77)
-
-/**
- * struct sata_fis_set_dev_bits - SATA Set Device Bits FIS
- *
- *
- */
-struct sata_fis_set_dev_bits {
-	u32 fis_type:8; /* word 0 */
-	u32 pm_port:4;
-	u32 reserved0:2;
-	u32 irq:1;
-	u32 notification:1;
-	u32 status_low:4;
-	u32 status_high:4;
-	u32 error:8;
-	u32 s_active;      /* word 1 */
-};
-
-/**
- * struct sata_fis_dma_activate - SATA DMA Activate FIS
- *
- *
- */
-struct sata_fis_dma_activate {
-	u32 fis_type:8; /* word 0 */
-	u32 pm_port:4;
-	u32 reserved0:24;
-};
-
-/**
- *
- *
- * The lower 5 bits in the DMA Buffer ID Low field of the DMA Setup are used to
- * communicate the command tag.
- */
-#define SATA_DMA_SETUP_TAG_ENABLE      0x1F
-
-#define SATA_DMA_SETUP_AUTO_ACT_ENABLE 0x80
-
-/**
- * struct sata_fis_dma_setup - SATA DMA Setup FIS
- *
- *
- */
-struct sata_fis_dma_setup {
-	u32 fis_type:8; /* word 0 */
-	u32 pm_port:4;
-	u32 reserved_00:1;
-	u32 direction:1;
-	u32 irq:1;
-	u32 auto_activate:1;
-	u32 reserved_01:16;
-	u32 dma_buffer_id_low;          /* word 1 */
-	u32 dma_buffer_id_high;         /* word 2 */
-	u32 reserved0;                  /* word 3 */
-	u32 dma_buffer_offset;          /* word 4 */
-	u32 dma_transfer_count;         /* word 5 */
-	u32 reserved1;                  /* word 6 */
-};
-
-/**
- * struct sata_fis_bist_activate - SATA BIST Activate FIS
- *
- *
- */
-struct sata_fis_bist_activate {
-	u32 fis_type:8; /* word 0 */
-	u32 reserved0:8;
-	u32 pattern_definition:8;
-	u32 reserved1:8;
-	u32 data1;                      /* word 1 */
-	u32 data2;                      /* word 1 */
-};
-
-/*
- *  SATA PIO Setup FIS
- */
-struct sata_fis_pio_setup {
-	u32 fis_type:8; /* word 0 */
-	u32 pm_port:4;
-	u32 reserved_00:1;
-	u32 direction:1;
-	u32 irq:1;
-	u32 reserved_01:1;
-	u32 status:8;
-	u32 error:8;
-	u32 lba_low:8; /* word 1 */
-	u32 lba_mid:8;
-	u32 lba_high:8;
-	u32 device:8;
-	u32 lba_low_exp:8; /* word 2 */
-	u32 lba_mid_exp:8;
-	u32 lba_high_exp:8;
-	u32 reserved:8;
-	u32 sector_count:8; /* word 3 */
-	u32 sector_count_exp:8;
-	u32 reserved1:8;
-	u32 ending_status:8;
-	u32 transfter_count:16; /* word 4 */
-	u32 reserved3:16;
-};
-
-/**
- * struct sata_fis_data - SATA Data FIS
- *
- *
- */
-struct sata_fis_data {
-	u32 fis_type:8; /* word 0 */
-	u32 pm_port:4;
-	u32 reserved0:24;
-	u8 data[4];        /* word 1 */
-};
-
-#endif /* _SATA_H_ */
diff --git a/drivers/scsi/isci/core/scic_phy.h b/drivers/scsi/isci/core/scic_phy.h
index 6fe39cc..d8c4bf1 100644
--- a/drivers/scsi/isci/core/scic_phy.h
+++ b/drivers/scsi/isci/core/scic_phy.h
@@ -67,7 +67,6 @@
 #include <scsi/sas.h>
 #include <scsi/libsas.h>
 #include "sci_status.h"
-#include "intel_sata.h"
 #include "intel_sas.h"
 
 struct scic_sds_phy;
diff --git a/drivers/scsi/isci/core/scic_sds_phy.c b/drivers/scsi/isci/core/scic_sds_phy.c
index 1b35b1a..0f292f1 100644
--- a/drivers/scsi/isci/core/scic_sds_phy.c
+++ b/drivers/scsi/isci/core/scic_sds_phy.c
@@ -54,8 +54,7 @@
  */
 
 #include <scsi/sas.h>
-#include "intel_ata.h"
-#include "intel_sata.h"
+#include "sas.h"
 #include "sci_base_state.h"
 #include "sci_base_state_machine.h"
 #include "scic_phy.h"
@@ -1279,23 +1278,19 @@ static enum sci_status scic_sds_phy_starting_substate_await_sig_fis_frame_handle
 	u32 frame_index)
 {
 	enum sci_status result;
-	u32 *frame_words;
-	struct sata_fis_header *fis_frame_header;
+	struct dev_to_host_fis *frame_header;
 	u32 *fis_frame_data;
 
 	result = scic_sds_unsolicited_frame_control_get_header(
 		&(scic_sds_phy_get_controller(sci_phy)->uf_control),
 		frame_index,
-		(void **)&frame_words);
+		(void **)&frame_header);
 
-	if (result != SCI_SUCCESS) {
+	if (result != SCI_SUCCESS)
 		return result;
-	}
-
-	fis_frame_header = (struct sata_fis_header *)frame_words;
 
-	if ((fis_frame_header->fis_type == SATA_FIS_TYPE_REGD2H) &&
-	    !(fis_frame_header->status & ATA_STATUS_REG_BSY_BIT)) {
+	if ((frame_header->fis_type == FIS_REGD2H) &&
+	    !(frame_header->status & ATA_BUSY)) {
 		scic_sds_unsolicited_frame_control_get_buffer(
 			&(scic_sds_phy_get_controller(sci_phy)->uf_control),
 			frame_index,
@@ -1303,10 +1298,10 @@ static enum sci_status scic_sds_phy_starting_substate_await_sig_fis_frame_handle
 
 		scic_sds_controller_copy_sata_response(
 			&sci_phy->phy_type.sata.signature_fis_buffer,
-			frame_words,
+			frame_header,
 			fis_frame_data);
 
-		/* We got the IAF we can now go to the await spinup semaphore state */
+		/* got IAF we can now go to the await spinup semaphore state */
 		sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
 						    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
 
@@ -1318,7 +1313,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_sig_fis_frame_handle
 			 __func__,
 			 frame_index);
 
-	/* Regardless of the result release this frame since we are done with it */
+	/* Regardless of the result we are done with this frame with it */
 	scic_sds_controller_release_frame(scic_sds_phy_get_controller(sci_phy),
 					  frame_index);
 
diff --git a/drivers/scsi/isci/core/scic_sds_phy.h b/drivers/scsi/isci/core/scic_sds_phy.h
index c9fa207..22b3119 100644
--- a/drivers/scsi/isci/core/scic_sds_phy.h
+++ b/drivers/scsi/isci/core/scic_sds_phy.h
@@ -56,7 +56,6 @@
 #ifndef _SCIC_SDS_PHY_H_
 #define _SCIC_SDS_PHY_H_
 
-#include "intel_sata.h"
 #include "intel_sas.h"
 #include "scu_registers.h"
 #include "sci_base_state_machine.h"
diff --git a/drivers/scsi/isci/core/scic_sds_request.c b/drivers/scsi/isci/core/scic_sds_request.c
index 1306765..31df526 100644
--- a/drivers/scsi/isci/core/scic_sds_request.c
+++ b/drivers/scsi/isci/core/scic_sds_request.c
@@ -55,8 +55,6 @@
 
 #include <scsi/sas.h>
 #include "intel_sas.h"
-#include "intel_sata.h"
-#include "intel_sat.h"
 #include "scic_controller.h"
 #include "scic_io_request.h"
 #include "scic_sds_controller.h"
@@ -631,51 +629,55 @@ static void scu_ssp_task_request_construct_task_context(
  *
  * enum sci_status
  */
-static enum sci_status scic_io_request_construct_sata(struct scic_sds_request *sci_req,
-						      u8 proto, u32 len,
-						      enum dma_data_direction dir,
-						      bool copy)
+static enum sci_status
+scic_io_request_construct_sata(struct scic_sds_request *sci_req,
+			       u32 len,
+			       enum dma_data_direction dir,
+			       bool copy)
 {
 	enum sci_status status = SCI_SUCCESS;
+	struct isci_request *ireq = sci_req->ireq;
+	struct sas_task *task = isci_request_access_task(ireq);
+
+	/* check for management protocols */
+	if (ireq->ttype == tmf_task) {
+		struct isci_tmf *tmf = isci_request_access_tmf(ireq);
+
+		if (tmf->tmf_code == isci_tmf_sata_srst_high ||
+		    tmf->tmf_code == isci_tmf_sata_srst_low)
+			return scic_sds_stp_soft_reset_request_construct(sci_req);
+		else {
+			dev_err(scic_to_dev(sci_req->owning_controller),
+				"%s: Request 0x%p received un-handled SAT "
+				"management protocol 0x%x.\n",
+				__func__, sci_req, tmf->tmf_code);
+
+			return SCI_FAILURE;
+		}
+	}
 
-	switch (proto) {
-	case SAT_PROTOCOL_PIO_DATA_IN:
-	case SAT_PROTOCOL_PIO_DATA_OUT:
-		status = scic_sds_stp_pio_request_construct(sci_req, proto, copy);
-		break;
-
-	case SAT_PROTOCOL_UDMA_DATA_IN:
-	case SAT_PROTOCOL_UDMA_DATA_OUT:
-		status = scic_sds_stp_udma_request_construct(sci_req, len, dir);
-		break;
+	if (!sas_protocol_ata(task->task_proto)) {
+		dev_err(scic_to_dev(sci_req->owning_controller),
+			"%s: Non-ATA protocol in SATA path: 0x%x\n",
+			__func__,
+			task->task_proto);
+		return SCI_FAILURE;
 
-	case SAT_PROTOCOL_ATA_HARD_RESET:
-	case SAT_PROTOCOL_SOFT_RESET:
-		status = scic_sds_stp_soft_reset_request_construct(sci_req);
-		break;
+	}
 
-	case SAT_PROTOCOL_NON_DATA:
-		status = scic_sds_stp_non_data_request_construct(sci_req);
-		break;
+	/* non data */
+	if (task->data_dir == DMA_NONE)
+		return scic_sds_stp_non_data_request_construct(sci_req);
 
-	case SAT_PROTOCOL_FPDMA:
-		status = scic_sds_stp_ncq_request_construct(sci_req, len, dir);
-		break;
+	/* NCQ */
+	if (task->ata_task.use_ncq)
+		return scic_sds_stp_ncq_request_construct(sci_req, len, dir);
 
-	case SAT_PROTOCOL_DMA_QUEUED:
-	case SAT_PROTOCOL_DMA:
-	case SAT_PROTOCOL_DEVICE_DIAGNOSTIC:
-	case SAT_PROTOCOL_DEVICE_RESET:
-	case SAT_PROTOCOL_RETURN_RESPONSE_INFO:
-	default:
-		dev_err(scic_to_dev(sci_req->owning_controller),
-			"%s: SCIC IO Request 0x%p received un-handled "
-			"SAT Protocl %d.\n",
-			__func__, sci_req, proto);
-
-		status = SCI_FAILURE;
-		break;
-	}
+	/* DMA */
+	if (task->ata_task.dma_xfer)
+		return scic_sds_stp_udma_request_construct(sci_req, len, dir);
+	else /* PIO */
+		return scic_sds_stp_pio_request_construct(sci_req, copy);
 
 	return status;
 }
@@ -735,7 +737,6 @@ enum sci_status scic_io_request_construct_basic_sata(
 {
 	enum sci_status status;
 	struct scic_sds_stp_request *stp_req;
-	u8 proto;
 	u32 len;
 	enum dma_data_direction dir;
 	bool copy = false;
@@ -748,10 +749,9 @@ enum sci_status scic_io_request_construct_basic_sata(
 
 	len = isci_request_io_request_get_transfer_length(isci_request);
 	dir = isci_request_io_request_get_data_direction(isci_request);
-	proto = isci_sata_get_sat_protocol(isci_request);
 	copy = (task->data_dir == DMA_NONE) ? false : true;
 
-	status = scic_io_request_construct_sata(sci_req, proto, len, dir, copy);
+	status = scic_io_request_construct_sata(sci_req, len, dir, copy);
 
 	if (status == SCI_SUCCESS)
 		sci_base_state_machine_change_state(&sci_req->state_machine,
@@ -764,33 +764,30 @@ enum sci_status scic_io_request_construct_basic_sata(
 enum sci_status scic_task_request_construct_sata(
 	struct scic_sds_request *sci_req)
 {
-	enum sci_status status;
-	u8 sat_protocol;
-	struct isci_request *isci_request = sci_req->ireq;
-
-	sat_protocol = isci_sata_get_sat_protocol(isci_request);
+	enum sci_status status = SCI_SUCCESS;
+	struct isci_request *ireq = sci_req->ireq;
 
-	switch (sat_protocol) {
-	case SAT_PROTOCOL_ATA_HARD_RESET:
-	case SAT_PROTOCOL_SOFT_RESET:
-		status = scic_sds_stp_soft_reset_request_construct(sci_req);
-		break;
+	/* check for management protocols */
+	if (ireq->ttype == tmf_task) {
+		struct isci_tmf *tmf = isci_request_access_tmf(ireq);
 
-	default:
-		dev_err(scic_to_dev(sci_req->owning_controller),
-			"%s: SCIC IO Request 0x%p received un-handled SAT "
-			"Protocl %d.\n",
-			__func__,
-			sci_req,
-			sat_protocol);
+		if (tmf->tmf_code == isci_tmf_sata_srst_high ||
+		    tmf->tmf_code == isci_tmf_sata_srst_low) {
+			status = scic_sds_stp_soft_reset_request_construct(sci_req);
+		} else {
+			dev_err(scic_to_dev(sci_req->owning_controller),
+				"%s: Request 0x%p received un-handled SAT "
+				"Protocol 0x%x.\n",
+				__func__, sci_req, tmf->tmf_code);
 
-		status = SCI_FAILURE;
-		break;
+			return SCI_FAILURE;
+		}
 	}
 
 	if (status == SCI_SUCCESS)
-		sci_base_state_machine_change_state(&sci_req->state_machine,
-			SCI_BASE_REQUEST_STATE_CONSTRUCTED);
+		sci_base_state_machine_change_state(
+				&sci_req->state_machine,
+				SCI_BASE_REQUEST_STATE_CONSTRUCTED);
 
 	return status;
 }
diff --git a/drivers/scsi/isci/core/scic_sds_stp_request.c b/drivers/scsi/isci/core/scic_sds_stp_request.c
index 1cd111c..b3ad33b 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_request.c
+++ b/drivers/scsi/isci/core/scic_sds_stp_request.c
@@ -53,10 +53,8 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-
-#include "intel_ata.h"
-#include "intel_sata.h"
-#include "intel_sat.h"
+#include <scsi/sas.h>
+#include "sas.h"
 #include "sci_base_state.h"
 #include "sci_base_state_machine.h"
 #include "scic_io_request.h"
@@ -136,7 +134,8 @@ u32 scic_sds_stp_request_get_object_size(void)
 
 void scic_sds_stp_request_assign_buffers(struct scic_sds_request *sci_req)
 {
-	struct scic_sds_stp_request *stp_req = container_of(sci_req, typeof(*stp_req), parent);
+	struct scic_sds_stp_request *stp_req =
+		container_of(sci_req, typeof(*stp_req), parent);
 
 	sci_req->command_buffer = scic_sds_stp_request_get_h2d_reg_buffer(stp_req);
 	sci_req->response_buffer = scic_sds_stp_request_get_response_buffer(stp_req);
@@ -353,7 +352,7 @@ static void scu_stp_raw_request_construct_task_context(
 	task_context->control_frame         = 0;
 	task_context->priority              = SCU_TASK_PRIORITY_NORMAL;
 	task_context->task_type             = SCU_TASK_TYPE_SATA_RAW_FRAME;
-	task_context->type.stp.fis_type     = SATA_FIS_TYPE_REGH2D;
+	task_context->type.stp.fis_type     = FIS_REGH2D;
 	task_context->transfer_length_bytes =
 		sizeof(struct host_to_dev_fis) - sizeof(u32);
 }
@@ -484,68 +483,65 @@ static enum sci_status scic_sds_stp_request_non_data_await_h2d_tc_completion_han
  * if the received frame was processed successfully.
  */
 static enum sci_status scic_sds_stp_request_non_data_await_d2h_frame_handler(
-	struct scic_sds_request *request,
+	struct scic_sds_request *sci_req,
 	u32 frame_index)
 {
 	enum sci_status status;
-	struct sata_fis_header *frame_header;
+	struct dev_to_host_fis *frame_header;
 	u32 *frame_buffer;
-	struct scic_sds_stp_request *sci_req = (struct scic_sds_stp_request *)request;
+	struct scic_sds_stp_request *stp_req =
+		container_of(sci_req, typeof(*stp_req), parent);
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&sci_req->parent.owning_controller->uf_control,
+		&stp_req->parent.owning_controller->uf_control,
 		frame_index,
-		(void **)&frame_header
-		);
+		(void **)&frame_header);
 
 	if (status == SCI_SUCCESS) {
 		switch (frame_header->fis_type) {
-		case SATA_FIS_TYPE_REGD2H:
+		case FIS_REGD2H:
 			scic_sds_unsolicited_frame_control_get_buffer(
-				&sci_req->parent.owning_controller->uf_control,
+				&stp_req->parent.owning_controller->uf_control,
 				frame_index,
-				(void **)&frame_buffer
-				);
+				(void **)&frame_buffer);
 
 			scic_sds_controller_copy_sata_response(
-				&sci_req->d2h_reg_fis, (u32 *)frame_header, frame_buffer
-				);
+				&stp_req->d2h_reg_fis,
+				(u32 *)frame_header,
+				frame_buffer);
 
 			/* The command has completed with error */
 			scic_sds_request_set_status(
-				&sci_req->parent,
+				&stp_req->parent,
 				SCU_TASK_DONE_CHECK_RESPONSE,
-				SCI_FAILURE_IO_RESPONSE_VALID
-				);
+				SCI_FAILURE_IO_RESPONSE_VALID);
 			break;
 
 		default:
-			dev_warn(scic_to_dev(request->owning_controller),
+			dev_warn(scic_to_dev(sci_req->owning_controller),
 				 "%s: IO Request:0x%p Frame Id:%d protocol "
 				 "violation occurred\n",
-				 __func__, sci_req, frame_index);
+				 __func__, stp_req, frame_index);
 
 			scic_sds_request_set_status(
-				&sci_req->parent,
+				&stp_req->parent,
 				SCU_TASK_DONE_UNEXP_FIS,
-				SCI_FAILURE_PROTOCOL_VIOLATION
-				);
+				SCI_FAILURE_PROTOCOL_VIOLATION);
 			break;
 		}
 
 		sci_base_state_machine_change_state(
-			&sci_req->parent.state_machine,
-			SCI_BASE_REQUEST_STATE_COMPLETED
-			);
+			&stp_req->parent.state_machine,
+			SCI_BASE_REQUEST_STATE_COMPLETED);
 
 		/* Frame has been decoded return it to the controller */
 		scic_sds_controller_release_frame(
-			sci_req->parent.owning_controller, frame_index);
+			stp_req->parent.owning_controller, frame_index);
 	} else
-		dev_err(scic_to_dev(request->owning_controller),
+		dev_err(scic_to_dev(sci_req->owning_controller),
 			"%s: SCIC IO Request 0x%p could not get frame header "
 			"for frame index %d, status %x\n",
-			__func__, sci_req, frame_index, status);
+			__func__, stp_req, frame_index, status);
 
 	return status;
 }
@@ -603,7 +599,8 @@ static const struct sci_base_state scic_sds_stp_request_started_non_data_substat
 
 enum sci_status scic_sds_stp_non_data_request_construct(struct scic_sds_request *sci_req)
 {
-	struct scic_sds_stp_request *stp_req = container_of(sci_req, typeof(*stp_req), parent);
+	struct scic_sds_stp_request *stp_req =
+		container_of(sci_req, typeof(*stp_req), parent);
 
 	scic_sds_stp_non_ncq_request_construct(sci_req);
 
@@ -634,7 +631,8 @@ static enum sci_status scic_sds_stp_request_pio_data_out_trasmit_data_frame(
 	struct scic_sds_request *sci_req,
 	u32 length)
 {
-	struct scic_sds_stp_request *stp_req = (struct scic_sds_stp_request *)sci_req;
+	struct scic_sds_stp_request *stp_req =
+		container_of(sci_req, typeof(*stp_req), parent);
 	struct scu_sgl_element *current_sgl;
 
 	/*
@@ -654,7 +652,7 @@ static enum sci_status scic_sds_stp_request_pio_data_out_trasmit_data_frame(
 	task_context->command_iu_upper = current_sgl->address_upper;
 	task_context->command_iu_lower = current_sgl->address_lower;
 	task_context->transfer_length_bytes = length;
-	task_context->type.stp.fis_type = SATA_FIS_TYPE_DATA;
+	task_context->type.stp.fis_type = FIS_DATA;
 
 	/* send the new TC out. */
 	return scic_controller_continue_io(sci_req);
@@ -675,7 +673,8 @@ static enum sci_status scic_sds_stp_request_pio_data_out_transmit_data(
 	u32 remaining_bytes_in_current_sgl = 0;
 	enum sci_status status = SCI_SUCCESS;
 
-	struct scic_sds_stp_request *stp_req = (struct scic_sds_stp_request *)sci_req;
+	struct scic_sds_stp_request *stp_req =
+		container_of(sci_req, typeof(*stp_req), parent);
 
 	sgl_offset = stp_req->type.pio.request_current.sgl_offset;
 
@@ -855,122 +854,126 @@ static enum sci_status scic_sds_stp_request_pio_await_h2d_completion_tc_completi
  * enum sci_status
  */
 static enum sci_status scic_sds_stp_request_pio_await_frame_frame_handler(
-	struct scic_sds_request *request,
+	struct scic_sds_request *sci_req,
 	u32 frame_index)
 {
 	enum sci_status status;
-	struct sata_fis_header *frame_header;
+	struct dev_to_host_fis *frame_header;
 	u32 *frame_buffer;
-	struct scic_sds_stp_request *sci_req;
-
-	sci_req = (struct scic_sds_stp_request *)request;
+	struct scic_sds_stp_request *stp_req = container_of(sci_req, typeof(*stp_req), parent);
+	struct isci_request *ireq = sci_req->ireq;
+	struct sas_task *task = isci_request_access_task(ireq);
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(sci_req->parent.owning_controller->uf_control),
+		&(stp_req->parent.owning_controller->uf_control),
 		frame_index,
-		(void **)&frame_header
-		);
+		(void **)&frame_header);
 
 	if (status == SCI_SUCCESS) {
 		switch (frame_header->fis_type) {
-		case SATA_FIS_TYPE_PIO_SETUP:
+		case FIS_PIO_SETUP:
 			/* Get from the frame buffer the PIO Setup Data */
 			scic_sds_unsolicited_frame_control_get_buffer(
-				&(sci_req->parent.owning_controller->uf_control),
+				&(stp_req->parent.owning_controller->uf_control),
 				frame_index,
-				(void **)&frame_buffer
-				);
+				(void **)&frame_buffer);
 
-			/*
-			 * Get the data from the PIO Setup
-			 * The SCU Hardware returns first word in the frame_header and the rest
-			 * of the data is in the frame buffer so we need to back up one dword */
-			sci_req->type.pio.pio_transfer_bytes =
-				(u16)((struct sata_fis_pio_setup *)(&frame_buffer[-1]))->transfter_count;
-			sci_req->type.pio.ending_status =
-				(u8)((struct sata_fis_pio_setup *)(&frame_buffer[-1]))->ending_status;
+			/* Get the data from the PIO Setup The SCU Hardware
+			 * returns first word in the frame_header and the rest
+			 * of the data is in the frame buffer so we need to back
+			 * up one dword
+			 */
+
+			/* transfer_count: first 16bits in the 4th dword */
+			stp_req->type.pio.pio_transfer_bytes =
+				frame_buffer[3] & 0xffff;
+
+			/* ending_status: 4th byte in the 3rd dword */
+			stp_req->type.pio.ending_status =
+				(frame_buffer[2] >> 24) & 0xff;
 
 			scic_sds_controller_copy_sata_response(
-				&sci_req->d2h_reg_fis, (u32 *)frame_header, frame_buffer
-				);
+				&stp_req->d2h_reg_fis,
+				(u32 *)frame_header,
+				frame_buffer);
 
-			sci_req->d2h_reg_fis.status =
-				sci_req->type.pio.ending_status;
+			stp_req->d2h_reg_fis.status =
+				stp_req->type.pio.ending_status;
 
-			/* The next state is dependent on whether the request was PIO Data-in or Data out */
-			if (sci_req->type.pio.sat_protocol == SAT_PROTOCOL_PIO_DATA_IN) {
+			/* The next state is dependent on whether the
+			 * request was PIO Data-in or Data out
+			 */
+			if (task->data_dir == DMA_FROM_DEVICE) {
 				sci_base_state_machine_change_state(
-					&sci_req->parent.started_substate_machine,
-					SCIC_SDS_STP_REQUEST_STARTED_PIO_DATA_IN_AWAIT_DATA_SUBSTATE
-					);
-			} else if (sci_req->type.pio.sat_protocol == SAT_PROTOCOL_PIO_DATA_OUT) {
+					&stp_req->parent.started_substate_machine,
+					SCIC_SDS_STP_REQUEST_STARTED_PIO_DATA_IN_AWAIT_DATA_SUBSTATE);
+			} else if (task->data_dir == DMA_TO_DEVICE) {
 				/* Transmit data */
-				status = scic_sds_stp_request_pio_data_out_transmit_data(request);
+				status = scic_sds_stp_request_pio_data_out_transmit_data(sci_req);
 				if (status == SCI_SUCCESS) {
 					sci_base_state_machine_change_state(
-						&sci_req->parent.started_substate_machine,
-						SCIC_SDS_STP_REQUEST_STARTED_PIO_DATA_OUT_TRANSMIT_DATA_SUBSTATE
-						);
+						&stp_req->parent.started_substate_machine,
+						SCIC_SDS_STP_REQUEST_STARTED_PIO_DATA_OUT_TRANSMIT_DATA_SUBSTATE);
 				}
 			}
 			break;
 
-		case SATA_FIS_TYPE_SETDEVBITS:
+		case FIS_SETDEVBITS:
 			sci_base_state_machine_change_state(
-				&sci_req->parent.started_substate_machine,
-				SCIC_SDS_STP_REQUEST_STARTED_PIO_AWAIT_FRAME_SUBSTATE
-				);
+				&stp_req->parent.started_substate_machine,
+				SCIC_SDS_STP_REQUEST_STARTED_PIO_AWAIT_FRAME_SUBSTATE);
 			break;
 
-		case SATA_FIS_TYPE_REGD2H:
-			if ((frame_header->status & ATA_STATUS_REG_BSY_BIT) == 0) {
+		case FIS_REGD2H:
+			if ((frame_header->status & ATA_BUSY) == 0) {
 				scic_sds_unsolicited_frame_control_get_buffer(
-					&(sci_req->parent.owning_controller->uf_control),
+					&(stp_req->parent.owning_controller->uf_control),
 					frame_index,
-					(void **)&frame_buffer
-					);
+					(void **)&frame_buffer);
 
 				scic_sds_controller_copy_sata_response(
-					&sci_req->d2h_reg_fis, (u32 *)frame_header, frame_buffer);
+					&stp_req->d2h_reg_fis,
+					(u32 *)frame_header,
+					frame_buffer);
 
 				scic_sds_request_set_status(
-					&sci_req->parent,
+					&stp_req->parent,
 					SCU_TASK_DONE_CHECK_RESPONSE,
-					SCI_FAILURE_IO_RESPONSE_VALID
-					);
+					SCI_FAILURE_IO_RESPONSE_VALID);
 
 				sci_base_state_machine_change_state(
-					&sci_req->parent.state_machine,
-					SCI_BASE_REQUEST_STATE_COMPLETED
-					);
+					&stp_req->parent.state_machine,
+					SCI_BASE_REQUEST_STATE_COMPLETED);
 			} else {
-				/*
-				 * Now why is the drive sending a D2H Register FIS when it is still busy?
-				 * Do nothing since we are still in the right state. */
-				dev_dbg(scic_to_dev(request->owning_controller),
+				/* Now why is the drive sending a D2H Register
+				 * FIS when it is still busy?
+				 * Do nothing since we are still in the right
+				 * state.
+				 */
+				dev_dbg(scic_to_dev(sci_req->owning_controller),
 					"%s: SCIC PIO Request 0x%p received "
 					"D2H Register FIS with BSY status "
 					"0x%x\n",
 					__func__,
-					sci_req,
+					stp_req,
 					frame_header->status);
 			}
 			break;
 
 		default:
+			/* FIXME: what do we do here? */
 			break;
 		}
 
 		/* Frame is decoded return it to the controller */
 		scic_sds_controller_release_frame(
-			sci_req->parent.owning_controller,
-			frame_index
-			);
+			stp_req->parent.owning_controller,
+			frame_index);
 	} else
-		dev_err(scic_to_dev(request->owning_controller),
+		dev_err(scic_to_dev(sci_req->owning_controller),
 			"%s: SCIC IO Request 0x%p could not get frame header "
 			"for frame index %d, status %x\n",
-			__func__, sci_req, frame_index, status);
+			__func__, stp_req, frame_index, status);
 
 	return status;
 }
@@ -983,100 +986,94 @@ static enum sci_status scic_sds_stp_request_pio_await_frame_frame_handler(
  * enum sci_status
  */
 static enum sci_status scic_sds_stp_request_pio_data_in_await_data_frame_handler(
-	struct scic_sds_request *request,
+	struct scic_sds_request *sci_req,
 	u32 frame_index)
 {
 	enum sci_status status;
-	struct sata_fis_header *frame_header;
+	struct dev_to_host_fis *frame_header;
 	struct sata_fis_data *frame_buffer;
-	struct scic_sds_stp_request *sci_req;
-
-	sci_req = (struct scic_sds_stp_request *)request;
+	struct scic_sds_stp_request *stp_req =
+		container_of(sci_req, typeof(*stp_req), parent);
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(sci_req->parent.owning_controller->uf_control),
+		&(stp_req->parent.owning_controller->uf_control),
 		frame_index,
-		(void **)&frame_header
-		);
+		(void **)&frame_header);
 
 	if (status == SCI_SUCCESS) {
-		if (frame_header->fis_type == SATA_FIS_TYPE_DATA) {
-			if (sci_req->type.pio.request_current.sgl_pair == NULL) {
-				sci_req->parent.saved_rx_frame_index = frame_index;
-				sci_req->type.pio.pio_transfer_bytes = 0;
+		if (frame_header->fis_type == FIS_DATA) {
+			if (stp_req->type.pio.request_current.sgl_pair ==
+					NULL) {
+				stp_req->parent.saved_rx_frame_index =
+					frame_index;
+				stp_req->type.pio.pio_transfer_bytes = 0;
 			} else {
 				status = scic_sds_unsolicited_frame_control_get_buffer(
-					&(sci_req->parent.owning_controller->uf_control),
+					&(stp_req->parent.owning_controller->uf_control),
 					frame_index,
-					(void **)&frame_buffer
-					);
+					(void **)&frame_buffer);
 
-				status = scic_sds_stp_request_pio_data_in_copy_data(sci_req, (u8 *)frame_buffer);
+				status = scic_sds_stp_request_pio_data_in_copy_data(
+						stp_req,
+						(u8 *)frame_buffer);
 
 				/* Frame is decoded return it to the controller */
 				scic_sds_controller_release_frame(
-					sci_req->parent.owning_controller,
-					frame_index
-					);
+					stp_req->parent.owning_controller,
+					frame_index);
 			}
 
 			/*
-			 * Check for the end of the transfer, are there more bytes remaining
-			 * for this data transfer */
-			if (
-				(status == SCI_SUCCESS)
-				&& (sci_req->type.pio.pio_transfer_bytes == 0)
-				) {
-				if ((sci_req->type.pio.ending_status & ATA_STATUS_REG_BSY_BIT) == 0) {
+			 * Check for the end of the transfer, are there more
+			 * bytes remaining for this data transfer
+			 */
+			if ((status == SCI_SUCCESS) &&
+			    (stp_req->type.pio.pio_transfer_bytes == 0)) {
+				if ((stp_req->type.pio.ending_status &
+							ATA_BUSY) == 0) {
 					scic_sds_request_set_status(
-						&sci_req->parent,
+						&stp_req->parent,
 						SCU_TASK_DONE_CHECK_RESPONSE,
-						SCI_FAILURE_IO_RESPONSE_VALID
-						);
+						SCI_FAILURE_IO_RESPONSE_VALID);
 
 					sci_base_state_machine_change_state(
-						&sci_req->parent.state_machine,
-						SCI_BASE_REQUEST_STATE_COMPLETED
-						);
+						&stp_req->parent.state_machine,
+						SCI_BASE_REQUEST_STATE_COMPLETED);
 				} else {
 					sci_base_state_machine_change_state(
-						&request->started_substate_machine,
-						SCIC_SDS_STP_REQUEST_STARTED_PIO_AWAIT_FRAME_SUBSTATE
-						);
+						&sci_req->started_substate_machine,
+						SCIC_SDS_STP_REQUEST_STARTED_PIO_AWAIT_FRAME_SUBSTATE);
 				}
 			}
 		} else {
-			dev_err(scic_to_dev(request->owning_controller),
+			dev_err(scic_to_dev(sci_req->owning_controller),
 				"%s: SCIC PIO Request 0x%p received frame %d "
 				"with fis type 0x%02x when expecting a data "
 				"fis.\n",
 				__func__,
-				sci_req,
+				stp_req,
 				frame_index,
 				frame_header->fis_type);
 
 			scic_sds_request_set_status(
-				&sci_req->parent,
+				&stp_req->parent,
 				SCU_TASK_DONE_GOOD,
-				SCI_FAILURE_IO_REQUIRES_SCSI_ABORT
-				);
+				SCI_FAILURE_IO_REQUIRES_SCSI_ABORT);
 
 			sci_base_state_machine_change_state(
-				&sci_req->parent.state_machine,
-				SCI_BASE_REQUEST_STATE_COMPLETED
-				);
+				&stp_req->parent.state_machine,
+				SCI_BASE_REQUEST_STATE_COMPLETED);
 
 			/* Frame is decoded return it to the controller */
 			scic_sds_controller_release_frame(
-				sci_req->parent.owning_controller,
-				frame_index
-				);
+				stp_req->parent.owning_controller,
+				frame_index);
 		}
 	} else
-		dev_err(scic_to_dev(request->owning_controller),
+		dev_err(scic_to_dev(sci_req->owning_controller),
 			"%s: SCIC IO Request 0x%p could not get frame header "
 			"for frame index %d, status %x\n",
-			__func__, sci_req, frame_index, status);
+			__func__, stp_req, frame_index, status);
 
 	return status;
 }
@@ -1094,10 +1091,10 @@ static enum sci_status scic_sds_stp_request_pio_data_out_await_data_transmit_com
 	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
-	enum sci_status status                     = SCI_SUCCESS;
-	bool all_frames_transferred     = false;
-
-	struct scic_sds_stp_request *stp_req = (struct scic_sds_stp_request *)sci_req;
+	enum sci_status status = SCI_SUCCESS;
+	bool all_frames_transferred = false;
+	struct scic_sds_stp_request *stp_req =
+		container_of(sci_req, typeof(*stp_req), parent);
 
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
@@ -1279,11 +1276,12 @@ static const struct sci_base_state scic_sds_stp_request_started_pio_substate_tab
 	}
 };
 
-enum sci_status scic_sds_stp_pio_request_construct(struct scic_sds_request *sci_req,
-						   u8 sat_protocol,
-						   bool copy_rx_frame)
+enum sci_status
+scic_sds_stp_pio_request_construct(struct scic_sds_request *sci_req,
+				   bool copy_rx_frame)
 {
-	struct scic_sds_stp_request *stp_req = container_of(sci_req, typeof(*stp_req), parent);
+	struct scic_sds_stp_request *stp_req =
+		container_of(sci_req, typeof(*stp_req), parent);
 	struct scic_sds_stp_pio_request *pio = &stp_req->type.pio;
 
 	scic_sds_stp_non_ncq_request_construct(sci_req);
@@ -1297,7 +1295,6 @@ enum sci_status scic_sds_stp_pio_request_construct(struct scic_sds_request *sci_
 
 	pio->request_current.sgl_offset = 0;
 	pio->request_current.sgl_set = SCU_SGL_ELEMENT_PAIR_A;
-	pio->sat_protocol = sat_protocol;
 
 	if (copy_rx_frame) {
 		scic_sds_request_build_sgl(sci_req);
@@ -1340,30 +1337,25 @@ static enum sci_status scic_sds_stp_request_udma_general_frame_handler(
 	u32 frame_index)
 {
 	enum sci_status status;
-	struct sata_fis_header *frame_header;
+	struct dev_to_host_fis *frame_header;
 	u32 *frame_buffer;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
 		&sci_req->owning_controller->uf_control,
 		frame_index,
-		(void **)&frame_header
-		);
+		(void **)&frame_header);
 
-	if (
-		(status == SCI_SUCCESS)
-		&& (frame_header->fis_type == SATA_FIS_TYPE_REGD2H)
-		) {
+	if ((status == SCI_SUCCESS) &&
+	    (frame_header->fis_type == FIS_REGD2H)) {
 		scic_sds_unsolicited_frame_control_get_buffer(
 			&sci_req->owning_controller->uf_control,
 			frame_index,
-			(void **)&frame_buffer
-			);
+			(void **)&frame_buffer);
 
 		scic_sds_controller_copy_sata_response(
 			&((struct scic_sds_stp_request *)sci_req)->d2h_reg_fis,
 			(u32 *)frame_header,
-			frame_buffer
-			);
+			frame_buffer);
 	}
 
 	scic_sds_controller_release_frame(
@@ -1399,7 +1391,7 @@ static enum sci_status scic_sds_stp_request_udma_await_tc_completion_tc_completi
 		/*
 		 * We must check ther response buffer to see if the D2H Register FIS was
 		 * received before we got the TC completion. */
-		if (sci_req->d2h_reg_fis.fis_type == SATA_FIS_TYPE_REGD2H) {
+		if (sci_req->d2h_reg_fis.fis_type == FIS_REGD2H) {
 			scic_sds_remote_device_suspend(
 				sci_req->parent.target_device,
 				SCU_EVENT_SPECIFIC(SCU_NORMALIZE_COMPLETION_STATUS(completion_code))
@@ -1648,35 +1640,34 @@ static enum sci_status scic_sds_stp_request_soft_reset_await_d2h_frame_handler(
 	u32 frame_index)
 {
 	enum sci_status status;
-	struct sata_fis_header *frame_header;
+	struct dev_to_host_fis *frame_header;
 	u32 *frame_buffer;
-	struct scic_sds_stp_request *sci_req = (struct scic_sds_stp_request *)request;
+	struct scic_sds_stp_request *stp_req =
+		(struct scic_sds_stp_request *)request;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(sci_req->parent.owning_controller->uf_control),
+		&(stp_req->parent.owning_controller->uf_control),
 		frame_index,
-		(void **)&frame_header
-		);
+		(void **)&frame_header);
 
 	if (status == SCI_SUCCESS) {
 		switch (frame_header->fis_type) {
-		case SATA_FIS_TYPE_REGD2H:
+		case FIS_REGD2H:
 			scic_sds_unsolicited_frame_control_get_buffer(
-				&(sci_req->parent.owning_controller->uf_control),
+				&(stp_req->parent.owning_controller->uf_control),
 				frame_index,
-				(void **)&frame_buffer
-				);
+				(void **)&frame_buffer);
 
 			scic_sds_controller_copy_sata_response(
-				&sci_req->d2h_reg_fis, (u32 *)frame_header, frame_buffer
-				);
+				&stp_req->d2h_reg_fis,
+				(u32 *)frame_header,
+				frame_buffer);
 
 			/* The command has completed with error */
 			scic_sds_request_set_status(
-				&sci_req->parent,
+				&stp_req->parent,
 				SCU_TASK_DONE_CHECK_RESPONSE,
-				SCI_FAILURE_IO_RESPONSE_VALID
-				);
+				SCI_FAILURE_IO_RESPONSE_VALID);
 			break;
 
 		default:
@@ -1684,30 +1675,28 @@ static enum sci_status scic_sds_stp_request_soft_reset_await_d2h_frame_handler(
 				 "%s: IO Request:0x%p Frame Id:%d protocol "
 				 "violation occurred\n",
 				 __func__,
-				 sci_req,
+				 stp_req,
 				 frame_index);
 
 			scic_sds_request_set_status(
-				&sci_req->parent,
+				&stp_req->parent,
 				SCU_TASK_DONE_UNEXP_FIS,
-				SCI_FAILURE_PROTOCOL_VIOLATION
-				);
+				SCI_FAILURE_PROTOCOL_VIOLATION);
 			break;
 		}
 
 		sci_base_state_machine_change_state(
-			&sci_req->parent.state_machine,
+			&stp_req->parent.state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED);
 
 		/* Frame has been decoded return it to the controller */
 		scic_sds_controller_release_frame(
-			sci_req->parent.owning_controller, frame_index
-			);
+			stp_req->parent.owning_controller, frame_index);
 	} else
 		dev_err(scic_to_dev(request->owning_controller),
 			"%s: SCIC IO Request 0x%p could not get frame header "
 			"for frame index %d, status %x\n",
-			__func__, sci_req, frame_index, status);
+			__func__, stp_req, frame_index, status);
 
 	return status;
 }
@@ -1798,7 +1787,8 @@ static const struct sci_base_state scic_sds_stp_request_started_soft_reset_subst
 
 enum sci_status scic_sds_stp_soft_reset_request_construct(struct scic_sds_request *sci_req)
 {
-	struct scic_sds_stp_request *stp_req = container_of(sci_req, typeof(*stp_req), parent);
+	struct scic_sds_stp_request *stp_req =
+		container_of(sci_req, typeof(*stp_req), parent);
 
 	scic_sds_stp_non_ncq_request_construct(sci_req);
 
diff --git a/drivers/scsi/isci/core/scic_sds_stp_request.h b/drivers/scsi/isci/core/scic_sds_stp_request.h
index 807bc4e..50cb48e 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_request.h
+++ b/drivers/scsi/isci/core/scic_sds_stp_request.h
@@ -57,7 +57,7 @@
 #define _SCIC_SDS_STP_REQUEST_T_
 
 #include <linux/dma-mapping.h>
-#include "intel_sata.h"
+#include <scsi/sas.h>
 #include "scic_sds_request.h"
 
 /**
@@ -111,11 +111,6 @@ struct scic_sds_stp_request {
 			 */
 			u8 ending_error;
 
-			/**
-			 * Protocol Type. This is filled in by core during IO Request construction type.
-			 */
-			u8 sat_protocol;
-
 			struct scic_sds_request_pio_sgl {
 				struct scu_sgl_element_pair *sgl_pair;
 				u8 sgl_set;
@@ -173,7 +168,6 @@ u32 scic_sds_stp_request_get_object_size(void);
 
 enum sci_status scic_sds_stp_pio_request_construct(
 	struct scic_sds_request *scic_io_request,
-	u8 sat_protocol,
 	bool copy_rx_frame);
 
 enum sci_status scic_sds_stp_udma_request_construct(
diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index a23ebe8..e766b27 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -53,7 +53,7 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "intel_sas.h"
-#include "intel_ata.h"
+#include "sas.h"
 #include "isci.h"
 #include "port.h"
 #include "remote_device.h"
@@ -327,7 +327,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		break;
 	}
 	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ: {
-		struct sata_fis_header *hdr;
+		struct dev_to_host_fis *hdr;
 
 		status = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
 								       frame_index,
@@ -335,14 +335,14 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		if (status != SCI_SUCCESS)
 			return status;
 
-		if (hdr->fis_type == SATA_FIS_TYPE_SETDEVBITS &&
-		    (hdr->status & ATA_STATUS_REG_ERROR_BIT)) {
+		if (hdr->fis_type == FIS_SETDEVBITS &&
+		    (hdr->status & ATA_ERR)) {
 			sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
 
 			/* TODO Check sactive and complete associated IO if any. */
 			sci_base_state_machine_change_state(sm, SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
-		} else if (hdr->fis_type == SATA_FIS_TYPE_REGD2H &&
-			   (hdr->status & ATA_STATUS_REG_ERROR_BIT)) {
+		} else if (hdr->fis_type == FIS_REGD2H &&
+			   (hdr->status & ATA_ERR)) {
 			/*
 			 * Some devices return D2H FIS when an NCQ error is detected.
 			 * Treat this like an SDB error FIS ready reason.
@@ -469,6 +469,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	struct sci_base_state_machine *sm = &sci_dev->state_machine;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	struct isci_request *ireq = sci_req->ireq;
 	enum sci_status status;
 
 	switch (state) {
@@ -510,6 +511,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		 * substate.
 		 */
 		enum scic_sds_remote_device_states new_state;
+		struct sas_task *task = isci_request_access_task(ireq);
 
 		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
 		if (status != SCI_SUCCESS)
@@ -523,7 +525,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		if (status != SCI_SUCCESS)
 			break;
 
-		if (isci_sata_get_sat_protocol(sci_req->ireq) == SAT_PROTOCOL_FPDMA)
+		if (task->ata_task.use_ncq)
 			new_state = SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ;
 		else {
 			sci_dev->working_request = sci_req;
@@ -532,8 +534,10 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		sci_base_state_machine_change_state(sm, new_state);
 		break;
 	}
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
-		if (isci_sata_get_sat_protocol(sci_req->ireq) == SAT_PROTOCOL_FPDMA) {
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ: {
+		struct sas_task *task = isci_request_access_task(ireq);
+
+		if (task->ata_task.use_ncq) {
 			status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
 			if (status != SCI_SUCCESS)
 				return status;
@@ -546,6 +550,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		} else
 			return SCI_FAILURE_INVALID_STATE;
 		break;
+	}
 	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
diff --git a/drivers/scsi/isci/sas.h b/drivers/scsi/isci/sas.h
new file mode 100644
index 0000000..05af8bd
--- /dev/null
+++ b/drivers/scsi/isci/sas.h
@@ -0,0 +1,72 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _SCI_SAS_H_
+#define _SCI_SAS_H_
+/*
+ * SATA FIS Types These constants depict the various SATA FIS types devined in
+ * the serial ATA specification.
+ * XXX: This needs to go into <scsi/sas.h>
+ */
+#define FIS_REGH2D          0x27
+#define FIS_REGD2H          0x34
+#define FIS_SETDEVBITS      0xA1
+#define FIS_DMA_ACTIVATE    0x39
+#define FIS_DMA_SETUP       0x41
+#define FIS_BIST_ACTIVATE   0x58
+#define FIS_PIO_SETUP       0x5F
+#define FIS_DATA            0x46
+
+#endif
diff --git a/drivers/scsi/isci/sata.c b/drivers/scsi/isci/sata.c
index 0837450..a08fcf5 100644
--- a/drivers/scsi/isci/sata.c
+++ b/drivers/scsi/isci/sata.c
@@ -61,11 +61,6 @@
 #include "task.h"
 #include "request.h"
 #include "sata.h"
-#include "intel_sat.h"
-#include "intel_ata.h"
-
-static u8 isci_sata_get_management_task_protocol(struct isci_tmf *tmf);
-
 
 /**
  * isci_sata_task_to_fis_copy() - This function gets the host_to_dev_fis from
@@ -158,7 +153,7 @@ void isci_request_process_stp_response(struct sas_task *task,
 	 * If the device fault bit is set in the status register, then
 	 * set the sense data and return.
 	 */
-	if (d2h_reg_fis->status & ATA_STATUS_REG_DEVICE_FAULT_BIT)
+	if (d2h_reg_fis->status & ATA_DF)
 		ts->stat = SAS_PROTO_RESPONSE;
 	else
 		ts->stat = SAM_STAT_GOOD;
@@ -166,74 +161,6 @@ void isci_request_process_stp_response(struct sas_task *task,
 	ts->resp = SAS_TASK_COMPLETE;
 }
 
-/**
- * isci_sata_get_sat_protocol() - retrieve the sat protocol for the request
- * @isci_request: ata request
- *
- * Note: temporary implementation until expert mode removes the callback
- *
- */
-u8 isci_sata_get_sat_protocol(struct isci_request *isci_request)
-{
-	struct sas_task *task;
-	struct domain_device *dev;
-
-	dev_dbg(&isci_request->isci_host->pdev->dev,
-		"%s: isci_request = %p, ttype = %d\n",
-		__func__, isci_request, isci_request->ttype);
-
-	if (tmf_task == isci_request->ttype) {
-		struct isci_tmf *tmf = isci_request_access_tmf(isci_request);
-
-		return isci_sata_get_management_task_protocol(tmf);
-	}
-
-	task = isci_request_access_task(isci_request);
-	dev = task->dev;
-
-	if (!sas_protocol_ata(task->task_proto)) {
-		WARN(1, "unhandled task protocol\n");
-		return SAT_PROTOCOL_NON_DATA;
-	}
-
-	if (task->data_dir == DMA_NONE)
-		return SAT_PROTOCOL_NON_DATA;
-
-	/* the "_IN" protocol types are equivalent to their "_OUT"
-	 * analogs as far as the core is concerned
-	 */
-	if (dev->sata_dev.command_set == ATAPI_COMMAND_SET) {
-		if (task->ata_task.dma_xfer)
-			return SAT_PROTOCOL_PACKET_DMA_DATA_IN;
-		else
-			return SAT_PROTOCOL_PACKET_PIO_DATA_IN;
-	}
-
-	if (task->ata_task.use_ncq)
-		return SAT_PROTOCOL_FPDMA;
-
-	if (task->ata_task.dma_xfer)
-		return SAT_PROTOCOL_UDMA_DATA_IN;
-	else
-		return SAT_PROTOCOL_PIO_DATA_IN;
-}
-
-static u8 isci_sata_get_management_task_protocol(
-	struct isci_tmf *tmf)
-{
-	u8 ret = 0;
-
-	pr_warn("tmf = %p, func = %d\n", tmf, tmf->tmf_code);
-
-	if ((tmf->tmf_code == isci_tmf_sata_srst_high) ||
-	    (tmf->tmf_code == isci_tmf_sata_srst_low)) {
-		pr_warn("%s: tmf->tmf_code == TMF_LU_RESET\n", __func__);
-		ret = SAT_PROTOCOL_SOFT_RESET;
-	}
-
-	return ret;
-}
-
 enum sci_status isci_sata_management_task_request_build(
 	struct isci_request *isci_request)
 {
diff --git a/drivers/scsi/isci/sata.h b/drivers/scsi/isci/sata.h
index b6ba25b..1b89f1f 100644
--- a/drivers/scsi/isci/sata.h
+++ b/drivers/scsi/isci/sata.h
@@ -53,10 +53,6 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "intel_sat.h"
-
-
-
 struct host_to_dev_fis *isci_sata_task_to_fis_copy(
 	struct sas_task *task);
 
-- 
1.6.0.2

