From: Nicholas Bellinger <nab@linux-iscsi.org>
Date: Sat, 8 Oct 2011 13:59:52 -0700
Subject: [PATCH] target: Remove session_reinstatement parameter from ->transport_wait_for_tasks
Git-commit: 39c05f321a4b27f3036392eed68bd94ce2267155
References: FATE#313550
Patch-Mainline: v3.2

This patch removes the unnecessary session_reinstatement parameter from
se_cmd->transport_wait_for_tasks(), logic in transport_generic_wait_for_tasks,
and usage within iscsi-target code.

This also includes the removal of the 'bool' return from transport_put_cmd() +
transport_generic_free_cmd() that is no longer necessary.

Cc: Christoph Hellwig <hch@lst.de>
Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/target/iscsi/iscsi_target.c      |    4 +-
 drivers/target/iscsi/iscsi_target_erl2.c |   15 ++++++-------
 drivers/target/target_core_transport.c   |   33 ++++++++++--------------------
 include/target/target_core_base.h        |    2 +-
 include/target/target_core_transport.h   |    2 +-
 5 files changed, 22 insertions(+), 34 deletions(-)

diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c
index 7dc2cfe..354a833 100644
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@ -3960,7 +3960,7 @@ static void iscsit_release_commands_from_conn(struct iscsi_conn *conn)
 			 * iscsit_get_lun_for_cmd() in iscsit_handle_scsi_cmd().
 			 */
 			if (cmd->tmr_req && se_cmd->transport_wait_for_tasks)
-				se_cmd->transport_wait_for_tasks(se_cmd, 1, 1);
+				se_cmd->transport_wait_for_tasks(se_cmd, 1);
 			else if (cmd->se_cmd.se_cmd_flags & SCF_SE_LUN_CMD)
 				transport_release_cmd(se_cmd);
 			else
@@ -3976,7 +3976,7 @@ static void iscsit_release_commands_from_conn(struct iscsi_conn *conn)
 		se_cmd = &cmd->se_cmd;
 
 		if (se_cmd->transport_wait_for_tasks)
-			se_cmd->transport_wait_for_tasks(se_cmd, 1, 1);
+			se_cmd->transport_wait_for_tasks(se_cmd, 1);
 
 		spin_lock_bh(&conn->cmd_lock);
 	}
diff --git a/drivers/target/iscsi/iscsi_target_erl2.c b/drivers/target/iscsi/iscsi_target_erl2.c
index 91a4d17..000356b 100644
--- a/drivers/target/iscsi/iscsi_target_erl2.c
+++ b/drivers/target/iscsi/iscsi_target_erl2.c
@@ -148,7 +148,7 @@ void iscsit_free_connection_recovery_entires(struct iscsi_session *sess)
 				iscsit_release_cmd(cmd);
 			else
 				cmd->se_cmd.transport_wait_for_tasks(
-						&cmd->se_cmd, 1, 1);
+						&cmd->se_cmd, 1);
 			spin_lock(&cr->conn_recovery_cmd_lock);
 		}
 		spin_unlock(&cr->conn_recovery_cmd_lock);
@@ -175,7 +175,7 @@ void iscsit_free_connection_recovery_entires(struct iscsi_session *sess)
 				iscsit_release_cmd(cmd);
 			else
 				cmd->se_cmd.transport_wait_for_tasks(
-						&cmd->se_cmd, 1, 1);
+						&cmd->se_cmd, 1);
 			spin_lock(&cr->conn_recovery_cmd_lock);
 		}
 		spin_unlock(&cr->conn_recovery_cmd_lock);
@@ -265,7 +265,7 @@ void iscsit_discard_cr_cmds_by_expstatsn(
 			iscsit_release_cmd(cmd);
 		else
 			cmd->se_cmd.transport_wait_for_tasks(
-					&cmd->se_cmd, 1, 0);
+					&cmd->se_cmd, 1);
 		spin_lock(&cr->conn_recovery_cmd_lock);
 	}
 	spin_unlock(&cr->conn_recovery_cmd_lock);
@@ -324,7 +324,7 @@ int iscsit_discard_unacknowledged_ooo_cmdsns_for_conn(struct iscsi_conn *conn)
 			iscsit_release_cmd(cmd);
 		else
 			cmd->se_cmd.transport_wait_for_tasks(
-					&cmd->se_cmd, 1, 1);
+					&cmd->se_cmd, 1);
 		spin_lock_bh(&conn->cmd_lock);
 	}
 	spin_unlock_bh(&conn->cmd_lock);
@@ -383,7 +383,7 @@ int iscsit_prepare_cmds_for_realligance(struct iscsi_conn *conn)
 				iscsit_release_cmd(cmd);
 			else
 				cmd->se_cmd.transport_wait_for_tasks(
-						&cmd->se_cmd, 1, 0);
+						&cmd->se_cmd, 1);
 			spin_lock_bh(&conn->cmd_lock);
 			continue;
 		}
@@ -409,7 +409,7 @@ int iscsit_prepare_cmds_for_realligance(struct iscsi_conn *conn)
 				iscsit_release_cmd(cmd);
 			else
 				cmd->se_cmd.transport_wait_for_tasks(
-						&cmd->se_cmd, 1, 1);
+						&cmd->se_cmd, 1);
 			spin_lock_bh(&conn->cmd_lock);
 			continue;
 		}
@@ -436,8 +436,7 @@ int iscsit_prepare_cmds_for_realligance(struct iscsi_conn *conn)
 
 		if ((cmd->se_cmd.se_cmd_flags & SCF_SE_LUN_CMD) &&
 		     cmd->se_cmd.transport_wait_for_tasks)
-			cmd->se_cmd.transport_wait_for_tasks(&cmd->se_cmd,
-					0, 0);
+			cmd->se_cmd.transport_wait_for_tasks(&cmd->se_cmd, 0);
 		/*
 		 * Add the struct iscsi_cmd to the connection recovery cmd list
 		 */
diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
index 1008bc2..fe5063e 100644
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@ -86,7 +86,7 @@ static u32 transport_allocate_tasks(struct se_cmd *cmd,
 		enum dma_data_direction data_direction,
 		struct scatterlist *sgl, unsigned int nents);
 static int transport_generic_get_mem(struct se_cmd *cmd);
-static bool transport_put_cmd(struct se_cmd *cmd);
+static void transport_put_cmd(struct se_cmd *cmd);
 static void transport_remove_cmd_from_queue(struct se_cmd *cmd,
 		struct se_queue_obj *qobj);
 static int transport_set_sense_codes(struct se_cmd *cmd, u8 asc, u8 ascq);
@@ -1638,7 +1638,7 @@ static int transport_check_alloc_task_attr(struct se_cmd *cmd)
 	return 0;
 }
 
-static void transport_generic_wait_for_tasks(struct se_cmd *, int, int);
+static void transport_generic_wait_for_tasks(struct se_cmd *, int);
 
 /*	transport_generic_allocate_tasks():
  *
@@ -2504,7 +2504,7 @@ void transport_new_cmd_failure(struct se_cmd *se_cmd)
 	spin_unlock_irqrestore(&se_cmd->t_state_lock, flags);
 }
 
-static void transport_nop_wait_for_tasks(struct se_cmd *, int, int);
+static void transport_nop_wait_for_tasks(struct se_cmd *, int);
 
 static inline u32 transport_get_sectors_6(
 	unsigned char *cdb,
@@ -3746,7 +3746,7 @@ static inline void transport_free_pages(struct se_cmd *cmd)
  *
  * This routine releases our reference to the command and frees it if possible.
  */
-static bool transport_put_cmd(struct se_cmd *cmd)
+static void transport_put_cmd(struct se_cmd *cmd)
 {
 	unsigned long flags;
 	int free_tasks = 0;
@@ -3774,10 +3774,9 @@ static bool transport_put_cmd(struct se_cmd *cmd)
 
 	transport_free_pages(cmd);
 	transport_release_cmd(cmd);
-	return true;
+	return;
 out_busy:
 	spin_unlock_irqrestore(&cmd->t_state_lock, flags);
-	return false;
 }
 
 /*
@@ -4341,7 +4340,7 @@ void transport_release_cmd(struct se_cmd *cmd)
 }
 EXPORT_SYMBOL(transport_release_cmd);
 
-bool transport_generic_free_cmd(struct se_cmd *cmd, int wait_for_tasks)
+void transport_generic_free_cmd(struct se_cmd *cmd, int wait_for_tasks)
 {
 	if (!(cmd->se_cmd_flags & SCF_SE_LUN_CMD))
 		transport_release_cmd(cmd);
@@ -4352,21 +4351,18 @@ bool transport_generic_free_cmd(struct se_cmd *cmd, int wait_for_tasks)
 			transport_lun_remove_cmd(cmd);
 
 		if (wait_for_tasks && cmd->transport_wait_for_tasks)
-			cmd->transport_wait_for_tasks(cmd, 0, 0);
+			cmd->transport_wait_for_tasks(cmd, 0);
 
 		transport_free_dev_tasks(cmd);
 
-		return transport_put_cmd(cmd);
+		transport_put_cmd(cmd);
 	}
-
-	return true;
 }
 EXPORT_SYMBOL(transport_generic_free_cmd);
 
 static void transport_nop_wait_for_tasks(
 	struct se_cmd *cmd,
-	int remove_cmd,
-	int session_reinstatement)
+	int remove_cmd)
 {
 	return;
 }
@@ -4547,8 +4543,7 @@ int transport_clear_lun_from_sessions(struct se_lun *lun)
  */
 static void transport_generic_wait_for_tasks(
 	struct se_cmd *cmd,
-	int remove_cmd,
-	int session_reinstatement)
+	int remove_cmd)
 {
 	unsigned long flags;
 
@@ -4624,13 +4619,7 @@ remove:
 	if (!remove_cmd)
 		return;
 
-	if (!transport_generic_free_cmd(cmd, 0) && session_reinstatement) {
-		unsigned long flags;
-
-		spin_lock_irqsave(&cmd->t_state_lock, flags);
-		transport_all_task_dev_remove_state(cmd);
-		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
-	}
+	transport_generic_free_cmd(cmd, 0);
 }
 
 static int transport_get_sense_codes(
diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h
index db3f353..22cbc28 100644
--- a/include/target/target_core_base.h
+++ b/include/target/target_core_base.h
@@ -481,7 +481,7 @@ struct se_cmd {
 	struct target_core_fabric_ops *se_tfo;
 	int (*transport_emulate_cdb)(struct se_cmd *);
 	void (*transport_split_cdb)(unsigned long long, u32, unsigned char *);
-	void (*transport_wait_for_tasks)(struct se_cmd *, int, int);
+	void (*transport_wait_for_tasks)(struct se_cmd *, int);
 	void (*transport_complete_callback)(struct se_cmd *);
 	int (*transport_qf_callback)(struct se_cmd *);
 
diff --git a/include/target/target_core_transport.h b/include/target/target_core_transport.h
index a113129..e67feeb 100644
--- a/include/target/target_core_transport.h
+++ b/include/target/target_core_transport.h
@@ -184,7 +184,7 @@ extern int transport_check_aborted_status(struct se_cmd *, int);
 extern int transport_send_check_condition_and_sense(struct se_cmd *, u8, int);
 extern void transport_send_task_abort(struct se_cmd *);
 extern void transport_release_cmd(struct se_cmd *);
-extern bool transport_generic_free_cmd(struct se_cmd *, int);
+extern void transport_generic_free_cmd(struct se_cmd *, int);
 extern void transport_generic_wait_for_cmds(struct se_cmd *, int);
 extern int transport_init_task_sg(struct se_task *, struct se_mem *, u32);
 extern int transport_map_mem_to_sg(struct se_task *, struct list_head *,
-- 
1.7.4.2

