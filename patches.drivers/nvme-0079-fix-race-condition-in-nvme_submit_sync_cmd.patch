From: Jens Axboe <axboe@fb.com>
Date: Fri, 12 Dec 2014 08:53:40 -0700
Subject: NVMe: fix race condition in nvme_submit_sync_cmd()
References: bnc#936076,FATE#318544
Patch-Mainline: v3.20
Git-commit: 849c6e7746e4f6317ace6aa7d2fcdcd844e99ddb

If we have a race between the schedule timing out and the command
completing, we could have the task issuing the command exit
nvme_submit_sync_cmd() while the irq is running sync_completion().
If that happens, we could be corrupting memory, since the stack
that held 'cmdinfo' is no longer valid.

Fix this by always calling nvme_abort_cmd_info(). Once that call
completes, we know that we have either run sync_completion() if
the completion came in, or that we will never run it since we now
have special_completion() as the command callback handler.

Acked-by: Keith Busch <keith.busch@intel.com>
Signed-off-by: Jens Axboe <axboe@fb.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/block/nvme-core.c | 23 +++++++++++++++--------
 1 file changed, 15 insertions(+), 8 deletions(-)

diff --git a/drivers/block/nvme-core.c b/drivers/block/nvme-core.c
index 962c630..96569a1 100644
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@ -1035,17 +1035,24 @@ static int nvme_submit_sync_cmd(struct nvme_dev *dev, int q_idx,
 		return ret;
 	}
 	unlock_nvmeq(nvmeq);
-	schedule_timeout(timeout);
+	ret = schedule_timeout(timeout);
 
-	if (cmdinfo.status == -EINTR) {
-		nvmeq = lock_nvmeq(dev, q_idx);
-		if (nvmeq) {
-			nvme_abort_command(nvmeq, cmdid);
-			unlock_nvmeq(nvmeq);
-		}
-		return -EINTR;
+	/*
+	 * Ensure that sync_completion has either run, or that it will
+	 * never run.
+	 */
+	nvmeq = lock_nvmeq(dev, q_idx);
+	if (nvmeq) {
+		nvme_abort_command(nvmeq, cmdid);
+		unlock_nvmeq(nvmeq);
 	}
 
+	/*
+	 * We never got the completion
+	 */
+	if (cmdinfo.status == -EINTR)
+		return -EINTR;
+
 	if (result)
 		*result = cmdinfo.result;
 
-- 
1.8.5.2

