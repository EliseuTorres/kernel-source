From 1d38b5cb94161a413092bb98afd551ddbbaa6f9c Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Wed, 3 Dec 2014 17:24:00 +0200
Subject: [char-misc 05/11] mei: ME hardware reset needs to be synchronized
Git-commit: 68f8ea184bf7a552b59a38c4b0c7dc243822d2d5
Patch-mainline: 3.9-rc5
References: bnc#876086

commit 68f8ea184bf7a552b59a38c4b0c7dc243822d2d5 upstream

This fixes failure during initialization on Lynx Point LP devices.

ME driver needs to release the device from the reset
only after the FW has completed its flow and indicated
it by delivering an interrupt to the host.

This is the correct behavior for all the ME devices yet the
the previous versions are less susceptive to the implementation
that ignored FW reset completion indication.

We add mei_me_hw_reset_release function which is called
after reset from the interrupt thread or directly
from mei_reset during power down.

[Backport to v3.7: files were moved]

Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/misc/mei/init.c      |   22 ++++++++++++++++++----
 drivers/misc/mei/interrupt.c |    3 ++-
 drivers/misc/mei/mei_dev.h   |    1 +
 3 files changed, 21 insertions(+), 5 deletions(-)

--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -248,6 +248,21 @@ out:
 }
 
 /**
+ * mei_me_hw_reset_release - release device from the reset
+ *
+ * @dev: the device structure
+ */
+void mei_me_hw_reset_release(struct mei_device *dev)
+{
+	dev->host_hw_state = mei_hcsr_read(dev);
+
+	dev->host_hw_state &= ~H_RST;
+	dev->host_hw_state |= H_IG;
+
+	mei_hcsr_set(dev);
+}
+
+/**
  * mei_hw_reset - resets fw via mei csr register.
  *
  * @dev: the device structure
@@ -294,10 +309,9 @@ void mei_reset(struct mei_device *dev, i
 
 	mei_hw_reset(dev, interrupts_enabled);
 
-	dev->host_hw_state &= ~H_RST;
-	dev->host_hw_state |= H_IG;
-
-	mei_hcsr_set(dev);
+	if (dev->dev_state == MEI_DEV_DISABLED ||
+	    dev->dev_state == MEI_DEV_POWER_DOWN)
+		mei_me_hw_reset_release(dev);
 
 	dev_dbg(&dev->pdev->dev, "currently saved host_hw_state = 0x%08x.\n",
 	    dev->host_hw_state);
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -1499,7 +1499,8 @@ irqreturn_t mei_interrupt_thread_handler
 			mutex_unlock(&dev->device_lock);
 			return IRQ_HANDLED;
 		} else {
-			dev_dbg(&dev->pdev->dev, "FW not ready.\n");
+			dev_dbg(&dev->pdev->dev, "Reset Completed.\n");
+			mei_me_hw_reset_release(dev);
 			mutex_unlock(&dev->device_lock);
 			return IRQ_HANDLED;
 		}
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -288,6 +288,7 @@ struct mei_device {
 struct mei_device *mei_device_init(struct pci_dev *pdev);
 void mei_reset(struct mei_device *dev, int interrupts);
 int mei_hw_init(struct mei_device *dev);
+void mei_me_hw_reset_release(struct mei_device *dev);
 int mei_task_initialize_clients(void *data);
 int mei_initialize_clients(struct mei_device *dev);
 int mei_disconnect_host_client(struct mei_device *dev, struct mei_cl *cl);
