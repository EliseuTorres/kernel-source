From 4a4a11b98a39f479cdccef879635a72b0422049b Mon Sep 17 00:00:00 2001
From: Jayamohan Kallickal <jayamohank@gmail.com>
Date: Fri, 5 Apr 2013 20:38:31 -0700
Subject: [SCSI] be2iscsi : Fix the NOP-In handling code path
Git-commit: 4a4a11b98a39f479cdccef879635a72b0422049b
Patch-mainline: v3.10-rc1
References: FATE#317534 bsc#908901

When target send a NOP-IN with valid TTT, driver issues a NOP-OUT
and the task was not freed from driver. The task list available for
the session used to run out, and as no more task list were available
no more iSCSI commands were exchanged on that session.
This patches fixed the issue, by calling iscsi_put_task.

Signed-off-by: Minh Tran <minhduc.tran@emulex.com>
Signed-off-by: John Soni Jose <sony.john-n@emulex.com>
Signed-off-by: Jayamohan Kallickal <jayamohan.kallickal@emulex.com>
Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
Signed-off-by: James Bottomley <JBottomley@Parallels.com>
Acked-by: Lee Duncan <lduncan@suse.com>
---
 drivers/scsi/be2iscsi/be_iscsi.c |    3 ++-
 drivers/scsi/be2iscsi/be_main.c  |   11 ++++++-----
 drivers/scsi/be2iscsi/be_main.h  |    3 ++-
 3 files changed, 10 insertions(+), 7 deletions(-)

--- a/drivers/scsi/be2iscsi/be_iscsi.c
+++ b/drivers/scsi/be2iscsi/be_iscsi.c
@@ -1004,7 +1004,8 @@ static void beiscsi_free_ep(struct beisc
 
 	beiscsi_conn = beiscsi_ep->conn;
 	if (beiscsi_conn->login_in_progress) {
-		beiscsi_free_mgmt_task_handles(beiscsi_conn);
+		beiscsi_free_mgmt_task_handles(beiscsi_conn,
+					       beiscsi_conn->task);
 		beiscsi_conn->login_in_progress = 0;
 	}
 }
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -4064,11 +4064,13 @@ static void beiscsi_clean_port(struct be
 /**
  * beiscsi_free_mgmt_task_handles()- Free driver CXN resources
  * @beiscsi_conn: ptr to the conn to be cleaned up
+ * @task: ptr to iscsi_task resource to be freed.
  *
  * Free driver mgmt resources binded to CXN.
  **/
 void
-beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn)
+beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn,
+				struct iscsi_task *task)
 {
 	struct beiscsi_io_task *io_task;
 	struct beiscsi_hba *phba = beiscsi_conn->phba;
@@ -4079,7 +4081,7 @@ beiscsi_free_mgmt_task_handles(struct be
 	pwrb_context = &phwi_ctrlr->wrb_context
 		       [beiscsi_conn->beiscsi_conn_cid
 		       - phba->fw_config.iscsi_cid_start];
-	io_task = beiscsi_conn->task->dd_data;
+	io_task = task->dd_data;
 
 	if (io_task->pwrb_handle) {
 		memset(io_task->pwrb_handle->pwrb, 0,
@@ -4093,8 +4095,8 @@ beiscsi_free_mgmt_task_handles(struct be
 		spin_lock_bh(&phba->mgmt_sgl_lock);
 		free_mgmt_sgl_handle(phba,
 				     io_task->psgl_handle);
-		spin_unlock_bh(&phba->mgmt_sgl_lock);
 		io_task->psgl_handle = NULL;
+		spin_unlock_bh(&phba->mgmt_sgl_lock);
 	}
 
 	if (io_task->mtask_addr)
@@ -4144,7 +4146,7 @@ static void beiscsi_cleanup_task(struct
 		}
 	} else {
 		if (!beiscsi_conn->login_in_progress)
-			beiscsi_free_mgmt_task_handles(beiscsi_conn);
+			beiscsi_free_mgmt_task_handles(beiscsi_conn, task);
 	}
 }
 
@@ -4372,7 +4374,6 @@ int beiscsi_iotask_v2(struct iscsi_task
 	unsigned int doorbell = 0;
 
 	pwrb = io_task->pwrb_handle->pwrb;
-	memset(pwrb, 0, sizeof(*pwrb));
 
 	io_task->cmd_bhs->iscsi_hdr.exp_statsn = 0;
 	io_task->bhs_len = sizeof(struct be_cmd_bhs);
--- a/drivers/scsi/be2iscsi/be_main.h
+++ b/drivers/scsi/be2iscsi/be_main.h
@@ -753,7 +753,8 @@ void
 free_mgmt_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle);
 
 void beiscsi_process_all_cqs(struct work_struct *work);
-void beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn);
+void beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn,
+				     struct iscsi_task *task);
 
 static inline bool beiscsi_error(struct beiscsi_hba *phba)
 {
