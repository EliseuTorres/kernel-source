From: Shreyas Bhatewara <sbhatewara@vmware.com>
Date: Thu, 15 Jul 2010 21:51:14 +0000
Subject: [PATCH] net-next: vmxnet3 fixes [3/5] Initialize link state at probe
 time
References: bnc#624020
Patch-mainline: 2.6.36-rc2
Git-commit: 4a1745fc54e22e9fa928d72f97ee0e91449c9fd0

This change initializes the state of link at the time when driver is
loaded. The ethtool output for 'link detected' and 'link speed'
is thus valid even before the interface is brought up.

Signed-off-by: Shreyas Bhatewara <sbhatewara@vmware.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Brandon Philips <bphilips@suse.de>

---
 drivers/net/vmxnet3/vmxnet3_drv.c |   13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

Index: linux-2.6.32-SLE11-SP1/drivers/net/vmxnet3/vmxnet3_drv.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/net/vmxnet3/vmxnet3_drv.c
+++ linux-2.6.32-SLE11-SP1/drivers/net/vmxnet3/vmxnet3_drv.c
@@ -131,7 +131,7 @@ vmxnet3_tq_stop(struct vmxnet3_tx_queue
  * Check the link state. This may start or stop the tx queue.
  */
 static void
-vmxnet3_check_link(struct vmxnet3_adapter *adapter)
+vmxnet3_check_link(struct vmxnet3_adapter *adapter, bool affectTxQueue)
 {
 	u32 ret;
 
@@ -144,14 +144,16 @@ vmxnet3_check_link(struct vmxnet3_adapte
 		if (!netif_carrier_ok(adapter->netdev))
 			netif_carrier_on(adapter->netdev);
 
-		vmxnet3_tq_start(&adapter->tx_queue, adapter);
+		if (affectTxQueue)
+			vmxnet3_tq_start(&adapter->tx_queue, adapter);
 	} else {
 		printk(KERN_INFO "%s: NIC Link is Down\n",
 		       adapter->netdev->name);
 		if (netif_carrier_ok(adapter->netdev))
 			netif_carrier_off(adapter->netdev);
 
-		vmxnet3_tq_stop(&adapter->tx_queue, adapter);
+		if (affectTxQueue)
+			vmxnet3_tq_stop(&adapter->tx_queue, adapter);
 	}
 }
 
@@ -167,7 +169,7 @@ vmxnet3_process_events(struct vmxnet3_ad
 
 	/* Check if link state has changed */
 	if (events & VMXNET3_ECR_LINK)
-		vmxnet3_check_link(adapter);
+		vmxnet3_check_link(adapter, true);
 
 	/* Check if there is an error on xmit/recv queues */
 	if (events & (VMXNET3_ECR_TQERR | VMXNET3_ECR_RQERR)) {
@@ -1747,7 +1749,7 @@ vmxnet3_activate_dev(struct vmxnet3_adap
 	 * Check link state when first activating device. It will start the
 	 * tx queue if the link is up.
 	 */
-	vmxnet3_check_link(adapter);
+	vmxnet3_check_link(adapter, true);
 
 	napi_enable(&adapter->napi);
 	vmxnet3_enable_all_intrs(adapter);
@@ -2349,6 +2351,7 @@ vmxnet3_probe_device(struct pci_dev *pde
 	}
 
 	set_bit(VMXNET3_STATE_BIT_QUIESCED, &adapter->state);
+	vmxnet3_check_link(adapter, false);
 	atomic_inc(&devices_found);
 	return 0;
 
