From mcarlson@broadcom.com  Thu Jun 23 22:01:22 2011
From: Matt Carlson <mcarlson@broadcom.com>
Date: Wed, 22 Jun 2011 18:57:00 -0700
Subject: [PATCH 147/194] tg3: Add jumbo frame loopback tests to selftest
Git-commit: 4852a8614f63999e38539ad16615054dcd20a05d
Patch-mainline: v3.0-rc1
References: bnc#697783, FATE#311457

This patch adds jumbo frame loopback test support to the ethtool
selftest.

Signed-off-by: Matt Carlson <mcarlson@broadcom.com>
Reviewed-by: Michael Chan <mchan@broadcom.com>
Reviewed-by: Benjamin Li <benli@broadcom.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 drivers/net/tg3.c |   34 +++++++++++++++++++++++++---------
 1 files changed, 25 insertions(+), 9 deletions(-)

diff --git a/drivers/net/tg3.c b/drivers/net/tg3.c
index bda3e98..6606d5a 100644
--- a/drivers/net/tg3.c
+++ b/drivers/net/tg3.c
@@ -11022,7 +11022,7 @@ static int tg3_test_memory(struct tg3 *tp)
 #define TG3_MAC_LOOPBACK	0
 #define TG3_PHY_LOOPBACK	1
 
-static int tg3_run_loopback(struct tg3 *tp, int loopback_mode)
+static int tg3_run_loopback(struct tg3 *tp, u32 pktsz, int loopback_mode)
 {
 	u32 mac_mode, rx_start_idx, rx_idx, tx_idx, opaque_key;
 	u32 desc_idx, coal_now;
@@ -11120,7 +11120,7 @@ static int tg3_run_loopback(struct tg3 *tp, int loopback_mode)
 
 	err = -EIO;
 
-	tx_len = 1514;
+	tx_len = pktsz;
 	skb = netdev_alloc_skb(tp->dev, tx_len);
 	if (!skb)
 		return -ENOMEM;
@@ -11129,7 +11129,7 @@ static int tg3_run_loopback(struct tg3 *tp, int loopback_mode)
 	memcpy(tx_data, tp->dev->dev_addr, 6);
 	memset(tx_data + 6, 0x0, 8);
 
-	tw32(MAC_RX_MTU_SIZE, tx_len + 4);
+	tw32(MAC_RX_MTU_SIZE, tx_len + ETH_FCS_LEN);
 
 	for (i = 14; i < tx_len; i++)
 		tx_data[i] = (u8) (i & 0xff);
@@ -11185,8 +11185,6 @@ static int tg3_run_loopback(struct tg3 *tp, int loopback_mode)
 	desc = &rnapi->rx_rcb[rx_start_idx];
 	desc_idx = desc->opaque & RXD_OPAQUE_INDEX_MASK;
 	opaque_key = desc->opaque & RXD_OPAQUE_RING_MASK;
-	if (opaque_key != RXD_OPAQUE_RING_STD)
-		goto out;
 
 	if ((desc->err_vlan & RXD_ERR_MASK) != 0 &&
 	    (desc->err_vlan != RXD_ERR_ODD_NIBBLE_RCVD_MII))
@@ -11196,9 +11194,20 @@ static int tg3_run_loopback(struct tg3 *tp, int loopback_mode)
 	if (rx_len != tx_len)
 		goto out;
 
-	rx_skb = tpr->rx_std_buffers[desc_idx].skb;
+	if (pktsz <= TG3_RX_STD_DMA_SZ - ETH_FCS_LEN) {
+		if (opaque_key != RXD_OPAQUE_RING_STD)
+			goto out;
+
+		rx_skb = tpr->rx_std_buffers[desc_idx].skb;
+		map = dma_unmap_addr(&tpr->rx_std_buffers[desc_idx], mapping);
+	} else {
+		if (opaque_key != RXD_OPAQUE_RING_JUMBO)
+			goto out;
+
+		rx_skb = tpr->rx_jmb_buffers[desc_idx].skb;
+		map = dma_unmap_addr(&tpr->rx_jmb_buffers[desc_idx], mapping);
+	}
 
-	map = dma_unmap_addr(&tpr->rx_std_buffers[desc_idx], mapping);
 	pci_dma_sync_single_for_cpu(tp->pdev, map, rx_len, PCI_DMA_FROMDEVICE);
 
 	for (i = 14; i < tx_len; i++) {
@@ -11264,9 +11273,13 @@ static int tg3_test_loopback(struct tg3 *tp)
 				  CPMU_CTRL_LINK_AWARE_MODE));
 	}
 
-	if (tg3_run_loopback(tp, TG3_MAC_LOOPBACK))
+	if (tg3_run_loopback(tp, ETH_FRAME_LEN, TG3_MAC_LOOPBACK))
 		err |= TG3_MAC_LOOPBACK_FAILED;
 
+	if ((tp->tg3_flags & TG3_FLAG_JUMBO_RING_ENABLE) &&
+	    tg3_run_loopback(tp, 9000 + ETH_HLEN, TG3_MAC_LOOPBACK))
+		err |= (TG3_MAC_LOOPBACK_FAILED << 2);
+
 	if (tp->tg3_flags & TG3_FLAG_CPMU_PRESENT) {
 		tw32(TG3_CPMU_CTRL, cpmuctrl);
 
@@ -11276,8 +11289,11 @@ static int tg3_test_loopback(struct tg3 *tp)
 
 	if (!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&
 	    !(tp->tg3_flags3 & TG3_FLG3_USE_PHYLIB)) {
-		if (tg3_run_loopback(tp, TG3_PHY_LOOPBACK))
+		if (tg3_run_loopback(tp, ETH_FRAME_LEN, TG3_PHY_LOOPBACK))
 			err |= TG3_PHY_LOOPBACK_FAILED;
+		if ((tp->tg3_flags & TG3_FLAG_JUMBO_RING_ENABLE) &&
+		    tg3_run_loopback(tp, 9000 + ETH_HLEN, TG3_PHY_LOOPBACK))
+			err |= (TG3_PHY_LOOPBACK_FAILED << 2);
 	}
 
 	/* Re-enable gphy autopowerdown. */
-- 
1.7.3.4

