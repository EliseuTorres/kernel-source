From 6e55b7df0ebe0ee399f3b2b3b08cdef772258910 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Mon, 11 Mar 2013 18:27:03 +0200
Subject: [char-misc 07/11] mei: add hw start callback
Git-commit: aafae7ecd80181983403de13db0b4895acdc233d
Patch-mainline: 3.10-rc1
References: bnc#876086

commit aafae7ecd80181983403de13db0b4895acdc233d upstream

This callback wraps up hardware dependent details
of the hardware initialization.

This callback also contains host ready setting
so we can remove host_set_ready callback

In ME we switch to waiting on event so
we can streamline the initialization flow.

[Backport to v3.7 aggressive backport of this patch]

Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/misc/mei/init.c      |   42 +++++++++++++++++++++++++++++++++++++++---
 drivers/misc/mei/interrupt.c |   12 +++---------
 drivers/misc/mei/mei_dev.h   |    2 ++
 3 files changed, 44 insertions(+), 12 deletions(-)

--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -140,6 +140,7 @@ struct mei_device *mei_device_init(struc
 	INIT_LIST_HEAD(&dev->wd_cl.link);
 	INIT_LIST_HEAD(&dev->iamthif_cl.link);
 	mutex_init(&dev->device_lock);
+	init_waitqueue_head(&dev->wait_hw_ready);
 	init_waitqueue_head(&dev->wait_recvd_msg);
 	init_waitqueue_head(&dev->wait_stop_wd);
 	dev->dev_state = MEI_DEV_INITIALIZING;
@@ -279,6 +280,29 @@ static void mei_hw_reset(struct mei_devi
 }
 
 /**
+ * mei_me_hw_ready_wait - wait until the me(hw) has turned ready
+ * or timeout is reached
+ *
+ * @dev: mei device
+ * Return: 0 on success, error otherwise
+ */
+static int mei_hw_ready_wait(struct mei_device *dev)
+{
+	mutex_unlock(&dev->device_lock);
+	wait_event_timeout(dev->wait_hw_ready,
+			   dev->recvd_hw_ready,
+			   msecs_to_jiffies(2 * MSEC_PER_SEC));
+	mutex_lock(&dev->device_lock);
+	if (!dev->recvd_hw_ready) {
+		dev_err(&dev->pdev->dev, "wait hw ready failed\n");
+		return -ETIME;
+	}
+	dev->recvd_hw_ready = false;
+	return 0;
+}
+
+
+/**
  * mei_reset - resets host and fw.
  *
  * @dev: the device structure
@@ -309,9 +333,10 @@ void mei_reset(struct mei_device *dev, i
 
 	mei_hw_reset(dev, interrupts_enabled);
 
-	if (dev->dev_state == MEI_DEV_DISABLED ||
-	    dev->dev_state == MEI_DEV_POWER_DOWN)
-		mei_me_hw_reset_release(dev);
+	if (interrupts_enabled)
+		mei_hw_ready_wait(dev);
+
+	mei_me_hw_reset_release(dev);
 
 	dev_dbg(&dev->pdev->dev, "currently saved host_hw_state = 0x%08x.\n",
 	    dev->host_hw_state);
@@ -377,6 +402,17 @@ void mei_reset(struct mei_device *dev, i
 		list_del(&cb_pos->cb_list);
 		mei_free_cb_private(cb_pos);
 	}
+	if (!interrupts_enabled)
+		return;
+
+	dev->host_hw_state |= (H_IE | H_IG | H_RDY);
+	mei_hcsr_set(dev);
+	dev->dev_state = MEI_DEV_INIT_CLIENTS;
+	dev_dbg(&dev->pdev->dev, "link is established start sending messages.\n");
+	/* link is established
+	 * start sending messages.
+	 */
+	mei_host_start_message(dev);
 }
 
 
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -1488,19 +1488,13 @@ irqreturn_t mei_interrupt_thread_handler
 	if ((dev->host_hw_state & H_RDY) == 0) {
 		if ((dev->me_hw_state & ME_RDY_HRA) == ME_RDY_HRA) {
 			dev_dbg(&dev->pdev->dev, "we need to start the dev.\n");
-			dev->host_hw_state |= (H_IE | H_IG | H_RDY);
-			mei_hcsr_set(dev);
-			dev->dev_state = MEI_DEV_INIT_CLIENTS;
-			dev_dbg(&dev->pdev->dev, "link is established start sending messages.\n");
-			/* link is established
-			 * start sending messages.
-			 */
-			mei_host_start_message(dev);
+			dev->recvd_hw_ready = true;
+			wake_up(&dev->wait_hw_ready);
+
 			mutex_unlock(&dev->device_lock);
 			return IRQ_HANDLED;
 		} else {
 			dev_dbg(&dev->pdev->dev, "Reset Completed.\n");
-			mei_me_hw_reset_release(dev);
 			mutex_unlock(&dev->device_lock);
 			return IRQ_HANDLED;
 		}
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -221,6 +221,7 @@ struct mei_device {
 	struct mutex device_lock; /* device lock */
 	struct delayed_work timer_work;	/* MEI timer delayed work (timeouts) */
 	bool recvd_msg;
+	bool recvd_hw_ready;
 	/*
 	 * hw states of host and fw(ME)
 	 */
@@ -230,6 +231,7 @@ struct mei_device {
 	/*
 	 * waiting queue for receive message from FW
 	 */
+	wait_queue_head_t wait_hw_ready;
 	wait_queue_head_t wait_recvd_msg;
 	wait_queue_head_t wait_stop_wd;
 
