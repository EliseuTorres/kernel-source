From: Dan Williams <dan.j.williams@intel.com>
Date: Fri, 1 Jul 2011 10:52:55 -0700
Subject: [PATCH 268/273] isci: merge sata.[ch] into request.c
Git-commit: 16ba77091b44af28b3ff3318b4a2aa4fbf7d4c24
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Undo some needless separation.

Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/Makefile  |    2 +-
 drivers/scsi/isci/request.c |   71 +++++++------
 drivers/scsi/isci/request.h |    2 -
 drivers/scsi/isci/sata.c    |  232 -------------------------------------------
 drivers/scsi/isci/sata.h    |   79 ---------------
 drivers/scsi/isci/task.c    |  100 +++++++++++++++----
 drivers/scsi/isci/task.h    |   12 ---
 7 files changed, 120 insertions(+), 378 deletions(-)
 delete mode 100644 drivers/scsi/isci/sata.c
 delete mode 100644 drivers/scsi/isci/sata.h

diff --git a/drivers/scsi/isci/Makefile b/drivers/scsi/isci/Makefile
index 4244970..3359e10 100644
--- a/drivers/scsi/isci/Makefile
+++ b/drivers/scsi/isci/Makefile
@@ -1,5 +1,5 @@
 obj-$(CONFIG_SCSI_ISCI) += isci.o
-isci-objs := init.o phy.o request.o sata.o \
+isci-objs := init.o phy.o request.o \
 	     remote_device.o port.o \
 	     host.o task.o probe_roms.o \
 	     remote_node_context.o \
diff --git a/drivers/scsi/isci/request.c b/drivers/scsi/isci/request.c
index 7c500bb..33c8ed1 100644
--- a/drivers/scsi/isci/request.c
+++ b/drivers/scsi/isci/request.c
@@ -56,7 +56,6 @@
 #include "isci.h"
 #include "task.h"
 #include "request.h"
-#include "sata.h"
 #include "scu_completion_codes.h"
 #include "scu_event_codes.h"
 #include "sas.h"
@@ -1092,16 +1091,6 @@ smp_request_await_tc_event(struct isci_request *ireq,
 	return SCI_SUCCESS;
 }
 
-void sci_stp_io_request_set_ncq_tag(struct isci_request *ireq,
-				     u16 ncq_tag)
-{
-	/**
-	 * @note This could be made to return an error to the user if the user
-	 *       attempts to set the NCQ tag in the wrong state.
-	 */
-	ireq->tc->type.stp.ncq_tag = ncq_tag;
-}
-
 static struct scu_sgl_element *pio_sgl_next(struct isci_stp_request *stp_req)
 {
 	struct scu_sgl_element *sgl;
@@ -2410,6 +2399,29 @@ static void isci_task_save_for_upper_layer_completion(
 	}
 }
 
+static void isci_request_process_stp_response(struct sas_task *task,
+					      void *response_buffer)
+{
+	struct dev_to_host_fis *d2h_reg_fis = response_buffer;
+	struct task_status_struct *ts = &task->task_status;
+	struct ata_task_resp *resp = (void *)&ts->buf[0];
+
+	resp->frame_len = le16_to_cpu(*(__le16 *)(response_buffer + 6));
+	memcpy(&resp->ending_fis[0], response_buffer + 16, 24);
+	ts->buf_valid_size = sizeof(*resp);
+
+	/**
+	 * If the device fault bit is set in the status register, then
+	 * set the sense data and return.
+	 */
+	if (d2h_reg_fis->status & ATA_DF)
+		ts->stat = SAS_PROTO_RESPONSE;
+	else
+		ts->stat = SAM_STAT_GOOD;
+
+	ts->resp = SAS_TASK_COMPLETE;
+}
+
 static void isci_request_io_request_complete(struct isci_host *ihost,
 					     struct isci_request *request,
 					     enum sci_io_status completion_status)
@@ -2985,34 +2997,29 @@ static enum sci_status isci_request_ssp_request_construct(
 	return status;
 }
 
-static enum sci_status isci_request_stp_request_construct(
-	struct isci_request *request)
+static enum sci_status isci_request_stp_request_construct(struct isci_request *ireq)
 {
-	struct sas_task *task = isci_request_access_task(request);
+	struct sas_task *task = isci_request_access_task(ireq);
+	struct host_to_dev_fis *fis = &ireq->stp.cmd;
+	struct ata_queued_cmd *qc = task->uldd_task;
 	enum sci_status status;
-	struct host_to_dev_fis *register_fis;
 
-	dev_dbg(&request->isci_host->pdev->dev,
-		"%s: request = %p\n",
+	dev_dbg(&ireq->isci_host->pdev->dev,
+		"%s: ireq = %p\n",
 		__func__,
-		request);
-
-	/* Get the host_to_dev_fis from the core and copy
-	 * the fis from the task into it.
-	 */
-	register_fis = isci_sata_task_to_fis_copy(task);
+		ireq);
 
-	status = sci_io_request_construct_basic_sata(request);
+	memcpy(fis, &task->ata_task.fis, sizeof(struct host_to_dev_fis));
+	if (!task->ata_task.device_control_reg_update)
+		fis->flags |= 0x80;
+	fis->flags &= 0xF0;
 
-	/* Set the ncq tag in the fis, from the queue
-	 * command in the task.
-	 */
-	if (isci_sata_is_task_ncq(task)) {
+	status = sci_io_request_construct_basic_sata(ireq);
 
-		isci_sata_set_ncq_tag(
-			register_fis,
-			task
-			);
+	if (qc && (qc->tf.command == ATA_CMD_FPDMA_WRITE ||
+		   qc->tf.command == ATA_CMD_FPDMA_READ)) {
+		fis->sector_count = qc->tag << 3;
+		ireq->tc->type.stp.ncq_tag = qc->tag;
 	}
 
 	return status;
diff --git a/drivers/scsi/isci/request.h b/drivers/scsi/isci/request.h
index 5970840..11bc279 100644
--- a/drivers/scsi/isci/request.h
+++ b/drivers/scsi/isci/request.h
@@ -435,8 +435,6 @@ enum sci_status
 sci_task_request_construct_ssp(struct isci_request *ireq);
 enum sci_status
 sci_task_request_construct_sata(struct isci_request *ireq);
-void
-sci_stp_io_request_set_ncq_tag(struct isci_request *ireq, u16 ncq_tag);
 void sci_smp_request_copy_response(struct isci_request *ireq);
 
 static inline int isci_task_is_ncq_recovery(struct sas_task *task)
diff --git a/drivers/scsi/isci/sata.c b/drivers/scsi/isci/sata.c
deleted file mode 100644
index 47b96c2..0000000
--- a/drivers/scsi/isci/sata.c
+++ /dev/null
@@ -1,232 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <scsi/sas.h>
-#include "isci.h"
-#include "remote_device.h"
-#include "task.h"
-#include "request.h"
-#include "sata.h"
-
-/**
- * isci_sata_task_to_fis_copy() - This function gets the host_to_dev_fis from
- *    the core and copies the fis from the task into it.
- * @task: This parameter is a pointer to the task struct from libsas.
- *
- * pointer to the host_to_dev_fis from the core request object.
- */
-struct host_to_dev_fis *isci_sata_task_to_fis_copy(struct sas_task *task)
-{
-	struct isci_request *ireq = task->lldd_task;
-	struct host_to_dev_fis *fis = &ireq->stp.cmd;
-
-	memcpy(fis, &task->ata_task.fis, sizeof(struct host_to_dev_fis));
-
-	if (!task->ata_task.device_control_reg_update)
-		fis->flags |= 0x80;
-
-	fis->flags &= 0xF0;
-
-	return fis;
-}
-
-/**
- * isci_sata_is_task_ncq() - This function determines if the given stp task is
- *    a ncq request.
- * @task: This parameter is a pointer to the task struct from libsas.
- *
- * true if the task is ncq
- */
-bool isci_sata_is_task_ncq(struct sas_task *task)
-{
-	struct ata_queued_cmd *qc = task->uldd_task;
-
-	bool ret = (qc &&
-		    (qc->tf.command == ATA_CMD_FPDMA_WRITE ||
-		     qc->tf.command == ATA_CMD_FPDMA_READ));
-
-	return ret;
-}
-
-/**
- * isci_sata_set_ncq_tag() - This function sets the ncq tag field in the
- *    host_to_dev_fis equal to the tag in the queue command in the task.
- * @task: This parameter is a pointer to the task struct from libsas.
- * @register_fis: This parameter is a pointer to the host_to_dev_fis from the
- *    core request object.
- *
- */
-void isci_sata_set_ncq_tag(
-	struct host_to_dev_fis *register_fis,
-	struct sas_task *task)
-{
-	struct ata_queued_cmd *qc = task->uldd_task;
-	struct isci_request *request = task->lldd_task;
-
-	register_fis->sector_count = qc->tag << 3;
-	sci_stp_io_request_set_ncq_tag(request, qc->tag);
-}
-
-/**
- * isci_request_process_stp_response() - This function sets the status and
- *    response, in the task struct, from the request object for the upper layer
- *    driver.
- * @sas_task: This parameter is the task struct from the upper layer driver.
- * @response_buffer: This parameter points to the response of the completed
- *    request.
- *
- * none.
- */
-void isci_request_process_stp_response(struct sas_task *task,
-				       void *response_buffer)
-{
-	struct dev_to_host_fis *d2h_reg_fis = response_buffer;
-	struct task_status_struct *ts = &task->task_status;
-	struct ata_task_resp *resp = (void *)&ts->buf[0];
-
-	resp->frame_len = le16_to_cpu(*(__le16 *)(response_buffer + 6));
-	memcpy(&resp->ending_fis[0], response_buffer + 16, 24);
-	ts->buf_valid_size = sizeof(*resp);
-
-	/**
-	 * If the device fault bit is set in the status register, then
-	 * set the sense data and return.
-	 */
-	if (d2h_reg_fis->status & ATA_DF)
-		ts->stat = SAS_PROTO_RESPONSE;
-	else
-		ts->stat = SAM_STAT_GOOD;
-
-	ts->resp = SAS_TASK_COMPLETE;
-}
-
-enum sci_status isci_sata_management_task_request_build(struct isci_request *ireq)
-{
-	struct isci_tmf *isci_tmf;
-	enum sci_status status;
-
-	if (tmf_task != ireq->ttype)
-		return SCI_FAILURE;
-
-	isci_tmf = isci_request_access_tmf(ireq);
-
-	switch (isci_tmf->tmf_code) {
-
-	case isci_tmf_sata_srst_high:
-	case isci_tmf_sata_srst_low: {
-		struct host_to_dev_fis *fis = &ireq->stp.cmd;
-
-		memset(fis, 0, sizeof(*fis));
-
-		fis->fis_type  =  0x27;
-		fis->flags     &= ~0x80;
-		fis->flags     &= 0xF0;
-		if (isci_tmf->tmf_code == isci_tmf_sata_srst_high)
-			fis->control |= ATA_SRST;
-		else
-			fis->control &= ~ATA_SRST;
-		break;
-	}
-	/* other management commnd go here... */
-	default:
-		return SCI_FAILURE;
-	}
-
-	/* core builds the protocol specific request
-	 *  based on the h2d fis.
-	 */
-	status = sci_task_request_construct_sata(ireq);
-
-	return status;
-}
-
-/**
- * isci_task_send_lu_reset_sata() - This function is called by of the SAS
- *    Domain Template functions. This is one of the Task Management functoins
- *    called by libsas, to reset the given SAS lun. Note the assumption that
- *    while this call is executing, no I/O will be sent by the host to the
- *    device.
- * @lun: This parameter specifies the lun to be reset.
- *
- * status, zero indicates success.
- */
-int isci_task_send_lu_reset_sata(
-	struct isci_host *isci_host,
-	struct isci_remote_device *isci_device,
-	u8 *lun)
-{
-	struct isci_tmf tmf;
-	int ret = TMF_RESP_FUNC_FAILED;
-
-	/* Send the soft reset to the target */
-	#define ISCI_SRST_TIMEOUT_MS 25000 /* 25 second timeout. */
-	isci_task_build_tmf(&tmf, isci_tmf_sata_srst_high, NULL, NULL);
-
-	ret = isci_task_execute_tmf(isci_host, isci_device, &tmf,
-				    ISCI_SRST_TIMEOUT_MS);
-
-	if (ret != TMF_RESP_FUNC_COMPLETE) {
-		dev_warn(&isci_host->pdev->dev,
-			 "%s: Assert SRST failed (%p) = %x",
-			 __func__,
-			 isci_device,
-			 ret);
-
-		/* Return the failure so that the LUN reset is escalated
-		 * to a target reset.
-		 */
-	}
-	return ret;
-}
diff --git a/drivers/scsi/isci/sata.h b/drivers/scsi/isci/sata.h
deleted file mode 100644
index 1b89f1f..0000000
--- a/drivers/scsi/isci/sata.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-struct host_to_dev_fis *isci_sata_task_to_fis_copy(
-	struct sas_task *task);
-
-bool isci_sata_is_task_ncq(
-	struct sas_task *task);
-
-void isci_sata_set_ncq_tag(
-	struct host_to_dev_fis *register_fis,
-	struct sas_task *task);
-
-void isci_request_process_stp_response(
-	struct sas_task *task,
-	void *response_buffer);
-
-u8 isci_sata_get_sat_protocol(
-	struct isci_request *isci_request);
-
-enum sci_status isci_sata_management_task_request_build(
-	struct isci_request *isci_request);
-
-int isci_task_send_lu_reset_sata(
-	struct isci_host *isci_host,
-	struct isci_remote_device *isci_device,
-	u8 *lun);
diff --git a/drivers/scsi/isci/task.c b/drivers/scsi/isci/task.c
index 20112cd..5d962b6 100644
--- a/drivers/scsi/isci/task.c
+++ b/drivers/scsi/isci/task.c
@@ -61,7 +61,6 @@
 #include "remote_node_context.h"
 #include "isci.h"
 #include "request.h"
-#include "sata.h"
 #include "task.h"
 #include "host.h"
 
@@ -238,6 +237,46 @@ int isci_task_execute_task(struct sas_task *task, int num, gfp_t gfp_flags)
 	return 0;
 }
 
+static enum sci_status isci_sata_management_task_request_build(struct isci_request *ireq)
+{
+	struct isci_tmf *isci_tmf;
+	enum sci_status status;
+
+	if (tmf_task != ireq->ttype)
+		return SCI_FAILURE;
+
+	isci_tmf = isci_request_access_tmf(ireq);
+
+	switch (isci_tmf->tmf_code) {
+
+	case isci_tmf_sata_srst_high:
+	case isci_tmf_sata_srst_low: {
+		struct host_to_dev_fis *fis = &ireq->stp.cmd;
+
+		memset(fis, 0, sizeof(*fis));
+
+		fis->fis_type  =  0x27;
+		fis->flags     &= ~0x80;
+		fis->flags     &= 0xF0;
+		if (isci_tmf->tmf_code == isci_tmf_sata_srst_high)
+			fis->control |= ATA_SRST;
+		else
+			fis->control &= ~ATA_SRST;
+		break;
+	}
+	/* other management commnd go here... */
+	default:
+		return SCI_FAILURE;
+	}
+
+	/* core builds the protocol specific request
+	 *  based on the h2d fis.
+	 */
+	status = sci_task_request_construct_sata(ireq);
+
+	return status;
+}
+
 static struct isci_request *isci_task_request_build(struct isci_host *ihost,
 						    struct isci_remote_device *idev,
 						    u16 tag, struct isci_tmf *isci_tmf)
@@ -287,9 +326,9 @@ static struct isci_request *isci_task_request_build(struct isci_host *ihost,
 	return ireq;
 }
 
-int isci_task_execute_tmf(struct isci_host *ihost,
-			  struct isci_remote_device *idev,
-			  struct isci_tmf *tmf, unsigned long timeout_ms)
+static int isci_task_execute_tmf(struct isci_host *ihost,
+				 struct isci_remote_device *idev,
+				 struct isci_tmf *tmf, unsigned long timeout_ms)
 {
 	DECLARE_COMPLETION_ONSTACK(completion);
 	enum sci_task_status status = SCI_TASK_FAILURE;
@@ -401,13 +440,12 @@ int isci_task_execute_tmf(struct isci_host *ihost,
 	return ret;
 }
 
-void isci_task_build_tmf(
-	struct isci_tmf *tmf,
-	enum isci_tmf_function_codes code,
-	void (*tmf_sent_cb)(enum isci_tmf_cb_state,
-			    struct isci_tmf *,
-			    void *),
-	void *cb_data)
+static void isci_task_build_tmf(struct isci_tmf *tmf,
+				enum isci_tmf_function_codes code,
+				void (*tmf_sent_cb)(enum isci_tmf_cb_state,
+						    struct isci_tmf *,
+						    void *),
+				void *cb_data)
 {
 	memset(tmf, 0, sizeof(*tmf));
 
@@ -416,16 +454,14 @@ void isci_task_build_tmf(
 	tmf->cb_data       = cb_data;
 }
 
-static void isci_task_build_abort_task_tmf(
-	struct isci_tmf *tmf,
-	enum isci_tmf_function_codes code,
-	void (*tmf_sent_cb)(enum isci_tmf_cb_state,
-			    struct isci_tmf *,
-			    void *),
-	struct isci_request *old_request)
+static void isci_task_build_abort_task_tmf(struct isci_tmf *tmf,
+					   enum isci_tmf_function_codes code,
+					   void (*tmf_sent_cb)(enum isci_tmf_cb_state,
+							       struct isci_tmf *,
+							       void *),
+					   struct isci_request *old_request)
 {
-	isci_task_build_tmf(tmf, code, tmf_sent_cb,
-			    (void *)old_request);
+	isci_task_build_tmf(tmf, code, tmf_sent_cb, old_request);
 	tmf->io_tag = old_request->io_tag;
 }
 
@@ -804,6 +840,30 @@ static int isci_task_send_lu_reset_sas(
 	return ret;
 }
 
+static int isci_task_send_lu_reset_sata(struct isci_host *ihost,
+				 struct isci_remote_device *idev, u8 *lun)
+{
+	int ret = TMF_RESP_FUNC_FAILED;
+	struct isci_tmf tmf;
+
+	/* Send the soft reset to the target */
+	#define ISCI_SRST_TIMEOUT_MS 25000 /* 25 second timeout. */
+	isci_task_build_tmf(&tmf, isci_tmf_sata_srst_high, NULL, NULL);
+
+	ret = isci_task_execute_tmf(ihost, idev, &tmf, ISCI_SRST_TIMEOUT_MS);
+
+	if (ret != TMF_RESP_FUNC_COMPLETE) {
+		dev_warn(&ihost->pdev->dev,
+			 "%s: Assert SRST failed (%p) = %x",
+			 __func__, idev, ret);
+
+		/* Return the failure so that the LUN reset is escalated
+		 * to a target reset.
+		 */
+	}
+	return ret;
+}
+
 /**
  * isci_task_lu_reset() - This function is one of the SAS Domain Template
  *    functions. This is one of the Task Management functoins called by libsas,
diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 42019de..4a7fa90 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -211,18 +211,6 @@ int isci_queuecommand(
 
 int isci_bus_reset_handler(struct scsi_cmnd *cmd);
 
-void isci_task_build_tmf(
-	struct isci_tmf *tmf,
-	enum isci_tmf_function_codes code,
-	void (*tmf_sent_cb)(enum isci_tmf_cb_state,
-			    struct isci_tmf *,
-			    void *),
-	void *cb_data);
-
-int isci_task_execute_tmf(struct isci_host *isci_host,
-			  struct isci_remote_device *idev,
-			  struct isci_tmf *tmf, unsigned long timeout_ms);
-
 /**
  * enum isci_completion_selection - This enum defines the possible actions to
  *    take with respect to a given request's notification back to libsas.
-- 
1.6.0.2

