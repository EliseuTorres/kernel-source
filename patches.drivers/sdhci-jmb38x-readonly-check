From: Takashi Iwai <tiwai@suse.de>
Subject: [PATCH v2] mmc: Fix read-only detection with JMicron 388 chip
Patch-mainline: Submitted
References: bnc#686980

On HP laptops with JMicron 388 chip, the write-locked SD card isn't
detected correctly as read-only in many cases.  This is because the
PRESENT_STATE register becomes unsable just after plugging, and it
returns the WRITE_PROTECT bit wrongly at the first read.

This patch fixes the read-only detection by adding a new sdhci quirk
indicating to check the register more intensively with a relatively
long delay.

The patch is tested with 2.6.39-rc4 kernel.

Cc: Aries Lee <arieslee@jmicron.com>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/mmc/host/sdhci-pci.c |    3 +++
 drivers/mmc/host/sdhci.c     |   40 +++++++++++++++++++++++++++++-----------
 drivers/mmc/host/sdhci.h     |    2 ++
 3 files changed, 34 insertions(+), 11 deletions(-)

--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1173,26 +1173,44 @@
 	spin_unlock_irqrestore(&host->lock, flags);
 }
 
-static int sdhci_get_ro(struct mmc_host *mmc)
+static int check_ro(struct sdhci_host *host)
 {
-	struct sdhci_host *host;
 	unsigned long flags;
 	int present;
 
-	host = mmc_priv(mmc);
-
 	spin_lock_irqsave(&host->lock, flags);
+	present = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	spin_unlock_irqrestore(&host->lock, flags);
+	present = !(present & SDHCI_WRITE_PROTECT);
+	if (host->quirks & SDHCI_QUIRK_INVERTED_WRITE_PROTECT)
+		present = !present;
+	return present;
+}
+
+#define SAMPLE_COUNT	5
+
+static int sdhci_get_ro(struct mmc_host *mmc)
+{
+	struct sdhci_host *host;
+	int i, ro_count;
+
+	host = mmc_priv(mmc);
 
 	if (host->flags & SDHCI_DEVICE_DEAD)
-		present = 0;
-	else
-		present = sdhci_readl(host, SDHCI_PRESENT_STATE);
+		return 0;
 
-	spin_unlock_irqrestore(&host->lock, flags);
+	if (!(host->quirks & SDHCI_QUIRK_UNSTABLE_RO_DETECT))
+		return check_ro(host);
 
-	if (host->quirks & SDHCI_QUIRK_INVERTED_WRITE_PROTECT)
-		return !!(present & SDHCI_WRITE_PROTECT);
-	return !(present & SDHCI_WRITE_PROTECT);
+	ro_count = 0;
+	for (i = 0; i < SAMPLE_COUNT; i++) {
+		if (check_ro(host)) {
+			if (++ro_count > SAMPLE_COUNT / 2)
+				return 1;
+		}
+		msleep(30);
+	}
+	return 0;
 }
 
 static void sdhci_enable_sdio_irq(struct mmc_host *mmc, int enable)
--- a/drivers/mmc/host/sdhci-pci.c
+++ b/drivers/mmc/host/sdhci-pci.c
@@ -201,6 +201,9 @@
 	if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)
 		chip->quirks |= SDHCI_QUIRK_MMC_VDD_180;
 
+	/* unsable RO-detection */
+	chip->quirks |= SDHCI_QUIRK_UNSTABLE_RO_DETECT;
+
 	return 0;
 }
 
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -237,6 +237,8 @@
 #define SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK		(1<<24)
 /* Controller doesn't support VDD 180 for MMC (for SD/MMC combo chips) */
 #define SDHCI_QUIRK_MMC_VDD_180				(1<<30)
+/* The read-only detection via SDHCI_PRESENT_STATE register is unstable */
+#define SDHCI_QUIRK_UNSTABLE_RO_DETECT			(1<<31)
 
 	int			irq;		/* Device IRQ */
 	void __iomem *		ioaddr;		/* Mapped address */
