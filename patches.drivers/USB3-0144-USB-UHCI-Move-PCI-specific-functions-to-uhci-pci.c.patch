From c31a65f869f7b8a7039007411c76d7b6f9a63323 Mon Sep 17 00:00:00 2001
From: Jan Andersson <jan@gaisler.com>
Date: Fri, 6 May 2011 12:00:15 +0200
Subject: USB: UHCI: Move PCI specific functions to uhci-pci.c
Patch-mainline: v3.0
Git-commit: c31a65f869f7b8a7039007411c76d7b6f9a63323

This patch is part of a series that extend the UHCI HCD to support
non-PCI controllers.

This patch moves PCI specific functions to uhci-pci.c and includes
this file in uhci-hcd.c. It also renames the function uhci_init to
uhci_pci_init.

uhci_init/uhci_pci_init is modified so that the port-detection logic
is kept in a new separate function uhci_count_ports() in uhci-hcd.c.

Signed-off-by: Jan Andersson <jan@gaisler.com>
Acked-by: Alan Stern <stern@rowland.harvard.edu>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

---
 drivers/usb/host/uhci-hcd.c |  327 ++++----------------------------------------
 drivers/usb/host/uhci-pci.c |  296 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 331 insertions(+), 292 deletions(-)

--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -48,7 +48,6 @@
 #include <asm/system.h>
 
 #include "uhci-hcd.h"
-#include "pci-quirks.h"
 
 /*
  * Version Information
@@ -143,15 +142,6 @@ static void finish_reset(struct uhci_hcd
 }
 
 /*
- * Make sure the controller is completely inactive, unable to
- * generate interrupts or do DMA.
- */
-static void uhci_pci_reset_hc(struct uhci_hcd *uhci)
-{
-	uhci_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci->io_addr);
-}
-
-/*
  * Last rites for a defunct/nonfunctional controller
  * or one we don't want to use any more.
  */
@@ -167,18 +157,6 @@ static void uhci_hc_died(struct uhci_hcd
 }
 
 /*
- * Initialize a controller that was newly discovered or has just been
- * resumed.  In either case we can't be sure of its previous state.
- *
- * Returns: 1 if the controller was reset, 0 otherwise.
- */
-static int uhci_pci_check_and_reset_hc(struct uhci_hcd *uhci)
-{
-	return uhci_check_and_reset_hc(to_pci_dev(uhci_dev(uhci)),
-				uhci->io_addr);
-}
-
-/*
  * Initialize a controller that was newly discovered or has lost power
  * or otherwise been reset while it was suspended.  In none of these cases
  * can we be sure of its previous state.
@@ -189,14 +167,6 @@ static void check_and_reset_hc(struct uh
 		finish_reset(uhci);
 }
 
-static void uhci_pci_configure_hc(struct uhci_hcd *uhci)
-{
-	struct pci_dev *pdev = to_pci_dev(uhci_dev(uhci));
-
-	/* Enable PIRQ */
-	pci_write_config_word(pdev, USBLEGSUP, USBLEGSUP_DEFAULT);
-}
-
 /*
  * Store the basic register settings needed by the controller.
  */
@@ -218,38 +188,6 @@ static void configure_hc(struct uhci_hcd
 }
 
 
-static int uhci_pci_resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
-{
-	int port;
-
-	switch (to_pci_dev(uhci_dev(uhci))->vendor) {
-	default:
-		break;
-
-	case PCI_VENDOR_ID_GENESYS:
-		/* Genesys Logic's GL880S controllers don't generate
-		 * resume-detect interrupts.
-		 */
-		return 1;
-
-	case PCI_VENDOR_ID_INTEL:
-		/* Some of Intel's USB controllers have a bug that causes
-		 * resume-detect interrupts if any port has an over-current
-		 * condition.  To make matters worse, some motherboards
-		 * hardwire unused USB ports' over-current inputs active!
-		 * To prevent problems, we will not enable resume-detect
-		 * interrupts if any ports are OC.
-		 */
-		for (port = 0; port < uhci->rh_numports; ++port) {
-			if (inw(uhci->io_addr + USBPORTSC1 + port * 2) &
-					USBPORTSC_OC)
-				return 1;
-		}
-		break;
-	}
-	return 0;
-}
-
 static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 {
 	/* If we have to ignore overcurrent events then almost by definition
@@ -261,28 +199,6 @@ static int resume_detect_interrupts_are_
 		uhci->resume_detect_interrupts_are_broken(uhci) : 0;
 }
 
-static int uhci_pci_global_suspend_mode_is_broken(struct uhci_hcd *uhci)
-{
-	int port;
-	const char *sys_info;
-	static const char bad_Asus_board[] = "A7V8X";
-
-	/* One of Asus's motherboards has a bug which causes it to
-	 * wake up immediately from suspend-to-RAM if any of the ports
-	 * are connected.  In such cases we will not set EGSM.
-	 */
-	sys_info = dmi_get_system_info(DMI_BOARD_NAME);
-	if (sys_info && !strcmp(sys_info, bad_Asus_board)) {
-		for (port = 0; port < uhci->rh_numports; ++port) {
-			if (inw(uhci->io_addr + USBPORTSC1 + port * 2) &
-					USBPORTSC_CCS)
-				return 1;
-		}
-	}
-
-	return 0;
-}
-
 static int global_suspend_mode_is_broken(struct uhci_hcd *uhci)
 {
 	return uhci->global_suspend_mode_is_broken ?
@@ -548,82 +464,6 @@ static void release_uhci(struct uhci_hcd
 			uhci->frame, uhci->frame_dma_handle);
 }
 
-static int uhci_init(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned io_size = (unsigned) hcd->rsrc_len;
-	int port;
-
-	uhci->io_addr = (unsigned long) hcd->rsrc_start;
-
-	/* The UHCI spec says devices must have 2 ports, and goes on to say
-	 * they may have more but gives no way to determine how many there
-	 * are.  However according to the UHCI spec, Bit 7 of the port
-	 * status and control register is always set to 1.  So we try to
-	 * use this to our advantage.  Another common failure mode when
-	 * a nonexistent register is addressed is to return all ones, so
-	 * we test for that also.
-	 */
-	for (port = 0; port < (io_size - USBPORTSC1) / 2; port++) {
-		unsigned int portstatus;
-
-		portstatus = inw(uhci->io_addr + USBPORTSC1 + (port * 2));
-		if (!(portstatus & 0x0080) || portstatus == 0xffff)
-			break;
-	}
-	if (debug)
-		dev_info(uhci_dev(uhci), "detected %d ports\n", port);
-
-	/* Anything greater than 7 is weird so we'll ignore it. */
-	if (port > UHCI_RH_MAXCHILD) {
-		dev_info(uhci_dev(uhci), "port count misdetected? "
-				"forcing to 2 ports\n");
-		port = 2;
-	}
-	uhci->rh_numports = port;
-
-	/* Intel controllers report the OverCurrent bit active on.
-	 * VIA controllers report it active off, so we'll adjust the
-	 * bit value.  (It's not standardized in the UHCI spec.)
-	 */
-	if (to_pci_dev(uhci_dev(uhci))->vendor == PCI_VENDOR_ID_VIA)
-		uhci->oc_low = 1;
-
-	/* HP's server management chip requires a longer port reset delay. */
-	if (to_pci_dev(uhci_dev(uhci))->vendor == PCI_VENDOR_ID_HP)
-		uhci->wait_for_hp = 1;
-
-	/* Set up pointers to PCI-specific functions */
-	uhci->reset_hc = uhci_pci_reset_hc;
-	uhci->check_and_reset_hc = uhci_pci_check_and_reset_hc;
-	uhci->configure_hc = uhci_pci_configure_hc;
-	uhci->resume_detect_interrupts_are_broken =
-		uhci_pci_resume_detect_interrupts_are_broken;
-	uhci->global_suspend_mode_is_broken =
-		uhci_pci_global_suspend_mode_is_broken;
-
-
-	/* Kick BIOS off this hardware and reset if the controller
-	 * isn't already safely quiescent.
-	 */
-	check_and_reset_hc(uhci);
-	return 0;
-}
-
-/* Make sure the controller is quiescent and that we're not using it
- * any more.  This is mainly for the benefit of programs which, like kexec,
- * expect the hardware to be idle: not doing DMA or generating IRQs.
- *
- * This routine may be called in a damaged or failing kernel.  Hence we
- * do not acquire the spinlock before shutting down the controller.
- */
-static void uhci_shutdown(struct pci_dev *pdev)
-{
-	struct usb_hcd *hcd = pci_get_drvdata(pdev);
-
-	uhci_hc_died(hcd_to_uhci(hcd));
-}
-
 /*
  * Allocate a frame list, and then setup the skeleton
  *
@@ -840,86 +680,6 @@ static int uhci_rh_resume(struct usb_hcd
 	return rc;
 }
 
-static int uhci_pci_suspend(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	int rc = 0;
-
-	dev_dbg(uhci_dev(uhci), "%s\n", __func__);
-
-	spin_lock_irq(&uhci->lock);
-	if (!HCD_HW_ACCESSIBLE(hcd) || uhci->dead)
-		goto done_okay;		/* Already suspended or dead */
-
-	if (uhci->rh_state > UHCI_RH_SUSPENDED) {
-		dev_warn(uhci_dev(uhci), "Root hub isn't suspended!\n");
-		rc = -EBUSY;
-		goto done;
-	};
-
-	/* All PCI host controllers are required to disable IRQ generation
-	 * at the source, so we must turn off PIRQ.
-	 */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
-	mb();
-	clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
-
-	/* FIXME: Enable non-PME# remote wakeup? */
-
-done_okay:
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-done:
-	spin_unlock_irq(&uhci->lock);
-	return rc;
-}
-
-static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-
-	dev_dbg(uhci_dev(uhci), "%s\n", __func__);
-
-	/* Since we aren't in D3 any more, it's safe to set this flag
-	 * even if the controller was dead.
-	 */
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
-	mb();
-
-	spin_lock_irq(&uhci->lock);
-
-	/* Make sure resume from hibernation re-enumerates everything */
-	if (hibernated) {
-		uhci->reset_hc(uhci);
-		finish_reset(uhci);
-	}
-
-	/* The firmware may have changed the controller settings during
-	 * a system wakeup.  Check it and reconfigure to avoid problems.
- 	 */
-	else {
-		check_and_reset_hc(uhci);
-	}
-	configure_hc(uhci);
-
-	if (uhci->rh_state == UHCI_RH_RESET) {
-
-		/* The controller had to be reset */
-		usb_root_hub_lost_power(hcd->self.root_hub);
-		suspend_rh(uhci, UHCI_RH_SUSPENDED);
-	}
-
-	spin_unlock_irq(&uhci->lock);
-	synchronize_irq(hcd->irq);
-
-	/* If interrupts don't work and remote wakeup is enabled then
-	 * the suspended root hub needs to be polled.
-	 */
-	if (!uhci->RD_enable && hcd->self.root_hub->do_remote_wakeup) {
-		set_bit(HCD_FLAG_POLL_RH, &hcd->flags);
-		usb_hcd_poll_rh_status(hcd);
-	}
-	return 0;
-}
 #endif
 
 /* Wait until a particular device/endpoint's QH is idle, and free it */
@@ -962,62 +722,45 @@ static int uhci_hcd_get_frame_number(str
 	return frame_number + delta;
 }
 
-static const char hcd_name[] = "uhci_hcd";
+/* Determines number of ports on controller */
+static int uhci_count_ports(struct usb_hcd *hcd)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	unsigned io_size = (unsigned) hcd->rsrc_len;
+	int port;
 
-static const struct hc_driver uhci_driver = {
-	.description =		hcd_name,
-	.product_desc =		"UHCI Host Controller",
-	.hcd_priv_size =	sizeof(struct uhci_hcd),
-
-	/* Generic hardware linkage */
-	.irq =			uhci_irq,
-	.flags =		HCD_USB11,
-
-	/* Basic lifecycle operations */
-	.reset =		uhci_init,
-	.start =		uhci_start,
-#ifdef CONFIG_PM
-	.pci_suspend =		uhci_pci_suspend,
-	.pci_resume =		uhci_pci_resume,
-	.bus_suspend =		uhci_rh_suspend,
-	.bus_resume =		uhci_rh_resume,
-#endif
-	.stop =			uhci_stop,
+	/* The UHCI spec says devices must have 2 ports, and goes on to say
+	 * they may have more but gives no way to determine how many there
+	 * are.  However according to the UHCI spec, Bit 7 of the port
+	 * status and control register is always set to 1.  So we try to
+	 * use this to our advantage.  Another common failure mode when
+	 * a nonexistent register is addressed is to return all ones, so
+	 * we test for that also.
+	 */
+	for (port = 0; port < (io_size - USBPORTSC1) / 2; port++) {
+		unsigned int portstatus;
+
+		portstatus = inw(uhci->io_addr + USBPORTSC1 + (port * 2));
+		if (!(portstatus & 0x0080) || portstatus == 0xffff)
+			break;
+	}
+	if (debug)
+		dev_info(uhci_dev(uhci), "detected %d ports\n", port);
+
+	/* Anything greater than 7 is weird so we'll ignore it. */
+	if (port > UHCI_RH_MAXCHILD) {
+		dev_info(uhci_dev(uhci), "port count misdetected? "
+				"forcing to 2 ports\n");
+		port = 2;
+	}
 
-	.urb_enqueue =		uhci_urb_enqueue,
-	.urb_dequeue =		uhci_urb_dequeue,
+	return port;
+}
 
-	.endpoint_disable =	uhci_hcd_endpoint_disable,
-	.get_frame_number =	uhci_hcd_get_frame_number,
+static const char hcd_name[] = "uhci_hcd";
+
+#include "uhci-pci.c"
 
-	.hub_status_data =	uhci_hub_status_data,
-	.hub_control =		uhci_hub_control,
-};
-
-static DEFINE_PCI_DEVICE_TABLE(uhci_pci_ids) = { {
-	/* handle any USB UHCI controller */
-	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_UHCI, ~0),
-	.driver_data =	(unsigned long) &uhci_driver,
-	}, { /* end: all zeroes */ }
-};
-
-MODULE_DEVICE_TABLE(pci, uhci_pci_ids);
-
-static struct pci_driver uhci_pci_driver = {
-	.name =		(char *)hcd_name,
-	.id_table =	uhci_pci_ids,
-
-	.probe =	usb_hcd_pci_probe,
-	.remove =	usb_hcd_pci_remove,
-	.shutdown =	uhci_shutdown,
-
-#ifdef CONFIG_PM_SLEEP
-	.driver =	{
-		.pm =	&usb_hcd_pci_pm_ops
-	},
-#endif
-};
- 
 static int __init uhci_hcd_init(void)
 {
 	int retval = -ENOMEM;
--- /dev/null
+++ b/drivers/usb/host/uhci-pci.c
@@ -0,0 +1,296 @@
+/*
+ * UHCI HCD (Host Controller Driver) PCI Bus Glue.
+ *
+ * Extracted from uhci-hcd.c:
+ * Maintainer: Alan Stern <stern@rowland.harvard.edu>
+ *
+ * (C) Copyright 1999 Linus Torvalds
+ * (C) Copyright 1999-2002 Johannes Erdfelt, johannes@erdfelt.com
+ * (C) Copyright 1999 Randy Dunlap
+ * (C) Copyright 1999 Georg Acher, acher@in.tum.de
+ * (C) Copyright 1999 Deti Fliegl, deti@fliegl.de
+ * (C) Copyright 1999 Thomas Sailer, sailer@ife.ee.ethz.ch
+ * (C) Copyright 1999 Roman Weissgaerber, weissg@vienna.at
+ * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
+ *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
+ * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
+ * (C) Copyright 2004-2007 Alan Stern, stern@rowland.harvard.edu
+ */
+
+#include "pci-quirks.h"
+
+/*
+ * Make sure the controller is completely inactive, unable to
+ * generate interrupts or do DMA.
+ */
+static void uhci_pci_reset_hc(struct uhci_hcd *uhci)
+{
+	uhci_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci->io_addr);
+}
+
+/*
+ * Initialize a controller that was newly discovered or has just been
+ * resumed.  In either case we can't be sure of its previous state.
+ *
+ * Returns: 1 if the controller was reset, 0 otherwise.
+ */
+static int uhci_pci_check_and_reset_hc(struct uhci_hcd *uhci)
+{
+	return uhci_check_and_reset_hc(to_pci_dev(uhci_dev(uhci)),
+				uhci->io_addr);
+}
+
+/*
+ * Store the basic register settings needed by the controller.
+ * This function is called at the end of configure_hc in uhci-hcd.c.
+ */
+static void uhci_pci_configure_hc(struct uhci_hcd *uhci)
+{
+	struct pci_dev *pdev = to_pci_dev(uhci_dev(uhci));
+
+	/* Enable PIRQ */
+	pci_write_config_word(pdev, USBLEGSUP, USBLEGSUP_DEFAULT);
+}
+
+static int uhci_pci_resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
+{
+	int port;
+
+	switch (to_pci_dev(uhci_dev(uhci))->vendor) {
+	default:
+		break;
+
+	case PCI_VENDOR_ID_GENESYS:
+		/* Genesys Logic's GL880S controllers don't generate
+		 * resume-detect interrupts.
+		 */
+		return 1;
+
+	case PCI_VENDOR_ID_INTEL:
+		/* Some of Intel's USB controllers have a bug that causes
+		 * resume-detect interrupts if any port has an over-current
+		 * condition.  To make matters worse, some motherboards
+		 * hardwire unused USB ports' over-current inputs active!
+		 * To prevent problems, we will not enable resume-detect
+		 * interrupts if any ports are OC.
+		 */
+		for (port = 0; port < uhci->rh_numports; ++port) {
+			if (inw(uhci->io_addr + USBPORTSC1 + port * 2) &
+					USBPORTSC_OC)
+				return 1;
+		}
+		break;
+	}
+	return 0;
+}
+
+static int uhci_pci_global_suspend_mode_is_broken(struct uhci_hcd *uhci)
+{
+	int port;
+	const char *sys_info;
+	static const char bad_Asus_board[] = "A7V8X";
+
+	/* One of Asus's motherboards has a bug which causes it to
+	 * wake up immediately from suspend-to-RAM if any of the ports
+	 * are connected.  In such cases we will not set EGSM.
+	 */
+	sys_info = dmi_get_system_info(DMI_BOARD_NAME);
+	if (sys_info && !strcmp(sys_info, bad_Asus_board)) {
+		for (port = 0; port < uhci->rh_numports; ++port) {
+			if (inw(uhci->io_addr + USBPORTSC1 + port * 2) &
+					USBPORTSC_CCS)
+				return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int uhci_pci_init(struct usb_hcd *hcd)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+
+	uhci->io_addr = (unsigned long) hcd->rsrc_start;
+
+	uhci->rh_numports = uhci_count_ports(hcd);
+
+	/* Intel controllers report the OverCurrent bit active on.
+	 * VIA controllers report it active off, so we'll adjust the
+	 * bit value.  (It's not standardized in the UHCI spec.)
+	 */
+	if (to_pci_dev(uhci_dev(uhci))->vendor == PCI_VENDOR_ID_VIA)
+		uhci->oc_low = 1;
+
+	/* HP's server management chip requires a longer port reset delay. */
+	if (to_pci_dev(uhci_dev(uhci))->vendor == PCI_VENDOR_ID_HP)
+		uhci->wait_for_hp = 1;
+
+	/* Set up pointers to PCI-specific functions */
+	uhci->reset_hc = uhci_pci_reset_hc;
+	uhci->check_and_reset_hc = uhci_pci_check_and_reset_hc;
+	uhci->configure_hc = uhci_pci_configure_hc;
+	uhci->resume_detect_interrupts_are_broken =
+		uhci_pci_resume_detect_interrupts_are_broken;
+	uhci->global_suspend_mode_is_broken =
+		uhci_pci_global_suspend_mode_is_broken;
+
+
+	/* Kick BIOS off this hardware and reset if the controller
+	 * isn't already safely quiescent.
+	 */
+	check_and_reset_hc(uhci);
+	return 0;
+}
+
+/* Make sure the controller is quiescent and that we're not using it
+ * any more.  This is mainly for the benefit of programs which, like kexec,
+ * expect the hardware to be idle: not doing DMA or generating IRQs.
+ *
+ * This routine may be called in a damaged or failing kernel.  Hence we
+ * do not acquire the spinlock before shutting down the controller.
+ */
+static void uhci_shutdown(struct pci_dev *pdev)
+{
+	struct usb_hcd *hcd = pci_get_drvdata(pdev);
+
+	uhci_hc_died(hcd_to_uhci(hcd));
+}
+
+#ifdef CONFIG_PM
+
+static int uhci_pci_suspend(struct usb_hcd *hcd)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	int rc = 0;
+
+	dev_dbg(uhci_dev(uhci), "%s\n", __func__);
+
+	spin_lock_irq(&uhci->lock);
+	if (!HCD_HW_ACCESSIBLE(hcd) || uhci->dead)
+		goto done_okay;		/* Already suspended or dead */
+
+	if (uhci->rh_state > UHCI_RH_SUSPENDED) {
+		dev_warn(uhci_dev(uhci), "Root hub isn't suspended!\n");
+		rc = -EBUSY;
+		goto done;
+	};
+
+	/* All PCI host controllers are required to disable IRQ generation
+	 * at the source, so we must turn off PIRQ.
+	 */
+	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
+	mb();
+	clear_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+
+	/* FIXME: Enable non-PME# remote wakeup? */
+
+done_okay:
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+done:
+	spin_unlock_irq(&uhci->lock);
+	return rc;
+}
+
+static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+
+	dev_dbg(uhci_dev(uhci), "%s\n", __func__);
+
+	/* Since we aren't in D3 any more, it's safe to set this flag
+	 * even if the controller was dead.
+	 */
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	mb();
+
+	spin_lock_irq(&uhci->lock);
+
+	/* Make sure resume from hibernation re-enumerates everything */
+	if (hibernated) {
+		uhci->reset_hc(uhci);
+		finish_reset(uhci);
+	}
+
+	/* The firmware may have changed the controller settings during
+	 * a system wakeup.  Check it and reconfigure to avoid problems.
+ 	 */
+	else {
+		check_and_reset_hc(uhci);
+	}
+	configure_hc(uhci);
+
+	if (uhci->rh_state == UHCI_RH_RESET) {
+
+		/* The controller had to be reset */
+		usb_root_hub_lost_power(hcd->self.root_hub);
+		suspend_rh(uhci, UHCI_RH_SUSPENDED);
+	}
+
+	spin_unlock_irq(&uhci->lock);
+	synchronize_irq(hcd->irq);
+
+	/* If interrupts don't work and remote wakeup is enabled then
+	 * the suspended root hub needs to be polled.
+	 */
+	if (!uhci->RD_enable && hcd->self.root_hub->do_remote_wakeup) {
+		set_bit(HCD_FLAG_POLL_RH, &hcd->flags);
+		usb_hcd_poll_rh_status(hcd);
+	}
+	return 0;
+}
+
+#endif
+
+static const struct hc_driver uhci_driver = {
+	.description =		hcd_name,
+	.product_desc =		"UHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct uhci_hcd),
+
+	/* Generic hardware linkage */
+	.irq =			uhci_irq,
+	.flags =		HCD_USB11,
+
+	/* Basic lifecycle operations */
+	.reset =		uhci_pci_init,
+	.start =		uhci_start,
+#ifdef CONFIG_PM
+	.pci_suspend =		uhci_pci_suspend,
+	.pci_resume =		uhci_pci_resume,
+	.bus_suspend =		uhci_rh_suspend,
+	.bus_resume =		uhci_rh_resume,
+#endif
+	.stop =			uhci_stop,
+
+	.urb_enqueue =		uhci_urb_enqueue,
+	.urb_dequeue =		uhci_urb_dequeue,
+
+	.endpoint_disable =	uhci_hcd_endpoint_disable,
+	.get_frame_number =	uhci_hcd_get_frame_number,
+
+	.hub_status_data =	uhci_hub_status_data,
+	.hub_control =		uhci_hub_control,
+};
+
+static DEFINE_PCI_DEVICE_TABLE(uhci_pci_ids) = { {
+	/* handle any USB UHCI controller */
+	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_UHCI, ~0),
+	.driver_data =	(unsigned long) &uhci_driver,
+	}, { /* end: all zeroes */ }
+};
+
+MODULE_DEVICE_TABLE(pci, uhci_pci_ids);
+
+static struct pci_driver uhci_pci_driver = {
+	.name =		(char *)hcd_name,
+	.id_table =	uhci_pci_ids,
+
+	.probe =	usb_hcd_pci_probe,
+	.remove =	usb_hcd_pci_remove,
+	.shutdown =	uhci_shutdown,
+
+#ifdef CONFIG_PM_SLEEP
+	.driver =	{
+		.pm =	&usb_hcd_pci_pm_ops
+	},
+#endif
+};
