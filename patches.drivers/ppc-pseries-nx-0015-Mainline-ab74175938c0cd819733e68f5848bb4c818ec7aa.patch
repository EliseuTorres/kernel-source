Subject: [PATCH] crypto: nx - fix limits to sg lists for AES-ECB
From: Marcelo Cerri <mhcerri@linux.vnet.ibm.com>
Git-commit: ab74175938c0cd819733e68f5848bb4c818ec7aa
Patch-mainline: v3.10-5906-gab74175
References: fate#317629

This patch updates the nx-aes-ecb implementation to perform several
hyper calls if needed in order to always respect the length limits for
scatter/gather lists.

Two different limits are considered:

 - "ibm,max-sg-len": maximum number of bytes of each scatter/gather
   list.

 - "ibm,max-sync-cop":
    - The total number of bytes that a scatter/gather list can hold.
    - The maximum number of elements that a scatter/gather list can have.

Reviewed-by: Joy Latten <jmlatten@linux.vnet.ibm.com>
Signed-off-by: Marcelo Cerri <mhcerri@linux.vnet.ibm.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Acked-by: Dinar Valeev <dvaleev@suse.com>
---
 drivers/crypto/nx/nx-aes-ecb.c | 48 ++++++++++++++++++++++++++----------------
 1 file changed, 30 insertions(+), 18 deletions(-)

Index: linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-ecb.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/crypto/nx/nx-aes-ecb.c
+++ linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-ecb.c
@@ -71,37 +71,49 @@ static int ecb_aes_nx_crypt(struct blkci
 	struct nx_crypto_ctx *nx_ctx = crypto_blkcipher_ctx(desc->tfm);
 	struct nx_csbcpb *csbcpb = nx_ctx->csbcpb;
 	unsigned long irq_flags;
+	unsigned int processed = 0, to_process;
+	u32 max_sg_len;
 	int rc;
 
 	spin_lock_irqsave(&nx_ctx->lock, irq_flags);
 
-	if (nbytes > nx_ctx->ap->databytelen) {
-		rc = -EINVAL;
-		goto out;
-	}
-
+	max_sg_len = min_t(u32, nx_driver.of.max_sg_len/sizeof(struct nx_sg),
+				nx_ctx->ap->sglen);
 	if (enc)
 		NX_CPB_FDM(csbcpb) |= NX_FDM_ENDE_ENCRYPT;
 	else
 		NX_CPB_FDM(csbcpb) &= ~NX_FDM_ENDE_ENCRYPT;
 
-	rc = nx_build_sg_lists(nx_ctx, desc, dst, src, nbytes, 0, NULL);
-	if (rc)
-		goto out;
-
-	if (!nx_ctx->op.inlen || !nx_ctx->op.outlen) {
-		rc = -EINVAL;
-		goto out;
-	}
-
-	rc = nx_hcall_sync(nx_ctx, &nx_ctx->op,
-			   desc->flags & CRYPTO_TFM_REQ_MAY_SLEEP);
-	if (rc)
-		goto out;
-
-	atomic_inc(&(nx_ctx->stats->aes_ops));
-	atomic64_add(csbcpb->csb.processed_byte_count,
-		     &(nx_ctx->stats->aes_bytes));
+	do {
+               to_process = min_t(u64, nbytes - processed,
+                               nx_ctx->ap->databytelen);
+               to_process = min_t(u64, to_process,
+                               NX_PAGE_SIZE * (max_sg_len - 1));
+               to_process = to_process & ~(AES_BLOCK_SIZE - 1);
+
+               rc = nx_build_sg_lists(nx_ctx, desc, dst, src, to_process,
+                               processed, NULL);
+
+               if (rc)
+                       goto out;
+
+               if (!nx_ctx->op.inlen || !nx_ctx->op.outlen) {
+                       rc = -EINVAL;
+                       goto out;
+               }
+
+               rc = nx_hcall_sync(nx_ctx, &nx_ctx->op,
+                               desc->flags & CRYPTO_TFM_REQ_MAY_SLEEP);
+               if (rc)
+                       goto out;
+
+               atomic_inc(&(nx_ctx->stats->aes_ops));
+               atomic64_add(csbcpb->csb.processed_byte_count,
+                               &(nx_ctx->stats->aes_bytes));
+
+               processed += to_process;
+       } while (processed < nbytes);
+
 out:
 	spin_unlock_irqrestore(&nx_ctx->lock, irq_flags);
 	return rc;
