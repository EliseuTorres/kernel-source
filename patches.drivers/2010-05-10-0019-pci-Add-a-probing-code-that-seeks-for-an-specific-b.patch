From: Aristeu Rozanski <aris@redhat.com>
Subject: pci: Add a probing code that seeks for an specific bus
References: fate#311968
Git-commit: 5707b24a50b40582226618c56692af932db9fe02
Patch-mainline: v2.6.35-rc2


Signed-off-by: Thomas Renninger <trenn@suse.de>

This patch adds a probing code that seeks for an specific pci bus. It
still needs testing, but it is hoped that this will help to identify the
memory controller with Xeon 55xx series.

Signed-off-by: Aristeu Sergio <arozansk@redhat.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

---
 arch/x86/include/asm/pci_x86.h |    2 +
 arch/x86/pci/legacy.c          |   42 ++++++++++++++++++++++++-----------------
 2 files changed, 27 insertions(+), 17 deletions(-)

Index: linux-2.6.32-SLE11-SP1/arch/x86/include/asm/pci_x86.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/include/asm/pci_x86.h
+++ linux-2.6.32-SLE11-SP1/arch/x86/include/asm/pci_x86.h
@@ -54,6 +54,8 @@ extern int pcibios_last_bus;
 extern struct pci_bus *pci_root_bus;
 extern struct pci_ops pci_root_ops;
 
+void pcibios_scan_specific_bus(int busn);
+
 /* pci-irq.c */
 
 struct irq_info {
Index: linux-2.6.32-SLE11-SP1/arch/x86/pci/legacy.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/pci/legacy.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/pci/legacy.c
@@ -11,28 +11,14 @@
  */
 static void __devinit pcibios_fixup_peer_bridges(void)
 {
-	int n, devfn;
-	long node;
+	int n;
 
 	if (pcibios_last_bus <= 0 || pcibios_last_bus > 0xff)
 		return;
 	DBG("PCI: Peer bridge fixup\n");
 
-	for (n=0; n <= pcibios_last_bus; n++) {
-		u32 l;
-		if (pci_find_bus(0, n))
-			continue;
-		node = get_mp_bus_to_node(n);
-		for (devfn = 0; devfn < 256; devfn += 8) {
-			if (!raw_pci_read(0, n, devfn, PCI_VENDOR_ID, 2, &l) &&
-			    l != 0x0000 && l != 0xffff) {
-				DBG("Found device at %02x:%02x [%04x]\n", n, devfn, l);
-				printk(KERN_INFO "PCI: Discovered peer bus %02x\n", n);
-				pci_scan_bus_on_node(n, &pci_root_ops, node);
-				break;
-			}
-		}
-	}
+	for (n=0; n <= pcibios_last_bus; n++)
+		pcibios_scan_specific_bus(n);
 }
 
 static int __init pci_legacy_init(void)
@@ -52,6 +38,28 @@ static int __init pci_legacy_init(void)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(pci_legacy_init);
+
+void pcibios_scan_specific_bus(int busn)
+{
+	int devfn;
+	long node;
+	u32 l;
+
+	if (pci_find_bus(0, busn))
+		return;
+
+	node = get_mp_bus_to_node(busn);
+	for (devfn = 0; devfn < 256; devfn += 8) {
+		if (!raw_pci_read(0, busn, devfn, PCI_VENDOR_ID, 2, &l) &&
+		    l != 0x0000 && l != 0xffff) {
+			DBG("Found device at %02x:%02x [%04x]\n", busn, devfn, l);
+			printk(KERN_INFO "PCI: Discovered peer bus %02x\n", busn);
+			pci_scan_bus_on_node(busn, &pci_root_ops, node);
+			return;
+		}
+	}
+}
 
 int __init pci_subsys_init(void)
 {
