From d507cd668a3f6d07b31e914722b453c454b03204 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Tue, 26 Apr 2011 15:25:02 +0200
Subject: [PATCH] ALSA: hda - Enable sync_write workaround for AMD generically
Git-commit: d507cd668a3f6d07b31e914722b453c454b03204
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6.git
Patch-mainline: 2.6.40-rc1
References: bnc#691269,bnc#687760

The workaround for AMD chipset via sync_write flag seems needed for
machines with Realtek codecs.  So, it's better to activate it
generically in hda_intel.c from the beginning.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/pci/hda/hda_intel.c      |   11 +++++++++++
 sound/pci/hda/patch_sigmatel.c |   16 ----------------
 2 files changed, 11 insertions(+), 16 deletions(-)

--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -1418,6 +1418,17 @@
 		}
 	}
 
+	/* AMD chipsets often cause the communication stalls upon certain
+	 * sequence like the pin-detection.  It seems that forcing the synced
+	 * access works around the stall.  Grrr...
+	 */
+	if (chip->pci->vendor == PCI_VENDOR_ID_AMD ||
+	    chip->pci->vendor == PCI_VENDOR_ID_ATI) {
+		snd_printk(KERN_INFO SFX "Enable sync_write for AMD chipset\n");
+		chip->bus->sync_write = 1;
+		chip->bus->allow_bus_reset = 1;
+	}
+
 	/* Then create codec instances */
 	for (c = 0; c < max_slots; c++) {
 		if ((chip->codec_mask & (1 << c)) & chip->codec_probe_mask) {
--- a/sound/pci/hda/patch_sigmatel.c
+++ b/sound/pci/hda/patch_sigmatel.c
@@ -5451,13 +5451,6 @@
 	spec->capvols = stac92hd83xxx_capvols;
 	spec->capsws = stac92hd83xxx_capsws;
 
-	if (codec->bus->pci && codec->bus->pci->vendor == PCI_VENDOR_ID_AMD) {
-		snd_printk(KERN_INFO "idt92hd83xxx: "
-			   "Enable sync_write for AMD chipset\n");
-		codec->bus->sync_write = 1;
-		codec->bus->allow_bus_reset = 1;
-	}
-
 	spec->board_config = snd_hda_check_board_config(codec,
 							STAC_92HD83XXX_MODELS,
 							stac92hd83xxx_models,
@@ -5710,15 +5703,6 @@
 	if (get_wcaps(codec, 0xa) & AC_WCAP_IN_AMP)
 		snd_hda_sequence_write_cache(codec, unmute_init);
 
-	/* Some HP machines seem to have unstable codec communications
-	 * especially with ATI fglrx driver.  For recovering from the
-	 * CORB/RIRB stall, allow the BUS reset and keep always sync
-	 */
-	if (spec->board_config == STAC_HP_DV5) {
-		codec->bus->sync_write = 1;
-		codec->bus->allow_bus_reset = 1;
-	}
-
 	spec->aloopback_ctl = stac92hd71bxx_loopback;
 	spec->aloopback_mask = 0x50;
 	spec->aloopback_shift = 0;
