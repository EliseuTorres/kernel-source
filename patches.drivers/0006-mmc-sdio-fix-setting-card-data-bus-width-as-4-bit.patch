From: Yong Ding <yongd@marvell.com>
Date: Tue, 15 May 2012 13:09:43 +0800
Subject: [PATCH 06/10] mmc: sdio: fix setting card data bus width as 4-bit
Git-commit: 2a0fe914a38745f5b03534c4e4f4056cbd6978b8
Patch-mainline: v3.5-rc4~28^2~10
References: bnc#799019,fate#313948

SDIO_CCCR_IF[1:0] in SDIO card is used for card data bus width
setting as below:

     00b: 1-bit bus
     01b: Reserved
     10b: 4-bit bus
     11b: 8-bit bus (only for embedded SDIO)

And sdio_enable_wide is for setting data bus width as 4-bit.
But currently, it first reads the register, second OR' 1b with
SDIO_CCCR_IF[1], and then writes it back.

As we can see, this is based on such assumption that the
SDIO_CCCR_IF[0] is always 0. Apparently, this is not right.

Signed-off-by: Yong Ding <yongd@marvell.com>
Acked-by: Philip Rakity <prakity@marvell.com>
Signed-off-by: Chris Ball <cjb@laptop.org>
Acked-by: Cho, Yu-Chen <acho@suse.com>
---
 drivers/mmc/core/sdio.c  |    6 ++++++
 include/linux/mmc/sdio.h |    2 ++
 2 files changed, 8 insertions(+)

--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -217,6 +217,12 @@ static int sdio_enable_wide(struct mmc_c
 	if (ret)
 		return ret;
 
+	if ((ctrl & SDIO_BUS_WIDTH_MASK) == SDIO_BUS_WIDTH_RESERVED)
+		pr_warning("%s: SDIO_CCCR_IF is invalid: 0x%02x\n",
+			   mmc_hostname(card->host), ctrl);
+
+	/* set as 4-bit bus width */
+	ctrl &= ~SDIO_BUS_WIDTH_MASK;
 	ctrl |= SDIO_BUS_WIDTH_4BIT;
 
 	ret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);
--- a/include/linux/mmc/sdio.h
+++ b/include/linux/mmc/sdio.h
@@ -98,7 +98,9 @@
 
 #define SDIO_CCCR_IF		0x07	/* bus interface controls */
 
+#define  SDIO_BUS_WIDTH_MASK	0x03	/* data bus width setting */
 #define  SDIO_BUS_WIDTH_1BIT	0x00
+#define  SDIO_BUS_WIDTH_RESERVED 0x01
 #define  SDIO_BUS_WIDTH_4BIT	0x02
 #define  SDIO_BUS_ECSI		0x20	/* Enable continuous SPI interrupt */
 #define  SDIO_BUS_SCSI		0x40	/* Support continuous SPI interrupt */
