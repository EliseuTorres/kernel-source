From: Scott Teel <scott.teel@hp.com>
Date: Tue, 18 Feb 2014 13:57:21 -0600
Subject: [SCSI] hpsa: retry certain ioaccel error cases on the RAID path
References: bnc#913241,FATE#317338
Patch-Mainline: v3.16
Git-commit: a09c1441e450a5912ce378cb18a04479a7745451

Change the handling of HP SSD Smart Path errors with status:
  0x02 CHECK CONDITION
  0x08 BUSY
  0x18 RESERVATION CONFLICT
  0x40 TASK ABORTED
So that they get retried on the RAID Path.

Signed-off-by: Scott Teel <scott.teel@hp.com>
Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Signed-off-by: James Bottomley <JBottomley@Parallels.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/hpsa.c | 45 +++++++++++++++++++++++++++++++++++++++------
 1 file changed, 39 insertions(+), 6 deletions(-)

diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c
index 6e3d9ce..40e9a88 100644
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@ -1340,12 +1340,18 @@ static void hpsa_unmap_sg_chain_block(struct ctlr_info *h,
 	pci_unmap_single(h->pdev, temp64.val, chain_sg->Len, PCI_DMA_TODEVICE);
 }
 
-static void handle_ioaccel_mode2_error(struct ctlr_info *h,
+
+/* Decode the various types of errors on ioaccel2 path.
+ * Return 1 for any error that should generate a RAID path retry.
+ * Return 0 for errors that don't require a RAID path retry.
+ */
+static int handle_ioaccel_mode2_error(struct ctlr_info *h,
 					struct CommandList *c,
 					struct scsi_cmnd *cmd,
 					struct io_accel2_cmd *c2)
 {
 	int data_len;
+	int retry = 0;
 
 	switch (c2->error_data.serv_response) {
 	case IOACCEL2_SERV_RESPONSE_COMPLETE:
@@ -1369,16 +1375,19 @@ static void handle_ioaccel_mode2_error(struct ctlr_info *h,
 			memcpy(cmd->sense_buffer,
 				c2->error_data.sense_data_buff, data_len);
 			cmd->result |= SAM_STAT_CHECK_CONDITION;
+			retry = 1;
 			break;
 		case IOACCEL2_STATUS_SR_TASK_COMP_BUSY:
 			dev_warn(&h->pdev->dev,
 				"%s: task complete with BUSY status.\n",
 				"HP SSD Smart Path");
+			retry = 1;
 			break;
 		case IOACCEL2_STATUS_SR_TASK_COMP_RES_CON:
 			dev_warn(&h->pdev->dev,
 				"%s: task complete with reservation conflict.\n",
 				"HP SSD Smart Path");
+			retry = 1;
 			break;
 		case IOACCEL2_STATUS_SR_TASK_COMP_SET_FULL:
 			/* Make scsi midlayer do unlimited retries */
@@ -1388,11 +1397,13 @@ static void handle_ioaccel_mode2_error(struct ctlr_info *h,
 			dev_warn(&h->pdev->dev,
 				"%s: task complete with aborted status.\n",
 				"HP SSD Smart Path");
+			retry = 1;
 			break;
 		default:
 			dev_warn(&h->pdev->dev,
 				"%s: task complete with unrecognized status: 0x%02x\n",
 				"HP SSD Smart Path", c2->error_data.status);
+			retry = 1;
 			break;
 		}
 		break;
@@ -1401,6 +1412,7 @@ static void handle_ioaccel_mode2_error(struct ctlr_info *h,
 		dev_warn(&h->pdev->dev,
 			"unexpected delivery or target failure, status = 0x%02x\n",
 			c2->error_data.status);
+		retry = 1;
 		break;
 	case IOACCEL2_SERV_RESPONSE_TMF_COMPLETE:
 		break;
@@ -1408,6 +1420,7 @@ static void handle_ioaccel_mode2_error(struct ctlr_info *h,
 		break;
 	case IOACCEL2_SERV_RESPONSE_TMF_REJECTED:
 		dev_warn(&h->pdev->dev, "task management function rejected.\n");
+		retry = 1;
 		break;
 	case IOACCEL2_SERV_RESPONSE_TMF_WRONG_LUN:
 		dev_warn(&h->pdev->dev, "task management function invalid LUN\n");
@@ -1415,9 +1428,13 @@ static void handle_ioaccel_mode2_error(struct ctlr_info *h,
 	default:
 		dev_warn(&h->pdev->dev,
 			"%s: Unrecognized server response: 0x%02x\n",
-			"HP SSD Smart Path", c2->error_data.serv_response);
+			"HP SSD Smart Path",
+			c2->error_data.serv_response);
+		retry = 1;
 		break;
 	}
+
+	return retry;	/* retry on raid path? */
 }
 
 static void process_ioaccel2_completion(struct ctlr_info *h,
@@ -1425,6 +1442,7 @@ static void process_ioaccel2_completion(struct ctlr_info *h,
 		struct hpsa_scsi_dev_t *dev)
 {
 	struct io_accel2_cmd *c2 = &h->ioaccel2_cmd_pool[c->cmdindex];
+	int raid_retry = 0;
 
 	/* check for good status */
 	if (likely(c2->error_data.serv_response == 0 &&
@@ -1441,11 +1459,16 @@ static void process_ioaccel2_completion(struct ctlr_info *h,
 	if (is_logical_dev_addr_mode(dev->scsi3addr) &&
 		c2->error_data.serv_response ==
 			IOACCEL2_SERV_RESPONSE_FAILURE) {
-		if (c2->error_data.status !=
-				IOACCEL2_STATUS_SR_IOACCEL_DISABLED)
+		if (c2->error_data.status ==
+			IOACCEL2_STATUS_SR_IOACCEL_DISABLED)
+			dev_warn(&h->pdev->dev,
+				"%s: Path is unavailable, retrying on standard path.\n",
+				"HP SSD Smart Path");
+		else
 			dev_warn(&h->pdev->dev,
-				"%s: Error 0x%02x, Retrying on standard path.\n",
+				"%s: Error 0x%02x, retrying on standard path.\n",
 				"HP SSD Smart Path", c2->error_data.status);
+
 		dev->offload_enabled = 0;
 		h->drv_req_rescan = 1;	/* schedule controller for a rescan */
 		cmd->result = DID_SOFT_ERROR << 16;
@@ -1453,7 +1476,17 @@ static void process_ioaccel2_completion(struct ctlr_info *h,
 		cmd->scsi_done(cmd);
 		return;
 	}
-	handle_ioaccel_mode2_error(h, c, cmd, c2);
+	raid_retry = handle_ioaccel_mode2_error(h, c, cmd, c2);
+	/* If error found, disable Smart Path, schedule a rescan,
+	 * and force a retry on the standard path.
+	 */
+	if (raid_retry) {
+		dev_warn(&h->pdev->dev, "%s: Retrying on standard path.\n",
+			"HP SSD Smart Path");
+		dev->offload_enabled = 0; /* Disable Smart Path */
+		h->drv_req_rescan = 1;	  /* schedule controller rescan */
+		cmd->result = DID_SOFT_ERROR << 16;
+	}
 	cmd_free(h, c);
 	cmd->scsi_done(cmd);
 }
-- 
1.8.5.2

