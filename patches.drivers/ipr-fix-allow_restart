From: Wayne Boyer <wayneb@linux.vnet.ibm.com>
Subject: ipr: move setting of the allow_restart flag for vsets and disks
Patch-mainline: 2.6.35.x
References: bnc#617248

A problem was found where the call to scsi_add_device() fails intermittently
for an adapter.  This is caused when __scsi_add_device() returns -ENODEV as
a result of not calling scsi_probe_and_add_lun() since the call to
scsi_host_scan_allowed() fails.  scsi_host_scan_allowed() fails because the
adapter state is set to SHOST_RECOVERY instead of SHOST_RUNNING. The state of
the adapter is being set to SHOST_RECOVERY by scsi_eh_scmd_add() during
error handling.

This problem is avoided by moving the setting of the allow_restart flag to
later in the device initialization sequence.  This prevents further error
handling if we get a NOT_READY response from a TUR command by causing
scsi_check_sense() to return SUCCESS.  Therefore, scsi_eh_scmd_add() will
not run and the adapter state will remain as SHOST_RUNNING.

Signed-off-by: Wayne Boyer <wayneb@linux.vnet.ibm.com>
Acked-by: Brian King <brking@linux.vnet.ibm.com>
Signed-off-by: James Bottomley <James.Bottomley@suse.de>
Acked-by: Torsten Duwe <duwe@suse.de>

Index: b/drivers/scsi/ipr.c
===================================================================
--- a/drivers/scsi/ipr.c	2010-06-08 09:37:16.000000000 -0700
+++ b/drivers/scsi/ipr.c	2010-06-08 09:42:58.000000000 -0700
@@ -3676,8 +3676,6 @@ static int ipr_slave_configure(struct sc
 					     IPR_VSET_RW_TIMEOUT);
 			blk_queue_max_sectors(sdev->request_queue, IPR_VSET_MAX_SECTORS);
 		}
-		if (ipr_is_vset_device(res) || ipr_is_scsi_disk(res))
-			sdev->allow_restart = 1;
 		if (ipr_is_gata(res) && res->sata_port)
 			ap = res->sata_port->ap;
 		spin_unlock_irqrestore(ioa_cfg->host->host_lock, lock_flags);
@@ -5994,7 +5992,8 @@ static int ipr_init_res_table(struct ipr
 			list_move_tail(&res->queue, &ioa_cfg->used_res_q);
 			ipr_init_res_entry(res);
 			res->add_to_ml = 1;
-		}
+		} else if (res->sdev && (ipr_is_vset_device(res) || ipr_is_scsi_disk(res)))
+			res->sdev->allow_restart = 1;

 		if (found)
 			memcpy(&res->cfgte, cfgte, sizeof(struct ipr_config_table_entry));


