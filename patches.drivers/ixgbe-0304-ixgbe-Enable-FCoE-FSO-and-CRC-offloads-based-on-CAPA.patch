From: Alexander Duyck <alexander.h.duyck@intel.com>
Date: Fri, 25 May 2012 06:38:18 +0000
Subject: ixgbe: Enable FCoE FSO and CRC offloads based on CAPABLE instead of
 ENABLED flag
Patch-mainline: v3.6-rc1
Git-commit: a58915c7ecba89bef0914664ecf87c2156c68630
References: bnc#795303 FATE#313662

Instead of only setting the FCOE segmentation offload and CRC offload flags
if we enable FCoE, we could just set them always since there are no
modifications needed to the hardware or adapter FCoE structure in order to
use these features.

The advantage to this is that if FCoE enablement fails, for example because
SR-IOV was enabled on 82599, we will still have use of the FCoE
segmentation offload and Tx/Rx CRC offloads which should still help to
improve the FCoE performance.

Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
Tested-by: Ross Brattain <ross.b.brattain@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c |   16 +++++++++-------
 drivers/net/ethernet/intel/ixgbe/ixgbe_main.c |    5 ++++-
 2 files changed, 13 insertions(+), 8 deletions(-)
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
@@ -616,11 +616,11 @@ void ixgbe_configure_fcoe(struct ixgbe_a
 	int i, fcoe_q, fcoe_i;
 	u32 etqf;
 
-	/* leave registers unconfigued if FCoE is disabled */
-	if (!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED))
+	/* Minimal functionality for FCoE requires at least CRC offloads */
+	if (!(adapter->netdev->features & NETIF_F_FCOE_CRC))
 		return;
 
-	/* Enable L2 EtherType filter for FCoE, necessary for FCoE Rx CRC */
+	/* Enable L2 EtherType filter for FCoE, needed for FCoE CRC and DDP */
 	etqf = ETH_P_FCOE | IXGBE_ETQF_FCOE | IXGBE_ETQF_FILTER_EN;
 	if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {
 		etqf |= IXGBE_ETQF_POOL_ENABLE;
@@ -629,6 +629,10 @@ void ixgbe_configure_fcoe(struct ixgbe_a
 	IXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_FCOE), etqf);
 	IXGBE_WRITE_REG(hw, IXGBE_ETQS(IXGBE_ETQF_FILTER_FCOE), 0);
 
+	/* leave registers un-configured if FCoE is disabled */
+	if (!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED))
+		return;
+
 	/* Use one or more Rx queues for FCoE by redirection table */
 	for (i = 0; i < IXGBE_FCRETA_SIZE; i++) {
 		fcoe_i = fcoe->offset + (i % fcoe->indices);
@@ -804,7 +808,7 @@ int ixgbe_fcoe_enable(struct net_device
 
 	/* enable FCoE and notify stack */
 	adapter->flags |= IXGBE_FLAG_FCOE_ENABLED;
-	netdev->features |= NETIF_F_FSO | NETIF_F_FCOE_CRC | NETIF_F_FCOE_MTU;
+	netdev->features |= NETIF_F_FCOE_MTU;
 	netdev_features_change(netdev);
 
 	/* release existing queues and reallocate them */
@@ -844,9 +848,7 @@ int ixgbe_fcoe_disable(struct net_device
 
 	/* disable FCoE and notify stack */
 	adapter->flags &= ~IXGBE_FLAG_FCOE_ENABLED;
-	netdev->features &= ~(NETIF_F_FCOE_CRC |
-			      NETIF_F_FSO |
-			      NETIF_F_FCOE_MTU);
+	netdev->features &= ~NETIF_F_FCOE_MTU;
 
 	netdev_features_change(netdev);
 
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -6379,7 +6379,7 @@ netdev_tx_t ixgbe_xmit_frame_ring(struct
 #ifdef IXGBE_FCOE
 	/* setup tx offload for FCoE */
 	if ((protocol == __constant_htons(ETH_P_FCOE)) &&
-	    (adapter->flags & IXGBE_FLAG_FCOE_ENABLED)) {
+	    (tx_ring->netdev->features & (NETIF_F_FSO | NETIF_F_FCOE_CRC))) {
 		tso = ixgbe_fso(tx_ring, first, &hdr_len);
 		if (tso < 0)
 			goto out_drop;
@@ -7247,6 +7247,9 @@ static int __devinit ixgbe_probe(struct
 
 		adapter->ring_feature[RING_F_FCOE].limit = IXGBE_FCRETA_SIZE;
 
+		netdev->features |= NETIF_F_FSO |
+				    NETIF_F_FCOE_CRC;
+
 		netdev->vlan_features |= NETIF_F_FSO |
 					 NETIF_F_FCOE_CRC |
 					 NETIF_F_FCOE_MTU;
