From: Matthew Wilcox <matthew.r.wilcox@intel.com>
Date: Tue, 15 Feb 2011 16:28:20 -0500
Subject: NVMe: Let the kthread take care of devices earlier
Git-commit: 740216fc59cba54f65187c9ed92f29bce3cf8778
References: FATE#313627
Patch-Mainline: v3.7-rc1

If interrupts are misconfigured, the kthread will be needed to process
admin queue completions.

Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/block/nvme.c |   14 ++++++++++----
 1 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/drivers/block/nvme.c b/drivers/block/nvme.c
index f3aa809..df1d8bd 100644
--- a/drivers/block/nvme.c
+++ b/drivers/block/nvme.c
@@ -1112,6 +1112,8 @@ static int nvme_kthread(void *data)
 			int i;
 			for (i = 0; i < dev->queue_count; i++) {
 				struct nvme_queue *nvmeq = dev->queues[i];
+				if (!nvmeq)
+					continue;
 				spin_lock_irq(&nvmeq->q_lock);
 				if (nvme_process_cq(nvmeq))
 					printk("process_cq did something\n");
@@ -1437,17 +1439,21 @@ static int __devinit nvme_probe(struct pci_dev *pdev,
 		goto unmap;
 	dev->queue_count++;
 
-	result = nvme_dev_add(dev);
-	if (result)
-		goto delete;
-
 	spin_lock(&dev_list_lock);
 	list_add(&dev->node, &dev_list);
 	spin_unlock(&dev_list_lock);
 
+	result = nvme_dev_add(dev);
+	if (result)
+		goto delete;
+
 	return 0;
 
  delete:
+	spin_lock(&dev_list_lock);
+	list_del(&dev->node);
+	spin_unlock(&dev_list_lock);
+
 	nvme_free_queues(dev);
  unmap:
 	iounmap(dev->bar);
-- 
1.7.4.2

