From 6878da05006feb68efe23a6ae010b1a5df32ca5f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Fri, 13 Sep 2013 15:59:11 +0300
Subject: [PATCH] drm/i915: Add intel_dotclock_calculate()
Mime-version: 1.0
Content-type: text/plain; charset=UTF-8
Content-transfer-encoding: 8bit
Git-commit: 6878da05006feb68efe23a6ae010b1a5df32ca5f
Patch-mainline: 3.13-rc1
References: FATE#318416

Extract the code to calculate the dotclock from the link clock and M/N
values into a new function from ironlake_crtc_clock_get().

The new function can be used to calculate the dotclock for both FDI and
DP cases.

Also simplify the code a bit along the way.

V2: Don't forget about non-pch encoders in ironlake_crtc_clock_get()

Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Reviewed-by: Jani Nikula <jani.nikula@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/intel_display.c |   43 +++++++++++++++++------------------
 drivers/gpu/drm/i915/intel_drv.h     |    2 +
 2 files changed, 24 insertions(+), 21 deletions(-)

--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -7511,16 +7511,9 @@ static void i9xx_crtc_clock_get(struct i
 	pipe_config->adjusted_mode.clock = clock.dot;
 }
 
-static void ironlake_crtc_clock_get(struct intel_crtc *crtc,
-				    struct intel_crtc_config *pipe_config)
+int intel_dotclock_calculate(int link_freq,
+			     const struct intel_link_m_n *m_n)
 {
-	struct drm_device *dev = crtc->base.dev;
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	enum transcoder cpu_transcoder = pipe_config->cpu_transcoder;
-	int link_freq;
-	u64 clock;
-	u32 link_m, link_n;
-
 	/*
 	 * The calculation for the data clock is:
 	 * pixel_clock = ((m/n)*(link_clock * nr_lanes))/bpp
@@ -7531,6 +7524,18 @@ static void ironlake_crtc_clock_get(stru
 	 * link_clock = (m * link_clock) / n
 	 */
 
+	if (!m_n->link_n)
+		return 0;
+
+	return div_u64((u64)m_n->link_m * link_freq, m_n->link_n);
+}
+
+static void ironlake_crtc_clock_get(struct intel_crtc *crtc,
+				    struct intel_crtc_config *pipe_config)
+{
+	struct drm_device *dev = crtc->base.dev;
+	int link_freq;
+
 	/*
 	 * We need to get the FDI or DP link clock here to derive
 	 * the M/N dividers.
@@ -7539,21 +7544,17 @@ static void ironlake_crtc_clock_get(stru
 	 * For DP, it's either 1.62GHz or 2.7GHz.
 	 * We do our calculations in 10*MHz since we don't need much precison.
 	 */
-	if (pipe_config->has_pch_encoder)
+	if (pipe_config->has_pch_encoder) {
 		link_freq = intel_fdi_link_freq(dev) * 10000;
-	else
-		link_freq = pipe_config->port_clock;
-
-	link_m = I915_READ(PIPE_LINK_M1(cpu_transcoder));
-	link_n = I915_READ(PIPE_LINK_N1(cpu_transcoder));
 
-	if (!link_m || !link_n)
-		return;
-
-	clock = ((u64)link_m * (u64)link_freq);
-	do_div(clock, link_n);
+		pipe_config->adjusted_mode.clock =
+			intel_dotclock_calculate(link_freq, &pipe_config->fdi_m_n);
+	} else {
+		link_freq = pipe_config->port_clock;
 
-	pipe_config->adjusted_mode.clock = clock;
+		pipe_config->adjusted_mode.clock =
+			intel_dotclock_calculate(link_freq, &pipe_config->dp_m_n);
+	}
 }
 
 /** Returns the currently programmed mode of the given pipe. */
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -806,5 +806,7 @@ extern void intel_aux_display_runtime_ge
 extern void intel_aux_display_runtime_put(struct drm_i915_private *dev_priv);
 extern void intel_dp_get_m_n(struct intel_crtc *crtc,
 			     struct intel_crtc_config *pipe_config);
+extern int intel_dotclock_calculate(int link_freq,
+				    const struct intel_link_m_n *m_n);
 
 #endif /* __INTEL_DRV_H__ */
