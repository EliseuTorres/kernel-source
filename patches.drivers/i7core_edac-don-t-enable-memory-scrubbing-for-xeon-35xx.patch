From 27100db0e0d381d24b6f3cb1a4f439996e7c00c8 Mon Sep 17 00:00:00 2001
From: Mauro Carvalho Chehab <mchehab@redhat.com>
Date: Thu, 4 Aug 2011 21:35:27 -0300
Subject: i7core_edac: Don't enable memory scrubbing for Xeon 35xx
Git-commit: 27100db0e0d381d24b6f3cb1a4f439996e7c00c8
Patch-mainline: v3.2-rc1
References: bnc#800339

Xeon 35xx doesn't mention memory scrub. It seems that only Xeon 55xx
and above supports it.

Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
Acked-by: Borislav Petkov <bp@suse.de>
---
 drivers/edac/i7core_edac.c | 46 +++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 39 insertions(+), 7 deletions(-)

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 0c02486cf57a..aeb01f42ffef 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -263,7 +263,7 @@ struct i7core_pvt {
 	unsigned long	rdimm_ce_count[NUM_CHANS][MAX_DIMMS];
 	int		rdimm_last_ce_count[NUM_CHANS][MAX_DIMMS];
 
-	unsigned int	is_registered;
+	bool		is_registered, enable_scrub;
 
 	/* mcelog glue */
 	struct edac_mce		edac_mce;
@@ -1487,8 +1487,10 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct pci_dev *pdev;
 	int i, func, slot;
+	char *family;
 
-	pvt->is_registered = 0;
+	pvt->is_registered = false;
+	pvt->enable_scrub  = false;
 	for (i = 0; i < i7core_dev->n_devs; i++) {
 		pdev = i7core_dev->pdev[i];
 		if (!pdev)
@@ -1504,9 +1506,37 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 			if (unlikely(func > MAX_CHAN_FUNC))
 				goto error;
 			pvt->pci_ch[slot - 4][func] = pdev;
-		} else if (!slot && !func)
+		} else if (!slot && !func) {
 			pvt->pci_noncore = pdev;
-		else
+
+			/* Detect the processor family */
+			switch (pdev->device) {
+			case PCI_DEVICE_ID_INTEL_I7_NONCORE:
+				family = "Xeon 35xx/ i7core";
+				pvt->enable_scrub = false;
+				break;
+			case PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT:
+				family = "i7-800/i5-700";
+				pvt->enable_scrub = false;
+				break;
+			case PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE:
+				family = "Xeon 34xx";
+				pvt->enable_scrub = false;
+				break;
+			case PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT:
+				family = "Xeon 55xx";
+				pvt->enable_scrub = true;
+				break;
+			case PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_REV2:
+				family = "Xeon 56xx / i7-900";
+				pvt->enable_scrub = true;
+				break;
+			default:
+				family = "unknown";
+				pvt->enable_scrub = false;
+			}
+			debugf0("Detected a processor type %s\n", family);
+		} else
 			goto error;
 
 		debugf0("Associated fn %d.%d, dev = %p, socket %d\n",
@@ -1515,7 +1545,7 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 
 		if (PCI_SLOT(pdev->devfn) == 3 &&
 			PCI_FUNC(pdev->devfn) == 2)
-			pvt->is_registered = 1;
+			pvt->is_registered = true;
 	}
 
 	return 0;
@@ -2060,7 +2090,8 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 		__func__, mci, &i7core_dev->pdev[0]->dev);
 
 	/* Disable scrubrate setting */
-	disable_sdram_scrub_setting(mci);
+	if (pvt->enable_scrub)
+		disable_sdram_scrub_setting(mci);
 
 	/* Disable MCE NMI handler */
 	edac_mce_unregister(&pvt->edac_mce);
@@ -2136,7 +2167,8 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	mci->edac_check = i7core_check_error;
 
 	/* Enable scrubrate setting */
-	enable_sdram_scrub_setting(mci);
+	if (pvt->enable_scrub)
+		enable_sdram_scrub_setting(mci);
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (unlikely(edac_mc_add_mc(mci))) {

