From: Matt Carlson <mcarlson@broadcom.com>
Date: Fri, 4 Nov 2011 09:15:04 +0000
Subject: [PATCH 024/105] tg3: Eliminate timer race with reset_task
Patch-mainline: v3.2-rc1
Git-commit: 5b1906241905d9bd1abe920854b3d43c2b9c85e1
References: bnc#790588 FATE#313912

During shutdown, it is impossible to reliably disable the timer and
reset_task threads.  Each thread can schedule the other, which leads to
shutdown code that chases its tail.

To fix the problem, this patch removes the ability of tg3_reset_task to
schedule a new timer thread.  To support this change, tg3_timer no
longer terminates itself, but rather goes into a polling mode.

Signed-off-by: Matt Carlson <mcarlson@broadcom.com>
Reviewed-by: Michael Chan <mchan@broadcom.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Nithin Nayak Sujir <nsujir@broadcom.com>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ethernet/broadcom/tg3.c |   14 ++------------
 drivers/net/ethernet/broadcom/tg3.h |    1 -
 2 files changed, 2 insertions(+), 13 deletions(-)

--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -6385,7 +6385,6 @@ static void tg3_reset_task(struct work_s
 {
 	struct tg3 *tp = container_of(work, struct tg3, reset_task);
 	int err;
-	unsigned int restart_timer;
 
 	tg3_full_lock(tp, 0);
 
@@ -6403,9 +6402,6 @@ static void tg3_reset_task(struct work_s
 
 	tg3_full_lock(tp, 1);
 
-	restart_timer = tg3_flag(tp, RESTART_TIMER);
-	tg3_flag_clear(tp, RESTART_TIMER);
-
 	if (tg3_flag(tp, TX_RECOVERY_PENDING)) {
 		tp->write32_tx_mbox = tg3_write32_tx_mbox;
 		tp->write32_rx_mbox = tg3_write_flush_reg32;
@@ -6420,9 +6416,6 @@ static void tg3_reset_task(struct work_s
 
 	tg3_netif_start(tp);
 
-	if (restart_timer)
-		mod_timer(&tp->timer, jiffies + 1);
-
 out:
 	tg3_full_unlock(tp);
 
@@ -9326,7 +9319,7 @@ static void tg3_timer(unsigned long __op
 {
 	struct tg3 *tp = (struct tg3 *) __opaque;
 
-	if (tp->irq_sync)
+	if (tp->irq_sync || tg3_flag(tp, RESET_TASK_PENDING))
 		goto restart_timer;
 
 	spin_lock(&tp->lock);
@@ -9349,10 +9342,9 @@ static void tg3_timer(unsigned long __op
 		}
 
 		if (!(tr32(WDMAC_MODE) & WDMAC_MODE_ENABLE)) {
-			tg3_flag_set(tp, RESTART_TIMER);
 			spin_unlock(&tp->lock);
 			tg3_reset_task_schedule(tp);
-			return;
+			goto restart_timer;
 		}
 	}
 
@@ -16076,12 +16068,10 @@ static pci_ers_result_t tg3_io_error_det
 	tg3_netif_stop(tp);
 
 	del_timer_sync(&tp->timer);
-	tg3_flag_clear(tp, RESTART_TIMER);
 
 	/* Want to make sure that the reset task doesn't run */
 	tg3_reset_task_cancel(tp);
 	tg3_flag_clear(tp, TX_RECOVERY_PENDING);
-	tg3_flag_clear(tp, RESTART_TIMER);
 
 	netif_device_detach(netdev);
 
--- a/drivers/net/ethernet/broadcom/tg3.h
+++ b/drivers/net/ethernet/broadcom/tg3.h
@@ -2880,7 +2880,6 @@ enum TG3_FLAGS {
 	TG3_FLAG_JUMBO_CAPABLE,
 	TG3_FLAG_CHIP_RESETTING,
 	TG3_FLAG_INIT_COMPLETE,
-	TG3_FLAG_RESTART_TIMER,
 	TG3_FLAG_TSO_BUG,
 	TG3_FLAG_IS_5788,
 	TG3_FLAG_MAX_RXPEND_64,
