From rajeshk@dut4145.unminc.com  Thu Jun 23 22:59:43 2011
From: Rajesh K Borundia <rajeshk@dut4145.unminc.com>
Date: Tue, 19 Apr 2011 10:27:39 -0700
Subject: [PATCH 53/56] netxen: Add support for VLAN RX HW acceleration
Git-commit: 81fb267869124a45113627e09fd5f17d75b8da9d
Patch-mainline: Never. "In upstream, kernel takes care of VLAN RX HW acceleration by default.", bnc#698269
References: bnc#698269, FATE#311464

Signed-off-by: Rajesh K Borundia <rajesh.borundia@qlogic.com>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 drivers/net/netxen/netxen_nic.h      |    1 +
 drivers/net/netxen/netxen_nic_init.c |   32 ++++++++++++++++++++++++++++++--
 drivers/net/netxen/netxen_nic_main.c |   10 ++++++++++
 3 files changed, 41 insertions(+), 2 deletions(-)

diff --git a/drivers/net/netxen/netxen_nic.h b/drivers/net/netxen/netxen_nic.h
index 311a994..bd040ad 100644
--- a/drivers/net/netxen/netxen_nic.h
+++ b/drivers/net/netxen/netxen_nic.h
@@ -1213,6 +1213,7 @@ struct netxen_adapter {
 
 	u8 mac_addr[ETH_ALEN];
 
+	struct vlan_group *vlgrp;
 	struct netxen_adapter_stats stats;
 
 	struct netxen_recv_context recv_ctx;
diff --git a/drivers/net/netxen/netxen_nic_init.c b/drivers/net/netxen/netxen_nic_init.c
index d9b0b48..f3b0a63 100644
--- a/drivers/net/netxen/netxen_nic_init.c
+++ b/drivers/net/netxen/netxen_nic_init.c
@@ -25,6 +25,7 @@
 
 #include <linux/netdevice.h>
 #include <linux/delay.h>
+#include <linux/if_vlan.h>
 #include "netxen_nic.h"
 #include "netxen_nic_hw.h"
 
@@ -1509,7 +1510,9 @@ netxen_process_rcv(struct netxen_adapter *adapter,
 	struct netxen_rx_buffer *buffer;
 	struct sk_buff *skb;
 	struct nx_host_rds_ring *rds_ring;
+	struct ethhdr *eth_hdr;
 	int index, length, cksum, pkt_offset;
+	u16 vid = 0xffff;
 
 	if (unlikely(ring >= adapter->max_rds_rings))
 		return NULL;
@@ -1539,9 +1542,20 @@ netxen_process_rcv(struct netxen_adapter *adapter,
 	if (pkt_offset)
 		skb_pull(skb, pkt_offset);
 
+	if (adapter->vlgrp) {
+		if (!__vlan_get_tag(skb, &vid)) {
+			eth_hdr = (struct ethhdr *) skb->data;
+			memmove(skb->data + VLAN_HLEN, eth_hdr, ETH_ALEN * 2);
+			skb_pull(skb, VLAN_HLEN);
+		}
+	}
+
 	skb->protocol = eth_type_trans(skb, netdev);
 
-	napi_gro_receive(&sds_ring->napi, skb);
+	if (vid != 0xffff)
+		vlan_gro_receive(&sds_ring->napi, adapter->vlgrp, vid, skb);
+	else
+		napi_gro_receive(&sds_ring->napi, skb);
 
 	adapter->stats.rx_pkts++;
 	adapter->stats.rxbytes += length;
@@ -1565,11 +1579,13 @@ netxen_process_lro(struct netxen_adapter *adapter,
 	struct nx_host_rds_ring *rds_ring;
 	struct iphdr *iph;
 	struct tcphdr *th;
+	struct ethhdr *eth_hdr;
 	bool push, timestamp;
 	int l2_hdr_offset, l4_hdr_offset;
 	int index;
 	u16 lro_length, length, data_offset;
 	u32 seq_number;
+	u16 vid = 0xffff;
 
 	if (unlikely(ring > adapter->max_rds_rings))
 		return NULL;
@@ -1601,6 +1617,15 @@ netxen_process_lro(struct netxen_adapter *adapter,
 	skb_put(skb, lro_length + data_offset);
 
 	skb_pull(skb, l2_hdr_offset);
+
+	if (adapter->vlgrp) {
+		if (!__vlan_get_tag(skb, &vid)) {
+			eth_hdr = (struct ethhdr *) skb->data;
+			memmove(skb->data + VLAN_HLEN, eth_hdr, ETH_ALEN * 2);
+			skb_pull(skb, VLAN_HLEN);
+		}
+	}
+
 	skb->protocol = eth_type_trans(skb, netdev);
 
 	iph = (struct iphdr *)skb->data;
@@ -1615,7 +1640,10 @@ netxen_process_lro(struct netxen_adapter *adapter,
 
 	length = skb->len;
 
-	netif_receive_skb(skb);
+	if ((vid != 0xffff))
+		vlan_hwaccel_receive_skb(skb, adapter->vlgrp, vid);
+	else
+		netif_receive_skb(skb);
 
 	adapter->stats.lro_pkts++;
 	adapter->stats.rxbytes += length;
diff --git a/drivers/net/netxen/netxen_nic_main.c b/drivers/net/netxen/netxen_nic_main.c
index 6e80494..6789c62 100644
--- a/drivers/net/netxen/netxen_nic_main.c
+++ b/drivers/net/netxen/netxen_nic_main.c
@@ -477,6 +477,13 @@ static int netxen_nic_set_mac(struct net_device *netdev, void *p)
 	return 0;
 }
 
+static void netxen_vlan_rx_register(struct net_device *netdev,
+				struct vlan_group *grp)
+{
+	struct netxen_adapter *adapter = netdev_priv(netdev);
+	adapter->vlgrp = grp;
+}
+
 static void netxen_set_multicast_list(struct net_device *dev)
 {
 	struct netxen_adapter *adapter = netdev_priv(dev);
@@ -497,6 +504,7 @@ static const struct net_device_ops netxen_netdev_ops = {
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller = netxen_nic_poll_controller,
 #endif
+	.ndo_vlan_rx_register   = netxen_vlan_rx_register,
 };
 
 static void
@@ -1226,6 +1234,8 @@ netxen_setup_netdev(struct netxen_adapter *adapter,
 	if (adapter->capabilities & NX_FW_CAPABILITY_FVLANTX)
 		netdev->features |= (NETIF_F_HW_VLAN_TX);
 
+	netdev->features |= (NETIF_F_HW_VLAN_RX);
+
 	if (adapter->capabilities & NX_FW_CAPABILITY_HW_LRO)
 		netdev->features |= NETIF_F_LRO;
 
-- 
1.6.3.3

