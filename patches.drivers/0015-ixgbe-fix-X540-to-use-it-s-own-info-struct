From: "Lee, Chun-Yi" <jlee@suse.com>
Subject: [PATCH 15/16] ixgbe: fix X540 to use it's own info struct
Patch-mainline: 2.6.38
Git-commit: d994653db465616a7bf27703e733170c47488cdf
References: bnc#691742, fate#311957

From: Don Skidmore <donald.c.skidmore@intel.com>

This patch enables X540 hardware to use it's own set of support
functions.  This is useful as it has no need of SFP+ support.  A
couple minor bugs with the eeprom semaphore were also cleaned up.

Signed-off-by: Don Skidmore <donald.c.skidmore@intel.com>
Tested-by: Stephen Ko <stephen.s.ko@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
---
 drivers/net/ixgbe/ixgbe_main.c |   16 ++++++++--------
 drivers/net/ixgbe/ixgbe_x540.c |    4 ++--
 2 files changed, 10 insertions(+), 10 deletions(-)

--- a/drivers/net/ixgbe/ixgbe_main.c
+++ b/drivers/net/ixgbe/ixgbe_main.c
@@ -117,7 +117,7 @@ static struct pci_device_id ixgbe_pci_tb
 	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_COMBO_BACKPLANE),
 	 board_82599 },
 	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X540T),
-	 board_82599 },
+	 board_X540 },
 
 	/* required last entry */
 	{0, }
@@ -1388,6 +1388,13 @@ static irqreturn_t ixgbe_msix_lsc(int ir
 
 	switch (hw->mac.type) {
 	case ixgbe_mac_82599EB:
+		ixgbe_check_sfp_event(adapter, eicr);
+		if ((adapter->flags2 & IXGBE_FLAG2_TEMP_SENSOR_CAPABLE) &&
+		    ((eicr & IXGBE_EICR_GPI_SDP0) || (eicr & IXGBE_EICR_LSC))) {
+			adapter->interrupt_event = eicr;
+			schedule_work(&adapter->check_overtemp_task);
+		}
+		/* now fallthrough to handle Flow Director */
 	case ixgbe_mac_X540:
 		/* Handle Flow Director Full threshold interrupt */
 		if (eicr & IXGBE_EICR_FLOW_DIR) {
@@ -1403,12 +1410,6 @@ static irqreturn_t ixgbe_msix_lsc(int ir
 					schedule_work(&adapter->fdir_reinit_task);
 			}
 		}
-		ixgbe_check_sfp_event(adapter, eicr);
-		if ((adapter->flags2 & IXGBE_FLAG2_TEMP_SENSOR_CAPABLE) &&
-		    ((eicr & IXGBE_EICR_GPI_SDP0) || (eicr & IXGBE_EICR_LSC))) {
-			adapter->interrupt_event = eicr;
-			schedule_work(&adapter->check_overtemp_task);
-		}
 		break;
 	default:
 		break;
@@ -1989,7 +1990,6 @@ static irqreturn_t ixgbe_intr(int irq, v
 
 	switch (hw->mac.type) {
 	case ixgbe_mac_82599EB:
-	case ixgbe_mac_X540:
 		ixgbe_check_sfp_event(adapter, eicr);
 		if ((adapter->flags2 & IXGBE_FLAG2_TEMP_SENSOR_CAPABLE) &&
 		    ((eicr & IXGBE_EICR_GPI_SDP0) || (eicr & IXGBE_EICR_LSC))) {
--- a/drivers/net/ixgbe/ixgbe_x540.c
+++ b/drivers/net/ixgbe/ixgbe_x540.c
@@ -278,7 +278,7 @@ static s32 ixgbe_read_eerd_X540(struct i
 {
 	s32 status;
 
-	if (ixgbe_acquire_swfw_sync_X540(hw, IXGBE_GSSR_EEP_SM))
+	if (ixgbe_acquire_swfw_sync_X540(hw, IXGBE_GSSR_EEP_SM) == 0)
 		status = ixgbe_read_eerd_generic(hw, offset, data);
 	else
 		status = IXGBE_ERR_SWFW_SYNC;
@@ -311,7 +311,7 @@ static s32 ixgbe_write_eewr_X540(struct
 	       (data << IXGBE_EEPROM_RW_REG_DATA) |
 	       IXGBE_EEPROM_RW_REG_START;
 
-	if (ixgbe_acquire_swfw_sync_X540(hw, IXGBE_GSSR_EEP_SM)) {
+	if (ixgbe_acquire_swfw_sync_X540(hw, IXGBE_GSSR_EEP_SM) == 0) {
 		status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);
 		if (status != 0) {
 			hw_dbg(hw, "Eeprom write EEWR timed out\n");

