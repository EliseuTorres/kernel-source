From 92fd8fd13b7570f6a8ba519c4e8ec98f10a86ce9 Mon Sep 17 00:00:00 2001
From: Keith Packard <keithp@keithp.com>
Date: Mon, 25 Jul 2011 19:50:10 -0700
Subject: [PATCH] drm/i915: Use dp_detect_common in hotplug helper function
Git-commit: 92fd8fd13b7570f6a8ba519c4e8ec98f10a86ce9
Patch-mainline: 3.1-rc1

This uses the common dpcd reading routine, i915_dp_detect_common,
instead of open-coding a call to intel_dp_aux_native_read. Besides
reducing duplicated code, this also gains the read retries which
may be necessary when a cable is first plugged back in and the link
needs to be retrained.

Signed-off-by: Keith Packard <keithp@keithp.com>
Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
Reviewed-by: Adam Jackson <ajax@redhat.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/intel_dp.c |   39 +++++++++++++++++++--------------------
 1 file changed, 19 insertions(+), 20 deletions(-)

--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -1573,6 +1573,20 @@
 	POSTING_READ(intel_dp->output_reg);
 }
 
+static enum drm_connector_status
+i915_dp_detect_common(struct intel_dp *intel_dp)
+{
+	enum drm_connector_status status = connector_status_disconnected;
+
+	if (intel_dp_aux_native_read_retry(intel_dp, 0x000, intel_dp->dpcd,
+					   sizeof (intel_dp->dpcd)) &&
+	    (intel_dp->dpcd[DP_DPCD_REV] != 0)) {
+		status = connector_status_connected;
+	}
+
+	return status;
+}
+
 /*
  * According to DP spec
  * 5.1.2:
@@ -1585,45 +1599,30 @@
 static void
 intel_dp_check_link_status(struct intel_dp *intel_dp)
 {
-	int ret;
-
 	if (!intel_dp->base.base.crtc)
 		return;
 
+	/* Try to read receiver status if the link appears to be up */
 	if (!intel_dp_get_link_status(intel_dp)) {
 		intel_dp_link_down(intel_dp);
 		return;
 	}
 
-	/* Try to read receiver status if the link appears to be up */
-	ret = intel_dp_aux_native_read(intel_dp,
-				       0x000, intel_dp->dpcd,
-				       sizeof (intel_dp->dpcd));
-	if (ret != sizeof(intel_dp->dpcd)) {
+	/* Now read the DPCD to see if it's actually running */
+	if (i915_dp_detect_common(intel_dp) != connector_status_connected) {
 		intel_dp_link_down(intel_dp);
 		return;
 	}
 
 	if (!intel_channel_eq_ok(intel_dp)) {
+		DRM_DEBUG_KMS("%s: channel EQ not ok, retraining\n",
+			      drm_get_encoder_name(&intel_dp->base.base));
 		intel_dp_start_link_train(intel_dp);
 		intel_dp_complete_link_train(intel_dp);
 	}
 }
 
 static enum drm_connector_status
-i915_dp_detect_common(struct intel_dp *intel_dp)
-{
-	enum drm_connector_status status = connector_status_disconnected;
-
-	if (intel_dp_aux_native_read_retry(intel_dp, 0x000, intel_dp->dpcd,
-					   sizeof (intel_dp->dpcd)) &&
-	    (intel_dp->dpcd[DP_DPCD_REV] != 0))
-		status = connector_status_connected;
-
-	return status;
-}
-
-static enum drm_connector_status
 ironlake_dp_detect(struct intel_dp *intel_dp)
 {
 	enum drm_connector_status status;
