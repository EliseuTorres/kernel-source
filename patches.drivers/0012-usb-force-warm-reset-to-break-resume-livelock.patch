From 4de73c4aebf604d1bca5ee99567f2b177bd5f3cb Mon Sep 17 00:00:00 2001
From: Dan Williams <dan.j.williams@intel.com>
Date: Tue, 7 Jan 2014 00:32:33 -0800
Git-Commit: 7c1b24861de474b281ea96441e7c8f8a0ab6bc1e
Patch-Mainline: v3.15
References: FATE#315518
Subject: [PATCH 12/12] usb: force warm reset to break resume livelock

Resuming a powered down port sometimes results in the port state being
stuck in USB_SS_PORT_LS_POLLING:

 hub 3-0:1.0: debounce: port 1: total 2000ms stable 0ms status 0x2e0
 port1: can't get reconnection after setting port  power on, status -110
 hub 3-0:1.0: port 1 status 0000.02e0 after resume, -19
 usb 3-1: can't resume, status -19
 hub 3-0:1.0: logical disconnect on port 1

In the case above we wait 2 seconds for the port to reconnect and for
that entire time the port remained in the polling state.  A warm reset
triggers the device to reconnect and resume as normal.  With this patch
we get:

 hub 3-0:1.0: debounce: port 1: total 2000ms stable 0ms status 0x2e0
 usb usb3: port1 usb_port_runtime_resume requires warm reset
 hub 3-0:1.0: port 1 not warm reset yet, waiting 50ms
 usb 3-1: reset SuperSpeed USB device number 2 using xhci_hcd

With this in place we may want to consider reducing the timeout and
relying on warm reset for recovery.  Other xHCs that fail to propagate
warm resets on hub resume may want to trigger this behavior via a quirk.

Cc: Julius Werner <jwerner@chromium.org>
Cc: Alan Stern <stern@rowland.harvard.edu>
Cc: Vikas Sajjan <vikas.sajjan@linaro.org>
Cc: Kukjin Kim <kgene.kim@samsung.com>
Cc: Vincent Palatin <vpalatin@chromium.org>
Cc: Lan Tianyu <tianyu.lan@intel.com>
Cc: Ksenia Ragiadakou <burzalodowa@gmail.com>
Cc: Vivek Gautam <gautam.vivek@samsung.com>
Cc: Douglas Anderson <dianders@chromium.org>
Cc: Felipe Balbi <balbi@ti.com>
Cc: Sunil Joshi <joshi@samsung.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Oliver Neukum <oneukum@suse.de>
---
 drivers/usb/core/hub.c  | 23 +++++++++++++++--------
 drivers/usb/core/hub.h  |  2 ++
 drivers/usb/core/port.c | 30 +++++++++++++++++++++---------
 3 files changed, 38 insertions(+), 17 deletions(-)

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index fb211cd..28d1218 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2528,10 +2528,12 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 /* Is a USB 3.0 port in the Inactive or Complinance Mode state?
  * Port worm reset is required to recover
  */
-static bool hub_port_warm_reset_required(struct usb_hub *hub, u16 portstatus)
+static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
+					u16 portstatus)
 {
 	return hub_is_superspeed(hub->hdev) &&
-		(((portstatus & USB_PORT_STAT_LINK_STATE) ==
+		(test_bit(port1, hub->warm_reset_bits) ||
+		((portstatus & USB_PORT_STAT_LINK_STATE) ==
 		  USB_SS_PORT_LS_SS_INACTIVE) ||
 		 ((portstatus & USB_PORT_STAT_LINK_STATE) ==
 		  USB_SS_PORT_LS_COMP_MOD)) ;
@@ -2571,7 +2573,7 @@ static int hub_port_wait_reset(struct usb_hub *hub, int port1,
 	if ((portstatus & USB_PORT_STAT_RESET))
 		return -EBUSY;
 
-	if (hub_port_warm_reset_required(hub, portstatus))
+	if (hub_port_warm_reset_required(hub, port1, portstatus))
 		return -ENOTCONN;
 
 	/* Device went away? */
@@ -2670,7 +2672,7 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 		if (status < 0)
 			goto done;
 
-		if (hub_port_warm_reset_required(hub, portstatus))
+		if (hub_port_warm_reset_required(hub, port1, portstatus))
 			warm = true;
 	}
 
@@ -2709,7 +2711,7 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 					&portstatus, &portchange) < 0)
 				goto done;
 
-			if (!hub_port_warm_reset_required(hub, portstatus))
+			if (!hub_port_warm_reset_required(hub, port1, portstatus))
 				goto done;
 
 			/*
@@ -2782,8 +2784,13 @@ static int check_port_resume_type(struct usb_device *udev,
 		struct usb_hub *hub, int port1,
 		int status, unsigned portchange, unsigned portstatus)
 {
+	/* Is a warm reset needed to recover the connection? */
+	if (udev->reset_resume
+		&& hub_port_warm_reset_required(hub, port1, portstatus)) {
+		/* pass */;
+	}
 	/* Is the device still present? */
-	if (status || port_is_suspended(hub, portstatus) ||
+	else if (status || port_is_suspended(hub, portstatus) ||
 			!port_is_power_on(hub, portstatus) ||
 			!(portstatus & USB_PORT_STAT_CONNECTION)) {
 		if (status >= 0)
@@ -3926,7 +3933,7 @@ int hub_port_debounce(struct usb_hub *hub, int port1, bool must_be_connected)
 		"debounce: port %d: total %dms stable %dms status 0x%x\n",
 		port1, total_time, stable_time, portstatus);
 
-	if (stable_time < HUB_DEBOUNCE_STABLE)
+	if (stable_time < HUB_DEBOUNCE_STABLE && !must_be_connected)
 		return -ETIMEDOUT;
 	return portstatus;
 }
@@ -4790,7 +4797,7 @@ static void port_event(struct usb_hub *hub, int port1)
 		 * Warm reset a USB3 protocol port if it's in
 		 * SS.Inactive state.
 		 */
-		if (hub_port_warm_reset_required(hub, portstatus)) {
+		if (hub_port_warm_reset_required(hub, port1, portstatus)) {
 			int status;
 
 			dev_dbg(hub_dev, "port%d: do warm reset\n", port1);
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index c214fe8..0d86652 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -51,6 +51,8 @@ struct usb_hub {
 							device present */
 	unsigned long		wakeup_bits[1];	/* ports that have signaled
 							remote wakeup */
+	unsigned long		warm_reset_bits[1]; /* ports that want warm
+						       reset recovery */
 #if USB_MAXCHILDREN > 31 /* 8*sizeof(unsigned long) - 1 */
 #error event_bits[] is too short!
 #endif
diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index f04b027..f1407c9 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -96,20 +96,32 @@ static int usb_port_runtime_resume(struct device *dev)
 
 	retval = usb_hub_set_port_power(hdev, hub, port1, true);
 	if (port_dev->child && !retval) {
+		u16 portstatus;
 		/*
-		 * Attempt to wait for usb hub port to be reconnected in order
-		 * to make the resume procedure successful.  The device may have
-		 * disconnected while the port was powered off, so ignore the
-		 * return status.
+		 * Our preference is to simply wait for the port to reconnect.
+		 * However, there are cases where toggling port power results in
+		 * the host port being stuck in SS.Polling.  This is likely the
+		 * caused by the hub failing to trigger warm reset on exiting
+		 * the logical poweroff state.  We detect it here and flag the
+		 * port as needing warm reset recovery (to be performed later
+		 * by usb_port_resume())
 		 */
-		retval = hub_port_debounce_be_connected(hub, port1);
-		if (retval < 0)
-			dev_dbg(&port_dev->dev, "can't get reconnection after setting port  power on, status %d\n",
-					retval);
+		portstatus = hub_port_debounce_be_connected(hub, port1);
+		if (!(portstatus & USB_PORT_STAT_CONNECTION)
+				&& hub_is_superspeed(hdev)
+				&& (portstatus & USB_SS_PORT_LS_POLLING)) {
+			dev_dbg(&hdev->dev, "port%d %s requires warm reset\n",
+					port1, __func__);
+			set_bit(port1, hub->warm_reset_bits);
+		} else if (!(portstatus & USB_PORT_STAT_CONNECTION)) {
+			dev_dbg(&hdev->dev, "port%d %s failed reconnect\n",
+					port1, __func__);
+		}
 
 		/*
 		 * Keep this port awake until we have had a chance to recover
-		 * the child
+		 * the child.  If warm reset was flagged above it will be
++		 * carried out by the child resume reset
 		 */
 		pm_runtime_get_noresume(&port_dev->dev);
 		port_dev->resume_child = 1;
-- 
1.8.4

