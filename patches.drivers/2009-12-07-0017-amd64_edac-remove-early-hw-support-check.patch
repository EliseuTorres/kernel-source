From: Borislav Petkov <borislav.petkov@amd.com>
Subject: amd64_edac: remove early hw support check
References: fate#311968
Patch-Mainline: yes
Git-commit: 986a42a25059143d153e30a0cc36630bd0e623c6


Signed-off-by: Thomas Renninger <trenn@suse.de>

The .probe_valid_hardware low_ops member checked whether the DCTs are in
DDR3 mode and bailed out if so. Now that all the needed changes for DDR3
support is in place, remove it.

Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>

---
 drivers/edac/amd64_edac.c |   47 ----------------------------------------------
 drivers/edac/amd64_edac.h |    1 
 2 files changed, 1 insertion(+), 47 deletions(-)

Index: linux-2.6.32-SLE11-SP1/drivers/edac/amd64_edac.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/edac/amd64_edac.c
+++ linux-2.6.32-SLE11-SP1/drivers/edac/amd64_edac.c
@@ -1741,42 +1741,6 @@ static void amd64_debug_display_dimm_siz
 }
 
 /*
- * Very early hardware probe on pci_probe thread to determine if this module
- * supports the hardware.
- *
- * Return:
- *      0 for OK
- *      1 for error
- */
-static int f10_probe_valid_hardware(struct amd64_pvt *pvt)
-{
-	int ret = 0;
-
-	/*
-	 * If we are on a DDR3 machine, we don't know yet if
-	 * we support that properly at this time
-	 */
-	if ((pvt->dchr0 & DDR3_MODE) ||
-	    (pvt->dchr1 & DDR3_MODE)) {
-
-		amd64_printk(KERN_WARNING,
-			"%s() This machine is running with DDR3 memory. "
-			"This is not currently supported. "
-			"DCHR0=0x%x DCHR1=0x%x\n",
-			__func__, pvt->dchr0, pvt->dchr1);
-
-		amd64_printk(KERN_WARNING,
-			"   Contact '%s' module MAINTAINER to help add"
-			" support.\n",
-			EDAC_MOD_STR);
-
-		ret = 1;
-
-	}
-	return ret;
-}
-
-/*
  * There currently are 3 types type of MC devices for AMD Athlon/Opterons
  * (as per PCI DEVICE_IDs):
  *
@@ -1805,7 +1769,6 @@ static struct amd64_family_type amd64_fa
 		.addr_f1_ctl = PCI_DEVICE_ID_AMD_10H_NB_MAP,
 		.misc_f3_ctl = PCI_DEVICE_ID_AMD_10H_NB_MISC,
 		.ops = {
-			.probe_valid_hardware	= f10_probe_valid_hardware,
 			.early_channel_count	= f10_early_channel_count,
 			.get_error_address	= f10_get_error_address,
 			.read_dram_base_limit	= f10_read_dram_base_limit,
@@ -1819,7 +1782,6 @@ static struct amd64_family_type amd64_fa
 		.addr_f1_ctl = PCI_DEVICE_ID_AMD_11H_NB_MAP,
 		.misc_f3_ctl = PCI_DEVICE_ID_AMD_11H_NB_MISC,
 		.ops = {
-			.probe_valid_hardware	= f10_probe_valid_hardware,
 			.early_channel_count	= f10_early_channel_count,
 			.get_error_address	= f10_get_error_address,
 			.read_dram_base_limit	= f10_read_dram_base_limit,
@@ -2834,17 +2796,10 @@ static int amd64_init_2nd_stage(struct a
 {
 	int node_id = pvt->mc_node_id;
 	struct mem_ctl_info *mci;
-	int ret, err = 0;
+	int ret;
 
 	amd64_read_mc_registers(pvt);
 
-	ret = -ENODEV;
-	if (pvt->ops->probe_valid_hardware) {
-		err = pvt->ops->probe_valid_hardware(pvt);
-		if (err)
-			goto err_exit;
-	}
-
 	/*
 	 * We need to determine how many memory channels there are. Then use
 	 * that information for calculating the size of the dynamic instance
Index: linux-2.6.32-SLE11-SP1/drivers/edac/amd64_edac.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/edac/amd64_edac.h
+++ linux-2.6.32-SLE11-SP1/drivers/edac/amd64_edac.h
@@ -526,7 +526,6 @@ extern struct mcidev_sysfs_attribute amd
  * functions and per device encoding/decoding logic.
  */
 struct low_ops {
-	int (*probe_valid_hardware)	(struct amd64_pvt *pvt);
 	int (*early_channel_count)	(struct amd64_pvt *pvt);
 
 	u64 (*get_error_address)	(struct mem_ctl_info *mci,
