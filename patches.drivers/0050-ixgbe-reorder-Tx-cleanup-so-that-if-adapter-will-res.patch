From b953799ee29075afd30afe4c0fb65f278b088f69 Mon Sep 17 00:00:00 2001
From: Alexander Duyck <alexander.h.duyck@intel.com>
Date: Tue, 16 Nov 2010 19:26:58 -0800
Subject: [PATCH] ixgbe: reorder Tx cleanup so that if adapter will reset we don't rearm
Patch-mainline: v2.6.38-rc1
Git-commit: b953799ee29075afd30afe4c0fb65f278b088f69
References: bnc#687049, fate#311821

The code as it existed could re-arm the queues when it was requesting a HW
reset due to a TX hang. Instead of doing that this change makes it so that
we will just exit if the hardware is believed to be hung.

Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
Tested-by: Ross Brattain <ross.b.brattain@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Signed-off-by: Joey Lee <jlee@suse.com>

---
 drivers/net/ixgbe/ixgbe_main.c |   37 +++++++++++++++++--------------------
 1 file changed, 17 insertions(+), 20 deletions(-)

--- a/drivers/net/ixgbe/ixgbe_main.c
+++ b/drivers/net/ixgbe/ixgbe_main.c
@@ -405,8 +405,8 @@ static bool ixgbe_clean_tx_irq(struct ix
 	struct net_device *netdev = adapter->netdev;
 	union ixgbe_adv_tx_desc *tx_desc, *eop_desc;
 	struct ixgbe_tx_buffer *tx_buffer_info;
-	unsigned int i, eop, count = 0;
 	unsigned int total_bytes = 0, total_packets = 0;
+	u16 i, eop, count = 0;
 
 	i = tx_ring->next_to_clean;
 	eop = tx_ring->tx_buffer_info[i].next_to_watch;
@@ -462,6 +462,22 @@ static bool ixgbe_clean_tx_irq(struct ix
 	}
 
 	tx_ring->next_to_clean = i;
+	tx_ring->total_bytes += total_bytes;
+	tx_ring->total_packets += total_packets;
+	tx_ring->stats.packets += total_packets;
+	tx_ring->stats.bytes += total_bytes;
+
+	if (check_for_tx_hang(tx_ring) &&
+	    ixgbe_check_tx_hang(adapter, tx_ring, i)) {
+		/* schedule immediate reset if we believe we hung */
+		DPRINTK(PROBE, INFO,
+			"tx hang %d detected, resetting adapter\n",
+			adapter->tx_timeout_count + 1);
+		ixgbe_tx_timeout(adapter->netdev);
+
+		/* the adapter is about to reset, no point in enabling stuff */
+		return true;
+	}
 
 #define TX_WAKE_THRESHOLD (DESC_NEEDED * 2)
 	if (unlikely(count && netif_carrier_ok(netdev) &&
@@ -477,25 +493,6 @@ static bool ixgbe_clean_tx_irq(struct ix
 		}
 	}
 
-	if (check_for_tx_hang(tx_ring) &&
-	    ixgbe_check_tx_hang(adapter, tx_ring, i)) {
-		/* schedule immediate reset if we believe we hung */
-		DPRINTK(PROBE, INFO,
-			"tx hang %d detected, resetting adapter\n",
-			adapter->tx_timeout_count + 1);
-		ixgbe_tx_timeout(adapter->netdev);
-	}
-
-	/* re-arm the interrupt */
-	if (count >= tx_ring->work_limit)
-		ixgbe_irq_rearm_queues(adapter, ((u64)1 << q_vector->v_idx));
-
-	tx_ring->total_bytes += total_bytes;
-	tx_ring->total_packets += total_packets;
-	tx_ring->stats.packets += total_packets;
-	tx_ring->stats.bytes += total_bytes;
-	netdev->stats.tx_bytes += total_bytes;
-	netdev->stats.tx_packets += total_packets;
 	return (count < tx_ring->work_limit);
 }
 
