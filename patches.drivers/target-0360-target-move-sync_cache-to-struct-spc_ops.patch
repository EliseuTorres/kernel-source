From: Christoph Hellwig <hch@infradead.org>
Date: Sun, 17 Jun 2012 18:40:53 -0400
Subject: [PATCH] target: move sync_cache to struct spc_ops
Git-commit: ad67f0d9e63ca94661e06a145f05a9302368a826
References: FATE#313550
Patch-Mainline: v3.6

Add spc_ops->execute_sync_cache() caller for ->execute_cmd() setup,
and update IBLOCK + FILEIO backends to use it.

Signed-off-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/target/target_core_file.c    |    8 +++++---
 drivers/target/target_core_iblock.c  |    5 +++--
 drivers/target/target_core_sbc.c     |   18 ++++--------------
 include/target/target_core_backend.h |    2 +-
 4 files changed, 13 insertions(+), 20 deletions(-)

diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c
index 720ed59..9e21005 100644
--- a/drivers/target/target_core_file.c
+++ b/drivers/target/target_core_file.c
@@ -331,7 +331,7 @@ static int fd_do_writev(struct se_cmd *cmd, struct scatterlist *sgl,
 	return 1;
 }
 
-static void fd_emulate_sync_cache(struct se_cmd *cmd)
+static int fd_execute_sync_cache(struct se_cmd *cmd)
 {
 	struct se_device *dev = cmd->se_dev;
 	struct fd_dev *fd_dev = dev->dev_ptr;
@@ -365,7 +365,7 @@ static void fd_emulate_sync_cache(struct se_cmd *cmd)
 		pr_err("FILEIO: vfs_fsync_range() failed: %d\n", ret);
 
 	if (immed)
-		return;
+		return 0;
 
 	if (ret) {
 		cmd->scsi_sense_reason = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
@@ -373,6 +373,8 @@ static void fd_emulate_sync_cache(struct se_cmd *cmd)
 	} else {
 		target_complete_cmd(cmd, SAM_STAT_GOOD);
 	}
+
+	return 0;
 }
 
 static int fd_execute_rw(struct se_cmd *cmd)
@@ -554,6 +556,7 @@ static sector_t fd_get_blocks(struct se_device *dev)
 
 static struct spc_ops fd_spc_ops = {
 	.execute_rw		= fd_execute_rw,
+	.execute_sync_cache	= fd_execute_sync_cache,
 };
 
 static int fd_parse_cdb(struct se_cmd *cmd)
@@ -573,7 +576,6 @@ static struct se_subsystem_api fileio_template = {
 	.create_virtdevice	= fd_create_virtdevice,
 	.free_device		= fd_free_device,
 	.parse_cdb		= fd_parse_cdb,
-	.do_sync_cache		= fd_emulate_sync_cache,
 	.check_configfs_dev_params = fd_check_configfs_dev_params,
 	.set_configfs_dev_params = fd_set_configfs_dev_params,
 	.show_configfs_dev_params = fd_show_configfs_dev_params,
diff --git a/drivers/target/target_core_iblock.c b/drivers/target/target_core_iblock.c
index eb94367..863c962 100644
--- a/drivers/target/target_core_iblock.c
+++ b/drivers/target/target_core_iblock.c
@@ -296,7 +296,7 @@ static void iblock_end_io_flush(struct bio *bio, int err)
  * Implement SYCHRONIZE CACHE.  Note that we can't handle lba ranges and must
  * always flush the whole cache.
  */
-static void iblock_emulate_sync_cache(struct se_cmd *cmd)
+static int iblock_execute_sync_cache(struct se_cmd *cmd)
 {
 	struct iblock_dev *ib_dev = cmd->se_dev->dev_ptr;
 	int immed = (cmd->t_task_cdb[1] & 0x2);
@@ -315,6 +315,7 @@ static void iblock_emulate_sync_cache(struct se_cmd *cmd)
 	if (!immed)
 		bio->bi_private = cmd;
 	submit_bio(WRITE_FLUSH, bio);
+	return 0;
 }
 
 static int iblock_do_discard(struct se_device *dev, sector_t lba, u32 range)
@@ -667,6 +668,7 @@ static void iblock_bio_done(struct bio *bio, int err)
 
 static struct spc_ops iblock_spc_ops = {
 	.execute_rw		= iblock_execute_rw,
+	.execute_sync_cache	= iblock_execute_sync_cache,
 };
 
 static int iblock_parse_cdb(struct se_cmd *cmd)
@@ -687,7 +689,6 @@ static struct se_subsystem_api iblock_template = {
 	.free_device		= iblock_free_device,
 	.parse_cdb		= iblock_parse_cdb,
 	.do_discard		= iblock_do_discard,
-	.do_sync_cache		= iblock_emulate_sync_cache,
 	.check_configfs_dev_params = iblock_check_configfs_dev_params,
 	.set_configfs_dev_params = iblock_set_configfs_dev_params,
 	.show_configfs_dev_params = iblock_show_configfs_dev_params,
diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c
index da441b2..377c510 100644
--- a/drivers/target/target_core_sbc.c
+++ b/drivers/target/target_core_sbc.c
@@ -204,19 +204,6 @@ static int sbc_emulate_write_same(struct se_cmd *cmd)
 	return 0;
 }
 
-static int sbc_emulate_synchronize_cache(struct se_cmd *cmd)
-{
-	if (!cmd->se_dev->transport->do_sync_cache) {
-		pr_err("SYNCHRONIZE_CACHE emulation not supported"
-			" for: %s\n", cmd->se_dev->transport->name);
-		cmd->scsi_sense_reason = TCM_UNSUPPORTED_SCSI_OPCODE;
-		return -ENOSYS;
-	}
-
-	cmd->se_dev->transport->do_sync_cache(cmd);
-	return 0;
-}
-
 static int sbc_emulate_verify(struct se_cmd *cmd)
 {
 	target_complete_cmd(cmd, GOOD);
@@ -541,6 +528,9 @@ int sbc_parse_cdb(struct se_cmd *cmd, struct spc_ops *ops)
 		break;
 	case SYNCHRONIZE_CACHE:
 	case SYNCHRONIZE_CACHE_16:
+		if (!ops->execute_sync_cache)
+			goto out_unsupported_cdb;
+
 		/*
 		 * Extract LBA and range to be flushed for emulated SYNCHRONIZE_CACHE
 		 */
@@ -562,7 +552,7 @@ int sbc_parse_cdb(struct se_cmd *cmd, struct spc_ops *ops)
 			if (sbc_check_valid_sectors(cmd) < 0)
 				goto out_invalid_cdb_field;
 		}
-		cmd->execute_cmd = sbc_emulate_synchronize_cache;
+		cmd->execute_cmd = ops->execute_sync_cache;
 		break;
 	case UNMAP:
 		size = get_unaligned_be16(&cdb[7]);
diff --git a/include/target/target_core_backend.h b/include/target/target_core_backend.h
index 9b4f2c9..5797b11 100644
--- a/include/target/target_core_backend.h
+++ b/include/target/target_core_backend.h
@@ -27,7 +27,6 @@ struct se_subsystem_api {
 
 	int (*parse_cdb)(struct se_cmd *cmd);
 	int (*do_discard)(struct se_device *, sector_t, u32);
-	void (*do_sync_cache)(struct se_cmd *);
 	ssize_t (*check_configfs_dev_params)(struct se_hba *,
 			struct se_subsystem_dev *);
 	ssize_t (*set_configfs_dev_params)(struct se_hba *,
@@ -42,6 +41,7 @@ struct se_subsystem_api {
 
 struct spc_ops {
 	int (*execute_rw)(struct se_cmd *cmd);
+	int (*execute_sync_cache)(struct se_cmd *cmd);
 };
 
 int	transport_subsystem_register(struct se_subsystem_api *);
-- 
1.7.4.2

