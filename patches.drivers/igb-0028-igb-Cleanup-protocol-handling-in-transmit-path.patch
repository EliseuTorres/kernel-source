From: Alexander Duyck <alexander.h.duyck@intel.com>
Date: Fri, 26 Aug 2011 07:44:53 +0000
Subject: igb: Cleanup protocol handling in transmit path
Patch-mainline: v3.2-rc1
Git-commit: 31f6adbb352ae118550ab51f2a5ed1023ec7eb03
References: bnc#795297 FATE#313656

This change is meant to cleanup the protocol handling in the transmit path
so that it correctly offloads software VLAN tagged frames.

Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
Tested-by:  Aaron Brown  <aaron.f.brown@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: David Chang <dchang@suse.com>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ethernet/intel/igb/igb_main.c |   23 +++++++++++------------
 1 file changed, 11 insertions(+), 12 deletions(-)

--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -3997,8 +3997,8 @@ void igb_tx_ctxtdesc(struct igb_ring *tx
 	context_desc->mss_l4len_idx	= cpu_to_le32(mss_l4len_idx);
 }
 
-static inline int igb_tso(struct igb_ring *tx_ring,
-			  struct sk_buff *skb, u32 tx_flags, u8 *hdr_len)
+static inline int igb_tso(struct igb_ring *tx_ring, struct sk_buff *skb,
+			  u32 tx_flags, __be16 protocol, u8 *hdr_len)
 {
 	int err;
 	u32 vlan_macip_lens, type_tucmd;
@@ -4016,7 +4016,7 @@ static inline int igb_tso(struct igb_rin
 	/* ADV DTYP TUCMD MKRLOC/ISCSIHEDLEN */
 	type_tucmd = E1000_ADVTXD_TUCMD_L4T_TCP;
 
-	if (skb->protocol == htons(ETH_P_IP)) {
+	if (protocol == __constant_htons(ETH_P_IP)) {
 		struct iphdr *iph = ip_hdr(skb);
 		iph->tot_len = 0;
 		iph->check = 0;
@@ -4049,8 +4049,8 @@ static inline int igb_tso(struct igb_rin
 	return 1;
 }
 
-static inline bool igb_tx_csum(struct igb_ring *tx_ring,
-			       struct sk_buff *skb, u32 tx_flags)
+static inline bool igb_tx_csum(struct igb_ring *tx_ring, struct sk_buff *skb,
+			       u32 tx_flags, __be16 protocol)
 {
 	u32 vlan_macip_lens = 0;
 	u32 mss_l4len_idx = 0;
@@ -4061,7 +4061,7 @@ static inline bool igb_tx_csum(struct ig
 			return false;
 	} else {
 		u8 l4_hdr = 0;
-		switch (skb->protocol) {
+		switch (protocol) {
 		case __constant_htons(ETH_P_IP):
 			vlan_macip_lens |= skb_network_header_len(skb);
 			type_tucmd |= E1000_ADVTXD_TUCMD_IPV4;
@@ -4075,7 +4075,7 @@ static inline bool igb_tx_csum(struct ig
 			if (unlikely(net_ratelimit())) {
 				dev_warn(tx_ring->dev,
 				 "partial checksum but proto=%x!\n",
-				 skb->protocol);
+				 protocol);
 			}
 			break;
 		}
@@ -4315,6 +4315,7 @@ netdev_tx_t igb_xmit_frame_ring(struct s
 	struct igb_tx_buffer *first;
 	int tso, count;
 	u32 tx_flags = 0;
+	__be16 protocol = vlan_get_protocol(skb);
 	u8 hdr_len = 0;
 
 	/* need: 1 descriptor per page,
@@ -4340,16 +4341,14 @@ netdev_tx_t igb_xmit_frame_ring(struct s
 	/* record the location of the first descriptor for this packet */
 	first = &tx_ring->tx_buffer_info[tx_ring->next_to_use];
 
-	tso = igb_tso(tx_ring, skb, tx_flags, &hdr_len);
-
+	tso = igb_tso(tx_ring, skb, tx_flags, protocol, &hdr_len);
 	if (tso < 0) {
 		goto out_drop;
 	} else if (tso) {
 		tx_flags |= IGB_TX_FLAGS_TSO | IGB_TX_FLAGS_CSUM;
-		if (skb->protocol == htons(ETH_P_IP))
+		if (protocol == htons(ETH_P_IP))
 			tx_flags |= IGB_TX_FLAGS_IPV4;
-
-	} else if (igb_tx_csum(tx_ring, skb, tx_flags) &&
+	} else if (igb_tx_csum(tx_ring, skb, tx_flags, protocol) &&
 		   (skb->ip_summed == CHECKSUM_PARTIAL)) {
 		tx_flags |= IGB_TX_FLAGS_CSUM;
 	}
