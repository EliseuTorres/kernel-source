From: Gary Hade <garyhade@us.ibm.com>
Subject: ACPI, APEI: Fix incorrect APEI register bit width check and usage
References: bnc#725592
Patch-Mainline: v3.4-rc1
Git-commit: 15afae604651d4e17652d2ffb56f5e36f991cfef


Signed-off-by: Thomas Renninger <trenn@suse.de>

The current code incorrectly assumes that
(1) the APEI register bit width is always 8, 16, 32, or 64 and
(2) the APEI register bit width is always equal to the APEI
    register access width.

ERST serialization instructions entries such as:

[030h 0048   1]                       Action : 00 [Begin Write Operation]
[031h 0049   1]                  Instruction : 03 [Write Register Value]
[032h 0050   1]        Flags (decoded below) : 01
                      Preserve Register Bits : 1
[033h 0051   1]                     Reserved : 00

[034h 0052  12]              Register Region : [Generic Address Structure]
[034h 0052   1]                     Space ID : 00 [SystemMemory]
[035h 0053   1]                    Bit Width : 03
[036h 0054   1]                   Bit Offset : 00
[037h 0055   1]         Encoded Access Width : 03 [DWord Access:32]
[038h 0056   8]                      Address : 000000007F2D7038

[040h 0064   8]                        Value : 0000000000000001
[048h 0072   8]                         Mask : 0000000000000007

break this assumption by yielding:
  [Firmware Bug]: APEI: Invalid bit width in GAR [0x7f2d7038/3/0]

I have found no ACPI specification requirements corresponding
with the above assumptions.  There is even a good example in
the Serialization Instruction Entries section (ACPI 4.0 section
17.4,1.2, ACPI 4.0a section 2.5.1.2, ACPI 5.0 section 18.5.1.2)
that mentions a serialization instruction with a bit range of
[6:2] which is 5 bits wide, _not_ 8, 16, 32, or 64 bits wide.

Compile and boot tested with 3.3.0-rc7 on a IBM HX5.

Signed-off-by: Gary Hade <garyhade@us.ibm.com>
Signed-off-by: Len Brown <len.brown@intel.com>

---
 drivers/acpi/apei/apei-base.c |   42 +++++++++++++++++++++---------
 drivers/acpi/atomicio.c       |   58 +++++++++++++++++++++++++++---------------
 2 files changed, 67 insertions(+), 33 deletions(-)

Index: linux-3.0-SLE11-SP2/drivers/acpi/apei/apei-base.c
===================================================================
--- linux-3.0-SLE11-SP2.orig/drivers/acpi/apei/apei-base.c
+++ linux-3.0-SLE11-SP2/drivers/acpi/apei/apei-base.c
@@ -520,33 +520,48 @@ void apei_resources_release(struct apei_
 }
 EXPORT_SYMBOL_GPL(apei_resources_release);
 
-static int apei_check_gar(struct acpi_generic_address *reg, u64 *paddr)
+static int apei_check_gar(struct acpi_generic_address *reg, u64 *paddr,
+				u32 *access_bit_width)
 {
-	u32 width, space_id;
+	u32 bit_width, bit_offset, access_size_code, space_id;
 
-	width = reg->bit_width;
+	bit_width = reg->bit_width;
+	bit_offset = reg->bit_offset;
+	access_size_code = reg->access_width;
 	space_id = reg->space_id;
 	/* Handle possible alignment issues */
 	memcpy(paddr, &reg->address, sizeof(*paddr));
 	if (!*paddr) {
 		pr_warning(FW_BUG APEI_PFX
-			   "Invalid physical address in GAR [0x%llx/%u/%u]\n",
-			   *paddr, width, space_id);
+			   "Invalid physical address in GAR [0x%llx/%u/%u/%u/%u]\n",
+			   *paddr, bit_width, bit_offset, access_size_code,
+			   space_id);
 		return -EINVAL;
 	}
 
-	if ((width != 8) && (width != 16) && (width != 32) && (width != 64)) {
+	if (access_size_code < 1 || access_size_code > 4) {
 		pr_warning(FW_BUG APEI_PFX
-			   "Invalid bit width in GAR [0x%llx/%u/%u]\n",
-			   *paddr, width, space_id);
+			   "Invalid access size code in GAR [0x%llx/%u/%u/%u/%u]\n",
+			   *paddr, bit_width, bit_offset, access_size_code,
+			   space_id);
+		return -EINVAL;
+	}
+	*access_bit_width = 1UL << (access_size_code + 2);
+
+	if ((bit_width + bit_offset) > *access_bit_width) {
+		pr_warning(FW_BUG APEI_PFX
+			   "Invalid bit width + offset in GAR [0x%llx/%u/%u/%u/%u]\n",
+			   *paddr, bit_width, bit_offset, access_size_code,
+			   space_id);
 		return -EINVAL;
 	}
 
 	if (space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY &&
 	    space_id != ACPI_ADR_SPACE_SYSTEM_IO) {
 		pr_warning(FW_BUG APEI_PFX
-			   "Invalid address space type in GAR [0x%llx/%u/%u]\n",
-			   *paddr, width, space_id);
+			   "Invalid address space type in GAR [0x%llx/%u/%u/%u/%u]\n",
+			   *paddr, bit_width, bit_offset, access_size_code,
+			   space_id);
 		return -EINVAL;
 	}
 
@@ -560,23 +575,24 @@ static int collect_res_callback(struct a
 	struct apei_resources *resources = data;
 	struct acpi_generic_address *reg = &entry->register_region;
 	u8 ins = entry->instruction;
+	u32 access_bit_width;
 	u64 paddr;
 	int rc;
 
 	if (!(ctx->ins_table[ins].flags & APEI_EXEC_INS_ACCESS_REGISTER))
 		return 0;
 
-	rc = apei_check_gar(reg, &paddr);
+	rc = apei_check_gar(reg, &paddr, &access_bit_width);
 	if (rc)
 		return rc;
 
 	switch (reg->space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
 		return apei_res_add(&resources->iomem, paddr,
-				    reg->bit_width / 8);
+				    access_bit_width / 8);
 	case ACPI_ADR_SPACE_SYSTEM_IO:
 		return apei_res_add(&resources->ioport, paddr,
-				    reg->bit_width / 8);
+				    access_bit_width / 8);
 	default:
 		return -EINVAL;
 	}
Index: linux-3.0-SLE11-SP2/drivers/acpi/atomicio.c
===================================================================
--- linux-3.0-SLE11-SP2.orig/drivers/acpi/atomicio.c
+++ linux-3.0-SLE11-SP2/drivers/acpi/atomicio.c
@@ -183,27 +183,40 @@ static void acpi_post_unmap(phys_addr_t
 
 /* In NMI handler, should set silent = 1 */
 static int acpi_check_gar(struct acpi_generic_address *reg,
-			  u64 *paddr, int silent)
+			  u64 *paddr, u32 *access_bit_width, int silent)
 {
-	u32 width, space_id;
+	u32 bit_width, bit_offset, access_size_code, space_id;
 
-	width = reg->bit_width;
+	bit_width = reg->bit_width;
+	bit_offset = reg->bit_offset;
+	access_size_code = reg->access_width;
 	space_id = reg->space_id;
 	/* Handle possible alignment issues */
 	memcpy(paddr, &reg->address, sizeof(*paddr));
 	if (!*paddr) {
 		if (!silent)
 			pr_warning(FW_BUG ACPI_PFX
-			"Invalid physical address in GAR [0x%llx/%u/%u]\n",
-				   *paddr, width, space_id);
+			   "Invalid physical address in GAR [0x%llx/%u/%u/%u/%u]\n",
+			   *paddr, bit_width, bit_offset, access_size_code,
+			   space_id);
 		return -EINVAL;
 	}
 
-	if ((width != 8) && (width != 16) && (width != 32) && (width != 64)) {
+	if (access_size_code < 1 || access_size_code > 4) {
 		if (!silent)
 			pr_warning(FW_BUG ACPI_PFX
-				   "Invalid bit width in GAR [0x%llx/%u/%u]\n",
-				   *paddr, width, space_id);
+			   "Invalid access size code in GAR [0x%llx/%u/%u/%u/%u]\n",
+			   *paddr, bit_width, bit_offset, access_size_code,
+			   space_id);
+		return -EINVAL;
+	}
+	*access_bit_width = 1UL << (access_size_code + 2);
+
+	if ((bit_width + bit_offset) > *access_bit_width) {
+		pr_warning(FW_BUG ACPI_PFX
+			   "Invalid bit width + offset in GAR [0x%llx/%u/%u/%u/%u]\n",
+			   *paddr, bit_width, bit_offset, access_size_code,
+			   space_id);
 		return -EINVAL;
 	}
 
@@ -211,8 +224,9 @@ static int acpi_check_gar(struct acpi_ge
 	    space_id != ACPI_ADR_SPACE_SYSTEM_IO) {
 		if (!silent)
 			pr_warning(FW_BUG ACPI_PFX
-			"Invalid address space type in GAR [0x%llx/%u/%u]\n",
-				   *paddr, width, space_id);
+			   "Invalid address space type in GAR [0x%llx/%u/%u/%u/%u]\n",
+			   *paddr, bit_width, bit_offset, access_size_code,
+			   space_id);
 		return -EINVAL;
 	}
 
@@ -225,15 +239,16 @@ int acpi_pre_map_gar(struct acpi_generic
 	u64 paddr;
 	void __iomem *vaddr;
 	int rc;
+	u32 access_bit_width;
 
 	if (reg->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
 		return 0;
 
-	rc = acpi_check_gar(reg, &paddr, 0);
+	rc = acpi_check_gar(reg, &paddr, &access_bit_width, 0);
 	if (rc)
 		return rc;
 
-	vaddr = acpi_pre_map(paddr, reg->bit_width / 8);
+	vaddr = acpi_pre_map(paddr, access_bit_width / 8);
 	if (!vaddr)
 		return -EIO;
 
@@ -246,15 +261,16 @@ int acpi_post_unmap_gar(struct acpi_gene
 {
 	u64 paddr;
 	int rc;
+	u32 access_bit_width;
 
 	if (reg->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)
 		return 0;
 
-	rc = acpi_check_gar(reg, &paddr, 0);
+	rc = acpi_check_gar(reg, &paddr, &access_bit_width, 0);
 	if (rc)
 		return rc;
 
-	acpi_post_unmap(paddr, reg->bit_width / 8);
+	acpi_post_unmap(paddr, access_bit_width / 8);
 
 	return 0;
 }
@@ -327,17 +343,18 @@ int acpi_atomic_read(u64 *val, struct ac
 {
 	u64 paddr;
 	int rc;
+	u32 access_bit_width;
 
-	rc = acpi_check_gar(reg, &paddr, 1);
+	rc = acpi_check_gar(reg, &paddr, &access_bit_width, 1);
 	if (rc)
 		return rc;
 
 	*val = 0;
 	switch (reg->space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
-		return acpi_atomic_read_mem(paddr, val, reg->bit_width);
+		return acpi_atomic_read_mem(paddr, val, access_bit_width);
 	case ACPI_ADR_SPACE_SYSTEM_IO:
-		return acpi_os_read_port(paddr, (u32 *)val, reg->bit_width);
+		return acpi_os_read_port(paddr, (u32 *)val, access_bit_width);
 	default:
 		return -EINVAL;
 	}
@@ -348,16 +365,17 @@ int acpi_atomic_write(u64 val, struct ac
 {
 	u64 paddr;
 	int rc;
+	u32 access_bit_width;
 
-	rc = acpi_check_gar(reg, &paddr, 1);
+	rc = acpi_check_gar(reg, &paddr, &access_bit_width, 1);
 	if (rc)
 		return rc;
 
 	switch (reg->space_id) {
 	case ACPI_ADR_SPACE_SYSTEM_MEMORY:
-		return acpi_atomic_write_mem(paddr, val, reg->bit_width);
+		return acpi_atomic_write_mem(paddr, val, access_bit_width);
 	case ACPI_ADR_SPACE_SYSTEM_IO:
-		return acpi_os_write_port(paddr, val, reg->bit_width);
+		return acpi_os_write_port(paddr, val, access_bit_width);
 	default:
 		return -EINVAL;
 	}
