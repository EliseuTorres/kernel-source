From: Dan Williams <dan.j.williams@intel.com>
Date: Sun, 8 May 2011 21:36:46 -0700
Subject: [PATCH 181/273] isci: uplevel register hardware data structures and unsolicited frame handling
Git-commit: 63a3a15fb00ef49e50e98ff675094afcd92f113a
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Reported-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/Makefile                         |    2 +-
 drivers/scsi/isci/core/scic_sds_phy.h              |    2 +-
 drivers/scsi/isci/core/scic_sds_port.c             |    2 +-
 drivers/scsi/isci/core/scic_sds_port.h             |    2 +-
 drivers/scsi/isci/core/scic_sds_port_registers.h   |   66 -
 drivers/scsi/isci/core/scic_sds_request.c          |    4 +-
 drivers/scsi/isci/core/scic_sds_stp_request.c      |    2 +-
 .../isci/core/scic_sds_unsolicited_frame_control.c |  357 ----
 .../isci/core/scic_sds_unsolicited_frame_control.h |  251 ---
 drivers/scsi/isci/core/scu_completion_codes.h      |  283 ---
 drivers/scsi/isci/core/scu_event_codes.h           |  336 ----
 drivers/scsi/isci/core/scu_registers.h             | 1826 ------------------
 drivers/scsi/isci/core/scu_task_context.h          |  942 ----------
 drivers/scsi/isci/core/scu_unsolicited_frame.h     |  117 --
 drivers/scsi/isci/core/scu_viit_data.h             |  178 --
 drivers/scsi/isci/host.c                           |    2 +-
 drivers/scsi/isci/host.h                           |    4 +-
 drivers/scsi/isci/registers.h                      | 1934 ++++++++++++++++++++
 drivers/scsi/isci/scu_completion_codes.h           |  283 +++
 drivers/scsi/isci/scu_event_codes.h                |  336 ++++
 drivers/scsi/isci/scu_task_context.h               |  942 ++++++++++
 drivers/scsi/isci/scu_unsolicited_frame.h          |  117 ++
 drivers/scsi/isci/unsolicited_frame_control.c      |  357 ++++
 drivers/scsi/isci/unsolicited_frame_control.h      |  251 +++
 24 files changed, 4230 insertions(+), 4366 deletions(-)
 delete mode 100644 drivers/scsi/isci/core/scic_sds_port_registers.h
 delete mode 100644 drivers/scsi/isci/core/scic_sds_unsolicited_frame_control.c
 delete mode 100644 drivers/scsi/isci/core/scic_sds_unsolicited_frame_control.h
 delete mode 100644 drivers/scsi/isci/core/scu_completion_codes.h
 delete mode 100644 drivers/scsi/isci/core/scu_event_codes.h
 delete mode 100644 drivers/scsi/isci/core/scu_registers.h
 delete mode 100644 drivers/scsi/isci/core/scu_task_context.h
 delete mode 100644 drivers/scsi/isci/core/scu_unsolicited_frame.h
 delete mode 100644 drivers/scsi/isci/core/scu_viit_data.h
 create mode 100644 drivers/scsi/isci/registers.h
 create mode 100644 drivers/scsi/isci/scu_completion_codes.h
 create mode 100644 drivers/scsi/isci/scu_event_codes.h
 create mode 100644 drivers/scsi/isci/scu_task_context.h
 create mode 100644 drivers/scsi/isci/scu_unsolicited_frame.h
 create mode 100644 drivers/scsi/isci/unsolicited_frame_control.c
 create mode 100644 drivers/scsi/isci/unsolicited_frame_control.h

diff --git a/drivers/scsi/isci/Makefile b/drivers/scsi/isci/Makefile
index 45f8f68..0153b0f 100644
--- a/drivers/scsi/isci/Makefile
+++ b/drivers/scsi/isci/Makefile
@@ -5,6 +5,7 @@ isci-objs := init.o phy.o request.o sata.o \
 	     host.o task.o probe_roms.o \
 	     remote_node_context.o \
 	     remote_node_table.o \
+	     unsolicited_frame_control.o \
 	     core/scic_sds_request.o \
 	     core/scic_sds_stp_request.o \
 	     core/scic_sds_port.o \
@@ -12,6 +13,5 @@ isci-objs := init.o phy.o request.o sata.o \
 	     core/scic_sds_phy.o \
 	     core/scic_sds_ssp_request.o \
 	     core/scic_sds_smp_request.o \
-	     core/scic_sds_unsolicited_frame_control.o \
 	     core/sci_base_state_machine.o \
 	     core/sci_util.o
diff --git a/drivers/scsi/isci/core/scic_sds_phy.h b/drivers/scsi/isci/core/scic_sds_phy.h
index c40c09b..472718d 100644
--- a/drivers/scsi/isci/core/scic_sds_phy.h
+++ b/drivers/scsi/isci/core/scic_sds_phy.h
@@ -58,7 +58,7 @@
 
 #include "sas.h"
 #include "scic_phy.h"
-#include "scu_registers.h"
+#include "registers.h"
 #include "sci_base_state_machine.h"
 #include <scsi/libsas.h>
 
diff --git a/drivers/scsi/isci/core/scic_sds_port.c b/drivers/scsi/isci/core/scic_sds_port.c
index 652d823..652917e 100644
--- a/drivers/scsi/isci/core/scic_sds_port.c
+++ b/drivers/scsi/isci/core/scic_sds_port.c
@@ -61,7 +61,7 @@
 #include "remote_device.h"
 #include "remote_node_context.h"
 #include "scic_sds_request.h"
-#include "scu_registers.h"
+#include "registers.h"
 #include "timers.h"
 
 #define SCIC_SDS_PORT_MIN_TIMER_COUNT  (SCI_MAX_PORTS)
diff --git a/drivers/scsi/isci/core/scic_sds_port.h b/drivers/scsi/isci/core/scic_sds_port.h
index bd612d5..4b28c5a 100644
--- a/drivers/scsi/isci/core/scic_sds_port.h
+++ b/drivers/scsi/isci/core/scic_sds_port.h
@@ -59,7 +59,7 @@
 #include <linux/kernel.h>
 #include "isci.h"
 #include "sas.h"
-#include "scu_registers.h"
+#include "registers.h"
 #include "sci_base_state_machine.h"
 
 struct scic_sds_controller;
diff --git a/drivers/scsi/isci/core/scic_sds_port_registers.h b/drivers/scsi/isci/core/scic_sds_port_registers.h
deleted file mode 100644
index 01e24e5..0000000
--- a/drivers/scsi/isci/core/scic_sds_port_registers.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCIC_SDS_PORT_REGISTERS_H_
-#define _SCIC_SDS_PORT_REGISTERS_H_
-
-/**
- * This file contains a set of macros that assist in reading the SCU hardware
- *    registers.
- *
- *
- */
-
-#endif /* _SCIC_SDS_PORT_REGISTERS_H_ */
diff --git a/drivers/scsi/isci/core/scic_sds_request.c b/drivers/scsi/isci/core/scic_sds_request.c
index 1405aa7..cd27960 100644
--- a/drivers/scsi/isci/core/scic_sds_request.c
+++ b/drivers/scsi/isci/core/scic_sds_request.c
@@ -55,13 +55,13 @@
 
 #include <scsi/sas.h>
 #include "scic_io_request.h"
-#include "scu_registers.h"
+#include "registers.h"
 #include "scic_sds_port.h"
 #include "remote_device.h"
 #include "scic_sds_request.h"
 #include "scic_sds_smp_request.h"
 #include "scic_sds_stp_request.h"
-#include "scic_sds_unsolicited_frame_control.h"
+#include "unsolicited_frame_control.h"
 #include "sci_util.h"
 #include "scu_completion_codes.h"
 #include "scu_task_context.h"
diff --git a/drivers/scsi/isci/core/scic_sds_stp_request.c b/drivers/scsi/isci/core/scic_sds_stp_request.c
index 2f50951..9a787e2 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_request.c
+++ b/drivers/scsi/isci/core/scic_sds_stp_request.c
@@ -62,7 +62,7 @@
 #include "scic_sds_request.h"
 #include "scic_sds_stp_pio_request.h"
 #include "scic_sds_stp_request.h"
-#include "scic_sds_unsolicited_frame_control.h"
+#include "unsolicited_frame_control.h"
 #include "sci_util.h"
 #include "scu_completion_codes.h"
 #include "scu_event_codes.h"
diff --git a/drivers/scsi/isci/core/scic_sds_unsolicited_frame_control.c b/drivers/scsi/isci/core/scic_sds_unsolicited_frame_control.c
deleted file mode 100644
index d0e0373..0000000
--- a/drivers/scsi/isci/core/scic_sds_unsolicited_frame_control.c
+++ /dev/null
@@ -1,357 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "host.h"
-#include "scic_sds_unsolicited_frame_control.h"
-#include "scu_registers.h"
-#include "sci_util.h"
-
-/**
- * This method will program the unsolicited frames (UFs) into the UF address
- *    table and construct the UF frame structure being modeled in the core.  It
- *    will handle the case where some of the UFs are not being used and thus
- *    should have entries programmed to zero in the address table.
- * @uf_control: This parameter specifies the unsolicted frame control object
- *    for which to construct the unsolicited frames objects.
- * @uf_buffer_phys_address: This parameter specifies the physical address for
- *    the first unsolicited frame buffer.
- * @uf_buffer_virt_address: This parameter specifies the virtual address for
- *    the first unsolicited frame buffer.
- * @unused_uf_header_entries: This parameter specifies the number of unused UF
- *    headers.  This value can be non-zero when there are a non-power of 2
- *    number of unsolicited frames being supported.
- * @used_uf_header_entries: This parameter specifies the number of actually
- *    utilized UF headers.
- *
- */
-static void scic_sds_unsolicited_frame_control_construct_frames(
-	struct scic_sds_unsolicited_frame_control *uf_control,
-	dma_addr_t uf_buffer_phys_address,
-	void *uf_buffer_virt_address,
-	u32 unused_uf_header_entries,
-	u32 used_uf_header_entries)
-{
-	u32 index;
-	struct scic_sds_unsolicited_frame *uf;
-
-	/*
-	 * Program the unused buffers into the UF address table and the
-	 * controller's array of UFs.
-	 */
-	for (index = 0; index < unused_uf_header_entries; index++) {
-		uf = &uf_control->buffers.array[index];
-
-		sci_cb_make_physical_address(
-			uf_control->address_table.array[index], 0, 0
-			);
-		uf->buffer = NULL;
-		uf->header = &uf_control->headers.array[index];
-		uf->state  = UNSOLICITED_FRAME_EMPTY;
-	}
-
-	/*
-	 * Program the actual used UF buffers into the UF address table and
-	 * the controller's array of UFs.
-	 */
-	for (index = unused_uf_header_entries;
-	     index < unused_uf_header_entries + used_uf_header_entries;
-	     index++) {
-		uf = &uf_control->buffers.array[index];
-
-		uf_control->address_table.array[index] = uf_buffer_phys_address;
-
-		uf->buffer = uf_buffer_virt_address;
-		uf->header = &uf_control->headers.array[index];
-		uf->state  = UNSOLICITED_FRAME_EMPTY;
-
-		/*
-		 * Increment the address of the physical and virtual memory
-		 * pointers. Everything is aligned on 1k boundary with an
-		 * increment of 1k.
-		 */
-		uf_buffer_virt_address += SCU_UNSOLICITED_FRAME_BUFFER_SIZE;
-		uf_buffer_phys_address += SCU_UNSOLICITED_FRAME_BUFFER_SIZE;
-	}
-}
-
-int scic_sds_unsolicited_frame_control_construct(struct scic_sds_controller *scic)
-{
-	struct scic_sds_unsolicited_frame_control *uf_control = &scic->uf_control;
-	u32 unused_uf_header_entries;
-	u32 used_uf_header_entries;
-	u32 used_uf_buffer_bytes;
-	u32 unused_uf_header_bytes;
-	u32 used_uf_header_bytes;
-	dma_addr_t uf_buffer_phys_address;
-	void *uf_buffer_virt_address;
-	size_t size;
-
-	/*
-	 * The UF buffer address table size must be programmed to a power
-	 * of 2.  Find the first power of 2 that is equal to or greater then
-	 * the number of unsolicited frame buffers to be utilized.
-	 */
-	uf_control->address_table.count = SCU_MIN_UF_TABLE_ENTRIES;
-	while (uf_control->address_table.count < uf_control->buffers.count &&
-	       uf_control->address_table.count < SCU_ABSOLUTE_MAX_UNSOLICITED_FRAMES)
-		uf_control->address_table.count <<= 1;
-
-	/*
-	 * Prepare all of the memory sizes for the UF headers, UF address
-	 * table, and UF buffers themselves.
-	 */
-	used_uf_buffer_bytes     = uf_control->buffers.count
-				   * SCU_UNSOLICITED_FRAME_BUFFER_SIZE;
-	unused_uf_header_entries = uf_control->address_table.count
-				   - uf_control->buffers.count;
-	used_uf_header_entries   = uf_control->buffers.count;
-	unused_uf_header_bytes   = unused_uf_header_entries
-				   * sizeof(struct scu_unsolicited_frame_header);
-	used_uf_header_bytes     = used_uf_header_entries
-				   * sizeof(struct scu_unsolicited_frame_header);
-
-	size = used_uf_buffer_bytes + used_uf_header_bytes +
-			uf_control->address_table.count * sizeof(dma_addr_t);
-
-
-	/*
-	 * The Unsolicited Frame buffers are set at the start of the UF
-	 * memory descriptor entry. The headers and address table will be
-	 * placed after the buffers.
-	 */
-	uf_buffer_virt_address = dmam_alloc_coherent(scic_to_dev(scic), size,
-							&uf_buffer_phys_address, GFP_KERNEL);
-	if (!uf_buffer_virt_address)
-		return -ENOMEM;
-
-	/*
-	 * Program the location of the UF header table into the SCU.
-	 * Notes:
-	 * - The address must align on a 64-byte boundary. Guaranteed to be
-	 *   on 64-byte boundary already 1KB boundary for unsolicited frames.
-	 * - Program unused header entries to overlap with the last
-	 *   unsolicited frame.  The silicon will never DMA to these unused
-	 *   headers, since we program the UF address table pointers to
-	 *   NULL.
-	 */
-	uf_control->headers.physical_address =
-				uf_buffer_phys_address +
-				used_uf_buffer_bytes -
-				unused_uf_header_bytes;
-
-	uf_control->headers.array =
-				uf_buffer_virt_address +
-				used_uf_buffer_bytes -
-				unused_uf_header_bytes;
-
-	/*
-	 * Program the location of the UF address table into the SCU.
-	 * Notes:
-	 * - The address must align on a 64-bit boundary. Guaranteed to be on 64
-	 *   byte boundary already due to above programming headers being on a
-	 *   64-bit boundary and headers are on a 64-bytes in size.
-	 */
-	uf_control->address_table.physical_address =
-				uf_buffer_phys_address +
-				used_uf_buffer_bytes +
-				used_uf_header_bytes;
-
-	uf_control->address_table.array =
-				uf_buffer_virt_address +
-				used_uf_buffer_bytes +
-				used_uf_header_bytes;
-
-	uf_control->get = 0;
-
-	/*
-	 * UF buffer requirements are:
-	 * - The last entry in the UF queue is not NULL.
-	 * - There is a power of 2 number of entries (NULL or not-NULL)
-	 *   programmed into the queue.
-	 * - Aligned on a 1KB boundary. */
-
-	/*
-	 * If the user provided less then the maximum amount of memory,
-	 * then be sure that we programm the first entries in the UF
-	 * address table to NULL. */
-	scic_sds_unsolicited_frame_control_construct_frames(
-		uf_control,
-		uf_buffer_phys_address,
-		uf_buffer_virt_address,
-		unused_uf_header_entries,
-		used_uf_header_entries
-		);
-
-	return 0;
-}
-
-/**
- * This method returns the frame header for the specified frame index.
- * @uf_control:
- * @frame_index:
- * @frame_header:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_unsolicited_frame_control_get_header(
-	struct scic_sds_unsolicited_frame_control *uf_control,
-	u32 frame_index,
-	void **frame_header)
-{
-	if (frame_index < uf_control->address_table.count) {
-		/*
-		 * Skip the first word in the frame since this is a controll word used
-		 * by the hardware. */
-		*frame_header = &uf_control->buffers.array[frame_index].header->data;
-
-		return SCI_SUCCESS;
-	}
-
-	return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-}
-
-/**
- * This method returns the frame buffer for the specified frame index.
- * @uf_control:
- * @frame_index:
- * @frame_buffer:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_unsolicited_frame_control_get_buffer(
-	struct scic_sds_unsolicited_frame_control *uf_control,
-	u32 frame_index,
-	void **frame_buffer)
-{
-	if (frame_index < uf_control->address_table.count) {
-		*frame_buffer = uf_control->buffers.array[frame_index].buffer;
-
-		return SCI_SUCCESS;
-	}
-
-	return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-}
-
-/**
- * This method releases the frame once this is done the frame is available for
- *    re-use by the hardware.  The data contained in the frame header and frame
- *    buffer is no longer valid.
- * @uf_control: This parameter specifies the UF control object
- * @frame_index: This parameter specifies the frame index to attempt to release.
- *
- * This method returns an indication to the caller as to whether the
- * unsolicited frame get pointer should be updated.
- */
-bool scic_sds_unsolicited_frame_control_release_frame(
-	struct scic_sds_unsolicited_frame_control *uf_control,
-	u32 frame_index)
-{
-	u32 frame_get;
-	u32 frame_cycle;
-
-	frame_get   = uf_control->get & (uf_control->address_table.count - 1);
-	frame_cycle = uf_control->get & uf_control->address_table.count;
-
-	/*
-	 * In the event there are NULL entries in the UF table, we need to
-	 * advance the get pointer in order to find out if this frame should
-	 * be released (i.e. update the get pointer). */
-	while (((lower_32_bits(uf_control->address_table.array[frame_get])
-					== 0) &&
-		(upper_32_bits(uf_control->address_table.array[frame_get])
-					== 0)) &&
-	       (frame_get < uf_control->address_table.count))
-		frame_get++;
-
-	/*
-	 * The table has a NULL entry as it's last element.  This is
-	 * illegal. */
-	BUG_ON(frame_get >= uf_control->address_table.count);
-
-	if (frame_index < uf_control->address_table.count) {
-		uf_control->buffers.array[frame_index].state = UNSOLICITED_FRAME_RELEASED;
-
-		/*
-		 * The frame index is equal to the current get pointer so we
-		 * can now free up all of the frame entries that */
-		if (frame_get == frame_index) {
-			while (
-				uf_control->buffers.array[frame_get].state
-				== UNSOLICITED_FRAME_RELEASED
-				) {
-				uf_control->buffers.array[frame_get].state = UNSOLICITED_FRAME_EMPTY;
-
-				INCREMENT_QUEUE_GET(
-					frame_get,
-					frame_cycle,
-					uf_control->address_table.count - 1,
-					uf_control->address_table.count
-					);
-			}
-
-			uf_control->get =
-				(SCU_UFQGP_GEN_BIT(ENABLE_BIT) | frame_cycle | frame_get);
-
-			return true;
-		} else {
-			/*
-			 * Frames remain in use until we advance the get pointer
-			 * so there is nothing we can do here */
-		}
-	}
-
-	return false;
-}
-
diff --git a/drivers/scsi/isci/core/scic_sds_unsolicited_frame_control.h b/drivers/scsi/isci/core/scic_sds_unsolicited_frame_control.h
deleted file mode 100644
index 0d8ca8c..0000000
--- a/drivers/scsi/isci/core/scic_sds_unsolicited_frame_control.h
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCIC_SDS_UNSOLICITED_FRAME_CONTROL_H_
-#define _SCIC_SDS_UNSOLICITED_FRAME_CONTROL_H_
-
-#include "isci.h"
-#include "scu_unsolicited_frame.h"
-
-/**
- * enum unsolicited_frame_state -
- *
- * This enumeration represents the current unsolicited frame state.  The
- * controller object can not updtate the hardware unsolicited frame put pointer
- * unless it has already processed the priror unsolicited frames.
- */
-enum unsolicited_frame_state {
-	/**
-	 * This state is when the frame is empty and not in use.  It is
-	 * different from the released state in that the hardware could DMA
-	 * data to this frame buffer.
-	 */
-	UNSOLICITED_FRAME_EMPTY,
-
-	/**
-	 * This state is set when the frame buffer is in use by by some
-	 * object in the system.
-	 */
-	UNSOLICITED_FRAME_IN_USE,
-
-	/**
-	 * This state is set when the frame is returned to the free pool
-	 * but one or more frames prior to this one are still in use.
-	 * Once all of the frame before this one are freed it will go to
-	 * the empty state.
-	 */
-	UNSOLICITED_FRAME_RELEASED,
-
-	UNSOLICITED_FRAME_MAX_STATES
-};
-
-/**
- * struct scic_sds_unsolicited_frame -
- *
- * This is the unsolicited frame data structure it acts as the container for
- * the current frame state, frame header and frame buffer.
- */
-struct scic_sds_unsolicited_frame {
-	/**
-	 * This field contains the current frame state
-	 */
-	enum unsolicited_frame_state state;
-
-	/**
-	 * This field points to the frame header data.
-	 */
-	struct scu_unsolicited_frame_header *header;
-
-	/**
-	 * This field points to the frame buffer data.
-	 */
-	void *buffer;
-
-};
-
-/**
- * struct scic_sds_uf_header_array -
- *
- * This structure contains all of the unsolicited frame header information.
- */
-struct scic_sds_uf_header_array {
-	/**
-	 * This field is represents a virtual pointer to the start
-	 * address of the UF address table.  The table contains
-	 * 64-bit pointers as required by the hardware.
-	 */
-	struct scu_unsolicited_frame_header *array;
-
-	/**
-	 * This field specifies the physical address location for the UF
-	 * buffer array.
-	 */
-	dma_addr_t physical_address;
-
-};
-
-/**
- * struct scic_sds_uf_buffer_array -
- *
- * This structure contains all of the unsolicited frame buffer (actual payload)
- * information.
- */
-struct scic_sds_uf_buffer_array {
-	/**
-	 * This field is the minimum number of unsolicited frames supported by the
-	 * hardware and the number of unsolicited frames requested by the software.
-	 */
-	u32 count;
-
-	/**
-	 * This field is the SCIC_UNSOLICITED_FRAME data its used to manage
-	 * the data for the unsolicited frame requests.  It also represents
-	 * the virtual address location that corresponds to the
-	 * physical_address field.
-	 */
-	struct scic_sds_unsolicited_frame array[SCU_UNSOLICITED_FRAME_CONTROL_ARRAY_SIZE];
-
-	/**
-	 * This field specifies the physical address location for the UF
-	 * buffer array.
-	 */
-	dma_addr_t physical_address;
-
-};
-
-/**
- * struct scic_sds_uf_address_table_array -
- *
- * This object maintains all of the unsolicited frame address table specific
- * data.  The address table is a collection of 64-bit pointers that point to
- * 1KB buffers into which the silicon will DMA unsolicited frames.
- */
-struct scic_sds_uf_address_table_array {
-	/**
-	 * This field specifies the actual programmed size of the
-	 * unsolicited frame buffer address table.  The size of the table
-	 * can be larger than the actual number of UF buffers, but it must
-	 * be a power of 2 and the last entry in the table is not allowed
-	 * to be NULL.
-	 */
-	u32 count;
-
-	/**
-	 * This field represents a virtual pointer that refers to the
-	 * starting address of the UF address table.
-	 * 64-bit pointers are required by the hardware.
-	 */
-	dma_addr_t *array;
-
-	/**
-	 * This field specifies the physical address location for the UF
-	 * address table.
-	 */
-	dma_addr_t physical_address;
-
-};
-
-/**
- * struct scic_sds_unsolicited_frame_control -
- *
- * This object contains all of the data necessary to handle unsolicited frames.
- */
-struct scic_sds_unsolicited_frame_control {
-	/**
-	 * This field is the software copy of the unsolicited frame queue
-	 * get pointer.  The controller object writes this value to the
-	 * hardware to let the hardware put more unsolicited frame entries.
-	 */
-	u32 get;
-
-	/**
-	 * This field contains all of the unsolicited frame header
-	 * specific fields.
-	 */
-	struct scic_sds_uf_header_array headers;
-
-	/**
-	 * This field contains all of the unsolicited frame buffer
-	 * specific fields.
-	 */
-	struct scic_sds_uf_buffer_array buffers;
-
-	/**
-	 * This field contains all of the unsolicited frame address table
-	 * specific fields.
-	 */
-	struct scic_sds_uf_address_table_array address_table;
-
-};
-
-struct scic_sds_controller;
-
-int scic_sds_unsolicited_frame_control_construct(struct scic_sds_controller *scic);
-
-enum sci_status scic_sds_unsolicited_frame_control_get_header(
-	struct scic_sds_unsolicited_frame_control *uf_control,
-	u32 frame_index,
-	void **frame_header);
-
-enum sci_status scic_sds_unsolicited_frame_control_get_buffer(
-	struct scic_sds_unsolicited_frame_control *uf_control,
-	u32 frame_index,
-	void **frame_buffer);
-
-bool scic_sds_unsolicited_frame_control_release_frame(
-	struct scic_sds_unsolicited_frame_control *uf_control,
-	u32 frame_index);
-
-#endif /* _SCIC_SDS_UNSOLICITED_FRAME_CONTROL_H_ */
diff --git a/drivers/scsi/isci/core/scu_completion_codes.h b/drivers/scsi/isci/core/scu_completion_codes.h
deleted file mode 100644
index c8b329c..0000000
--- a/drivers/scsi/isci/core/scu_completion_codes.h
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCU_COMPLETION_CODES_HEADER_
-#define _SCU_COMPLETION_CODES_HEADER_
-
-/**
- * This file contains the constants and macros for the SCU hardware completion
- *    codes.
- *
- *
- */
-
-#define SCU_COMPLETION_TYPE_SHIFT      28
-#define SCU_COMPLETION_TYPE_MASK       0x70000000
-
-/**
- * SCU_COMPLETION_TYPE() -
- *
- * This macro constructs an SCU completion type
- */
-#define SCU_COMPLETION_TYPE(type) \
-	((u32)(type) << SCU_COMPLETION_TYPE_SHIFT)
-
-/**
- * SCU_COMPLETION_TYPE() -
- *
- * These macros contain the SCU completion types SCU_COMPLETION_TYPE
- */
-#define SCU_COMPLETION_TYPE_TASK       SCU_COMPLETION_TYPE(0)
-#define SCU_COMPLETION_TYPE_SDMA       SCU_COMPLETION_TYPE(1)
-#define SCU_COMPLETION_TYPE_UFI        SCU_COMPLETION_TYPE(2)
-#define SCU_COMPLETION_TYPE_EVENT      SCU_COMPLETION_TYPE(3)
-#define SCU_COMPLETION_TYPE_NOTIFY     SCU_COMPLETION_TYPE(4)
-
-/**
- *
- *
- * These constants provide the shift and mask values for the various parts of
- * an SCU completion code.
- */
-#define SCU_COMPLETION_STATUS_MASK       0x0FFC0000
-#define SCU_COMPLETION_TL_STATUS_MASK    0x0FC00000
-#define SCU_COMPLETION_TL_STATUS_SHIFT   22
-#define SCU_COMPLETION_SDMA_STATUS_MASK  0x003C0000
-#define SCU_COMPLETION_PEG_MASK          0x00010000
-#define SCU_COMPLETION_PORT_MASK         0x00007000
-#define SCU_COMPLETION_PE_MASK           SCU_COMPLETION_PORT_MASK
-#define SCU_COMPLETION_PE_SHIFT          12
-#define SCU_COMPLETION_INDEX_MASK        0x00000FFF
-
-/**
- * SCU_GET_COMPLETION_TYPE() -
- *
- * This macro returns the SCU completion type.
- */
-#define SCU_GET_COMPLETION_TYPE(completion_code) \
-	((completion_code) & SCU_COMPLETION_TYPE_MASK)
-
-/**
- * SCU_GET_COMPLETION_STATUS() -
- *
- * This macro returns the SCU completion status.
- */
-#define SCU_GET_COMPLETION_STATUS(completion_code) \
-	((completion_code) & SCU_COMPLETION_STATUS_MASK)
-
-/**
- * SCU_GET_COMPLETION_TL_STATUS() -
- *
- * This macro returns the transport layer completion status.
- */
-#define SCU_GET_COMPLETION_TL_STATUS(completion_code) \
-	((completion_code) & SCU_COMPLETION_TL_STATUS_MASK)
-
-/**
- * SCU_MAKE_COMPLETION_STATUS() -
- *
- * This macro takes a completion code and performs the shift and mask
- * operations to turn it into a completion code that can be compared to a
- * SCU_GET_COMPLETION_TL_STATUS.
- */
-#define SCU_MAKE_COMPLETION_STATUS(completion_code) \
-	((u32)(completion_code) << SCU_COMPLETION_TL_STATUS_SHIFT)
-
-/**
- * SCU_NORMALIZE_COMPLETION_STATUS() -
- *
- * This macro takes a SCU_GET_COMPLETION_TL_STATUS and normalizes it for a
- * return code.
- */
-#define SCU_NORMALIZE_COMPLETION_STATUS(completion_code) \
-	(\
-		((completion_code) & SCU_COMPLETION_TL_STATUS_MASK) \
-		>> SCU_COMPLETION_TL_STATUS_SHIFT \
-	)
-
-/**
- * SCU_GET_COMPLETION_SDMA_STATUS() -
- *
- * This macro returns the SDMA completion status.
- */
-#define SCU_GET_COMPLETION_SDMA_STATUS(completion_code)	\
-	((completion_code) & SCU_COMPLETION_SDMA_STATUS_MASK)
-
-/**
- * SCU_GET_COMPLETION_PEG() -
- *
- * This macro returns the Protocol Engine Group from the completion code.
- */
-#define SCU_GET_COMPLETION_PEG(completion_code)	\
-	((completion_code) & SCU_COMPLETION_PEG_MASK)
-
-/**
- * SCU_GET_COMPLETION_PORT() -
- *
- * This macro reuturns the logical port index from the completion code.
- */
-#define SCU_GET_COMPLETION_PORT(completion_code) \
-	((completion_code) & SCU_COMPLETION_PORT_MASK)
-
-/**
- * SCU_GET_PROTOCOL_ENGINE_INDEX() -
- *
- * This macro returns the PE index from the completion code.
- */
-#define SCU_GET_PROTOCOL_ENGINE_INDEX(completion_code) \
-	(((completion_code) & SCU_COMPLETION_PE_MASK) >> SCU_COMPLETION_PE_SHIFT)
-
-/**
- * SCU_GET_COMPLETION_INDEX() -
- *
- * This macro returns the index of the completion which is either a TCi or an
- * RNi depending on the completion type.
- */
-#define SCU_GET_COMPLETION_INDEX(completion_code) \
-	((completion_code) & SCU_COMPLETION_INDEX_MASK)
-
-#define SCU_UNSOLICITED_FRAME_MASK     0x0FFF0000
-#define SCU_UNSOLICITED_FRAME_SHIFT    16
-
-/**
- * SCU_GET_FRAME_INDEX() -
- *
- * This macro returns a normalized frame index from an unsolicited frame
- * completion.
- */
-#define SCU_GET_FRAME_INDEX(completion_code) \
-	(\
-		((completion_code) & SCU_UNSOLICITED_FRAME_MASK) \
-		>> SCU_UNSOLICITED_FRAME_SHIFT \
-	)
-
-#define SCU_UNSOLICITED_FRAME_ERROR_MASK  0x00008000
-
-/**
- * SCU_GET_FRAME_ERROR() -
- *
- * This macro returns a zero (0) value if there is no frame error otherwise it
- * returns non-zero (!0).
- */
-#define SCU_GET_FRAME_ERROR(completion_code) \
-	((completion_code) & SCU_UNSOLICITED_FRAME_ERROR_MASK)
-
-/**
- *
- *
- * These constants represent normalized completion codes which must be shifted
- * 18 bits to match it with the hardware completion code. In a 16-bit compiler,
- * immediate constants are 16-bit values (the size of an int). If we shift
- * those by 18 bits, we completely lose the value. To ensure the value is a
- * 32-bit value like we want, each immediate value must be cast to a u32.
- */
-#define SCU_TASK_DONE_GOOD                                  ((u32)0x00)
-#define SCU_TASK_DONE_CRC_ERR                               ((u32)0x14)
-#define SCU_TASK_DONE_CHECK_RESPONSE                        ((u32)0x14)
-#define SCU_TASK_DONE_GEN_RESPONSE                          ((u32)0x15)
-#define SCU_TASK_DONE_NAK_CMD_ERR                           ((u32)0x16)
-#define SCU_TASK_DONE_CMD_LL_R_ERR                          ((u32)0x16)
-#define SCU_TASK_DONE_LL_R_ERR                              ((u32)0x17)
-#define SCU_TASK_DONE_ACK_NAK_TO                            ((u32)0x17)
-#define SCU_TASK_DONE_LL_PERR                               ((u32)0x18)
-#define SCU_TASK_DONE_LL_SY_TERM                            ((u32)0x19)
-#define SCU_TASK_DONE_NAK_ERR                               ((u32)0x19)
-#define SCU_TASK_DONE_LL_LF_TERM                            ((u32)0x1A)
-#define SCU_TASK_DONE_DATA_LEN_ERR                          ((u32)0x1A)
-#define SCU_TASK_DONE_LL_CL_TERM                            ((u32)0x1B)
-#define SCU_TASK_DONE_LL_ABORT_ERR                          ((u32)0x1B)
-#define SCU_TASK_DONE_SEQ_INV_TYPE                          ((u32)0x1C)
-#define SCU_TASK_DONE_UNEXP_XR                              ((u32)0x1C)
-#define SCU_TASK_DONE_INV_FIS_TYPE                          ((u32)0x1D)
-#define SCU_TASK_DONE_XR_IU_LEN_ERR                         ((u32)0x1D)
-#define SCU_TASK_DONE_INV_FIS_LEN                           ((u32)0x1E)
-#define SCU_TASK_DONE_XR_WD_LEN                             ((u32)0x1E)
-#define SCU_TASK_DONE_SDMA_ERR                              ((u32)0x1F)
-#define SCU_TASK_DONE_OFFSET_ERR                            ((u32)0x20)
-#define SCU_TASK_DONE_MAX_PLD_ERR                           ((u32)0x21)
-#define SCU_TASK_DONE_EXCESS_DATA                           ((u32)0x22)
-#define SCU_TASK_DONE_LF_ERR                                ((u32)0x23)
-#define SCU_TASK_DONE_UNEXP_FIS                             ((u32)0x24)
-#define SCU_TASK_DONE_UNEXP_RESP                            ((u32)0x24)
-#define SCU_TASK_DONE_EARLY_RESP                            ((u32)0x25)
-#define SCU_TASK_DONE_SMP_RESP_TO_ERR                       ((u32)0x26)
-#define SCU_TASK_DONE_DMASETUP_DIRERR                       ((u32)0x27)
-#define SCU_TASK_DONE_SMP_UFI_ERR                           ((u32)0x27)
-#define SCU_TASK_DONE_XFERCNT_ERR                           ((u32)0x28)
-#define SCU_TASK_DONE_SMP_FRM_TYPE_ERR                      ((u32)0x28)
-#define SCU_TASK_DONE_SMP_LL_RX_ERR                         ((u32)0x29)
-#define SCU_TASK_DONE_RESP_LEN_ERR                          ((u32)0x2A)
-#define SCU_TASK_DONE_UNEXP_DATA                            ((u32)0x2B)
-#define SCU_TASK_DONE_OPEN_FAIL                             ((u32)0x2C)
-#define SCU_TASK_DONE_UNEXP_SDBFIS                          ((u32)0x2D)
-#define SCU_TASK_DONE_REG_ERR                               ((u32)0x2E)
-#define SCU_TASK_DONE_SDB_ERR                               ((u32)0x2F)
-#define SCU_TASK_DONE_TASK_ABORT                            ((u32)0x30)
-#define SCU_TASK_DONE_CMD_SDMA_ERR                          ((U32)0x32)
-#define SCU_TASK_DONE_CMD_LL_ABORT_ERR                      ((U32)0x33)
-#define SCU_TASK_OPEN_REJECT_WRONG_DESTINATION              ((u32)0x34)
-#define SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1             ((u32)0x35)
-#define SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2             ((u32)0x36)
-#define SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3             ((u32)0x37)
-#define SCU_TASK_OPEN_REJECT_BAD_DESTINATION                ((u32)0x38)
-#define SCU_TASK_OPEN_REJECT_ZONE_VIOLATION                 ((u32)0x39)
-#define SCU_TASK_DONE_VIIT_ENTRY_NV                         ((u32)0x3A)
-#define SCU_TASK_DONE_IIT_ENTRY_NV                          ((u32)0x3B)
-#define SCU_TASK_DONE_RNCNV_OUTBOUND                        ((u32)0x3C)
-#define SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY             ((u32)0x3D)
-#define SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED         ((u32)0x3E)
-#define SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED  ((u32)0x3F)
-
-#endif /* _SCU_COMPLETION_CODES_HEADER_ */
diff --git a/drivers/scsi/isci/core/scu_event_codes.h b/drivers/scsi/isci/core/scu_event_codes.h
deleted file mode 100644
index 36a945a..0000000
--- a/drivers/scsi/isci/core/scu_event_codes.h
+++ /dev/null
@@ -1,336 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __SCU_EVENT_CODES_HEADER__
-#define __SCU_EVENT_CODES_HEADER__
-
-/**
- * This file contains the constants and macros for the SCU event codes.
- *
- *
- */
-
-#define SCU_EVENT_TYPE_CODE_SHIFT      24
-#define SCU_EVENT_TYPE_CODE_MASK       0x0F000000
-
-#define SCU_EVENT_SPECIFIC_CODE_SHIFT  18
-#define SCU_EVENT_SPECIFIC_CODE_MASK   0x00FC0000
-
-#define SCU_EVENT_CODE_MASK \
-	(SCU_EVENT_TYPE_CODE_MASK | SCU_EVENT_SPECIFIC_CODE_MASK)
-
-/**
- * SCU_EVENT_TYPE() -
- *
- * This macro constructs an SCU event type from the type value.
- */
-#define SCU_EVENT_TYPE(type) \
-	((u32)(type) << SCU_EVENT_TYPE_CODE_SHIFT)
-
-/**
- * SCU_EVENT_SPECIFIC() -
- *
- * This macro constructs an SCU event specifier from the code value.
- */
-#define SCU_EVENT_SPECIFIC(code) \
-	((u32)(code) << SCU_EVENT_SPECIFIC_CODE_SHIFT)
-
-/**
- * SCU_EVENT_MESSAGE() -
- *
- * This macro constructs a combines an SCU event type and SCU event specifier
- * from the type and code values.
- */
-#define SCU_EVENT_MESSAGE(type, code) \
-	((type) | SCU_EVENT_SPECIFIC(code))
-
-/**
- * SCU_EVENT_TYPE() -
- *
- * SCU_EVENT_TYPES
- */
-#define SCU_EVENT_TYPE_SMU_COMMAND_ERROR  SCU_EVENT_TYPE(0x08)
-#define SCU_EVENT_TYPE_SMU_PCQ_ERROR      SCU_EVENT_TYPE(0x09)
-#define SCU_EVENT_TYPE_SMU_ERROR          SCU_EVENT_TYPE(0x00)
-#define SCU_EVENT_TYPE_TRANSPORT_ERROR    SCU_EVENT_TYPE(0x01)
-#define SCU_EVENT_TYPE_BROADCAST_CHANGE   SCU_EVENT_TYPE(0x02)
-#define SCU_EVENT_TYPE_OSSP_EVENT         SCU_EVENT_TYPE(0x03)
-#define SCU_EVENT_TYPE_FATAL_MEMORY_ERROR SCU_EVENT_TYPE(0x0F)
-#define SCU_EVENT_TYPE_RNC_SUSPEND_TX     SCU_EVENT_TYPE(0x04)
-#define SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX  SCU_EVENT_TYPE(0x05)
-#define SCU_EVENT_TYPE_RNC_OPS_MISC       SCU_EVENT_TYPE(0x06)
-#define SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT SCU_EVENT_TYPE(0x07)
-#define SCU_EVENT_TYPE_ERR_CNT_EVENT      SCU_EVENT_TYPE(0x0A)
-
-/**
- *
- *
- * SCU_EVENT_SPECIFIERS
- */
-#define SCU_EVENT_SPECIFIER_DRIVER_SUSPEND 0x20
-#define SCU_EVENT_SPECIFIER_RNC_RELEASE    0x00
-
-/**
- *
- *
- * SMU_COMMAND_EVENTS
- */
-#define SCU_EVENT_INVALID_CONTEXT_COMMAND \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_COMMAND_ERROR, 0x00)
-
-/**
- *
- *
- * SMU_PCQ_EVENTS
- */
-#define SCU_EVENT_UNCORRECTABLE_PCQ_ERROR \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_PCQ_ERROR, 0x00)
-
-/**
- *
- *
- * SMU_EVENTS
- */
-#define SCU_EVENT_UNCORRECTABLE_REGISTER_WRITE \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_ERROR, 0x02)
-#define SCU_EVENT_UNCORRECTABLE_REGISTER_READ \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_ERROR, 0x03)
-#define SCU_EVENT_PCIE_INTERFACE_ERROR \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_ERROR, 0x04)
-#define SCU_EVENT_FUNCTION_LEVEL_RESET \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_ERROR, 0x05)
-
-/**
- *
- *
- * TRANSPORT_LEVEL_ERRORS
- */
-#define SCU_EVENT_ACK_NAK_TIMEOUT_ERROR	\
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_TRANSPORT_ERROR, 0x00)
-
-/**
- *
- *
- * BROADCAST_CHANGE_EVENTS
- */
-#define SCU_EVENT_BROADCAST_CHANGE \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x01)
-#define SCU_EVENT_BROADCAST_RESERVED0 \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x02)
-#define SCU_EVENT_BROADCAST_RESERVED1 \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x03)
-#define SCU_EVENT_BROADCAST_SES	\
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x04)
-#define SCU_EVENT_BROADCAST_EXPANDER \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x05)
-#define SCU_EVENT_BROADCAST_AEN	\
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x06)
-#define SCU_EVENT_BROADCAST_RESERVED3 \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x07)
-#define SCU_EVENT_BROADCAST_RESERVED4 \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x08)
-#define SCU_EVENT_PE_SUSPENDED \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x09)
-
-/**
- *
- *
- * OSSP_EVENTS
- */
-#define SCU_EVENT_PORT_SELECTOR_DETECTED \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x10)
-#define SCU_EVENT_SENT_PORT_SELECTION \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x11)
-#define SCU_EVENT_HARD_RESET_TRANSMITTED \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x12)
-#define SCU_EVENT_HARD_RESET_RECEIVED \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x13)
-#define SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x15)
-#define SCU_EVENT_LINK_FAILURE \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x16)
-#define SCU_EVENT_SATA_SPINUP_HOLD \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x17)
-#define SCU_EVENT_SAS_15_SSC \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x18)
-#define SCU_EVENT_SAS_15 \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x19)
-#define SCU_EVENT_SAS_30_SSC \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1A)
-#define SCU_EVENT_SAS_30 \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1B)
-#define SCU_EVENT_SAS_60_SSC \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1C)
-#define SCU_EVENT_SAS_60 \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1D)
-#define SCU_EVENT_SATA_15_SSC \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1E)
-#define SCU_EVENT_SATA_15 \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1F)
-#define SCU_EVENT_SATA_30_SSC \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x20)
-#define SCU_EVENT_SATA_30 \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x21)
-#define SCU_EVENT_SATA_60_SSC \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x22)
-#define SCU_EVENT_SATA_60 \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x23)
-#define SCU_EVENT_SAS_PHY_DETECTED \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x24)
-#define SCU_EVENT_SATA_PHY_DETECTED \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x25)
-
-/**
- *
- *
- * FATAL_INTERNAL_MEMORY_ERROR_EVENTS
- */
-#define SCU_EVENT_TSC_RNSC_UNCORRECTABLE_ERROR \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_FATAL_MEMORY_ERROR,  0x00)
-#define SCU_EVENT_TC_RNC_UNCORRECTABLE_ERROR \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_FATAL_MEMORY_ERROR,  0x01)
-#define SCU_EVENT_ZPT_UNCORRECTABLE_ERROR \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_FATAL_MEMORY_ERROR,  0x02)
-
-/**
- *
- *
- * REMOTE_NODE_SUSPEND_EVENTS
- */
-#define SCU_EVENT_TL_RNC_SUSPEND_TX \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_SUSPEND_TX, 0x00)
-#define SCU_EVENT_TL_RNC_SUSPEND_TX_RX \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX, 0x00)
-#define SCU_EVENT_DRIVER_POST_RNC_SUSPEND_TX \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_SUSPEND_TX, 0x20)
-#define SCU_EVENT_DRIVER_POST_RNC_SUSPEND_TX_RX	\
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX, 0x20)
-
-/**
- *
- *
- * REMOTE_NODE_MISC_EVENTS
- */
-#define SCU_EVENT_POST_RCN_RELEASE \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_OPS_MISC, SCU_EVENT_SPECIFIER_RNC_RELEASE)
-#define SCU_EVENT_POST_IT_NEXUS_LOSS_TIMER_ENABLE \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_OPS_MISC, 0x01)
-#define SCU_EVENT_POST_IT_NEXUS_LOSS_TIMER_DISABLE \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_OPS_MISC, 0x02)
-#define SCU_EVENT_POST_RNC_COMPLETE \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_OPS_MISC, 0x03)
-#define SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_OPS_MISC, 0x04)
-
-/**
- *
- *
- * ERROR_COUNT_EVENT
- */
-#define SCU_EVENT_RX_CREDIT_BLOCKED_RECEIVED \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_ERR_CNT_EVENT, 0x00)
-#define SCU_EVENT_TX_DONE_CREDIT_TIMEOUT \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_ERR_CNT_EVENT, 0x01)
-#define SCU_EVENT_RX_DONE_CREDIT_TIMEOUT \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_ERR_CNT_EVENT, 0x02)
-
-/**
- * scu_get_event_type() -
- *
- * This macro returns the SCU event type from the event code.
- */
-#define scu_get_event_type(event_code) \
-	((event_code) & SCU_EVENT_TYPE_CODE_MASK)
-
-/**
- * scu_get_event_specifier() -
- *
- * This macro returns the SCU event specifier from the event code.
- */
-#define scu_get_event_specifier(event_code) \
-	((event_code) & SCU_EVENT_SPECIFIC_CODE_MASK)
-
-/**
- * scu_get_event_code() -
- *
- * This macro returns the combined SCU event type and SCU event specifier from
- * the event code.
- */
-#define scu_get_event_code(event_code) \
-	((event_code) & SCU_EVENT_CODE_MASK)
-
-
-/**
- *
- *
- * PTS_SCHEDULE_EVENT
- */
-#define SCU_EVENT_SMP_RESPONSE_NO_PE \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT, 0x00)
-#define SCU_EVENT_SPECIFIC_SMP_RESPONSE_NO_PE \
-	scu_get_event_specifier(SCU_EVENT_SMP_RESPONSE_NO_PE)
-
-#define SCU_EVENT_TASK_TIMEOUT \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT, 0x01)
-#define SCU_EVENT_SPECIFIC_TASK_TIMEOUT	\
-	scu_get_event_specifier(SCU_EVENT_TASK_TIMEOUT)
-
-#define SCU_EVENT_IT_NEXUS_TIMEOUT \
-	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT, 0x02)
-#define SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT \
-	scu_get_event_specifier(SCU_EVENT_IT_NEXUS_TIMEOUT)
-
-
-#endif /* __SCU_EVENT_CODES_HEADER__ */
diff --git a/drivers/scsi/isci/core/scu_registers.h b/drivers/scsi/isci/core/scu_registers.h
deleted file mode 100644
index 12f2bac..0000000
--- a/drivers/scsi/isci/core/scu_registers.h
+++ /dev/null
@@ -1,1826 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCU_REGISTERS_H_
-#define _SCU_REGISTERS_H_
-
-/**
- * This file contains the constants and structures for the SCU memory mapped
- *    registers.
- *
- *
- */
-
-#include "scu_viit_data.h"
-
-
-/* Generate a value for an SCU register */
-#define SCU_GEN_VALUE(name, value) \
-	(((value) << name ## _SHIFT) & (name ## _MASK))
-
-/*
- * Generate a bit value for an SCU register
- * Make sure that the register MASK is just a single bit */
-#define SCU_GEN_BIT(name) \
-	SCU_GEN_VALUE(name, ((u32)1))
-
-#define SCU_SET_BIT(name, reg_value) \
-	((reg_value) | SCU_GEN_BIT(name))
-
-#define SCU_CLEAR_BIT(name, reg_value) \
-	((reg_value)$ ~(SCU_GEN_BIT(name)))
-
-/*
- * *****************************************************************************
- * Unions for bitfield definitions of SCU Registers
- * SMU Post Context Port
- * ***************************************************************************** */
-#define SMU_POST_CONTEXT_PORT_CONTEXT_INDEX_SHIFT         (0)
-#define SMU_POST_CONTEXT_PORT_CONTEXT_INDEX_MASK          (0x00000FFF)
-#define SMU_POST_CONTEXT_PORT_LOGICAL_PORT_INDEX_SHIFT    (12)
-#define SMU_POST_CONTEXT_PORT_LOGICAL_PORT_INDEX_MASK     (0x0000F000)
-#define SMU_POST_CONTEXT_PORT_PROTOCOL_ENGINE_SHIFT       (16)
-#define SMU_POST_CONTEXT_PORT_PROTOCOL_ENGINE_MASK        (0x00030000)
-#define SMU_POST_CONTEXT_PORT_COMMAND_CONTEXT_SHIFT       (18)
-#define SMU_POST_CONTEXT_PORT_COMMAND_CONTEXT_MASK        (0x00FC0000)
-#define SMU_POST_CONTEXT_PORT_RESERVED_MASK               (0xFF000000)
-
-#define SMU_PCP_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SMU_POST_CONTEXT_PORT_ ## name, value)
-
-/* ***************************************************************************** */
-#define SMU_INTERRUPT_STATUS_COMPLETION_SHIFT       (31)
-#define SMU_INTERRUPT_STATUS_COMPLETION_MASK        (0x80000000)
-#define SMU_INTERRUPT_STATUS_QUEUE_SUSPEND_SHIFT    (1)
-#define SMU_INTERRUPT_STATUS_QUEUE_SUSPEND_MASK     (0x00000002)
-#define SMU_INTERRUPT_STATUS_QUEUE_ERROR_SHIFT      (0)
-#define SMU_INTERRUPT_STATUS_QUEUE_ERROR_MASK       (0x00000001)
-#define SMU_INTERRUPT_STATUS_RESERVED_MASK          (0x7FFFFFFC)
-
-#define SMU_ISR_GEN_BIT(name) \
-	SCU_GEN_BIT(SMU_INTERRUPT_STATUS_ ## name)
-
-#define SMU_ISR_QUEUE_ERROR   SMU_ISR_GEN_BIT(QUEUE_ERROR)
-#define SMU_ISR_QUEUE_SUSPEND SMU_ISR_GEN_BIT(QUEUE_SUSPEND)
-#define SMU_ISR_COMPLETION    SMU_ISR_GEN_BIT(COMPLETION)
-
-/* ***************************************************************************** */
-#define SMU_INTERRUPT_MASK_COMPLETION_SHIFT         (31)
-#define SMU_INTERRUPT_MASK_COMPLETION_MASK          (0x80000000)
-#define SMU_INTERRUPT_MASK_QUEUE_SUSPEND_SHIFT      (1)
-#define SMU_INTERRUPT_MASK_QUEUE_SUSPEND_MASK       (0x00000002)
-#define SMU_INTERRUPT_MASK_QUEUE_ERROR_SHIFT        (0)
-#define SMU_INTERRUPT_MASK_QUEUE_ERROR_MASK         (0x00000001)
-#define SMU_INTERRUPT_MASK_RESERVED_MASK            (0x7FFFFFFC)
-
-#define SMU_IMR_GEN_BIT(name) \
-	SCU_GEN_BIT(SMU_INTERRUPT_MASK_ ## name)
-
-#define SMU_IMR_QUEUE_ERROR   SMU_IMR_GEN_BIT(QUEUE_ERROR)
-#define SMU_IMR_QUEUE_SUSPEND SMU_IMR_GEN_BIT(QUEUE_SUSPEND)
-#define SMU_IMR_COMPLETION    SMU_IMR_GEN_BIT(COMPLETION)
-
-/* ***************************************************************************** */
-#define SMU_INTERRUPT_COALESCING_CONTROL_TIMER_SHIFT    (0)
-#define SMU_INTERRUPT_COALESCING_CONTROL_TIMER_MASK     (0x0000001F)
-#define SMU_INTERRUPT_COALESCING_CONTROL_NUMBER_SHIFT   (8)
-#define SMU_INTERRUPT_COALESCING_CONTROL_NUMBER_MASK    (0x0000FF00)
-#define SMU_INTERRUPT_COALESCING_CONTROL_RESERVED_MASK  (0xFFFF00E0)
-
-#define SMU_ICC_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SMU_INTERRUPT_COALESCING_CONTROL_ ## name, value)
-
-/* ***************************************************************************** */
-#define SMU_TASK_CONTEXT_RANGE_START_SHIFT      (0)
-#define SMU_TASK_CONTEXT_RANGE_START_MASK       (0x00000FFF)
-#define SMU_TASK_CONTEXT_RANGE_ENDING_SHIFT     (16)
-#define SMU_TASK_CONTEXT_RANGE_ENDING_MASK      (0x0FFF0000)
-#define SMU_TASK_CONTEXT_RANGE_ENABLE_SHIFT     (31)
-#define SMU_TASK_CONTEXT_RANGE_ENABLE_MASK      (0x80000000)
-#define SMU_TASK_CONTEXT_RANGE_RESERVED_MASK    (0x7000F000)
-
-#define SMU_TCR_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SMU_TASK_CONTEXT_RANGE_ ## name, value)
-
-#define SMU_TCR_GEN_BIT(name, value) \
-	SCU_GEN_BIT(SMU_TASK_CONTEXT_RANGE_ ## name)
-
-/* ***************************************************************************** */
-
-#define SMU_COMPLETION_QUEUE_PUT_POINTER_SHIFT          (0)
-#define SMU_COMPLETION_QUEUE_PUT_POINTER_MASK           (0x00003FFF)
-#define SMU_COMPLETION_QUEUE_PUT_CYCLE_BIT_SHIFT        (15)
-#define SMU_COMPLETION_QUEUE_PUT_CYCLE_BIT_MASK         (0x00008000)
-#define SMU_COMPLETION_QUEUE_PUT_EVENT_POINTER_SHIFT    (16)
-#define SMU_COMPLETION_QUEUE_PUT_EVENT_POINTER_MASK     (0x03FF0000)
-#define SMU_COMPLETION_QUEUE_PUT_EVENT_CYCLE_BIT_SHIFT  (26)
-#define SMU_COMPLETION_QUEUE_PUT_EVENT_CYCLE_BIT_MASK   (0x04000000)
-#define SMU_COMPLETION_QUEUE_PUT_RESERVED_MASK          (0xF8004000)
-
-#define SMU_CQPR_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SMU_COMPLETION_QUEUE_PUT_ ## name, value)
-
-#define SMU_CQPR_GEN_BIT(name) \
-	SCU_GEN_BIT(SMU_COMPLETION_QUEUE_PUT_ ## name)
-
-/* ***************************************************************************** */
-
-#define SMU_COMPLETION_QUEUE_GET_POINTER_SHIFT          (0)
-#define SMU_COMPLETION_QUEUE_GET_POINTER_MASK           (0x00003FFF)
-#define SMU_COMPLETION_QUEUE_GET_CYCLE_BIT_SHIFT        (15)
-#define SMU_COMPLETION_QUEUE_GET_CYCLE_BIT_MASK         (0x00008000)
-#define SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_SHIFT    (16)
-#define SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_MASK     (0x03FF0000)
-#define SMU_COMPLETION_QUEUE_GET_EVENT_CYCLE_BIT_SHIFT  (26)
-#define SMU_COMPLETION_QUEUE_GET_EVENT_CYCLE_BIT_MASK   (0x04000000)
-#define SMU_COMPLETION_QUEUE_GET_ENABLE_SHIFT           (30)
-#define SMU_COMPLETION_QUEUE_GET_ENABLE_MASK            (0x40000000)
-#define SMU_COMPLETION_QUEUE_GET_EVENT_ENABLE_SHIFT     (31)
-#define SMU_COMPLETION_QUEUE_GET_EVENT_ENABLE_MASK      (0x80000000)
-#define SMU_COMPLETION_QUEUE_GET_RESERVED_MASK          (0x38004000)
-
-#define SMU_CQGR_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SMU_COMPLETION_QUEUE_GET_ ## name, value)
-
-#define SMU_CQGR_GEN_BIT(name) \
-	SCU_GEN_BIT(SMU_COMPLETION_QUEUE_GET_ ## name)
-
-#define SMU_CQGR_CYCLE_BIT \
-	SMU_CQGR_GEN_BIT(CYCLE_BIT)
-
-#define SMU_CQGR_EVENT_CYCLE_BIT \
-	SMU_CQGR_GEN_BIT(EVENT_CYCLE_BIT)
-
-#define SMU_CQGR_GET_POINTER_SET(value)	\
-	SMU_CQGR_GEN_VAL(POINTER, value)
-
-
-/* ***************************************************************************** */
-#define SMU_COMPLETION_QUEUE_CONTROL_QUEUE_LIMIT_SHIFT  (0)
-#define SMU_COMPLETION_QUEUE_CONTROL_QUEUE_LIMIT_MASK   (0x00003FFF)
-#define SMU_COMPLETION_QUEUE_CONTROL_EVENT_LIMIT_SHIFT  (16)
-#define SMU_COMPLETION_QUEUE_CONTROL_EVENT_LIMIT_MASK   (0x03FF0000)
-#define SMU_COMPLETION_QUEUE_CONTROL_RESERVED_MASK      (0xFC00C000)
-
-#define SMU_CQC_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SMU_COMPLETION_QUEUE_CONTROL_ ## name, value)
-
-#define SMU_CQC_QUEUE_LIMIT_SET(value) \
-	SMU_CQC_GEN_VAL(QUEUE_LIMIT, value)
-
-#define SMU_CQC_EVENT_LIMIT_SET(value) \
-	SMU_CQC_GEN_VAL(EVENT_LIMIT, value)
-
-
-/* ***************************************************************************** */
-#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_SHIFT    (0)
-#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_MASK     (0x00000FFF)
-#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_SHIFT    (12)
-#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_MASK     (0x00007000)
-#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_SHIFT   (15)
-#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_MASK    (0x07FF8000)
-#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_PEG_SHIFT   (27)
-#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_PEG_MASK    (0x08000000)
-#define SMU_DEVICE_CONTEXT_CAPACITY_RESERVED_MASK   (0xF0000000)
-
-#define SMU_DCC_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SMU_DEVICE_CONTEXT_CAPACITY_ ## name, value)
-
-#define SMU_DCC_GET_MAX_PEG(value) \
-	(\
-		((value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_PEG_MASK) \
-		>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_SHIFT \
-	)
-
-#define SMU_DCC_GET_MAX_LP(value) \
-	(\
-		((value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_MASK) \
-		>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_SHIFT \
-	)
-
-#define SMU_DCC_GET_MAX_TC(value) \
-	(\
-		((value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_MASK) \
-		>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_SHIFT \
-	)
-
-#define SMU_DCC_GET_MAX_RNC(value) \
-	(\
-		((value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_MASK) \
-		>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_SHIFT \
-	)
-
-/* -------------------------------------------------------------------------- */
-
-#define SMU_CONTROL_STATUS_TASK_CONTEXT_RANGE_ENABLE_SHIFT      (0)
-#define SMU_CONTROL_STATUS_TASK_CONTEXT_RANGE_ENABLE_MASK       (0x00000001)
-#define SMU_CONTROL_STATUS_COMPLETION_BYTE_SWAP_ENABLE_SHIFT    (1)
-#define SMU_CONTROL_STATUS_COMPLETION_BYTE_SWAP_ENABLE_MASK     (0x00000002)
-#define SMU_CONTROL_STATUS_CONTEXT_RAM_INIT_COMPLETED_SHIFT     (16)
-#define SMU_CONTROL_STATUS_CONTEXT_RAM_INIT_COMPLETED_MASK      (0x00010000)
-#define SMU_CONTROL_STATUS_SCHEDULER_RAM_INIT_COMPLETED_SHIFT   (17)
-#define SMU_CONTROL_STATUS_SCHEDULER_RAM_INIT_COMPLETED_MASK    (0x00020000)
-#define SMU_CONTROL_STATUS_RESERVED_MASK                        (0xFFFCFFFC)
-
-#define SMU_SMUCSR_GEN_BIT(name) \
-	SCU_GEN_BIT(SMU_CONTROL_STATUS_ ## name)
-
-#define SMU_SMUCSR_SCHEDULER_RAM_INIT_COMPLETED	\
-	(SMU_SMUCSR_GEN_BIT(SCHEDULER_RAM_INIT_COMPLETED))
-
-#define SMU_SMUCSR_CONTEXT_RAM_INIT_COMPLETED	\
-	(SMU_SMUCSR_GEN_BIT(CONTEXT_RAM_INIT_COMPLETED))
-
-#define SCU_RAM_INIT_COMPLETED \
-	(\
-		SMU_SMUCSR_CONTEXT_RAM_INIT_COMPLETED \
-		| SMU_SMUCSR_SCHEDULER_RAM_INIT_COMPLETED \
-	)
-
-/* -------------------------------------------------------------------------- */
-
-#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE0_SHIFT  (0)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE0_MASK   (0x00000001)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE1_SHIFT  (1)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE1_MASK   (0x00000002)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE2_SHIFT  (2)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE2_MASK   (0x00000004)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE3_SHIFT  (3)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE3_MASK   (0x00000008)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE0_SHIFT  (8)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE0_MASK   (0x00000100)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE1_SHIFT  (9)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE1_MASK   (0x00000200)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE2_SHIFT  (10)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE2_MASK   (0x00000400)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE3_SHIFT  (11)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE3_MASK   (0x00000800)
-
-#define SMU_RESET_PROTOCOL_ENGINE(peg, pe) \
-	((1 << (pe)) << ((peg) * 8))
-
-#define SMU_RESET_PEG_PROTOCOL_ENGINES(peg) \
-	(\
-		SMU_RESET_PROTOCOL_ENGINE(peg, 0) \
-		| SMU_RESET_PROTOCOL_ENGINE(peg, 1) \
-		| SMU_RESET_PROTOCOL_ENGINE(peg, 2) \
-		| SMU_RESET_PROTOCOL_ENGINE(peg, 3) \
-	)
-
-#define SMU_RESET_ALL_PROTOCOL_ENGINES() \
-	(\
-		SMU_RESET_PEG_PROTOCOL_ENGINES(0) \
-		| SMU_RESET_PEG_PROTOCOL_ENGINES(1) \
-	)
-
-#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG0_LP0_SHIFT  (16)
-#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG0_LP0_MASK   (0x00010000)
-#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG0_LP2_SHIFT  (17)
-#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG0_LP2_MASK   (0x00020000)
-#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG1_LP0_SHIFT  (18)
-#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG1_LP0_MASK   (0x00040000)
-#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG1_LP2_SHIFT  (19)
-#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG1_LP2_MASK   (0x00080000)
-
-#define SMU_RESET_WIDE_PORT_QUEUE(peg, wide_port) \
-	((1 << ((wide_port) / 2)) << ((peg) * 2) << 16)
-
-#define SMU_SOFTRESET_CONTROL_RESET_PEG0_SHIFT      (20)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG0_MASK       (0x00100000)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG1_SHIFT      (21)
-#define SMU_SOFTRESET_CONTROL_RESET_PEG1_MASK       (0x00200000)
-#define SMU_SOFTRESET_CONTROL_RESET_SCU_SHIFT       (22)
-#define SMU_SOFTRESET_CONTROL_RESET_SCU_MASK        (0x00400000)
-
-/*
- * It seems to make sense that if you are going to reset the protocol
- * engine group that you would also reset all of the protocol engines */
-#define SMU_RESET_PROTOCOL_ENGINE_GROUP(peg) \
-	(\
-		(1 << ((peg) + 20)) \
-		| SMU_RESET_WIDE_PORT_QUEUE(peg, 0) \
-		| SMU_RESET_WIDE_PORT_QUEUE(peg, 1) \
-		| SMU_RESET_PEG_PROTOCOL_ENGINES(peg) \
-	)
-
-#define SMU_RESET_ALL_PROTOCOL_ENGINE_GROUPS() \
-	(\
-		SMU_RESET_PROTOCOL_ENGINE_GROUP(0) \
-		| SMU_RESET_PROTOCOL_ENGINE_GROUP(1) \
-	)
-
-#define SMU_RESET_SCU()  (0xFFFFFFFF)
-
-
-
-/* ***************************************************************************** */
-#define SMU_TASK_CONTEXT_ASSIGNMENT_STARTING_SHIFT              (0)
-#define SMU_TASK_CONTEXT_ASSIGNMENT_STARTING_MASK               (0x00000FFF)
-#define SMU_TASK_CONTEXT_ASSIGNMENT_ENDING_SHIFT                (16)
-#define SMU_TASK_CONTEXT_ASSIGNMENT_ENDING_MASK                 (0x0FFF0000)
-#define SMU_TASK_CONTEXT_ASSIGNMENT_RANGE_CHECK_ENABLE_SHIFT    (31)
-#define SMU_TASK_CONTEXT_ASSIGNMENT_RANGE_CHECK_ENABLE_MASK     (0x80000000)
-#define SMU_TASK_CONTEXT_ASSIGNMENT_RESERVED_MASK               (0x7000F000)
-
-#define SMU_TCA_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SMU_TASK_CONTEXT_ASSIGNMENT_ ## name, value)
-
-#define SMU_TCA_GEN_BIT(name) \
-	SCU_GEN_BIT(SMU_TASK_CONTEXT_ASSIGNMENT_ ## name)
-
-/* ***************************************************************************** */
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_CONTROL_QUEUE_SIZE_SHIFT   (0)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_CONTROL_QUEUE_SIZE_MASK    (0x00000FFF)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_CONTROL_RESERVED_MASK      (0xFFFFF000)
-
-#define SCU_UFQC_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_SDMA_UNSOLICITED_FRAME_QUEUE_CONTROL_ ## name, value)
-
-#define SCU_UFQC_QUEUE_SIZE_SET(value) \
-	SCU_UFQC_GEN_VAL(QUEUE_SIZE, value)
-
-/* ***************************************************************************** */
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_POINTER_SHIFT      (0)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_POINTER_MASK       (0x00000FFF)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_CYCLE_BIT_SHIFT    (12)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_CYCLE_BIT_MASK     (0x00001000)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_RESERVED_MASK      (0xFFFFE000)
-
-#define SCU_UFQPP_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_ ## name, value)
-
-#define SCU_UFQPP_GEN_BIT(name)	\
-	SCU_GEN_BIT(SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_ ## name)
-
-/*
- * *****************************************************************************
- * * SDMA Registers
- * ***************************************************************************** */
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_POINTER_SHIFT      (0)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_POINTER_MASK       (0x00000FFF)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_CYCLE_BIT_SHIFT    (12)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_CYCLE_BIT_MASK     (12)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_ENABLE_BIT_SHIFT   (31)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_ENABLE_BIT_MASK    (0x80000000)
-#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_RESERVED_MASK      (0x7FFFE000)
-
-#define SCU_UFQGP_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_ ## name, value)
-
-#define SCU_UFQGP_GEN_BIT(name)	\
-	SCU_GEN_BIT(SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_ ## name)
-
-#define SCU_UFQGP_CYCLE_BIT(value) \
-	SCU_UFQGP_GEN_BIT(CYCLE_BIT, value)
-
-#define SCU_UFQGP_GET_POINTER(value) \
-	SCU_UFQGP_GEN_VALUE(POINTER, value)
-
-#define SCU_UFQGP_ENABLE(value)	\
-	(SCU_UFQGP_GEN_BIT(ENABLE) | value)
-
-#define SCU_UFQGP_DISABLE(value) \
-	(~SCU_UFQGP_GEN_BIT(ENABLE) & value)
-
-#define SCU_UFQGP_VALUE(bit, value) \
-	(SCU_UFQGP_CYCLE_BIT(bit) | SCU_UFQGP_GET_POINTER(value))
-
-/* ***************************************************************************** */
-#define SCU_PDMA_CONFIGURATION_ADDRESS_MODIFIER_SHIFT                               (0)
-#define SCU_PDMA_CONFIGURATION_ADDRESS_MODIFIER_MASK                                (0x0000FFFF)
-#define SCU_PDMA_CONFIGURATION_PCI_RELAXED_ORDERING_ENABLE_SHIFT                    (16)
-#define SCU_PDMA_CONFIGURATION_PCI_RELAXED_ORDERING_ENABLE_MASK                     (0x00010000)
-#define SCU_PDMA_CONFIGURATION_PCI_NO_SNOOP_ENABLE_SHIFT                            (17)
-#define SCU_PDMA_CONFIGURATION_PCI_NO_SNOOP_ENABLE_MASK                             (0x00020000)
-#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_BYTE_SWAP_SHIFT                   (18)
-#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_BYTE_SWAP_MASK                    (0x00040000)
-#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_SGL_FETCH_SHIFT               (19)
-#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_SGL_FETCH_MASK                (0x00080000)
-#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_RX_HEADER_RAM_WRITE_SHIFT     (20)
-#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_RX_HEADER_RAM_WRITE_MASK      (0x00100000)
-#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_UF_ADDRESS_FETCH_SHIFT        (21)
-#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_UF_ADDRESS_FETCH_MASK         (0x00200000)
-#define SCU_PDMA_CONFIGURATION_ADDRESS_MODIFIER_SELECT_SHIFT                        (22)
-#define SCU_PDMA_CONFIGURATION_ADDRESS_MODIFIER_SELECT_MASK                         (0x00400000)
-#define SCU_PDMA_CONFIGURATION_RESERVED_MASK                                        (0xFF800000)
-
-#define SCU_PDMACR_GEN_VALUE(name, value) \
-	SCU_GEN_VALUE(SCU_PDMA_CONFIGURATION_ ## name, value)
-
-#define SCU_PDMACR_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_PDMA_CONFIGURATION_ ## name)
-
-#define SCU_PDMACR_BE_GEN_BIT(name) \
-	SCU_PCMACR_GEN_BIT(BIG_ENDIAN_CONTROL_ ## name)
-
-/* ***************************************************************************** */
-#define SCU_CDMA_CONFIGURATION_PCI_RELAXED_ORDERING_ENABLE_SHIFT                    (8)
-#define SCU_CDMA_CONFIGURATION_PCI_RELAXED_ORDERING_ENABLE_MASK                     (0x00000100)
-
-#define SCU_CDMACR_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_CDMA_CONFIGURATION_ ## name)
-
-/*
- * *****************************************************************************
- * * SCU Link Layer Registers
- * ***************************************************************************** */
-#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_TIMEOUT_SHIFT             (0)
-#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_TIMEOUT_MASK              (0x000000FF)
-#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_LOCK_TIME_SHIFT           (8)
-#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_LOCK_TIME_MASK            (0x0000FF00)
-#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_RATE_CHANGE_DELAY_SHIFT   (16)
-#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_RATE_CHANGE_DELAY_MASK    (0x00FF0000)
-#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_DWORD_SYNC_TIMEOUT_SHIFT  (24)
-#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_DWORD_SYNC_TIMEOUT_MASK   (0xFF000000)
-#define SCU_LINK_LAYER_SPEED_NECGOIATION_TIMER_VALUES_REQUIRED_MASK             (0x00000000)
-#define SCU_LINK_LAYER_SPEED_NECGOIATION_TIMER_VALUES_DEFAULT_MASK              (0x7D00676F)
-#define SCU_LINK_LAYER_SPEED_NECGOIATION_TIMER_VALUES_RESERVED_MASK             (0x00FF0000)
-
-#define SCU_SAS_SPDTOV_GEN_VALUE(name, value) \
-	SCU_GEN_VALUE(SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_ ## name, value)
-
-
-#define SCU_LINK_STATUS_DWORD_SYNC_AQUIRED_SHIFT            (2)
-#define SCU_LINK_STATUS_DWORD_SYNC_AQUIRED_MASK             (0x00000004)
-#define SCU_LINK_STATUS_TRANSMIT_PORT_SELECTION_DONE_SHIFT  (4)
-#define SCU_LINK_STATUS_TRANSMIT_PORT_SELECTION_DONE_MASK   (0x00000010)
-#define SCU_LINK_STATUS_RECEIVER_CREDIT_EXHAUSTED_SHIFT     (5)
-#define SCU_LINK_STATUS_RECEIVER_CREDIT_EXHAUSTED_MASK      (0x00000020)
-#define SCU_LINK_STATUS_RESERVED_MASK                       (0xFFFFFFCD)
-
-#define SCU_SAS_LLSTA_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_LINK_STATUS_ ## name)
-
-
-/* TODO: Where is the SATA_PSELTOV register? */
-
-/*
- * *****************************************************************************
- * * SCU SAS Maximum Arbitration Wait Time Timeout Register
- * ***************************************************************************** */
-#define SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_VALUE_SHIFT       (0)
-#define SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_VALUE_MASK        (0x00007FFF)
-#define SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_SCALE_SHIFT       (15)
-#define SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_SCALE_MASK        (0x00008000)
-
-#define SCU_SAS_MAWTTOV_GEN_VALUE(name, value) \
-	SCU_GEN_VALUE(SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_ ## name, value)
-
-#define SCU_SAS_MAWTTOV_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_ ## name)
-
-
-/*
- * TODO: Where is the SAS_LNKTOV regsiter?
- * TODO: Where is the SAS_PHYTOV register? */
-
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_SMP_TARGET_SHIFT            (1)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_SMP_TARGET_MASK             (0x00000002)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_STP_TARGET_SHIFT            (2)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_STP_TARGET_MASK             (0x00000004)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_SSP_TARGET_SHIFT            (3)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_SSP_TARGET_MASK             (0x00000008)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_DA_SATA_HOST_SHIFT          (8)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_DA_SATA_HOST_MASK           (0x00000100)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_SMP_INITIATOR_SHIFT         (9)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_SMP_INITIATOR_MASK          (0x00000200)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_STP_INITIATOR_SHIFT         (10)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_STP_INITIATOR_MASK          (0x00000400)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_SSP_INITIATOR_SHIFT         (11)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_SSP_INITIATOR_MASK          (0x00000800)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_REASON_CODE_SHIFT           (16)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_REASON_CODE_MASK            (0x000F0000)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_ADDRESS_FRAME_TYPE_SHIFT    (24)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_ADDRESS_FRAME_TYPE_MASK     (0x0F000000)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_DEVICE_TYPE_SHIFT           (28)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_DEVICE_TYPE_MASK            (0x70000000)
-#define SCU_SAS_TRANSMIT_IDENTIFICATION_RESERVED_MASK               (0x80F0F1F1)
-
-#define SCU_SAS_TIID_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_SAS_TRANSMIT_IDENTIFICATION_ ## name, value)
-
-#define SCU_SAS_TIID_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_SAS_TRANSMIT_IDENTIFICATION_ ## name)
-
-/* SAS Identify Frame PHY Identifier Register */
-#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_BREAK_REPLY_CAPABLE_SHIFT      (16)
-#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_BREAK_REPLY_CAPABLE_MASK       (0x00010000)
-#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_REQUESTED_INSIDE_ZPSDS_SHIFT   (17)
-#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_REQUESTED_INSIDE_ZPSDS_MASK    (0x00020000)
-#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_INSIDE_ZPSDS_PERSISTENT_SHIFT  (18)
-#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_INSIDE_ZPSDS_PERSISTENT_MASK   (0x00040000)
-#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_ID_SHIFT                       (24)
-#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_ID_MASK                        (0xFF000000)
-#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_RESERVED_MASK                  (0x00F800FF)
-
-#define SCU_SAS_TIPID_GEN_VALUE(name, value) \
-	SCU_GEN_VALUE(SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_ ## name, value)
-
-#define SCU_SAS_TIPID_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_ ## name)
-
-
-#define SCU_SAS_PHY_CONFIGURATION_TX_PARITY_CHECK_SHIFT                     (4)
-#define SCU_SAS_PHY_CONFIGURATION_TX_PARITY_CHECK_MASK                      (0x00000010)
-#define SCU_SAS_PHY_CONFIGURATION_TX_BAD_CRC_SHIFT                          (6)
-#define SCU_SAS_PHY_CONFIGURATION_TX_BAD_CRC_MASK                           (0x00000040)
-#define SCU_SAS_PHY_CONFIGURATION_DISABLE_SCRAMBLER_SHIFT                   (7)
-#define SCU_SAS_PHY_CONFIGURATION_DISABLE_SCRAMBLER_MASK                    (0x00000080)
-#define SCU_SAS_PHY_CONFIGURATION_DISABLE_DESCRAMBLER_SHIFT                 (8)
-#define SCU_SAS_PHY_CONFIGURATION_DISABLE_DESCRAMBLER_MASK                  (0x00000100)
-#define SCU_SAS_PHY_CONFIGURATION_DISABLE_CREDIT_INSERTION_SHIFT            (9)
-#define SCU_SAS_PHY_CONFIGURATION_DISABLE_CREDIT_INSERTION_MASK             (0x00000200)
-#define SCU_SAS_PHY_CONFIGURATION_SUSPEND_PROTOCOL_ENGINE_SHIFT             (11)
-#define SCU_SAS_PHY_CONFIGURATION_SUSPEND_PROTOCOL_ENGINE_MASK              (0x00000800)
-#define SCU_SAS_PHY_CONFIGURATION_SATA_SPINUP_HOLD_SHIFT                    (12)
-#define SCU_SAS_PHY_CONFIGURATION_SATA_SPINUP_HOLD_MASK                     (0x00001000)
-#define SCU_SAS_PHY_CONFIGURATION_TRANSMIT_PORT_SELECTION_SIGNAL_SHIFT      (13)
-#define SCU_SAS_PHY_CONFIGURATION_TRANSMIT_PORT_SELECTION_SIGNAL_MASK       (0x00002000)
-#define SCU_SAS_PHY_CONFIGURATION_HARD_RESET_SHIFT                          (14)
-#define SCU_SAS_PHY_CONFIGURATION_HARD_RESET_MASK                           (0x00004000)
-#define SCU_SAS_PHY_CONFIGURATION_OOB_ENABLE_SHIFT                          (15)
-#define SCU_SAS_PHY_CONFIGURATION_OOB_ENABLE_MASK                           (0x00008000)
-#define SCU_SAS_PHY_CONFIGURATION_ENABLE_FRAME_TX_INSERT_ALIGN_SHIFT        (23)
-#define SCU_SAS_PHY_CONFIGURATION_ENABLE_FRAME_TX_INSERT_ALIGN_MASK         (0x00800000)
-#define SCU_SAS_PHY_CONFIGURATION_FORWARD_IDENTIFY_FRAME_SHIFT              (27)
-#define SCU_SAS_PHY_CONFIGURATION_FORWARD_IDENTIFY_FRAME_MASK               (0x08000000)
-#define SCU_SAS_PHY_CONFIGURATION_DISABLE_BYTE_TRANSPOSE_STP_FRAME_SHIFT    (28)
-#define SCU_SAS_PHY_CONFIGURATION_DISABLE_BYTE_TRANSPOSE_STP_FRAME_MASK     (0x10000000)
-#define SCU_SAS_PHY_CONFIGURATION_OOB_RESET_SHIFT                           (29)
-#define SCU_SAS_PHY_CONFIGURATION_OOB_RESET_MASK                            (0x20000000)
-#define SCU_SAS_PHY_CONFIGURATION_THREE_IAF_ENABLE_SHIFT                    (30)
-#define SCU_SAS_PHY_CONFIGURATION_THREE_IAF_ENABLE_MASK                     (0x40000000)
-#define SCU_SAS_PHY_CONFIGURATION_OOB_ALIGN0_ENABLE_SHIFT                   (31)
-#define SCU_SAS_PHY_CONFIGURATION_OOB_ALIGN0_ENABLE_MASK                    (0x80000000)
-#define SCU_SAS_PHY_CONFIGURATION_REQUIRED_MASK                             (0x0100000F)
-#define SCU_SAS_PHY_CONFIGURATION_DEFAULT_MASK                              (0x4180100F)
-#define SCU_SAS_PHY_CONFIGURATION_RESERVED_MASK                             (0x00000000)
-
-#define SCU_SAS_PCFG_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_SAS_PHY_CONFIGURATION_ ## name)
-
-#define SCU_LINK_LAYER_ALIGN_INSERTION_FREQUENCY_GENERAL_SHIFT      (0)
-#define SCU_LINK_LAYER_ALIGN_INSERTION_FREQUENCY_GENERAL_MASK       (0x000007FF)
-#define SCU_LINK_LAYER_ALIGN_INSERTION_FREQUENCY_CONNECTED_SHIFT    (16)
-#define SCU_LINK_LAYER_ALIGN_INSERTION_FREQUENCY_CONNECTED_MASK     (0x00ff0000)
-
-#define SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_LINK_LAYER_ALIGN_INSERTION_FREQUENCY_##name, value)
-
-#define SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_COUNT_SHIFT    (0)
-#define SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_COUNT_MASK     (0x0003FFFF)
-#define SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_ENABLE_SHIFT   (31)
-#define SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_ENABLE_MASK    (0x80000000)
-#define SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_RESERVED_MASK  (0x7FFC0000)
-
-#define SCU_ENSPINUP_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_ ## name, value)
-
-#define SCU_ENSPINUP_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_ ## name)
-
-
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_TXSSCTYPE_SHIFT     (1)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_TXSSCTYPE_MASK      (0x00000002)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_RLLRATE_SHIFT       (4)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_RLLRATE_MASK        (0x000000F0)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO15GBPS_SHIFT     (8)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO15GBPS_MASK      (0x00000100)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW15GBPS_SHIFT      (9)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW15GBPS_MASK       (0x00000201)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO30GBPS_SHIFT     (10)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO30GBPS_MASK      (0x00000401)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW30GBPS_SHIFT      (11)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW30GBPS_MASK       (0x00000801)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO60GBPS_SHIFT     (12)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO60GBPS_MASK      (0x00001001)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW60GBPS_SHIFT      (13)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW60GBPS_MASK       (0x00002001)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_EVEN_PARITY_SHIFT   (31)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_EVEN_PARITY_MASK    (0x80000000)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_DEFAULT_MASK        (0x00003F01)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_REQUIRED_MASK       (0x00000001)
-#define SCU_LINK_LAYER_PHY_CAPABILITIES_RESERVED_MASK       (0x7FFFC00D)
-
-#define SCU_SAS_PHYCAP_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_LINK_LAYER_PHY_CAPABILITIES_ ## name, value)
-
-#define SCU_SAS_PHYCAP_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_LINK_LAYER_PHY_CAPABILITIES_ ## name)
-
-
-#define SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_VIRTUAL_EXPANDER_PHY_ZONE_GROUP_SHIFT  (0)
-#define SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_VIRTUAL_EXPANDER_PHY_ZONE_GROUP_MASK   (0x000000FF)
-#define SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_INSIDE_SOURCE_ZONE_GROUP_SHIFT         (31)
-#define SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_INSIDE_SOURCE_ZONE_GROUP_MASK          (0x80000000)
-#define SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_RESERVED_MASK                          (0x7FFFFF00)
-
-#define SCU_PSZGCR_GEN_VAL(name, value)	\
-	SCU_GEN_VALUE(SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_ ## name, value)
-
-#define SCU_PSZGCR_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_ ## name)
-
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE0_LOCKED_SHIFT        (1)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE0_LOCKED_MASK         (0x00000002)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE0_UPDATING_SHIFT      (2)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE0_UPDATING_MASK       (0x00000004)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE1_LOCKED_SHIFT        (4)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE1_LOCKED_MASK         (0x00000010)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE1_UPDATING_SHIFT      (5)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE1_UPDATING_MASK       (0x00000020)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE0_SHIFT (16)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE0_MASK  (0x00030000)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE0_SHIFT      (19)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE0_MASK       (0x00080000)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE1_SHIFT (20)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE1_MASK  (0x00300000)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE1_SHIFT      (23)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE1_MASK       (0x00800000)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE2_SHIFT (24)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE2_MASK  (0x03000000)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE2_SHIFT      (27)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE2_MASK       (0x08000000)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE3_SHIFT (28)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE3_MASK  (0x30000000)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE3_SHIFT      (31)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE3_MASK       (0x80000000)
-#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_RESERVED_MASK             (0x4444FFC9)
-
-#define SCU_PEG_SCUVZECR_GEN_VAL(name, val) \
-	SCU_GEN_VALUE(SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ ## name, val)
-
-#define SCU_PEG_SCUVZECR_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ ## name)
-
-
-/*
- * *****************************************************************************
- * * Port Task Scheduler registers shift and mask values
- * ***************************************************************************** */
-#define SCU_PTSG_CONTROL_IT_NEXUS_TIMEOUT_SHIFT     (0)
-#define SCU_PTSG_CONTROL_IT_NEXUS_TIMEOUT_MASK      (0x0000FFFF)
-#define SCU_PTSG_CONTROL_TASK_TIMEOUT_SHIFT         (16)
-#define SCU_PTSG_CONTROL_TASK_TIMEOUT_MASK          (0x00FF0000)
-#define SCU_PTSG_CONTROL_PTSG_ENABLE_SHIFT          (24)
-#define SCU_PTSG_CONTROL_PTSG_ENABLE_MASK           (0x01000000)
-#define SCU_PTSG_CONTROL_ETM_ENABLE_SHIFT           (25)
-#define SCU_PTSG_CONTROL_ETM_ENABLE_MASK            (0x02000000)
-#define SCU_PTSG_CONTROL_DEFAULT_MASK               (0x00020002)
-#define SCU_PTSG_CONTROL_REQUIRED_MASK              (0x00000000)
-#define SCU_PTSG_CONTROL_RESERVED_MASK              (0xFC000000)
-
-#define SCU_PTSGCR_GEN_VAL(name, val) \
-	SCU_GEN_VALUE(SCU_PTSG_CONTROL_ ## name, val)
-
-#define SCU_PTSGCR_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_PTSG_CONTROL_ ## name)
-
-
-/* ***************************************************************************** */
-#define SCU_PTSG_REAL_TIME_CLOCK_SHIFT          (0)
-#define SCU_PTSG_REAL_TIME_CLOCK_MASK           (0x0000FFFF)
-#define SCU_PTSG_REAL_TIME_CLOCK_RESERVED_MASK  (0xFFFF0000)
-
-#define SCU_RTCR_GEN_VAL(name, val) \
-	SCU_GEN_VALUE(SCU_PTSG_ ## name, val)
-
-
-#define SCU_PTSG_REAL_TIME_CLOCK_CONTROL_PRESCALER_VALUE_SHIFT  (0)
-#define SCU_PTSG_REAL_TIME_CLOCK_CONTROL_PRESCALER_VALUE_MASK   (0x00FFFFFF)
-#define SCU_PTSG_REAL_TIME_CLOCK_CONTROL_RESERVED_MASK          (0xFF000000)
-
-#define SCU_RTCCR_GEN_VAL(name, val) \
-	SCU_GEN_VALUE(SCU_PTSG_REAL_TIME_CLOCK_CONTROL_ ## name, val)
-
-
-#define SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_SUSPEND_SHIFT  (0)
-#define SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_SUSPEND_MASK   (0x00000001)
-#define SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_ENABLE_SHIFT   (1)
-#define SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_ENABLE_MASK    (0x00000002)
-#define SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_RESERVED_MASK  (0xFFFFFFFC)
-
-#define SCU_PTSxCR_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_ ## name)
-
-
-#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_NEXT_RN_VALID_SHIFT             (0)
-#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_NEXT_RN_VALID_MASK              (0x00000001)
-#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_ACTIVE_RNSC_LIST_VALID_SHIFT    (1)
-#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_ACTIVE_RNSC_LIST_VALID_MASK     (0x00000002)
-#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_PTS_SUSPENDED_SHIFT             (2)
-#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_PTS_SUSPENDED_MASK              (0x00000004)
-#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_RESERVED_MASK                   (0xFFFFFFF8)
-
-#define SCU_PTSxSR_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_ ## name)
-
-
-/*
- * *****************************************************************************
- * * SGPIO Register shift and mask values
- * ***************************************************************************** */
-#define SCU_SGPIO_CONTROL_SGPIO_ENABLE_SHIFT                    (0)
-#define SCU_SGPIO_CONTROL_SGPIO_ENABLE_MASK                     (0x00000001)
-#define SCU_SGPIO_CONTROL_SGPIO_SERIAL_CLOCK_SELECT_SHIFT       (1)
-#define SCU_SGPIO_CONTROL_SGPIO_SERIAL_CLOCK_SELECT_MASK        (0x00000002)
-#define SCU_SGPIO_CONTROL_SGPIO_SERIAL_SHIFT_WIDTH_SELECT_SHIFT (2)
-#define SCU_SGPIO_CONTROL_SGPIO_SERIAL_SHIFT_WIDTH_SELECT_MASK  (0x00000004)
-#define SCU_SGPIO_CONTROL_SGPIO_TEST_BIT_SHIFT                  (15)
-#define SCU_SGPIO_CONTROL_SGPIO_TEST_BIT_MASK                   (0x00008000)
-#define SCU_SGPIO_CONTROL_SGPIO_RESERVED_MASK                   (0xFFFF7FF8)
-
-#define SCU_SGICRx_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_SGPIO_CONTROL_SGPIO_ ## name)
-
-#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R0_SHIFT      (0)
-#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R0_MASK       (0x0000000F)
-#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R1_SHIFT      (4)
-#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R1_MASK       (0x000000F0)
-#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R2_SHIFT      (8)
-#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R2_MASK       (0x00000F00)
-#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R3_SHIFT      (12)
-#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R3_MASK       (0x0000F000)
-#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_RESERVED_MASK (0xFFFF0000)
-
-#define SCU_SGPBRx_GEN_VAL(name, value)	\
-	SCU_GEN_VALUE(SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_ ## name, value)
-
-#define SCU_SGPIO_START_DRIVE_LOWER_R0_SHIFT        (0)
-#define SCU_SGPIO_START_DRIVE_LOWER_R0_MASK         (0x00000003)
-#define SCU_SGPIO_START_DRIVE_LOWER_R1_SHIFT        (4)
-#define SCU_SGPIO_START_DRIVE_LOWER_R1_MASK         (0x00000030)
-#define SCU_SGPIO_START_DRIVE_LOWER_R2_SHIFT        (8)
-#define SCU_SGPIO_START_DRIVE_LOWER_R2_MASK         (0x00000300)
-#define SCU_SGPIO_START_DRIVE_LOWER_R3_SHIFT        (12)
-#define SCU_SGPIO_START_DRIVE_LOWER_R3_MASK         (0x00003000)
-#define SCU_SGPIO_START_DRIVE_LOWER_RESERVED_MASK   (0xFFFF8888)
-
-#define SCU_SGSDLRx_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_SGPIO_START_DRIVE_LOWER_ ## name, value)
-
-#define SCU_SGPIO_START_DRIVE_UPPER_R0_SHIFT        (0)
-#define SCU_SGPIO_START_DRIVE_UPPER_R0_MASK         (0x00000003)
-#define SCU_SGPIO_START_DRIVE_UPPER_R1_SHIFT        (4)
-#define SCU_SGPIO_START_DRIVE_UPPER_R1_MASK         (0x00000030)
-#define SCU_SGPIO_START_DRIVE_UPPER_R2_SHIFT        (8)
-#define SCU_SGPIO_START_DRIVE_UPPER_R2_MASK         (0x00000300)
-#define SCU_SGPIO_START_DRIVE_UPPER_R3_SHIFT        (12)
-#define SCU_SGPIO_START_DRIVE_UPPER_R3_MASK         (0x00003000)
-#define SCU_SGPIO_START_DRIVE_UPPER_RESERVED_MASK   (0xFFFF8888)
-
-#define SCU_SGSDURx_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_SGPIO_START_DRIVE_LOWER_ ## name, value)
-
-#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D0_SHIFT      (0)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D0_MASK       (0x00000003)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D1_SHIFT      (4)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D1_MASK       (0x00000030)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D2_SHIFT      (8)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D2_MASK       (0x00000300)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D3_SHIFT      (12)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D3_MASK       (0x00003000)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_RESERVED_MASK (0xFFFF8888)
-
-#define SCU_SGSIDLRx_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_ ## name, value)
-
-#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D0_SHIFT      (0)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D0_MASK       (0x00000003)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D1_SHIFT      (4)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D1_MASK       (0x00000030)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D2_SHIFT      (8)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D2_MASK       (0x00000300)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D3_SHIFT      (12)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D3_MASK       (0x00003000)
-#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_RESERVED_MASK (0xFFFF8888)
-
-#define SCU_SGSIDURx_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_ ## name, value)
-
-#define SCU_SGPIO_VENDOR_SPECIFIC_CODE_SHIFT            (0)
-#define SCU_SGPIO_VENDOR_SPECIFIC_CODE_MASK             (0x0000000F)
-#define SCU_SGPIO_VENDOR_SPECIFIC_CODE_RESERVED_MASK    (0xFFFFFFF0)
-
-#define SCU_SGVSCR_GEN_VAL(value) \
-	SCU_GEN_VALUE(SCU_SGPIO_VENDOR_SPECIFIC_CODE ## name, value)
-
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA0_SHIFT           (0)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA0_MASK            (0x00000003)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA0_SHIFT    (2)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA0_MASK     (0x00000004)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA0_SHIFT      (3)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA0_MASK       (0x00000008)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA1_SHIFT           (4)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA1_MASK            (0x00000030)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA1_SHIFT    (6)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA1_MASK     (0x00000040)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA1_SHIFT      (7)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA1_MASK       (0x00000080)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA2_SHIFT           (8)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA2_MASK            (0x00000300)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA2_SHIFT    (10)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA2_MASK     (0x00000400)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA2_SHIFT      (11)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA2_MASK       (0x00000800)
-#define SCU_SGPIO_OUPUT_DATA_SELECT_RESERVED_MASK               (0xFFFFF000)
-
-#define SCU_SGODSR_GEN_VAL(name, value)	\
-	SCU_GEN_VALUE(SCU_SGPIO_OUPUT_DATA_SELECT_ ## name, value)
-
-#define SCU_SGODSR_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_SGPIO_OUPUT_DATA_SELECT_ ## name)
-
-/*
- * *****************************************************************************
- * * SMU Registers
- * ***************************************************************************** */
-
-/*
- * ----------------------------------------------------------------------------
- * SMU Registers
- * These registers are based off of BAR0
- *
- * To calculate the offset for other functions use
- *       BAR0 + FN# * SystemPageSize * 2
- *
- * The TCA is only accessable from FN#0 (Physical Function) and each
- * is programmed by (BAR0 + SCU_SMU_TCA_OFFSET + (FN# * 0x04)) or
- *    TCA0 for FN#0 is at BAR0 + 0x0400
- *    TCA1 for FN#1 is at BAR0 + 0x0404
- *    etc.
- * ----------------------------------------------------------------------------
- * Accessable to all FN#s */
-#define SCU_SMU_PCP_OFFSET          0x0000
-#define SCU_SMU_AMR_OFFSET          0x0004
-#define SCU_SMU_ISR_OFFSET          0x0010
-#define SCU_SMU_IMR_OFFSET          0x0014
-#define SCU_SMU_ICC_OFFSET          0x0018
-#define SCU_SMU_HTTLBAR_OFFSET      0x0020
-#define SCU_SMU_HTTUBAR_OFFSET      0x0024
-#define SCU_SMU_TCR_OFFSET          0x0028
-#define SCU_SMU_CQLBAR_OFFSET       0x0030
-#define SCU_SMU_CQUBAR_OFFSET       0x0034
-#define SCU_SMU_CQPR_OFFSET         0x0040
-#define SCU_SMU_CQGR_OFFSET         0x0044
-#define SCU_SMU_CQC_OFFSET          0x0048
-/* Accessable to FN#0 only */
-#define SCU_SMU_RNCLBAR_OFFSET      0x0080
-#define SCU_SMU_RNCUBAR_OFFSET      0x0084
-#define SCU_SMU_DCC_OFFSET          0x0090
-#define SCU_SMU_DFC_OFFSET          0x0094
-#define SCU_SMU_SMUCSR_OFFSET       0x0098
-#define SCU_SMU_SCUSRCR_OFFSET      0x009C
-#define SCU_SMU_SMAW_OFFSET         0x00A0
-#define SCU_SMU_SMDW_OFFSET         0x00A4
-/* Accessable to FN#0 only */
-#define SCU_SMU_TCA_OFFSET          0x0400
-/* Accessable to all FN#s */
-#define SCU_SMU_MT_MLAR0_OFFSET     0x2000
-#define SCU_SMU_MT_MUAR0_OFFSET     0x2004
-#define SCU_SMU_MT_MDR0_OFFSET      0x2008
-#define SCU_SMU_MT_VCR0_OFFSET      0x200C
-#define SCU_SMU_MT_MLAR1_OFFSET     0x2010
-#define SCU_SMU_MT_MUAR1_OFFSET     0x2014
-#define SCU_SMU_MT_MDR1_OFFSET      0x2018
-#define SCU_SMU_MT_VCR1_OFFSET      0x201C
-#define SCU_SMU_MPBA_OFFSET         0x3000
-
-/**
- * struct smu_registers - These are the SMU registers
- *
- *
- */
-struct smu_registers {
-/* 0x0000 PCP */
-	u32 post_context_port;
-/* 0x0004 AMR */
-	u32 address_modifier;
-	u32 reserved_08;
-	u32 reserved_0C;
-/* 0x0010 ISR */
-	u32 interrupt_status;
-/* 0x0014 IMR */
-	u32 interrupt_mask;
-/* 0x0018 ICC */
-	u32 interrupt_coalesce_control;
-	u32 reserved_1C;
-/* 0x0020 HTTLBAR */
-	u32 host_task_table_lower;
-/* 0x0024 HTTUBAR */
-	u32 host_task_table_upper;
-/* 0x0028 TCR */
-	u32 task_context_range;
-	u32 reserved_2C;
-/* 0x0030 CQLBAR */
-	u32 completion_queue_lower;
-/* 0x0034 CQUBAR */
-	u32 completion_queue_upper;
-	u32 reserved_38;
-	u32 reserved_3C;
-/* 0x0040 CQPR */
-	u32 completion_queue_put;
-/* 0x0044 CQGR */
-	u32 completion_queue_get;
-/* 0x0048 CQC */
-	u32 completion_queue_control;
-	u32 reserved_4C;
-	u32 reserved_5x[4];
-	u32 reserved_6x[4];
-	u32 reserved_7x[4];
-/*
- * Accessable to FN#0 only
- * 0x0080 RNCLBAR */
-	u32 remote_node_context_lower;
-/* 0x0084 RNCUBAR */
-	u32 remote_node_context_upper;
-	u32 reserved_88;
-	u32 reserved_8C;
-/* 0x0090 DCC */
-	u32 device_context_capacity;
-/* 0x0094 DFC */
-	u32 device_function_capacity;
-/* 0x0098 SMUCSR */
-	u32 control_status;
-/* 0x009C SCUSRCR */
-	u32 soft_reset_control;
-/* 0x00A0 SMAW */
-	u32 mmr_address_window;
-/* 0x00A4 SMDW */
-	u32 mmr_data_window;
-	u32 reserved_A8;
-	u32 reserved_AC;
-/* A whole bunch of reserved space */
-	u32 reserved_Bx[4];
-	u32 reserved_Cx[4];
-	u32 reserved_Dx[4];
-	u32 reserved_Ex[4];
-	u32 reserved_Fx[4];
-	u32 reserved_1xx[64];
-	u32 reserved_2xx[64];
-	u32 reserved_3xx[64];
-/*
- * Accessable to FN#0 only
- * 0x0400 TCA */
-	u32 task_context_assignment[256];
-/* MSI-X registers not included */
-};
-
-/*
- * *****************************************************************************
- * SDMA Registers
- * ***************************************************************************** */
-#define SCU_SDMA_BASE               0x6000
-#define SCU_SDMA_PUFATLHAR_OFFSET   0x0000
-#define SCU_SDMA_PUFATUHAR_OFFSET   0x0004
-#define SCU_SDMA_UFLHBAR_OFFSET     0x0008
-#define SCU_SDMA_UFUHBAR_OFFSET     0x000C
-#define SCU_SDMA_UFQC_OFFSET        0x0010
-#define SCU_SDMA_UFQPP_OFFSET       0x0014
-#define SCU_SDMA_UFQGP_OFFSET       0x0018
-#define SCU_SDMA_PDMACR_OFFSET      0x001C
-#define SCU_SDMA_CDMACR_OFFSET      0x0080
-
-/**
- * struct scu_sdma_registers - These are the SCU SDMA Registers
- *
- *
- */
-struct scu_sdma_registers {
-/* 0x0000 PUFATLHAR */
-	u32 uf_address_table_lower;
-/* 0x0004 PUFATUHAR */
-	u32 uf_address_table_upper;
-/* 0x0008 UFLHBAR */
-	u32 uf_header_base_address_lower;
-/* 0x000C UFUHBAR */
-	u32 uf_header_base_address_upper;
-/* 0x0010 UFQC */
-	u32 unsolicited_frame_queue_control;
-/* 0x0014 UFQPP */
-	u32 unsolicited_frame_put_pointer;
-/* 0x0018 UFQGP */
-	u32 unsolicited_frame_get_pointer;
-/* 0x001C PDMACR */
-	u32 pdma_configuration;
-/* Reserved until offset 0x80 */
-	u32 reserved_0020_007C[0x18];
-/* 0x0080 CDMACR */
-	u32 cdma_configuration;
-/* Remainder SDMA register space */
-	u32 reserved_0084_0400[0xDF];
-
-};
-
-/*
- * *****************************************************************************
- * * SCU Link Registers
- * ***************************************************************************** */
-#define SCU_PEG0_OFFSET    0x0000
-#define SCU_PEG1_OFFSET    0x8000
-
-#define SCU_TL0_OFFSET     0x0000
-#define SCU_TL1_OFFSET     0x0400
-#define SCU_TL2_OFFSET     0x0800
-#define SCU_TL3_OFFSET     0x0C00
-
-#define SCU_LL_OFFSET      0x0080
-#define SCU_LL0_OFFSET     (SCU_TL0_OFFSET + SCU_LL_OFFSET)
-#define SCU_LL1_OFFSET     (SCU_TL1_OFFSET + SCU_LL_OFFSET)
-#define SCU_LL2_OFFSET     (SCU_TL2_OFFSET + SCU_LL_OFFSET)
-#define SCU_LL3_OFFSET     (SCU_TL3_OFFSET + SCU_LL_OFFSET)
-
-/* Transport Layer Offsets (PEG + TL) */
-#define SCU_TLCR_OFFSET         0x0000
-#define SCU_TLADTR_OFFSET       0x0004
-#define SCU_TLTTMR_OFFSET       0x0008
-#define SCU_TLEECR0_OFFSET      0x000C
-#define SCU_STPTLDARNI_OFFSET   0x0010
-
-
-#define SCU_TLCR_HASH_SAS_CHECKING_ENABLE_SHIFT    (0)
-#define SCU_TLCR_HASH_SAS_CHECKING_ENABLE_MASK     (0x00000001)
-#define SCU_TLCR_CLEAR_TCI_NCQ_MAPPING_TABLE_SHIFT (1)
-#define SCU_TLCR_CLEAR_TCI_NCQ_MAPPING_TABLE_MASK  (0x00000002)
-#define SCU_TLCR_STP_WRITE_DATA_PREFETCH_SHIFT     (3)
-#define SCU_TLCR_STP_WRITE_DATA_PREFETCH_MASK      (0x00000008)
-#define SCU_TLCR_CMD_NAK_STATUS_CODE_SHIFT         (4)
-#define SCU_TLCR_CMD_NAK_STATUS_CODE_MASK          (0x00000010)
-#define SCU_TLCR_RESERVED_MASK                     (0xFFFFFFEB)
-
-#define SCU_TLCR_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_TLCR_ ## name)
-
-/**
- * struct scu_transport_layer_registers - These are the SCU Transport Layer
- *    registers
- *
- *
- */
-struct scu_transport_layer_registers {
-	/* 0x0000 TLCR */
-	u32 control;
-	/* 0x0004 TLADTR */
-	u32 arbitration_delay_timer;
-	/* 0x0008 TLTTMR */
-	u32 timer_test_mode;
-	/* 0x000C reserved */
-	u32 reserved_0C;
-	/* 0x0010 STPTLDARNI */
-	u32 stp_rni;
-	/* 0x0014 TLFEWPORCTRL */
-	u32 tlfe_wpo_read_control;
-	/* 0x0018 TLFEWPORDATA */
-	u32 tlfe_wpo_read_data;
-	/* 0x001C RXTLSSCSR1 */
-	u32 rxtl_single_step_control_status_1;
-	/* 0x0020 RXTLSSCSR2 */
-	u32 rxtl_single_step_control_status_2;
-	/* 0x0024 AWTRDDCR */
-	u32 tlfe_awt_retry_delay_debug_control;
-	/* Remainder of TL memory space */
-	u32 reserved_0028_007F[0x16];
-
-};
-
-/* Protocol Engine Group Registers */
-#define SCU_SCUVZECRx_OFFSET        0x1080
-
-/* Link Layer Offsets (PEG + TL + LL) */
-#define SCU_SAS_SPDTOV_OFFSET       0x0000
-#define SCU_SAS_LLSTA_OFFSET        0x0004
-#define SCU_SATA_PSELTOV_OFFSET     0x0008
-#define SCU_SAS_TIMETOV_OFFSET      0x0010
-#define SCU_SAS_LOSTOT_OFFSET       0x0014
-#define SCU_SAS_LNKTOV_OFFSET       0x0018
-#define SCU_SAS_PHYTOV_OFFSET       0x001C
-#define SCU_SAS_AFERCNT_OFFSET      0x0020
-#define SCU_SAS_WERCNT_OFFSET       0x0024
-#define SCU_SAS_TIID_OFFSET         0x0028
-#define SCU_SAS_TIDNH_OFFSET        0x002C
-#define SCU_SAS_TIDNL_OFFSET        0x0030
-#define SCU_SAS_TISSAH_OFFSET       0x0034
-#define SCU_SAS_TISSAL_OFFSET       0x0038
-#define SCU_SAS_TIPID_OFFSET        0x003C
-#define SCU_SAS_TIRES2_OFFSET       0x0040
-#define SCU_SAS_ADRSTA_OFFSET       0x0044
-#define SCU_SAS_MAWTTOV_OFFSET      0x0048
-#define SCU_SAS_FRPLDFIL_OFFSET     0x0054
-#define SCU_SAS_RFCNT_OFFSET        0x0060
-#define SCU_SAS_TFCNT_OFFSET        0x0064
-#define SCU_SAS_RFDCNT_OFFSET       0x0068
-#define SCU_SAS_TFDCNT_OFFSET       0x006C
-#define SCU_SAS_LERCNT_OFFSET       0x0070
-#define SCU_SAS_RDISERRCNT_OFFSET   0x0074
-#define SCU_SAS_CRERCNT_OFFSET      0x0078
-#define SCU_STPCTL_OFFSET           0x007C
-#define SCU_SAS_PCFG_OFFSET         0x0080
-#define SCU_SAS_CLKSM_OFFSET        0x0084
-#define SCU_SAS_TXCOMWAKE_OFFSET    0x0088
-#define SCU_SAS_TXCOMINIT_OFFSET    0x008C
-#define SCU_SAS_TXCOMSAS_OFFSET     0x0090
-#define SCU_SAS_COMINIT_OFFSET      0x0094
-#define SCU_SAS_COMWAKE_OFFSET      0x0098
-#define SCU_SAS_COMSAS_OFFSET       0x009C
-#define SCU_SAS_SFERCNT_OFFSET      0x00A0
-#define SCU_SAS_CDFERCNT_OFFSET     0x00A4
-#define SCU_SAS_DNFERCNT_OFFSET     0x00A8
-#define SCU_SAS_PRSTERCNT_OFFSET    0x00AC
-#define SCU_SAS_CNTCTL_OFFSET       0x00B0
-#define SCU_SAS_SSPTOV_OFFSET       0x00B4
-#define SCU_FTCTL_OFFSET            0x00B8
-#define SCU_FRCTL_OFFSET            0x00BC
-#define SCU_FTWMRK_OFFSET           0x00C0
-#define SCU_ENSPINUP_OFFSET         0x00C4
-#define SCU_SAS_TRNTOV_OFFSET       0x00C8
-#define SCU_SAS_PHYCAP_OFFSET       0x00CC
-#define SCU_SAS_PHYCTL_OFFSET       0x00D0
-#define SCU_SAS_LLCTL_OFFSET        0x00D8
-#define SCU_AFE_XCVRCR_OFFSET       0x00DC
-#define SCU_AFE_LUTCR_OFFSET        0x00E0
-
-#define SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_SHIFT                  (0)
-#define SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_MASK                   (0x00000003)
-#define SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN1                   (0)
-#define SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN2                   (1)
-#define SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN3                   (2)
-#define SCU_SAS_LINK_LAYER_CONTROL_BROADCAST_PRIMITIVE_SHIFT            (2)
-#define SCU_SAS_LINK_LAYER_CONTROL_BROADCAST_PRIMITIVE_MASK             (0x000003FC)
-#define SCU_SAS_LINK_LAYER_CONTROL_CLOSE_NO_ACTIVE_TASK_DISABLE_SHIFT   (16)
-#define SCU_SAS_LINK_LAYER_CONTROL_CLOSE_NO_ACTIVE_TASK_DISABLE_MASK    (0x00010000)
-#define SCU_SAS_LINK_LAYER_CONTROL_CLOSE_NO_OUTBOUND_TASK_DISABLE_SHIFT (17)
-#define SCU_SAS_LINK_LAYER_CONTROL_CLOSE_NO_OUTBOUND_TASK_DISABLE_MASK  (0x00020000)
-#define SCU_SAS_LINK_LAYER_CONTROL_NO_OUTBOUND_TASK_TIMEOUT_SHIFT       (24)
-#define SCU_SAS_LINK_LAYER_CONTROL_NO_OUTBOUND_TASK_TIMEOUT_MASK        (0xFF000000)
-#define SCU_SAS_LINK_LAYER_CONTROL_RESERVED                             (0x00FCFC00)
-
-#define SCU_SAS_LLCTL_GEN_VAL(name, value) \
-	SCU_GEN_VALUE(SCU_SAS_LINK_LAYER_CONTROL_ ## name, value)
-
-#define SCU_SAS_LLCTL_GEN_BIT(name) \
-	SCU_GEN_BIT(SCU_SAS_LINK_LAYER_CONTROL_ ## name)
-
-
-/* #define SCU_FRXHECR_DCNT_OFFSET      0x00B0 */
-#define SCU_PSZGCR_OFFSET           0x00E4
-#define SCU_SAS_RECPHYCAP_OFFSET    0x00E8
-/* #define SCU_TX_LUTSEL_OFFSET         0x00B8 */
-
-#define SCU_SAS_PTxC_OFFSET         0x00D4 /* Same offset as SAS_TCTSTM */
-
-/**
- * struct scu_link_layer_registers - SCU Link Layer Registers
- *
- *
- */
-struct scu_link_layer_registers {
-/* 0x0000 SAS_SPDTOV */
-	u32 speed_negotiation_timers;
-/* 0x0004 SAS_LLSTA */
-	u32 link_layer_status;
-/* 0x0008 SATA_PSELTOV */
-	u32 port_selector_timeout;
-	u32 reserved0C;
-/* 0x0010 SAS_TIMETOV */
-	u32 timeout_unit_value;
-/* 0x0014 SAS_RCDTOV */
-	u32 rcd_timeout;
-/* 0x0018 SAS_LNKTOV */
-	u32 link_timer_timeouts;
-/* 0x001C SAS_PHYTOV */
-	u32 sas_phy_timeouts;
-/* 0x0020 SAS_AFERCNT */
-	u32 received_address_frame_error_counter;
-/* 0x0024 SAS_WERCNT */
-	u32 invalid_dword_counter;
-/* 0x0028 SAS_TIID */
-	u32 transmit_identification;
-/* 0x002C SAS_TIDNH */
-	u32 sas_device_name_high;
-/* 0x0030 SAS_TIDNL */
-	u32 sas_device_name_low;
-/* 0x0034 SAS_TISSAH */
-	u32 source_sas_address_high;
-/* 0x0038 SAS_TISSAL */
-	u32 source_sas_address_low;
-/* 0x003C SAS_TIPID */
-	u32 identify_frame_phy_id;
-/* 0x0040 SAS_TIRES2 */
-	u32 identify_frame_reserved;
-/* 0x0044 SAS_ADRSTA */
-	u32 received_address_frame;
-/* 0x0048 SAS_MAWTTOV */
-	u32 maximum_arbitration_wait_timer_timeout;
-/* 0x004C SAS_PTxC */
-	u32 transmit_primitive;
-/* 0x0050 SAS_RORES */
-	u32 error_counter_event_notification_control;
-/* 0x0054 SAS_FRPLDFIL */
-	u32 frxq_payload_fill_threshold;
-/* 0x0058 SAS_LLHANG_TOT */
-	u32 link_layer_hang_detection_timeout;
-	u32 reserved_5C;
-/* 0x0060 SAS_RFCNT */
-	u32 received_frame_count;
-/* 0x0064 SAS_TFCNT */
-	u32 transmit_frame_count;
-/* 0x0068 SAS_RFDCNT */
-	u32 received_dword_count;
-/* 0x006C SAS_TFDCNT */
-	u32 transmit_dword_count;
-/* 0x0070 SAS_LERCNT */
-	u32 loss_of_sync_error_count;
-/* 0x0074 SAS_RDISERRCNT */
-	u32 running_disparity_error_count;
-/* 0x0078 SAS_CRERCNT */
-	u32 received_frame_crc_error_count;
-/* 0x007C STPCTL */
-	u32 stp_control;
-/* 0x0080 SAS_PCFG */
-	u32 phy_configuration;
-/* 0x0084 SAS_CLKSM */
-	u32 clock_skew_management;
-/* 0x0088 SAS_TXCOMWAKE */
-	u32 transmit_comwake_signal;
-/* 0x008C SAS_TXCOMINIT */
-	u32 transmit_cominit_signal;
-/* 0x0090 SAS_TXCOMSAS */
-	u32 transmit_comsas_signal;
-/* 0x0094 SAS_COMINIT */
-	u32 cominit_control;
-/* 0x0098 SAS_COMWAKE */
-	u32 comwake_control;
-/* 0x009C SAS_COMSAS */
-	u32 comsas_control;
-/* 0x00A0 SAS_SFERCNT */
-	u32 received_short_frame_count;
-/* 0x00A4 SAS_CDFERCNT */
-	u32 received_frame_without_credit_count;
-/* 0x00A8 SAS_DNFERCNT */
-	u32 received_frame_after_done_count;
-/* 0x00AC SAS_PRSTERCNT */
-	u32 phy_reset_problem_count;
-/* 0x00B0 SAS_CNTCTL */
-	u32 counter_control;
-/* 0x00B4 SAS_SSPTOV */
-	u32 ssp_timer_timeout_values;
-/* 0x00B8 FTCTL */
-	u32 ftx_control;
-/* 0x00BC FRCTL */
-	u32 frx_control;
-/* 0x00C0 FTWMRK */
-	u32 ftx_watermark;
-/* 0x00C4 ENSPINUP */
-	u32 notify_enable_spinup_control;
-/* 0x00C8 SAS_TRNTOV */
-	u32 sas_training_sequence_timer_values;
-/* 0x00CC SAS_PHYCAP */
-	u32 phy_capabilities;
-/* 0x00D0 SAS_PHYCTL */
-	u32 phy_control;
-	u32 reserved_d4;
-/* 0x00D8 LLCTL */
-	u32 link_layer_control;
-/* 0x00DC AFE_XCVRCR */
-	u32 afe_xcvr_control;
-/* 0x00E0 AFE_LUTCR */
-	u32 afe_lookup_table_control;
-/* 0x00E4 PSZGCR */
-	u32 phy_source_zone_group_control;
-/* 0x00E8 SAS_RECPHYCAP */
-	u32 receive_phycap;
-	u32 reserved_ec;
-/* 0x00F0 SNAFERXRSTCTL */
-	u32 speed_negotiation_afe_rx_reset_control;
-/* 0x00F4 SAS_SSIPMCTL */
-	u32 power_management_control;
-/* 0x00F8 SAS_PSPREQ_PRIM */
-	u32 sas_pm_partial_request_primitive;
-/* 0x00FC SAS_PSSREQ_PRIM */
-	u32 sas_pm_slumber_request_primitive;
-/* 0x0100 SAS_PPSACK_PRIM */
-	u32 sas_pm_ack_primitive_register;
-/* 0x0104 SAS_PSNAK_PRIM */
-	u32 sas_pm_nak_primitive_register;
-/* 0x0108 SAS_SSIPMTOV */
-	u32 sas_primitive_timeout;
-	u32 reserved_10c;
-/* 0x0110 - 0x011C PLAPRDCTRLxREG */
-	u32 pla_product_control[4];
-/* 0x0120 PLAPRDSUMREG */
-	u32 pla_product_sum;
-/* 0x0124 PLACONTROLREG */
-	u32 pla_control;
-/* Remainder of memory space 896 bytes */
-	u32 reserved_0128_037f[0x96];
-
-};
-
-/*
- * 0x00D4 // Same offset as SAS_TCTSTM SAS_PTxC
- *   u32   primitive_transmit_control; */
-
-/*
- * ----------------------------------------------------------------------------
- * SGPIO
- * ---------------------------------------------------------------------------- */
-#define SCU_SGPIO_OFFSET         0x1400
-
-/* #define SCU_SGPIO_OFFSET         0x6000   // later moves to 0x1400 see HSD 652625 */
-#define SCU_SGPIO_SGICR_OFFSET   0x0000
-#define SCU_SGPIO_SGPBR_OFFSET   0x0004
-#define SCU_SGPIO_SGSDLR_OFFSET  0x0008
-#define SCU_SGPIO_SGSDUR_OFFSET  0x000C
-#define SCU_SGPIO_SGSIDLR_OFFSET 0x0010
-#define SCU_SGPIO_SGSIDUR_OFFSET 0x0014
-#define SCU_SGPIO_SGVSCR_OFFSET  0x0018
-/* Address from 0x0820 to 0x083C */
-#define SCU_SGPIO_SGODSR_OFFSET  0x0020
-
-/**
- * struct scu_sgpio_registers - SCU SGPIO Registers
- *
- *
- */
-struct scu_sgpio_registers {
-/* 0x0000 SGPIO_SGICR */
-	u32 interface_control;
-/* 0x0004 SGPIO_SGPBR */
-	u32 blink_rate;
-/* 0x0008 SGPIO_SGSDLR */
-	u32 start_drive_lower;
-/* 0x000C SGPIO_SGSDUR */
-	u32 start_drive_upper;
-/* 0x0010 SGPIO_SGSIDLR */
-	u32 serial_input_lower;
-/* 0x0014 SGPIO_SGSIDUR */
-	u32 serial_input_upper;
-/* 0x0018 SGPIO_SGVSCR */
-	u32 vendor_specific_code;
-/* 0x0020 SGPIO_SGODSR */
-	u32 ouput_data_select[8];
-/* Remainder of memory space 256 bytes */
-	u32 reserved_1444_14ff[0x31];
-
-};
-
-/*
- * *****************************************************************************
- * * Defines for VIIT entry offsets
- * * Access additional entries by SCU_VIIT_BASE + index * 0x10
- * ***************************************************************************** */
-#define     SCU_VIIT_BASE     0x1c00
-
-struct scu_viit_registers {
-	u32 registers[256];
-};
-
-/*
- * *****************************************************************************
- * * SCU PORT TASK SCHEDULER REGISTERS
- * ***************************************************************************** */
-
-#define SCU_PTSG_BASE               0x1000
-
-#define SCU_PTSG_PTSGCR_OFFSET      0x0000
-#define SCU_PTSG_RTCR_OFFSET        0x0004
-#define SCU_PTSG_RTCCR_OFFSET       0x0008
-#define SCU_PTSG_PTS0CR_OFFSET      0x0010
-#define SCU_PTSG_PTS0SR_OFFSET      0x0014
-#define SCU_PTSG_PTS1CR_OFFSET      0x0018
-#define SCU_PTSG_PTS1SR_OFFSET      0x001C
-#define SCU_PTSG_PTS2CR_OFFSET      0x0020
-#define SCU_PTSG_PTS2SR_OFFSET      0x0024
-#define SCU_PTSG_PTS3CR_OFFSET      0x0028
-#define SCU_PTSG_PTS3SR_OFFSET      0x002C
-#define SCU_PTSG_PCSPE0CR_OFFSET    0x0030
-#define SCU_PTSG_PCSPE1CR_OFFSET    0x0034
-#define SCU_PTSG_PCSPE2CR_OFFSET    0x0038
-#define SCU_PTSG_PCSPE3CR_OFFSET    0x003C
-#define SCU_PTSG_ETMTSCCR_OFFSET    0x0040
-#define SCU_PTSG_ETMRNSCCR_OFFSET   0x0044
-
-/**
- * struct scu_port_task_scheduler_registers - These are the control/stats pairs
- *    for each Port Task Scheduler.
- *
- *
- */
-struct scu_port_task_scheduler_registers {
-	u32 control;
-	u32 status;
-};
-
-/**
- * struct scu_port_task_scheduler_group_registers - These are the PORT Task
- *    Scheduler registers
- *
- *
- */
-struct scu_port_task_scheduler_group_registers {
-/* 0x0000 PTSGCR */
-	u32 control;
-/* 0x0004 RTCR */
-	u32 real_time_clock;
-/* 0x0008 RTCCR */
-	u32 real_time_clock_control;
-/* 0x000C */
-	u32 reserved_0C;
-/*
- * 0x0010 PTS0CR
- * 0x0014 PTS0SR
- * 0x0018 PTS1CR
- * 0x001C PTS1SR
- * 0x0020 PTS2CR
- * 0x0024 PTS2SR
- * 0x0028 PTS3CR
- * 0x002C PTS3SR */
-	struct scu_port_task_scheduler_registers port[4];
-/*
- * 0x0030 PCSPE0CR
- * 0x0034 PCSPE1CR
- * 0x0038 PCSPE2CR
- * 0x003C PCSPE3CR */
-	u32 protocol_engine[4];
-/* 0x0040 ETMTSCCR */
-	u32 tc_scanning_interval_control;
-/* 0x0044 ETMRNSCCR */
-	u32 rnc_scanning_interval_control;
-/* Remainder of memory space 128 bytes */
-	u32 reserved_1048_107f[0x0E];
-
-};
-
-#define SCU_PTSG_SCUVZECR_OFFSET        0x003C
-
-/*
- * *****************************************************************************
- * * AFE REGISTERS
- * ***************************************************************************** */
-#define SCU_AFE_MMR_BASE                  0xE000
-
-/*
- * AFE 0 is at offset 0x0800
- * AFE 1 is at offset 0x0900
- * AFE 2 is at offset 0x0a00
- * AFE 3 is at offset 0x0b00 */
-struct scu_afe_transceiver {
-	/* 0x0000 AFE_XCVR_CTRL0 */
-	u32 afe_xcvr_control0;
-	/* 0x0004 AFE_XCVR_CTRL1 */
-	u32 afe_xcvr_control1;
-	/* 0x0008 */
-	u32 reserved_0008;
-	/* 0x000c afe_dfx_rx_control0 */
-	u32 afe_dfx_rx_control0;
-	/* 0x0010 AFE_DFX_RX_CTRL1 */
-	u32 afe_dfx_rx_control1;
-	/* 0x0014 */
-	u32 reserved_0014;
-	/* 0x0018 AFE_DFX_RX_STS0 */
-	u32 afe_dfx_rx_status0;
-	/* 0x001c AFE_DFX_RX_STS1 */
-	u32 afe_dfx_rx_status1;
-	/* 0x0020 */
-	u32 reserved_0020;
-	/* 0x0024 AFE_TX_CTRL */
-	u32 afe_tx_control;
-	/* 0x0028 AFE_TX_AMP_CTRL0 */
-	u32 afe_tx_amp_control0;
-	/* 0x002c AFE_TX_AMP_CTRL1 */
-	u32 afe_tx_amp_control1;
-	/* 0x0030 AFE_TX_AMP_CTRL2 */
-	u32 afe_tx_amp_control2;
-	/* 0x0034 AFE_TX_AMP_CTRL3 */
-	u32 afe_tx_amp_control3;
-	/* 0x0038 afe_tx_ssc_control */
-	u32 afe_tx_ssc_control;
-	/* 0x003c */
-	u32 reserved_003c;
-	/* 0x0040 AFE_RX_SSC_CTRL0 */
-	u32 afe_rx_ssc_control0;
-	/* 0x0044 AFE_RX_SSC_CTRL1 */
-	u32 afe_rx_ssc_control1;
-	/* 0x0048 AFE_RX_SSC_CTRL2 */
-	u32 afe_rx_ssc_control2;
-	/* 0x004c AFE_RX_EQ_STS0 */
-	u32 afe_rx_eq_status0;
-	/* 0x0050 AFE_RX_EQ_STS1 */
-	u32 afe_rx_eq_status1;
-	/* 0x0054 AFE_RX_CDR_STS */
-	u32 afe_rx_cdr_status;
-	/* 0x0058 */
-	u32 reserved_0058;
-	/* 0x005c AFE_CHAN_CTRL */
-	u32 afe_channel_control;
-	/* 0x0060-0x006c */
-	u32 reserved_0060_006c[0x04];
-	/* 0x0070 AFE_XCVR_EC_STS0 */
-	u32 afe_xcvr_error_capture_status0;
-	/* 0x0074 AFE_XCVR_EC_STS1 */
-	u32 afe_xcvr_error_capture_status1;
-	/* 0x0078 AFE_XCVR_EC_STS2 */
-	u32 afe_xcvr_error_capture_status2;
-	/* 0x007c afe_xcvr_ec_status3 */
-	u32 afe_xcvr_error_capture_status3;
-	/* 0x0080 AFE_XCVR_EC_STS4 */
-	u32 afe_xcvr_error_capture_status4;
-	/* 0x0084 AFE_XCVR_EC_STS5 */
-	u32 afe_xcvr_error_capture_status5;
-	/* 0x0088-0x00fc */
-	u32 reserved_008c_00fc[0x1e];
-};
-
-/**
- * struct scu_afe_registers - AFE Regsiters
- *
- *
- */
-/* Uaoa AFE registers */
-struct scu_afe_registers {
-	/* 0Xe000 AFE_BIAS_CTRL */
-	u32 afe_bias_control;
-	u32 reserved_0004;
-	/* 0x0008 AFE_PLL_CTRL0 */
-	u32 afe_pll_control0;
-	/* 0x000c AFE_PLL_CTRL1 */
-	u32 afe_pll_control1;
-	/* 0x0010 AFE_PLL_CTRL2 */
-	u32 afe_pll_control2;
-	/* 0x0014 AFE_CB_STS */
-	u32 afe_common_block_status;
-	/* 0x0018-0x007c */
-	u32 reserved_18_7c[0x1a];
-	/* 0x0080 AFE_PMSN_MCTRL0 */
-	u32 afe_pmsn_master_control0;
-	/* 0x0084 AFE_PMSN_MCTRL1 */
-	u32 afe_pmsn_master_control1;
-	/* 0x0088 AFE_PMSN_MCTRL2 */
-	u32 afe_pmsn_master_control2;
-	/* 0x008C-0x00fc */
-	u32 reserved_008c_00fc[0x1D];
-	/* 0x0100 AFE_DFX_MST_CTRL0 */
-	u32 afe_dfx_master_control0;
-	/* 0x0104 AFE_DFX_MST_CTRL1 */
-	u32 afe_dfx_master_control1;
-	/* 0x0108 AFE_DFX_DCL_CTRL */
-	u32 afe_dfx_dcl_control;
-	/* 0x010c AFE_DFX_DMON_CTRL */
-	u32 afe_dfx_digital_monitor_control;
-	/* 0x0110 AFE_DFX_AMONP_CTRL */
-	u32 afe_dfx_analog_p_monitor_control;
-	/* 0x0114 AFE_DFX_AMONN_CTRL */
-	u32 afe_dfx_analog_n_monitor_control;
-	/* 0x0118 AFE_DFX_NTL_STS */
-	u32 afe_dfx_ntl_status;
-	/* 0x011c AFE_DFX_FIFO_STS0 */
-	u32 afe_dfx_fifo_status0;
-	/* 0x0120 AFE_DFX_FIFO_STS1 */
-	u32 afe_dfx_fifo_status1;
-	/* 0x0124 AFE_DFX_MPAT_CTRL */
-	u32 afe_dfx_master_pattern_control;
-	/* 0x0128 AFE_DFX_P0_CTRL */
-	u32 afe_dfx_p0_control;
-	/* 0x012c-0x01a8 AFE_DFX_P0_DRx */
-	u32 afe_dfx_p0_data[32];
-	/* 0x01ac */
-	u32 reserved_01ac;
-	/* 0x01b0-0x020c AFE_DFX_P0_IRx */
-	u32 afe_dfx_p0_instruction[24];
-	/* 0x0210 */
-	u32 reserved_0210;
-	/* 0x0214 AFE_DFX_P1_CTRL */
-	u32 afe_dfx_p1_control;
-	/* 0x0218-0x245 AFE_DFX_P1_DRx */
-	u32 afe_dfx_p1_data[16];
-	/* 0x0258-0x029c */
-	u32 reserved_0258_029c[0x12];
-	/* 0x02a0-0x02bc AFE_DFX_P1_IRx */
-	u32 afe_dfx_p1_instruction[8];
-	/* 0x02c0-0x2fc */
-	u32 reserved_02c0_02fc[0x10];
-	/* 0x0300 AFE_DFX_TX_PMSN_CTRL */
-	u32 afe_dfx_tx_pmsn_control;
-	/* 0x0304 AFE_DFX_RX_PMSN_CTRL */
-	u32 afe_dfx_rx_pmsn_control;
-	u32 reserved_0308;
-	/* 0x030c AFE_DFX_NOA_CTRL0 */
-	u32 afe_dfx_noa_control0;
-	/* 0x0310 AFE_DFX_NOA_CTRL1 */
-	u32 afe_dfx_noa_control1;
-	/* 0x0314 AFE_DFX_NOA_CTRL2 */
-	u32 afe_dfx_noa_control2;
-	/* 0x0318 AFE_DFX_NOA_CTRL3 */
-	u32 afe_dfx_noa_control3;
-	/* 0x031c AFE_DFX_NOA_CTRL4 */
-	u32 afe_dfx_noa_control4;
-	/* 0x0320 AFE_DFX_NOA_CTRL5 */
-	u32 afe_dfx_noa_control5;
-	/* 0x0324 AFE_DFX_NOA_CTRL6 */
-	u32 afe_dfx_noa_control6;
-	/* 0x0328 AFE_DFX_NOA_CTRL7 */
-	u32 afe_dfx_noa_control7;
-	/* 0x032c-0x07fc */
-	u32 reserved_032c_07fc[0x135];
-
-	/* 0x0800-0x0bfc */
-	struct scu_afe_transceiver scu_afe_xcvr[4];
-
-	/* 0x0c00-0x0ffc */
-	u32 reserved_0c00_0ffc[0x0100];
-};
-
-struct scu_protocol_engine_group_registers {
-	u32 table[0xE0];
-};
-
-
-struct scu_viit_iit {
-	u32 table[256];
-};
-
-/**
- * Placeholder for the ZONE Partition Table information ZONING will not be
- *    included in the 1.1 release.
- *
- *
- */
-struct scu_zone_partition_table {
-	u32 table[2048];
-};
-
-/**
- * Placeholder for the CRAM register since I am not sure if we need to
- *    read/write to these registers as yet.
- *
- *
- */
-struct scu_completion_ram {
-	u32 ram[128];
-};
-
-/**
- * Placeholder for the FBRAM registers since I am not sure if we need to
- *    read/write to these registers as yet.
- *
- *
- */
-struct scu_frame_buffer_ram {
-	u32 ram[128];
-};
-
-#define scu_scratch_ram_SIZE_IN_DWORDS  256
-
-/**
- * Placeholder for the scratch RAM registers.
- *
- *
- */
-struct scu_scratch_ram {
-	u32 ram[scu_scratch_ram_SIZE_IN_DWORDS];
-};
-
-/**
- * Placeholder since I am not yet sure what these registers are here for.
- *
- *
- */
-struct noa_protocol_engine_partition {
-	u32 reserved[64];
-};
-
-/**
- * Placeholder since I am not yet sure what these registers are here for.
- *
- *
- */
-struct noa_hub_partition {
-	u32 reserved[64];
-};
-
-/**
- * Placeholder since I am not yet sure what these registers are here for.
- *
- *
- */
-struct noa_host_interface_partition {
-	u32 reserved[64];
-};
-
-/**
- * struct transport_link_layer_pair - The SCU Hardware pairs up the TL
- *    registers with the LL registers so we must place them adjcent to make the
- *    array of registers in the PEG.
- *
- *
- */
-struct transport_link_layer_pair {
-	struct scu_transport_layer_registers tl;
-	struct scu_link_layer_registers ll;
-};
-
-/**
- * struct scu_peg_registers - SCU Protocol Engine Memory mapped register space.
- *     These registers are unique to each protocol engine group.  There can be
- *    at most two PEG for a single SCU part.
- *
- *
- */
-struct scu_peg_registers {
-	struct transport_link_layer_pair pe[4];
-	struct scu_port_task_scheduler_group_registers ptsg;
-	struct scu_protocol_engine_group_registers peg;
-	struct scu_sgpio_registers sgpio;
-	u32 reserved_01500_1BFF[0x1C0];
-	struct scu_viit_entry viit[64];
-	struct scu_zone_partition_table zpt0;
-	struct scu_zone_partition_table zpt1;
-};
-
-/**
- * struct scu_registers - SCU regsiters including both PEG registers if we turn
- *    on that compile option. All of these registers are in the memory mapped
- *    space returned from BAR1.
- *
- *
- */
-struct scu_registers {
-	/* 0x0000 - PEG 0 */
-	struct scu_peg_registers peg0;
-
-	/* 0x6000 - SDMA and Miscellaneous */
-	struct scu_sdma_registers sdma;
-	struct scu_completion_ram cram;
-	struct scu_frame_buffer_ram fbram;
-	u32 reserved_6800_69FF[0x80];
-	struct noa_protocol_engine_partition noa_pe;
-	struct noa_hub_partition noa_hub;
-	struct noa_host_interface_partition noa_if;
-	u32 reserved_6d00_7fff[0x4c0];
-
-	/* 0x8000 - PEG 1 */
-	struct scu_peg_registers peg1;
-
-	/* 0xE000 - AFE Registers */
-	struct scu_afe_registers afe;
-
-	/* 0xF000 - reserved */
-	u32 reserved_f000_211fff[0x80c00];
-
-	/* 0x212000 - scratch RAM */
-	struct scu_scratch_ram scratch_ram;
-};
-
-#endif   /* _SCU_REGISTERS_HEADER_ */
diff --git a/drivers/scsi/isci/core/scu_task_context.h b/drivers/scsi/isci/core/scu_task_context.h
deleted file mode 100644
index 7df87d9..0000000
--- a/drivers/scsi/isci/core/scu_task_context.h
+++ /dev/null
@@ -1,942 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCU_TASK_CONTEXT_H_
-#define _SCU_TASK_CONTEXT_H_
-
-/**
- * This file contains the structures and constants for the SCU hardware task
- *    context.
- *
- *
- */
-
-
-/**
- * enum scu_ssp_task_type - This enumberation defines the various SSP task
- *    types the SCU hardware will accept. The definition for the various task
- *    types the SCU hardware will accept can be found in the DS specification.
- *
- *
- */
-typedef enum {
-	SCU_TASK_TYPE_IOREAD,           /* /< IO READ direction or no direction */
-	SCU_TASK_TYPE_IOWRITE,          /* /< IO Write direction */
-	SCU_TASK_TYPE_SMP_REQUEST,      /* /< SMP Request type */
-	SCU_TASK_TYPE_RESPONSE,         /* /< Driver generated response frame (targt mode) */
-	SCU_TASK_TYPE_RAW_FRAME,        /* /< Raw frame request type */
-	SCU_TASK_TYPE_PRIMITIVE         /* /< Request for a primitive to be transmitted */
-} scu_ssp_task_type;
-
-/**
- * enum scu_sata_task_type - This enumeration defines the various SATA task
- *    types the SCU hardware will accept. The definition for the various task
- *    types the SCU hardware will accept can be found in the DS specification.
- *
- *
- */
-typedef enum {
-	SCU_TASK_TYPE_DMA_IN,           /* /< Read request */
-	SCU_TASK_TYPE_FPDMAQ_READ,      /* /< NCQ read request */
-	SCU_TASK_TYPE_PACKET_DMA_IN,    /* /< Packet read request */
-	SCU_TASK_TYPE_SATA_RAW_FRAME,   /* /< Raw frame request */
-	RESERVED_4,
-	RESERVED_5,
-	RESERVED_6,
-	RESERVED_7,
-	SCU_TASK_TYPE_DMA_OUT,          /* /< Write request */
-	SCU_TASK_TYPE_FPDMAQ_WRITE,     /* /< NCQ write Request */
-	SCU_TASK_TYPE_PACKET_DMA_OUT    /* /< Packet write request */
-} scu_sata_task_type;
-
-
-/**
- *
- *
- * SCU_CONTEXT_TYPE
- */
-#define SCU_TASK_CONTEXT_TYPE  0
-#define SCU_RNC_CONTEXT_TYPE   1
-
-/**
- *
- *
- * SCU_TASK_CONTEXT_VALIDITY
- */
-#define SCU_TASK_CONTEXT_INVALID          0
-#define SCU_TASK_CONTEXT_VALID            1
-
-/**
- *
- *
- * SCU_COMMAND_CODE
- */
-#define SCU_COMMAND_CODE_INITIATOR_NEW_TASK   0
-#define SCU_COMMAND_CODE_ACTIVE_TASK          1
-#define SCU_COMMAND_CODE_PRIMITIVE_SEQ_TASK   2
-#define SCU_COMMAND_CODE_TARGET_RAW_FRAMES    3
-
-/**
- *
- *
- * SCU_TASK_PRIORITY
- */
-/**
- *
- *
- * This priority is used when there is no priority request for this request.
- */
-#define SCU_TASK_PRIORITY_NORMAL          0
-
-/**
- *
- *
- * This priority indicates that the task should be scheduled to the head of the
- * queue.  The task will NOT be executed if the TX is suspended for the remote
- * node.
- */
-#define SCU_TASK_PRIORITY_HEAD_OF_Q       1
-
-/**
- *
- *
- * This priority indicates that the task will be executed before all
- * SCU_TASK_PRIORITY_NORMAL and SCU_TASK_PRIORITY_HEAD_OF_Q tasks. The task
- * WILL be executed if the TX is suspended for the remote node.
- */
-#define SCU_TASK_PRIORITY_HIGH            2
-
-/**
- *
- *
- * This task priority is reserved and should not be used.
- */
-#define SCU_TASK_PRIORITY_RESERVED        3
-
-#define SCU_TASK_INITIATOR_MODE           1
-#define SCU_TASK_TARGET_MODE              0
-
-#define SCU_TASK_REGULAR                  0
-#define SCU_TASK_ABORTED                  1
-
-/* direction bit defintion */
-/**
- *
- *
- * SATA_DIRECTION
- */
-#define SCU_SATA_WRITE_DATA_DIRECTION     0
-#define SCU_SATA_READ_DATA_DIRECTION      1
-
-/**
- *
- *
- * SCU_COMMAND_CONTEXT_MACROS These macros provide the mask and shift
- * operations to construct the various SCU commands
- */
-#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_SHIFT           21
-#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_MASK            0x00E00000
-#define scu_get_command_request_type(x)	\
-	((x) & SCU_CONTEXT_COMMAND_REQUEST_TYPE_MASK)
-
-#define SCU_CONTEXT_COMMAND_REQUEST_SUBTYPE_SHIFT        18
-#define SCU_CONTEXT_COMMAND_REQUEST_SUBTYPE_MASK         0x001C0000
-#define scu_get_command_request_subtype(x) \
-	((x) & SCU_CONTEXT_COMMAND_REQUEST_SUBTYPE_MASK)
-
-#define SCU_CONTEXT_COMMAND_REQUEST_FULLTYPE_MASK	 \
-	(\
-		SCU_CONTEXT_COMMAND_REQUEST_TYPE_MASK		  \
-		| SCU_CONTEXT_COMMAND_REQUEST_SUBTYPE_MASK	    \
-	)
-#define scu_get_command_request_full_type(x) \
-	((x) & SCU_CONTEXT_COMMAND_REQUEST_FULLTYPE_MASK)
-
-#define SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT  16
-#define SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_MASK   0x00010000
-#define scu_get_command_protocl_engine_group(x)	\
-	((x) & SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_MASK)
-
-#define SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT           12
-#define SCU_CONTEXT_COMMAND_LOGICAL_PORT_MASK            0x00007000
-#define scu_get_command_reqeust_logical_port(x)	\
-	((x) & SCU_CONTEXT_COMMAND_LOGICAL_PORT_MASK)
-
-
-#define MAKE_SCU_CONTEXT_COMMAND_TYPE(type) \
-	((u32)(type) << SCU_CONTEXT_COMMAND_REQUEST_TYPE_SHIFT)
-
-/**
- * MAKE_SCU_CONTEXT_COMMAND_TYPE() -
- *
- * SCU_COMMAND_TYPES These constants provide the grouping of the different SCU
- * command types.
- */
-#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC    MAKE_SCU_CONTEXT_COMMAND_TYPE(0)
-#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC    MAKE_SCU_CONTEXT_COMMAND_TYPE(1)
-#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC   MAKE_SCU_CONTEXT_COMMAND_TYPE(2)
-#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC   MAKE_SCU_CONTEXT_COMMAND_TYPE(3)
-#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC  MAKE_SCU_CONTEXT_COMMAND_TYPE(6)
-
-#define MAKE_SCU_CONTEXT_COMMAND_REQUEST(type, command)	\
-	((type) | ((command) << SCU_CONTEXT_COMMAND_REQUEST_SUBTYPE_SHIFT))
-
-/**
- *
- *
- * SCU_REQUEST_TYPES These constants are the various request types that can be
- * posted to the SCU hardware.
- */
-#define SCU_CONTEXT_COMMAND_REQUST_POST_TC \
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC, 0))
-
-#define SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT \
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC, 1))
-
-#define SCU_CONTEXT_COMMAND_REQUST_DUMP_TC \
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC, 0))
-
-#define SCU_CONTEXT_COMMAND_POST_RNC_32	\
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC, 0))
-
-#define SCU_CONTEXT_COMMAND_POST_RNC_96	\
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC, 1))
-
-#define SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE	\
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC, 2))
-
-#define SCU_CONTEXT_COMMAND_DUMP_RNC_32	\
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC, 0))
-
-#define SCU_CONTEXT_COMMAND_DUMP_RNC_96	\
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC, 1))
-
-#define SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX	\
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC, 0))
-
-#define SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX_RX \
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC, 1))
-
-#define SCU_CONTEXT_COMMAND_POST_RNC_RESUME \
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC, 2))
-
-#define SCU_CONTEXT_IT_NEXUS_LOSS_TIMER_ENABLE \
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC, 3))
-
-#define SCU_CONTEXT_IT_NEXUS_LOSS_TIMER_DISABLE	\
-	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC, 4))
-
-/**
- *
- *
- * SCU_TASK_CONTEXT_PROTOCOL SCU Task context protocol types this is uesd to
- * program the SCU Task context protocol field in word 0x00.
- */
-#define SCU_TASK_CONTEXT_PROTOCOL_SMP    0x00
-#define SCU_TASK_CONTEXT_PROTOCOL_SSP    0x01
-#define SCU_TASK_CONTEXT_PROTOCOL_STP    0x02
-#define SCU_TASK_CONTEXT_PROTOCOL_NONE   0x07
-
-/**
- * struct ssp_task_context - This is the SCU hardware definition for an SSP
- *    request.
- *
- *
- */
-struct ssp_task_context {
-	/* OFFSET 0x18 */
-	u32 reserved00:24;
-	u32 frame_type:8;
-
-	/* OFFSET 0x1C */
-	u32 reserved01;
-
-	/* OFFSET 0x20 */
-	u32 fill_bytes:2;
-	u32 reserved02:6;
-	u32 changing_data_pointer:1;
-	u32 retransmit:1;
-	u32 retry_data_frame:1;
-	u32 tlr_control:2;
-	u32 reserved03:19;
-
-	/* OFFSET 0x24 */
-	u32 uiRsvd4;
-
-	/* OFFSET 0x28 */
-	u32 target_port_transfer_tag:16;
-	u32 tag:16;
-
-	/* OFFSET 0x2C */
-	u32 data_offset;
-};
-
-/**
- * struct stp_task_context - This is the SCU hardware definition for an STP
- *    request.
- *
- *
- */
-struct stp_task_context {
-	/* OFFSET 0x18 */
-	u32 fis_type:8;
-	u32 pm_port:4;
-	u32 reserved0:3;
-	u32 control:1;
-	u32 command:8;
-	u32 features:8;
-
-	/* OFFSET 0x1C */
-	u32 reserved1;
-
-	/* OFFSET 0x20 */
-	u32 reserved2;
-
-	/* OFFSET 0x24 */
-	u32 reserved3;
-
-	/* OFFSET 0x28 */
-	u32 ncq_tag:5;
-	u32 reserved4:27;
-
-	/* OFFSET 0x2C */
-	u32 data_offset; /* TODO: What is this used for? */
-};
-
-/**
- * struct smp_task_context - This is the SCU hardware definition for an SMP
- *    request.
- *
- *
- */
-struct smp_task_context {
-	/* OFFSET 0x18 */
-	u32 response_length:8;
-	u32 function_result:8;
-	u32 function:8;
-	u32 frame_type:8;
-
-	/* OFFSET 0x1C */
-	u32 smp_response_ufi:12;
-	u32 reserved1:20;
-
-	/* OFFSET 0x20 */
-	u32 reserved2;
-
-	/* OFFSET 0x24 */
-	u32 reserved3;
-
-	/* OFFSET 0x28 */
-	u32 reserved4;
-
-	/* OFFSET 0x2C */
-	u32 reserved5;
-};
-
-/**
- * struct primitive_task_context - This is the SCU hardware definition used
- *    when the driver wants to send a primitive on the link.
- *
- *
- */
-struct primitive_task_context {
-	/* OFFSET 0x18 */
-	/**
-	 * This field is the control word and it must be 0.
-	 */
-	u32 control; /* /< must be set to 0 */
-
-	/* OFFSET 0x1C */
-	/**
-	 * This field specifies the primitive that is to be transmitted.
-	 */
-	u32 sequence;
-
-	/* OFFSET 0x20 */
-	u32 reserved0;
-
-	/* OFFSET 0x24 */
-	u32 reserved1;
-
-	/* OFFSET 0x28 */
-	u32 reserved2;
-
-	/* OFFSET 0x2C */
-	u32 reserved3;
-};
-
-/**
- * The union of the protocols that can be selected in the SCU task context
- *    field.
- *
- * protocol_context
- */
-union protocol_context {
-	struct ssp_task_context ssp;
-	struct stp_task_context stp;
-	struct smp_task_context smp;
-	struct primitive_task_context primitive;
-	u32 words[6];
-};
-
-/**
- * struct scu_sgl_element - This structure represents a single SCU defined SGL
- *    element. SCU SGLs contain a 64 bit address with the maximum data transfer
- *    being 24 bits in size.  The SGL can not cross a 4GB boundary.
- *
- * struct scu_sgl_element
- */
-struct scu_sgl_element {
-	/**
-	 * This field is the upper 32 bits of the 64 bit physical address.
-	 */
-	u32 address_upper;
-
-	/**
-	 * This field is the lower 32 bits of the 64 bit physical address.
-	 */
-	u32 address_lower;
-
-	/**
-	 * This field is the number of bytes to transfer.
-	 */
-	u32 length:24;
-
-	/**
-	 * This field is the address modifier to be used when a virtual function is
-	 * requesting a data transfer.
-	 */
-	u32 address_modifier:8;
-
-};
-
-#define SCU_SGL_ELEMENT_PAIR_A   0
-#define SCU_SGL_ELEMENT_PAIR_B   1
-
-/**
- * struct scu_sgl_element_pair - This structure is the SCU hardware definition
- *    of a pair of SGL elements. The SCU hardware always works on SGL pairs.
- *    They are refered to in the DS specification as SGL A and SGL B.  Each SGL
- *    pair is followed by the address of the next pair.
- *
- *
- */
-struct scu_sgl_element_pair {
-	/* OFFSET 0x60-0x68 */
-	/**
-	 * This field is the SGL element A of the SGL pair.
-	 */
-	struct scu_sgl_element A;
-
-	/* OFFSET 0x6C-0x74 */
-	/**
-	 * This field is the SGL element B of the SGL pair.
-	 */
-	struct scu_sgl_element B;
-
-	/* OFFSET 0x78-0x7C */
-	/**
-	 * This field is the upper 32 bits of the 64 bit address to the next SGL
-	 * element pair.
-	 */
-	u32 next_pair_upper;
-
-	/**
-	 * This field is the lower 32 bits of the 64 bit address to the next SGL
-	 * element pair.
-	 */
-	u32 next_pair_lower;
-
-};
-
-/**
- * struct transport_snapshot - This structure is the SCU hardware scratch area
- *    for the task context. This is set to 0 by the driver but can be read by
- *    issuing a dump TC request to the SCU.
- *
- *
- */
-struct transport_snapshot {
-	/* OFFSET 0x48 */
-	u32 xfer_rdy_write_data_length;
-
-	/* OFFSET 0x4C */
-	u32 data_offset;
-
-	/* OFFSET 0x50 */
-	u32 data_transfer_size:24;
-	u32 reserved_50_0:8;
-
-	/* OFFSET 0x54 */
-	u32 next_initiator_write_data_offset;
-
-	/* OFFSET 0x58 */
-	u32 next_initiator_write_data_xfer_size:24;
-	u32 reserved_58_0:8;
-};
-
-/**
- * struct scu_task_context - This structure defines the contents of the SCU
- *    silicon task context. It lays out all of the fields according to the
- *    expected order and location for the Storage Controller unit.
- *
- *
- */
-struct scu_task_context {
-	/* OFFSET 0x00 ------ */
-	/**
-	 * This field must be encoded to one of the valid SCU task priority values
-	 *    - SCU_TASK_PRIORITY_NORMAL
-	 *    - SCU_TASK_PRIORITY_HEAD_OF_Q
-	 *    - SCU_TASK_PRIORITY_HIGH
-	 */
-	u32 priority:2;
-
-	/**
-	 * This field must be set to true if this is an initiator generated request.
-	 * Until target mode is supported all task requests are initiator requests.
-	 */
-	u32 initiator_request:1;
-
-	/**
-	 * This field must be set to one of the valid connection rates valid values
-	 * are 0x8, 0x9, and 0xA.
-	 */
-	u32 connection_rate:4;
-
-	/**
-	 * This field muse be programed when generating an SMP response since the SMP
-	 * connection remains open until the SMP response is generated.
-	 */
-	u32 protocol_engine_index:3;
-
-	/**
-	 * This field must contain the logical port for the task request.
-	 */
-	u32 logical_port_index:3;
-
-	/**
-	 * This field must be set to one of the SCU_TASK_CONTEXT_PROTOCOL values
-	 *    - SCU_TASK_CONTEXT_PROTOCOL_SMP
-	 *    - SCU_TASK_CONTEXT_PROTOCOL_SSP
-	 *    - SCU_TASK_CONTEXT_PROTOCOL_STP
-	 *    - SCU_TASK_CONTEXT_PROTOCOL_NONE
-	 */
-	u32 protocol_type:3;
-
-	/**
-	 * This filed must be set to the TCi allocated for this task
-	 */
-	u32 task_index:12;
-
-	/**
-	 * This field is reserved and must be set to 0x00
-	 */
-	u32 reserved_00_0:1;
-
-	/**
-	 * For a normal task request this must be set to 0.  If this is an abort of
-	 * this task request it must be set to 1.
-	 */
-	u32 abort:1;
-
-	/**
-	 * This field must be set to true for the SCU hardware to process the task.
-	 */
-	u32 valid:1;
-
-	/**
-	 * This field must be set to SCU_TASK_CONTEXT_TYPE
-	 */
-	u32 context_type:1;
-
-	/* OFFSET 0x04 */
-	/**
-	 * This field contains the RNi that is the target of this request.
-	 */
-	u32 remote_node_index:12;
-
-	/**
-	 * This field is programmed if this is a mirrored request, which we are not
-	 * using, in which case it is the RNi for the mirrored target.
-	 */
-	u32 mirrored_node_index:12;
-
-	/**
-	 * This field is programmed with the direction of the SATA reqeust
-	 *    - SCU_SATA_WRITE_DATA_DIRECTION
-	 *    - SCU_SATA_READ_DATA_DIRECTION
-	 */
-	u32 sata_direction:1;
-
-	/**
-	 * This field is programmsed with one of the following SCU_COMMAND_CODE
-	 *    - SCU_COMMAND_CODE_INITIATOR_NEW_TASK
-	 *    - SCU_COMMAND_CODE_ACTIVE_TASK
-	 *    - SCU_COMMAND_CODE_PRIMITIVE_SEQ_TASK
-	 *    - SCU_COMMAND_CODE_TARGET_RAW_FRAMES
-	 */
-	u32 command_code:2;
-
-	/**
-	 * This field is set to true if the remote node should be suspended.
-	 * This bit is only valid for SSP & SMP target devices.
-	 */
-	u32 suspend_node:1;
-
-	/**
-	 * This field is programmed with one of the following command type codes
-	 *
-	 * For SAS requests use the scu_ssp_task_type
-	 *    - SCU_TASK_TYPE_IOREAD
-	 *    - SCU_TASK_TYPE_IOWRITE
-	 *    - SCU_TASK_TYPE_SMP_REQUEST
-	 *    - SCU_TASK_TYPE_RESPONSE
-	 *    - SCU_TASK_TYPE_RAW_FRAME
-	 *    - SCU_TASK_TYPE_PRIMITIVE
-	 *
-	 * For SATA requests use the scu_sata_task_type
-	 *    - SCU_TASK_TYPE_DMA_IN
-	 *    - SCU_TASK_TYPE_FPDMAQ_READ
-	 *    - SCU_TASK_TYPE_PACKET_DMA_IN
-	 *    - SCU_TASK_TYPE_SATA_RAW_FRAME
-	 *    - SCU_TASK_TYPE_DMA_OUT
-	 *    - SCU_TASK_TYPE_FPDMAQ_WRITE
-	 *    - SCU_TASK_TYPE_PACKET_DMA_OUT
-	 */
-	u32 task_type:4;
-
-	/* OFFSET 0x08 */
-	/**
-	 * This field is reserved and the must be set to 0x00
-	 */
-	u32 link_layer_control:8; /* presently all reserved */
-
-	/**
-	 * This field is set to true when TLR is to be enabled
-	 */
-	u32 ssp_tlr_enable:1;
-
-	/**
-	 * This is field specifies if the SCU DMAs a response frame to host
-	 * memory for good response frames when operating in target mode.
-	 */
-	u32 dma_ssp_target_good_response:1;
-
-	/**
-	 * This field indicates if the SCU should DMA the response frame to
-	 * host memory.
-	 */
-	u32 do_not_dma_ssp_good_response:1;
-
-	/**
-	 * This field is set to true when strict ordering is to be enabled
-	 */
-	u32 strict_ordering:1;
-
-	/**
-	 * This field indicates the type of endianess to be utilized for the
-	 * frame.  command, task, and response frames utilized control_frame
-	 * set to 1.
-	 */
-	u32 control_frame:1;
-
-	/**
-	 * This field is reserved and the driver should set to 0x00
-	 */
-	u32 tl_control_reserved:3;
-
-	/**
-	 * This field is set to true when the SCU hardware task timeout control is to
-	 * be enabled
-	 */
-	u32 timeout_enable:1;
-
-	/**
-	 * This field is reserved and the driver should set it to 0x00
-	 */
-	u32 pts_control_reserved:7;
-
-	/**
-	 * This field should be set to true when block guard is to be enabled
-	 */
-	u32 block_guard_enable:1;
-
-	/**
-	 * This field is reserved and the driver should set to 0x00
-	 */
-	u32 sdma_control_reserved:7;
-
-	/* OFFSET 0x0C */
-	/**
-	 * This field is the address modifier for this io request it should be
-	 * programmed with the virtual function that is making the request.
-	 */
-	u32 address_modifier:16;
-
-	/**
-	 * @todo What we support mirrored SMP response frame?
-	 */
-	u32 mirrored_protocol_engine:3;  /* mirrored protocol Engine Index */
-
-	/**
-	 * If this is a mirrored request the logical port index for the mirrored RNi
-	 * must be programmed.
-	 */
-	u32 mirrored_logical_port:4;  /* mirrored local port index */
-
-	/**
-	 * This field is reserved and the driver must set it to 0x00
-	 */
-	u32 reserved_0C_0:8;
-
-	/**
-	 * This field must be set to true if the mirrored request processing is to be
-	 * enabled.
-	 */
-	u32 mirror_request_enable:1;  /* Mirrored request Enable */
-
-	/* OFFSET 0x10 */
-	/**
-	 * This field is the command iu length in dwords
-	 */
-	u32 ssp_command_iu_length:8;
-
-	/**
-	 * This is the target TLR enable bit it must be set to 0 when creatning the
-	 * task context.
-	 */
-	u32 xfer_ready_tlr_enable:1;
-
-	/**
-	 * This field is reserved and the driver must set it to 0x00
-	 */
-	u32 reserved_10_0:7;
-
-	/**
-	 * This is the maximum burst size that the SCU hardware will send in one
-	 * connection its value is (N x 512) and N must be a multiple of 2.  If the
-	 * value is 0x00 then maximum burst size is disabled.
-	 */
-	u32 ssp_max_burst_size:16;
-
-	/* OFFSET 0x14 */
-	/**
-	 * This filed is set to the number of bytes to be transfered in the request.
-	 */
-	u32 transfer_length_bytes:24; /* In terms of bytes */
-
-	/**
-	 * This field is reserved and the driver should set it to 0x00
-	 */
-	u32 reserved_14_0:8;
-
-	/* OFFSET 0x18-0x2C */
-	/**
-	 * This union provides for the protocol specif part of the SCU Task Context.
-	 */
-	union protocol_context type;
-
-	/* OFFSET 0x30-0x34 */
-	/**
-	 * This field is the upper 32 bits of the 64 bit physical address of the
-	 * command iu buffer
-	 */
-	u32 command_iu_upper;
-
-	/**
-	 * This field is the lower 32 bits of the 64 bit physical address of the
-	 * command iu buffer
-	 */
-	u32 command_iu_lower;
-
-	/* OFFSET 0x38-0x3C */
-	/**
-	 * This field is the upper 32 bits of the 64 bit physical address of the
-	 * response iu buffer
-	 */
-	u32 response_iu_upper;
-
-	/**
-	 * This field is the lower 32 bits of the 64 bit physical address of the
-	 * response iu buffer
-	 */
-	u32 response_iu_lower;
-
-	/* OFFSET 0x40 */
-	/**
-	 * This field is set to the task phase of the SCU hardware. The driver must
-	 * set this to 0x01
-	 */
-	u32 task_phase:8;
-
-	/**
-	 * This field is set to the transport layer task status.  The driver must set
-	 * this to 0x00
-	 */
-	u32 task_status:8;
-
-	/**
-	 * This field is used during initiator write TLR
-	 */
-	u32 previous_extended_tag:4;
-
-	/**
-	 * This field is set the maximum number of retries for a STP non-data FIS
-	 */
-	u32 stp_retry_count:2;
-
-	/**
-	 * This field is reserved and the driver must set it to 0x00
-	 */
-	u32 reserved_40_1:2;
-
-	/**
-	 * This field is used by the SCU TL to determine when to take a snapshot when
-	 * tranmitting read data frames.
-	 *    - 0x00 The entire IO
-	 *    - 0x01 32k
-	 *    - 0x02 64k
-	 *    - 0x04 128k
-	 *    - 0x08 256k
-	 */
-	u32 ssp_tlr_threshold:4;
-
-	/**
-	 * This field is reserved and the driver must set it to 0x00
-	 */
-	u32 reserved_40_2:4;
-
-	/* OFFSET 0x44 */
-	u32 write_data_length; /* read only set to 0 */
-
-	/* OFFSET 0x48-0x58 */
-	struct transport_snapshot snapshot; /* read only set to 0 */
-
-	/* OFFSET 0x5C */
-	u32 block_protection_enable:1;
-	u32 block_size:2;
-	u32 block_protection_function:2;
-	u32 reserved_5C_0:9;
-	u32 active_sgl_element:2;  /* read only set to 0 */
-	u32 sgl_exhausted:1;  /* read only set to 0 */
-	u32 payload_data_transfer_error:4;  /* read only set to 0 */
-	u32 frame_buffer_offset:11; /* read only set to 0 */
-
-	/* OFFSET 0x60-0x7C */
-	/**
-	 * This field is the first SGL element pair found in the TC data structure.
-	 */
-	struct scu_sgl_element_pair sgl_pair_ab;
-	/* OFFSET 0x80-0x9C */
-	/**
-	 * This field is the second SGL element pair found in the TC data structure.
-	 */
-	struct scu_sgl_element_pair sgl_pair_cd;
-
-	/* OFFSET 0xA0-BC */
-	struct scu_sgl_element_pair sgl_snapshot_ac;
-
-	/* OFFSET 0xC0 */
-	u32 active_sgl_element_pair; /* read only set to 0 */
-
-	/* OFFSET 0xC4-0xCC */
-	u32 reserved_C4_CC[3];
-
-	/* OFFSET 0xD0 */
-	u32 intermediate_crc_value:16;
-	u32 initial_crc_seed:16;
-
-	/* OFFSET 0xD4 */
-	u32 application_tag_for_verify:16;
-	u32 application_tag_for_generate:16;
-
-	/* OFFSET 0xD8 */
-	u32 reference_tag_seed_for_verify_function;
-
-	/* OFFSET 0xDC */
-	u32 reserved_DC;
-
-	/* OFFSET 0xE0 */
-	u32 reserved_E0_0:16;
-	u32 application_tag_mask_for_generate:16;
-
-	/* OFFSET 0xE4 */
-	u32 block_protection_control:16;
-	u32 application_tag_mask_for_verify:16;
-
-	/* OFFSET 0xE8 */
-	u32 block_protection_error:8;
-	u32 reserved_E8_0:24;
-
-	/* OFFSET 0xEC */
-	u32 reference_tag_seed_for_verify;
-
-	/* OFFSET 0xF0 */
-	u32 intermediate_crc_valid_snapshot:16;
-	u32 reserved_F0_0:16;
-
-	/* OFFSET 0xF4 */
-	u32 reference_tag_seed_for_verify_function_snapshot;
-
-	/* OFFSET 0xF8 */
-	u32 snapshot_of_reserved_dword_DC_of_tc;
-
-	/* OFFSET 0xFC */
-	u32 reference_tag_seed_for_generate_function_snapshot;
-
-};
-
-#endif /* _SCU_TASK_CONTEXT_H_ */
diff --git a/drivers/scsi/isci/core/scu_unsolicited_frame.h b/drivers/scsi/isci/core/scu_unsolicited_frame.h
deleted file mode 100644
index 187c4f0..0000000
--- a/drivers/scsi/isci/core/scu_unsolicited_frame.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * This field defines the SCU format of an unsolicited frame (UF).  A UF is a
- *    frame received by the SCU for which there is no known corresponding task
- *    context (TC).
- *
- *
- */
-
-#ifndef _SCU_UNSOLICITED_FRAME_H_
-#define _SCU_UNSOLICITED_FRAME_H_
-
-#include <linux/string.h>
-
-/**
- *
- *
- * This constant defines the number of DWORDS found the unsolicited frame
- * header data member.
- */
-#define SCU_UNSOLICITED_FRAME_HEADER_DATA_DWORDS 15
-
-/**
- * struct scu_unsolicited_frame_header -
- *
- * This structure delineates the format of an unsolicited frame header. The
- * first DWORD are UF attributes defined by the silicon architecture. The data
- * depicts actual header information received on the link.
- */
-struct scu_unsolicited_frame_header {
-	/**
-	 * This field indicates if there is an Initiator Index Table entry with
-	 * which this header is associated.
-	 */
-	u32 iit_exists:1;
-
-	/**
-	 * This field simply indicates the protocol type (i.e. SSP, STP, SMP).
-	 */
-	u32 protocol_type:3;
-
-	/**
-	 * This field indicates if the frame is an address frame (IAF or OAF)
-	 * or if it is a information unit frame.
-	 */
-	u32 is_address_frame:1;
-
-	/**
-	 * This field simply indicates the connection rate at which the frame
-	 * was received.
-	 */
-	u32 connection_rate:4;
-
-	u32 reserved:23;
-
-	/**
-	 * This field represents the actual header data received on the link.
-	 */
-	u32 data[SCU_UNSOLICITED_FRAME_HEADER_DATA_DWORDS];
-
-};
-
-#endif /* _SCU_UNSOLICITED_FRAME_H_ */
diff --git a/drivers/scsi/isci/core/scu_viit_data.h b/drivers/scsi/isci/core/scu_viit_data.h
deleted file mode 100644
index c959d91..0000000
--- a/drivers/scsi/isci/core/scu_viit_data.h
+++ /dev/null
@@ -1,178 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCU_VIIT_DATA_HEADER_
-#define _SCU_VIIT_DATA_HEADER_
-
-/**
- * This file contains the constants and structures for the SCU hardware VIIT
- *    table entries.
- *
- *
- */
-
-
-#define SCU_VIIT_ENTRY_ID_MASK         (0xC0000000)
-#define SCU_VIIT_ENTRY_ID_SHIFT        (30)
-
-#define SCU_VIIT_ENTRY_FUNCTION_MASK   (0x0FF00000)
-#define SCU_VIIT_ENTRY_FUNCTION_SHIFT  (20)
-
-#define SCU_VIIT_ENTRY_IPPTMODE_MASK   (0x0001F800)
-#define SCU_VIIT_ENTRY_IPPTMODE_SHIFT  (12)
-
-#define SCU_VIIT_ENTRY_LPVIE_MASK      (0x00000F00)
-#define SCU_VIIT_ENTRY_LPVIE_SHIFT     (8)
-
-#define SCU_VIIT_ENTRY_STATUS_MASK     (0x000000FF)
-#define SCU_VIIT_ENTRY_STATUS_SHIFT    (0)
-
-#define SCU_VIIT_ENTRY_ID_INVALID   (0 << SCU_VIIT_ENTRY_ID_SHIFT)
-#define SCU_VIIT_ENTRY_ID_VIIT      (1 << SCU_VIIT_ENTRY_ID_SHIFT)
-#define SCU_VIIT_ENTRY_ID_IIT       (2 << SCU_VIIT_ENTRY_ID_SHIFT)
-#define SCU_VIIT_ENTRY_ID_VIRT_EXP  (3 << SCU_VIIT_ENTRY_ID_SHIFT)
-
-#define SCU_VIIT_IPPT_SSP_INITIATOR (0x01 << SCU_VIIT_ENTRY_IPPTMODE_SHIFT)
-#define SCU_VIIT_IPPT_SMP_INITIATOR (0x02 << SCU_VIIT_ENTRY_IPPTMODE_SHIFT)
-#define SCU_VIIT_IPPT_STP_INITIATOR (0x04 << SCU_VIIT_ENTRY_IPPTMODE_SHIFT)
-#define SCU_VIIT_IPPT_INITIATOR	    \
-	(\
-		SCU_VIIT_IPPT_SSP_INITIATOR  \
-		| SCU_VIIT_IPPT_SMP_INITIATOR  \
-		| SCU_VIIT_IPPT_STP_INITIATOR  \
-	)
-
-#define SCU_VIIT_STATUS_RNC_VALID      (0x01 << SCU_VIIT_ENTRY_STATUS_SHIFT)
-#define SCU_VIIT_STATUS_ADDRESS_VALID  (0x02 << SCU_VIIT_ENTRY_STATUS_SHIFT)
-#define SCU_VIIT_STATUS_RNI_VALID      (0x04 << SCU_VIIT_ENTRY_STATUS_SHIFT)
-#define SCU_VIIT_STATUS_ALL_VALID      \
-	(\
-		SCU_VIIT_STATUS_RNC_VALID	\
-		| SCU_VIIT_STATUS_ADDRESS_VALID	  \
-		| SCU_VIIT_STATUS_RNI_VALID	  \
-	)
-
-#define SCU_VIIT_IPPT_SMP_TARGET    (0x10 << SCU_VIIT_ENTRY_IPPTMODE_SHIFT)
-
-/**
- * struct scu_viit_entry - This is the SCU Virtual Initiator Table Entry
- *
- *
- */
-struct scu_viit_entry {
-	/**
-	 * This must be encoded as to the type of initiator that is being constructed
-	 * for this port.
-	 */
-	u32 status;
-
-	/**
-	 * Virtual initiator high SAS Address
-	 */
-	u32 initiator_sas_address_hi;
-
-	/**
-	 * Virtual initiator low SAS Address
-	 */
-	u32 initiator_sas_address_lo;
-
-	/**
-	 * This must be 0
-	 */
-	u32 reserved;
-
-};
-
-
-/* IIT Status Defines */
-#define SCU_IIT_ENTRY_ID_MASK                (0xC0000000)
-#define SCU_IIT_ENTRY_ID_SHIFT               (30)
-
-#define SCU_IIT_ENTRY_STATUS_UPDATE_MASK     (0x20000000)
-#define SCU_IIT_ENTRY_STATUS_UPDATE_SHIFT    (29)
-
-#define SCU_IIT_ENTRY_LPI_MASK               (0x00000F00)
-#define SCU_IIT_ENTRY_LPI_SHIFT              (8)
-
-#define SCU_IIT_ENTRY_STATUS_MASK            (0x000000FF)
-#define SCU_IIT_ENTRY_STATUS_SHIFT           (0)
-
-/* IIT Remote Initiator Defines */
-#define SCU_IIT_ENTRY_REMOTE_TAG_MASK  (0x0000FFFF)
-#define SCU_IIT_ENTRY_REMOTE_TAG_SHIFT (0)
-
-#define SCU_IIT_ENTRY_REMOTE_RNC_MASK  (0x0FFF0000)
-#define SCU_IIT_ENTRY_REMOTE_RNC_SHIFT (16)
-
-#define SCU_IIT_ENTRY_ID_INVALID   (0 << SCU_IIT_ENTRY_ID_SHIFT)
-#define SCU_IIT_ENTRY_ID_VIIT      (1 << SCU_IIT_ENTRY_ID_SHIFT)
-#define SCU_IIT_ENTRY_ID_IIT       (2 << SCU_IIT_ENTRY_ID_SHIFT)
-#define SCU_IIT_ENTRY_ID_VIRT_EXP  (3 << SCU_IIT_ENTRY_ID_SHIFT)
-
-/**
- * struct scu_iit_entry - This will be implemented later when we support
- *    virtual functions
- *
- *
- */
-struct scu_iit_entry {
-	u32 status;
-	u32 remote_initiator_sas_address_hi;
-	u32 remote_initiator_sas_address_lo;
-	u32 remote_initiator;
-
-};
-
-#endif /* _SCU_VIIT_DATA_HEADER_ */
diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 43a5d7a..71a0466 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -66,7 +66,7 @@
 #include "sci_util.h"
 #include "scu_completion_codes.h"
 #include "scu_event_codes.h"
-#include "scu_registers.h"
+#include "registers.h"
 #include "scu_remote_node_context.h"
 #include "scu_task_context.h"
 #include "scu_unsolicited_frame.h"
diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 1f542c4..64edac8 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -61,9 +61,9 @@
 #include "pool.h"
 #include "sci_base_state_machine.h"
 #include "remote_node_table.h"
-#include "scu_registers.h"
+#include "registers.h"
 #include "scu_unsolicited_frame.h"
-#include "scic_sds_unsolicited_frame_control.h"
+#include "unsolicited_frame_control.h"
 #include "scic_sds_port_configuration_agent.h"
 
 struct scic_sds_request;
diff --git a/drivers/scsi/isci/registers.h b/drivers/scsi/isci/registers.h
new file mode 100644
index 0000000..9b266c7
--- /dev/null
+++ b/drivers/scsi/isci/registers.h
@@ -0,0 +1,1934 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _SCU_REGISTERS_H_
+#define _SCU_REGISTERS_H_
+
+/**
+ * This file contains the constants and structures for the SCU memory mapped
+ *    registers.
+ *
+ *
+ */
+
+#define SCU_VIIT_ENTRY_ID_MASK         (0xC0000000)
+#define SCU_VIIT_ENTRY_ID_SHIFT        (30)
+
+#define SCU_VIIT_ENTRY_FUNCTION_MASK   (0x0FF00000)
+#define SCU_VIIT_ENTRY_FUNCTION_SHIFT  (20)
+
+#define SCU_VIIT_ENTRY_IPPTMODE_MASK   (0x0001F800)
+#define SCU_VIIT_ENTRY_IPPTMODE_SHIFT  (12)
+
+#define SCU_VIIT_ENTRY_LPVIE_MASK      (0x00000F00)
+#define SCU_VIIT_ENTRY_LPVIE_SHIFT     (8)
+
+#define SCU_VIIT_ENTRY_STATUS_MASK     (0x000000FF)
+#define SCU_VIIT_ENTRY_STATUS_SHIFT    (0)
+
+#define SCU_VIIT_ENTRY_ID_INVALID   (0 << SCU_VIIT_ENTRY_ID_SHIFT)
+#define SCU_VIIT_ENTRY_ID_VIIT      (1 << SCU_VIIT_ENTRY_ID_SHIFT)
+#define SCU_VIIT_ENTRY_ID_IIT       (2 << SCU_VIIT_ENTRY_ID_SHIFT)
+#define SCU_VIIT_ENTRY_ID_VIRT_EXP  (3 << SCU_VIIT_ENTRY_ID_SHIFT)
+
+#define SCU_VIIT_IPPT_SSP_INITIATOR (0x01 << SCU_VIIT_ENTRY_IPPTMODE_SHIFT)
+#define SCU_VIIT_IPPT_SMP_INITIATOR (0x02 << SCU_VIIT_ENTRY_IPPTMODE_SHIFT)
+#define SCU_VIIT_IPPT_STP_INITIATOR (0x04 << SCU_VIIT_ENTRY_IPPTMODE_SHIFT)
+#define SCU_VIIT_IPPT_INITIATOR	    \
+	(\
+		SCU_VIIT_IPPT_SSP_INITIATOR  \
+		| SCU_VIIT_IPPT_SMP_INITIATOR  \
+		| SCU_VIIT_IPPT_STP_INITIATOR  \
+	)
+
+#define SCU_VIIT_STATUS_RNC_VALID      (0x01 << SCU_VIIT_ENTRY_STATUS_SHIFT)
+#define SCU_VIIT_STATUS_ADDRESS_VALID  (0x02 << SCU_VIIT_ENTRY_STATUS_SHIFT)
+#define SCU_VIIT_STATUS_RNI_VALID      (0x04 << SCU_VIIT_ENTRY_STATUS_SHIFT)
+#define SCU_VIIT_STATUS_ALL_VALID      \
+	(\
+		SCU_VIIT_STATUS_RNC_VALID	\
+		| SCU_VIIT_STATUS_ADDRESS_VALID	  \
+		| SCU_VIIT_STATUS_RNI_VALID	  \
+	)
+
+#define SCU_VIIT_IPPT_SMP_TARGET    (0x10 << SCU_VIIT_ENTRY_IPPTMODE_SHIFT)
+
+/**
+ * struct scu_viit_entry - This is the SCU Virtual Initiator Table Entry
+ *
+ *
+ */
+struct scu_viit_entry {
+	/**
+	 * This must be encoded as to the type of initiator that is being constructed
+	 * for this port.
+	 */
+	u32 status;
+
+	/**
+	 * Virtual initiator high SAS Address
+	 */
+	u32 initiator_sas_address_hi;
+
+	/**
+	 * Virtual initiator low SAS Address
+	 */
+	u32 initiator_sas_address_lo;
+
+	/**
+	 * This must be 0
+	 */
+	u32 reserved;
+
+};
+
+
+/* IIT Status Defines */
+#define SCU_IIT_ENTRY_ID_MASK                (0xC0000000)
+#define SCU_IIT_ENTRY_ID_SHIFT               (30)
+
+#define SCU_IIT_ENTRY_STATUS_UPDATE_MASK     (0x20000000)
+#define SCU_IIT_ENTRY_STATUS_UPDATE_SHIFT    (29)
+
+#define SCU_IIT_ENTRY_LPI_MASK               (0x00000F00)
+#define SCU_IIT_ENTRY_LPI_SHIFT              (8)
+
+#define SCU_IIT_ENTRY_STATUS_MASK            (0x000000FF)
+#define SCU_IIT_ENTRY_STATUS_SHIFT           (0)
+
+/* IIT Remote Initiator Defines */
+#define SCU_IIT_ENTRY_REMOTE_TAG_MASK  (0x0000FFFF)
+#define SCU_IIT_ENTRY_REMOTE_TAG_SHIFT (0)
+
+#define SCU_IIT_ENTRY_REMOTE_RNC_MASK  (0x0FFF0000)
+#define SCU_IIT_ENTRY_REMOTE_RNC_SHIFT (16)
+
+#define SCU_IIT_ENTRY_ID_INVALID   (0 << SCU_IIT_ENTRY_ID_SHIFT)
+#define SCU_IIT_ENTRY_ID_VIIT      (1 << SCU_IIT_ENTRY_ID_SHIFT)
+#define SCU_IIT_ENTRY_ID_IIT       (2 << SCU_IIT_ENTRY_ID_SHIFT)
+#define SCU_IIT_ENTRY_ID_VIRT_EXP  (3 << SCU_IIT_ENTRY_ID_SHIFT)
+
+/**
+ * struct scu_iit_entry - This will be implemented later when we support
+ *    virtual functions
+ *
+ *
+ */
+struct scu_iit_entry {
+	u32 status;
+	u32 remote_initiator_sas_address_hi;
+	u32 remote_initiator_sas_address_lo;
+	u32 remote_initiator;
+
+};
+
+/* Generate a value for an SCU register */
+#define SCU_GEN_VALUE(name, value) \
+	(((value) << name ## _SHIFT) & (name ## _MASK))
+
+/*
+ * Generate a bit value for an SCU register
+ * Make sure that the register MASK is just a single bit */
+#define SCU_GEN_BIT(name) \
+	SCU_GEN_VALUE(name, ((u32)1))
+
+#define SCU_SET_BIT(name, reg_value) \
+	((reg_value) | SCU_GEN_BIT(name))
+
+#define SCU_CLEAR_BIT(name, reg_value) \
+	((reg_value)$ ~(SCU_GEN_BIT(name)))
+
+/*
+ * *****************************************************************************
+ * Unions for bitfield definitions of SCU Registers
+ * SMU Post Context Port
+ * ***************************************************************************** */
+#define SMU_POST_CONTEXT_PORT_CONTEXT_INDEX_SHIFT         (0)
+#define SMU_POST_CONTEXT_PORT_CONTEXT_INDEX_MASK          (0x00000FFF)
+#define SMU_POST_CONTEXT_PORT_LOGICAL_PORT_INDEX_SHIFT    (12)
+#define SMU_POST_CONTEXT_PORT_LOGICAL_PORT_INDEX_MASK     (0x0000F000)
+#define SMU_POST_CONTEXT_PORT_PROTOCOL_ENGINE_SHIFT       (16)
+#define SMU_POST_CONTEXT_PORT_PROTOCOL_ENGINE_MASK        (0x00030000)
+#define SMU_POST_CONTEXT_PORT_COMMAND_CONTEXT_SHIFT       (18)
+#define SMU_POST_CONTEXT_PORT_COMMAND_CONTEXT_MASK        (0x00FC0000)
+#define SMU_POST_CONTEXT_PORT_RESERVED_MASK               (0xFF000000)
+
+#define SMU_PCP_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SMU_POST_CONTEXT_PORT_ ## name, value)
+
+/* ***************************************************************************** */
+#define SMU_INTERRUPT_STATUS_COMPLETION_SHIFT       (31)
+#define SMU_INTERRUPT_STATUS_COMPLETION_MASK        (0x80000000)
+#define SMU_INTERRUPT_STATUS_QUEUE_SUSPEND_SHIFT    (1)
+#define SMU_INTERRUPT_STATUS_QUEUE_SUSPEND_MASK     (0x00000002)
+#define SMU_INTERRUPT_STATUS_QUEUE_ERROR_SHIFT      (0)
+#define SMU_INTERRUPT_STATUS_QUEUE_ERROR_MASK       (0x00000001)
+#define SMU_INTERRUPT_STATUS_RESERVED_MASK          (0x7FFFFFFC)
+
+#define SMU_ISR_GEN_BIT(name) \
+	SCU_GEN_BIT(SMU_INTERRUPT_STATUS_ ## name)
+
+#define SMU_ISR_QUEUE_ERROR   SMU_ISR_GEN_BIT(QUEUE_ERROR)
+#define SMU_ISR_QUEUE_SUSPEND SMU_ISR_GEN_BIT(QUEUE_SUSPEND)
+#define SMU_ISR_COMPLETION    SMU_ISR_GEN_BIT(COMPLETION)
+
+/* ***************************************************************************** */
+#define SMU_INTERRUPT_MASK_COMPLETION_SHIFT         (31)
+#define SMU_INTERRUPT_MASK_COMPLETION_MASK          (0x80000000)
+#define SMU_INTERRUPT_MASK_QUEUE_SUSPEND_SHIFT      (1)
+#define SMU_INTERRUPT_MASK_QUEUE_SUSPEND_MASK       (0x00000002)
+#define SMU_INTERRUPT_MASK_QUEUE_ERROR_SHIFT        (0)
+#define SMU_INTERRUPT_MASK_QUEUE_ERROR_MASK         (0x00000001)
+#define SMU_INTERRUPT_MASK_RESERVED_MASK            (0x7FFFFFFC)
+
+#define SMU_IMR_GEN_BIT(name) \
+	SCU_GEN_BIT(SMU_INTERRUPT_MASK_ ## name)
+
+#define SMU_IMR_QUEUE_ERROR   SMU_IMR_GEN_BIT(QUEUE_ERROR)
+#define SMU_IMR_QUEUE_SUSPEND SMU_IMR_GEN_BIT(QUEUE_SUSPEND)
+#define SMU_IMR_COMPLETION    SMU_IMR_GEN_BIT(COMPLETION)
+
+/* ***************************************************************************** */
+#define SMU_INTERRUPT_COALESCING_CONTROL_TIMER_SHIFT    (0)
+#define SMU_INTERRUPT_COALESCING_CONTROL_TIMER_MASK     (0x0000001F)
+#define SMU_INTERRUPT_COALESCING_CONTROL_NUMBER_SHIFT   (8)
+#define SMU_INTERRUPT_COALESCING_CONTROL_NUMBER_MASK    (0x0000FF00)
+#define SMU_INTERRUPT_COALESCING_CONTROL_RESERVED_MASK  (0xFFFF00E0)
+
+#define SMU_ICC_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SMU_INTERRUPT_COALESCING_CONTROL_ ## name, value)
+
+/* ***************************************************************************** */
+#define SMU_TASK_CONTEXT_RANGE_START_SHIFT      (0)
+#define SMU_TASK_CONTEXT_RANGE_START_MASK       (0x00000FFF)
+#define SMU_TASK_CONTEXT_RANGE_ENDING_SHIFT     (16)
+#define SMU_TASK_CONTEXT_RANGE_ENDING_MASK      (0x0FFF0000)
+#define SMU_TASK_CONTEXT_RANGE_ENABLE_SHIFT     (31)
+#define SMU_TASK_CONTEXT_RANGE_ENABLE_MASK      (0x80000000)
+#define SMU_TASK_CONTEXT_RANGE_RESERVED_MASK    (0x7000F000)
+
+#define SMU_TCR_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SMU_TASK_CONTEXT_RANGE_ ## name, value)
+
+#define SMU_TCR_GEN_BIT(name, value) \
+	SCU_GEN_BIT(SMU_TASK_CONTEXT_RANGE_ ## name)
+
+/* ***************************************************************************** */
+
+#define SMU_COMPLETION_QUEUE_PUT_POINTER_SHIFT          (0)
+#define SMU_COMPLETION_QUEUE_PUT_POINTER_MASK           (0x00003FFF)
+#define SMU_COMPLETION_QUEUE_PUT_CYCLE_BIT_SHIFT        (15)
+#define SMU_COMPLETION_QUEUE_PUT_CYCLE_BIT_MASK         (0x00008000)
+#define SMU_COMPLETION_QUEUE_PUT_EVENT_POINTER_SHIFT    (16)
+#define SMU_COMPLETION_QUEUE_PUT_EVENT_POINTER_MASK     (0x03FF0000)
+#define SMU_COMPLETION_QUEUE_PUT_EVENT_CYCLE_BIT_SHIFT  (26)
+#define SMU_COMPLETION_QUEUE_PUT_EVENT_CYCLE_BIT_MASK   (0x04000000)
+#define SMU_COMPLETION_QUEUE_PUT_RESERVED_MASK          (0xF8004000)
+
+#define SMU_CQPR_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SMU_COMPLETION_QUEUE_PUT_ ## name, value)
+
+#define SMU_CQPR_GEN_BIT(name) \
+	SCU_GEN_BIT(SMU_COMPLETION_QUEUE_PUT_ ## name)
+
+/* ***************************************************************************** */
+
+#define SMU_COMPLETION_QUEUE_GET_POINTER_SHIFT          (0)
+#define SMU_COMPLETION_QUEUE_GET_POINTER_MASK           (0x00003FFF)
+#define SMU_COMPLETION_QUEUE_GET_CYCLE_BIT_SHIFT        (15)
+#define SMU_COMPLETION_QUEUE_GET_CYCLE_BIT_MASK         (0x00008000)
+#define SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_SHIFT    (16)
+#define SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_MASK     (0x03FF0000)
+#define SMU_COMPLETION_QUEUE_GET_EVENT_CYCLE_BIT_SHIFT  (26)
+#define SMU_COMPLETION_QUEUE_GET_EVENT_CYCLE_BIT_MASK   (0x04000000)
+#define SMU_COMPLETION_QUEUE_GET_ENABLE_SHIFT           (30)
+#define SMU_COMPLETION_QUEUE_GET_ENABLE_MASK            (0x40000000)
+#define SMU_COMPLETION_QUEUE_GET_EVENT_ENABLE_SHIFT     (31)
+#define SMU_COMPLETION_QUEUE_GET_EVENT_ENABLE_MASK      (0x80000000)
+#define SMU_COMPLETION_QUEUE_GET_RESERVED_MASK          (0x38004000)
+
+#define SMU_CQGR_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SMU_COMPLETION_QUEUE_GET_ ## name, value)
+
+#define SMU_CQGR_GEN_BIT(name) \
+	SCU_GEN_BIT(SMU_COMPLETION_QUEUE_GET_ ## name)
+
+#define SMU_CQGR_CYCLE_BIT \
+	SMU_CQGR_GEN_BIT(CYCLE_BIT)
+
+#define SMU_CQGR_EVENT_CYCLE_BIT \
+	SMU_CQGR_GEN_BIT(EVENT_CYCLE_BIT)
+
+#define SMU_CQGR_GET_POINTER_SET(value)	\
+	SMU_CQGR_GEN_VAL(POINTER, value)
+
+
+/* ***************************************************************************** */
+#define SMU_COMPLETION_QUEUE_CONTROL_QUEUE_LIMIT_SHIFT  (0)
+#define SMU_COMPLETION_QUEUE_CONTROL_QUEUE_LIMIT_MASK   (0x00003FFF)
+#define SMU_COMPLETION_QUEUE_CONTROL_EVENT_LIMIT_SHIFT  (16)
+#define SMU_COMPLETION_QUEUE_CONTROL_EVENT_LIMIT_MASK   (0x03FF0000)
+#define SMU_COMPLETION_QUEUE_CONTROL_RESERVED_MASK      (0xFC00C000)
+
+#define SMU_CQC_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SMU_COMPLETION_QUEUE_CONTROL_ ## name, value)
+
+#define SMU_CQC_QUEUE_LIMIT_SET(value) \
+	SMU_CQC_GEN_VAL(QUEUE_LIMIT, value)
+
+#define SMU_CQC_EVENT_LIMIT_SET(value) \
+	SMU_CQC_GEN_VAL(EVENT_LIMIT, value)
+
+
+/* ***************************************************************************** */
+#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_SHIFT    (0)
+#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_MASK     (0x00000FFF)
+#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_SHIFT    (12)
+#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_MASK     (0x00007000)
+#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_SHIFT   (15)
+#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_MASK    (0x07FF8000)
+#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_PEG_SHIFT   (27)
+#define SMU_DEVICE_CONTEXT_CAPACITY_MAX_PEG_MASK    (0x08000000)
+#define SMU_DEVICE_CONTEXT_CAPACITY_RESERVED_MASK   (0xF0000000)
+
+#define SMU_DCC_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SMU_DEVICE_CONTEXT_CAPACITY_ ## name, value)
+
+#define SMU_DCC_GET_MAX_PEG(value) \
+	(\
+		((value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_PEG_MASK) \
+		>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_SHIFT \
+	)
+
+#define SMU_DCC_GET_MAX_LP(value) \
+	(\
+		((value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_MASK) \
+		>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_SHIFT \
+	)
+
+#define SMU_DCC_GET_MAX_TC(value) \
+	(\
+		((value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_MASK) \
+		>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_SHIFT \
+	)
+
+#define SMU_DCC_GET_MAX_RNC(value) \
+	(\
+		((value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_MASK) \
+		>> SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_SHIFT \
+	)
+
+/* -------------------------------------------------------------------------- */
+
+#define SMU_CONTROL_STATUS_TASK_CONTEXT_RANGE_ENABLE_SHIFT      (0)
+#define SMU_CONTROL_STATUS_TASK_CONTEXT_RANGE_ENABLE_MASK       (0x00000001)
+#define SMU_CONTROL_STATUS_COMPLETION_BYTE_SWAP_ENABLE_SHIFT    (1)
+#define SMU_CONTROL_STATUS_COMPLETION_BYTE_SWAP_ENABLE_MASK     (0x00000002)
+#define SMU_CONTROL_STATUS_CONTEXT_RAM_INIT_COMPLETED_SHIFT     (16)
+#define SMU_CONTROL_STATUS_CONTEXT_RAM_INIT_COMPLETED_MASK      (0x00010000)
+#define SMU_CONTROL_STATUS_SCHEDULER_RAM_INIT_COMPLETED_SHIFT   (17)
+#define SMU_CONTROL_STATUS_SCHEDULER_RAM_INIT_COMPLETED_MASK    (0x00020000)
+#define SMU_CONTROL_STATUS_RESERVED_MASK                        (0xFFFCFFFC)
+
+#define SMU_SMUCSR_GEN_BIT(name) \
+	SCU_GEN_BIT(SMU_CONTROL_STATUS_ ## name)
+
+#define SMU_SMUCSR_SCHEDULER_RAM_INIT_COMPLETED	\
+	(SMU_SMUCSR_GEN_BIT(SCHEDULER_RAM_INIT_COMPLETED))
+
+#define SMU_SMUCSR_CONTEXT_RAM_INIT_COMPLETED	\
+	(SMU_SMUCSR_GEN_BIT(CONTEXT_RAM_INIT_COMPLETED))
+
+#define SCU_RAM_INIT_COMPLETED \
+	(\
+		SMU_SMUCSR_CONTEXT_RAM_INIT_COMPLETED \
+		| SMU_SMUCSR_SCHEDULER_RAM_INIT_COMPLETED \
+	)
+
+/* -------------------------------------------------------------------------- */
+
+#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE0_SHIFT  (0)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE0_MASK   (0x00000001)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE1_SHIFT  (1)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE1_MASK   (0x00000002)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE2_SHIFT  (2)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE2_MASK   (0x00000004)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE3_SHIFT  (3)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG0_PE3_MASK   (0x00000008)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE0_SHIFT  (8)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE0_MASK   (0x00000100)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE1_SHIFT  (9)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE1_MASK   (0x00000200)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE2_SHIFT  (10)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE2_MASK   (0x00000400)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE3_SHIFT  (11)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG1_PE3_MASK   (0x00000800)
+
+#define SMU_RESET_PROTOCOL_ENGINE(peg, pe) \
+	((1 << (pe)) << ((peg) * 8))
+
+#define SMU_RESET_PEG_PROTOCOL_ENGINES(peg) \
+	(\
+		SMU_RESET_PROTOCOL_ENGINE(peg, 0) \
+		| SMU_RESET_PROTOCOL_ENGINE(peg, 1) \
+		| SMU_RESET_PROTOCOL_ENGINE(peg, 2) \
+		| SMU_RESET_PROTOCOL_ENGINE(peg, 3) \
+	)
+
+#define SMU_RESET_ALL_PROTOCOL_ENGINES() \
+	(\
+		SMU_RESET_PEG_PROTOCOL_ENGINES(0) \
+		| SMU_RESET_PEG_PROTOCOL_ENGINES(1) \
+	)
+
+#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG0_LP0_SHIFT  (16)
+#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG0_LP0_MASK   (0x00010000)
+#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG0_LP2_SHIFT  (17)
+#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG0_LP2_MASK   (0x00020000)
+#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG1_LP0_SHIFT  (18)
+#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG1_LP0_MASK   (0x00040000)
+#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG1_LP2_SHIFT  (19)
+#define SMU_SOFTRESET_CONTROL_RESET_WIDE_PORT_PEG1_LP2_MASK   (0x00080000)
+
+#define SMU_RESET_WIDE_PORT_QUEUE(peg, wide_port) \
+	((1 << ((wide_port) / 2)) << ((peg) * 2) << 16)
+
+#define SMU_SOFTRESET_CONTROL_RESET_PEG0_SHIFT      (20)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG0_MASK       (0x00100000)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG1_SHIFT      (21)
+#define SMU_SOFTRESET_CONTROL_RESET_PEG1_MASK       (0x00200000)
+#define SMU_SOFTRESET_CONTROL_RESET_SCU_SHIFT       (22)
+#define SMU_SOFTRESET_CONTROL_RESET_SCU_MASK        (0x00400000)
+
+/*
+ * It seems to make sense that if you are going to reset the protocol
+ * engine group that you would also reset all of the protocol engines */
+#define SMU_RESET_PROTOCOL_ENGINE_GROUP(peg) \
+	(\
+		(1 << ((peg) + 20)) \
+		| SMU_RESET_WIDE_PORT_QUEUE(peg, 0) \
+		| SMU_RESET_WIDE_PORT_QUEUE(peg, 1) \
+		| SMU_RESET_PEG_PROTOCOL_ENGINES(peg) \
+	)
+
+#define SMU_RESET_ALL_PROTOCOL_ENGINE_GROUPS() \
+	(\
+		SMU_RESET_PROTOCOL_ENGINE_GROUP(0) \
+		| SMU_RESET_PROTOCOL_ENGINE_GROUP(1) \
+	)
+
+#define SMU_RESET_SCU()  (0xFFFFFFFF)
+
+
+
+/* ***************************************************************************** */
+#define SMU_TASK_CONTEXT_ASSIGNMENT_STARTING_SHIFT              (0)
+#define SMU_TASK_CONTEXT_ASSIGNMENT_STARTING_MASK               (0x00000FFF)
+#define SMU_TASK_CONTEXT_ASSIGNMENT_ENDING_SHIFT                (16)
+#define SMU_TASK_CONTEXT_ASSIGNMENT_ENDING_MASK                 (0x0FFF0000)
+#define SMU_TASK_CONTEXT_ASSIGNMENT_RANGE_CHECK_ENABLE_SHIFT    (31)
+#define SMU_TASK_CONTEXT_ASSIGNMENT_RANGE_CHECK_ENABLE_MASK     (0x80000000)
+#define SMU_TASK_CONTEXT_ASSIGNMENT_RESERVED_MASK               (0x7000F000)
+
+#define SMU_TCA_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SMU_TASK_CONTEXT_ASSIGNMENT_ ## name, value)
+
+#define SMU_TCA_GEN_BIT(name) \
+	SCU_GEN_BIT(SMU_TASK_CONTEXT_ASSIGNMENT_ ## name)
+
+/* ***************************************************************************** */
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_CONTROL_QUEUE_SIZE_SHIFT   (0)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_CONTROL_QUEUE_SIZE_MASK    (0x00000FFF)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_CONTROL_RESERVED_MASK      (0xFFFFF000)
+
+#define SCU_UFQC_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_SDMA_UNSOLICITED_FRAME_QUEUE_CONTROL_ ## name, value)
+
+#define SCU_UFQC_QUEUE_SIZE_SET(value) \
+	SCU_UFQC_GEN_VAL(QUEUE_SIZE, value)
+
+/* ***************************************************************************** */
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_POINTER_SHIFT      (0)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_POINTER_MASK       (0x00000FFF)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_CYCLE_BIT_SHIFT    (12)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_CYCLE_BIT_MASK     (0x00001000)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_RESERVED_MASK      (0xFFFFE000)
+
+#define SCU_UFQPP_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_ ## name, value)
+
+#define SCU_UFQPP_GEN_BIT(name)	\
+	SCU_GEN_BIT(SCU_SDMA_UNSOLICITED_FRAME_QUEUE_PUT_ ## name)
+
+/*
+ * *****************************************************************************
+ * * SDMA Registers
+ * ***************************************************************************** */
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_POINTER_SHIFT      (0)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_POINTER_MASK       (0x00000FFF)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_CYCLE_BIT_SHIFT    (12)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_CYCLE_BIT_MASK     (12)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_ENABLE_BIT_SHIFT   (31)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_ENABLE_BIT_MASK    (0x80000000)
+#define SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_RESERVED_MASK      (0x7FFFE000)
+
+#define SCU_UFQGP_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_ ## name, value)
+
+#define SCU_UFQGP_GEN_BIT(name)	\
+	SCU_GEN_BIT(SCU_SDMA_UNSOLICITED_FRAME_QUEUE_GET_ ## name)
+
+#define SCU_UFQGP_CYCLE_BIT(value) \
+	SCU_UFQGP_GEN_BIT(CYCLE_BIT, value)
+
+#define SCU_UFQGP_GET_POINTER(value) \
+	SCU_UFQGP_GEN_VALUE(POINTER, value)
+
+#define SCU_UFQGP_ENABLE(value)	\
+	(SCU_UFQGP_GEN_BIT(ENABLE) | value)
+
+#define SCU_UFQGP_DISABLE(value) \
+	(~SCU_UFQGP_GEN_BIT(ENABLE) & value)
+
+#define SCU_UFQGP_VALUE(bit, value) \
+	(SCU_UFQGP_CYCLE_BIT(bit) | SCU_UFQGP_GET_POINTER(value))
+
+/* ***************************************************************************** */
+#define SCU_PDMA_CONFIGURATION_ADDRESS_MODIFIER_SHIFT                               (0)
+#define SCU_PDMA_CONFIGURATION_ADDRESS_MODIFIER_MASK                                (0x0000FFFF)
+#define SCU_PDMA_CONFIGURATION_PCI_RELAXED_ORDERING_ENABLE_SHIFT                    (16)
+#define SCU_PDMA_CONFIGURATION_PCI_RELAXED_ORDERING_ENABLE_MASK                     (0x00010000)
+#define SCU_PDMA_CONFIGURATION_PCI_NO_SNOOP_ENABLE_SHIFT                            (17)
+#define SCU_PDMA_CONFIGURATION_PCI_NO_SNOOP_ENABLE_MASK                             (0x00020000)
+#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_BYTE_SWAP_SHIFT                   (18)
+#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_BYTE_SWAP_MASK                    (0x00040000)
+#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_SGL_FETCH_SHIFT               (19)
+#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_SGL_FETCH_MASK                (0x00080000)
+#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_RX_HEADER_RAM_WRITE_SHIFT     (20)
+#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_RX_HEADER_RAM_WRITE_MASK      (0x00100000)
+#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_UF_ADDRESS_FETCH_SHIFT        (21)
+#define SCU_PDMA_CONFIGURATION_BIG_ENDIAN_CONTROL_XPI_UF_ADDRESS_FETCH_MASK         (0x00200000)
+#define SCU_PDMA_CONFIGURATION_ADDRESS_MODIFIER_SELECT_SHIFT                        (22)
+#define SCU_PDMA_CONFIGURATION_ADDRESS_MODIFIER_SELECT_MASK                         (0x00400000)
+#define SCU_PDMA_CONFIGURATION_RESERVED_MASK                                        (0xFF800000)
+
+#define SCU_PDMACR_GEN_VALUE(name, value) \
+	SCU_GEN_VALUE(SCU_PDMA_CONFIGURATION_ ## name, value)
+
+#define SCU_PDMACR_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_PDMA_CONFIGURATION_ ## name)
+
+#define SCU_PDMACR_BE_GEN_BIT(name) \
+	SCU_PCMACR_GEN_BIT(BIG_ENDIAN_CONTROL_ ## name)
+
+/* ***************************************************************************** */
+#define SCU_CDMA_CONFIGURATION_PCI_RELAXED_ORDERING_ENABLE_SHIFT                    (8)
+#define SCU_CDMA_CONFIGURATION_PCI_RELAXED_ORDERING_ENABLE_MASK                     (0x00000100)
+
+#define SCU_CDMACR_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_CDMA_CONFIGURATION_ ## name)
+
+/*
+ * *****************************************************************************
+ * * SCU Link Layer Registers
+ * ***************************************************************************** */
+#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_TIMEOUT_SHIFT             (0)
+#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_TIMEOUT_MASK              (0x000000FF)
+#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_LOCK_TIME_SHIFT           (8)
+#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_LOCK_TIME_MASK            (0x0000FF00)
+#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_RATE_CHANGE_DELAY_SHIFT   (16)
+#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_RATE_CHANGE_DELAY_MASK    (0x00FF0000)
+#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_DWORD_SYNC_TIMEOUT_SHIFT  (24)
+#define SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_DWORD_SYNC_TIMEOUT_MASK   (0xFF000000)
+#define SCU_LINK_LAYER_SPEED_NECGOIATION_TIMER_VALUES_REQUIRED_MASK             (0x00000000)
+#define SCU_LINK_LAYER_SPEED_NECGOIATION_TIMER_VALUES_DEFAULT_MASK              (0x7D00676F)
+#define SCU_LINK_LAYER_SPEED_NECGOIATION_TIMER_VALUES_RESERVED_MASK             (0x00FF0000)
+
+#define SCU_SAS_SPDTOV_GEN_VALUE(name, value) \
+	SCU_GEN_VALUE(SCU_LINK_LAYER_SPEED_NEGOTIATION_TIMER_VALUES_ ## name, value)
+
+
+#define SCU_LINK_STATUS_DWORD_SYNC_AQUIRED_SHIFT            (2)
+#define SCU_LINK_STATUS_DWORD_SYNC_AQUIRED_MASK             (0x00000004)
+#define SCU_LINK_STATUS_TRANSMIT_PORT_SELECTION_DONE_SHIFT  (4)
+#define SCU_LINK_STATUS_TRANSMIT_PORT_SELECTION_DONE_MASK   (0x00000010)
+#define SCU_LINK_STATUS_RECEIVER_CREDIT_EXHAUSTED_SHIFT     (5)
+#define SCU_LINK_STATUS_RECEIVER_CREDIT_EXHAUSTED_MASK      (0x00000020)
+#define SCU_LINK_STATUS_RESERVED_MASK                       (0xFFFFFFCD)
+
+#define SCU_SAS_LLSTA_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_LINK_STATUS_ ## name)
+
+
+/* TODO: Where is the SATA_PSELTOV register? */
+
+/*
+ * *****************************************************************************
+ * * SCU SAS Maximum Arbitration Wait Time Timeout Register
+ * ***************************************************************************** */
+#define SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_VALUE_SHIFT       (0)
+#define SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_VALUE_MASK        (0x00007FFF)
+#define SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_SCALE_SHIFT       (15)
+#define SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_SCALE_MASK        (0x00008000)
+
+#define SCU_SAS_MAWTTOV_GEN_VALUE(name, value) \
+	SCU_GEN_VALUE(SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_ ## name, value)
+
+#define SCU_SAS_MAWTTOV_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_SAS_MAX_ARBITRATION_WAIT_TIME_TIMEOUT_ ## name)
+
+
+/*
+ * TODO: Where is the SAS_LNKTOV regsiter?
+ * TODO: Where is the SAS_PHYTOV register? */
+
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_SMP_TARGET_SHIFT            (1)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_SMP_TARGET_MASK             (0x00000002)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_STP_TARGET_SHIFT            (2)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_STP_TARGET_MASK             (0x00000004)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_SSP_TARGET_SHIFT            (3)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_SSP_TARGET_MASK             (0x00000008)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_DA_SATA_HOST_SHIFT          (8)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_DA_SATA_HOST_MASK           (0x00000100)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_SMP_INITIATOR_SHIFT         (9)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_SMP_INITIATOR_MASK          (0x00000200)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_STP_INITIATOR_SHIFT         (10)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_STP_INITIATOR_MASK          (0x00000400)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_SSP_INITIATOR_SHIFT         (11)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_SSP_INITIATOR_MASK          (0x00000800)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_REASON_CODE_SHIFT           (16)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_REASON_CODE_MASK            (0x000F0000)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_ADDRESS_FRAME_TYPE_SHIFT    (24)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_ADDRESS_FRAME_TYPE_MASK     (0x0F000000)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_DEVICE_TYPE_SHIFT           (28)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_DEVICE_TYPE_MASK            (0x70000000)
+#define SCU_SAS_TRANSMIT_IDENTIFICATION_RESERVED_MASK               (0x80F0F1F1)
+
+#define SCU_SAS_TIID_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_SAS_TRANSMIT_IDENTIFICATION_ ## name, value)
+
+#define SCU_SAS_TIID_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_SAS_TRANSMIT_IDENTIFICATION_ ## name)
+
+/* SAS Identify Frame PHY Identifier Register */
+#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_BREAK_REPLY_CAPABLE_SHIFT      (16)
+#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_BREAK_REPLY_CAPABLE_MASK       (0x00010000)
+#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_REQUESTED_INSIDE_ZPSDS_SHIFT   (17)
+#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_REQUESTED_INSIDE_ZPSDS_MASK    (0x00020000)
+#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_INSIDE_ZPSDS_PERSISTENT_SHIFT  (18)
+#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_INSIDE_ZPSDS_PERSISTENT_MASK   (0x00040000)
+#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_ID_SHIFT                       (24)
+#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_ID_MASK                        (0xFF000000)
+#define SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_RESERVED_MASK                  (0x00F800FF)
+
+#define SCU_SAS_TIPID_GEN_VALUE(name, value) \
+	SCU_GEN_VALUE(SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_ ## name, value)
+
+#define SCU_SAS_TIPID_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_LINK_LAYER_IDENTIFY_FRAME_PHY_IDENTIFIER_ ## name)
+
+
+#define SCU_SAS_PHY_CONFIGURATION_TX_PARITY_CHECK_SHIFT                     (4)
+#define SCU_SAS_PHY_CONFIGURATION_TX_PARITY_CHECK_MASK                      (0x00000010)
+#define SCU_SAS_PHY_CONFIGURATION_TX_BAD_CRC_SHIFT                          (6)
+#define SCU_SAS_PHY_CONFIGURATION_TX_BAD_CRC_MASK                           (0x00000040)
+#define SCU_SAS_PHY_CONFIGURATION_DISABLE_SCRAMBLER_SHIFT                   (7)
+#define SCU_SAS_PHY_CONFIGURATION_DISABLE_SCRAMBLER_MASK                    (0x00000080)
+#define SCU_SAS_PHY_CONFIGURATION_DISABLE_DESCRAMBLER_SHIFT                 (8)
+#define SCU_SAS_PHY_CONFIGURATION_DISABLE_DESCRAMBLER_MASK                  (0x00000100)
+#define SCU_SAS_PHY_CONFIGURATION_DISABLE_CREDIT_INSERTION_SHIFT            (9)
+#define SCU_SAS_PHY_CONFIGURATION_DISABLE_CREDIT_INSERTION_MASK             (0x00000200)
+#define SCU_SAS_PHY_CONFIGURATION_SUSPEND_PROTOCOL_ENGINE_SHIFT             (11)
+#define SCU_SAS_PHY_CONFIGURATION_SUSPEND_PROTOCOL_ENGINE_MASK              (0x00000800)
+#define SCU_SAS_PHY_CONFIGURATION_SATA_SPINUP_HOLD_SHIFT                    (12)
+#define SCU_SAS_PHY_CONFIGURATION_SATA_SPINUP_HOLD_MASK                     (0x00001000)
+#define SCU_SAS_PHY_CONFIGURATION_TRANSMIT_PORT_SELECTION_SIGNAL_SHIFT      (13)
+#define SCU_SAS_PHY_CONFIGURATION_TRANSMIT_PORT_SELECTION_SIGNAL_MASK       (0x00002000)
+#define SCU_SAS_PHY_CONFIGURATION_HARD_RESET_SHIFT                          (14)
+#define SCU_SAS_PHY_CONFIGURATION_HARD_RESET_MASK                           (0x00004000)
+#define SCU_SAS_PHY_CONFIGURATION_OOB_ENABLE_SHIFT                          (15)
+#define SCU_SAS_PHY_CONFIGURATION_OOB_ENABLE_MASK                           (0x00008000)
+#define SCU_SAS_PHY_CONFIGURATION_ENABLE_FRAME_TX_INSERT_ALIGN_SHIFT        (23)
+#define SCU_SAS_PHY_CONFIGURATION_ENABLE_FRAME_TX_INSERT_ALIGN_MASK         (0x00800000)
+#define SCU_SAS_PHY_CONFIGURATION_FORWARD_IDENTIFY_FRAME_SHIFT              (27)
+#define SCU_SAS_PHY_CONFIGURATION_FORWARD_IDENTIFY_FRAME_MASK               (0x08000000)
+#define SCU_SAS_PHY_CONFIGURATION_DISABLE_BYTE_TRANSPOSE_STP_FRAME_SHIFT    (28)
+#define SCU_SAS_PHY_CONFIGURATION_DISABLE_BYTE_TRANSPOSE_STP_FRAME_MASK     (0x10000000)
+#define SCU_SAS_PHY_CONFIGURATION_OOB_RESET_SHIFT                           (29)
+#define SCU_SAS_PHY_CONFIGURATION_OOB_RESET_MASK                            (0x20000000)
+#define SCU_SAS_PHY_CONFIGURATION_THREE_IAF_ENABLE_SHIFT                    (30)
+#define SCU_SAS_PHY_CONFIGURATION_THREE_IAF_ENABLE_MASK                     (0x40000000)
+#define SCU_SAS_PHY_CONFIGURATION_OOB_ALIGN0_ENABLE_SHIFT                   (31)
+#define SCU_SAS_PHY_CONFIGURATION_OOB_ALIGN0_ENABLE_MASK                    (0x80000000)
+#define SCU_SAS_PHY_CONFIGURATION_REQUIRED_MASK                             (0x0100000F)
+#define SCU_SAS_PHY_CONFIGURATION_DEFAULT_MASK                              (0x4180100F)
+#define SCU_SAS_PHY_CONFIGURATION_RESERVED_MASK                             (0x00000000)
+
+#define SCU_SAS_PCFG_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_SAS_PHY_CONFIGURATION_ ## name)
+
+#define SCU_LINK_LAYER_ALIGN_INSERTION_FREQUENCY_GENERAL_SHIFT      (0)
+#define SCU_LINK_LAYER_ALIGN_INSERTION_FREQUENCY_GENERAL_MASK       (0x000007FF)
+#define SCU_LINK_LAYER_ALIGN_INSERTION_FREQUENCY_CONNECTED_SHIFT    (16)
+#define SCU_LINK_LAYER_ALIGN_INSERTION_FREQUENCY_CONNECTED_MASK     (0x00ff0000)
+
+#define SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_LINK_LAYER_ALIGN_INSERTION_FREQUENCY_##name, value)
+
+#define SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_COUNT_SHIFT    (0)
+#define SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_COUNT_MASK     (0x0003FFFF)
+#define SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_ENABLE_SHIFT   (31)
+#define SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_ENABLE_MASK    (0x80000000)
+#define SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_RESERVED_MASK  (0x7FFC0000)
+
+#define SCU_ENSPINUP_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_ ## name, value)
+
+#define SCU_ENSPINUP_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_LINK_LAYER_ENABLE_SPINUP_CONTROL_ ## name)
+
+
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_TXSSCTYPE_SHIFT     (1)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_TXSSCTYPE_MASK      (0x00000002)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_RLLRATE_SHIFT       (4)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_RLLRATE_MASK        (0x000000F0)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO15GBPS_SHIFT     (8)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO15GBPS_MASK      (0x00000100)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW15GBPS_SHIFT      (9)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW15GBPS_MASK       (0x00000201)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO30GBPS_SHIFT     (10)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO30GBPS_MASK      (0x00000401)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW30GBPS_SHIFT      (11)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW30GBPS_MASK       (0x00000801)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO60GBPS_SHIFT     (12)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SWO60GBPS_MASK      (0x00001001)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW60GBPS_SHIFT      (13)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_SW60GBPS_MASK       (0x00002001)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_EVEN_PARITY_SHIFT   (31)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_EVEN_PARITY_MASK    (0x80000000)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_DEFAULT_MASK        (0x00003F01)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_REQUIRED_MASK       (0x00000001)
+#define SCU_LINK_LAYER_PHY_CAPABILITIES_RESERVED_MASK       (0x7FFFC00D)
+
+#define SCU_SAS_PHYCAP_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_LINK_LAYER_PHY_CAPABILITIES_ ## name, value)
+
+#define SCU_SAS_PHYCAP_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_LINK_LAYER_PHY_CAPABILITIES_ ## name)
+
+
+#define SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_VIRTUAL_EXPANDER_PHY_ZONE_GROUP_SHIFT  (0)
+#define SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_VIRTUAL_EXPANDER_PHY_ZONE_GROUP_MASK   (0x000000FF)
+#define SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_INSIDE_SOURCE_ZONE_GROUP_SHIFT         (31)
+#define SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_INSIDE_SOURCE_ZONE_GROUP_MASK          (0x80000000)
+#define SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_RESERVED_MASK                          (0x7FFFFF00)
+
+#define SCU_PSZGCR_GEN_VAL(name, value)	\
+	SCU_GEN_VALUE(SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_ ## name, value)
+
+#define SCU_PSZGCR_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_LINK_LAYER_PHY_SOURCE_ZONE_GROUP_CONTROL_ ## name)
+
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE0_LOCKED_SHIFT        (1)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE0_LOCKED_MASK         (0x00000002)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE0_UPDATING_SHIFT      (2)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE0_UPDATING_MASK       (0x00000004)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE1_LOCKED_SHIFT        (4)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE1_LOCKED_MASK         (0x00000010)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE1_UPDATING_SHIFT      (5)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZONE1_UPDATING_MASK       (0x00000020)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE0_SHIFT (16)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE0_MASK  (0x00030000)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE0_SHIFT      (19)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE0_MASK       (0x00080000)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE1_SHIFT (20)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE1_MASK  (0x00300000)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE1_SHIFT      (23)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE1_MASK       (0x00800000)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE2_SHIFT (24)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE2_MASK  (0x03000000)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE2_SHIFT      (27)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE2_MASK       (0x08000000)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE3_SHIFT (28)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ZPT_ASSOCIATION_PE3_MASK  (0x30000000)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE3_SHIFT      (31)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_AIP_ENABLE_PE3_MASK       (0x80000000)
+#define SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_RESERVED_MASK             (0x4444FFC9)
+
+#define SCU_PEG_SCUVZECR_GEN_VAL(name, val) \
+	SCU_GEN_VALUE(SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ ## name, val)
+
+#define SCU_PEG_SCUVZECR_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_PROTOCOL_ENGINE_GROUP_VIRTUAL_ZONING_EXPANDER_CONTROL_ ## name)
+
+
+/*
+ * *****************************************************************************
+ * * Port Task Scheduler registers shift and mask values
+ * ***************************************************************************** */
+#define SCU_PTSG_CONTROL_IT_NEXUS_TIMEOUT_SHIFT     (0)
+#define SCU_PTSG_CONTROL_IT_NEXUS_TIMEOUT_MASK      (0x0000FFFF)
+#define SCU_PTSG_CONTROL_TASK_TIMEOUT_SHIFT         (16)
+#define SCU_PTSG_CONTROL_TASK_TIMEOUT_MASK          (0x00FF0000)
+#define SCU_PTSG_CONTROL_PTSG_ENABLE_SHIFT          (24)
+#define SCU_PTSG_CONTROL_PTSG_ENABLE_MASK           (0x01000000)
+#define SCU_PTSG_CONTROL_ETM_ENABLE_SHIFT           (25)
+#define SCU_PTSG_CONTROL_ETM_ENABLE_MASK            (0x02000000)
+#define SCU_PTSG_CONTROL_DEFAULT_MASK               (0x00020002)
+#define SCU_PTSG_CONTROL_REQUIRED_MASK              (0x00000000)
+#define SCU_PTSG_CONTROL_RESERVED_MASK              (0xFC000000)
+
+#define SCU_PTSGCR_GEN_VAL(name, val) \
+	SCU_GEN_VALUE(SCU_PTSG_CONTROL_ ## name, val)
+
+#define SCU_PTSGCR_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_PTSG_CONTROL_ ## name)
+
+
+/* ***************************************************************************** */
+#define SCU_PTSG_REAL_TIME_CLOCK_SHIFT          (0)
+#define SCU_PTSG_REAL_TIME_CLOCK_MASK           (0x0000FFFF)
+#define SCU_PTSG_REAL_TIME_CLOCK_RESERVED_MASK  (0xFFFF0000)
+
+#define SCU_RTCR_GEN_VAL(name, val) \
+	SCU_GEN_VALUE(SCU_PTSG_ ## name, val)
+
+
+#define SCU_PTSG_REAL_TIME_CLOCK_CONTROL_PRESCALER_VALUE_SHIFT  (0)
+#define SCU_PTSG_REAL_TIME_CLOCK_CONTROL_PRESCALER_VALUE_MASK   (0x00FFFFFF)
+#define SCU_PTSG_REAL_TIME_CLOCK_CONTROL_RESERVED_MASK          (0xFF000000)
+
+#define SCU_RTCCR_GEN_VAL(name, val) \
+	SCU_GEN_VALUE(SCU_PTSG_REAL_TIME_CLOCK_CONTROL_ ## name, val)
+
+
+#define SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_SUSPEND_SHIFT  (0)
+#define SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_SUSPEND_MASK   (0x00000001)
+#define SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_ENABLE_SHIFT   (1)
+#define SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_ENABLE_MASK    (0x00000002)
+#define SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_RESERVED_MASK  (0xFFFFFFFC)
+
+#define SCU_PTSxCR_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_PTSG_PORT_TASK_SCHEDULER_CONTROL_ ## name)
+
+
+#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_NEXT_RN_VALID_SHIFT             (0)
+#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_NEXT_RN_VALID_MASK              (0x00000001)
+#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_ACTIVE_RNSC_LIST_VALID_SHIFT    (1)
+#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_ACTIVE_RNSC_LIST_VALID_MASK     (0x00000002)
+#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_PTS_SUSPENDED_SHIFT             (2)
+#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_PTS_SUSPENDED_MASK              (0x00000004)
+#define SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_RESERVED_MASK                   (0xFFFFFFF8)
+
+#define SCU_PTSxSR_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_PTSG_PORT_TASK_SCHEDULER_STATUS_ ## name)
+
+
+/*
+ * *****************************************************************************
+ * * SGPIO Register shift and mask values
+ * ***************************************************************************** */
+#define SCU_SGPIO_CONTROL_SGPIO_ENABLE_SHIFT                    (0)
+#define SCU_SGPIO_CONTROL_SGPIO_ENABLE_MASK                     (0x00000001)
+#define SCU_SGPIO_CONTROL_SGPIO_SERIAL_CLOCK_SELECT_SHIFT       (1)
+#define SCU_SGPIO_CONTROL_SGPIO_SERIAL_CLOCK_SELECT_MASK        (0x00000002)
+#define SCU_SGPIO_CONTROL_SGPIO_SERIAL_SHIFT_WIDTH_SELECT_SHIFT (2)
+#define SCU_SGPIO_CONTROL_SGPIO_SERIAL_SHIFT_WIDTH_SELECT_MASK  (0x00000004)
+#define SCU_SGPIO_CONTROL_SGPIO_TEST_BIT_SHIFT                  (15)
+#define SCU_SGPIO_CONTROL_SGPIO_TEST_BIT_MASK                   (0x00008000)
+#define SCU_SGPIO_CONTROL_SGPIO_RESERVED_MASK                   (0xFFFF7FF8)
+
+#define SCU_SGICRx_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_SGPIO_CONTROL_SGPIO_ ## name)
+
+#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R0_SHIFT      (0)
+#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R0_MASK       (0x0000000F)
+#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R1_SHIFT      (4)
+#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R1_MASK       (0x000000F0)
+#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R2_SHIFT      (8)
+#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R2_MASK       (0x00000F00)
+#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R3_SHIFT      (12)
+#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_R3_MASK       (0x0000F000)
+#define SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_RESERVED_MASK (0xFFFF0000)
+
+#define SCU_SGPBRx_GEN_VAL(name, value)	\
+	SCU_GEN_VALUE(SCU_SGPIO_PROGRAMMABLE_BLINK_REGISTER_ ## name, value)
+
+#define SCU_SGPIO_START_DRIVE_LOWER_R0_SHIFT        (0)
+#define SCU_SGPIO_START_DRIVE_LOWER_R0_MASK         (0x00000003)
+#define SCU_SGPIO_START_DRIVE_LOWER_R1_SHIFT        (4)
+#define SCU_SGPIO_START_DRIVE_LOWER_R1_MASK         (0x00000030)
+#define SCU_SGPIO_START_DRIVE_LOWER_R2_SHIFT        (8)
+#define SCU_SGPIO_START_DRIVE_LOWER_R2_MASK         (0x00000300)
+#define SCU_SGPIO_START_DRIVE_LOWER_R3_SHIFT        (12)
+#define SCU_SGPIO_START_DRIVE_LOWER_R3_MASK         (0x00003000)
+#define SCU_SGPIO_START_DRIVE_LOWER_RESERVED_MASK   (0xFFFF8888)
+
+#define SCU_SGSDLRx_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_SGPIO_START_DRIVE_LOWER_ ## name, value)
+
+#define SCU_SGPIO_START_DRIVE_UPPER_R0_SHIFT        (0)
+#define SCU_SGPIO_START_DRIVE_UPPER_R0_MASK         (0x00000003)
+#define SCU_SGPIO_START_DRIVE_UPPER_R1_SHIFT        (4)
+#define SCU_SGPIO_START_DRIVE_UPPER_R1_MASK         (0x00000030)
+#define SCU_SGPIO_START_DRIVE_UPPER_R2_SHIFT        (8)
+#define SCU_SGPIO_START_DRIVE_UPPER_R2_MASK         (0x00000300)
+#define SCU_SGPIO_START_DRIVE_UPPER_R3_SHIFT        (12)
+#define SCU_SGPIO_START_DRIVE_UPPER_R3_MASK         (0x00003000)
+#define SCU_SGPIO_START_DRIVE_UPPER_RESERVED_MASK   (0xFFFF8888)
+
+#define SCU_SGSDURx_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_SGPIO_START_DRIVE_LOWER_ ## name, value)
+
+#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D0_SHIFT      (0)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D0_MASK       (0x00000003)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D1_SHIFT      (4)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D1_MASK       (0x00000030)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D2_SHIFT      (8)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D2_MASK       (0x00000300)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D3_SHIFT      (12)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_D3_MASK       (0x00003000)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_RESERVED_MASK (0xFFFF8888)
+
+#define SCU_SGSIDLRx_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_ ## name, value)
+
+#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D0_SHIFT      (0)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D0_MASK       (0x00000003)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D1_SHIFT      (4)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D1_MASK       (0x00000030)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D2_SHIFT      (8)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D2_MASK       (0x00000300)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D3_SHIFT      (12)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_D3_MASK       (0x00003000)
+#define SCU_SGPIO_SERIAL_INPUT_DATA_UPPER_RESERVED_MASK (0xFFFF8888)
+
+#define SCU_SGSIDURx_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_SGPIO_SERIAL_INPUT_DATA_LOWER_ ## name, value)
+
+#define SCU_SGPIO_VENDOR_SPECIFIC_CODE_SHIFT            (0)
+#define SCU_SGPIO_VENDOR_SPECIFIC_CODE_MASK             (0x0000000F)
+#define SCU_SGPIO_VENDOR_SPECIFIC_CODE_RESERVED_MASK    (0xFFFFFFF0)
+
+#define SCU_SGVSCR_GEN_VAL(value) \
+	SCU_GEN_VALUE(SCU_SGPIO_VENDOR_SPECIFIC_CODE ## name, value)
+
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA0_SHIFT           (0)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA0_MASK            (0x00000003)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA0_SHIFT    (2)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA0_MASK     (0x00000004)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA0_SHIFT      (3)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA0_MASK       (0x00000008)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA1_SHIFT           (4)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA1_MASK            (0x00000030)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA1_SHIFT    (6)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA1_MASK     (0x00000040)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA1_SHIFT      (7)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA1_MASK       (0x00000080)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA2_SHIFT           (8)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INPUT_DATA2_MASK            (0x00000300)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA2_SHIFT    (10)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_INVERT_INPUT_DATA2_MASK     (0x00000400)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA2_SHIFT      (11)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_JOG_ENABLE_DATA2_MASK       (0x00000800)
+#define SCU_SGPIO_OUPUT_DATA_SELECT_RESERVED_MASK               (0xFFFFF000)
+
+#define SCU_SGODSR_GEN_VAL(name, value)	\
+	SCU_GEN_VALUE(SCU_SGPIO_OUPUT_DATA_SELECT_ ## name, value)
+
+#define SCU_SGODSR_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_SGPIO_OUPUT_DATA_SELECT_ ## name)
+
+/*
+ * *****************************************************************************
+ * * SMU Registers
+ * ***************************************************************************** */
+
+/*
+ * ----------------------------------------------------------------------------
+ * SMU Registers
+ * These registers are based off of BAR0
+ *
+ * To calculate the offset for other functions use
+ *       BAR0 + FN# * SystemPageSize * 2
+ *
+ * The TCA is only accessable from FN#0 (Physical Function) and each
+ * is programmed by (BAR0 + SCU_SMU_TCA_OFFSET + (FN# * 0x04)) or
+ *    TCA0 for FN#0 is at BAR0 + 0x0400
+ *    TCA1 for FN#1 is at BAR0 + 0x0404
+ *    etc.
+ * ----------------------------------------------------------------------------
+ * Accessable to all FN#s */
+#define SCU_SMU_PCP_OFFSET          0x0000
+#define SCU_SMU_AMR_OFFSET          0x0004
+#define SCU_SMU_ISR_OFFSET          0x0010
+#define SCU_SMU_IMR_OFFSET          0x0014
+#define SCU_SMU_ICC_OFFSET          0x0018
+#define SCU_SMU_HTTLBAR_OFFSET      0x0020
+#define SCU_SMU_HTTUBAR_OFFSET      0x0024
+#define SCU_SMU_TCR_OFFSET          0x0028
+#define SCU_SMU_CQLBAR_OFFSET       0x0030
+#define SCU_SMU_CQUBAR_OFFSET       0x0034
+#define SCU_SMU_CQPR_OFFSET         0x0040
+#define SCU_SMU_CQGR_OFFSET         0x0044
+#define SCU_SMU_CQC_OFFSET          0x0048
+/* Accessable to FN#0 only */
+#define SCU_SMU_RNCLBAR_OFFSET      0x0080
+#define SCU_SMU_RNCUBAR_OFFSET      0x0084
+#define SCU_SMU_DCC_OFFSET          0x0090
+#define SCU_SMU_DFC_OFFSET          0x0094
+#define SCU_SMU_SMUCSR_OFFSET       0x0098
+#define SCU_SMU_SCUSRCR_OFFSET      0x009C
+#define SCU_SMU_SMAW_OFFSET         0x00A0
+#define SCU_SMU_SMDW_OFFSET         0x00A4
+/* Accessable to FN#0 only */
+#define SCU_SMU_TCA_OFFSET          0x0400
+/* Accessable to all FN#s */
+#define SCU_SMU_MT_MLAR0_OFFSET     0x2000
+#define SCU_SMU_MT_MUAR0_OFFSET     0x2004
+#define SCU_SMU_MT_MDR0_OFFSET      0x2008
+#define SCU_SMU_MT_VCR0_OFFSET      0x200C
+#define SCU_SMU_MT_MLAR1_OFFSET     0x2010
+#define SCU_SMU_MT_MUAR1_OFFSET     0x2014
+#define SCU_SMU_MT_MDR1_OFFSET      0x2018
+#define SCU_SMU_MT_VCR1_OFFSET      0x201C
+#define SCU_SMU_MPBA_OFFSET         0x3000
+
+/**
+ * struct smu_registers - These are the SMU registers
+ *
+ *
+ */
+struct smu_registers {
+/* 0x0000 PCP */
+	u32 post_context_port;
+/* 0x0004 AMR */
+	u32 address_modifier;
+	u32 reserved_08;
+	u32 reserved_0C;
+/* 0x0010 ISR */
+	u32 interrupt_status;
+/* 0x0014 IMR */
+	u32 interrupt_mask;
+/* 0x0018 ICC */
+	u32 interrupt_coalesce_control;
+	u32 reserved_1C;
+/* 0x0020 HTTLBAR */
+	u32 host_task_table_lower;
+/* 0x0024 HTTUBAR */
+	u32 host_task_table_upper;
+/* 0x0028 TCR */
+	u32 task_context_range;
+	u32 reserved_2C;
+/* 0x0030 CQLBAR */
+	u32 completion_queue_lower;
+/* 0x0034 CQUBAR */
+	u32 completion_queue_upper;
+	u32 reserved_38;
+	u32 reserved_3C;
+/* 0x0040 CQPR */
+	u32 completion_queue_put;
+/* 0x0044 CQGR */
+	u32 completion_queue_get;
+/* 0x0048 CQC */
+	u32 completion_queue_control;
+	u32 reserved_4C;
+	u32 reserved_5x[4];
+	u32 reserved_6x[4];
+	u32 reserved_7x[4];
+/*
+ * Accessable to FN#0 only
+ * 0x0080 RNCLBAR */
+	u32 remote_node_context_lower;
+/* 0x0084 RNCUBAR */
+	u32 remote_node_context_upper;
+	u32 reserved_88;
+	u32 reserved_8C;
+/* 0x0090 DCC */
+	u32 device_context_capacity;
+/* 0x0094 DFC */
+	u32 device_function_capacity;
+/* 0x0098 SMUCSR */
+	u32 control_status;
+/* 0x009C SCUSRCR */
+	u32 soft_reset_control;
+/* 0x00A0 SMAW */
+	u32 mmr_address_window;
+/* 0x00A4 SMDW */
+	u32 mmr_data_window;
+	u32 reserved_A8;
+	u32 reserved_AC;
+/* A whole bunch of reserved space */
+	u32 reserved_Bx[4];
+	u32 reserved_Cx[4];
+	u32 reserved_Dx[4];
+	u32 reserved_Ex[4];
+	u32 reserved_Fx[4];
+	u32 reserved_1xx[64];
+	u32 reserved_2xx[64];
+	u32 reserved_3xx[64];
+/*
+ * Accessable to FN#0 only
+ * 0x0400 TCA */
+	u32 task_context_assignment[256];
+/* MSI-X registers not included */
+};
+
+/*
+ * *****************************************************************************
+ * SDMA Registers
+ * ***************************************************************************** */
+#define SCU_SDMA_BASE               0x6000
+#define SCU_SDMA_PUFATLHAR_OFFSET   0x0000
+#define SCU_SDMA_PUFATUHAR_OFFSET   0x0004
+#define SCU_SDMA_UFLHBAR_OFFSET     0x0008
+#define SCU_SDMA_UFUHBAR_OFFSET     0x000C
+#define SCU_SDMA_UFQC_OFFSET        0x0010
+#define SCU_SDMA_UFQPP_OFFSET       0x0014
+#define SCU_SDMA_UFQGP_OFFSET       0x0018
+#define SCU_SDMA_PDMACR_OFFSET      0x001C
+#define SCU_SDMA_CDMACR_OFFSET      0x0080
+
+/**
+ * struct scu_sdma_registers - These are the SCU SDMA Registers
+ *
+ *
+ */
+struct scu_sdma_registers {
+/* 0x0000 PUFATLHAR */
+	u32 uf_address_table_lower;
+/* 0x0004 PUFATUHAR */
+	u32 uf_address_table_upper;
+/* 0x0008 UFLHBAR */
+	u32 uf_header_base_address_lower;
+/* 0x000C UFUHBAR */
+	u32 uf_header_base_address_upper;
+/* 0x0010 UFQC */
+	u32 unsolicited_frame_queue_control;
+/* 0x0014 UFQPP */
+	u32 unsolicited_frame_put_pointer;
+/* 0x0018 UFQGP */
+	u32 unsolicited_frame_get_pointer;
+/* 0x001C PDMACR */
+	u32 pdma_configuration;
+/* Reserved until offset 0x80 */
+	u32 reserved_0020_007C[0x18];
+/* 0x0080 CDMACR */
+	u32 cdma_configuration;
+/* Remainder SDMA register space */
+	u32 reserved_0084_0400[0xDF];
+
+};
+
+/*
+ * *****************************************************************************
+ * * SCU Link Registers
+ * ***************************************************************************** */
+#define SCU_PEG0_OFFSET    0x0000
+#define SCU_PEG1_OFFSET    0x8000
+
+#define SCU_TL0_OFFSET     0x0000
+#define SCU_TL1_OFFSET     0x0400
+#define SCU_TL2_OFFSET     0x0800
+#define SCU_TL3_OFFSET     0x0C00
+
+#define SCU_LL_OFFSET      0x0080
+#define SCU_LL0_OFFSET     (SCU_TL0_OFFSET + SCU_LL_OFFSET)
+#define SCU_LL1_OFFSET     (SCU_TL1_OFFSET + SCU_LL_OFFSET)
+#define SCU_LL2_OFFSET     (SCU_TL2_OFFSET + SCU_LL_OFFSET)
+#define SCU_LL3_OFFSET     (SCU_TL3_OFFSET + SCU_LL_OFFSET)
+
+/* Transport Layer Offsets (PEG + TL) */
+#define SCU_TLCR_OFFSET         0x0000
+#define SCU_TLADTR_OFFSET       0x0004
+#define SCU_TLTTMR_OFFSET       0x0008
+#define SCU_TLEECR0_OFFSET      0x000C
+#define SCU_STPTLDARNI_OFFSET   0x0010
+
+
+#define SCU_TLCR_HASH_SAS_CHECKING_ENABLE_SHIFT    (0)
+#define SCU_TLCR_HASH_SAS_CHECKING_ENABLE_MASK     (0x00000001)
+#define SCU_TLCR_CLEAR_TCI_NCQ_MAPPING_TABLE_SHIFT (1)
+#define SCU_TLCR_CLEAR_TCI_NCQ_MAPPING_TABLE_MASK  (0x00000002)
+#define SCU_TLCR_STP_WRITE_DATA_PREFETCH_SHIFT     (3)
+#define SCU_TLCR_STP_WRITE_DATA_PREFETCH_MASK      (0x00000008)
+#define SCU_TLCR_CMD_NAK_STATUS_CODE_SHIFT         (4)
+#define SCU_TLCR_CMD_NAK_STATUS_CODE_MASK          (0x00000010)
+#define SCU_TLCR_RESERVED_MASK                     (0xFFFFFFEB)
+
+#define SCU_TLCR_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_TLCR_ ## name)
+
+/**
+ * struct scu_transport_layer_registers - These are the SCU Transport Layer
+ *    registers
+ *
+ *
+ */
+struct scu_transport_layer_registers {
+	/* 0x0000 TLCR */
+	u32 control;
+	/* 0x0004 TLADTR */
+	u32 arbitration_delay_timer;
+	/* 0x0008 TLTTMR */
+	u32 timer_test_mode;
+	/* 0x000C reserved */
+	u32 reserved_0C;
+	/* 0x0010 STPTLDARNI */
+	u32 stp_rni;
+	/* 0x0014 TLFEWPORCTRL */
+	u32 tlfe_wpo_read_control;
+	/* 0x0018 TLFEWPORDATA */
+	u32 tlfe_wpo_read_data;
+	/* 0x001C RXTLSSCSR1 */
+	u32 rxtl_single_step_control_status_1;
+	/* 0x0020 RXTLSSCSR2 */
+	u32 rxtl_single_step_control_status_2;
+	/* 0x0024 AWTRDDCR */
+	u32 tlfe_awt_retry_delay_debug_control;
+	/* Remainder of TL memory space */
+	u32 reserved_0028_007F[0x16];
+
+};
+
+/* Protocol Engine Group Registers */
+#define SCU_SCUVZECRx_OFFSET        0x1080
+
+/* Link Layer Offsets (PEG + TL + LL) */
+#define SCU_SAS_SPDTOV_OFFSET       0x0000
+#define SCU_SAS_LLSTA_OFFSET        0x0004
+#define SCU_SATA_PSELTOV_OFFSET     0x0008
+#define SCU_SAS_TIMETOV_OFFSET      0x0010
+#define SCU_SAS_LOSTOT_OFFSET       0x0014
+#define SCU_SAS_LNKTOV_OFFSET       0x0018
+#define SCU_SAS_PHYTOV_OFFSET       0x001C
+#define SCU_SAS_AFERCNT_OFFSET      0x0020
+#define SCU_SAS_WERCNT_OFFSET       0x0024
+#define SCU_SAS_TIID_OFFSET         0x0028
+#define SCU_SAS_TIDNH_OFFSET        0x002C
+#define SCU_SAS_TIDNL_OFFSET        0x0030
+#define SCU_SAS_TISSAH_OFFSET       0x0034
+#define SCU_SAS_TISSAL_OFFSET       0x0038
+#define SCU_SAS_TIPID_OFFSET        0x003C
+#define SCU_SAS_TIRES2_OFFSET       0x0040
+#define SCU_SAS_ADRSTA_OFFSET       0x0044
+#define SCU_SAS_MAWTTOV_OFFSET      0x0048
+#define SCU_SAS_FRPLDFIL_OFFSET     0x0054
+#define SCU_SAS_RFCNT_OFFSET        0x0060
+#define SCU_SAS_TFCNT_OFFSET        0x0064
+#define SCU_SAS_RFDCNT_OFFSET       0x0068
+#define SCU_SAS_TFDCNT_OFFSET       0x006C
+#define SCU_SAS_LERCNT_OFFSET       0x0070
+#define SCU_SAS_RDISERRCNT_OFFSET   0x0074
+#define SCU_SAS_CRERCNT_OFFSET      0x0078
+#define SCU_STPCTL_OFFSET           0x007C
+#define SCU_SAS_PCFG_OFFSET         0x0080
+#define SCU_SAS_CLKSM_OFFSET        0x0084
+#define SCU_SAS_TXCOMWAKE_OFFSET    0x0088
+#define SCU_SAS_TXCOMINIT_OFFSET    0x008C
+#define SCU_SAS_TXCOMSAS_OFFSET     0x0090
+#define SCU_SAS_COMINIT_OFFSET      0x0094
+#define SCU_SAS_COMWAKE_OFFSET      0x0098
+#define SCU_SAS_COMSAS_OFFSET       0x009C
+#define SCU_SAS_SFERCNT_OFFSET      0x00A0
+#define SCU_SAS_CDFERCNT_OFFSET     0x00A4
+#define SCU_SAS_DNFERCNT_OFFSET     0x00A8
+#define SCU_SAS_PRSTERCNT_OFFSET    0x00AC
+#define SCU_SAS_CNTCTL_OFFSET       0x00B0
+#define SCU_SAS_SSPTOV_OFFSET       0x00B4
+#define SCU_FTCTL_OFFSET            0x00B8
+#define SCU_FRCTL_OFFSET            0x00BC
+#define SCU_FTWMRK_OFFSET           0x00C0
+#define SCU_ENSPINUP_OFFSET         0x00C4
+#define SCU_SAS_TRNTOV_OFFSET       0x00C8
+#define SCU_SAS_PHYCAP_OFFSET       0x00CC
+#define SCU_SAS_PHYCTL_OFFSET       0x00D0
+#define SCU_SAS_LLCTL_OFFSET        0x00D8
+#define SCU_AFE_XCVRCR_OFFSET       0x00DC
+#define SCU_AFE_LUTCR_OFFSET        0x00E0
+
+#define SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_SHIFT                  (0)
+#define SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_MASK                   (0x00000003)
+#define SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN1                   (0)
+#define SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN2                   (1)
+#define SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN3                   (2)
+#define SCU_SAS_LINK_LAYER_CONTROL_BROADCAST_PRIMITIVE_SHIFT            (2)
+#define SCU_SAS_LINK_LAYER_CONTROL_BROADCAST_PRIMITIVE_MASK             (0x000003FC)
+#define SCU_SAS_LINK_LAYER_CONTROL_CLOSE_NO_ACTIVE_TASK_DISABLE_SHIFT   (16)
+#define SCU_SAS_LINK_LAYER_CONTROL_CLOSE_NO_ACTIVE_TASK_DISABLE_MASK    (0x00010000)
+#define SCU_SAS_LINK_LAYER_CONTROL_CLOSE_NO_OUTBOUND_TASK_DISABLE_SHIFT (17)
+#define SCU_SAS_LINK_LAYER_CONTROL_CLOSE_NO_OUTBOUND_TASK_DISABLE_MASK  (0x00020000)
+#define SCU_SAS_LINK_LAYER_CONTROL_NO_OUTBOUND_TASK_TIMEOUT_SHIFT       (24)
+#define SCU_SAS_LINK_LAYER_CONTROL_NO_OUTBOUND_TASK_TIMEOUT_MASK        (0xFF000000)
+#define SCU_SAS_LINK_LAYER_CONTROL_RESERVED                             (0x00FCFC00)
+
+#define SCU_SAS_LLCTL_GEN_VAL(name, value) \
+	SCU_GEN_VALUE(SCU_SAS_LINK_LAYER_CONTROL_ ## name, value)
+
+#define SCU_SAS_LLCTL_GEN_BIT(name) \
+	SCU_GEN_BIT(SCU_SAS_LINK_LAYER_CONTROL_ ## name)
+
+
+/* #define SCU_FRXHECR_DCNT_OFFSET      0x00B0 */
+#define SCU_PSZGCR_OFFSET           0x00E4
+#define SCU_SAS_RECPHYCAP_OFFSET    0x00E8
+/* #define SCU_TX_LUTSEL_OFFSET         0x00B8 */
+
+#define SCU_SAS_PTxC_OFFSET         0x00D4 /* Same offset as SAS_TCTSTM */
+
+/**
+ * struct scu_link_layer_registers - SCU Link Layer Registers
+ *
+ *
+ */
+struct scu_link_layer_registers {
+/* 0x0000 SAS_SPDTOV */
+	u32 speed_negotiation_timers;
+/* 0x0004 SAS_LLSTA */
+	u32 link_layer_status;
+/* 0x0008 SATA_PSELTOV */
+	u32 port_selector_timeout;
+	u32 reserved0C;
+/* 0x0010 SAS_TIMETOV */
+	u32 timeout_unit_value;
+/* 0x0014 SAS_RCDTOV */
+	u32 rcd_timeout;
+/* 0x0018 SAS_LNKTOV */
+	u32 link_timer_timeouts;
+/* 0x001C SAS_PHYTOV */
+	u32 sas_phy_timeouts;
+/* 0x0020 SAS_AFERCNT */
+	u32 received_address_frame_error_counter;
+/* 0x0024 SAS_WERCNT */
+	u32 invalid_dword_counter;
+/* 0x0028 SAS_TIID */
+	u32 transmit_identification;
+/* 0x002C SAS_TIDNH */
+	u32 sas_device_name_high;
+/* 0x0030 SAS_TIDNL */
+	u32 sas_device_name_low;
+/* 0x0034 SAS_TISSAH */
+	u32 source_sas_address_high;
+/* 0x0038 SAS_TISSAL */
+	u32 source_sas_address_low;
+/* 0x003C SAS_TIPID */
+	u32 identify_frame_phy_id;
+/* 0x0040 SAS_TIRES2 */
+	u32 identify_frame_reserved;
+/* 0x0044 SAS_ADRSTA */
+	u32 received_address_frame;
+/* 0x0048 SAS_MAWTTOV */
+	u32 maximum_arbitration_wait_timer_timeout;
+/* 0x004C SAS_PTxC */
+	u32 transmit_primitive;
+/* 0x0050 SAS_RORES */
+	u32 error_counter_event_notification_control;
+/* 0x0054 SAS_FRPLDFIL */
+	u32 frxq_payload_fill_threshold;
+/* 0x0058 SAS_LLHANG_TOT */
+	u32 link_layer_hang_detection_timeout;
+	u32 reserved_5C;
+/* 0x0060 SAS_RFCNT */
+	u32 received_frame_count;
+/* 0x0064 SAS_TFCNT */
+	u32 transmit_frame_count;
+/* 0x0068 SAS_RFDCNT */
+	u32 received_dword_count;
+/* 0x006C SAS_TFDCNT */
+	u32 transmit_dword_count;
+/* 0x0070 SAS_LERCNT */
+	u32 loss_of_sync_error_count;
+/* 0x0074 SAS_RDISERRCNT */
+	u32 running_disparity_error_count;
+/* 0x0078 SAS_CRERCNT */
+	u32 received_frame_crc_error_count;
+/* 0x007C STPCTL */
+	u32 stp_control;
+/* 0x0080 SAS_PCFG */
+	u32 phy_configuration;
+/* 0x0084 SAS_CLKSM */
+	u32 clock_skew_management;
+/* 0x0088 SAS_TXCOMWAKE */
+	u32 transmit_comwake_signal;
+/* 0x008C SAS_TXCOMINIT */
+	u32 transmit_cominit_signal;
+/* 0x0090 SAS_TXCOMSAS */
+	u32 transmit_comsas_signal;
+/* 0x0094 SAS_COMINIT */
+	u32 cominit_control;
+/* 0x0098 SAS_COMWAKE */
+	u32 comwake_control;
+/* 0x009C SAS_COMSAS */
+	u32 comsas_control;
+/* 0x00A0 SAS_SFERCNT */
+	u32 received_short_frame_count;
+/* 0x00A4 SAS_CDFERCNT */
+	u32 received_frame_without_credit_count;
+/* 0x00A8 SAS_DNFERCNT */
+	u32 received_frame_after_done_count;
+/* 0x00AC SAS_PRSTERCNT */
+	u32 phy_reset_problem_count;
+/* 0x00B0 SAS_CNTCTL */
+	u32 counter_control;
+/* 0x00B4 SAS_SSPTOV */
+	u32 ssp_timer_timeout_values;
+/* 0x00B8 FTCTL */
+	u32 ftx_control;
+/* 0x00BC FRCTL */
+	u32 frx_control;
+/* 0x00C0 FTWMRK */
+	u32 ftx_watermark;
+/* 0x00C4 ENSPINUP */
+	u32 notify_enable_spinup_control;
+/* 0x00C8 SAS_TRNTOV */
+	u32 sas_training_sequence_timer_values;
+/* 0x00CC SAS_PHYCAP */
+	u32 phy_capabilities;
+/* 0x00D0 SAS_PHYCTL */
+	u32 phy_control;
+	u32 reserved_d4;
+/* 0x00D8 LLCTL */
+	u32 link_layer_control;
+/* 0x00DC AFE_XCVRCR */
+	u32 afe_xcvr_control;
+/* 0x00E0 AFE_LUTCR */
+	u32 afe_lookup_table_control;
+/* 0x00E4 PSZGCR */
+	u32 phy_source_zone_group_control;
+/* 0x00E8 SAS_RECPHYCAP */
+	u32 receive_phycap;
+	u32 reserved_ec;
+/* 0x00F0 SNAFERXRSTCTL */
+	u32 speed_negotiation_afe_rx_reset_control;
+/* 0x00F4 SAS_SSIPMCTL */
+	u32 power_management_control;
+/* 0x00F8 SAS_PSPREQ_PRIM */
+	u32 sas_pm_partial_request_primitive;
+/* 0x00FC SAS_PSSREQ_PRIM */
+	u32 sas_pm_slumber_request_primitive;
+/* 0x0100 SAS_PPSACK_PRIM */
+	u32 sas_pm_ack_primitive_register;
+/* 0x0104 SAS_PSNAK_PRIM */
+	u32 sas_pm_nak_primitive_register;
+/* 0x0108 SAS_SSIPMTOV */
+	u32 sas_primitive_timeout;
+	u32 reserved_10c;
+/* 0x0110 - 0x011C PLAPRDCTRLxREG */
+	u32 pla_product_control[4];
+/* 0x0120 PLAPRDSUMREG */
+	u32 pla_product_sum;
+/* 0x0124 PLACONTROLREG */
+	u32 pla_control;
+/* Remainder of memory space 896 bytes */
+	u32 reserved_0128_037f[0x96];
+
+};
+
+/*
+ * 0x00D4 // Same offset as SAS_TCTSTM SAS_PTxC
+ *   u32   primitive_transmit_control; */
+
+/*
+ * ----------------------------------------------------------------------------
+ * SGPIO
+ * ---------------------------------------------------------------------------- */
+#define SCU_SGPIO_OFFSET         0x1400
+
+/* #define SCU_SGPIO_OFFSET         0x6000   // later moves to 0x1400 see HSD 652625 */
+#define SCU_SGPIO_SGICR_OFFSET   0x0000
+#define SCU_SGPIO_SGPBR_OFFSET   0x0004
+#define SCU_SGPIO_SGSDLR_OFFSET  0x0008
+#define SCU_SGPIO_SGSDUR_OFFSET  0x000C
+#define SCU_SGPIO_SGSIDLR_OFFSET 0x0010
+#define SCU_SGPIO_SGSIDUR_OFFSET 0x0014
+#define SCU_SGPIO_SGVSCR_OFFSET  0x0018
+/* Address from 0x0820 to 0x083C */
+#define SCU_SGPIO_SGODSR_OFFSET  0x0020
+
+/**
+ * struct scu_sgpio_registers - SCU SGPIO Registers
+ *
+ *
+ */
+struct scu_sgpio_registers {
+/* 0x0000 SGPIO_SGICR */
+	u32 interface_control;
+/* 0x0004 SGPIO_SGPBR */
+	u32 blink_rate;
+/* 0x0008 SGPIO_SGSDLR */
+	u32 start_drive_lower;
+/* 0x000C SGPIO_SGSDUR */
+	u32 start_drive_upper;
+/* 0x0010 SGPIO_SGSIDLR */
+	u32 serial_input_lower;
+/* 0x0014 SGPIO_SGSIDUR */
+	u32 serial_input_upper;
+/* 0x0018 SGPIO_SGVSCR */
+	u32 vendor_specific_code;
+/* 0x0020 SGPIO_SGODSR */
+	u32 ouput_data_select[8];
+/* Remainder of memory space 256 bytes */
+	u32 reserved_1444_14ff[0x31];
+
+};
+
+/*
+ * *****************************************************************************
+ * * Defines for VIIT entry offsets
+ * * Access additional entries by SCU_VIIT_BASE + index * 0x10
+ * ***************************************************************************** */
+#define     SCU_VIIT_BASE     0x1c00
+
+struct scu_viit_registers {
+	u32 registers[256];
+};
+
+/*
+ * *****************************************************************************
+ * * SCU PORT TASK SCHEDULER REGISTERS
+ * ***************************************************************************** */
+
+#define SCU_PTSG_BASE               0x1000
+
+#define SCU_PTSG_PTSGCR_OFFSET      0x0000
+#define SCU_PTSG_RTCR_OFFSET        0x0004
+#define SCU_PTSG_RTCCR_OFFSET       0x0008
+#define SCU_PTSG_PTS0CR_OFFSET      0x0010
+#define SCU_PTSG_PTS0SR_OFFSET      0x0014
+#define SCU_PTSG_PTS1CR_OFFSET      0x0018
+#define SCU_PTSG_PTS1SR_OFFSET      0x001C
+#define SCU_PTSG_PTS2CR_OFFSET      0x0020
+#define SCU_PTSG_PTS2SR_OFFSET      0x0024
+#define SCU_PTSG_PTS3CR_OFFSET      0x0028
+#define SCU_PTSG_PTS3SR_OFFSET      0x002C
+#define SCU_PTSG_PCSPE0CR_OFFSET    0x0030
+#define SCU_PTSG_PCSPE1CR_OFFSET    0x0034
+#define SCU_PTSG_PCSPE2CR_OFFSET    0x0038
+#define SCU_PTSG_PCSPE3CR_OFFSET    0x003C
+#define SCU_PTSG_ETMTSCCR_OFFSET    0x0040
+#define SCU_PTSG_ETMRNSCCR_OFFSET   0x0044
+
+/**
+ * struct scu_port_task_scheduler_registers - These are the control/stats pairs
+ *    for each Port Task Scheduler.
+ *
+ *
+ */
+struct scu_port_task_scheduler_registers {
+	u32 control;
+	u32 status;
+};
+
+/**
+ * struct scu_port_task_scheduler_group_registers - These are the PORT Task
+ *    Scheduler registers
+ *
+ *
+ */
+struct scu_port_task_scheduler_group_registers {
+/* 0x0000 PTSGCR */
+	u32 control;
+/* 0x0004 RTCR */
+	u32 real_time_clock;
+/* 0x0008 RTCCR */
+	u32 real_time_clock_control;
+/* 0x000C */
+	u32 reserved_0C;
+/*
+ * 0x0010 PTS0CR
+ * 0x0014 PTS0SR
+ * 0x0018 PTS1CR
+ * 0x001C PTS1SR
+ * 0x0020 PTS2CR
+ * 0x0024 PTS2SR
+ * 0x0028 PTS3CR
+ * 0x002C PTS3SR */
+	struct scu_port_task_scheduler_registers port[4];
+/*
+ * 0x0030 PCSPE0CR
+ * 0x0034 PCSPE1CR
+ * 0x0038 PCSPE2CR
+ * 0x003C PCSPE3CR */
+	u32 protocol_engine[4];
+/* 0x0040 ETMTSCCR */
+	u32 tc_scanning_interval_control;
+/* 0x0044 ETMRNSCCR */
+	u32 rnc_scanning_interval_control;
+/* Remainder of memory space 128 bytes */
+	u32 reserved_1048_107f[0x0E];
+
+};
+
+#define SCU_PTSG_SCUVZECR_OFFSET        0x003C
+
+/*
+ * *****************************************************************************
+ * * AFE REGISTERS
+ * ***************************************************************************** */
+#define SCU_AFE_MMR_BASE                  0xE000
+
+/*
+ * AFE 0 is at offset 0x0800
+ * AFE 1 is at offset 0x0900
+ * AFE 2 is at offset 0x0a00
+ * AFE 3 is at offset 0x0b00 */
+struct scu_afe_transceiver {
+	/* 0x0000 AFE_XCVR_CTRL0 */
+	u32 afe_xcvr_control0;
+	/* 0x0004 AFE_XCVR_CTRL1 */
+	u32 afe_xcvr_control1;
+	/* 0x0008 */
+	u32 reserved_0008;
+	/* 0x000c afe_dfx_rx_control0 */
+	u32 afe_dfx_rx_control0;
+	/* 0x0010 AFE_DFX_RX_CTRL1 */
+	u32 afe_dfx_rx_control1;
+	/* 0x0014 */
+	u32 reserved_0014;
+	/* 0x0018 AFE_DFX_RX_STS0 */
+	u32 afe_dfx_rx_status0;
+	/* 0x001c AFE_DFX_RX_STS1 */
+	u32 afe_dfx_rx_status1;
+	/* 0x0020 */
+	u32 reserved_0020;
+	/* 0x0024 AFE_TX_CTRL */
+	u32 afe_tx_control;
+	/* 0x0028 AFE_TX_AMP_CTRL0 */
+	u32 afe_tx_amp_control0;
+	/* 0x002c AFE_TX_AMP_CTRL1 */
+	u32 afe_tx_amp_control1;
+	/* 0x0030 AFE_TX_AMP_CTRL2 */
+	u32 afe_tx_amp_control2;
+	/* 0x0034 AFE_TX_AMP_CTRL3 */
+	u32 afe_tx_amp_control3;
+	/* 0x0038 afe_tx_ssc_control */
+	u32 afe_tx_ssc_control;
+	/* 0x003c */
+	u32 reserved_003c;
+	/* 0x0040 AFE_RX_SSC_CTRL0 */
+	u32 afe_rx_ssc_control0;
+	/* 0x0044 AFE_RX_SSC_CTRL1 */
+	u32 afe_rx_ssc_control1;
+	/* 0x0048 AFE_RX_SSC_CTRL2 */
+	u32 afe_rx_ssc_control2;
+	/* 0x004c AFE_RX_EQ_STS0 */
+	u32 afe_rx_eq_status0;
+	/* 0x0050 AFE_RX_EQ_STS1 */
+	u32 afe_rx_eq_status1;
+	/* 0x0054 AFE_RX_CDR_STS */
+	u32 afe_rx_cdr_status;
+	/* 0x0058 */
+	u32 reserved_0058;
+	/* 0x005c AFE_CHAN_CTRL */
+	u32 afe_channel_control;
+	/* 0x0060-0x006c */
+	u32 reserved_0060_006c[0x04];
+	/* 0x0070 AFE_XCVR_EC_STS0 */
+	u32 afe_xcvr_error_capture_status0;
+	/* 0x0074 AFE_XCVR_EC_STS1 */
+	u32 afe_xcvr_error_capture_status1;
+	/* 0x0078 AFE_XCVR_EC_STS2 */
+	u32 afe_xcvr_error_capture_status2;
+	/* 0x007c afe_xcvr_ec_status3 */
+	u32 afe_xcvr_error_capture_status3;
+	/* 0x0080 AFE_XCVR_EC_STS4 */
+	u32 afe_xcvr_error_capture_status4;
+	/* 0x0084 AFE_XCVR_EC_STS5 */
+	u32 afe_xcvr_error_capture_status5;
+	/* 0x0088-0x00fc */
+	u32 reserved_008c_00fc[0x1e];
+};
+
+/**
+ * struct scu_afe_registers - AFE Regsiters
+ *
+ *
+ */
+/* Uaoa AFE registers */
+struct scu_afe_registers {
+	/* 0Xe000 AFE_BIAS_CTRL */
+	u32 afe_bias_control;
+	u32 reserved_0004;
+	/* 0x0008 AFE_PLL_CTRL0 */
+	u32 afe_pll_control0;
+	/* 0x000c AFE_PLL_CTRL1 */
+	u32 afe_pll_control1;
+	/* 0x0010 AFE_PLL_CTRL2 */
+	u32 afe_pll_control2;
+	/* 0x0014 AFE_CB_STS */
+	u32 afe_common_block_status;
+	/* 0x0018-0x007c */
+	u32 reserved_18_7c[0x1a];
+	/* 0x0080 AFE_PMSN_MCTRL0 */
+	u32 afe_pmsn_master_control0;
+	/* 0x0084 AFE_PMSN_MCTRL1 */
+	u32 afe_pmsn_master_control1;
+	/* 0x0088 AFE_PMSN_MCTRL2 */
+	u32 afe_pmsn_master_control2;
+	/* 0x008C-0x00fc */
+	u32 reserved_008c_00fc[0x1D];
+	/* 0x0100 AFE_DFX_MST_CTRL0 */
+	u32 afe_dfx_master_control0;
+	/* 0x0104 AFE_DFX_MST_CTRL1 */
+	u32 afe_dfx_master_control1;
+	/* 0x0108 AFE_DFX_DCL_CTRL */
+	u32 afe_dfx_dcl_control;
+	/* 0x010c AFE_DFX_DMON_CTRL */
+	u32 afe_dfx_digital_monitor_control;
+	/* 0x0110 AFE_DFX_AMONP_CTRL */
+	u32 afe_dfx_analog_p_monitor_control;
+	/* 0x0114 AFE_DFX_AMONN_CTRL */
+	u32 afe_dfx_analog_n_monitor_control;
+	/* 0x0118 AFE_DFX_NTL_STS */
+	u32 afe_dfx_ntl_status;
+	/* 0x011c AFE_DFX_FIFO_STS0 */
+	u32 afe_dfx_fifo_status0;
+	/* 0x0120 AFE_DFX_FIFO_STS1 */
+	u32 afe_dfx_fifo_status1;
+	/* 0x0124 AFE_DFX_MPAT_CTRL */
+	u32 afe_dfx_master_pattern_control;
+	/* 0x0128 AFE_DFX_P0_CTRL */
+	u32 afe_dfx_p0_control;
+	/* 0x012c-0x01a8 AFE_DFX_P0_DRx */
+	u32 afe_dfx_p0_data[32];
+	/* 0x01ac */
+	u32 reserved_01ac;
+	/* 0x01b0-0x020c AFE_DFX_P0_IRx */
+	u32 afe_dfx_p0_instruction[24];
+	/* 0x0210 */
+	u32 reserved_0210;
+	/* 0x0214 AFE_DFX_P1_CTRL */
+	u32 afe_dfx_p1_control;
+	/* 0x0218-0x245 AFE_DFX_P1_DRx */
+	u32 afe_dfx_p1_data[16];
+	/* 0x0258-0x029c */
+	u32 reserved_0258_029c[0x12];
+	/* 0x02a0-0x02bc AFE_DFX_P1_IRx */
+	u32 afe_dfx_p1_instruction[8];
+	/* 0x02c0-0x2fc */
+	u32 reserved_02c0_02fc[0x10];
+	/* 0x0300 AFE_DFX_TX_PMSN_CTRL */
+	u32 afe_dfx_tx_pmsn_control;
+	/* 0x0304 AFE_DFX_RX_PMSN_CTRL */
+	u32 afe_dfx_rx_pmsn_control;
+	u32 reserved_0308;
+	/* 0x030c AFE_DFX_NOA_CTRL0 */
+	u32 afe_dfx_noa_control0;
+	/* 0x0310 AFE_DFX_NOA_CTRL1 */
+	u32 afe_dfx_noa_control1;
+	/* 0x0314 AFE_DFX_NOA_CTRL2 */
+	u32 afe_dfx_noa_control2;
+	/* 0x0318 AFE_DFX_NOA_CTRL3 */
+	u32 afe_dfx_noa_control3;
+	/* 0x031c AFE_DFX_NOA_CTRL4 */
+	u32 afe_dfx_noa_control4;
+	/* 0x0320 AFE_DFX_NOA_CTRL5 */
+	u32 afe_dfx_noa_control5;
+	/* 0x0324 AFE_DFX_NOA_CTRL6 */
+	u32 afe_dfx_noa_control6;
+	/* 0x0328 AFE_DFX_NOA_CTRL7 */
+	u32 afe_dfx_noa_control7;
+	/* 0x032c-0x07fc */
+	u32 reserved_032c_07fc[0x135];
+
+	/* 0x0800-0x0bfc */
+	struct scu_afe_transceiver scu_afe_xcvr[4];
+
+	/* 0x0c00-0x0ffc */
+	u32 reserved_0c00_0ffc[0x0100];
+};
+
+struct scu_protocol_engine_group_registers {
+	u32 table[0xE0];
+};
+
+
+struct scu_viit_iit {
+	u32 table[256];
+};
+
+/**
+ * Placeholder for the ZONE Partition Table information ZONING will not be
+ *    included in the 1.1 release.
+ *
+ *
+ */
+struct scu_zone_partition_table {
+	u32 table[2048];
+};
+
+/**
+ * Placeholder for the CRAM register since I am not sure if we need to
+ *    read/write to these registers as yet.
+ *
+ *
+ */
+struct scu_completion_ram {
+	u32 ram[128];
+};
+
+/**
+ * Placeholder for the FBRAM registers since I am not sure if we need to
+ *    read/write to these registers as yet.
+ *
+ *
+ */
+struct scu_frame_buffer_ram {
+	u32 ram[128];
+};
+
+#define scu_scratch_ram_SIZE_IN_DWORDS  256
+
+/**
+ * Placeholder for the scratch RAM registers.
+ *
+ *
+ */
+struct scu_scratch_ram {
+	u32 ram[scu_scratch_ram_SIZE_IN_DWORDS];
+};
+
+/**
+ * Placeholder since I am not yet sure what these registers are here for.
+ *
+ *
+ */
+struct noa_protocol_engine_partition {
+	u32 reserved[64];
+};
+
+/**
+ * Placeholder since I am not yet sure what these registers are here for.
+ *
+ *
+ */
+struct noa_hub_partition {
+	u32 reserved[64];
+};
+
+/**
+ * Placeholder since I am not yet sure what these registers are here for.
+ *
+ *
+ */
+struct noa_host_interface_partition {
+	u32 reserved[64];
+};
+
+/**
+ * struct transport_link_layer_pair - The SCU Hardware pairs up the TL
+ *    registers with the LL registers so we must place them adjcent to make the
+ *    array of registers in the PEG.
+ *
+ *
+ */
+struct transport_link_layer_pair {
+	struct scu_transport_layer_registers tl;
+	struct scu_link_layer_registers ll;
+};
+
+/**
+ * struct scu_peg_registers - SCU Protocol Engine Memory mapped register space.
+ *     These registers are unique to each protocol engine group.  There can be
+ *    at most two PEG for a single SCU part.
+ *
+ *
+ */
+struct scu_peg_registers {
+	struct transport_link_layer_pair pe[4];
+	struct scu_port_task_scheduler_group_registers ptsg;
+	struct scu_protocol_engine_group_registers peg;
+	struct scu_sgpio_registers sgpio;
+	u32 reserved_01500_1BFF[0x1C0];
+	struct scu_viit_entry viit[64];
+	struct scu_zone_partition_table zpt0;
+	struct scu_zone_partition_table zpt1;
+};
+
+/**
+ * struct scu_registers - SCU regsiters including both PEG registers if we turn
+ *    on that compile option. All of these registers are in the memory mapped
+ *    space returned from BAR1.
+ *
+ *
+ */
+struct scu_registers {
+	/* 0x0000 - PEG 0 */
+	struct scu_peg_registers peg0;
+
+	/* 0x6000 - SDMA and Miscellaneous */
+	struct scu_sdma_registers sdma;
+	struct scu_completion_ram cram;
+	struct scu_frame_buffer_ram fbram;
+	u32 reserved_6800_69FF[0x80];
+	struct noa_protocol_engine_partition noa_pe;
+	struct noa_hub_partition noa_hub;
+	struct noa_host_interface_partition noa_if;
+	u32 reserved_6d00_7fff[0x4c0];
+
+	/* 0x8000 - PEG 1 */
+	struct scu_peg_registers peg1;
+
+	/* 0xE000 - AFE Registers */
+	struct scu_afe_registers afe;
+
+	/* 0xF000 - reserved */
+	u32 reserved_f000_211fff[0x80c00];
+
+	/* 0x212000 - scratch RAM */
+	struct scu_scratch_ram scratch_ram;
+};
+
+#endif   /* _SCU_REGISTERS_HEADER_ */
diff --git a/drivers/scsi/isci/scu_completion_codes.h b/drivers/scsi/isci/scu_completion_codes.h
new file mode 100644
index 0000000..c8b329c
--- /dev/null
+++ b/drivers/scsi/isci/scu_completion_codes.h
@@ -0,0 +1,283 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _SCU_COMPLETION_CODES_HEADER_
+#define _SCU_COMPLETION_CODES_HEADER_
+
+/**
+ * This file contains the constants and macros for the SCU hardware completion
+ *    codes.
+ *
+ *
+ */
+
+#define SCU_COMPLETION_TYPE_SHIFT      28
+#define SCU_COMPLETION_TYPE_MASK       0x70000000
+
+/**
+ * SCU_COMPLETION_TYPE() -
+ *
+ * This macro constructs an SCU completion type
+ */
+#define SCU_COMPLETION_TYPE(type) \
+	((u32)(type) << SCU_COMPLETION_TYPE_SHIFT)
+
+/**
+ * SCU_COMPLETION_TYPE() -
+ *
+ * These macros contain the SCU completion types SCU_COMPLETION_TYPE
+ */
+#define SCU_COMPLETION_TYPE_TASK       SCU_COMPLETION_TYPE(0)
+#define SCU_COMPLETION_TYPE_SDMA       SCU_COMPLETION_TYPE(1)
+#define SCU_COMPLETION_TYPE_UFI        SCU_COMPLETION_TYPE(2)
+#define SCU_COMPLETION_TYPE_EVENT      SCU_COMPLETION_TYPE(3)
+#define SCU_COMPLETION_TYPE_NOTIFY     SCU_COMPLETION_TYPE(4)
+
+/**
+ *
+ *
+ * These constants provide the shift and mask values for the various parts of
+ * an SCU completion code.
+ */
+#define SCU_COMPLETION_STATUS_MASK       0x0FFC0000
+#define SCU_COMPLETION_TL_STATUS_MASK    0x0FC00000
+#define SCU_COMPLETION_TL_STATUS_SHIFT   22
+#define SCU_COMPLETION_SDMA_STATUS_MASK  0x003C0000
+#define SCU_COMPLETION_PEG_MASK          0x00010000
+#define SCU_COMPLETION_PORT_MASK         0x00007000
+#define SCU_COMPLETION_PE_MASK           SCU_COMPLETION_PORT_MASK
+#define SCU_COMPLETION_PE_SHIFT          12
+#define SCU_COMPLETION_INDEX_MASK        0x00000FFF
+
+/**
+ * SCU_GET_COMPLETION_TYPE() -
+ *
+ * This macro returns the SCU completion type.
+ */
+#define SCU_GET_COMPLETION_TYPE(completion_code) \
+	((completion_code) & SCU_COMPLETION_TYPE_MASK)
+
+/**
+ * SCU_GET_COMPLETION_STATUS() -
+ *
+ * This macro returns the SCU completion status.
+ */
+#define SCU_GET_COMPLETION_STATUS(completion_code) \
+	((completion_code) & SCU_COMPLETION_STATUS_MASK)
+
+/**
+ * SCU_GET_COMPLETION_TL_STATUS() -
+ *
+ * This macro returns the transport layer completion status.
+ */
+#define SCU_GET_COMPLETION_TL_STATUS(completion_code) \
+	((completion_code) & SCU_COMPLETION_TL_STATUS_MASK)
+
+/**
+ * SCU_MAKE_COMPLETION_STATUS() -
+ *
+ * This macro takes a completion code and performs the shift and mask
+ * operations to turn it into a completion code that can be compared to a
+ * SCU_GET_COMPLETION_TL_STATUS.
+ */
+#define SCU_MAKE_COMPLETION_STATUS(completion_code) \
+	((u32)(completion_code) << SCU_COMPLETION_TL_STATUS_SHIFT)
+
+/**
+ * SCU_NORMALIZE_COMPLETION_STATUS() -
+ *
+ * This macro takes a SCU_GET_COMPLETION_TL_STATUS and normalizes it for a
+ * return code.
+ */
+#define SCU_NORMALIZE_COMPLETION_STATUS(completion_code) \
+	(\
+		((completion_code) & SCU_COMPLETION_TL_STATUS_MASK) \
+		>> SCU_COMPLETION_TL_STATUS_SHIFT \
+	)
+
+/**
+ * SCU_GET_COMPLETION_SDMA_STATUS() -
+ *
+ * This macro returns the SDMA completion status.
+ */
+#define SCU_GET_COMPLETION_SDMA_STATUS(completion_code)	\
+	((completion_code) & SCU_COMPLETION_SDMA_STATUS_MASK)
+
+/**
+ * SCU_GET_COMPLETION_PEG() -
+ *
+ * This macro returns the Protocol Engine Group from the completion code.
+ */
+#define SCU_GET_COMPLETION_PEG(completion_code)	\
+	((completion_code) & SCU_COMPLETION_PEG_MASK)
+
+/**
+ * SCU_GET_COMPLETION_PORT() -
+ *
+ * This macro reuturns the logical port index from the completion code.
+ */
+#define SCU_GET_COMPLETION_PORT(completion_code) \
+	((completion_code) & SCU_COMPLETION_PORT_MASK)
+
+/**
+ * SCU_GET_PROTOCOL_ENGINE_INDEX() -
+ *
+ * This macro returns the PE index from the completion code.
+ */
+#define SCU_GET_PROTOCOL_ENGINE_INDEX(completion_code) \
+	(((completion_code) & SCU_COMPLETION_PE_MASK) >> SCU_COMPLETION_PE_SHIFT)
+
+/**
+ * SCU_GET_COMPLETION_INDEX() -
+ *
+ * This macro returns the index of the completion which is either a TCi or an
+ * RNi depending on the completion type.
+ */
+#define SCU_GET_COMPLETION_INDEX(completion_code) \
+	((completion_code) & SCU_COMPLETION_INDEX_MASK)
+
+#define SCU_UNSOLICITED_FRAME_MASK     0x0FFF0000
+#define SCU_UNSOLICITED_FRAME_SHIFT    16
+
+/**
+ * SCU_GET_FRAME_INDEX() -
+ *
+ * This macro returns a normalized frame index from an unsolicited frame
+ * completion.
+ */
+#define SCU_GET_FRAME_INDEX(completion_code) \
+	(\
+		((completion_code) & SCU_UNSOLICITED_FRAME_MASK) \
+		>> SCU_UNSOLICITED_FRAME_SHIFT \
+	)
+
+#define SCU_UNSOLICITED_FRAME_ERROR_MASK  0x00008000
+
+/**
+ * SCU_GET_FRAME_ERROR() -
+ *
+ * This macro returns a zero (0) value if there is no frame error otherwise it
+ * returns non-zero (!0).
+ */
+#define SCU_GET_FRAME_ERROR(completion_code) \
+	((completion_code) & SCU_UNSOLICITED_FRAME_ERROR_MASK)
+
+/**
+ *
+ *
+ * These constants represent normalized completion codes which must be shifted
+ * 18 bits to match it with the hardware completion code. In a 16-bit compiler,
+ * immediate constants are 16-bit values (the size of an int). If we shift
+ * those by 18 bits, we completely lose the value. To ensure the value is a
+ * 32-bit value like we want, each immediate value must be cast to a u32.
+ */
+#define SCU_TASK_DONE_GOOD                                  ((u32)0x00)
+#define SCU_TASK_DONE_CRC_ERR                               ((u32)0x14)
+#define SCU_TASK_DONE_CHECK_RESPONSE                        ((u32)0x14)
+#define SCU_TASK_DONE_GEN_RESPONSE                          ((u32)0x15)
+#define SCU_TASK_DONE_NAK_CMD_ERR                           ((u32)0x16)
+#define SCU_TASK_DONE_CMD_LL_R_ERR                          ((u32)0x16)
+#define SCU_TASK_DONE_LL_R_ERR                              ((u32)0x17)
+#define SCU_TASK_DONE_ACK_NAK_TO                            ((u32)0x17)
+#define SCU_TASK_DONE_LL_PERR                               ((u32)0x18)
+#define SCU_TASK_DONE_LL_SY_TERM                            ((u32)0x19)
+#define SCU_TASK_DONE_NAK_ERR                               ((u32)0x19)
+#define SCU_TASK_DONE_LL_LF_TERM                            ((u32)0x1A)
+#define SCU_TASK_DONE_DATA_LEN_ERR                          ((u32)0x1A)
+#define SCU_TASK_DONE_LL_CL_TERM                            ((u32)0x1B)
+#define SCU_TASK_DONE_LL_ABORT_ERR                          ((u32)0x1B)
+#define SCU_TASK_DONE_SEQ_INV_TYPE                          ((u32)0x1C)
+#define SCU_TASK_DONE_UNEXP_XR                              ((u32)0x1C)
+#define SCU_TASK_DONE_INV_FIS_TYPE                          ((u32)0x1D)
+#define SCU_TASK_DONE_XR_IU_LEN_ERR                         ((u32)0x1D)
+#define SCU_TASK_DONE_INV_FIS_LEN                           ((u32)0x1E)
+#define SCU_TASK_DONE_XR_WD_LEN                             ((u32)0x1E)
+#define SCU_TASK_DONE_SDMA_ERR                              ((u32)0x1F)
+#define SCU_TASK_DONE_OFFSET_ERR                            ((u32)0x20)
+#define SCU_TASK_DONE_MAX_PLD_ERR                           ((u32)0x21)
+#define SCU_TASK_DONE_EXCESS_DATA                           ((u32)0x22)
+#define SCU_TASK_DONE_LF_ERR                                ((u32)0x23)
+#define SCU_TASK_DONE_UNEXP_FIS                             ((u32)0x24)
+#define SCU_TASK_DONE_UNEXP_RESP                            ((u32)0x24)
+#define SCU_TASK_DONE_EARLY_RESP                            ((u32)0x25)
+#define SCU_TASK_DONE_SMP_RESP_TO_ERR                       ((u32)0x26)
+#define SCU_TASK_DONE_DMASETUP_DIRERR                       ((u32)0x27)
+#define SCU_TASK_DONE_SMP_UFI_ERR                           ((u32)0x27)
+#define SCU_TASK_DONE_XFERCNT_ERR                           ((u32)0x28)
+#define SCU_TASK_DONE_SMP_FRM_TYPE_ERR                      ((u32)0x28)
+#define SCU_TASK_DONE_SMP_LL_RX_ERR                         ((u32)0x29)
+#define SCU_TASK_DONE_RESP_LEN_ERR                          ((u32)0x2A)
+#define SCU_TASK_DONE_UNEXP_DATA                            ((u32)0x2B)
+#define SCU_TASK_DONE_OPEN_FAIL                             ((u32)0x2C)
+#define SCU_TASK_DONE_UNEXP_SDBFIS                          ((u32)0x2D)
+#define SCU_TASK_DONE_REG_ERR                               ((u32)0x2E)
+#define SCU_TASK_DONE_SDB_ERR                               ((u32)0x2F)
+#define SCU_TASK_DONE_TASK_ABORT                            ((u32)0x30)
+#define SCU_TASK_DONE_CMD_SDMA_ERR                          ((U32)0x32)
+#define SCU_TASK_DONE_CMD_LL_ABORT_ERR                      ((U32)0x33)
+#define SCU_TASK_OPEN_REJECT_WRONG_DESTINATION              ((u32)0x34)
+#define SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_1             ((u32)0x35)
+#define SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_2             ((u32)0x36)
+#define SCU_TASK_OPEN_REJECT_RESERVED_ABANDON_3             ((u32)0x37)
+#define SCU_TASK_OPEN_REJECT_BAD_DESTINATION                ((u32)0x38)
+#define SCU_TASK_OPEN_REJECT_ZONE_VIOLATION                 ((u32)0x39)
+#define SCU_TASK_DONE_VIIT_ENTRY_NV                         ((u32)0x3A)
+#define SCU_TASK_DONE_IIT_ENTRY_NV                          ((u32)0x3B)
+#define SCU_TASK_DONE_RNCNV_OUTBOUND                        ((u32)0x3C)
+#define SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY             ((u32)0x3D)
+#define SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED         ((u32)0x3E)
+#define SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED  ((u32)0x3F)
+
+#endif /* _SCU_COMPLETION_CODES_HEADER_ */
diff --git a/drivers/scsi/isci/scu_event_codes.h b/drivers/scsi/isci/scu_event_codes.h
new file mode 100644
index 0000000..36a945a
--- /dev/null
+++ b/drivers/scsi/isci/scu_event_codes.h
@@ -0,0 +1,336 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SCU_EVENT_CODES_HEADER__
+#define __SCU_EVENT_CODES_HEADER__
+
+/**
+ * This file contains the constants and macros for the SCU event codes.
+ *
+ *
+ */
+
+#define SCU_EVENT_TYPE_CODE_SHIFT      24
+#define SCU_EVENT_TYPE_CODE_MASK       0x0F000000
+
+#define SCU_EVENT_SPECIFIC_CODE_SHIFT  18
+#define SCU_EVENT_SPECIFIC_CODE_MASK   0x00FC0000
+
+#define SCU_EVENT_CODE_MASK \
+	(SCU_EVENT_TYPE_CODE_MASK | SCU_EVENT_SPECIFIC_CODE_MASK)
+
+/**
+ * SCU_EVENT_TYPE() -
+ *
+ * This macro constructs an SCU event type from the type value.
+ */
+#define SCU_EVENT_TYPE(type) \
+	((u32)(type) << SCU_EVENT_TYPE_CODE_SHIFT)
+
+/**
+ * SCU_EVENT_SPECIFIC() -
+ *
+ * This macro constructs an SCU event specifier from the code value.
+ */
+#define SCU_EVENT_SPECIFIC(code) \
+	((u32)(code) << SCU_EVENT_SPECIFIC_CODE_SHIFT)
+
+/**
+ * SCU_EVENT_MESSAGE() -
+ *
+ * This macro constructs a combines an SCU event type and SCU event specifier
+ * from the type and code values.
+ */
+#define SCU_EVENT_MESSAGE(type, code) \
+	((type) | SCU_EVENT_SPECIFIC(code))
+
+/**
+ * SCU_EVENT_TYPE() -
+ *
+ * SCU_EVENT_TYPES
+ */
+#define SCU_EVENT_TYPE_SMU_COMMAND_ERROR  SCU_EVENT_TYPE(0x08)
+#define SCU_EVENT_TYPE_SMU_PCQ_ERROR      SCU_EVENT_TYPE(0x09)
+#define SCU_EVENT_TYPE_SMU_ERROR          SCU_EVENT_TYPE(0x00)
+#define SCU_EVENT_TYPE_TRANSPORT_ERROR    SCU_EVENT_TYPE(0x01)
+#define SCU_EVENT_TYPE_BROADCAST_CHANGE   SCU_EVENT_TYPE(0x02)
+#define SCU_EVENT_TYPE_OSSP_EVENT         SCU_EVENT_TYPE(0x03)
+#define SCU_EVENT_TYPE_FATAL_MEMORY_ERROR SCU_EVENT_TYPE(0x0F)
+#define SCU_EVENT_TYPE_RNC_SUSPEND_TX     SCU_EVENT_TYPE(0x04)
+#define SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX  SCU_EVENT_TYPE(0x05)
+#define SCU_EVENT_TYPE_RNC_OPS_MISC       SCU_EVENT_TYPE(0x06)
+#define SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT SCU_EVENT_TYPE(0x07)
+#define SCU_EVENT_TYPE_ERR_CNT_EVENT      SCU_EVENT_TYPE(0x0A)
+
+/**
+ *
+ *
+ * SCU_EVENT_SPECIFIERS
+ */
+#define SCU_EVENT_SPECIFIER_DRIVER_SUSPEND 0x20
+#define SCU_EVENT_SPECIFIER_RNC_RELEASE    0x00
+
+/**
+ *
+ *
+ * SMU_COMMAND_EVENTS
+ */
+#define SCU_EVENT_INVALID_CONTEXT_COMMAND \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_COMMAND_ERROR, 0x00)
+
+/**
+ *
+ *
+ * SMU_PCQ_EVENTS
+ */
+#define SCU_EVENT_UNCORRECTABLE_PCQ_ERROR \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_PCQ_ERROR, 0x00)
+
+/**
+ *
+ *
+ * SMU_EVENTS
+ */
+#define SCU_EVENT_UNCORRECTABLE_REGISTER_WRITE \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_ERROR, 0x02)
+#define SCU_EVENT_UNCORRECTABLE_REGISTER_READ \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_ERROR, 0x03)
+#define SCU_EVENT_PCIE_INTERFACE_ERROR \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_ERROR, 0x04)
+#define SCU_EVENT_FUNCTION_LEVEL_RESET \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_SMU_ERROR, 0x05)
+
+/**
+ *
+ *
+ * TRANSPORT_LEVEL_ERRORS
+ */
+#define SCU_EVENT_ACK_NAK_TIMEOUT_ERROR	\
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_TRANSPORT_ERROR, 0x00)
+
+/**
+ *
+ *
+ * BROADCAST_CHANGE_EVENTS
+ */
+#define SCU_EVENT_BROADCAST_CHANGE \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x01)
+#define SCU_EVENT_BROADCAST_RESERVED0 \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x02)
+#define SCU_EVENT_BROADCAST_RESERVED1 \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x03)
+#define SCU_EVENT_BROADCAST_SES	\
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x04)
+#define SCU_EVENT_BROADCAST_EXPANDER \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x05)
+#define SCU_EVENT_BROADCAST_AEN	\
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x06)
+#define SCU_EVENT_BROADCAST_RESERVED3 \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x07)
+#define SCU_EVENT_BROADCAST_RESERVED4 \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x08)
+#define SCU_EVENT_PE_SUSPENDED \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_BROADCAST_CHANGE, 0x09)
+
+/**
+ *
+ *
+ * OSSP_EVENTS
+ */
+#define SCU_EVENT_PORT_SELECTOR_DETECTED \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x10)
+#define SCU_EVENT_SENT_PORT_SELECTION \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x11)
+#define SCU_EVENT_HARD_RESET_TRANSMITTED \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x12)
+#define SCU_EVENT_HARD_RESET_RECEIVED \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x13)
+#define SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x15)
+#define SCU_EVENT_LINK_FAILURE \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x16)
+#define SCU_EVENT_SATA_SPINUP_HOLD \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x17)
+#define SCU_EVENT_SAS_15_SSC \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x18)
+#define SCU_EVENT_SAS_15 \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x19)
+#define SCU_EVENT_SAS_30_SSC \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1A)
+#define SCU_EVENT_SAS_30 \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1B)
+#define SCU_EVENT_SAS_60_SSC \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1C)
+#define SCU_EVENT_SAS_60 \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1D)
+#define SCU_EVENT_SATA_15_SSC \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1E)
+#define SCU_EVENT_SATA_15 \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x1F)
+#define SCU_EVENT_SATA_30_SSC \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x20)
+#define SCU_EVENT_SATA_30 \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x21)
+#define SCU_EVENT_SATA_60_SSC \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x22)
+#define SCU_EVENT_SATA_60 \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x23)
+#define SCU_EVENT_SAS_PHY_DETECTED \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x24)
+#define SCU_EVENT_SATA_PHY_DETECTED \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_OSSP_EVENT, 0x25)
+
+/**
+ *
+ *
+ * FATAL_INTERNAL_MEMORY_ERROR_EVENTS
+ */
+#define SCU_EVENT_TSC_RNSC_UNCORRECTABLE_ERROR \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_FATAL_MEMORY_ERROR,  0x00)
+#define SCU_EVENT_TC_RNC_UNCORRECTABLE_ERROR \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_FATAL_MEMORY_ERROR,  0x01)
+#define SCU_EVENT_ZPT_UNCORRECTABLE_ERROR \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_FATAL_MEMORY_ERROR,  0x02)
+
+/**
+ *
+ *
+ * REMOTE_NODE_SUSPEND_EVENTS
+ */
+#define SCU_EVENT_TL_RNC_SUSPEND_TX \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_SUSPEND_TX, 0x00)
+#define SCU_EVENT_TL_RNC_SUSPEND_TX_RX \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX, 0x00)
+#define SCU_EVENT_DRIVER_POST_RNC_SUSPEND_TX \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_SUSPEND_TX, 0x20)
+#define SCU_EVENT_DRIVER_POST_RNC_SUSPEND_TX_RX	\
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX, 0x20)
+
+/**
+ *
+ *
+ * REMOTE_NODE_MISC_EVENTS
+ */
+#define SCU_EVENT_POST_RCN_RELEASE \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_OPS_MISC, SCU_EVENT_SPECIFIER_RNC_RELEASE)
+#define SCU_EVENT_POST_IT_NEXUS_LOSS_TIMER_ENABLE \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_OPS_MISC, 0x01)
+#define SCU_EVENT_POST_IT_NEXUS_LOSS_TIMER_DISABLE \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_OPS_MISC, 0x02)
+#define SCU_EVENT_POST_RNC_COMPLETE \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_OPS_MISC, 0x03)
+#define SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_RNC_OPS_MISC, 0x04)
+
+/**
+ *
+ *
+ * ERROR_COUNT_EVENT
+ */
+#define SCU_EVENT_RX_CREDIT_BLOCKED_RECEIVED \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_ERR_CNT_EVENT, 0x00)
+#define SCU_EVENT_TX_DONE_CREDIT_TIMEOUT \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_ERR_CNT_EVENT, 0x01)
+#define SCU_EVENT_RX_DONE_CREDIT_TIMEOUT \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_ERR_CNT_EVENT, 0x02)
+
+/**
+ * scu_get_event_type() -
+ *
+ * This macro returns the SCU event type from the event code.
+ */
+#define scu_get_event_type(event_code) \
+	((event_code) & SCU_EVENT_TYPE_CODE_MASK)
+
+/**
+ * scu_get_event_specifier() -
+ *
+ * This macro returns the SCU event specifier from the event code.
+ */
+#define scu_get_event_specifier(event_code) \
+	((event_code) & SCU_EVENT_SPECIFIC_CODE_MASK)
+
+/**
+ * scu_get_event_code() -
+ *
+ * This macro returns the combined SCU event type and SCU event specifier from
+ * the event code.
+ */
+#define scu_get_event_code(event_code) \
+	((event_code) & SCU_EVENT_CODE_MASK)
+
+
+/**
+ *
+ *
+ * PTS_SCHEDULE_EVENT
+ */
+#define SCU_EVENT_SMP_RESPONSE_NO_PE \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT, 0x00)
+#define SCU_EVENT_SPECIFIC_SMP_RESPONSE_NO_PE \
+	scu_get_event_specifier(SCU_EVENT_SMP_RESPONSE_NO_PE)
+
+#define SCU_EVENT_TASK_TIMEOUT \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT, 0x01)
+#define SCU_EVENT_SPECIFIC_TASK_TIMEOUT	\
+	scu_get_event_specifier(SCU_EVENT_TASK_TIMEOUT)
+
+#define SCU_EVENT_IT_NEXUS_TIMEOUT \
+	SCU_EVENT_MESSAGE(SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT, 0x02)
+#define SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT \
+	scu_get_event_specifier(SCU_EVENT_IT_NEXUS_TIMEOUT)
+
+
+#endif /* __SCU_EVENT_CODES_HEADER__ */
diff --git a/drivers/scsi/isci/scu_task_context.h b/drivers/scsi/isci/scu_task_context.h
new file mode 100644
index 0000000..7df87d9
--- /dev/null
+++ b/drivers/scsi/isci/scu_task_context.h
@@ -0,0 +1,942 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _SCU_TASK_CONTEXT_H_
+#define _SCU_TASK_CONTEXT_H_
+
+/**
+ * This file contains the structures and constants for the SCU hardware task
+ *    context.
+ *
+ *
+ */
+
+
+/**
+ * enum scu_ssp_task_type - This enumberation defines the various SSP task
+ *    types the SCU hardware will accept. The definition for the various task
+ *    types the SCU hardware will accept can be found in the DS specification.
+ *
+ *
+ */
+typedef enum {
+	SCU_TASK_TYPE_IOREAD,           /* /< IO READ direction or no direction */
+	SCU_TASK_TYPE_IOWRITE,          /* /< IO Write direction */
+	SCU_TASK_TYPE_SMP_REQUEST,      /* /< SMP Request type */
+	SCU_TASK_TYPE_RESPONSE,         /* /< Driver generated response frame (targt mode) */
+	SCU_TASK_TYPE_RAW_FRAME,        /* /< Raw frame request type */
+	SCU_TASK_TYPE_PRIMITIVE         /* /< Request for a primitive to be transmitted */
+} scu_ssp_task_type;
+
+/**
+ * enum scu_sata_task_type - This enumeration defines the various SATA task
+ *    types the SCU hardware will accept. The definition for the various task
+ *    types the SCU hardware will accept can be found in the DS specification.
+ *
+ *
+ */
+typedef enum {
+	SCU_TASK_TYPE_DMA_IN,           /* /< Read request */
+	SCU_TASK_TYPE_FPDMAQ_READ,      /* /< NCQ read request */
+	SCU_TASK_TYPE_PACKET_DMA_IN,    /* /< Packet read request */
+	SCU_TASK_TYPE_SATA_RAW_FRAME,   /* /< Raw frame request */
+	RESERVED_4,
+	RESERVED_5,
+	RESERVED_6,
+	RESERVED_7,
+	SCU_TASK_TYPE_DMA_OUT,          /* /< Write request */
+	SCU_TASK_TYPE_FPDMAQ_WRITE,     /* /< NCQ write Request */
+	SCU_TASK_TYPE_PACKET_DMA_OUT    /* /< Packet write request */
+} scu_sata_task_type;
+
+
+/**
+ *
+ *
+ * SCU_CONTEXT_TYPE
+ */
+#define SCU_TASK_CONTEXT_TYPE  0
+#define SCU_RNC_CONTEXT_TYPE   1
+
+/**
+ *
+ *
+ * SCU_TASK_CONTEXT_VALIDITY
+ */
+#define SCU_TASK_CONTEXT_INVALID          0
+#define SCU_TASK_CONTEXT_VALID            1
+
+/**
+ *
+ *
+ * SCU_COMMAND_CODE
+ */
+#define SCU_COMMAND_CODE_INITIATOR_NEW_TASK   0
+#define SCU_COMMAND_CODE_ACTIVE_TASK          1
+#define SCU_COMMAND_CODE_PRIMITIVE_SEQ_TASK   2
+#define SCU_COMMAND_CODE_TARGET_RAW_FRAMES    3
+
+/**
+ *
+ *
+ * SCU_TASK_PRIORITY
+ */
+/**
+ *
+ *
+ * This priority is used when there is no priority request for this request.
+ */
+#define SCU_TASK_PRIORITY_NORMAL          0
+
+/**
+ *
+ *
+ * This priority indicates that the task should be scheduled to the head of the
+ * queue.  The task will NOT be executed if the TX is suspended for the remote
+ * node.
+ */
+#define SCU_TASK_PRIORITY_HEAD_OF_Q       1
+
+/**
+ *
+ *
+ * This priority indicates that the task will be executed before all
+ * SCU_TASK_PRIORITY_NORMAL and SCU_TASK_PRIORITY_HEAD_OF_Q tasks. The task
+ * WILL be executed if the TX is suspended for the remote node.
+ */
+#define SCU_TASK_PRIORITY_HIGH            2
+
+/**
+ *
+ *
+ * This task priority is reserved and should not be used.
+ */
+#define SCU_TASK_PRIORITY_RESERVED        3
+
+#define SCU_TASK_INITIATOR_MODE           1
+#define SCU_TASK_TARGET_MODE              0
+
+#define SCU_TASK_REGULAR                  0
+#define SCU_TASK_ABORTED                  1
+
+/* direction bit defintion */
+/**
+ *
+ *
+ * SATA_DIRECTION
+ */
+#define SCU_SATA_WRITE_DATA_DIRECTION     0
+#define SCU_SATA_READ_DATA_DIRECTION      1
+
+/**
+ *
+ *
+ * SCU_COMMAND_CONTEXT_MACROS These macros provide the mask and shift
+ * operations to construct the various SCU commands
+ */
+#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_SHIFT           21
+#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_MASK            0x00E00000
+#define scu_get_command_request_type(x)	\
+	((x) & SCU_CONTEXT_COMMAND_REQUEST_TYPE_MASK)
+
+#define SCU_CONTEXT_COMMAND_REQUEST_SUBTYPE_SHIFT        18
+#define SCU_CONTEXT_COMMAND_REQUEST_SUBTYPE_MASK         0x001C0000
+#define scu_get_command_request_subtype(x) \
+	((x) & SCU_CONTEXT_COMMAND_REQUEST_SUBTYPE_MASK)
+
+#define SCU_CONTEXT_COMMAND_REQUEST_FULLTYPE_MASK	 \
+	(\
+		SCU_CONTEXT_COMMAND_REQUEST_TYPE_MASK		  \
+		| SCU_CONTEXT_COMMAND_REQUEST_SUBTYPE_MASK	    \
+	)
+#define scu_get_command_request_full_type(x) \
+	((x) & SCU_CONTEXT_COMMAND_REQUEST_FULLTYPE_MASK)
+
+#define SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT  16
+#define SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_MASK   0x00010000
+#define scu_get_command_protocl_engine_group(x)	\
+	((x) & SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_MASK)
+
+#define SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT           12
+#define SCU_CONTEXT_COMMAND_LOGICAL_PORT_MASK            0x00007000
+#define scu_get_command_reqeust_logical_port(x)	\
+	((x) & SCU_CONTEXT_COMMAND_LOGICAL_PORT_MASK)
+
+
+#define MAKE_SCU_CONTEXT_COMMAND_TYPE(type) \
+	((u32)(type) << SCU_CONTEXT_COMMAND_REQUEST_TYPE_SHIFT)
+
+/**
+ * MAKE_SCU_CONTEXT_COMMAND_TYPE() -
+ *
+ * SCU_COMMAND_TYPES These constants provide the grouping of the different SCU
+ * command types.
+ */
+#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC    MAKE_SCU_CONTEXT_COMMAND_TYPE(0)
+#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC    MAKE_SCU_CONTEXT_COMMAND_TYPE(1)
+#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC   MAKE_SCU_CONTEXT_COMMAND_TYPE(2)
+#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC   MAKE_SCU_CONTEXT_COMMAND_TYPE(3)
+#define SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC  MAKE_SCU_CONTEXT_COMMAND_TYPE(6)
+
+#define MAKE_SCU_CONTEXT_COMMAND_REQUEST(type, command)	\
+	((type) | ((command) << SCU_CONTEXT_COMMAND_REQUEST_SUBTYPE_SHIFT))
+
+/**
+ *
+ *
+ * SCU_REQUEST_TYPES These constants are the various request types that can be
+ * posted to the SCU hardware.
+ */
+#define SCU_CONTEXT_COMMAND_REQUST_POST_TC \
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC, 0))
+
+#define SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT \
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC, 1))
+
+#define SCU_CONTEXT_COMMAND_REQUST_DUMP_TC \
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC, 0))
+
+#define SCU_CONTEXT_COMMAND_POST_RNC_32	\
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC, 0))
+
+#define SCU_CONTEXT_COMMAND_POST_RNC_96	\
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC, 1))
+
+#define SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE	\
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC, 2))
+
+#define SCU_CONTEXT_COMMAND_DUMP_RNC_32	\
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC, 0))
+
+#define SCU_CONTEXT_COMMAND_DUMP_RNC_96	\
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC, 1))
+
+#define SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX	\
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC, 0))
+
+#define SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX_RX \
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC, 1))
+
+#define SCU_CONTEXT_COMMAND_POST_RNC_RESUME \
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC, 2))
+
+#define SCU_CONTEXT_IT_NEXUS_LOSS_TIMER_ENABLE \
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC, 3))
+
+#define SCU_CONTEXT_IT_NEXUS_LOSS_TIMER_DISABLE	\
+	(MAKE_SCU_CONTEXT_COMMAND_REQUEST(SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC, 4))
+
+/**
+ *
+ *
+ * SCU_TASK_CONTEXT_PROTOCOL SCU Task context protocol types this is uesd to
+ * program the SCU Task context protocol field in word 0x00.
+ */
+#define SCU_TASK_CONTEXT_PROTOCOL_SMP    0x00
+#define SCU_TASK_CONTEXT_PROTOCOL_SSP    0x01
+#define SCU_TASK_CONTEXT_PROTOCOL_STP    0x02
+#define SCU_TASK_CONTEXT_PROTOCOL_NONE   0x07
+
+/**
+ * struct ssp_task_context - This is the SCU hardware definition for an SSP
+ *    request.
+ *
+ *
+ */
+struct ssp_task_context {
+	/* OFFSET 0x18 */
+	u32 reserved00:24;
+	u32 frame_type:8;
+
+	/* OFFSET 0x1C */
+	u32 reserved01;
+
+	/* OFFSET 0x20 */
+	u32 fill_bytes:2;
+	u32 reserved02:6;
+	u32 changing_data_pointer:1;
+	u32 retransmit:1;
+	u32 retry_data_frame:1;
+	u32 tlr_control:2;
+	u32 reserved03:19;
+
+	/* OFFSET 0x24 */
+	u32 uiRsvd4;
+
+	/* OFFSET 0x28 */
+	u32 target_port_transfer_tag:16;
+	u32 tag:16;
+
+	/* OFFSET 0x2C */
+	u32 data_offset;
+};
+
+/**
+ * struct stp_task_context - This is the SCU hardware definition for an STP
+ *    request.
+ *
+ *
+ */
+struct stp_task_context {
+	/* OFFSET 0x18 */
+	u32 fis_type:8;
+	u32 pm_port:4;
+	u32 reserved0:3;
+	u32 control:1;
+	u32 command:8;
+	u32 features:8;
+
+	/* OFFSET 0x1C */
+	u32 reserved1;
+
+	/* OFFSET 0x20 */
+	u32 reserved2;
+
+	/* OFFSET 0x24 */
+	u32 reserved3;
+
+	/* OFFSET 0x28 */
+	u32 ncq_tag:5;
+	u32 reserved4:27;
+
+	/* OFFSET 0x2C */
+	u32 data_offset; /* TODO: What is this used for? */
+};
+
+/**
+ * struct smp_task_context - This is the SCU hardware definition for an SMP
+ *    request.
+ *
+ *
+ */
+struct smp_task_context {
+	/* OFFSET 0x18 */
+	u32 response_length:8;
+	u32 function_result:8;
+	u32 function:8;
+	u32 frame_type:8;
+
+	/* OFFSET 0x1C */
+	u32 smp_response_ufi:12;
+	u32 reserved1:20;
+
+	/* OFFSET 0x20 */
+	u32 reserved2;
+
+	/* OFFSET 0x24 */
+	u32 reserved3;
+
+	/* OFFSET 0x28 */
+	u32 reserved4;
+
+	/* OFFSET 0x2C */
+	u32 reserved5;
+};
+
+/**
+ * struct primitive_task_context - This is the SCU hardware definition used
+ *    when the driver wants to send a primitive on the link.
+ *
+ *
+ */
+struct primitive_task_context {
+	/* OFFSET 0x18 */
+	/**
+	 * This field is the control word and it must be 0.
+	 */
+	u32 control; /* /< must be set to 0 */
+
+	/* OFFSET 0x1C */
+	/**
+	 * This field specifies the primitive that is to be transmitted.
+	 */
+	u32 sequence;
+
+	/* OFFSET 0x20 */
+	u32 reserved0;
+
+	/* OFFSET 0x24 */
+	u32 reserved1;
+
+	/* OFFSET 0x28 */
+	u32 reserved2;
+
+	/* OFFSET 0x2C */
+	u32 reserved3;
+};
+
+/**
+ * The union of the protocols that can be selected in the SCU task context
+ *    field.
+ *
+ * protocol_context
+ */
+union protocol_context {
+	struct ssp_task_context ssp;
+	struct stp_task_context stp;
+	struct smp_task_context smp;
+	struct primitive_task_context primitive;
+	u32 words[6];
+};
+
+/**
+ * struct scu_sgl_element - This structure represents a single SCU defined SGL
+ *    element. SCU SGLs contain a 64 bit address with the maximum data transfer
+ *    being 24 bits in size.  The SGL can not cross a 4GB boundary.
+ *
+ * struct scu_sgl_element
+ */
+struct scu_sgl_element {
+	/**
+	 * This field is the upper 32 bits of the 64 bit physical address.
+	 */
+	u32 address_upper;
+
+	/**
+	 * This field is the lower 32 bits of the 64 bit physical address.
+	 */
+	u32 address_lower;
+
+	/**
+	 * This field is the number of bytes to transfer.
+	 */
+	u32 length:24;
+
+	/**
+	 * This field is the address modifier to be used when a virtual function is
+	 * requesting a data transfer.
+	 */
+	u32 address_modifier:8;
+
+};
+
+#define SCU_SGL_ELEMENT_PAIR_A   0
+#define SCU_SGL_ELEMENT_PAIR_B   1
+
+/**
+ * struct scu_sgl_element_pair - This structure is the SCU hardware definition
+ *    of a pair of SGL elements. The SCU hardware always works on SGL pairs.
+ *    They are refered to in the DS specification as SGL A and SGL B.  Each SGL
+ *    pair is followed by the address of the next pair.
+ *
+ *
+ */
+struct scu_sgl_element_pair {
+	/* OFFSET 0x60-0x68 */
+	/**
+	 * This field is the SGL element A of the SGL pair.
+	 */
+	struct scu_sgl_element A;
+
+	/* OFFSET 0x6C-0x74 */
+	/**
+	 * This field is the SGL element B of the SGL pair.
+	 */
+	struct scu_sgl_element B;
+
+	/* OFFSET 0x78-0x7C */
+	/**
+	 * This field is the upper 32 bits of the 64 bit address to the next SGL
+	 * element pair.
+	 */
+	u32 next_pair_upper;
+
+	/**
+	 * This field is the lower 32 bits of the 64 bit address to the next SGL
+	 * element pair.
+	 */
+	u32 next_pair_lower;
+
+};
+
+/**
+ * struct transport_snapshot - This structure is the SCU hardware scratch area
+ *    for the task context. This is set to 0 by the driver but can be read by
+ *    issuing a dump TC request to the SCU.
+ *
+ *
+ */
+struct transport_snapshot {
+	/* OFFSET 0x48 */
+	u32 xfer_rdy_write_data_length;
+
+	/* OFFSET 0x4C */
+	u32 data_offset;
+
+	/* OFFSET 0x50 */
+	u32 data_transfer_size:24;
+	u32 reserved_50_0:8;
+
+	/* OFFSET 0x54 */
+	u32 next_initiator_write_data_offset;
+
+	/* OFFSET 0x58 */
+	u32 next_initiator_write_data_xfer_size:24;
+	u32 reserved_58_0:8;
+};
+
+/**
+ * struct scu_task_context - This structure defines the contents of the SCU
+ *    silicon task context. It lays out all of the fields according to the
+ *    expected order and location for the Storage Controller unit.
+ *
+ *
+ */
+struct scu_task_context {
+	/* OFFSET 0x00 ------ */
+	/**
+	 * This field must be encoded to one of the valid SCU task priority values
+	 *    - SCU_TASK_PRIORITY_NORMAL
+	 *    - SCU_TASK_PRIORITY_HEAD_OF_Q
+	 *    - SCU_TASK_PRIORITY_HIGH
+	 */
+	u32 priority:2;
+
+	/**
+	 * This field must be set to true if this is an initiator generated request.
+	 * Until target mode is supported all task requests are initiator requests.
+	 */
+	u32 initiator_request:1;
+
+	/**
+	 * This field must be set to one of the valid connection rates valid values
+	 * are 0x8, 0x9, and 0xA.
+	 */
+	u32 connection_rate:4;
+
+	/**
+	 * This field muse be programed when generating an SMP response since the SMP
+	 * connection remains open until the SMP response is generated.
+	 */
+	u32 protocol_engine_index:3;
+
+	/**
+	 * This field must contain the logical port for the task request.
+	 */
+	u32 logical_port_index:3;
+
+	/**
+	 * This field must be set to one of the SCU_TASK_CONTEXT_PROTOCOL values
+	 *    - SCU_TASK_CONTEXT_PROTOCOL_SMP
+	 *    - SCU_TASK_CONTEXT_PROTOCOL_SSP
+	 *    - SCU_TASK_CONTEXT_PROTOCOL_STP
+	 *    - SCU_TASK_CONTEXT_PROTOCOL_NONE
+	 */
+	u32 protocol_type:3;
+
+	/**
+	 * This filed must be set to the TCi allocated for this task
+	 */
+	u32 task_index:12;
+
+	/**
+	 * This field is reserved and must be set to 0x00
+	 */
+	u32 reserved_00_0:1;
+
+	/**
+	 * For a normal task request this must be set to 0.  If this is an abort of
+	 * this task request it must be set to 1.
+	 */
+	u32 abort:1;
+
+	/**
+	 * This field must be set to true for the SCU hardware to process the task.
+	 */
+	u32 valid:1;
+
+	/**
+	 * This field must be set to SCU_TASK_CONTEXT_TYPE
+	 */
+	u32 context_type:1;
+
+	/* OFFSET 0x04 */
+	/**
+	 * This field contains the RNi that is the target of this request.
+	 */
+	u32 remote_node_index:12;
+
+	/**
+	 * This field is programmed if this is a mirrored request, which we are not
+	 * using, in which case it is the RNi for the mirrored target.
+	 */
+	u32 mirrored_node_index:12;
+
+	/**
+	 * This field is programmed with the direction of the SATA reqeust
+	 *    - SCU_SATA_WRITE_DATA_DIRECTION
+	 *    - SCU_SATA_READ_DATA_DIRECTION
+	 */
+	u32 sata_direction:1;
+
+	/**
+	 * This field is programmsed with one of the following SCU_COMMAND_CODE
+	 *    - SCU_COMMAND_CODE_INITIATOR_NEW_TASK
+	 *    - SCU_COMMAND_CODE_ACTIVE_TASK
+	 *    - SCU_COMMAND_CODE_PRIMITIVE_SEQ_TASK
+	 *    - SCU_COMMAND_CODE_TARGET_RAW_FRAMES
+	 */
+	u32 command_code:2;
+
+	/**
+	 * This field is set to true if the remote node should be suspended.
+	 * This bit is only valid for SSP & SMP target devices.
+	 */
+	u32 suspend_node:1;
+
+	/**
+	 * This field is programmed with one of the following command type codes
+	 *
+	 * For SAS requests use the scu_ssp_task_type
+	 *    - SCU_TASK_TYPE_IOREAD
+	 *    - SCU_TASK_TYPE_IOWRITE
+	 *    - SCU_TASK_TYPE_SMP_REQUEST
+	 *    - SCU_TASK_TYPE_RESPONSE
+	 *    - SCU_TASK_TYPE_RAW_FRAME
+	 *    - SCU_TASK_TYPE_PRIMITIVE
+	 *
+	 * For SATA requests use the scu_sata_task_type
+	 *    - SCU_TASK_TYPE_DMA_IN
+	 *    - SCU_TASK_TYPE_FPDMAQ_READ
+	 *    - SCU_TASK_TYPE_PACKET_DMA_IN
+	 *    - SCU_TASK_TYPE_SATA_RAW_FRAME
+	 *    - SCU_TASK_TYPE_DMA_OUT
+	 *    - SCU_TASK_TYPE_FPDMAQ_WRITE
+	 *    - SCU_TASK_TYPE_PACKET_DMA_OUT
+	 */
+	u32 task_type:4;
+
+	/* OFFSET 0x08 */
+	/**
+	 * This field is reserved and the must be set to 0x00
+	 */
+	u32 link_layer_control:8; /* presently all reserved */
+
+	/**
+	 * This field is set to true when TLR is to be enabled
+	 */
+	u32 ssp_tlr_enable:1;
+
+	/**
+	 * This is field specifies if the SCU DMAs a response frame to host
+	 * memory for good response frames when operating in target mode.
+	 */
+	u32 dma_ssp_target_good_response:1;
+
+	/**
+	 * This field indicates if the SCU should DMA the response frame to
+	 * host memory.
+	 */
+	u32 do_not_dma_ssp_good_response:1;
+
+	/**
+	 * This field is set to true when strict ordering is to be enabled
+	 */
+	u32 strict_ordering:1;
+
+	/**
+	 * This field indicates the type of endianess to be utilized for the
+	 * frame.  command, task, and response frames utilized control_frame
+	 * set to 1.
+	 */
+	u32 control_frame:1;
+
+	/**
+	 * This field is reserved and the driver should set to 0x00
+	 */
+	u32 tl_control_reserved:3;
+
+	/**
+	 * This field is set to true when the SCU hardware task timeout control is to
+	 * be enabled
+	 */
+	u32 timeout_enable:1;
+
+	/**
+	 * This field is reserved and the driver should set it to 0x00
+	 */
+	u32 pts_control_reserved:7;
+
+	/**
+	 * This field should be set to true when block guard is to be enabled
+	 */
+	u32 block_guard_enable:1;
+
+	/**
+	 * This field is reserved and the driver should set to 0x00
+	 */
+	u32 sdma_control_reserved:7;
+
+	/* OFFSET 0x0C */
+	/**
+	 * This field is the address modifier for this io request it should be
+	 * programmed with the virtual function that is making the request.
+	 */
+	u32 address_modifier:16;
+
+	/**
+	 * @todo What we support mirrored SMP response frame?
+	 */
+	u32 mirrored_protocol_engine:3;  /* mirrored protocol Engine Index */
+
+	/**
+	 * If this is a mirrored request the logical port index for the mirrored RNi
+	 * must be programmed.
+	 */
+	u32 mirrored_logical_port:4;  /* mirrored local port index */
+
+	/**
+	 * This field is reserved and the driver must set it to 0x00
+	 */
+	u32 reserved_0C_0:8;
+
+	/**
+	 * This field must be set to true if the mirrored request processing is to be
+	 * enabled.
+	 */
+	u32 mirror_request_enable:1;  /* Mirrored request Enable */
+
+	/* OFFSET 0x10 */
+	/**
+	 * This field is the command iu length in dwords
+	 */
+	u32 ssp_command_iu_length:8;
+
+	/**
+	 * This is the target TLR enable bit it must be set to 0 when creatning the
+	 * task context.
+	 */
+	u32 xfer_ready_tlr_enable:1;
+
+	/**
+	 * This field is reserved and the driver must set it to 0x00
+	 */
+	u32 reserved_10_0:7;
+
+	/**
+	 * This is the maximum burst size that the SCU hardware will send in one
+	 * connection its value is (N x 512) and N must be a multiple of 2.  If the
+	 * value is 0x00 then maximum burst size is disabled.
+	 */
+	u32 ssp_max_burst_size:16;
+
+	/* OFFSET 0x14 */
+	/**
+	 * This filed is set to the number of bytes to be transfered in the request.
+	 */
+	u32 transfer_length_bytes:24; /* In terms of bytes */
+
+	/**
+	 * This field is reserved and the driver should set it to 0x00
+	 */
+	u32 reserved_14_0:8;
+
+	/* OFFSET 0x18-0x2C */
+	/**
+	 * This union provides for the protocol specif part of the SCU Task Context.
+	 */
+	union protocol_context type;
+
+	/* OFFSET 0x30-0x34 */
+	/**
+	 * This field is the upper 32 bits of the 64 bit physical address of the
+	 * command iu buffer
+	 */
+	u32 command_iu_upper;
+
+	/**
+	 * This field is the lower 32 bits of the 64 bit physical address of the
+	 * command iu buffer
+	 */
+	u32 command_iu_lower;
+
+	/* OFFSET 0x38-0x3C */
+	/**
+	 * This field is the upper 32 bits of the 64 bit physical address of the
+	 * response iu buffer
+	 */
+	u32 response_iu_upper;
+
+	/**
+	 * This field is the lower 32 bits of the 64 bit physical address of the
+	 * response iu buffer
+	 */
+	u32 response_iu_lower;
+
+	/* OFFSET 0x40 */
+	/**
+	 * This field is set to the task phase of the SCU hardware. The driver must
+	 * set this to 0x01
+	 */
+	u32 task_phase:8;
+
+	/**
+	 * This field is set to the transport layer task status.  The driver must set
+	 * this to 0x00
+	 */
+	u32 task_status:8;
+
+	/**
+	 * This field is used during initiator write TLR
+	 */
+	u32 previous_extended_tag:4;
+
+	/**
+	 * This field is set the maximum number of retries for a STP non-data FIS
+	 */
+	u32 stp_retry_count:2;
+
+	/**
+	 * This field is reserved and the driver must set it to 0x00
+	 */
+	u32 reserved_40_1:2;
+
+	/**
+	 * This field is used by the SCU TL to determine when to take a snapshot when
+	 * tranmitting read data frames.
+	 *    - 0x00 The entire IO
+	 *    - 0x01 32k
+	 *    - 0x02 64k
+	 *    - 0x04 128k
+	 *    - 0x08 256k
+	 */
+	u32 ssp_tlr_threshold:4;
+
+	/**
+	 * This field is reserved and the driver must set it to 0x00
+	 */
+	u32 reserved_40_2:4;
+
+	/* OFFSET 0x44 */
+	u32 write_data_length; /* read only set to 0 */
+
+	/* OFFSET 0x48-0x58 */
+	struct transport_snapshot snapshot; /* read only set to 0 */
+
+	/* OFFSET 0x5C */
+	u32 block_protection_enable:1;
+	u32 block_size:2;
+	u32 block_protection_function:2;
+	u32 reserved_5C_0:9;
+	u32 active_sgl_element:2;  /* read only set to 0 */
+	u32 sgl_exhausted:1;  /* read only set to 0 */
+	u32 payload_data_transfer_error:4;  /* read only set to 0 */
+	u32 frame_buffer_offset:11; /* read only set to 0 */
+
+	/* OFFSET 0x60-0x7C */
+	/**
+	 * This field is the first SGL element pair found in the TC data structure.
+	 */
+	struct scu_sgl_element_pair sgl_pair_ab;
+	/* OFFSET 0x80-0x9C */
+	/**
+	 * This field is the second SGL element pair found in the TC data structure.
+	 */
+	struct scu_sgl_element_pair sgl_pair_cd;
+
+	/* OFFSET 0xA0-BC */
+	struct scu_sgl_element_pair sgl_snapshot_ac;
+
+	/* OFFSET 0xC0 */
+	u32 active_sgl_element_pair; /* read only set to 0 */
+
+	/* OFFSET 0xC4-0xCC */
+	u32 reserved_C4_CC[3];
+
+	/* OFFSET 0xD0 */
+	u32 intermediate_crc_value:16;
+	u32 initial_crc_seed:16;
+
+	/* OFFSET 0xD4 */
+	u32 application_tag_for_verify:16;
+	u32 application_tag_for_generate:16;
+
+	/* OFFSET 0xD8 */
+	u32 reference_tag_seed_for_verify_function;
+
+	/* OFFSET 0xDC */
+	u32 reserved_DC;
+
+	/* OFFSET 0xE0 */
+	u32 reserved_E0_0:16;
+	u32 application_tag_mask_for_generate:16;
+
+	/* OFFSET 0xE4 */
+	u32 block_protection_control:16;
+	u32 application_tag_mask_for_verify:16;
+
+	/* OFFSET 0xE8 */
+	u32 block_protection_error:8;
+	u32 reserved_E8_0:24;
+
+	/* OFFSET 0xEC */
+	u32 reference_tag_seed_for_verify;
+
+	/* OFFSET 0xF0 */
+	u32 intermediate_crc_valid_snapshot:16;
+	u32 reserved_F0_0:16;
+
+	/* OFFSET 0xF4 */
+	u32 reference_tag_seed_for_verify_function_snapshot;
+
+	/* OFFSET 0xF8 */
+	u32 snapshot_of_reserved_dword_DC_of_tc;
+
+	/* OFFSET 0xFC */
+	u32 reference_tag_seed_for_generate_function_snapshot;
+
+};
+
+#endif /* _SCU_TASK_CONTEXT_H_ */
diff --git a/drivers/scsi/isci/scu_unsolicited_frame.h b/drivers/scsi/isci/scu_unsolicited_frame.h
new file mode 100644
index 0000000..187c4f0
--- /dev/null
+++ b/drivers/scsi/isci/scu_unsolicited_frame.h
@@ -0,0 +1,117 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * This field defines the SCU format of an unsolicited frame (UF).  A UF is a
+ *    frame received by the SCU for which there is no known corresponding task
+ *    context (TC).
+ *
+ *
+ */
+
+#ifndef _SCU_UNSOLICITED_FRAME_H_
+#define _SCU_UNSOLICITED_FRAME_H_
+
+#include <linux/string.h>
+
+/**
+ *
+ *
+ * This constant defines the number of DWORDS found the unsolicited frame
+ * header data member.
+ */
+#define SCU_UNSOLICITED_FRAME_HEADER_DATA_DWORDS 15
+
+/**
+ * struct scu_unsolicited_frame_header -
+ *
+ * This structure delineates the format of an unsolicited frame header. The
+ * first DWORD are UF attributes defined by the silicon architecture. The data
+ * depicts actual header information received on the link.
+ */
+struct scu_unsolicited_frame_header {
+	/**
+	 * This field indicates if there is an Initiator Index Table entry with
+	 * which this header is associated.
+	 */
+	u32 iit_exists:1;
+
+	/**
+	 * This field simply indicates the protocol type (i.e. SSP, STP, SMP).
+	 */
+	u32 protocol_type:3;
+
+	/**
+	 * This field indicates if the frame is an address frame (IAF or OAF)
+	 * or if it is a information unit frame.
+	 */
+	u32 is_address_frame:1;
+
+	/**
+	 * This field simply indicates the connection rate at which the frame
+	 * was received.
+	 */
+	u32 connection_rate:4;
+
+	u32 reserved:23;
+
+	/**
+	 * This field represents the actual header data received on the link.
+	 */
+	u32 data[SCU_UNSOLICITED_FRAME_HEADER_DATA_DWORDS];
+
+};
+
+#endif /* _SCU_UNSOLICITED_FRAME_H_ */
diff --git a/drivers/scsi/isci/unsolicited_frame_control.c b/drivers/scsi/isci/unsolicited_frame_control.c
new file mode 100644
index 0000000..8d68dcc
--- /dev/null
+++ b/drivers/scsi/isci/unsolicited_frame_control.c
@@ -0,0 +1,357 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "host.h"
+#include "unsolicited_frame_control.h"
+#include "registers.h"
+#include "sci_util.h"
+
+/**
+ * This method will program the unsolicited frames (UFs) into the UF address
+ *    table and construct the UF frame structure being modeled in the core.  It
+ *    will handle the case where some of the UFs are not being used and thus
+ *    should have entries programmed to zero in the address table.
+ * @uf_control: This parameter specifies the unsolicted frame control object
+ *    for which to construct the unsolicited frames objects.
+ * @uf_buffer_phys_address: This parameter specifies the physical address for
+ *    the first unsolicited frame buffer.
+ * @uf_buffer_virt_address: This parameter specifies the virtual address for
+ *    the first unsolicited frame buffer.
+ * @unused_uf_header_entries: This parameter specifies the number of unused UF
+ *    headers.  This value can be non-zero when there are a non-power of 2
+ *    number of unsolicited frames being supported.
+ * @used_uf_header_entries: This parameter specifies the number of actually
+ *    utilized UF headers.
+ *
+ */
+static void scic_sds_unsolicited_frame_control_construct_frames(
+	struct scic_sds_unsolicited_frame_control *uf_control,
+	dma_addr_t uf_buffer_phys_address,
+	void *uf_buffer_virt_address,
+	u32 unused_uf_header_entries,
+	u32 used_uf_header_entries)
+{
+	u32 index;
+	struct scic_sds_unsolicited_frame *uf;
+
+	/*
+	 * Program the unused buffers into the UF address table and the
+	 * controller's array of UFs.
+	 */
+	for (index = 0; index < unused_uf_header_entries; index++) {
+		uf = &uf_control->buffers.array[index];
+
+		sci_cb_make_physical_address(
+			uf_control->address_table.array[index], 0, 0
+			);
+		uf->buffer = NULL;
+		uf->header = &uf_control->headers.array[index];
+		uf->state  = UNSOLICITED_FRAME_EMPTY;
+	}
+
+	/*
+	 * Program the actual used UF buffers into the UF address table and
+	 * the controller's array of UFs.
+	 */
+	for (index = unused_uf_header_entries;
+	     index < unused_uf_header_entries + used_uf_header_entries;
+	     index++) {
+		uf = &uf_control->buffers.array[index];
+
+		uf_control->address_table.array[index] = uf_buffer_phys_address;
+
+		uf->buffer = uf_buffer_virt_address;
+		uf->header = &uf_control->headers.array[index];
+		uf->state  = UNSOLICITED_FRAME_EMPTY;
+
+		/*
+		 * Increment the address of the physical and virtual memory
+		 * pointers. Everything is aligned on 1k boundary with an
+		 * increment of 1k.
+		 */
+		uf_buffer_virt_address += SCU_UNSOLICITED_FRAME_BUFFER_SIZE;
+		uf_buffer_phys_address += SCU_UNSOLICITED_FRAME_BUFFER_SIZE;
+	}
+}
+
+int scic_sds_unsolicited_frame_control_construct(struct scic_sds_controller *scic)
+{
+	struct scic_sds_unsolicited_frame_control *uf_control = &scic->uf_control;
+	u32 unused_uf_header_entries;
+	u32 used_uf_header_entries;
+	u32 used_uf_buffer_bytes;
+	u32 unused_uf_header_bytes;
+	u32 used_uf_header_bytes;
+	dma_addr_t uf_buffer_phys_address;
+	void *uf_buffer_virt_address;
+	size_t size;
+
+	/*
+	 * The UF buffer address table size must be programmed to a power
+	 * of 2.  Find the first power of 2 that is equal to or greater then
+	 * the number of unsolicited frame buffers to be utilized.
+	 */
+	uf_control->address_table.count = SCU_MIN_UF_TABLE_ENTRIES;
+	while (uf_control->address_table.count < uf_control->buffers.count &&
+	       uf_control->address_table.count < SCU_ABSOLUTE_MAX_UNSOLICITED_FRAMES)
+		uf_control->address_table.count <<= 1;
+
+	/*
+	 * Prepare all of the memory sizes for the UF headers, UF address
+	 * table, and UF buffers themselves.
+	 */
+	used_uf_buffer_bytes     = uf_control->buffers.count
+				   * SCU_UNSOLICITED_FRAME_BUFFER_SIZE;
+	unused_uf_header_entries = uf_control->address_table.count
+				   - uf_control->buffers.count;
+	used_uf_header_entries   = uf_control->buffers.count;
+	unused_uf_header_bytes   = unused_uf_header_entries
+				   * sizeof(struct scu_unsolicited_frame_header);
+	used_uf_header_bytes     = used_uf_header_entries
+				   * sizeof(struct scu_unsolicited_frame_header);
+
+	size = used_uf_buffer_bytes + used_uf_header_bytes +
+			uf_control->address_table.count * sizeof(dma_addr_t);
+
+
+	/*
+	 * The Unsolicited Frame buffers are set at the start of the UF
+	 * memory descriptor entry. The headers and address table will be
+	 * placed after the buffers.
+	 */
+	uf_buffer_virt_address = dmam_alloc_coherent(scic_to_dev(scic), size,
+							&uf_buffer_phys_address, GFP_KERNEL);
+	if (!uf_buffer_virt_address)
+		return -ENOMEM;
+
+	/*
+	 * Program the location of the UF header table into the SCU.
+	 * Notes:
+	 * - The address must align on a 64-byte boundary. Guaranteed to be
+	 *   on 64-byte boundary already 1KB boundary for unsolicited frames.
+	 * - Program unused header entries to overlap with the last
+	 *   unsolicited frame.  The silicon will never DMA to these unused
+	 *   headers, since we program the UF address table pointers to
+	 *   NULL.
+	 */
+	uf_control->headers.physical_address =
+				uf_buffer_phys_address +
+				used_uf_buffer_bytes -
+				unused_uf_header_bytes;
+
+	uf_control->headers.array =
+				uf_buffer_virt_address +
+				used_uf_buffer_bytes -
+				unused_uf_header_bytes;
+
+	/*
+	 * Program the location of the UF address table into the SCU.
+	 * Notes:
+	 * - The address must align on a 64-bit boundary. Guaranteed to be on 64
+	 *   byte boundary already due to above programming headers being on a
+	 *   64-bit boundary and headers are on a 64-bytes in size.
+	 */
+	uf_control->address_table.physical_address =
+				uf_buffer_phys_address +
+				used_uf_buffer_bytes +
+				used_uf_header_bytes;
+
+	uf_control->address_table.array =
+				uf_buffer_virt_address +
+				used_uf_buffer_bytes +
+				used_uf_header_bytes;
+
+	uf_control->get = 0;
+
+	/*
+	 * UF buffer requirements are:
+	 * - The last entry in the UF queue is not NULL.
+	 * - There is a power of 2 number of entries (NULL or not-NULL)
+	 *   programmed into the queue.
+	 * - Aligned on a 1KB boundary. */
+
+	/*
+	 * If the user provided less then the maximum amount of memory,
+	 * then be sure that we programm the first entries in the UF
+	 * address table to NULL. */
+	scic_sds_unsolicited_frame_control_construct_frames(
+		uf_control,
+		uf_buffer_phys_address,
+		uf_buffer_virt_address,
+		unused_uf_header_entries,
+		used_uf_header_entries
+		);
+
+	return 0;
+}
+
+/**
+ * This method returns the frame header for the specified frame index.
+ * @uf_control:
+ * @frame_index:
+ * @frame_header:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_unsolicited_frame_control_get_header(
+	struct scic_sds_unsolicited_frame_control *uf_control,
+	u32 frame_index,
+	void **frame_header)
+{
+	if (frame_index < uf_control->address_table.count) {
+		/*
+		 * Skip the first word in the frame since this is a controll word used
+		 * by the hardware. */
+		*frame_header = &uf_control->buffers.array[frame_index].header->data;
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE_INVALID_PARAMETER_VALUE;
+}
+
+/**
+ * This method returns the frame buffer for the specified frame index.
+ * @uf_control:
+ * @frame_index:
+ * @frame_buffer:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_unsolicited_frame_control_get_buffer(
+	struct scic_sds_unsolicited_frame_control *uf_control,
+	u32 frame_index,
+	void **frame_buffer)
+{
+	if (frame_index < uf_control->address_table.count) {
+		*frame_buffer = uf_control->buffers.array[frame_index].buffer;
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE_INVALID_PARAMETER_VALUE;
+}
+
+/**
+ * This method releases the frame once this is done the frame is available for
+ *    re-use by the hardware.  The data contained in the frame header and frame
+ *    buffer is no longer valid.
+ * @uf_control: This parameter specifies the UF control object
+ * @frame_index: This parameter specifies the frame index to attempt to release.
+ *
+ * This method returns an indication to the caller as to whether the
+ * unsolicited frame get pointer should be updated.
+ */
+bool scic_sds_unsolicited_frame_control_release_frame(
+	struct scic_sds_unsolicited_frame_control *uf_control,
+	u32 frame_index)
+{
+	u32 frame_get;
+	u32 frame_cycle;
+
+	frame_get   = uf_control->get & (uf_control->address_table.count - 1);
+	frame_cycle = uf_control->get & uf_control->address_table.count;
+
+	/*
+	 * In the event there are NULL entries in the UF table, we need to
+	 * advance the get pointer in order to find out if this frame should
+	 * be released (i.e. update the get pointer). */
+	while (((lower_32_bits(uf_control->address_table.array[frame_get])
+					== 0) &&
+		(upper_32_bits(uf_control->address_table.array[frame_get])
+					== 0)) &&
+	       (frame_get < uf_control->address_table.count))
+		frame_get++;
+
+	/*
+	 * The table has a NULL entry as it's last element.  This is
+	 * illegal. */
+	BUG_ON(frame_get >= uf_control->address_table.count);
+
+	if (frame_index < uf_control->address_table.count) {
+		uf_control->buffers.array[frame_index].state = UNSOLICITED_FRAME_RELEASED;
+
+		/*
+		 * The frame index is equal to the current get pointer so we
+		 * can now free up all of the frame entries that */
+		if (frame_get == frame_index) {
+			while (
+				uf_control->buffers.array[frame_get].state
+				== UNSOLICITED_FRAME_RELEASED
+				) {
+				uf_control->buffers.array[frame_get].state = UNSOLICITED_FRAME_EMPTY;
+
+				INCREMENT_QUEUE_GET(
+					frame_get,
+					frame_cycle,
+					uf_control->address_table.count - 1,
+					uf_control->address_table.count
+					);
+			}
+
+			uf_control->get =
+				(SCU_UFQGP_GEN_BIT(ENABLE_BIT) | frame_cycle | frame_get);
+
+			return true;
+		} else {
+			/*
+			 * Frames remain in use until we advance the get pointer
+			 * so there is nothing we can do here */
+		}
+	}
+
+	return false;
+}
+
diff --git a/drivers/scsi/isci/unsolicited_frame_control.h b/drivers/scsi/isci/unsolicited_frame_control.h
new file mode 100644
index 0000000..0d8ca8c
--- /dev/null
+++ b/drivers/scsi/isci/unsolicited_frame_control.h
@@ -0,0 +1,251 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _SCIC_SDS_UNSOLICITED_FRAME_CONTROL_H_
+#define _SCIC_SDS_UNSOLICITED_FRAME_CONTROL_H_
+
+#include "isci.h"
+#include "scu_unsolicited_frame.h"
+
+/**
+ * enum unsolicited_frame_state -
+ *
+ * This enumeration represents the current unsolicited frame state.  The
+ * controller object can not updtate the hardware unsolicited frame put pointer
+ * unless it has already processed the priror unsolicited frames.
+ */
+enum unsolicited_frame_state {
+	/**
+	 * This state is when the frame is empty and not in use.  It is
+	 * different from the released state in that the hardware could DMA
+	 * data to this frame buffer.
+	 */
+	UNSOLICITED_FRAME_EMPTY,
+
+	/**
+	 * This state is set when the frame buffer is in use by by some
+	 * object in the system.
+	 */
+	UNSOLICITED_FRAME_IN_USE,
+
+	/**
+	 * This state is set when the frame is returned to the free pool
+	 * but one or more frames prior to this one are still in use.
+	 * Once all of the frame before this one are freed it will go to
+	 * the empty state.
+	 */
+	UNSOLICITED_FRAME_RELEASED,
+
+	UNSOLICITED_FRAME_MAX_STATES
+};
+
+/**
+ * struct scic_sds_unsolicited_frame -
+ *
+ * This is the unsolicited frame data structure it acts as the container for
+ * the current frame state, frame header and frame buffer.
+ */
+struct scic_sds_unsolicited_frame {
+	/**
+	 * This field contains the current frame state
+	 */
+	enum unsolicited_frame_state state;
+
+	/**
+	 * This field points to the frame header data.
+	 */
+	struct scu_unsolicited_frame_header *header;
+
+	/**
+	 * This field points to the frame buffer data.
+	 */
+	void *buffer;
+
+};
+
+/**
+ * struct scic_sds_uf_header_array -
+ *
+ * This structure contains all of the unsolicited frame header information.
+ */
+struct scic_sds_uf_header_array {
+	/**
+	 * This field is represents a virtual pointer to the start
+	 * address of the UF address table.  The table contains
+	 * 64-bit pointers as required by the hardware.
+	 */
+	struct scu_unsolicited_frame_header *array;
+
+	/**
+	 * This field specifies the physical address location for the UF
+	 * buffer array.
+	 */
+	dma_addr_t physical_address;
+
+};
+
+/**
+ * struct scic_sds_uf_buffer_array -
+ *
+ * This structure contains all of the unsolicited frame buffer (actual payload)
+ * information.
+ */
+struct scic_sds_uf_buffer_array {
+	/**
+	 * This field is the minimum number of unsolicited frames supported by the
+	 * hardware and the number of unsolicited frames requested by the software.
+	 */
+	u32 count;
+
+	/**
+	 * This field is the SCIC_UNSOLICITED_FRAME data its used to manage
+	 * the data for the unsolicited frame requests.  It also represents
+	 * the virtual address location that corresponds to the
+	 * physical_address field.
+	 */
+	struct scic_sds_unsolicited_frame array[SCU_UNSOLICITED_FRAME_CONTROL_ARRAY_SIZE];
+
+	/**
+	 * This field specifies the physical address location for the UF
+	 * buffer array.
+	 */
+	dma_addr_t physical_address;
+
+};
+
+/**
+ * struct scic_sds_uf_address_table_array -
+ *
+ * This object maintains all of the unsolicited frame address table specific
+ * data.  The address table is a collection of 64-bit pointers that point to
+ * 1KB buffers into which the silicon will DMA unsolicited frames.
+ */
+struct scic_sds_uf_address_table_array {
+	/**
+	 * This field specifies the actual programmed size of the
+	 * unsolicited frame buffer address table.  The size of the table
+	 * can be larger than the actual number of UF buffers, but it must
+	 * be a power of 2 and the last entry in the table is not allowed
+	 * to be NULL.
+	 */
+	u32 count;
+
+	/**
+	 * This field represents a virtual pointer that refers to the
+	 * starting address of the UF address table.
+	 * 64-bit pointers are required by the hardware.
+	 */
+	dma_addr_t *array;
+
+	/**
+	 * This field specifies the physical address location for the UF
+	 * address table.
+	 */
+	dma_addr_t physical_address;
+
+};
+
+/**
+ * struct scic_sds_unsolicited_frame_control -
+ *
+ * This object contains all of the data necessary to handle unsolicited frames.
+ */
+struct scic_sds_unsolicited_frame_control {
+	/**
+	 * This field is the software copy of the unsolicited frame queue
+	 * get pointer.  The controller object writes this value to the
+	 * hardware to let the hardware put more unsolicited frame entries.
+	 */
+	u32 get;
+
+	/**
+	 * This field contains all of the unsolicited frame header
+	 * specific fields.
+	 */
+	struct scic_sds_uf_header_array headers;
+
+	/**
+	 * This field contains all of the unsolicited frame buffer
+	 * specific fields.
+	 */
+	struct scic_sds_uf_buffer_array buffers;
+
+	/**
+	 * This field contains all of the unsolicited frame address table
+	 * specific fields.
+	 */
+	struct scic_sds_uf_address_table_array address_table;
+
+};
+
+struct scic_sds_controller;
+
+int scic_sds_unsolicited_frame_control_construct(struct scic_sds_controller *scic);
+
+enum sci_status scic_sds_unsolicited_frame_control_get_header(
+	struct scic_sds_unsolicited_frame_control *uf_control,
+	u32 frame_index,
+	void **frame_header);
+
+enum sci_status scic_sds_unsolicited_frame_control_get_buffer(
+	struct scic_sds_unsolicited_frame_control *uf_control,
+	u32 frame_index,
+	void **frame_buffer);
+
+bool scic_sds_unsolicited_frame_control_release_frame(
+	struct scic_sds_unsolicited_frame_control *uf_control,
+	u32 frame_index);
+
+#endif /* _SCIC_SDS_UNSOLICITED_FRAME_CONTROL_H_ */
-- 
1.6.0.2

