Subject: [PATCH] crypto: nx - add offset to nx_build_sg_lists()
From: Marcelo Cerri <mhcerri@linux.vnet.ibm.com>
Git-commit: a8fc391a15957e2f2871c4ea3f6e84c33095c374
Patch-mainline: v3.10-5905-ga8fc391
References: fate#317629

This patch includes one more parameter to nx_build_sg_lists() to skip
the given number of bytes from beginning of each sg list.

This is needed in order to implement the fixes for the AES modes to make
them able to process larger chunks of data.

Reviewed-by: Joy Latten <jmlatten@linux.vnet.ibm.com>
Signed-off-by: Marcelo Cerri <mhcerri@linux.vnet.ibm.com>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
Acked-by: Dinar Valeev <dvaleev@suse.com>
---
 drivers/crypto/nx/nx-aes-cbc.c | 2 +-
 drivers/crypto/nx/nx-aes-ccm.c | 4 ++--
 drivers/crypto/nx/nx-aes-ctr.c | 2 +-
 drivers/crypto/nx/nx-aes-ecb.c | 2 +-
 drivers/crypto/nx/nx-aes-gcm.c | 2 +-
 drivers/crypto/nx/nx.c         | 9 +++++++--
 drivers/crypto/nx/nx.h         | 2 +-
 7 files changed, 14 insertions(+), 9 deletions(-)

Index: linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-ecb.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/crypto/nx/nx-aes-ecb.c
+++ linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-ecb.c
@@ -85,7 +85,7 @@ static int ecb_aes_nx_crypt(struct blkci
 	else
 		NX_CPB_FDM(csbcpb) &= ~NX_FDM_ENDE_ENCRYPT;
 
-	rc = nx_build_sg_lists(nx_ctx, desc, dst, src, nbytes, NULL);
+	rc = nx_build_sg_lists(nx_ctx, desc, dst, src, nbytes, 0, NULL);
 	if (rc)
 		goto out;
 
Index: linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-gcm.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/crypto/nx/nx-aes-gcm.c
+++ linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-gcm.c
@@ -226,7 +226,7 @@ static int gcm_aes_nx_crypt(struct aead_
 
 	csbcpb->cpb.aes_gcm.bit_length_data = nbytes * 8;
 
-	rc = nx_build_sg_lists(nx_ctx, &desc, req->dst, req->src, nbytes,
+	rc = nx_build_sg_lists(nx_ctx, &desc, req->dst, req->src, nbytes, 0,
 			       csbcpb->cpb.aes_gcm.iv_or_cnt);
 	if (rc)
 		goto out;
Index: linux-3.0-SLE11-SP4/drivers/crypto/nx/nx.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/crypto/nx/nx.c
+++ linux-3.0-SLE11-SP4/drivers/crypto/nx/nx.c
@@ -212,6 +212,8 @@ struct nx_sg *nx_walk_and_build(struct n
  * @dst: destination scatterlist
  * @src: source scatterlist
  * @nbytes: length of data described in the scatterlists
+ * @offset: number of bytes to fast-forward past at the beginning of
+ *          scatterlists.
  * @iv: destination for the iv data, if the algorithm requires it
  *
  * This is common code shared by all the AES algorithms. It uses the block
@@ -223,6 +225,7 @@ int nx_build_sg_lists(struct nx_crypto_c
 		      struct scatterlist    *dst,
 		      struct scatterlist    *src,
 		      unsigned int           nbytes,
+		      unsigned int           offset,
 		      u8                    *iv)
 {
 	struct nx_sg *nx_insg = nx_ctx->in_sg;
@@ -231,8 +234,10 @@ int nx_build_sg_lists(struct nx_crypto_c
 	if (iv)
 		memcpy(iv, desc->info, AES_BLOCK_SIZE);
 
-	nx_insg = nx_walk_and_build(nx_insg, nx_ctx->ap->sglen, src, 0, nbytes);
-	nx_outsg = nx_walk_and_build(nx_outsg, nx_ctx->ap->sglen, dst, 0, nbytes);
+	nx_insg = nx_walk_and_build(nx_insg, nx_ctx->ap->sglen, src,
+				    offset, nbytes);
+	nx_outsg = nx_walk_and_build(nx_outsg, nx_ctx->ap->sglen, dst,
+				    offset, nbytes);
 
 	/* these lengths should be negative, which will indicate to phyp that
 	 * the input and output parameters are scatterlists, not linear
Index: linux-3.0-SLE11-SP4/drivers/crypto/nx/nx.h
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/crypto/nx/nx.h
+++ linux-3.0-SLE11-SP4/drivers/crypto/nx/nx.h
@@ -156,7 +156,7 @@ int nx_hcall_sync(struct nx_crypto_ctx *
 struct nx_sg *nx_build_sg_list(struct nx_sg *, u8 *, unsigned int, u32);
 int nx_build_sg_lists(struct nx_crypto_ctx *, struct blkcipher_desc *,
 		      struct scatterlist *, struct scatterlist *, unsigned int,
-		      u8 *);
+		      unsigned int, u8 *);
 struct nx_sg *nx_walk_and_build(struct nx_sg *, unsigned int,
 				struct scatterlist *, unsigned int,
 				unsigned int);
Index: linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-cbc.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/crypto/nx/nx-aes-cbc.c
+++ linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-cbc.c
@@ -85,7 +85,7 @@ static int cbc_aes_nx_crypt(struct blkci
 	else
 		NX_CPB_FDM(csbcpb) &= ~NX_FDM_ENDE_ENCRYPT;
 
-	rc = nx_build_sg_lists(nx_ctx, desc, dst, src, nbytes,
+	rc = nx_build_sg_lists(nx_ctx, desc, dst, src, nbytes, 0,
 			       csbcpb->cpb.aes_cbc.iv);
 	if (rc)
 		goto out;
Index: linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-ccm.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/crypto/nx/nx-aes-ccm.c
+++ linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-ccm.c
@@ -293,7 +293,7 @@ static int ccm_nx_decrypt(struct aead_re
 	if (rc)
 		goto out;
 
-	rc = nx_build_sg_lists(nx_ctx, desc, req->dst, req->src, nbytes,
+	rc = nx_build_sg_lists(nx_ctx, desc, req->dst, req->src, nbytes, 0,
 			       csbcpb->cpb.aes_ccm.iv_or_ctr);
 	if (rc)
 		goto out;
@@ -339,7 +339,7 @@ static int ccm_nx_encrypt(struct aead_re
 	if (rc)
 		goto out;
 
-	rc = nx_build_sg_lists(nx_ctx, desc, req->dst, req->src, nbytes,
+	rc = nx_build_sg_lists(nx_ctx, desc, req->dst, req->src, nbytes, 0,
 			       csbcpb->cpb.aes_ccm.iv_or_ctr);
 	if (rc)
 		goto out;
Index: linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-ctr.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/crypto/nx/nx-aes-ctr.c
+++ linux-3.0-SLE11-SP4/drivers/crypto/nx/nx-aes-ctr.c
@@ -98,7 +98,7 @@ static int ctr_aes_nx_crypt(struct blkci
 		goto out;
 	}
 
-	rc = nx_build_sg_lists(nx_ctx, desc, dst, src, nbytes,
+	rc = nx_build_sg_lists(nx_ctx, desc, dst, src, nbytes, 0,
 			       csbcpb->cpb.aes_ctr.iv);
 	if (rc)
 		goto out;
