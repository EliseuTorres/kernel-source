From: Tomas Winkler <tomas.winkler@intel.com>
Subject: mei: ME hardware reset needs to be synchronized
References: bnc#821619
Patch-mainline: v3.9
Git-commit: 68f8ea184bf7a552b59a38c4b0c7dc243822d2d5

This fixes failure during initialization on Lynx Point LP devices.

ME driver needs to release the device from the reset
only after the FW has completed its flow and indicated
it by delivering an interrupt to the host.

This is the correct behavior for all the ME devices yet the
the previous versions are less susceptive to the implementation
that ignored FW reset completion indication.

We add mei_me_hw_reset_release function which is called
after reset from the interrupt thread or directly
from mei_reset during power down.
    
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

Backported to the SLE11 SP3 kernel by Lin Wang <lin.x.wang@intel.com>.

Acked-by: Jean Delvare <jdelvare@suse.de>

diff -uNr /home/workspace/source/linux-3.0.76-0.11/drivers/misc/mei//init.c mei//init.c
--- linux-3.0.76-0.11/drivers/misc/mei/init.c	2013-07-03 16:30:32.000000000 +0800
+++ linux-3.0.76-0.11/drivers/misc/mei/init.c	2013-07-08 16:11:10.000000000 +0800
@@ -247,6 +247,24 @@
 	return ret;
 }
 
+
+/**
+ * mei_hw_reset_release - release device from the reset
+ *
+ * @dev: the device structure
+ */
+void mei_hw_reset_release(struct mei_device *dev)
+{
+	u32 hcsr = mei_hcsr_read(dev);
+
+	hcsr |= H_IG;
+	hcsr &= ~H_RST;
+	hcsr &= ~H_IS;
+
+	mei_reg_write(dev, H_CSR, hcsr);
+	dev->host_hw_state = mei_hcsr_read(dev);
+}
+
 /**
  * mei_hw_reset - resets fw via mei csr register.
  *
@@ -261,6 +279,9 @@
 		mei_enable_interrupts(dev);
 	else
 		mei_disable_interrupts(dev);
+
+	if (dev->dev_state == MEI_DEV_POWER_DOWN)
+		mei_hw_reset_release(dev);
 }
 
 /**
@@ -294,11 +315,6 @@
 
 	mei_hw_reset(dev, interrupts_enabled);
 
-	dev->host_hw_state &= ~H_RST;
-	dev->host_hw_state |= H_IG;
-
-	mei_hcsr_set(dev);
-
 	dev_dbg(&dev->pdev->dev, "currently saved host_hw_state = 0x%08x.\n",
 	    dev->host_hw_state);
 
diff -uNr /home/workspace/source/linux-3.0.76-0.11/drivers/misc/mei//interrupt.c mei//interrupt.c
--- linux-3.0.76-0.11/drivers/misc/mei/interrupt.c	2013-07-03 16:30:32.000000000 +0800
+++ linux-3.0.76-0.11/drivers/misc/mei/interrupt.c	2013-07-08 14:42:24.000000000 +0800
@@ -1497,7 +1497,8 @@
 			mutex_unlock(&dev->device_lock);
 			return IRQ_HANDLED;
 		} else {
-			dev_dbg(&dev->pdev->dev, "FW not ready.\n");
+			dev_dbg(&dev->pdev->dev, "mei: F/W reset complete.\n");
+			mei_hw_reset_release(dev);
 			mutex_unlock(&dev->device_lock);
 			return IRQ_HANDLED;
 		}
diff -uNr /home/workspace/source/linux-3.0.76-0.11/drivers/misc/mei//mei_dev.h mei//mei_dev.h
--- linux-3.0.76-0.11/drivers/misc/mei/mei_dev.h	2013-07-03 16:30:32.000000000 +0800
+++ linux-3.0.76-0.11/drivers/misc/mei/mei_dev.h	2013-07-03 18:08:09.000000000 +0800
@@ -437,4 +437,9 @@
 void mei_enable_interrupts(struct mei_device *dev);
 void mei_disable_interrupts(struct mei_device *dev);
 
+/*
+ * mei hw reset function
+ */
+void mei_hw_reset_release(struct mei_device *dev);
+
 #endif
