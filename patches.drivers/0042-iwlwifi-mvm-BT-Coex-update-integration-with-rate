From ffa6c7077c3f7a433312b733688b9b14f38de17e Mon Sep 17 00:00:00 2001
From: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
Date: Sun, 6 Oct 2013 11:41:20 +0300
Subject: [PATCH 42/50] iwlwifi: mvm: BT Coex - update integration with rate control
Git-commit: ffa6c7077c3f7a433312b733688b9b14f38de17e
Patch-mainline: 3.13-rc1
References: FATE#316958

Remove code that is not needed and always allow MIMO when
in tight mode. In loose mode, we should avoid MIMO since BT
can use the other antenna to Rx while we Tx.

Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
Signed-off-by: Johannes Berg <johannes.berg@intel.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/net/wireless/iwlwifi/mvm/bt-coex.c |   18 +++++++++++
 drivers/net/wireless/iwlwifi/mvm/mvm.h     |    3 +
 drivers/net/wireless/iwlwifi/mvm/rs.c      |   45 +----------------------------
 3 files changed, 23 insertions(+), 43 deletions(-)

--- a/drivers/net/wireless/iwlwifi/mvm/bt-coex.c
+++ b/drivers/net/wireless/iwlwifi/mvm/bt-coex.c
@@ -921,6 +921,24 @@ u16 iwl_mvm_bt_coex_agg_time_limit(struc
 	return LINK_QUAL_AGG_TIME_LIMIT_BT_ACT;
 }
 
+bool iwl_mvm_bt_coex_is_mimo_allowed(struct iwl_mvm *mvm,
+				     struct ieee80211_sta *sta)
+{
+	struct iwl_mvm_sta *mvmsta = (void *)sta->drv_priv;
+
+	if (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading) <
+	    BT_HIGH_TRAFFIC)
+		return true;
+
+	/*
+	 * In Tight, BT can't Rx while we Tx, so use both antennas since BT is
+	 * already killed.
+	 * In Loose, BT can Rx while we Tx, so forbid MIMO to let BT Rx while we
+	 * Tx.
+	 */
+	return iwl_get_coex_type(mvm, mvmsta->vif) == BT_COEX_TIGHT_LUT;
+}
+
 void iwl_mvm_bt_coex_vif_change(struct iwl_mvm *mvm)
 {
 	if (!(mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_NEWBT_COEX))
--- a/drivers/net/wireless/iwlwifi/mvm/mvm.h
+++ b/drivers/net/wireless/iwlwifi/mvm/mvm.h
@@ -820,6 +820,9 @@ void iwl_mvm_bt_rssi_event(struct iwl_mv
 void iwl_mvm_bt_coex_vif_change(struct iwl_mvm *mvm);
 u16 iwl_mvm_bt_coex_agg_time_limit(struct iwl_mvm *mvm,
 				   struct ieee80211_sta *sta);
+bool iwl_mvm_bt_coex_is_mimo_allowed(struct iwl_mvm *mvm,
+				     struct ieee80211_sta *sta);
+
 enum iwl_bt_kill_msk {
 	BT_KILL_MSK_DEFAULT,
 	BT_KILL_MSK_SCO_HID_A2DP,
--- a/drivers/net/wireless/iwlwifi/mvm/rs.c
+++ b/drivers/net/wireless/iwlwifi/mvm/rs.c
@@ -1402,29 +1402,9 @@ static int rs_move_siso_to_other(struct
 	u8 update_search_tbl_counter = 0;
 	int ret;
 
-	switch (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading)) {
-	case IWL_BT_COEX_TRAFFIC_LOAD_NONE:
-		/* nothing */
-		break;
-	case IWL_BT_COEX_TRAFFIC_LOAD_LOW:
-		/* avoid switching to antenna B but allow MIMO */
-		if (tbl->action == IWL_SISO_SWITCH_ANTENNA &&
-		    tbl->ant_type == ANT_A)
-			tbl->action = IWL_SISO_SWITCH_MIMO2;
-		break;
-	case IWL_BT_COEX_TRAFFIC_LOAD_HIGH:
-	case IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:
-		/* A - avoid antenna B and MIMO. B - switch to A */
-		if (tbl->ant_type == ANT_A)
-			valid_tx_ant =
-				first_antenna(iwl_fw_valid_tx_ant(mvm->fw));
+	if (tbl->action == IWL_SISO_SWITCH_MIMO2 &&
+	    !iwl_mvm_bt_coex_is_mimo_allowed(mvm, sta))
 		tbl->action = IWL_SISO_SWITCH_ANTENNA;
-		break;
-	default:
-		IWL_ERR(mvm, "Invalid BT load %d",
-			le32_to_cpu(mvm->last_bt_notif.bt_activity_grading));
-		break;
-	}
 
 	start_action = tbl->action;
 	while (1) {
@@ -1519,27 +1499,6 @@ static int rs_move_mimo2_to_other(struct
 	u8 update_search_tbl_counter = 0;
 	int ret;
 
-	switch (le32_to_cpu(mvm->last_bt_notif.bt_activity_grading)) {
-	case IWL_BT_COEX_TRAFFIC_LOAD_NONE:
-		/* nothing */
-		break;
-	case IWL_BT_COEX_TRAFFIC_LOAD_HIGH:
-	case IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:
-		/* avoid antenna B and MIMO */
-		if (tbl->action != IWL_MIMO2_SWITCH_SISO_A)
-			tbl->action = IWL_MIMO2_SWITCH_SISO_A;
-		break;
-	case IWL_BT_COEX_TRAFFIC_LOAD_LOW:
-		/* avoid antenna B unless MIMO */
-		if (tbl->action == IWL_MIMO2_SWITCH_SISO_B)
-			tbl->action = IWL_MIMO2_SWITCH_SISO_A;
-		break;
-	default:
-		IWL_ERR(mvm, "Invalid BT load %d",
-			le32_to_cpu(mvm->last_bt_notif.bt_activity_grading));
-		break;
-	}
-
 	start_action = tbl->action;
 	while (1) {
 		lq_sta->action_counter++;
