From: Eugeni Dodonov <eugeni.dodonov@intel.com>
Date: Fri Mar 23 11:57:19 2012 -030
Subject: drm/i915: enable plain RC6 on Sandy Bridge by default
Patch-Mainline: v3.4-rc2
Git-commit: aa46419186992e6b8b8010319f0ca7f40a0d13f5
References: bnc#725355

This is yet another chapter in the ongoing saga of bringing RC6 to Sandy
Bridge machines by default.

Now that we have discovered that RC6 issues are triggered by RC6+ state,
let's try to disable it by default. Plain RC6 is the one responsible for
most energy savings, and so far it haven't given any problems - at least,
none we are aware of.

So with this, when i915_enable_rc6=-1 (e.g., the default value), we'll
attempt to enable plain RC6 only on SNB. For Ivy Bridge, the behavior
stays the same as always - we enable both RC6 and deep RC6.

Note that while this exact patch does not has explicit tested-by's, the
equivalent settings were fixed in 3.3 kernel by a smaller patch. And it
has also received considerable testing through Canonical RC6 task-force
testing at https://wiki.ubuntu.com/Kernel/PowerManagementRC6. Up to date,
it looks like all the known issues are gone.

v2: improve description and reference a couple of open bugs related to
RC6 which seem to be fixed with this change.

[NOTE: this is a combined patch from 83b7f9ac9126f0532ca34c14e4f0582c565c6b0d
 and aa46419186992e6b8b8010319f0ca7f40a0d13f5]

References: https://bugs.freedesktop.org/show_bug.cgi?id=41682
References: https://bugs.freedesktop.org/show_bug.cgi?id=38567
References: https://bugs.freedesktop.org/show_bug.cgi?id=44867
Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
Signed-off-by: Eugeni Dodonov <eugeni.dodonov@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Egbert Eich <eich@suse.de>
---
 drivers/gpu/drm/i915/i915_drv.h      |   22 ++++++++++++++++++++++
 drivers/gpu/drm/i915/intel_display.c |   19 +++++++++++--------
 2 files changed, 33 insertions(+), 8 deletions(-)

--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1005,6 +1005,28 @@ struct drm_i915_file_private {
 
 #include "i915_trace.h"
 
+/**
+ * RC6 is a special power stage which allows the GPU to enter an very
+ * low-voltage mode when idle, using down to 0V while at this stage.  This
+ * stage is entered automatically when the GPU is idle when RC6 support is
+ * enabled, and as soon as new workload arises GPU wakes up automatically as wel
+l.
+*
+* There are different RC6 modes available in Intel GPU, which differentiate
+* among each other with the latency required to enter and leave RC6 and
+* voltage consumed by the GPU in different states.
+*
+* The combination of the following flags define which states GPU is allowed
+* to enter, while RC6 is the normal RC6 state, RC6p is the deep RC6p
+* Their support by hardware varies according to the
+* GPU, BIOS, chipset and platform. RC6 is usually the safest one and the one
+* which brings the most power savings; deeper states save more power, but
+* require higher latency to switch to and wake up.
+*/
+
+#define INTEL_RC6_ENABLE                        (1<<0)
+#define INTEL_RC6p_ENABLE                       (1<<1)
+
 extern struct drm_ioctl_desc i915_ioctls[];
 extern int i915_max_ioctl;
 extern unsigned int i915_fbpercrtc;
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -7996,7 +7996,7 @@ void intel_init_emon(struct drm_device *
 	dev_priv->corr = (lcfuse & LCFUSE_HIV_MASK);
 }
 
-static bool intel_enable_rc6(struct drm_device *dev)
+static int intel_enable_rc6(struct drm_device *dev)
 {
 	/*
 	 * Respect the kernel parameter if it is set
@@ -8014,11 +8014,11 @@ static bool intel_enable_rc6(struct drm_
 	 * Disable rc6 on Sandybridge
 	 */
 	if (INTEL_INFO(dev)->gen == 6) {
-		DRM_DEBUG_DRIVER("Sandybridge: RC6 disabled\n");
-		return 0;
+		DRM_DEBUG_DRIVER("Sandybridge: deep RC6 disabled\n");
+		return INTEL_RC6_ENABLE;
 	}
-	DRM_DEBUG_DRIVER("RC6 enabled\n");
-	return 1;
+	DRM_DEBUG_DRIVER("RC6 and deep RC6 enabled\n");
+	return (INTEL_RC6_ENABLE | INTEL_RC6p_ENABLE);
 }
 
 void gen6_enable_rps(struct drm_i915_private *dev_priv)
@@ -8027,6 +8027,7 @@ void gen6_enable_rps(struct drm_i915_pri
 	u32 gt_perf_status = I915_READ(GEN6_GT_PERF_STATUS);
 	u32 pcu_mbox, rc6_mask = 0;
 	int cur_freq, min_freq, max_freq;
+	int rc6_mode;
 	int i;
 
 	/* Here begins a magic sequence of register writes to enable
@@ -8057,9 +8058,11 @@ void gen6_enable_rps(struct drm_i915_pri
 	I915_WRITE(GEN6_RC6p_THRESHOLD, 100000);
 	I915_WRITE(GEN6_RC6pp_THRESHOLD, 64000); /* unused */
 
-	if (intel_enable_rc6(dev_priv->dev))
-		rc6_mask = GEN6_RC_CTL_RC6_ENABLE |
-			((IS_GEN7(dev_priv->dev)) ? GEN6_RC_CTL_RC6p_ENABLE : 0);
+	rc6_mode = intel_enable_rc6(dev_priv->dev);
+	if (rc6_mode & INTEL_RC6_ENABLE)
+		rc6_mask = GEN6_RC_CTL_RC6_ENABLE;
+	if (rc6_mode & INTEL_RC6p_ENABLE)
+		rc6_mask |= GEN6_RC_CTL_RC6p_ENABLE;
 
 	I915_WRITE(GEN6_RC_CONTROL,
 		   rc6_mask |
