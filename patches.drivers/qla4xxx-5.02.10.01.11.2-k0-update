From: Hannes Reinecke <hare@suse.de>
Date: Wed, 3 Aug 2011 09:57:00 +0200
Subject: [PATCH] qla4xxx: Update to 5.02.10.01.11.2-k0
Patch-Mainline: 2.6.38
References: bnc#689435

This is a combined patchset of the upstream commit ids:
6790d4fecf4373016e2983f913bcc0f1cdfa8ca0
4cd83cbef878b5d0d4c65ac0a20d12a8bf9f551d
3930b8c1f3582d43757cbcc9b7ecaf05f6b4a66e
9640de2099a3c7936b65bf3a45e67a324de950c8
7edd9a7b28f57d8a5bcdb1a0def2aa09d1dd49d4
2d7924e6be8b994f718429001457e677a2159445
5fa8b573134108a333a317378998a9f1299c4dd6
cb74428ee3811d7749d07e00161336ba9f98b394
1b46807e0bc6160449ce04a207fa98a694bc443c

backported for SLES11 SP2.

Signed-off-by: Nilesh Javali <nilesh.javali@qlogic.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/qla4xxx/ql4_def.h     |    8 --
 drivers/scsi/qla4xxx/ql4_fw.h      |    2 +-
 drivers/scsi/qla4xxx/ql4_glbl.h    |    1 -
 drivers/scsi/qla4xxx/ql4_init.c    |  189 ++++++------------------------------
 drivers/scsi/qla4xxx/ql4_isr.c     |   34 -------
 drivers/scsi/qla4xxx/ql4_mbx.c     |   44 ++++-----
 drivers/scsi/qla4xxx/ql4_nx.c      |   70 +++++++++-----
 drivers/scsi/qla4xxx/ql4_os.c      |  133 +++++++++++++------------
 drivers/scsi/qla4xxx/ql4_version.h |    2 +-
 9 files changed, 164 insertions(+), 319 deletions(-)

diff --git a/drivers/scsi/qla4xxx/ql4_def.h b/drivers/scsi/qla4xxx/ql4_def.h
index 3ed020f..ace4a9d 100644
--- a/drivers/scsi/qla4xxx/ql4_def.h
+++ b/drivers/scsi/qla4xxx/ql4_def.h
@@ -205,7 +205,6 @@ struct srb {
 	struct scsi_cmnd *cmd;	/* (4) SCSI command block */
 	dma_addr_t dma_handle;	/* (4) for unmap of single transfers */
 	struct kref srb_ref;	/* reference count for this srb */
-	uint32_t fw_ddb_index;
 	uint8_t err_id;		/* error id */
 #define SRB_ERR_PORT	   1	/* Request failed because "port down" */
 #define SRB_ERR_LOOP	   2	/* Request failed because "loop down" */
@@ -252,9 +251,6 @@ struct ddb_entry {
 #define DF_REMOVE		4	/* FW DDB is destroyed */
 #define DF_DYNAMIC_LUN_SCAN_NEEDED	5
 
-	unsigned long dev_scan_wait_to_start_relogin;
-	unsigned long dev_scan_wait_to_complete_relogin;
-
 	uint16_t os_target_id;	/* Target ID */
 	uint16_t fw_ddb_index;	/* DDB firmware index */
 	uint16_t options;
@@ -390,7 +386,6 @@ struct scsi_qla_host {
 #define AF_INIT_DONE			1 /* 0x00000002 */
 #define AF_MBOX_COMMAND			2 /* 0x00000004 */
 #define AF_MBOX_COMMAND_DONE		3 /* 0x00000008 */
-#define AF_DPC_SCHEDULED		5 /* 0x00000020 */
 #define AF_INTERRUPTS_ON		6 /* 0x00000040 */
 #define AF_GET_CRASH_RECORD		7 /* 0x00000080 */
 #define AF_LINK_UP			8 /* 0x00000100 */
@@ -409,7 +404,6 @@ struct scsi_qla_host {
 #define AF_PCI_CHANNEL_IO_PERM_FAILURE	24 /* 0x01000000 */
 #define AF_PT_ACTIVE			25 /* 0x02000000 */
 #define AF_QUIESCE_OWNER		26 /* 0x04000000 */
-#define AF_P3P_RST_HDLR_ACTIVE		27 /* 0x08000000 */
 
 	unsigned long dpc_flags;
 
@@ -516,7 +510,6 @@ struct scsi_qla_host {
 
 	/* Recovery Timers */
 	uint32_t port_down_retry_count;
-	uint32_t discovery_wait;
 	atomic_t check_relogin_timeouts;
 	uint32_t retry_reset_ha_cnt;
 	uint32_t isp_reset_timer;	/* reset test timer */
@@ -900,6 +893,5 @@ static inline uint8_t ql4_is_memzero(const char *m, size_t s)
 /* Defines for process_aen() */
 #define PROCESS_ALL_AENS	 0
 #define FLUSH_DDB_CHANGED_AENS	 1
-#define RELOGIN_DDB_CHANGED_AENS 2
 
 #endif	/*_QLA4XXX_H */
diff --git a/drivers/scsi/qla4xxx/ql4_fw.h b/drivers/scsi/qla4xxx/ql4_fw.h
index e42b1f5..45726ac 100644
--- a/drivers/scsi/qla4xxx/ql4_fw.h
+++ b/drivers/scsi/qla4xxx/ql4_fw.h
@@ -307,6 +307,7 @@ struct qla_flt_header {
 #define FLT_REG_FW_82		0x74
 #define FLT_REG_GOLD_FW_82	0x75
 #define FLT_REG_BOOT_CODE_82	0x78
+#define FLT_REG_FW_82_1		0x97
 
 struct qla_flt_region {
 	uint32_t code;
@@ -350,7 +351,6 @@ struct qla_flt_region {
 #define MBOX_CMD_READ_FLASH			0x0026
 #define MBOX_CMD_FREE_DATABASE_ENTRY		0x0031
 #define MBOX_CMD_CONN_CLOSE			0x0056
-#define MBOX_CMD_CONN_CLOSE_SESS_LOGOUT		0x0056
 #define LOGOUT_OPTION_CLOSE_SESSION		0x02
 #define LOGOUT_OPTION_RESET			0x04
 #define LOGOUT_OPTION_FREE_DDB			0x08
diff --git a/drivers/scsi/qla4xxx/ql4_glbl.h b/drivers/scsi/qla4xxx/ql4_glbl.h
index 702bd2f..713fa63 100644
--- a/drivers/scsi/qla4xxx/ql4_glbl.h
+++ b/drivers/scsi/qla4xxx/ql4_glbl.h
@@ -181,7 +181,6 @@ void qla4xxx_get_conn_event_log(struct scsi_qla_host *);
 int qla4xxx_cmd_wait(struct scsi_qla_host *, uint32_t timeout);
 
 extern int ql4xextended_error_logging;
-extern int ql4xdiscoverywait;
 extern int ql4xdontresethba;
 extern int ql4xenablemsix;
 extern int ql4xkeepalive;
diff --git a/drivers/scsi/qla4xxx/ql4_init.c b/drivers/scsi/qla4xxx/ql4_init.c
index 58e4913..489583a 100644
--- a/drivers/scsi/qla4xxx/ql4_init.c
+++ b/drivers/scsi/qla4xxx/ql4_init.c
@@ -840,6 +840,30 @@ exit_find_duplicate_ddb:
 
 }
 
+static void qla4xxx_flush_AENS(struct scsi_qla_host *ha)
+{
+	unsigned long wtime;
+
+	/* Flush the 0x8014 AEN from the firmware as a result of
+	 * Auto connect. We are basically doing get_firmware_ddb()
+	 * to determine whether we need to log back in or not.
+	 *  Trying to do a set ddb before we have processed 0x8014
+	 *  will result in another set_ddb() for the same ddb. In other
+	 *  words there will be stale entries in the aen_q.
+	 */
+	wtime = jiffies + (2 * HZ);
+	do {
+		if (qla4xxx_get_firmware_state(ha) == QLA_SUCCESS)
+			if (ha->firmware_state & (BIT_2 | BIT_0))
+				return;
+
+		if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
+			qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
+
+		msleep(1000);
+	} while (!time_after_eq(jiffies, wtime));
+}
+
 /**
  * qla4xxx_build_ddb_list - builds driver ddb list
  * @ha: Pointer to host adapter structure.
@@ -861,6 +885,8 @@ static int qla4xxx_build_ddb_list(struct scsi_qla_host *ha)
 	uint32_t ipv6_device;
 	uint32_t new_tgt;
 
+	qla4xxx_flush_AENS(ha);
+
 	fw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
 			&fw_ddb_entry_dma, GFP_KERNEL);
 	if (fw_ddb_entry == NULL) {
@@ -966,147 +992,6 @@ exit_build_ddb_list_no_free:
 	return status;
 }
 
-struct qla4_relog_scan {
-	int halt_wait;
-	uint32_t conn_err;
-	uint32_t fw_ddb_index;
-	uint32_t next_fw_ddb_index;
-	uint32_t fw_ddb_device_state;
-};
-
-static int qla4_test_rdy(struct scsi_qla_host *ha, struct qla4_relog_scan *rs)
-{
-	struct ddb_entry *ddb_entry;
-
-	if (qla4_is_relogin_allowed(ha, rs->conn_err)) {
-		/* We either have a device that is in
-		 * the process of relogging in or a
-		 * device that is waiting to be
-		 * relogged in */
-		rs->halt_wait = 0;
-
-		ddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha,
-							   rs->fw_ddb_index);
-		if (ddb_entry == NULL)
-			return QLA_ERROR;
-
-		if (ddb_entry->dev_scan_wait_to_start_relogin != 0
-		    && time_after_eq(jiffies,
-				     ddb_entry->
-				     dev_scan_wait_to_start_relogin))
-		{
-			ddb_entry->dev_scan_wait_to_start_relogin = 0;
-			qla4xxx_set_ddb_entry(ha, rs->fw_ddb_index, 0);
-		}
-	}
-	return QLA_SUCCESS;
-}
-
-static int qla4_scan_for_relogin(struct scsi_qla_host *ha,
-				 struct qla4_relog_scan *rs)
-{
-	int error;
-
-	/* scan for relogins
-	 * ----------------- */
-	for (rs->fw_ddb_index = 0; rs->fw_ddb_index < MAX_DDB_ENTRIES;
-	     rs->fw_ddb_index = rs->next_fw_ddb_index) {
-		if (qla4xxx_get_fwddb_entry(ha, rs->fw_ddb_index, NULL, 0,
-					    NULL, &rs->next_fw_ddb_index,
-					    &rs->fw_ddb_device_state,
-					    &rs->conn_err, NULL, NULL)
-		    == QLA_ERROR)
-			return QLA_ERROR;
-
-		if (rs->fw_ddb_device_state == DDB_DS_LOGIN_IN_PROCESS)
-			rs->halt_wait = 0;
-
-		if (rs->fw_ddb_device_state == DDB_DS_SESSION_FAILED ||
-		    rs->fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE) {
-			error = qla4_test_rdy(ha, rs);
-			if (error)
-				return error;
-		}
-
-		/* We know we've reached the last device when
-		 * next_fw_ddb_index is 0 */
-		if (rs->next_fw_ddb_index == 0)
-			break;
-	}
-	return QLA_SUCCESS;
-}
-
-/**
- * qla4xxx_devices_ready - wait for target devices to be logged in
- * @ha: pointer to adapter structure
- *
- * This routine waits up to ql4xdiscoverywait seconds
- * F/W database during driver load time.
- **/
-static int qla4xxx_devices_ready(struct scsi_qla_host *ha)
-{
-	int error;
-	unsigned long discovery_wtime;
-	struct qla4_relog_scan rs;
-
-	discovery_wtime = jiffies + (ql4xdiscoverywait * HZ);
-
-	DEBUG(ql4_info(ha, "Waiting (%d) for devices ...\n",
-			ql4xdiscoverywait));
-	do {
-		/* poll for AEN. */
-		qla4xxx_get_firmware_state(ha);
-		if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags)) {
-			/* Process AENs for targets coming online
-			 * during initial discovery
-			 */
-			qla4xxx_process_aen(ha, PROCESS_ALL_AENS);
-		}
-
-		/* if no relogins active or needed, halt discvery wait */
-		rs.halt_wait = 1;
-
-		error = qla4_scan_for_relogin(ha, &rs);
-
-		if (rs.halt_wait) {
-			DEBUG2(ql4_info(ha, "%s: Delay halted.  Devices "
-				      "Ready.\n", __func__));
-			return QLA_SUCCESS;
-		}
-
-		msleep(2000);
-	} while (!time_after_eq(jiffies, discovery_wtime));
-
-	DEBUG3(qla4xxx_get_conn_event_log(ha));
-
-	return QLA_SUCCESS;
-}
-
-static void qla4xxx_flush_AENS(struct scsi_qla_host *ha)
-{
-	unsigned long wtime;
-
-	/* Flush the 0x8014 AEN from the firmware as a result of
-	 * Auto connect. We are basically doing get_firmware_ddb()
-	 * to determine whether we need to log back in or not.
-	 *  Trying to do a set ddb before we have processed 0x8014
-	 *  will result in another set_ddb() for the same ddb. In other
-	 *  words there will be stale entries in the aen_q.
-	 */
-	wtime = jiffies + (2 * HZ);
-	do {
-		if (qla4xxx_get_firmware_state(ha) == QLA_SUCCESS)
-			if (ha->firmware_state & (BIT_2 | BIT_0))
-				return;
-
-		if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
-			qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
-
-		msleep(1000);
-	} while (!time_after_eq(jiffies, wtime));
-
-}
-
 static int qla4xxx_initialize_ddb_list(struct scsi_qla_host *ha)
 {
 	uint16_t fw_ddb_index;
@@ -1122,26 +1007,8 @@ static int qla4xxx_initialize_ddb_list(struct scsi_qla_host *ha)
 
 	ha->tot_ddbs = 0;
 
-	qla4xxx_flush_AENS(ha);
-
-	/* Wait for an AEN */
-	qla4xxx_devices_ready(ha);
-
-	/*
-	 * First perform device discovery for active
-	 * fw ddb indexes and build
-	 * ddb list.
-	 */
-	if ((status = qla4xxx_build_ddb_list(ha)) == QLA_ERROR)
-		return status;
-
-	/*
-	 * Targets can come online after the inital discovery, so processing
-	 * the aens here will catch them.
-	 */
-	if (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))
-		qla4xxx_process_aen(ha, PROCESS_ALL_AENS);
-
+	/* Perform device discovery and build ddb list. */
+	status = qla4xxx_build_ddb_list(ha);
 	return status;
 }
 
diff --git a/drivers/scsi/qla4xxx/ql4_isr.c b/drivers/scsi/qla4xxx/ql4_isr.c
index 975bea4..3850189 100644
--- a/drivers/scsi/qla4xxx/ql4_isr.c
+++ b/drivers/scsi/qla4xxx/ql4_isr.c
@@ -1033,7 +1033,6 @@ qla4_8xxx_msix_rsp_q(int irq, void *dev_id)
  * The type of AENs to process is specified by process_aen and can be
  *	PROCESS_ALL_AENS	 0
  *	FLUSH_DDB_CHANGED_AENS	 1
- *	RELOGIN_DDB_CHANGED_AENS 2
  **/
 void qla4xxx_process_aen(struct scsi_qla_host * ha, uint8_t process_aen)
 {
@@ -1068,39 +1067,6 @@ void qla4xxx_process_aen(struct scsi_qla_host * ha, uint8_t process_aen)
 					      ha->aen_out, mbox_sts[0],
 					      mbox_sts[2], mbox_sts[3]));
 				break;
-			case RELOGIN_DDB_CHANGED_AENS:
-			{
-			    /* For use during init time, we only want to
-			     * relogin non-active ddbs */
-
-			    struct ddb_entry *ddb_entry;
-
-			    ddb_entry =
-				qla4xxx_lookup_ddb_by_fw_index(ha, mbox_sts[2]);
-
-			    if (ddb_entry) {
-				DEBUG6(dev_info(&ha->pdev->dev, "%s AEN[%d] ddb"
-					" 0x%p sess 0x%p conn 0x%p state "
-					"0x%x\n", __func__, ha->aen_out,
-					ddb_entry, ddb_entry->sess,
-					ddb_entry->conn,
-					atomic_read(&ddb_entry->state)));
-
-				ddb_entry->dev_scan_wait_to_complete_relogin =
-					0;
-				ddb_entry->dev_scan_wait_to_start_relogin =
-					jiffies +
-					((ddb_entry->default_time2wait + 4)
-									* HZ);
-
-				DEBUG2(ql4_info(ha, "ddb [%d] initate"
-					      " RELOGIN after %d seconds\n",
-					      ddb_entry->fw_ddb_index,
-					      ddb_entry->default_time2wait +
-					      4));
-			    }
-			    break;
-			}
 			case PROCESS_ALL_AENS:
 			default:
 				/* WARNING: Post init only */
diff --git a/drivers/scsi/qla4xxx/ql4_mbx.c b/drivers/scsi/qla4xxx/ql4_mbx.c
index b24d0d9..56c5194 100644
--- a/drivers/scsi/qla4xxx/ql4_mbx.c
+++ b/drivers/scsi/qla4xxx/ql4_mbx.c
@@ -32,7 +32,6 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 	u_long wait_count;
 	uint32_t intr_status;
 	unsigned long flags = 0;
-	uint8_t	force_polling = 0;
 	uint32_t dev_state;
 
 	/* Make sure that pointers are valid */
@@ -42,11 +41,12 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 		return status;
 	}
 
-	if ((is_aer_supported(ha)) &&
-	    (test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))) {
-		DEBUG2(ql4_info(ha, "%s: Perm failure on EEH, "
-				"timeout MBX Exiting.\n", __func__));
-		return status;
+	if (is_qla8022(ha)) {
+		if (test_bit(AF_FW_RECOVERY, &ha->flags)) {
+			DEBUG2(ql4_warn(ha, "%s: prematurely completing "
+				"mbx cmd as firmware recovery detected\n", __func__));
+			return status;
+		}
 	}
 
 	if (is_qla8022(ha)) {
@@ -59,12 +59,13 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 				__func__);
 			return status;
 		}
+	}
 
-		if (test_bit(AF_FW_RECOVERY, &ha->flags)) {
-			DEBUG2(ql4_warn(ha, "%s: prematurely completing"
-				" mbx cmd as firmware recovery detected\n", __func__));
-			return status;
-		}
+	if ((is_aer_supported(ha)) &&
+	    (test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))) {
+		DEBUG2(ql4_info(ha, "%s: Perm failure on EEH, "
+			"timeout MBX Exiting.\n", __func__));
+		return status;
 	}
 
 	/* Mailbox code active */
@@ -136,22 +137,13 @@ int qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,
 		goto mbox_exit;
 	}
 
-	/* Always poll for mailbox completion when calling the Disable
-	   Interrupts mailbox command, as the interrupts will be disabled
-	   upon completion */
-	if (is_qla8022(ha) &&
-	    (mbx_cmd[0] == MBOX_CMD_ENABLE_INTRS) &&
-	    (mbx_cmd[1] == INTR_DISABLE))
-		force_polling = 1;
-
 	/*
 	 * Wait for completion: Poll or completion queue
 	 */
 	if (test_bit(AF_IRQ_ATTACHED, &ha->flags) &&
 	    test_bit(AF_INTERRUPTS_ON, &ha->flags) &&
 	    test_bit(AF_ONLINE, &ha->flags) &&
-	    !test_bit(AF_HA_REMOVAL, &ha->flags) &&
-	    !force_polling) {
+	    !test_bit(AF_HA_REMOVAL, &ha->flags)) {
 		/* Do not poll for completion. Use completion queue */
 		set_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags);
 		wait_for_completion_timeout(&ha->mbx_intr_comp, MBOX_TOV * HZ);
@@ -499,9 +491,6 @@ qla4xxx_update_local_ifcb(struct scsi_qla_host *ha,
 
 	ha->port_down_retry_count = le16_to_cpu(init_fw_cb->conn_ka_timeout);
 
-	/* Save Command Line Paramater info */
-	ha->discovery_wait = ql4xdiscoverywait;
-
 	qla4xxx_update_local_ip(ha, init_fw_cb);
 
 	return QLA_SUCCESS;
@@ -565,7 +554,10 @@ int qla4xxx_initialize_fw_cb(struct scsi_qla_host * ha)
 		    __constant_cpu_to_le16(FWOPT_ENABLE_CRBDB);
 
 	init_fw_cb->fw_options &= __constant_cpu_to_le16(~FWOPT_TARGET_MODE);
-	init_fw_cb->add_fw_options &= __constant_cpu_to_le16(SERIALIZE_TASK_MGMT);
+	/* Set bit for "serialize task mgmt" all other bits need to be zero */
+	init_fw_cb->add_fw_options = 0;
+	init_fw_cb->add_fw_options |=
+		__constant_cpu_to_le16(SERIALIZE_TASK_MGMT);
 
 	if (qla4xxx_set_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma)
 		!= QLA_SUCCESS) {
@@ -1019,7 +1011,7 @@ int qla4xxx_abort_task(struct scsi_qla_host *ha, struct srb *srb)
 		return status;
 
 	mbox_cmd[0] = MBOX_CMD_ABORT_TASK;
-	mbox_cmd[1] = srb->fw_ddb_index;
+	mbox_cmd[1] = srb->ddb->fw_ddb_index;
 	mbox_cmd[2] = index;
 	/* Immediate Command Enable */
 	mbox_cmd[5] = 0x01;
diff --git a/drivers/scsi/qla4xxx/ql4_nx.c b/drivers/scsi/qla4xxx/ql4_nx.c
index 91507d4..1c799b5 100644
--- a/drivers/scsi/qla4xxx/ql4_nx.c
+++ b/drivers/scsi/qla4xxx/ql4_nx.c
@@ -940,12 +940,26 @@ qla4_8xxx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
 	/* Halt all the indiviual PEGs and other blocks of the ISP */
 	qla4_8xxx_rom_lock(ha);
 
-	/* mask all niu interrupts */
+	/* disable all I2Q */
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x10, 0x0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x14, 0x0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x18, 0x0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x1c, 0x0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x20, 0x0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_I2Q + 0x24, 0x0);
+
+	/* disable all niu interrupts */
 	qla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0x40, 0xff);
 	/* disable xge rx/tx */
 	qla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0x70000, 0x00);
 	/* disable xg1 rx/tx */
 	qla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0x80000, 0x00);
+	/* disable sideband mac */
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0x90000, 0x00);
+	/* disable ap0 mac */
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0xa0000, 0x00);
+	/* disable ap1 mac */
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_NIU + 0xb0000, 0x00);
 
 	/* halt sre */
 	val = qla4_8xxx_rd_32(ha, QLA82XX_CRB_SRE + 0x1000);
@@ -960,6 +974,7 @@ qla4_8xxx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
 	qla4_8xxx_wr_32(ha, QLA82XX_CRB_TIMER + 0x10, 0x0);
 	qla4_8xxx_wr_32(ha, QLA82XX_CRB_TIMER + 0x18, 0x0);
 	qla4_8xxx_wr_32(ha, QLA82XX_CRB_TIMER + 0x100, 0x0);
+	qla4_8xxx_wr_32(ha, QLA82XX_CRB_TIMER + 0x200, 0x0);
 
 	/* halt pegs */
 	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x3c, 1);
@@ -968,8 +983,7 @@ qla4_8xxx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
 	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x3c, 1);
 	qla4_8xxx_wr_32(ha, QLA82XX_CRB_PEG_NET_4 + 0x3c, 1);
 
-	/* big hammer */
-	msleep(1000);
+	msleep(5);
 
 	if (test_bit(DPC_RESET_HA, &ha->dpc_flags))
 		/* don't reset CAM block on reset */
@@ -1121,14 +1135,14 @@ qla4_8xxx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)
 static int
 qla4_8xxx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)
 {
-	int  i;
+	int  i, rval = 0;
 	long size = 0;
 	long flashaddr, memaddr;
 	u64 data;
 	u32 high, low;
 
 	flashaddr = memaddr = ha->hw.flt_region_bootload;
-	size = (image_start - flashaddr)/8;
+	size = (image_start - flashaddr) / 8;
 
 	DEBUG2(ql4_info(ha, "%s: bootldr=0x%lx, fw_image=0x%x\n",
 			__func__, flashaddr, image_start));
@@ -1137,15 +1151,17 @@ qla4_8xxx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)
 		if ((qla4_8xxx_rom_fast_read(ha, flashaddr, (int *)&low)) ||
 		    (qla4_8xxx_rom_fast_read(ha, flashaddr + 4,
 		    (int *)&high))) {
-			return -1;
+			rval = -1;
+			goto exit_load_from_flash;
 		}
 		data = ((u64)high << 32) | low ;
-		if( qla4_8xxx_pci_mem_write_2M(ha, memaddr, &data, 8))
-			return -1;
+		rval = qla4_8xxx_pci_mem_write_2M(ha, memaddr, &data, 8);
+		if (rval)
+			goto exit_load_from_flash;
 		flashaddr += 8;
 		memaddr   += 8;
 
-		if (i%0x1000 == 0)
+		if (i % 0x1000 == 0)
 			msleep(1);
 
 	}
@@ -1157,7 +1173,8 @@ qla4_8xxx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)
 	qla4_8xxx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);
 	read_unlock(&ha->hw_lock);
 
-	return 0;
+exit_load_from_flash:
+	return rval;
 }
 
 static int qla4_8xxx_load_fw(struct scsi_qla_host *ha, uint32_t image_start)
@@ -1834,8 +1851,9 @@ int qla4_8xxx_device_state_handler(struct scsi_qla_host *ha)
 	/* wait for 30 seconds for device to go ready */
 	dev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);
 
+	qla4_8xxx_idc_lock(ha);
+
 	while (1) {
-		qla4_8xxx_idc_lock(ha);
 
 		if (time_after_eq(jiffies, dev_init_timeout)) {
 			DEBUG2(ql4_warn(ha, "%s: Device init failed!\n",
@@ -1851,25 +1869,27 @@ int qla4_8xxx_device_state_handler(struct scsi_qla_host *ha)
 		/* NOTE: Make sure idc unlocked upon exit of switch statement */
 		switch (dev_state) {
 		case QLA82XX_DEV_READY:
-			qla4_8xxx_idc_unlock(ha);
 			goto exit;
 		case QLA82XX_DEV_COLD:
 			rval = qla4_8xxx_device_bootstrap(ha);
-			qla4_8xxx_idc_unlock(ha);
 			goto exit;
 		case QLA82XX_DEV_INITIALIZING:
 			qla4_8xxx_idc_unlock(ha);
 			msleep(1000);
+			qla4_8xxx_idc_lock(ha);
 			break;
 		case QLA82XX_DEV_NEED_RESET:
-			if (!ql4xdontresethba) {
+			if (!ql4xdontresethba)
 				qla4_8xxx_need_reset_handler(ha);
-				/* Update timeout value after need
-				 * reset handler */
-				dev_init_timeout = jiffies +
-					(ha->nx_dev_init_timeout * HZ);
+			else {
+				qla4_8xxx_idc_unlock(ha);
+				msleep(1000);
+				qla4_8xxx_idc_lock(ha);
 			}
-			qla4_8xxx_idc_unlock(ha);
+			/* Update timeout value after need
+			 * reset handler */
+			dev_init_timeout = jiffies +
+					(ha->nx_dev_init_timeout * HZ);
 			break;
 		case QLA82XX_DEV_NEED_QUIESCENT:
 			/* idc locked/unlocked in handler */
@@ -1878,7 +1898,6 @@ int qla4_8xxx_device_state_handler(struct scsi_qla_host *ha)
 			/* Reset the init timeout after qsnt handler */
 			dev_init_timeout = jiffies +
 					   (ha->nx_dev_init_timeout * HZ);
-			qla4_8xxx_idc_unlock(ha);
 			break;
 		case QLA82XX_DEV_QUIESCENT:
 			/* Quiesce_owner will exit, other functions will wait
@@ -1891,7 +1910,7 @@ int qla4_8xxx_device_state_handler(struct scsi_qla_host *ha)
 			DEBUG2(ql4_dbg(ha, "%s: quiescent.. sleep\n", 
 					__func__));
 			msleep(1000);
-
+			qla4_8xxx_idc_lock(ha);
 			/* Reset the init timeout after qsnt handler */
 			dev_init_timeout = jiffies +
 					   (ha->nx_dev_init_timeout * HZ);
@@ -1900,6 +1919,7 @@ int qla4_8xxx_device_state_handler(struct scsi_qla_host *ha)
 			qla4_8xxx_idc_unlock(ha);
 			qla4xxx_dead_adapter_cleanup(ha);
 			rval = QLA_ERROR;
+			qla4_8xxx_idc_lock(ha);
 			goto exit;
 		default:
 			ql4_info(ha, "%s: Unknown Device State: %x\n",
@@ -1907,10 +1927,12 @@ int qla4_8xxx_device_state_handler(struct scsi_qla_host *ha)
 			qla4_8xxx_idc_unlock(ha);
 			qla4xxx_dead_adapter_cleanup(ha);
 			rval = QLA_ERROR;
+			qla4_8xxx_idc_lock(ha);
 			goto exit;
 		}
 	}
 exit:
+	qla4_8xxx_idc_unlock(ha);
 	return rval;
 }
 
@@ -2063,6 +2085,7 @@ qla4_8xxx_get_flt_info(struct scsi_qla_host *ha, uint32_t flt_addr)
 			hw->flt_region_boot = start;
 			break;
 		case FLT_REG_FW_82:
+		case FLT_REG_FW_82_1:
 			hw->flt_region_fw = start;
 			break;
 		case FLT_REG_BOOTLOAD_82:
@@ -2243,7 +2266,7 @@ qla4_8xxx_isp_reset(struct scsi_qla_host *ha)
 		qla4_8xxx_wr_32(ha, QLA82XX_CRB_DEV_STATE,
 		    QLA82XX_DEV_NEED_RESET);
 	} else
-		ql4_info(ha, "HW State: DEVICE INITIALIZING\n");
+		ql4_info(ha, "HW State: 0x%d\n", dev_state);
 
 	qla4_8xxx_idc_unlock(ha);
 
@@ -2379,14 +2402,13 @@ qla4_8xxx_enable_intrs(struct scsi_qla_host *ha)
 void
 qla4_8xxx_disable_intrs(struct scsi_qla_host *ha)
 {
-	if (test_bit(AF_INTERRUPTS_ON, &ha->flags))
+	if (test_and_clear_bit(AF_INTERRUPTS_ON, &ha->flags))
 		qla4_8xxx_mbx_intr_disable(ha);
 
 	spin_lock_irq(&ha->hardware_lock);
 	/* BIT 10 - set */
 	qla4_8xxx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0x0400);
 	spin_unlock_irq(&ha->hardware_lock);
-	clear_bit(AF_INTERRUPTS_ON, &ha->flags);
 }
 
 struct ql4_init_msix_entry {
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 7c9cbe5..35c0e88 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -40,10 +40,6 @@ static struct kmem_cache *srb_cachep;
 /*
  * Module parameter information and variables
  */
-int ql4xdiscoverywait = 60;
-module_param(ql4xdiscoverywait, int, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(ql4xdiscoverywait, "Discovery wait time");
-
 int ql4xdontresethba = 0;
 module_param(ql4xdontresethba, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(ql4xdontresethba,
@@ -390,11 +386,6 @@ int qla4xxx_add_sess(struct ddb_entry *ddb_entry)
 			ddb_entry->fw_ddb_index, ddb_entry->os_target_id,
 			ddb_entry->sess, ddb_entry->conn));
 
-	if (test_bit(AF_ONLINE, &ha->flags)) {
-		scsi_scan_target(&ddb_entry->sess->dev, 0,
-			ddb_entry->sess->target_id, SCAN_WILD_CARD, 0);
-        }
-
 	return 0;
 }
 
@@ -677,10 +668,6 @@ static void qla4xxx_mem_free(struct scsi_qla_host *ha)
 		if (ha->nx_pcibase)
 			iounmap(
 			    (struct device_reg_82xx __iomem *)ha->nx_pcibase);
-
-		if (ha->nx_db_wr_ptr)
-			iounmap(
-			    (struct device_reg_82xx __iomem *)ha->nx_db_wr_ptr);
 	} else if (ha->reg)
 		iounmap(ha->reg);
 	pci_release_regions(ha->pdev);
@@ -828,14 +815,16 @@ void qla4_8xxx_watchdog(struct scsi_qla_host *ha)
 	/* don't poll if reset is going on */
 	if (!(test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||
 	      test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
-	      test_bit(AF_P3P_RST_HDLR_ACTIVE, &ha->flags))) {
+	      test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags))) {
 		dev_state = qla4_8xxx_rd_32(ha, QLA82XX_CRB_DEV_STATE);
 		if (dev_state == QLA82XX_DEV_NEED_RESET &&
 		    !test_bit(DPC_RESET_HA, &ha->dpc_flags)) {
-			ql4_info(ha, "%s: HW State: NEED RESET!\n",
-					__func__);
-			set_bit(DPC_RESET_HA, &ha->dpc_flags);
-			qla4xxx_wake_dpc(ha);
+			if (!ql4xdontresethba) {
+				ql4_info(ha, "%s: HW State: NEED RESET!\n",
+						__func__);
+				set_bit(DPC_RESET_HA, &ha->dpc_flags);
+				qla4xxx_wake_dpc(ha);
+			}
 		} else if (dev_state == QLA82XX_DEV_NEED_QUIESCENT &&
 		    !test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {
 			ql4_err(ha, "%s: HW State: NEED QUIESCENT detected "
@@ -852,6 +841,34 @@ void qla4_8xxx_watchdog(struct scsi_qla_host *ha)
 				halt_status = qla4_8xxx_rd_32(ha,
 						QLA82XX_PEG_HALT_STATUS1);
 
+				ql4_printk(KERN_INFO, ha,
+					"scsi(%ld): %s, Dumping hw/fw "
+					"registers: PEG_HALT_STATUS1: 0x%x, "
+					"PEG_HALT_STATUS2: 0x%x,\n "
+					"PEG_NET_0_PC: 0x%x, PEG_NET_1_PC:"
+					" 0x%x,\n PEG_NET_2_PC: 0x%x, "
+					"PEG_NET_3_PC: 0x%x,\n PEG_NET_4_PC: "
+					"0x%x\n", ha->host_no,
+					__func__, halt_status,
+					qla4_8xxx_rd_32(ha,
+							QLA82XX_PEG_HALT_STATUS2),
+					qla4_8xxx_rd_32(ha,
+							QLA82XX_CRB_PEG_NET_0 +
+							0x3c),
+					qla4_8xxx_rd_32(ha,
+							QLA82XX_CRB_PEG_NET_1 +
+							0x3c),
+					qla4_8xxx_rd_32(ha,
+							QLA82XX_CRB_PEG_NET_2 +
+							0x3c),
+					qla4_8xxx_rd_32(ha,
+							QLA82XX_CRB_PEG_NET_3 +
+							0x3c),
+					qla4_8xxx_rd_32(ha,
+							QLA82XX_CRB_PEG_NET_4 +
+							0x3c));
+
+
 				/* Since we cannot change dev_state in
 				 * interrupt context, set appropriate DPC
 				 * flag then wakeup DPC */
@@ -1015,7 +1032,7 @@ void qla4xxx_timer(struct scsi_qla_host *ha)
 	}
 
 	/* Wakeup the dpc routine for this adapter, if needed. */
-	if ((start_dpc ||
+	if (start_dpc ||
 	     test_bit(DPC_RESET_HA, &ha->dpc_flags) ||
 	     test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||
 	     test_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags) ||
@@ -1034,9 +1051,7 @@ void qla4xxx_timer(struct scsi_qla_host *ha)
 	     test_bit(DPC_ISNS_REREGISTER, &ha->dpc_flags) ||
 	     test_bit(DPC_ISNS_DEREGISTER, &ha->dpc_flags) ||
 	     test_bit(DPC_ISNS_STOP, &ha->dpc_flags) ||
-	     test_bit(DPC_AEN, &ha->dpc_flags)) &&
-	     !test_bit(AF_DPC_SCHEDULED, &ha->flags) &&
-	     ha->dpc_thread) {
+	     test_bit(DPC_AEN, &ha->dpc_flags)) {
 		DEBUG2(ql4_info(ha, "%s: scheduling dpc routine"
 			      " - dpc flags = 0x%lx\n",
 			      __func__, ha->dpc_flags));
@@ -1273,7 +1288,11 @@ static int qla4xxx_recover_adapter(struct scsi_qla_host *ha)
 
 	set_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);
 
-	set_bit(AF_P3P_RST_HDLR_ACTIVE, &ha->flags);
+	/* Block all sessions, so iscsi_block_scsi_eh()
+	 * blocks device_reset and target_reset error handlers
+	 * till sessions become ACTIVE
+	 */
+	qla4xxx_mark_all_devices_missing(ha);
 
 	if (test_bit(DPC_RESET_HA, &ha->dpc_flags))
 		reset_chip = 1;
@@ -1343,7 +1362,8 @@ static int qla4xxx_recover_adapter(struct scsi_qla_host *ha)
 	/* Flush any pending ddb changed AENs */
 	qla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);
 
-	clear_bit(AF_P3P_RST_HDLR_ACTIVE, &ha->flags);
+	if (is_qla8022(ha))
+		clear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);
 
 recover_ha_init_adapter:
 	/* Upon successful firmware/chip reset, re-initialize the adapter */
@@ -1553,13 +1573,31 @@ exit_async_pdu_iocb:
 	return;
 }
 
+static void qla4xxx_relogin_all_devices(struct scsi_qla_host *ha)
+{
+	struct ddb_entry *ddb_entry, *dtemp;
+
+	list_for_each_entry_safe(ddb_entry, dtemp, &ha->ddb_list, list) {
+		if ((atomic_read(&ddb_entry->state) == DDB_STATE_MISSING) ||
+		    (atomic_read(&ddb_entry->state) == DDB_STATE_DEAD)) {
+			if (ddb_entry->fw_ddb_device_state ==
+			    DDB_DS_SESSION_ACTIVE) {
+				atomic_set(&ddb_entry->state, DDB_STATE_ONLINE);
+				ql4_printk(KERN_INFO, ha, "scsi%ld: %s: ddb[%d]"
+				    " marked ONLINE\n",	ha->host_no, __func__,
+				    ddb_entry->fw_ddb_index);
+
+				iscsi_unblock_session(ddb_entry->sess);
+			} else
+				qla4xxx_relogin_device(ha, ddb_entry);
+		}
+	}
+}
+
 void qla4xxx_wake_dpc(struct scsi_qla_host *ha)
 {
-	if (ha->dpc_thread &&
-	    !test_bit(AF_DPC_SCHEDULED, &ha->flags)) {
-		set_bit(AF_DPC_SCHEDULED, &ha->flags);
+	if (ha->dpc_thread)
 		queue_work(ha->dpc_thread, &ha->dpc_work);
-	}
 }
 
 /**
@@ -1587,11 +1625,11 @@ static void qla4xxx_do_dpc(struct work_struct *data)
 
 	/* Initialization not yet finished. Don't do anything yet. */
 	if (!test_bit(AF_INIT_DONE, &ha->flags))
-		goto do_dpc_exit;
+		return;
 
 	if (test_bit(AF_EEH_BUSY, &ha->flags)) {
 		DEBUG2(ql4_info(ha, "%s: flags = %lx\n", __func__, ha->flags));
-		goto do_dpc_exit;
+		return;
 	}
 
 	/* HBA is in the process of being permanently disabled.
@@ -1691,13 +1729,7 @@ dpc_post_reset_ha:
 	if (test_and_clear_bit(DPC_LINK_CHANGED, &ha->dpc_flags)) {
 		if (!test_bit(AF_LINK_UP, &ha->flags)) {
 			/* ---- link down? --- */
-			list_for_each_entry_safe(ddb_entry, dtemp,
-						 &ha->ddb_list, list) {
-				if (atomic_read(&ddb_entry->state) ==
-						DDB_STATE_ONLINE)
-					qla4xxx_mark_device_missing(ha,
-							ddb_entry);
-			}
+			qla4xxx_mark_all_devices_missing(ha);
 		} else {
 			/* ---- link up? --- *
 			 * F/W will auto login to all devices ONLY ONCE after
@@ -1705,30 +1737,7 @@ dpc_post_reset_ha:
 			 * fatal error recovery.  Therefore, the driver must
 			 * manually relogin to devices when recovering from
 			 * connection failures, logouts, expired KATO, etc. */
-
-			list_for_each_entry_safe(ddb_entry, dtemp,
-							&ha->ddb_list, list) {
-				if ((atomic_read(&ddb_entry->state) ==
-						 DDB_STATE_MISSING) ||
-				    (atomic_read(&ddb_entry->state) ==
-						 DDB_STATE_DEAD)) {
-					if ((ddb_entry->fw_ddb_device_state ==
-					     DDB_DS_SESSION_ACTIVE) &&
-					    ddb_entry->conn) {
-						atomic_set(&ddb_entry->state,
-							   DDB_STATE_ONLINE);
-						ql4_info(ha, "%s: ddb[%d]"
-							" marked ONLINE\n",
-							__func__,
-							ddb_entry->fw_ddb_index);
-
-						iscsi_unblock_session(
-							ddb_entry->sess);
-					} else
-						qla4xxx_relogin_device(
-							ha, ddb_entry);
-				}
-			}
+			qla4xxx_relogin_all_devices(ha);
 		}
 	}
 
@@ -1842,8 +1851,6 @@ dpc_post_reset_ha:
 		}
 		clear_bit(DPC_ASYNC_ISCSI_PDU, &ha->dpc_flags);
 	}
-do_dpc_exit:
-	clear_bit(AF_DPC_SCHEDULED, &ha->flags);
 }
 
 /**
diff --git a/drivers/scsi/qla4xxx/ql4_version.h b/drivers/scsi/qla4xxx/ql4_version.h
index 1ea3850..99419fe 100644
--- a/drivers/scsi/qla4xxx/ql4_version.h
+++ b/drivers/scsi/qla4xxx/ql4_version.h
@@ -5,7 +5,7 @@
  * See LICENSE.qla4xxx for copyright and licensing details.
  */
 
-#define QLA4XXX_DRIVER_VERSION	"5.02.10.00.11.2-k0"
+#define QLA4XXX_DRIVER_VERSION	"5.02.10.01.11.2-k0"
 
 /*
  * Driver Versioning Scheme:
-- 
1.6.0.2

