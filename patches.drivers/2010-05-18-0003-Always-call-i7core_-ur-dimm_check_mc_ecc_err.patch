From: Vernon Mauery <vernux@us.ibm.com>
Subject: Always call i7core_[ur]dimm_check_mc_ecc_err
References: fate#311968
Patch-Mainline: yes
Git-commit: 8a311e179e52d122ac203d8e88014284c18ca8ab


Signed-off-by: Thomas Renninger <trenn@suse.de>

This fixes an error in function i7core_check_error

In commit ca9c90ba09ca3c9799319f46a56f397afbf617c2 which converts the
driver to use double buffering, there is a change in the logic.  Before,
if mce_count was zero, it skipped over a couple of statements and
finished out with a call to the *check_mc_ecc_err function.  The current
code checks to see if mce_count is 0 and then exits.

This change reverts the behavior back to the original where if there are
no errors to report, we skip to the end and call the *check_mc_ecc_err
function.

This fix allows the driver to work again on my Nehalem based blades
again.

Signed-off-by: Vernon Mauery <vernux@us.ibm.com>
Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

---
 drivers/edac/i7core_edac.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

Index: linux-2.6.32-SLE11-SP1/drivers/edac/i7core_edac.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/edac/i7core_edac.c
+++ linux-2.6.32-SLE11-SP1/drivers/edac/i7core_edac.c
@@ -1671,7 +1671,7 @@ static void i7core_check_error(struct me
 	count = (pvt->mce_out + MCE_LOG_LEN - pvt->mce_in)
 		% MCE_LOG_LEN;
 	if (!count)
-		return;
+		goto check_ce_error;
 
 	m = pvt->mce_outentry;
 	if (pvt->mce_in + count > MCE_LOG_LEN) {
@@ -1704,6 +1704,7 @@ static void i7core_check_error(struct me
 	/*
 	 * Now, let's increment CE error counts
 	 */
+check_ce_error:
 	if (!pvt->is_registered)
 		i7core_udimm_check_mc_ecc_err(mci);
 	else
