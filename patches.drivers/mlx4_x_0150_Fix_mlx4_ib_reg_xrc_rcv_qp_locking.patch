From: Sébastien Dugué <sebastien.dugue@bull.net>
Subject: IB/mlx4_ib XRC RCV: Fix mlx4_ib_reg_xrc_rcv_qp() locking
References: bnc#706587
Patch-mainline: no

In mlx4_ib_reg_xrc_rcv_qp(), we need to take the xrc_reg_list_lock spinlock
when walking the xrc_reg_list.

Also, I guess spin_lock_irqsave() could be replaced by spin_lock_irq() in
that function as we know for sure we're in process context.

Signed-off-by: Sébastien Dugué <sebastien.dugue@bull.net>
Acked-by: John Jolly <jjolly@suse.de>

--

 drivers/infiniband/hw/mlx4/qp.c |    3 +++
 1 file changed, 3 insertions(+)

dIndex: kernel-ib/drivers/infiniband/hw/mlx4/qp.c
===================================================================
--- a/drivers/infiniband/hw/mlx4/qp.c
+++ b/drivers/infiniband/hw/mlx4/qp.c
@@ -2384,13 +2384,16 @@ int mlx4_ib_reg_xrc_rcv_qp(struct ib_xrc
 	}
 
 	mutex_lock(&mibqp->mutex);
+	spin_lock_irqsave(&mibqp->xrc_reg_list_lock, flags);
 	list_for_each_entry(tmp, &mibqp->xrc_reg_list, list)
 		if (tmp->context == context) {
+			spin_unlock_irqrestore(&mibqp->xrc_reg_list_lock, flags);
 			mutex_unlock(&mibqp->mutex);
 			kfree(ctx_entry);
 			mutex_unlock(&to_mdev(xrcd->device)->xrc_reg_mutex);
 			return 0;
 		}
+	spin_unlock_irqrestore(&mibqp->xrc_reg_list_lock, flags);
 
 	ctx_entry->context = context;
 	spin_lock_irqsave(&mibqp->xrc_reg_list_lock, flags);
