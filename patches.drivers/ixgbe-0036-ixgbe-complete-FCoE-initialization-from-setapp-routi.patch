From: John Fastabend <john.r.fastabend@intel.com>
Date: Sat, 18 Jun 2011 07:39:52 +0000
Subject: ixgbe: complete FCoE initialization from setapp() routine
Patch-mainline: v3.1-rc1
Git-commit: 9372453e87560f1602815bf08b9e2af0f5136a61
References: bnc#795303 FATE#313662

Commit,

commit c8ca76ebc6e50752c5311b92bb9aef7edb324577
Author: John Fastabend <john.r.fastabend@intel.com>
Date:   Sat Mar 12 03:50:53 2011 +0000

    ixgbe: DCB, further cleanups to app configuration

Removed the getapp() routines from ixgbe because they are no
longer needed. It also allowed the set hardware routines to
use both IEEE 802.1Qaz app types and CEE app types. This
added code to do bit shifting in the IEEE case.

This patch reverts the checks and handles the IEEE case
from the setapp entry point. I prefer this because it
keeps the two paths from having to be aware of the DCB
mode. This resolves a bug where I missed setting the
selector bit in the IEEE spec value and left it in the
CEE value. Now that they are separate routines these types
of errors should not occur.

Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
Tested-by: Ross Brattain <ross.b.brattain@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ixgbe/ixgbe_dcb_nl.c |   38 +++++++++++++++++++++++++-------------
 1 file changed, 25 insertions(+), 13 deletions(-)
--- a/drivers/net/ixgbe/ixgbe_dcb_nl.c
+++ b/drivers/net/ixgbe/ixgbe_dcb_nl.c
@@ -330,24 +330,20 @@ static void ixgbe_dcbnl_get_pfc_cfg(stru
 static u8 ixgbe_dcbnl_set_all(struct net_device *netdev)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	int ret;
+#ifdef IXGBE_FCOE
 	struct dcb_app app = {
 			      .selector = DCB_APP_IDTYPE_ETHTYPE,
 			      .protocol = ETH_P_FCOE,
 			     };
 	u8 up = dcb_getapp(netdev, &app);
-	int ret;
+#endif
 
 	ret = ixgbe_copy_dcb_cfg(&adapter->temp_dcb_cfg, &adapter->dcb_cfg,
 				 MAX_TRAFFIC_CLASS);
 	if (ret)
 		return DCB_NO_HW_CHG;
 
-	/* In IEEE mode app data must be parsed into DCBX format for
-	 * hardware routines.
-	 */
-	if (adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE)
-		up = (1 << up);
-
 #ifdef IXGBE_FCOE
 	if (up && (up != (1 << adapter->fcoe.up)))
 		adapter->dcb_set_bitmap |= BIT_APP_UPCHG;
@@ -678,18 +674,34 @@ static int ixgbe_dcbnl_ieee_setapp(struc
 				   struct dcb_app *app)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+	int err = -EINVAL;
 
 	if (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))
-		return -EINVAL;
+		return err;
 
-	dcb_setapp(dev, app);
+	err = dcb_ieee_setapp(dev, app);
 
 #ifdef IXGBE_FCOE
-	if (app->selector == 1 && app->protocol == ETH_P_FCOE &&
-	    adapter->fcoe.tc == app->priority)
-		ixgbe_dcbnl_set_all(dev);
+	if (!err && app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&
+	    app->protocol == ETH_P_FCOE) {
+		u8 app_mask = dcb_ieee_getapp_mask(dev, app);
+
+		if (app_mask & (1 << adapter->fcoe.up))
+			return err;
+
+		adapter->fcoe.up = app->priority;
+
+		if (netif_running(dev))
+			dev->netdev_ops->ndo_stop(dev);
+
+		ixgbe_clear_interrupt_scheme(adapter);
+		ixgbe_init_interrupt_scheme(adapter);
+
+		if (netif_running(dev))
+			dev->netdev_ops->ndo_open(dev);
+	}
 #endif
-	return 0;
+	return err;
 }
 
 static u8 ixgbe_dcbnl_getdcbx(struct net_device *dev)
