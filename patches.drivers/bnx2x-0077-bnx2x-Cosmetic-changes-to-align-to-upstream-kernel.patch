From: Yuval Mintz <yuvalmin@broadcom.com>
Date: Wed, 2 Jan 2013 13:37:59 +0200
Subject: [PATCH 77/77] bnx2x: Cosmetic changes to align to upstream kernel
Patch-mainline: Never
References: bnc#790597 FATE#313915

This (non-upstream) patch contains several cosmetic changes which
align this kernel with current upstream version - mostly new lines
and indentation fixes.
This will make it easier to backport patches in the future.

Signed-off-by: Yuval Mintz <yuvalmin@broadcom.com>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ethernet/broadcom/bnx2x/bnx2x.h         |   12 ------
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c     |   16 +++-----
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h     |    2 -
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c     |    3 -
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_fw_defs.h |    4 --
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_hsi.h     |    2 -
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c    |    7 +--
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.h    |    3 -
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c    |   25 +++++++------
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h     |    5 +-
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c      |    2 -
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h      |   36 ++++++++------------
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c   |    5 --
 13 files changed, 49 insertions(+), 73 deletions(-)

--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h
@@ -276,7 +276,6 @@ enum {
  * txdata for FWD (if exist) is one location after FCoE
  * txdata for OOO (if exist) is one location after FWD
  */
-
 enum {
 	FCOE_TXQ_IDX_OFFSET,
 	FWD_TXQ_IDX_OFFSET,
@@ -1438,7 +1437,7 @@ struct bnx2x {
 	int				fw_stats_req_sz;
 
 	/*
-	 * FW statistics data shortcut (points at the begining of
+	 * FW statistics data shortcut (points at the beginning of
 	 * fw_stats buffer + fw_stats_req_sz).
 	 */
 	struct bnx2x_fw_stats_data	*fw_stats_data;
@@ -1776,15 +1775,6 @@ int bnx2x_set_mac_one(struct bnx2x *bp,
 		      struct bnx2x_vlan_mac_obj *obj, bool set,
 		      int mac_type, unsigned long *ramrod_flags);
 /**
- * Deletes all MACs configured for the specific MAC object.
- *
- * @param bp Function driver instance
- * @param mac_obj MAC object to cleanup
- *
- * @return zero if all MACs were cleaned
- */
-
-/**
  * bnx2x_del_all_macs - delete all MACs configured for the specific MAC object
  *
  * @bp:			driver handle
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
@@ -619,8 +619,8 @@ static int bnx2x_alloc_rx_skb(struct bnx
 
 static
 void bnx2x_csum_validate(struct sk_buff *skb, union eth_rx_cqe *cqe,
-				struct bnx2x_fastpath *fp,
-				struct bnx2x_eth_q_stats *qstats)
+				 struct bnx2x_fastpath *fp,
+				 struct bnx2x_eth_q_stats *qstats)
 {
 	/* Do nothing if no L4 csum validation was done.
 	 * We do not check whether IP csum was validated. For IPv4 we assume
@@ -1773,8 +1773,7 @@ static int bnx2x_init_rss_pf(struct bnx2
 	int i;
 	u8 num_eth_queues = BNX2X_NUM_ETH_QUEUES(bp);
 
-	/*
-	 * Prepare the initial contents for the indirection table if RSS is
+	/* Prepare the initial contents fo the indirection table if RSS is
 	 * enabled
 	 */
 	for (i = 0; i < sizeof(bp->rss_conf_obj.ind_table); i++)
@@ -2039,8 +2038,8 @@ static void bnx2x_bz_fp(struct bnx2x *bp
 	 * minimal size so it must be set prior to queue memory allocation
 	 */
 	fp->disable_tpa = !(bp->flags & TPA_ENABLE_FLAG ||
-			   (bp->flags & GRO_ENABLE_FLAG &&
-			    bnx2x_mtu_allows_gro(bp->dev->mtu)));
+				  (bp->flags & GRO_ENABLE_FLAG &&
+				   bnx2x_mtu_allows_gro(bp->dev->mtu)));
 	if (bp->flags & TPA_ENABLE_FLAG)
 		fp->mode = TPA_MODE_LRO;
 	else if (bp->flags & GRO_ENABLE_FLAG)
@@ -2051,7 +2050,6 @@ static void bnx2x_bz_fp(struct bnx2x *bp
 		fp->disable_tpa = 1;
 }
 
-
 int bnx2x_load_cnic(struct bnx2x *bp)
 {
 	int i, rc, port = BP_PORT(bp);
@@ -2136,8 +2134,8 @@ load_error_cnic0:
 	bnx2x_free_mem_cnic(bp);
 	return rc;
 #endif /* ! BNX2X_STOP_ON_ERROR */
- }
- 
+}
+
 
 /* must be called with rtnl_lock */
 int bnx2x_nic_load(struct bnx2x *bp, int load_mode)
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
@@ -91,7 +91,7 @@ void bnx2x_send_unload_done(struct bnx2x
  * bnx2x_config_rss_pf - configure RSS parameters in a PF.
  *
  * @bp:			driver handle
- * @rss_obj		RSS object to use
+ * @rss_obj:		RSS object to use
  * @ind_table:		indirection table to configure
  * @config_hash:	re-configure RSS hash keys configuration
  */
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_dcb.c
@@ -29,7 +29,6 @@
 #include "bnx2x_cmn.h"
 #include "bnx2x_dcb.h"
 
-
 /* forward declarations of dcbx related functions */
 static int bnx2x_dcbx_stop_hw_tx(struct bnx2x *bp);
 static void bnx2x_pfc_set_pfc(struct bnx2x *bp);
@@ -763,7 +762,7 @@ void bnx2x_dcbx_set_params(struct bnx2x
 		DP(NETIF_MSG_LINK, "BNX2X_DCBX_STATE_TX_RELEASED\n");
 		bnx2x_fw_command(bp, DRV_MSG_CODE_DCBX_PMF_DRV_OK, 0);
 #ifdef BCM_DCBNL
-		/**
+		/*
 		 * Send a notification for the new negotiated parameters
 		 */
 		dcbnl_cee_notify(bp->dev, RTM_GETDCB, DCB_CMD_CEE_GET, 0, 0);
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_fw_defs.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_fw_defs.h
@@ -318,9 +318,7 @@
 #define DISABLE_STATISTIC_COUNTER_ID_VALUE 0
 
 
-/**
- * This file defines HSI constants common to all microcode flows
- */
+/* This file defines HSI constants common to all microcode flows */
 
 #define PROTOCOL_STATE_BIT_OFFSET 6
 
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_hsi.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_hsi.h
@@ -2818,7 +2818,7 @@ struct afex_stats {
 #define BCM_5710_FW_MAJOR_VERSION			7
 #define BCM_5710_FW_MINOR_VERSION			8
 #define BCM_5710_FW_REVISION_VERSION		2
-#define BCM_5710_FW_ENGINEERING_VERSION		0
+#define BCM_5710_FW_ENGINEERING_VERSION			0
 #define BCM_5710_FW_COMPILE_FLAGS			1
 
 
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c
@@ -3598,6 +3598,7 @@ static void bnx2x_ext_phy_update_adv_fc(
 			 MDIO_AN_REG_ADV_PAUSE_MASK) >> 10;
 	DP(NETIF_MSG_LINK, "Ext PHY pause result 0x%x\n", pause_result);
 	bnx2x_pause_resolve(vars, pause_result);
+
 }
 
 static u8 bnx2x_ext_phy_resolve_fc(struct bnx2x_phy *phy,
@@ -3605,18 +3606,16 @@ static u8 bnx2x_ext_phy_resolve_fc(struc
 				   struct link_vars *vars)
 {
 	u8 ret = 0;
-
 	vars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-
 	if (phy->req_flow_ctrl != BNX2X_FLOW_CTRL_AUTO) {
 		/* Update the advertised flow-controled of LD/LP in AN */
 		if (phy->req_line_speed == SPEED_AUTO_NEG)
 			bnx2x_ext_phy_update_adv_fc(phy, params, vars);
 		/* But set the flow-control result as the requested one */
 		vars->flow_ctrl = phy->req_flow_ctrl;
-	} else if (phy->req_line_speed != SPEED_AUTO_NEG) {
+	} else if (phy->req_line_speed != SPEED_AUTO_NEG)
 		vars->flow_ctrl = params->req_fc_auto_adv;
-	} else if (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {
+	else if (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {
 		ret = 1;
 		bnx2x_ext_phy_update_adv_fc(phy, params, vars);
 	}
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.h
@@ -493,8 +493,7 @@ struct bnx2x_ets_params {
 	struct bnx2x_ets_cos_params cos[DCBX_MAX_NUM_COS];
 };
 
-/**
- * Used to update the PFC attributes in EMAC, BMAC, NIG and BRB
+/* Used to update the PFC attributes in EMAC, BMAC, NIG and BRB
  * when link is already up
  */
 int bnx2x_update_pfc(struct link_params *params,
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@ -3998,7 +3998,7 @@ void bnx2x_set_pf_load(struct bnx2x *bp)
 }
 
 /**
- * bnx2x_clear_pf_load - decrement the load counter
+ * bnx2x_clear_pf_load - clear pf load mark
  *
  * @bp:		driver handle
  *
@@ -4052,7 +4052,7 @@ static bool bnx2x_get_load_status(struct
 
 	val = (val & mask) >> shift;
 
-	DP(NETIF_MSG_HW | NETIF_MSG_IFUP, "load mask for engine %d = %d\n",
+	DP(NETIF_MSG_HW | NETIF_MSG_IFUP, "load mask for engine %d = 0x%x\n",
 	   engine, val);
 
 	return val != 0;
@@ -4064,7 +4064,7 @@ static void _print_next_block(int idx, c
 }
 
 static int bnx2x_check_blocks_with_parity0(u32 sig, int par_num,
-						  bool print)
+					   bool print)
 {
 	int i = 0;
 	u32 cur_bit = 0;
@@ -10579,8 +10579,8 @@ static void __devinit bnx2x_get_cnic_mac
 				val = MF_CFG_RD(bp, func_ext_config[func].
 						iscsi_mac_addr_lower);
 				bnx2x_set_mac_buf(iscsi_mac, val, val2);
-				BNX2X_DEV_INFO("Read iSCSI MAC: %pM\n",
-					       iscsi_mac);
+				BNX2X_DEV_INFO
+					("Read iSCSI MAC: %pM\n", iscsi_mac);
 			} else {
 				bp->flags |= NO_ISCSI_OOO_FLAG | NO_ISCSI_FLAG;
 			}
@@ -10589,10 +10589,10 @@ static void __devinit bnx2x_get_cnic_mac
 				val2 = MF_CFG_RD(bp, func_ext_config[func].
 						 fcoe_mac_addr_upper);
 				val = MF_CFG_RD(bp, func_ext_config[func].
-						 fcoe_mac_addr_lower);
+						fcoe_mac_addr_lower);
 				bnx2x_set_mac_buf(fip_mac, val, val2);
-				BNX2X_DEV_INFO("Read FCoE L2 MAC: %pM\n",
-					       fip_mac);
+				BNX2X_DEV_INFO
+					("Read FCoE L2 MAC: %pM\n", fip_mac);
 			} else {
 				bp->flags |= NO_FCOE_FLAG;
 			}
@@ -10623,6 +10623,7 @@ static void __devinit bnx2x_get_cnic_mac
 		if (IS_MF_FCOE_AFEX(bp))
 			/* use FIP MAC as primary MAC */
 			memcpy(bp->dev->dev_addr, fip_mac, ETH_ALEN);
+
 	} else {
 		val2 = SHMEM_RD(bp, dev_info.port_hw_config[port].
 				iscsi_mac_upper);
@@ -10637,7 +10638,7 @@ static void __devinit bnx2x_get_cnic_mac
 		bnx2x_set_mac_buf(fip_mac, val, val2);
 	}
 
-	/* Disable iSCSI if MAC configuration is invalid. */
+	/* Disable iSCSI OOO if MAC configuration is invalid. */
 	if (!is_valid_ether_addr(iscsi_mac)) {
 		bp->flags |= NO_ISCSI_OOO_FLAG | NO_ISCSI_FLAG;
 		memset(iscsi_mac, 0, ETH_ALEN);
@@ -10683,6 +10684,7 @@ static void __devinit bnx2x_get_mac_hwin
 
 	memcpy(bp->link_params.mac_addr, bp->dev->dev_addr, ETH_ALEN);
 	memcpy(bp->dev->perm_addr, bp->dev->dev_addr, ETH_ALEN);
+
 	if (!bnx2x_is_valid_ether_addr(bp, bp->dev->dev_addr))
 		dev_err(&bp->pdev->dev,
 			"bad Ethernet MAC address configuration: %pM\n"
@@ -11109,6 +11111,7 @@ static int __devinit bnx2x_init_bp(struc
 		bnx2x_prev_unload(bp);
 	}
 
+
 	if (CHIP_REV_IS_FPGA(bp))
 		dev_err(&bp->pdev->dev, "FPGA detected\n");
 
@@ -11832,8 +11835,7 @@ static void bnx2x_prep_ops(const u8 *_so
 	}
 }
 
-/**
- * IRO array is stored in the following format:
+/* IRO array is stored in the following format:
  * {base(24bit), m1(16bit), m2(16bit), m3(16bit), size(16bit) }
  */
 static void bnx2x_prep_iro(const u8 *_source, u8 *_target, u32 n)
@@ -12163,6 +12165,7 @@ static int __devinit bnx2x_init_one(stru
 	/* disable FCOE L2 queue for E1x*/
 	if (CHIP_IS_E1x(bp))
 		bp->flags |= NO_FCOE_FLAG;
+
 	/* disable FCOE for 57840 device, until FW supports it */
 	switch (ent->driver_data) {
 	case BCM57840_O:
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h
@@ -1,5 +1,5 @@
 /* bnx2x_reg.h: Broadcom Everest network driver.
-
+ *
  * Copyright (c) 2007-2012 Broadcom Corporation
  *
  * This program is free software; you can redistribute it and/or modify
@@ -7340,8 +7340,7 @@ Theotherbitsarereservedandshouldbezero*/
 #define CDU_REGION_NUMBER_UCM_AG 4
 
 
-/**
- * String-to-compress [31:8] = CID (all 24 bits)
+/* String-to-compress [31:8] = CID (all 24 bits)
  * String-to-compress [7:4] = Region
  * String-to-compress [3:0] = Type
  */
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
@@ -4318,7 +4318,7 @@ static int bnx2x_queue_comp_cmd(struct b
 
 	if (o->next_tx_only >= o->max_cos)
 		/* >= becuase tx only must always be smaller than cos since the
-		 * primary connection suports COS 0
+		 * primary connection supports COS 0
 		 */
 		BNX2X_ERR("illegal value for next tx_only: %d. max cos was %d",
 			   o->next_tx_only, o->max_cos);
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h
@@ -173,9 +173,8 @@ typedef int (*exe_q_remove)(struct bnx2x
 			    union bnx2x_qable_obj *o,
 			    struct bnx2x_exeq_elem *elem);
 
-/**
- * @return positive is entry was optimized, 0 - if not, negative
- *         in case of an error.
+/* Return positive if entry was optimized, 0 - if not, negative
+ * in case of an error.
  */
 typedef int (*exe_q_optimize)(struct bnx2x *bp,
 			      union bnx2x_qable_obj *o,
@@ -1298,12 +1297,11 @@ void bnx2x_init_rx_mode_obj(struct bnx2x
 			    struct bnx2x_rx_mode_obj *o);
 
 /**
- * Send and RX_MODE ramrod according to the provided parameters.
+ * bnx2x_config_rx_mode - Send and RX_MODE ramrod according to the provided parameters.
  *
- * @param bp
- * @param p Command parameters
+ * @p: Command parameters
  *
- * @return 0 - if operation was successfull and there is no pending completions,
+ * Return: 0 - if operation was successfull and there is no pending completions,
  *         positive number - if there are pending completions,
  *         negative - if there were errors
  */
@@ -1320,7 +1318,11 @@ void bnx2x_init_mcast_obj(struct bnx2x *
 			  bnx2x_obj_type type);
 
 /**
- * Configure multicast MACs list. May configure a new list
+ * bnx2x_config_mcast - Configure multicast MACs list.
+ *
+ * @cmd: command to execute: BNX2X_MCAST_CMD_X
+ *
+ * May configure a new list
  * provided in p->mcast_list (BNX2X_MCAST_CMD_ADD), clean up
  * (BNX2X_MCAST_CMD_DEL) or restore (BNX2X_MCAST_CMD_RESTORE) a current
  * configuration, continue to execute the pending commands
@@ -1331,11 +1333,7 @@ void bnx2x_init_mcast_obj(struct bnx2x *
  * the current command will be enqueued to the tail of the
  * pending commands list.
  *
- * @param bp
- * @param p
- * @param command to execute: BNX2X_MCAST_CMD_X
- *
- * @return 0 is operation was sucessfull and there are no pending completions,
+ * Return: 0 is operation was successfull and there are no pending completions,
  *         negative if there were errors, positive if there are pending
  *         completions.
  */
@@ -1360,21 +1358,17 @@ void bnx2x_init_rss_config_obj(struct bn
 			       bnx2x_obj_type type);
 
 /**
- * Updates RSS configuration according to provided parameters.
- *
- * @param bp
- * @param p
+ * bnx2x_config_rss - Updates RSS configuration according to provided parameters
  *
- * @return 0 in case of success
+ * Return: 0 in case of success
  */
 int bnx2x_config_rss(struct bnx2x *bp,
 		     struct bnx2x_config_rss_params *p);
 
 /**
- * Return the current ind_table configuration.
+ * bnx2x_get_rss_ind_table - Return the current ind_table configuration.
  *
- * @param bp
- * @param ind_table buffer to fill with the current indirection
+ * @ind_table: buffer to fill with the current indirection
  *                  table content. Should be at least
  *                  T_ETH_INDIRECTION_TABLE_SIZE bytes long.
  */
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c
@@ -1354,12 +1354,9 @@ static void bnx2x_port_stats_base_init(s
 	bnx2x_stats_comp(bp);
 }
 
-/**
- * This function will prepare the statistics ramrod data the way
+/* This function will prepare the statistics ramrod data the way
  * we will only have to increment the statistics counter and
  * send the ramrod each time we have to.
- *
- * @param bp
  */
 static void bnx2x_prep_fw_stats_req(struct bnx2x *bp)
 {
