From: ServeRAID Driver Development <ServeRAIDDriver@hcl.in>
Date: Mon, 27 Sep 2010 09:39:30 +0200
Subject: aacraid race condition
References: bnc#636850
Patch-Mainline: n/a

We have identified a possibility of race condition when trying
to limit the Management Fibs count to avoid File System read
only issue. To avoid File System read only, we are restricting
the management fib count to 8 using a conditional check (management
fib count should not greater than  AAC_NUM_MGT_FIB). But in case
of aacraid 24701, the condition check and increment operation of
the management fib are not with in the same lock. Hence, multiple
threads can go through the same code at a time and might cause
race condition.

Signed-off-by: ServeRAID Driver Development <ServeRAIDDriver@hcl.in>
Acked-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/aacraid/aacraid.h b/drivers/scsi/aacraid/aacraid.h
index 587c4e6..929cf67 100644
--- a/drivers/scsi/aacraid/aacraid.h
+++ b/drivers/scsi/aacraid/aacraid.h
@@ -12,7 +12,7 @@
  *----------------------------------------------------------------------------*/
 
 #ifndef AAC_DRIVER_BUILD
-# define AAC_DRIVER_BUILD 24701
+# define AAC_DRIVER_BUILD 24702
 # define AAC_DRIVER_BRANCH "-ms"
 #endif
 #define MAXIMUM_NUM_CONTAINERS	32
diff --git a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c
index d29af45..569e2a5 100644
--- a/drivers/scsi/aacraid/commsup.c
+++ b/drivers/scsi/aacraid/commsup.c
@@ -397,6 +397,7 @@ int aac_fib_send(u16 command, struct fib *fibptr, unsigned long size,
 	struct hw_fib * hw_fib = fibptr->hw_fib_va;
 	unsigned long flags = 0;
 	unsigned long qflags;
+	unsigned long mflags = 0;
 
 	if (!(hw_fib->header.XferState & cpu_to_le32(HostOwned)))
 		return -EBUSY;
@@ -478,13 +479,28 @@ int aac_fib_send(u16 command, struct fib *fibptr, unsigned long size,
 	if (!dev->queues)
 		return -EBUSY;
 
-	if(wait)
+	if(wait) {
+
+		spin_lock_irqsave(&dev->manage_lock, mflags);
+		if (dev->management_fib_count >= AAC_NUM_MGT_FIB) {
+			printk(KERN_INFO "No management Fibs Available:%d\n",
+						dev->management_fib_count);
+			spin_unlock_irqrestore(&dev->manage_lock, mflags);
+			return -EBUSY;
+		}
+		dev->management_fib_count++;
+		spin_unlock_irqrestore(&dev->manage_lock, mflags);
 		spin_lock_irqsave(&fibptr->event_lock, flags);
+	}
 
 	if (aac_adapter_deliver(fibptr) != 0) {
 		printk(KERN_ERR "aac_fib_send: returned -EBUSY\n");
-		if (wait)
+		if (wait) {
 			spin_unlock_irqrestore(&fibptr->event_lock, flags);
+			spin_lock_irqsave(&dev->manage_lock, mflags);
+			dev->management_fib_count--;
+			spin_unlock_irqrestore(&dev->manage_lock, mflags);
+		}
 		return -EBUSY;
 	}
 
@@ -494,13 +510,7 @@ int aac_fib_send(u16 command, struct fib *fibptr, unsigned long size,
 	 */
 
 	if (wait) {
-		unsigned long mflags;
 		spin_unlock_irqrestore(&fibptr->event_lock, flags);
-
-		spin_lock_irqsave(&dev->manage_lock, mflags);
-		dev->management_fib_count++;
-		spin_unlock_irqrestore(&dev->manage_lock, mflags);
-
 		/* Only set for first known interruptable command */
 		if (wait < 0) {
 			/*
@@ -535,9 +545,10 @@ int aac_fib_send(u16 command, struct fib *fibptr, unsigned long size,
 				}
 				udelay(5);
 			}
-		} else
-			down_interruptible(&fibptr->event_wait);
-
+		} else if (down_interruptible(&fibptr->event_wait)) {
+			/* Do nothing ... satisfy
+			* down_interruptible must_check */
+		}
 		spin_lock_irqsave(&fibptr->event_lock, flags);
 		if (fibptr->done == 0) {
 			fibptr->done = 2; /* Tell interrupt we aborted */
