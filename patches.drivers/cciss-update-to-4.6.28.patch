From: Mike Miller <mike.miller@hp.com>
Date: Fri, 1 Jul 2011 12:50:30 +0200
Subject: cciss: Update to version 4.6.28
References: FATE#311200,bnc#703422
Patch-Mainline: Not yet

This patch updates the cciss driver to versionn 4.6.28.

Signed-off-by: Mike Miller <mike.miller@hp.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/block/cciss.c       |  320 +++++++++++++++-----------------------------
 drivers/block/cciss.h       |  151 ++++++++++----------
 drivers/block/cciss_cmd.h   |   14 -
 drivers/block/cciss_scsi.c  |  223 +++++++++++++++---------------
 drivers/block/cciss_scsi.h  |    3 
 include/linux/cciss_ioctl.h |    8 -
 6 files changed, 313 insertions(+), 406 deletions(-)

--- a/drivers/block/cciss.c
+++ b/drivers/block/cciss.c
@@ -1,6 +1,6 @@
 /*
  *    Disk Array driver for HP Smart Array controllers.
- *    (C) Copyright 2000, 2007 Hewlett-Packard Development Company, L.P.
+ *    (C) Copyright 2000, 2010 Hewlett-Packard Development Company, L.P.
  *
  *    This program is free software; you can redistribute it and/or modify
  *    it under the terms of the GNU General Public License as published by
@@ -52,30 +52,34 @@
 #include <scsi/scsi_ioctl.h>
 #include <linux/cdrom.h>
 #include <linux/scatterlist.h>
-#include <linux/kthread.h>
+#include "cciss_cmd.h"
+#include "cciss.h"
+#include <linux/cciss_ioctl.h>
 
 #define CCISS_DRIVER_VERSION(maj,min,submin) ((maj<<16)|(min<<8)|(submin))
-#define DRIVER_NAME "HP CISS Driver (v 3.6.26)"
-#define DRIVER_VERSION CCISS_DRIVER_VERSION(3, 6, 26)
+#define DRIVER_NAME "HP CISS Driver (v 4.6.28)"
+#define DRIVER_VERSION CCISS_DRIVER_VERSION(4, 6, 28)
 
 /* Embedded module documentation macros - see modules.h */
 MODULE_AUTHOR("Hewlett-Packard Company");
 MODULE_DESCRIPTION("Driver for HP Smart Array Controllers");
 MODULE_SUPPORTED_DEVICE("HP Smart Array Controllers");
-MODULE_VERSION("3.6.26");
+MODULE_VERSION("4.6.28");
 MODULE_LICENSE("GPL");
 static int cciss_tape_cmds = 6;
 module_param(cciss_tape_cmds, int, 0644);
 MODULE_PARM_DESC(cciss_tape_cmds,
 	"number of commands to allocate for tape devices (default: 6)");
 
+static int cciss_allow_hpsa;
+module_param(cciss_allow_hpsa, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(cciss_allow_hpsa,
+	"Prevent cciss driver from accessing hardware known to be "
+	" supported by the hpsa driver");
+
 static DEFINE_MUTEX(cciss_mutex);
 static struct proc_dir_entry *proc_cciss;
 
-#include "cciss_cmd.h"
-#include "cciss.h"
-#include <linux/cciss_ioctl.h>
-
 /* define the PCI info for the cards we can control */
 static const struct pci_device_id cciss_pci_device_id[] = {
 	{PCI_VENDOR_ID_COMPAQ, PCI_DEVICE_ID_COMPAQ_CISS,  0x0E11, 0x4070},
@@ -127,9 +131,7 @@ static struct board_type products[] = {
 	{0x3214103C, "Smart Array E200i", &SA5_access},
 	{0x3215103C, "Smart Array E200i", &SA5_access},
 	{0x3237103C, "Smart Array E500", &SA5_access},
-	{0x3223103C, "Smart Array P800", &SA5_access},
-	{0x3234103C, "Smart Array P400", &SA5_access},
-	{0x323D103C, "Smart Array P700m", &SA5_access},
+	{0x323d103c, "Smart Array P700M", &SA5_access},
 };
 
 /* How long to wait (in milliseconds) for board to go into simple mode */
@@ -142,14 +144,10 @@ static struct board_type products[] = {
 #define MAX_CTLR	32
 
 /* Originally cciss driver only supports 8 major numbers */
-#define MAX_CTLR_ORIG 	8
+#define MAX_CTLR_ORIG	8
 
 static ctlr_info_t *hba[MAX_CTLR];
 
-static struct task_struct *cciss_scan_thread;
-static DEFINE_MUTEX(scan_mutex);
-static LIST_HEAD(scan_q);
-
 static void do_cciss_request(struct request_queue *q);
 static irqreturn_t do_cciss_intx(int irq, void *dev_id);
 static irqreturn_t do_cciss_msix_intr(int irq, void *dev_id);
@@ -184,14 +182,15 @@ static int sendcmd_withirq_core(ctlr_inf
 	int attempt_retry);
 static int process_sendcmd_error(ctlr_info_t *h, CommandList_struct *c);
 
-static int add_to_scan_list(struct ctlr_info *h);
-static int scan_thread(void *data);
+static void cciss_get_uid(ctlr_info_t *h, int logvol,
+				unsigned char *uid, int buflen);
 static int check_for_unit_attention(ctlr_info_t *h, CommandList_struct *c);
 static void cciss_hba_release(struct device *dev);
 static void cciss_device_release(struct device *dev);
 static void cciss_free_gendisk(ctlr_info_t *h, int drv_index);
 static void cciss_free_drive_info(ctlr_info_t *h, int drv_index);
-static inline u32 next_command(ctlr_info_t *h);
+static inline void log_unit_to_scsi3addr(ctlr_info_t *h,
+	unsigned char scsi3addr[], uint32_t log_unit);
 static int __devinit cciss_find_cfg_addrs(struct pci_dev *pdev,
 	void __iomem *vaddr, u32 *cfg_base_addr, u64 *cfg_base_addr_index,
 	u64 *cfg_offset);
@@ -218,6 +217,8 @@ static void cciss_procinit(ctlr_info_t *
 static int cciss_compat_ioctl(struct block_device *, fmode_t,
 			      unsigned, unsigned long);
 #endif
+static void cciss_sysfs_stat_inquiry(ctlr_info_t *h, int logvol,
+			drive_info_struct *drv);
 
 static const struct block_device_operations cciss_fops = {
 	.owner = THIS_MODULE,
@@ -557,8 +558,6 @@ static void __devinit cciss_procinit(ctl
 }
 #endif				/* CONFIG_PROC_FS */
 
-#define MAX_PRODUCT_NAME_LEN 19
-
 #define to_hba(n) container_of(n, struct ctlr_info, dev)
 #define to_drv(n) container_of(n, drive_info_struct, dev)
 
@@ -622,6 +621,7 @@ static ssize_t host_show_resettable(stru
 }
 static DEVICE_ATTR(resettable, S_IRUGO, host_show_resettable, NULL);
 
+#if 0
 static ssize_t host_store_rescan(struct device *dev,
 				 struct device_attribute *attr,
 				 const char *buf, size_t count)
@@ -635,6 +635,7 @@ static ssize_t host_store_rescan(struct
 	return count;
 }
 static DEVICE_ATTR(rescan, S_IWUSR, NULL, host_store_rescan);
+#endif /* mfm need to do something else in sysfs */
 
 static ssize_t dev_show_unique_id(struct device *dev,
 				 struct device_attribute *attr,
@@ -650,7 +651,7 @@ static ssize_t dev_show_unique_id(struct
 	if (h->busy_configuring)
 		ret = -EBUSY;
 	else
-		memcpy(sn, drv->serial_no, sizeof(sn));
+		memcpy(sn, drv->uid, sizeof(sn));
 	spin_unlock_irqrestore(&h->lock, flags);
 
 	if (ret)
@@ -806,7 +807,9 @@ static ssize_t cciss_show_usage_count(st
 static DEVICE_ATTR(usage_count, S_IRUGO, cciss_show_usage_count, NULL);
 
 static struct attribute *cciss_host_attrs[] = {
+#if 0
 	&dev_attr_rescan.attr,
+#endif
 	&dev_attr_resettable.attr,
 	NULL
 };
@@ -1179,6 +1182,7 @@ static int cciss_ioctl32_passthru(struct
 	int err;
 	u32 cp;
 
+	memset(&arg64, 0, sizeof(arg64));
 	err = 0;
 	err |=
 	    copy_from_user(&arg64.LUN_info, &arg32->LUN_info,
@@ -1453,20 +1457,17 @@ static int cciss_passthru(ctlr_info_t *h
 	if (!capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
-	if (copy_from_user
-	    (&iocommand, argp, sizeof(IOCTL_Command_struct)))
+	if (copy_from_user(&iocommand, argp, sizeof(IOCTL_Command_struct)))
 		return -EFAULT;
 	if ((iocommand.buf_size < 1) &&
-	    (iocommand.Request.Type.Direction != XFER_NONE)) {
+	    (iocommand.Request.Type.Direction != XFER_NONE))
 		return -EINVAL;
-	}
 	if (iocommand.buf_size > 0) {
 		buff = kmalloc(iocommand.buf_size, GFP_KERNEL);
 		if (buff == NULL)
 			return -EFAULT;
 	}
 	if (iocommand.Request.Type.Direction == XFER_WRITE) {
-		/* Copy the data into the buffer we created */
 		if (copy_from_user(buff, iocommand.buf, iocommand.buf_size)) {
 			kfree(buff);
 			return -EFAULT;
@@ -1504,7 +1505,7 @@ static int cciss_passthru(ctlr_info_t *h
 		c->SG[0].Addr.lower = temp64.val32.lower;
 		c->SG[0].Addr.upper = temp64.val32.upper;
 		c->SG[0].Len = iocommand.buf_size;
-		c->SG[0].Ext = 0;  /* we are not chaining */
+		c->SG[0].Ext = 0; /* we are not chaining */
 	}
 	c->waiting = &wait;
 
@@ -1512,7 +1513,7 @@ static int cciss_passthru(ctlr_info_t *h
 	wait_for_completion(&wait);
 
 	if (iocommand.buf_size > 0) {
-		/* unlock the buffers from DMA */
+		/* unmap the DMA buffers */
 		temp64.val32.lower = c->SG[0].Addr.lower;
 		temp64.val32.upper = c->SG[0].Addr.upper;
 		pci_unmap_single(h->pdev, (dma_addr_t) temp64.val,
@@ -1618,19 +1619,28 @@ static int cciss_bigpassthru(ctlr_info_t
 	}
 	c->cmd_type = CMD_IOCTL_PEND;
 	c->Header.ReplyQueue = 0;
-	c->Header.SGList = sg_used;
-	c->Header.SGTotal = sg_used;
+
+	if (ioc->buf_size > 0) {
+		c->Header.SGList = sg_used;
+		c->Header.SGTotal = sg_used;
+	} else {
+		c->Header.SGList = 0;
+		c->Header.SGTotal = 0;
+	}
 	c->Header.LUN = ioc->LUN_info;
 	c->Header.Tag.lower = c->busaddr;
 
 	c->Request = ioc->Request;
-	for (i = 0; i < sg_used; i++) {
-		temp64.val = pci_map_single(h->pdev, buff[i], buff_size[i],
-				    PCI_DMA_BIDIRECTIONAL);
-		c->SG[i].Addr.lower = temp64.val32.lower;
-		c->SG[i].Addr.upper = temp64.val32.upper;
-		c->SG[i].Len = buff_size[i];
-		c->SG[i].Ext = 0;	/* we are not chaining */
+	if (ioc->buf_size > 0) {
+		int i;
+		for (i = 0; i < sg_used; i++) {
+			temp64.val = pci_map_single(h->pdev, buff[i],
+				    buff_size[i], PCI_DMA_BIDIRECTIONAL);
+			c->SG[i].Addr.lower = temp64.val32.lower;
+			c->SG[i].Addr.upper = temp64.val32.upper;
+			c->SG[i].Len = buff_size[i];
+			c->SG[i].Ext = 0;	/* we are not chaining */
+		}
 	}
 	c->waiting = &wait;
 	enqueue_cmd_and_start_io(h, c);
@@ -1639,9 +1649,8 @@ static int cciss_bigpassthru(ctlr_info_t
 	for (i = 0; i < sg_used; i++) {
 		temp64.val32.lower = c->SG[i].Addr.lower;
 		temp64.val32.upper = c->SG[i].Addr.upper;
-		pci_unmap_single(h->pdev,
-			(dma_addr_t) temp64.val, buff_size[i],
-			PCI_DMA_BIDIRECTIONAL);
+		pci_unmap_single(h->pdev, (dma_addr_t) temp64.val,
+			buff_size[i], PCI_DMA_BIDIRECTIONAL);
 	}
 	check_ioctl_unit_attention(h, c);
 	/* Copy the error information out */
@@ -1677,7 +1686,7 @@ cleanup1:
 }
 
 static int cciss_ioctl(struct block_device *bdev, fmode_t mode,
-	unsigned int cmd, unsigned long arg)
+       unsigned int cmd, unsigned long arg)
 {
 	struct gendisk *disk = bdev->bd_disk;
 	ctlr_info_t *h = get_host(disk);
@@ -1880,8 +1889,8 @@ static void cciss_get_device_descr(ctlr_
  * number cannot be had, for whatever reason, 16 bytes of 0xff
  * are returned instead.
  */
-static void cciss_get_serial_no(ctlr_info_t *h, int logvol,
-				unsigned char *serial_no, int buflen)
+static void cciss_get_uid(ctlr_info_t *h, int logvol,
+				unsigned char *uid, int buflen)
 {
 #define PAGE_83_INQ_BYTES 64
 	int rc;
@@ -1890,16 +1899,16 @@ static void cciss_get_serial_no(ctlr_inf
 
 	if (buflen > 16)
 		buflen = 16;
-	memset(serial_no, 0xff, buflen);
+	memset(uid, 0xff, buflen);
 	buf = kzalloc(PAGE_83_INQ_BYTES, GFP_KERNEL);
 	if (!buf)
 		return;
-	memset(serial_no, 0, buflen);
+	memset(uid, 0, buflen);
 	log_unit_to_scsi3addr(h, scsi3addr, logvol);
 	rc = sendcmd_withirq(h, CISS_INQUIRY, buf,
 		PAGE_83_INQ_BYTES, 0x83, scsi3addr, TYPE_CMD);
 	if (rc == IO_OK)
-		memcpy(serial_no, &buf[8], buflen);
+		memcpy(uid, &buf[8], buflen);
 	kfree(buf);
 	return;
 }
@@ -2007,16 +2016,15 @@ static void cciss_update_drive_info(ctlr
 
 	cciss_get_device_descr(h, drv_index, drvinfo->vendor,
 				drvinfo->model, drvinfo->rev);
-	cciss_get_serial_no(h, drv_index, drvinfo->serial_no,
-			sizeof(drvinfo->serial_no));
+	cciss_get_uid(h, drv_index, drvinfo->uid, sizeof(drvinfo->uid));
 	/* Save the lunid in case we deregister the disk, below. */
 	memcpy(drvinfo->LunID, h->drv[drv_index]->LunID,
 		sizeof(drvinfo->LunID));
 
 	/* Is it the same disk we already know, and nothing's changed? */
 	if (h->drv[drv_index]->raid_level != -1 &&
-		((memcmp(drvinfo->serial_no,
-				h->drv[drv_index]->serial_no, 16) == 0) &&
+		((memcmp(drvinfo->uid,
+				h->drv[drv_index]->uid, 16) == 0) &&
 		drvinfo->block_size == h->drv[drv_index]->block_size &&
 		drvinfo->nr_blocks == h->drv[drv_index]->nr_blocks &&
 		drvinfo->heads == h->drv[drv_index]->heads &&
@@ -2064,7 +2072,7 @@ static void cciss_update_drive_info(ctlr
 		h->drv[drv_index]->sectors = drvinfo->sectors;
 		h->drv[drv_index]->cylinders = drvinfo->cylinders;
 		h->drv[drv_index]->raid_level = drvinfo->raid_level;
-		memcpy(h->drv[drv_index]->serial_no, drvinfo->serial_no, 16);
+		memcpy(h->drv[drv_index]->uid, drvinfo->uid, 16);
 		memcpy(h->drv[drv_index]->vendor, drvinfo->vendor,
 			VENDOR_LEN + 1);
 		memcpy(h->drv[drv_index]->model, drvinfo->model, MODEL_LEN + 1);
@@ -2074,6 +2082,7 @@ static void cciss_update_drive_info(ctlr
 	++h->num_luns;
 	disk = h->gendisk[drv_index];
 	set_capacity(disk, h->drv[drv_index]->nr_blocks);
+	cciss_sysfs_stat_inquiry(h, drv_index, h->drv[drv_index]);
 
 	/* If it's not disk 0 (drv_index != 0)
 	 * or if it was disk 0, but there was previously
@@ -2234,7 +2243,7 @@ static void cciss_add_controller_node(ct
 	h->drv[drv_index]->sectors = 0;
 	h->drv[drv_index]->cylinders = 0;
 	h->drv[drv_index]->raid_level = -1;
-	memset(h->drv[drv_index]->serial_no, 0, 16);
+	memset(h->drv[drv_index]->uid, 0, 16);
 	disk = h->gendisk[drv_index];
 	if (cciss_add_disk(h, disk, drv_index) == 0)
 		return;
@@ -2396,7 +2405,7 @@ static void cciss_clear_drive_info(drive
 	drive_info->sectors = 0;
 	drive_info->cylinders = 0;
 	drive_info->raid_level = -1;
-	memset(drive_info->serial_no, 0, sizeof(drive_info->serial_no));
+	memset(drive_info->uid, 0, sizeof(drive_info->uid));
 	memset(drive_info->model, 0, sizeof(drive_info->model));
 	memset(drive_info->rev, 0, sizeof(drive_info->rev));
 	memset(drive_info->vendor, 0, sizeof(drive_info->vendor));
@@ -2928,7 +2937,7 @@ static int cciss_revalidate(struct gendi
 	InquiryData_struct *inq_buff = NULL;
 
 	for (logvol = 0; logvol <= h->highest_lun; logvol++) {
-		if (!h->drv[logvol])
+		if (!h->drv[logvol]) /* h->drv[] may contain holes */
 			continue;
 		if (memcmp(h->drv[logvol]->LunID, drv->LunID,
 			sizeof(drv->LunID)) == 0) {
@@ -3176,8 +3185,7 @@ static inline void complete_command(ctlr
 				DID_PASSTHROUGH : DID_ERROR);
 		break;
 	case CMD_UNSOLICITED_ABORT:
-		dev_warn(&h->pdev->dev, "cciss%d: unsolicited "
-		       "abort %p\n", h->ctlr, cmd);
+		dev_warn(&h->pdev->dev, "unsolicited abort %p\n", cmd);
 		if (cmd->retry_count < MAX_CMD_RETRIES) {
 			retry_cmd = 1;
 			dev_warn(&h->pdev->dev, "retrying %p\n", cmd);
@@ -3201,7 +3209,7 @@ static inline void complete_command(ctlr
 		dev_warn(&h->pdev->dev, "cmd %p unabortable\n", cmd);
 		rq->errors = make_status_bytes(SAM_STAT_GOOD,
 			cmd->err_info->CommandStatus, DRIVER_OK,
-			cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC ?
+			(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?
 				DID_PASSTHROUGH : DID_ERROR);
 		break;
 	default:
@@ -3613,127 +3621,6 @@ static irqreturn_t do_cciss_msix_intr(in
 	return IRQ_HANDLED;
 }
 
-/**
- * add_to_scan_list() - add controller to rescan queue
- * @h:		      Pointer to the controller.
- *
- * Adds the controller to the rescan queue if not already on the queue.
- *
- * returns 1 if added to the queue, 0 if skipped (could be on the
- * queue already, or the controller could be initializing or shutting
- * down).
- **/
-static int add_to_scan_list(struct ctlr_info *h)
-{
-	struct ctlr_info *test_h;
-	int found = 0;
-	int ret = 0;
-
-	if (h->busy_initializing)
-		return 0;
-
-	if (!mutex_trylock(&h->busy_shutting_down))
-		return 0;
-
-	mutex_lock(&scan_mutex);
-	list_for_each_entry(test_h, &scan_q, scan_list) {
-		if (test_h == h) {
-			found = 1;
-			break;
-		}
-	}
-	if (!found && !h->busy_scanning) {
-		INIT_COMPLETION(h->scan_wait);
-		list_add_tail(&h->scan_list, &scan_q);
-		ret = 1;
-	}
-	mutex_unlock(&scan_mutex);
-	mutex_unlock(&h->busy_shutting_down);
-
-	return ret;
-}
-
-/**
- * remove_from_scan_list() - remove controller from rescan queue
- * @h:			   Pointer to the controller.
- *
- * Removes the controller from the rescan queue if present. Blocks if
- * the controller is currently conducting a rescan.  The controller
- * can be in one of three states:
- * 1. Doesn't need a scan
- * 2. On the scan list, but not scanning yet (we remove it)
- * 3. Busy scanning (and not on the list). In this case we want to wait for
- *    the scan to complete to make sure the scanning thread for this
- *    controller is completely idle.
- **/
-static void remove_from_scan_list(struct ctlr_info *h)
-{
-	struct ctlr_info *test_h, *tmp_h;
-
-	mutex_lock(&scan_mutex);
-	list_for_each_entry_safe(test_h, tmp_h, &scan_q, scan_list) {
-		if (test_h == h) { /* state 2. */
-			list_del(&h->scan_list);
-			complete_all(&h->scan_wait);
-			mutex_unlock(&scan_mutex);
-			return;
-		}
-	}
-	if (h->busy_scanning) { /* state 3. */
-		mutex_unlock(&scan_mutex);
-		wait_for_completion(&h->scan_wait);
-	} else { /* state 1, nothing to do. */
-		mutex_unlock(&scan_mutex);
-	}
-}
-
-/**
- * scan_thread() - kernel thread used to rescan controllers
- * @data:	 Ignored.
- *
- * A kernel thread used scan for drive topology changes on
- * controllers. The thread processes only one controller at a time
- * using a queue.  Controllers are added to the queue using
- * add_to_scan_list() and removed from the queue either after done
- * processing or using remove_from_scan_list().
- *
- * returns 0.
- **/
-static int scan_thread(void *data)
-{
-	struct ctlr_info *h;
-
-	while (1) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule();
-		if (kthread_should_stop())
-			break;
-
-		while (1) {
-			mutex_lock(&scan_mutex);
-			if (list_empty(&scan_q)) {
-				mutex_unlock(&scan_mutex);
-				break;
-			}
-
-			h = list_entry(scan_q.next,
-				       struct ctlr_info,
-				       scan_list);
-			list_del(&h->scan_list);
-			h->busy_scanning = 1;
-			mutex_unlock(&scan_mutex);
-
-			rebuild_lun_table(h, 0, 0);
-			complete_all(&h->scan_wait);
-			mutex_lock(&scan_mutex);
-			h->busy_scanning = 0;
-			mutex_unlock(&scan_mutex);
-		}
-	}
-
-	return 0;
-}
-
 static int check_for_unit_attention(ctlr_info_t *h, CommandList_struct *c)
 {
 	if (c->err_info->SenseInfo[2] != UNIT_ATTENTION)
@@ -4094,9 +3981,10 @@ static int __devinit cciss_lookup_board_
 	*board_id = ((subsystem_device_id << 16) & 0xffff0000) |
 			subsystem_vendor_id;
 
-	for (i = 0; i < ARRAY_SIZE(products); i++)
+	for (i = 0; i < ARRAY_SIZE(products); i++) {
 		if (*board_id == products[i].board_id)
 			return i;
+	}
 	dev_warn(&pdev->dev, "unrecognized board ID: 0x%08x, ignoring.\n",
 		*board_id);
 	return -ENODEV;
@@ -4184,7 +4072,7 @@ static int __devinit cciss_find_cfgtable
 	if (rc)
 		return rc;
 	h->cfgtable = remap_pci_mem(pci_resource_start(h->pdev,
-		cfg_base_addr_index) + cfg_offset, sizeof(h->cfgtable));
+		cfg_base_addr_index) + cfg_offset, sizeof(*h->cfgtable));
 	if (!h->cfgtable)
 		return -ENOMEM;
 	rc = write_driver_ver_to_cfgtable(h->cfgtable);
@@ -4696,6 +4584,7 @@ static __devinit int cciss_kdump_hard_re
 	rc = cciss_controller_hard_reset(pdev, vaddr, use_doorbell);
 	if (rc)
 		goto unmap_cfgtable;
+
 	pci_restore_state(pdev);
 	rc = pci_enable_device(pdev);
 	if (rc) {
@@ -4903,10 +4792,6 @@ static void cciss_undo_allocations_after
 	cciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);
 	cciss_free_scatterlists(h);
 	cciss_free_cmd_pool(h);
-	kfree(h->blockFetchTable);
-	if (h->reply_pool)
-		pci_free_consistent(h->pdev, h->max_commands * sizeof(__u64),
-				h->reply_pool, h->reply_pool_dhandle);
 	if (h->transtable)
 		iounmap(h->transtable);
 	if (h->cfgtable)
@@ -4963,9 +4848,6 @@ reinit_after_soft_reset:
 	INIT_LIST_HEAD(&h->reqQ);
 	mutex_init(&h->busy_shutting_down);
 
-	if (cciss_pci_init(h) != 0)
-		goto clean_no_release_regions;
-
 	sprintf(h->devname, "cciss%d", i);
 	h->ctlr = i;
 
@@ -4974,7 +4856,8 @@ reinit_after_soft_reset:
 	if (cciss_tape_cmds > 16)
 		cciss_tape_cmds = 16;
 
-	init_completion(&h->scan_wait);
+	if (cciss_pci_init(h) != 0)
+		goto clean_no_release_regions;
 
 	if (cciss_create_hba_sysfs_entry(h))
 		goto clean0;
@@ -5199,8 +5082,6 @@ static void __devexit cciss_remove_one(s
 	}
 
 	mutex_lock(&h->busy_shutting_down);
-
-	remove_from_scan_list(h);
 	remove_proc_entry(h->devname, proc_cciss);
 	unregister_blkdev(h->major, h->devname);
 
@@ -5285,25 +5166,14 @@ static int __init cciss_init(void)
 	if (err)
 		return err;
 
-	/* Start the scan thread */
-	cciss_scan_thread = kthread_run(scan_thread, NULL, "cciss_scan");
-	if (IS_ERR(cciss_scan_thread)) {
-		err = PTR_ERR(cciss_scan_thread);
-		goto err_bus_unregister;
-	}
-
 	/* Register for our PCI devices */
 	err = pci_register_driver(&cciss_pci_driver);
 	if (err)
-		goto err_thread_stop;
-
+		goto err_bus_unregister;
 	return err;
 
-err_thread_stop:
-	kthread_stop(cciss_scan_thread);
 err_bus_unregister:
 	bus_unregister(&cciss_bus_type);
-
 	return err;
 }
 
@@ -5320,11 +5190,51 @@ static void __exit cciss_cleanup(void)
 			cciss_remove_one(hba[i]->pdev);
 		}
 	}
-	kthread_stop(cciss_scan_thread);
 	if (proc_cciss)
 		remove_proc_entry("driver/cciss", NULL);
 	bus_unregister(&cciss_bus_type);
 }
 
+static void cciss_sysfs_stat_inquiry(ctlr_info_t *h, int logvol,
+			drive_info_struct *drv)
+{
+	int return_code;
+	InquiryData_struct *inq_buff;
+	unsigned char scsi3addr[8];
+
+	/* If there are no heads then this is the controller disk and
+	 * not a valid logical drive so don't query it.
+	 */
+	if (!drv->heads)
+		return;
+
+	inq_buff = kzalloc(sizeof(InquiryData_struct), GFP_KERNEL);
+	if (!inq_buff) {
+		dev_err(&h->pdev->dev, "out of memory\n");
+		goto err;
+	}
+	log_unit_to_scsi3addr(h, scsi3addr, logvol);
+	return_code = sendcmd_withirq(h, CISS_INQUIRY, inq_buff, sizeof(*inq_buff), 0,
+			scsi3addr, TYPE_CMD);
+	if (return_code == IO_OK) {
+		memcpy(drv->vendor, &inq_buff->data_byte[8], 8);
+		drv->vendor[8]='\0';
+		memcpy(drv->model, &inq_buff->data_byte[16], 16);
+		drv->model[16] = '\0';
+		memcpy(drv->rev, &inq_buff->data_byte[32], 4);
+		drv->rev[4] = '\0';
+	} else { /* Get geometry failed */
+		dev_warn(&h->pdev->dev, "inquiry for VPD page 0 failed\n");
+	}
+	kfree(inq_buff);
+	cciss_get_uid(h, logvol, drv->uid, sizeof(drv->uid));
+
+err:
+	drv->vendor[8] = '\0';
+	drv->model[16] = '\0';
+	drv->rev[4] = '\0';
+
+}
+
 module_init(cciss_init);
 module_exit(cciss_cleanup);
--- a/drivers/block/cciss.h
+++ b/drivers/block/cciss.h
@@ -31,13 +31,14 @@ struct access_method {
 typedef struct _drive_info_struct
 {
 	unsigned char LunID[8];
-	int 	usage_count;
+#define CCISS_HBA_LUNID "\0\0\0\0\0\0\0\0"
+	int	usage_count;
 	struct request_queue *queue;
 	sector_t nr_blocks;
 	int	block_size;
-	int 	heads;
+	int	heads;
 	int	sectors;
-	int 	cylinders;
+	int	cylinders;
 	int	raid_level; /* set to -1 to indicate that
 			     * the drive is not in use/configured
 			     */
@@ -45,8 +46,8 @@ typedef struct _drive_info_struct
 				   * to prevent it from being opened or it's
 				   * queue from being started.
 				   */
-	struct	device dev;
-	__u8 serial_no[16]; /* from inquiry page 0x83,
+	struct device dev;
+	__u8 uid[16];	    /* from inquiry page 0x83,
 			     * not necc. null terminated.
 			     */
 	char vendor[VENDOR_LEN + 1]; /* SCSI vendor string */
@@ -55,6 +56,11 @@ typedef struct _drive_info_struct
 	char device_initialized;     /* indicates whether dev is initialized */
 } drive_info_struct;
 
+struct Cmd_sg_list {
+	dma_addr_t		sg_chain_dma;
+	int			chain_block_size;
+};
+
 struct ctlr_info
 {
 	int	ctlr;
@@ -65,15 +71,15 @@ struct ctlr_info
 	__u32	board_id;
 	void __iomem *vaddr;
 	unsigned long paddr;
-	int 	nr_cmds; /* Number of commands allowed on this controller */
+	int	nr_cmds; /* Number of commands allowed on this controller */
 	CfgTable_struct __iomem *cfgtable;
 	int	interrupts_enabled;
 	int	major;
-	int 	max_commands;
+	int	max_commands;
 	int	commands_outstanding;
-	int 	max_outstanding; /* Debug */ 
+	int	max_outstanding; /* Debug */
 	int	num_luns;
-	int 	highest_lun;
+	int	highest_lun;
 	int	usage_count;  /* number of opens all all minor devices */
 	/* Need space for temp sg list
 	 * number of scatter/gathers supported
@@ -92,7 +98,7 @@ struct ctlr_info
 	unsigned int intr[4];
 	unsigned int msix_vector;
 	unsigned int msi_vector;
-	int 	cciss_max_sectors;
+	int	cciss_max_sectors;
 	BYTE	cciss_read;
 	BYTE	cciss_write;
 	BYTE	cciss_read_capacity;
@@ -102,7 +108,7 @@ struct ctlr_info
 
 	struct access_method access;
 
-	/* queue and queue Info */ 
+	/* queue and queue Info */
 	struct list_head reqQ;
 	struct list_head cmpQ;
 	unsigned int Qdepth;
@@ -111,16 +117,15 @@ struct ctlr_info
 	spinlock_t lock;
 
 	/* pointers to command and error info pool */
-	CommandList_struct 	*cmd_pool;
-	dma_addr_t		cmd_pool_dhandle; 
-	ErrorInfo_struct 	*errinfo_pool;
-	dma_addr_t		errinfo_pool_dhandle; 
-        unsigned long  		*cmd_pool_bits;
+	CommandList_struct	*cmd_pool;
+	dma_addr_t		cmd_pool_dhandle;
+	ErrorInfo_struct	*errinfo_pool;
+	dma_addr_t		errinfo_pool_dhandle;
+	unsigned long		*cmd_pool_bits;
 	int			nr_allocs;
-	int			nr_frees; 
+	int			nr_frees;
 	int			busy_configuring;
 	int			busy_initializing;
-	int			busy_scanning;
 	struct mutex		busy_shutting_down;
 
 	/* This element holds the zero based queue number of the last
@@ -134,8 +139,6 @@ struct ctlr_info
 	struct cciss_scsi_adapter_data_t *scsi_ctlr;
 #endif
 	unsigned char alive;
-	struct list_head scan_list;
-	struct completion scan_wait;
 	struct device dev;
 	/*
 	 * Performant mode tables.
@@ -174,21 +177,21 @@ struct ctlr_info
 #define SA5B_INTR_OFF		0x04
 #define SA5_INTR_PENDING	0x08
 #define SA5B_INTR_PENDING	0x04
-#define FIFO_EMPTY		0xffffffff	
+#define FIFO_EMPTY		0xffffffff
 #define CCISS_FIRMWARE_READY	0xffff0000 /* value in scratchpad register */
 /* Perf. mode flags */
 #define SA5_PERF_INTR_PENDING	0x04
 #define SA5_PERF_INTR_OFF	0x05
 #define SA5_OUTDB_STATUS_PERF_BIT	0x01
 #define SA5_OUTDB_CLEAR_PERF_BIT	0x01
-#define SA5_OUTDB_CLEAR         0xA0
-#define SA5_OUTDB_CLEAR_PERF_BIT        0x01
-#define SA5_OUTDB_STATUS        0x9C
+#define SA5_OUTDB_CLEAR			0xA0
+#define SA5_OUTDB_CLEAR_PERF_BIT	0x01
+#define SA5_OUTDB_STATUS		0x9C
 
 
 #define  CISS_ERROR_BIT		0x02
 
-#define CCISS_INTR_ON 	1 
+#define CCISS_INTR_ON	1
 #define CCISS_INTR_OFF	0
 
 
@@ -209,34 +212,34 @@ struct ctlr_info
 	((CCISS_BOARD_NOT_READY_WAIT_SECS * 1000) / \
 		CCISS_BOARD_READY_POLL_INTERVAL_MSECS)
 #define CCISS_POST_RESET_PAUSE_MSECS (3000)
-#define CCISS_POST_RESET_NOOP_INTERVAL_MSECS (4000)
+#define CCISS_POST_RESET_NOOP_INTERVAL_MSECS (1000)
 #define CCISS_POST_RESET_NOOP_RETRIES (12)
 #define CCISS_POST_RESET_NOOP_TIMEOUT_MSECS (10000)
 
-/* 
-	Send the command to the hardware 
+/*
+	Send the command to the hardware
 */
-static void SA5_submit_command( ctlr_info_t *h, CommandList_struct *c) 
+static void SA5_submit_command( ctlr_info_t *h, CommandList_struct *c)
 {
 #ifdef CCISS_DEBUG
 	printk(KERN_WARNING "cciss%d: Sending %08x - down to controller\n",
 			h->ctlr, c->busaddr);
 #endif /* CCISS_DEBUG */
-         writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
-	readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
-	 h->commands_outstanding++;
-	 if ( h->commands_outstanding > h->max_outstanding)
+	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
+	(void) readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
+	h->commands_outstanding++;
+	if ( h->commands_outstanding > h->max_outstanding)
 		h->max_outstanding = h->commands_outstanding;
 }
 
-/*  
- *  This card is the opposite of the other cards.  
- *   0 turns interrupts on... 
- *   0x08 turns them off... 
+/*
+ *  This card is the opposite of the other cards.
+ *   0 turns interrupts on...
+ *   0x08 turns them off...
  */
 static void SA5_intr_mask(ctlr_info_t *h, unsigned long val)
 {
-	if (val) 
+	if (val)
 	{ /* Turn interrupts on */
 		h->interrupts_enabled = 1;
 		writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
@@ -244,7 +247,7 @@ static void SA5_intr_mask(ctlr_info_t *h
 	} else /* Turn them off */
 	{
 		h->interrupts_enabled = 0;
-        	writel( SA5_INTR_OFF, 
+		writel( SA5_INTR_OFF,
 			h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 	}
@@ -256,18 +259,16 @@ static void SA5_intr_mask(ctlr_info_t *h
  */
 static void SA5B_intr_mask(ctlr_info_t *h, unsigned long val)
 {
-        if (val)
-        { /* Turn interrupts on */
+	if (val) { /* Turn interrupts on */
 		h->interrupts_enabled = 1;
-                writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+		writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
-        } else /* Turn them off */
-        {
+	} else { /* Turn them off */
 		h->interrupts_enabled = 0;
-                writel( SA5B_INTR_OFF,
-                        h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+		writel( SA5B_INTR_OFF,
+			h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
-        }
+	}
 }
 
 /* Performant mode intr_mask */
@@ -286,39 +287,39 @@ static void SA5_performant_intr_mask(ctl
 }
 
 /*
- *  Returns true if fifo is full.  
- * 
- */ 
+ *  Returns true if fifo is full.
+ *
+ */
 static unsigned long SA5_fifo_full(ctlr_info_t *h)
 {
 	if( h->commands_outstanding >= h->max_commands)
 		return(1);
-	else 
+	else
 		return(0);
 
 }
-/* 
- *   returns value read from hardware. 
- *     returns FIFO_EMPTY if there is nothing to read 
- */ 
+/*
+ *   returns value read from hardware.
+ *     returns FIFO_EMPTY if there is nothing to read
+ */
 static unsigned long SA5_completed(ctlr_info_t *h)
 {
-	unsigned long register_value 
+	unsigned long register_value
 		= readl(h->vaddr + SA5_REPLY_PORT_OFFSET);
 	if(register_value != FIFO_EMPTY)
 	{
 		h->commands_outstanding--;
 #ifdef CCISS_DEBUG
 		printk("cciss:  Read %lx back from board\n", register_value);
-#endif /* CCISS_DEBUG */ 
-	} 
+#endif /* CCISS_DEBUG */
+	}
 #ifdef CCISS_DEBUG
 	else
 	{
 		printk("cciss:  FIFO Empty read\n");
 	}
-#endif 
-	return ( register_value); 
+#endif
+	return ( register_value);
 
 }
 
@@ -356,17 +357,17 @@ static unsigned long SA5_performant_comp
 	return register_value;
 }
 /*
- *	Returns true if an interrupt is pending.. 
+ *	Returns true if an interrupt is pending..
  */
 static bool SA5_intr_pending(ctlr_info_t *h)
 {
-	unsigned long register_value  = 
+	unsigned long register_value  =
 		readl(h->vaddr + SA5_INTR_STATUS);
 #ifdef CCISS_DEBUG
 	printk("cciss: intr_pending %lx\n", register_value);
 #endif  /* CCISS_DEBUG */
-	if( register_value &  SA5_INTR_PENDING) 
-		return  1;	
+	if( register_value &  SA5_INTR_PENDING)
+		return  1;
 	return 0 ;
 }
 
@@ -375,14 +376,14 @@ static bool SA5_intr_pending(ctlr_info_t
  */
 static bool SA5B_intr_pending(ctlr_info_t *h)
 {
-        unsigned long register_value  =
-                readl(h->vaddr + SA5_INTR_STATUS);
+	unsigned long register_value  =
+		readl(h->vaddr + SA5_INTR_STATUS);
 #ifdef CCISS_DEBUG
-        printk("cciss: intr_pending %lx\n", register_value);
+	printk("cciss: intr_pending %lx\n", register_value);
 #endif  /* CCISS_DEBUG */
-        if( register_value &  SA5B_INTR_PENDING)
-                return  1;
-        return 0 ;
+	if( register_value &  SA5B_INTR_PENDING)
+		return  1;
+	return 0 ;
 }
 
 static bool SA5_performant_intr_pending(ctlr_info_t *h)
@@ -409,11 +410,11 @@ static struct access_method SA5_access =
 };
 
 static struct access_method SA5B_access = {
-        SA5_submit_command,
-        SA5B_intr_mask,
-        SA5_fifo_full,
-        SA5B_intr_pending,
-        SA5_completed,
+	SA5_submit_command,
+	SA5B_intr_mask,
+	SA5_fifo_full,
+	SA5B_intr_pending,
+	SA5_completed,
 };
 
 static struct access_method SA5_performant_access = {
--- a/drivers/block/cciss_cmd.h
+++ b/drivers/block/cciss_cmd.h
@@ -76,7 +76,7 @@ typedef union _u64bit
 } u64bit;
 
 /* Type defs used in the following structs */
-#define QWORD vals32 
+#define QWORD vals32
 
 /* STRUCTURES */
 #define CISS_MAX_PHYS_LUN	1024
@@ -101,7 +101,7 @@ typedef struct _ReportLUNdata_struct
   BYTE LUN[CISS_MAX_LUN][8];
 } ReportLunData_struct;
 
-#define CCISS_READ_CAPACITY 0x25 /* Read Capacity */ 
+#define CCISS_READ_CAPACITY 0x25 /* Read Capacity */
 typedef struct _ReadCapdata_struct
 {
   BYTE total_size[4];	/* Total size in blocks */
@@ -199,11 +199,11 @@ typedef struct _CommandList_struct {
   RequestBlock_struct      Request;
   ErrDescriptor_struct     ErrDesc;
   SGDescriptor_struct      SG[MAXSGENTRIES];
-	/* information associated with the command */ 
+	/* information associated with the command */
   __u32			   busaddr; /* physical address of this record */
-  ErrorInfo_struct * 	   err_info; /* pointer to the allocated mem */ 
+  ErrorInfo_struct *	   err_info; /* pointer to the allocated mem */
   int			   ctlr;
-  int			   cmd_type; 
+  int			   cmd_type;
   long			   cmdindex;
   struct list_head list;
   struct request *	   rq;
@@ -245,7 +245,7 @@ typedef struct _CfgTable_struct {
   u32		   misc_fw_support; /* offset 0x78 */
 #define MISC_FW_DOORBELL_RESET (0x02)
 #define MISC_FW_DOORBELL_RESET2 (0x10)
-	u8	   driver_version[32];
+  u8		   driver_version[32];
 } CfgTable_struct;
 
 struct TransTable_struct {
@@ -265,5 +265,5 @@ struct TransTable_struct {
   u32 RepQAddr0High32;
 };
 
-#pragma pack()	 
+#pragma pack()
 #endif /* CCISS_CMD_H */
--- a/drivers/block/cciss_scsi.c
+++ b/drivers/block/cciss_scsi.c
@@ -1,6 +1,6 @@
 /*
  *    Disk Array driver for HP Smart Array controllers, SCSI Tape module.
- *    (C) Copyright 2001, 2007 Hewlett-Packard Development Company, L.P.
+ *    (C) Copyright 2001, 2010 Hewlett-Packard Development Company, L.P.
  *
  *    This program is free software; you can redistribute it and/or modify
  *    it under the terms of the GNU General Public License as published by
@@ -17,15 +17,15 @@
  *    02111-1307, USA.
  *
  *    Questions/Comments/Bugfixes to iss_storagedev@hp.com
- *    
+ *
  *    Author: Stephen M. Cameron
  */
 #ifdef CONFIG_CISS_SCSI_TAPE
 
-/* Here we have code to present the driver as a scsi driver 
-   as it is simultaneously presented as a block driver.  The 
+/* Here we have code to present the driver as a scsi driver
+   as it is simultaneously presented as a block driver.  The
    reason for doing this is to allow access to SCSI tape drives
-   through the array controller.  Note in particular, neither 
+   through the array controller.  Note in particular, neither
    physical nor logical disks are presented through the scsi layer. */
 
 #include <linux/timer.h>
@@ -37,7 +37,7 @@
 
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
-#include <scsi/scsi_host.h> 
+#include <scsi/scsi_host.h>
 
 #include "cciss_scsi.h"
 
@@ -102,12 +102,9 @@ struct cciss_scsi_cmd_stack_elem_t {
 	ErrorInfo_struct Err;
 	__u32 busaddr;
 	int cmdindex;
-	u8 pad[IS_32_BIT * SCSI_PAD_32 + IS_64_BIT * SCSI_PAD_64];
+	unsigned char pad[IS_32_BIT * SCSI_PAD_32 + IS_64_BIT * SCSI_PAD_64];
 };
 
-#pragma pack()
-
-#pragma pack(1)
 struct cciss_scsi_cmd_stack_t {
 	struct cciss_scsi_cmd_stack_elem_t *pool;
 	struct cciss_scsi_cmd_stack_elem_t **elem;
@@ -122,7 +119,7 @@ struct cciss_scsi_adapter_data_t {
 	struct cciss_scsi_cmd_stack_t cmd_stack;
 	SGDescriptor_struct **cmd_sg_list;
 	int registered;
-	spinlock_t lock; // to protect ccissscsi[ctlr]; 
+	spinlock_t lock; // to protect ccissscsi[ctlr];
 };
 
 #define CPQ_TAPE_LOCK(h, flags) spin_lock_irqsave( \
@@ -145,36 +142,36 @@ scsi_cmd_alloc(ctlr_info_t *h)
 	u64bit temp64;
 
 	sa = h->scsi_ctlr;
-	stk = &sa->cmd_stack; 
+	stk = &sa->cmd_stack;
 
-	if (stk->top < 0) 
+	if (stk->top < 0)
 		return NULL;
-	c = stk->elem[stk->top]; 	
+	c = stk->elem[stk->top];
 	/* memset(c, 0, sizeof(*c)); */
 	memset(&c->cmd, 0, sizeof(c->cmd));
 	memset(&c->Err, 0, sizeof(c->Err));
 	/* set physical addr of cmd and addr of scsi parameters */
-	c->cmd.busaddr = c->busaddr; 
+	c->cmd.busaddr = c->busaddr;
 	c->cmd.cmdindex = c->cmdindex;
-	/* (__u32) (stk->cmd_pool_handle + 
+	/* (__u32) (stk->cmd_pool_handle +
 		(sizeof(struct cciss_scsi_cmd_stack_elem_t)*stk->top)); */
 
 	temp64.val = (__u64) (c->busaddr + sizeof(CommandList_struct));
-	/* (__u64) (stk->cmd_pool_handle + 
+	/* (__u64) (stk->cmd_pool_handle +
 		(sizeof(struct cciss_scsi_cmd_stack_elem_t)*stk->top) +
 		 sizeof(CommandList_struct)); */
 	stk->top--;
 	c->cmd.ErrDesc.Addr.lower = temp64.val32.lower;
 	c->cmd.ErrDesc.Addr.upper = temp64.val32.upper;
 	c->cmd.ErrDesc.Len = sizeof(ErrorInfo_struct);
-	
+
 	c->cmd.ctlr = h->ctlr;
 	c->cmd.err_info = &c->Err;
 
 	return (CommandList_struct *) c;
 }
 
-static void 
+static void
 scsi_cmd_free(ctlr_info_t *h, CommandList_struct *c)
 {
 	/* assume only one process in here at a time, locking done by caller. */
@@ -185,7 +182,7 @@ scsi_cmd_free(ctlr_info_t *h, CommandLis
 	struct cciss_scsi_cmd_stack_t *stk;
 
 	sa = h->scsi_ctlr;
-	stk = &sa->cmd_stack; 
+	stk = &sa->cmd_stack;
 	stk->top++;
 	if (stk->top >= stk->nelems) {
 		dev_err(&h->pdev->dev,
@@ -225,16 +222,16 @@ scsi_cmd_stack_setup(ctlr_info_t *h, str
 	stk->elem = kmalloc(sizeof(stk->elem[0]) * stk->nelems, GFP_KERNEL);
 	if (!stk->elem) {
 		pci_free_consistent(h->pdev, size, stk->pool,
-		stk->cmd_pool_handle);
+			stk->cmd_pool_handle);
 		return -1;
 	}
 	for (i = 0; i < stk->nelems; i++) {
 		stk->elem[i] = &stk->pool[i];
-		stk->elem[i]->busaddr = (__u32) (stk->cmd_pool_handle + 
+		stk->elem[i]->busaddr = (__u32) (stk->cmd_pool_handle +
 			(sizeof(struct cciss_scsi_cmd_stack_elem_t) * i));
 		stk->elem[i]->cmdindex = i;
 	}
-	stk->top = stk->nelems-1;
+	stk->top = stk->nelems - 1;
 	return 0;
 }
 
@@ -246,8 +243,8 @@ scsi_cmd_stack_free(ctlr_info_t *h)
 	size_t size;
 
 	sa = h->scsi_ctlr;
-	stk = &sa->cmd_stack; 
-	if (stk->top != stk->nelems-1) {
+	stk = &sa->cmd_stack;
+	if (stk->top != stk->nelems - 1) {
 		dev_warn(&h->pdev->dev,
 			"bug: %d scsi commands are still outstanding.\n",
 			stk->nelems - stk->top);
@@ -305,7 +302,7 @@ print_cmd(CommandList_struct *cp)
 	printk("queue:%d\n", cp->Header.ReplyQueue);
 	printk("sglist:%d\n", cp->Header.SGList);
 	printk("sgtot:%d\n", cp->Header.SGTotal);
-	printk("Tag:0x%08x/0x%08x\n", cp->Header.Tag.upper, 
+	printk("Tag:0x%08x/0x%08x\n", cp->Header.Tag.upper,
 			cp->Header.Tag.lower);
 	printk("LUN:0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
 		cp->Header.LUN.LunAddrBytes[0],
@@ -331,8 +328,8 @@ print_cmd(CommandList_struct *cp)
 		cp->Request.CDB[10], cp->Request.CDB[11],
 		cp->Request.CDB[12], cp->Request.CDB[13],
 		cp->Request.CDB[14], cp->Request.CDB[15]),
-	printk("edesc.Addr: 0x%08x/0%08x, Len  = %d\n", 
-		cp->ErrDesc.Addr.upper, cp->ErrDesc.Addr.lower, 
+	printk("edesc.Addr: 0x%08x/0%08x, Len  = %d\n",
+		cp->ErrDesc.Addr.upper, cp->ErrDesc.Addr.lower,
 			cp->ErrDesc.Len);
 	printk("sgs..........Errorinfo:\n");
 	printk("scsistatus:%d\n", cp->err_info->ScsiStatus);
@@ -342,12 +339,11 @@ print_cmd(CommandList_struct *cp)
 	printk("offense size:%d\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_size);
 	printk("offense byte:%d\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_num);
 	printk("offense value:%d\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_value);
-			
 }
 
 #endif
 
-static int 
+static int
 find_bus_target_lun(ctlr_info_t *h, int *bus, int *target, int *lun)
 {
 	/* finds an unused bus, target, lun for a new device */
@@ -357,24 +353,24 @@ find_bus_target_lun(ctlr_info_t *h, int
 
 	memset(&target_taken[0], 0, CCISS_MAX_SCSI_DEVS_PER_HBA);
 
-	target_taken[SELF_SCSI_ID] = 1;	
+	target_taken[SELF_SCSI_ID] = 1;
 	for (i = 0; i < ccissscsi[h->ctlr].ndevices; i++)
 		target_taken[ccissscsi[h->ctlr].dev[i].target] = 1;
-	
+
 	for (i = 0; i < CCISS_MAX_SCSI_DEVS_PER_HBA; i++) {
 		if (!target_taken[i]) {
 			*bus = 0; *target=i; *lun = 0; found=1;
 			break;
 		}
 	}
-	return (!found);	
+	return (!found);
 }
 struct scsi2map {
 	char scsi3addr[8];
 	int bus, target, lun;
 };
 
-static int 
+static int
 cciss_scsi_add_entry(ctlr_info_t *h, int hostno,
 		struct cciss_scsi_dev_t *device,
 		struct scsi2map *added, int *nadded)
@@ -439,8 +435,8 @@ cciss_scsi_add_entry(ctlr_info_t *h, int
 
 	ccissscsi[h->ctlr].ndevices++;
 
-	/* initially, (before registering with scsi layer) we don't 
-	   know our hostno and we don't want to print anything first 
+	/* initially, (before registering with scsi layer) we don't
+	   know our hostno and we don't want to print anything first
 	   time anyway (the scsi layer's inquiries will show that info) */
 	if (hostno != -1)
 		dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d added.\n",
@@ -525,7 +521,7 @@ adjust_cciss_scsi_table(ctlr_info_t *h,
 	/* sd contains scsi3 addresses and devtypes, but
 	   bus target and lun are not filled in.  This funciton
 	   takes what's in sd to be the current and adjusts
-	   ccissscsi[] to be in line with what's in sd. */ 
+	   ccissscsi[] to be in line with what's in sd. */
 
 	int i,j, found, changes=0;
 	struct cciss_scsi_dev_t *csd;
@@ -550,7 +546,7 @@ adjust_cciss_scsi_table(ctlr_info_t *h,
 	if (hostno != -1)  /* if it's not the first time... */
 		sh = h->scsi_ctlr->scsi_host;
 
-	/* find any devices in ccissscsi[] that are not in 
+	/* find any devices in ccissscsi[] that are not in
 	   sd[] and remove them from ccissscsi[] */
 
 	i = 0;
@@ -570,7 +566,7 @@ adjust_cciss_scsi_table(ctlr_info_t *h,
 			}
 		}
 
-		if (found == 0) { /* device no longer present. */ 
+		if (found == 0) { /* device no longer present. */
 			changes++;
 			cciss_scsi_remove_entry(h, hostno, i,
 				removed, &nremoved);
@@ -596,12 +592,12 @@ adjust_cciss_scsi_table(ctlr_info_t *h,
 				sizeof(csd->model));
 			memcpy(csd->revision, sd[j].revision,
 				sizeof(csd->revision));
-		} else 		/* device is same as it ever was, */
+		} else		/* device is same as it ever was, */
 			i++;	/* so just move along. */
 	}
 
 	/* Now, make sure every device listed in sd[] is also
- 	   listed in ccissscsi[], adding them if they aren't found */
+	   listed in ccissscsi[], adding them if they aren't found */
 
 	for (i=0;i<nsds;i++) {
 		found=0;
@@ -612,7 +608,7 @@ adjust_cciss_scsi_table(ctlr_info_t *h,
 				if (device_is_the_same(&sd[i], csd))
 					found=2;	/* found device */
 				else
-					found=1; 	/* found a bug. */
+					found=1;	/* found a bug. */
 				break;
 			}
 		}
@@ -699,14 +695,14 @@ lookup_scsi3addr(ctlr_info_t *h, int bus
 	return -1;
 }
 
-static void 
+static void
 cciss_scsi_setup(ctlr_info_t *h)
 {
 	struct cciss_scsi_adapter_data_t * shba;
 
 	ccissscsi[h->ctlr].ndevices = 0;
 	shba = (struct cciss_scsi_adapter_data_t *)
-		kmalloc(sizeof(*shba), GFP_KERNEL);	
+		kmalloc(sizeof(*shba), GFP_KERNEL);
 	if (shba == NULL)
 		return;
 	shba->scsi_host = NULL;
@@ -742,7 +738,7 @@ static void complete_scsi_command(Comman
 	if (c->Header.SGTotal > h->max_cmd_sgentries)
 		cciss_unmap_sg_chain_block(h, c);
 
-	cmd->result = (DID_OK << 16); 		/* host byte */
+	cmd->result = (DID_OK << 16);		/* host byte */
 	cmd->result |= (COMMAND_COMPLETE << 8);	/* msg byte */
 	/* cmd->result |= (GOOD < 1); */		/* status byte */
 
@@ -751,20 +747,20 @@ static void complete_scsi_command(Comman
 
 	/* copy the sense data whether we need to or not. */
 
-	memcpy(cmd->sense_buffer, ei->SenseInfo, 
+	memcpy(cmd->sense_buffer, ei->SenseInfo,
 		ei->SenseLen > SCSI_SENSE_BUFFERSIZE ?
-			SCSI_SENSE_BUFFERSIZE : 
+			SCSI_SENSE_BUFFERSIZE :
 			ei->SenseLen);
 	scsi_set_resid(cmd, ei->ResidualCnt);
 
-	if(ei->CommandStatus != 0) 
-	{ /* an error has occurred */ 
+	if(ei->CommandStatus != 0)
+	{ /* an error has occurred */
 		switch(ei->CommandStatus)
 		{
 			case CMD_TARGET_STATUS:
 				/* Pass it up to the upper layers... */
 				if (!ei->ScsiStatus) {
-					
+
 	/* Ordinarily, this case should never happen, but there is a bug
 	   in some released firmware revisions that allows it to happen
 	   if, for example, a 4100 backplane loses power and the tape
@@ -787,7 +783,7 @@ static void complete_scsi_command(Comman
 				/* print_bytes(c, sizeof(*c), 1, 0);
 				print_cmd(c); */
      /* We get CMD_INVALID if you address a non-existent tape drive instead
-	of a selection timeout (no response).  You will see this if you yank 
+	of a selection timeout (no response).  You will see this if you yank
 	out a tape drive, then try to access it. This is kind of a shame
 	because it means that any other CMD_INVALID (e.g. driver bug) will
 	get interpreted as a missing target. */
@@ -797,12 +793,12 @@ static void complete_scsi_command(Comman
 			case CMD_PROTOCOL_ERR:
 				dev_warn(&h->pdev->dev,
 					"%p has protocol error\n", c);
-                        break;
+			break;
 			case CMD_HARDWARE_ERR:
 				cmd->result = DID_ERROR << 16;
 				dev_warn(&h->pdev->dev,
 					"%p had hardware error\n", c);
-                        break;
+			break;
 			case CMD_CONNECTION_LOST:
 				cmd->result = DID_ERROR << 16;
 				dev_warn(&h->pdev->dev,
@@ -835,7 +831,7 @@ static void complete_scsi_command(Comman
 				cmd->result = DID_ERROR << 16;
 				dev_warn(&h->pdev->dev,
 					"%p returned unknown status %x\n", c,
-						ei->CommandStatus); 
+						ei->CommandStatus);
 		}
 	}
 	cmd->scsi_done(cmd);
@@ -851,15 +847,15 @@ cciss_scsi_detect(ctlr_info_t *h)
 	sh = scsi_host_alloc(&cciss_driver_template, sizeof(struct ctlr_info *));
 	if (sh == NULL)
 		goto fail;
-	sh->io_port = 0;	// good enough?  FIXME, 
+	sh->io_port = 0;	// good enough?  FIXME,
 	sh->n_io_port = 0;	// I don't think we use these two...
-	sh->this_id = SELF_SCSI_ID;  
-	sh->can_queue = cciss_tape_cmds;
+	sh->this_id = SELF_SCSI_ID;
 	sh->sg_tablesize = h->maxsgentries;
+	sh->can_queue = cciss_tape_cmds;
 	sh->max_cmd_len = MAX_COMMAND_SIZE;
 	sh->max_sectors = h->cciss_max_sectors;
 
-	((struct cciss_scsi_adapter_data_t *) 
+	((struct cciss_scsi_adapter_data_t *)
 		h->scsi_ctlr)->scsi_host = sh;
 	sh->hostdata[0] = (unsigned long) h;
 	sh->irq = h->intr[SIMPLE_MODE_INT];
@@ -911,7 +907,7 @@ cciss_map_one(struct pci_dev *pdev,
 static int
 cciss_scsi_do_simple_cmd(ctlr_info_t *h,
 			CommandList_struct *c,
-			unsigned char *scsi3addr, 
+			unsigned char *scsi3addr,
 			unsigned char *cdb,
 			unsigned char cdblen,
 			unsigned char *buf, int bufsize,
@@ -926,7 +922,7 @@ cciss_scsi_do_simple_cmd(ctlr_info_t *h,
 	c->Header.Tag.lower = c->busaddr;  /* Use k. address of cmd as tag */
 	// Fill in the request block...
 
-	/* printk("Using scsi3addr 0x%02x%0x2%0x2%0x2%0x2%0x2%0x2%0x2\n", 
+	/* printk("Using scsi3addr 0x%02x%0x2%0x2%0x2%0x2%0x2%0x2%0x2\n",
 		scsi3addr[0], scsi3addr[1], scsi3addr[2], scsi3addr[3],
 		scsi3addr[4], scsi3addr[5], scsi3addr[6], scsi3addr[7]); */
 
@@ -940,7 +936,7 @@ cciss_scsi_do_simple_cmd(ctlr_info_t *h,
 
 	/* Fill in the SG list and do dma mapping */
 	cciss_map_one(h->pdev, c, (unsigned char *) buf,
-			bufsize, DMA_FROM_DEVICE); 
+			bufsize, DMA_FROM_DEVICE);
 
 	c->waiting = &wait;
 	enqueue_cmd_and_start_io(h, c);
@@ -951,7 +947,7 @@ cciss_scsi_do_simple_cmd(ctlr_info_t *h,
 	return(0);
 }
 
-static void 
+static void
 cciss_scsi_interpret_error(ctlr_info_t *h, CommandList_struct *c)
 {
 	ErrorInfo_struct *ei;
@@ -1041,7 +1037,7 @@ cciss_scsi_do_inquiry(ctlr_info_t *h, un
 	spin_unlock_irqrestore(&h->lock, flags);
 
 	if (c == NULL) {			/* trouble... */
-		printk("cmd_alloc returned NULL!\n");
+		dev_warn(&h->pdev->dev, "scsi_cmd_alloc returned NULL!\n");
 		return -1;
 	}
 
@@ -1058,7 +1054,7 @@ cciss_scsi_do_inquiry(ctlr_info_t *h, un
 
 	if (rc != 0) return rc; /* something went wrong */
 
-	if (ei->CommandStatus != 0 && 
+	if (ei->CommandStatus != 0 &&
 	    ei->CommandStatus != CMD_DATA_UNDERRUN) {
 		cciss_scsi_interpret_error(h, c);
 		rc = -1;
@@ -1066,7 +1062,7 @@ cciss_scsi_do_inquiry(ctlr_info_t *h, un
 	spin_lock_irqsave(&h->lock, flags);
 	scsi_cmd_free(h, c);
 	spin_unlock_irqrestore(&h->lock, flags);
-	return rc;	
+	return rc;
 }
 
 /* Get the device id from inquiry page 0x83 */
@@ -1095,7 +1091,7 @@ cciss_scsi_do_report_phys_luns(ctlr_info
 	int rc;
 	CommandList_struct *c;
 	unsigned char cdb[12];
-	unsigned char scsi3addr[8]; 
+	unsigned char scsi3addr[8];
 	ErrorInfo_struct *ei;
 	unsigned long flags;
 
@@ -1103,7 +1099,7 @@ cciss_scsi_do_report_phys_luns(ctlr_info
 	c = scsi_cmd_alloc(h);
 	spin_unlock_irqrestore(&h->lock, flags);
 	if (c == NULL) {			/* trouble... */
-		printk("cmd_alloc returned NULL!\n");
+		dev_warn(&h->pdev->dev, "scsi_cmd_alloc returned NULL!\n");
 		return -1;
 	}
 
@@ -1122,14 +1118,14 @@ cciss_scsi_do_report_phys_luns(ctlr_info
 	cdb[11] = 0;
 
 	rc = cciss_scsi_do_simple_cmd(h, c, scsi3addr,
-				cdb, 12, 
-				(unsigned char *) buf, 
+				cdb, 12,
+				(unsigned char *) buf,
 				bufsize, XFER_READ);
 
 	if (rc != 0) return rc; /* something went wrong */
 
 	ei = c->err_info;
-	if (ei->CommandStatus != 0 && 
+	if (ei->CommandStatus != 0 &&
 	    ei->CommandStatus != CMD_DATA_UNDERRUN) {
 		cciss_scsi_interpret_error(h, c);
 		rc = -1;
@@ -1137,36 +1133,36 @@ cciss_scsi_do_report_phys_luns(ctlr_info
 	spin_lock_irqsave(&h->lock, flags);
 	scsi_cmd_free(h, c);
 	spin_unlock_irqrestore(&h->lock, flags);
-	return rc;	
+	return rc;
 }
 
 static void
 cciss_update_non_disk_devices(ctlr_info_t *h, int hostno)
 {
 	/* the idea here is we could get notified from /proc
-	   that some devices have changed, so we do a report 
-	   physical luns cmd, and adjust our list of devices 
+	   that some devices have changed, so we do a report
+	   physical luns cmd, and adjust our list of devices
 	   accordingly.  (We can't rely on the scsi-mid layer just
-	   doing inquiries, because the "busses" that the scsi 
+	   doing inquiries, because the "busses" that the scsi
 	   mid-layer probes are totally fabricated by this driver,
 	   so new devices wouldn't show up.
 
-	   the scsi3addr's of devices won't change so long as the 
-	   adapter is not reset.  That means we can rescan and 
-	   tell which devices we already know about, vs. new 
+	   the scsi3addr's of devices won't change so long as the
+	   adapter is not reset.  That means we can rescan and
+	   tell which devices we already know about, vs. new
 	   devices, vs.  disappearing devices.
 
 	   Also, if you yank out a tape drive, then put in a disk
-	   in it's place, (say, a configured volume from another 
-	   array controller for instance)  _don't_ poke this driver 
-           (so it thinks it's still a tape, but _do_ poke the scsi 
-           mid layer, so it does an inquiry... the scsi mid layer 
+	   in it's place, (say, a configured volume from another
+	   array controller for instance)  _don't_ poke this driver
+           (so it thinks it's still a tape, but _do_ poke the scsi
+           mid layer, so it does an inquiry... the scsi mid layer
            will see the physical disk.  This would be bad.  Need to
-	   think about how to prevent that.  One idea would be to 
+	   think about how to prevent that.  One idea would be to
 	   snoop all scsi responses and if an inquiry repsonse comes
 	   back that reports a disk, chuck it an return selection
 	   timeout instead and adjust our table...  Not sure i like
-	   that though.  
+	   that though.
 
 	 */
 #define OBDR_TAPE_INQ_SIZE 49
@@ -1186,7 +1182,7 @@ cciss_update_non_disk_devices(ctlr_info_
 	currentsd = kzalloc(sizeof(*currentsd) *
 			(CCISS_MAX_SCSI_DEVS_PER_HBA+1), GFP_KERNEL);
 	if (ld_buff == NULL || inq_buff == NULL || currentsd == NULL) {
-		printk(KERN_ERR "cciss: out of memory\n");
+		dev_err(&h->pdev->dev, "out of memory\n");
 		goto out;
 	}
 	this_device = &currentsd[CCISS_MAX_SCSI_DEVS_PER_HBA];
@@ -1194,20 +1190,20 @@ cciss_update_non_disk_devices(ctlr_info_
 		ch = &ld_buff->LUNListLength[0];
 		num_luns = ((ch[0]<<24) | (ch[1]<<16) | (ch[2]<<8) | ch[3]) / 8;
 		if (num_luns > CISS_MAX_PHYS_LUN) {
-			printk(KERN_WARNING 
-				"cciss: Maximum physical LUNs (%d) exceeded.  "
-				"%d LUNs ignored.\n", CISS_MAX_PHYS_LUN, 
+			dev_warn(&h->pdev->dev,
+				"Maximum physical LUNs (%d) exceeded.  "
+				"%d LUNs ignored.\n", CISS_MAX_PHYS_LUN,
 				num_luns - CISS_MAX_PHYS_LUN);
 			num_luns = CISS_MAX_PHYS_LUN;
 		}
 	}
 	else {
-		printk(KERN_ERR  "cciss: Report physical LUNs failed.\n");
+		dev_err(&h->pdev->dev, "Report physical LUNs failed.\n");
 		goto out;
 	}
 
 
-	/* adjust our table of devices */	
+	/* adjust our table of devices */
 	for (i = 0; i < num_luns; i++) {
 		/* for each physical lun, do an inquiry */
 		if (ld_buff->LUN[i][3] & 0xC0) continue;
@@ -1258,15 +1254,15 @@ cciss_update_non_disk_devices(ctlr_info_
 		  case 0x01: /* sequential access, (tape) */
 		  case 0x08: /* medium changer */
 			if (ncurrent >= CCISS_MAX_SCSI_DEVS_PER_HBA) {
-				printk(KERN_INFO "cciss%d: %s ignored, "
-					"too many devices.\n", h->ctlr,
+				dev_info(&h->pdev->dev, "%s ignored, "
+					"too many devices.\n",
 					scsi_device_type(this_device->devtype));
 				break;
 			}
 			currentsd[ncurrent] = *this_device;
 			ncurrent++;
 			break;
-		  default: 
+		  default:
 			break;
 		}
 	}
@@ -1305,9 +1301,9 @@ cciss_scsi_user_command(ctlr_info_t *h,
 static int
 cciss_scsi_proc_info(struct Scsi_Host *sh,
 		char *buffer, /* data buffer */
-		char **start, 	   /* where data in buffer starts */
+		char **start,	   /* where data in buffer starts */
 		off_t offset,	   /* offset from start of imaginary file */
-		int length, 	   /* length of data in buffer */
+		int length,	   /* length of data in buffer */
 		int func)	   /* 0 == read, 1 == write */
 {
 
@@ -1344,19 +1340,19 @@ cciss_scsi_proc_info(struct Scsi_Host *s
 				sd->scsi3addr[6], sd->scsi3addr[7]);
 		}
 		datalen = buflen - offset;
-		if (datalen < 0) { 	/* they're reading past EOF. */
+		if (datalen < 0) {	/* they're reading past EOF. */
 			datalen = 0;
-			*start = buffer+buflen;	
+			*start = buffer+buflen;
 		} else
 			*start = buffer + offset;
 		return(datalen);
-	} else 	/* User is writing to /proc/scsi/cciss*?/?*  ... */
+	} else	/* User is writing to /proc/scsi/cciss*?/?*  ... */
 		return cciss_scsi_user_command(h, sh->host_no,
-			buffer, length);	
-} 
+			buffer, length);
+}
 
-/* cciss_scatter_gather takes a struct scsi_cmnd, (cmd), and does the pci 
-   dma mapping  and fills in the scatter gather entries of the 
+/* cciss_scatter_gather takes a struct scsi_cmnd, (cmd), and does the pci
+   dma mapping  and fills in the scatter gather entries of the
    cciss command, c. */
 
 static void cciss_scatter_gather(ctlr_info_t *h, CommandList_struct *c,
@@ -1452,7 +1448,7 @@ cciss_scsi_queue_command_lck(struct scsi
 
 	// Fill in the command list header
 
-	cmd->scsi_done = done;    // save this for use by completion code 
+	cmd->scsi_done = done;    // save this for use by completion code
 
 	/* save c in case we have to abort it */
 	cmd->host_scribble = (unsigned char *) c;
@@ -1462,7 +1458,7 @@ cciss_scsi_queue_command_lck(struct scsi
 	c->Header.ReplyQueue = 0;  /* unused in simple mode */
 	memcpy(&c->Header.LUN.LunAddrBytes[0], &scsi3addr[0], 8);
 	c->Header.Tag.lower = c->busaddr;  /* Use k. address of cmd as tag */
-	
+
 	// Fill in the request block...
 
 	c->Request.Timeout = 0;
@@ -1490,15 +1486,15 @@ cciss_scsi_queue_command_lck(struct scsi
 
 		c->Request.Type.Direction = XFER_RSVD;
 		// This is technically wrong, and cciss controllers should
-		// reject it with CMD_INVALID, which is the most correct 
-		// response, but non-fibre backends appear to let it 
+		// reject it with CMD_INVALID, which is the most correct
+		// response, but non-fibre backends appear to let it
 		// slide by, and give the same results as if this field
 		// were set correctly.  Either way is acceptable for
 		// our purposes here.
 
 		break;
 
-	  default: 
+	  default:
 		dev_warn(&h->pdev->dev, "unknown data direction: %d\n",
 			cmd->sc_data_direction);
 		BUG();
@@ -1522,9 +1518,9 @@ static void cciss_unregister_scsi(ctlr_i
 
 	spin_lock_irqsave(&h->lock, flags);
 	sa = h->scsi_ctlr;
-	stk = &sa->cmd_stack; 
+	stk = &sa->cmd_stack;
 
-	/* if we weren't ever actually registered, don't unregister */ 
+	/* if we weren't ever actually registered, don't unregister */
 	if (sa->registered) {
 		spin_unlock_irqrestore(&h->lock, flags);
 		scsi_remove_host(sa->scsi_host);
@@ -1532,7 +1528,7 @@ static void cciss_unregister_scsi(ctlr_i
 		spin_lock_irqsave(&h->lock, flags);
 	}
 
-	/* set scsi_host to NULL so our detect routine will 
+	/* set scsi_host to NULL so our detect routine will
 	   find us on register */
 	sa->scsi_host = NULL;
 	spin_unlock_irqrestore(&h->lock, flags);
@@ -1548,7 +1544,7 @@ static int cciss_engage_scsi(ctlr_info_t
 
 	spin_lock_irqsave(&h->lock, flags);
 	sa = h->scsi_ctlr;
-	stk = &sa->cmd_stack; 
+	stk = &sa->cmd_stack;
 
 	if (sa->registered) {
 		dev_info(&h->pdev->dev, "SCSI subsystem already engaged.\n");
@@ -1644,13 +1640,13 @@ retry_tur:
 	return rc;
 }
 
-/* Need at least one of these error handlers to keep ../scsi/hosts.c from 
- * complaining.  Doing a host- or bus-reset can't do anything good here. 
+/* Need at least one of these error handlers to keep ../scsi/hosts.c from
+ * complaining.  Doing a host- or bus-reset can't do anything good here.
  * Despite what it might say in scsi_error.c, there may well be commands
  * on the controller, as the cciss driver registers twice, once as a block
  * device for the logical drives, and once as a scsi device, for any tape
  * drives.  So we know there are no commands out on the tape drives, but we
- * don't know there are no commands on the controller, and it is likely 
+ * don't know there are no commands on the controller, and it is likely
  * that there probably are, as the cciss block device is most commonly used
  * as a boot device (embedded controller on HP/Compaq systems.)
 */
@@ -1712,5 +1708,6 @@ static int  cciss_eh_abort_handler(struc
 /* If no tape support, then these become defined out of existence */
 
 #define cciss_scsi_setup(cntl_num)
+static void print_cmd(CommandList_struct *cp) {}
 
 #endif /* CONFIG_CISS_SCSI_TAPE */
--- a/drivers/block/cciss_scsi.h
+++ b/drivers/block/cciss_scsi.h
@@ -1,6 +1,6 @@
 /*
  *    Disk Array driver for HP Smart Array controllers, SCSI Tape module.
- *    (C) Copyright 2001, 2007 Hewlett-Packard Development Company, L.P.
+ *    (C) Copyright 2001, 2010 Hewlett-Packard Development Company, L.P.
  *
  *    This program is free software; you can redistribute it and/or modify
  *    it under the terms of the GNU General Public License as published by
@@ -74,6 +74,5 @@ struct cciss_scsi_hba_t {
 #define CCISS_MAX_SCSI_DEVS_PER_HBA 16
 	struct cciss_scsi_dev_t dev[CCISS_MAX_SCSI_DEVS_PER_HBA];
 };
-
 #endif /* _CCISS_SCSI_H_ */
 #endif /* CONFIG_CISS_SCSI_TAPE */
--- a/include/linux/cciss_ioctl.h
+++ b/include/linux/cciss_ioctl.h
@@ -14,7 +14,7 @@ typedef struct _cciss_pci_info_struct
 	unsigned char 	dev_fn;
 	unsigned short	domain;
 	__u32 		board_id;
-} cciss_pci_info_struct; 
+} cciss_pci_info_struct;
 
 typedef struct _cciss_coalint_struct
 {
@@ -40,7 +40,7 @@ typedef __u32 DriverVer_type;
 typedef struct _IOCTL_Command_struct {
   LUNAddr_struct	   LUN_info;
   RequestBlock_struct      Request;
-  ErrorInfo_struct  	   error_info; 
+  ErrorInfo_struct  	   error_info;
   WORD			   buf_size;  /* size in bytes of the buf */
   BYTE			   __user *buf;
 } IOCTL_Command_struct;
@@ -77,7 +77,7 @@ typedef struct _LogvolInfo_struct{
 #define CCISS_PASSTHRU	   _IOWR(CCISS_IOC_MAGIC, 11, IOCTL_Command_struct)
 #define CCISS_DEREGDISK	   _IO(CCISS_IOC_MAGIC, 12)
 
-/* no longer used... use REGNEWD instead */ 
+/* no longer used... use REGNEWD instead */
 #define CCISS_REGNEWDISK  _IOW(CCISS_IOC_MAGIC, 13, int)
 
 #define CCISS_REGNEWD	   _IO(CCISS_IOC_MAGIC, 14)
@@ -112,4 +112,4 @@ typedef struct _BIG_IOCTL32_Command_stru
 
 #endif /* CONFIG_COMPAT */
 #endif /* __KERNEL__ */
-#endif  
+#endif
