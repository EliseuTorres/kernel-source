From 0d451e79567f0c5b51004354e08c95f442491cb4 Mon Sep 17 00:00:00 2001
From: Carolyn Wyborny <carolyn.wyborny@intel.com>
Date: Fri, 11 Apr 2014 01:46:40 +0000
Subject: [PATCH v5 136/164] igb: Cleanups to fix msleep warnings

Git-commit: 0d451e79567f0c5b51004354e08c95f442491cb4
Patch-mainline: v3.16-rc1
Reference: fate#317388, bsc#909491
Target: sle11-sp4

This patch fixes WARNING:MSLEEP found by checkpatch check.

Signed-off-by: Carolyn Wyborny <carolyn.wyborny@intel.com>
Tested-by: Aaron Brown <aaron.f.brown@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>

---
 drivers/net/ethernet/intel/igb/e1000_82575.c |   16 ++++++++--------
 drivers/net/ethernet/intel/igb/e1000_mac.c   |    2 +-
 drivers/net/ethernet/intel/igb/e1000_phy.c   |    2 +-
 drivers/net/ethernet/intel/igb/igb_ethtool.c |   16 ++++++++--------
 drivers/net/ethernet/intel/igb/igb_main.c    |    6 +++---
 5 files changed, 21 insertions(+), 21 deletions(-)

Index: linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/e1000_82575.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/net/ethernet/intel/igb/e1000_82575.c
+++ linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/e1000_82575.c
@@ -1212,7 +1212,7 @@ static s32 igb_get_cfg_done_82575(struct
 	while (timeout) {
 		if (rd32(E1000_EEMNGCTL) & mask)
 			break;
-		msleep(1);
+		usleep_range(1000, 2000);
 		timeout--;
 	}
 	if (!timeout)
@@ -1312,7 +1312,7 @@ void igb_power_up_serdes_link_82575(stru
 
 	/* flush the write to verify completion */
 	wrfl();
-	msleep(1);
+	usleep_range(1000, 2000);
 }
 
 /**
@@ -1407,7 +1407,7 @@ void igb_shutdown_serdes_link_82575(stru
 
 		/* flush the write to verify completion */
 		wrfl();
-		msleep(1);
+		usleep_range(1000, 2000);
 	}
 }
 
@@ -1442,7 +1442,7 @@ static s32 igb_reset_hw_82575(struct e10
 	wr32(E1000_TCTL, E1000_TCTL_PSP);
 	wrfl();
 
-	msleep(10);
+	usleep_range(10000, 20000);
 
 	ctrl = rd32(E1000_CTRL);
 
@@ -1920,7 +1920,7 @@ void igb_rx_fifo_flush_82575(struct e100
 	}
 	/* Poll all queues to verify they have shut down */
 	for (ms_wait = 0; ms_wait < 10; ms_wait++) {
-		msleep(1);
+		usleep_range(1000, 2000);
 		rx_enabled = 0;
 		for (i = 0; i < 4; i++)
 			rx_enabled |= rd32(E1000_RXDCTL(i));
@@ -1948,7 +1948,7 @@ void igb_rx_fifo_flush_82575(struct e100
 	wr32(E1000_RCTL, temp_rctl);
 	wr32(E1000_RCTL, temp_rctl | E1000_RCTL_EN);
 	wrfl();
-	msleep(2);
+	usleep_range(2000, 3000);
 
 	/* Enable RX queues that were previously enabled and restore our
 	 * previous state
@@ -2236,7 +2236,7 @@ static s32 igb_reset_hw_82580(struct e10
 	wr32(E1000_TCTL, E1000_TCTL_PSP);
 	wrfl();
 
-	msleep(10);
+	usleep_range(10000, 11000);
 
 	/* Determine whether or not a global dev reset is requested */
 	if (global_device_reset &&
@@ -2254,7 +2254,7 @@ static s32 igb_reset_hw_82580(struct e10
 
 	/* Add delay to insure DEV_RST has time to complete */
 	if (global_device_reset)
-		msleep(5);
+		usleep_range(5000, 6000);
 
 	ret_val = igb_get_auto_rd_done(hw);
 	if (ret_val) {
Index: linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/e1000_mac.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/net/ethernet/intel/igb/e1000_mac.c
+++ linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/e1000_mac.c
@@ -1261,7 +1261,7 @@ s32 igb_get_auto_rd_done(struct e1000_hw
 	while (i < AUTO_READ_DONE_TIMEOUT) {
 		if (rd32(E1000_EECD) & E1000_EECD_AUTO_RD)
 			break;
-		msleep(1);
+		usleep_range(1000, 2000);
 		i++;
 	}
 
Index: linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/e1000_phy.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/net/ethernet/intel/igb/e1000_phy.c
+++ linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/e1000_phy.c
@@ -2240,7 +2240,7 @@ void igb_power_down_phy_copper(struct e1
 		hw->phy.ops.write_reg(hw, GS40G_COPPER_SPEC, power_reg);
 	}
 	hw->phy.ops.write_reg(hw, PHY_CONTROL, mii_reg);
-	msleep(1);
+	usleep_range(1000, 2000);
 }
 
 /**
Index: linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/igb_ethtool.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/net/ethernet/intel/igb/igb_ethtool.c
+++ linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/igb_ethtool.c
@@ -283,7 +283,7 @@ static int igb_set_settings(struct net_d
 	}
 
 	while (test_and_set_bit(__IGB_RESETTING, &adapter->state))
-		msleep(1);
+		usleep_range(1000, 2000);
 
 	if (ecmd->autoneg == AUTONEG_ENABLE) {
 		hw->mac.autoneg = 1;
@@ -396,7 +396,7 @@ static int igb_set_pauseparam(struct net
 	adapter->fc_autoneg = pause->autoneg;
 
 	while (test_and_set_bit(__IGB_RESETTING, &adapter->state))
-		msleep(1);
+		usleep_range(1000, 2000);
 
 	if (adapter->fc_autoneg == AUTONEG_ENABLE) {
 		hw->fc.requested_mode = e1000_fc_default;
@@ -883,7 +883,7 @@ static int igb_set_ringparam(struct net_
 	}
 
 	while (test_and_set_bit(__IGB_RESETTING, &adapter->state))
-		msleep(1);
+		usleep_range(1000, 2000);
 
 	if (!netif_running(adapter->netdev)) {
 		for (i = 0; i < adapter->num_tx_queues; i++)
@@ -1413,7 +1413,7 @@ static int igb_intr_test(struct igb_adap
 	/* Disable all the interrupts */
 	wr32(E1000_IMC, ~0);
 	wrfl();
-	msleep(10);
+	usleep_range(10000, 11000);
 
 	/* Define all writable bits for ICS */
 	switch (hw->mac.type) {
@@ -1460,7 +1460,7 @@ static int igb_intr_test(struct igb_adap
 			wr32(E1000_IMC, mask);
 			wr32(E1000_ICS, mask);
 			wrfl();
-			msleep(10);
+			usleep_range(10000, 11000);
 
 			if (adapter->test_icr & mask) {
 				*data = 3;
@@ -1482,7 +1482,7 @@ static int igb_intr_test(struct igb_adap
 		wr32(E1000_IMS, mask);
 		wr32(E1000_ICS, mask);
 		wrfl();
-		msleep(10);
+		usleep_range(10000, 11000);
 
 		if (!(adapter->test_icr & mask)) {
 			*data = 4;
@@ -1504,7 +1504,7 @@ static int igb_intr_test(struct igb_adap
 			wr32(E1000_IMC, ~mask);
 			wr32(E1000_ICS, ~mask);
 			wrfl();
-			msleep(10);
+			usleep_range(10000, 11000);
 
 			if (adapter->test_icr & mask) {
 				*data = 5;
@@ -1516,7 +1516,7 @@ static int igb_intr_test(struct igb_adap
 	/* Disable all the interrupts */
 	wr32(E1000_IMC, ~0);
 	wrfl();
-	msleep(10);
+	usleep_range(10000, 11000);
 
 	/* Unhook test interrupt handler */
 	if (adapter->flags & IGB_FLAG_HAS_MSIX)
Index: linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/igb_main.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/net/ethernet/intel/igb/igb_main.c
+++ linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/igb_main.c
@@ -1785,7 +1785,7 @@ void igb_down(struct igb_adapter *adapte
 	wr32(E1000_TCTL, tctl);
 	/* flush both disables and wait for them to finish */
 	wrfl();
-	msleep(10);
+	usleep_range(10000, 11000);
 
 	igb_irq_disable(adapter);
 
@@ -1825,7 +1825,7 @@ void igb_reinit_locked(struct igb_adapte
 {
 	WARN_ON(in_interrupt());
 	while (test_and_set_bit(__IGB_RESETTING, &adapter->state))
-		msleep(1);
+		usleep_range(1000, 2000);
 	igb_down(adapter);
 	igb_up(adapter);
 	clear_bit(__IGB_RESETTING, &adapter->state);
@@ -5029,7 +5029,7 @@ static int igb_change_mtu(struct net_dev
 		max_frame = ETH_FRAME_LEN + ETH_FCS_LEN;
 
 	while (test_and_set_bit(__IGB_RESETTING, &adapter->state))
-		msleep(1);
+		usleep_range(1000, 2000);
 
 	/* igb_down has a dependency on max_frame_size */
 	adapter->max_frame_size = max_frame;
