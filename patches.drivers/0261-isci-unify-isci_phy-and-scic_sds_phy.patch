From: Dan Williams <dan.j.williams@intel.com>
Date: Tue, 28 Jun 2011 15:05:53 -0700
Subject: [PATCH 261/273] isci: unify isci_phy and scic_sds_phy
Git-commit: 852809559e4680ba4768262a6c3d21454fcd460e
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

They are one in the same object so remove the distinction.  The near
duplicate fields (owning_port, and isci_port) will be cleaned up
after the scic_sds_port isci_port unification.

Reported-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/host.c          |   92 ++++----
 drivers/scsi/isci/host.h          |   17 +-
 drivers/scsi/isci/phy.c           |  479 ++++++++++++++++++-------------------
 drivers/scsi/isci/phy.h           |  112 ++-------
 drivers/scsi/isci/port.c          |  299 +++++++++--------------
 drivers/scsi/isci/port.h          |   16 +-
 drivers/scsi/isci/port_config.c   |  135 +++++------
 drivers/scsi/isci/remote_device.c |    2 +-
 8 files changed, 500 insertions(+), 652 deletions(-)

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index d91cd6d..c5c2733 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -311,7 +311,7 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct scu_unsolicited_frame_header *frame_header;
-	struct scic_sds_phy *phy;
+	struct isci_phy *iphy;
 	struct scic_sds_remote_device *device;
 
 	enum sci_status result = SCI_FAILURE;
@@ -332,8 +332,8 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 
 	if (frame_header->is_address_frame) {
 		index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
-		phy = &ihost->phys[index].sci;
-		result = scic_sds_phy_frame_handler(phy, frame_index);
+		iphy = &ihost->phys[index];
+		result = scic_sds_phy_frame_handler(iphy, frame_index);
 	} else {
 
 		index = SCU_GET_COMPLETION_INDEX(completion_entry);
@@ -344,8 +344,8 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 			 * device that has not yet been created.  In either case forwared
 			 * the frame to the PE and let it take care of the frame data. */
 			index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
-			phy = &ihost->phys[index].sci;
-			result = scic_sds_phy_frame_handler(phy, frame_index);
+			iphy = &ihost->phys[index];
+			result = scic_sds_phy_frame_handler(iphy, frame_index);
 		} else {
 			if (index < scic->remote_node_entries)
 				device = scic->device_table[index];
@@ -372,7 +372,7 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct scic_sds_remote_device *device;
 	struct isci_request *ireq;
-	struct scic_sds_phy *phy;
+	struct isci_phy *iphy;
 	u32 index;
 
 	index = SCU_GET_COMPLETION_INDEX(completion_entry);
@@ -452,8 +452,8 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 	 * we get the event notification.  This is a type 4 event. */
 	case SCU_EVENT_TYPE_OSSP_EVENT:
 		index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
-		phy = &ihost->phys[index].sci;
-		scic_sds_phy_event_handler(phy, completion_entry);
+		iphy = &ihost->phys[index];
+		scic_sds_phy_event_handler(iphy, completion_entry);
 		break;
 
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
@@ -862,11 +862,11 @@ static void scic_sds_controller_transition_to_ready(
 	}
 }
 
-static bool is_phy_starting(struct scic_sds_phy *sci_phy)
+static bool is_phy_starting(struct isci_phy *iphy)
 {
 	enum scic_sds_phy_states state;
 
-	state = sci_phy->sm.current_state_id;
+	state = iphy->sm.current_state_id;
 	switch (state) {
 	case SCI_PHY_STARTING:
 	case SCI_PHY_SUB_INITIAL:
@@ -896,7 +896,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 {
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct scic_sds_oem_params *oem = &scic->oem_parameters.sds1;
-	struct scic_sds_phy *sci_phy;
+	struct isci_phy *iphy;
 	enum sci_status status;
 
 	status = SCI_SUCCESS;
@@ -910,10 +910,10 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 		u8 index;
 
 		for (index = 0; index < SCI_MAX_PHYS; index++) {
-			sci_phy = &ihost->phys[index].sci;
-			state = sci_phy->sm.current_state_id;
+			iphy = &ihost->phys[index];
+			state = iphy->sm.current_state_id;
 
-			if (!phy_get_non_dummy_port(sci_phy))
+			if (!phy_get_non_dummy_port(iphy))
 				continue;
 
 			/* The controller start operation is complete iff:
@@ -922,9 +922,9 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 			 * - have an indication of a connected device and it has
 			 *   finished the link training process.
 			 */
-			if ((sci_phy->is_in_link_training == false && state == SCI_PHY_INITIAL) ||
-			    (sci_phy->is_in_link_training == false && state == SCI_PHY_STOPPED) ||
-			    (sci_phy->is_in_link_training == true && is_phy_starting(sci_phy))) {
+			if ((iphy->is_in_link_training == false && state == SCI_PHY_INITIAL) ||
+			    (iphy->is_in_link_training == false && state == SCI_PHY_STOPPED) ||
+			    (iphy->is_in_link_training == true && is_phy_starting(iphy))) {
 				is_controller_start_complete = false;
 				break;
 			}
@@ -939,10 +939,10 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 			scic->phy_startup_timer_pending = false;
 		}
 	} else {
-		sci_phy = &ihost->phys[scic->next_phy_to_start].sci;
+		iphy = &ihost->phys[scic->next_phy_to_start];
 
 		if (oem->controller.mode_type == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
-			if (phy_get_non_dummy_port(sci_phy) == NULL) {
+			if (phy_get_non_dummy_port(iphy) == NULL) {
 				scic->next_phy_to_start++;
 
 				/* Caution recursion ahead be forwarned
@@ -958,7 +958,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 			}
 		}
 
-		status = scic_sds_phy_start(sci_phy);
+		status = scic_sds_phy_start(iphy);
 
 		if (status == SCI_SUCCESS) {
 			sci_mod_timer(&scic->phy_timer,
@@ -970,7 +970,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 				 "to stop phy %d because of status "
 				 "%d.\n",
 				 __func__,
-				 ihost->phys[scic->next_phy_to_start].sci.phy_index,
+				 ihost->phys[scic->next_phy_to_start].phy_index,
 				 status);
 		}
 
@@ -1312,8 +1312,8 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	/* Cancel any/all outstanding phy timers */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
-		struct scic_sds_phy *sci_phy = &ihost->phys[i].sci;
-		del_timer_sync(&sci_phy->sata_timer.timer);
+		struct isci_phy *iphy = &ihost->phys[i];
+		del_timer_sync(&iphy->sata_timer.timer);
 	}
 
 	del_timer_sync(&ihost->sci.port_agent.timer.timer);
@@ -1527,7 +1527,7 @@ static enum sci_status scic_sds_controller_stop_phys(struct scic_sds_controller
 	status = SCI_SUCCESS;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		phy_status = scic_sds_phy_stop(&ihost->phys[index].sci);
+		phy_status = scic_sds_phy_stop(&ihost->phys[index]);
 
 		if (phy_status != SCI_SUCCESS &&
 		    phy_status != SCI_FAILURE_INVALID_STATE) {
@@ -1537,7 +1537,7 @@ static enum sci_status scic_sds_controller_stop_phys(struct scic_sds_controller
 				 "%s: Controller stop operation failed to stop "
 				 "phy %d because of status %d.\n",
 				 __func__,
-				 ihost->phys[index].sci.phy_index, phy_status);
+				 ihost->phys[index].phy_index, phy_status);
 		}
 	}
 
@@ -1786,7 +1786,7 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 	/* Construct the phys for this controller */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
 		/* Add all the PHYs to the dummy port */
-		scic_sds_phy_construct(&ihost->phys[i].sci,
+		scic_sds_phy_construct(&ihost->phys[i],
 				       &ihost->ports[SCI_MAX_PORTS].sci, i);
 	}
 
@@ -1865,7 +1865,7 @@ static void power_control_timeout(unsigned long data)
 	struct sci_timer *tmr = (struct sci_timer *)data;
 	struct scic_sds_controller *scic = container_of(tmr, typeof(*scic), power_control.timer);
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct scic_sds_phy *sci_phy;
+	struct isci_phy *iphy;
 	unsigned long flags;
 	u8 i;
 
@@ -1886,8 +1886,8 @@ static void power_control_timeout(unsigned long data)
 		if (scic->power_control.phys_waiting == 0)
 			break;
 
-		sci_phy = scic->power_control.requesters[i];
-		if (sci_phy == NULL)
+		iphy = scic->power_control.requesters[i];
+		if (iphy == NULL)
 			continue;
 
 		if (scic->power_control.phys_granted_power >=
@@ -1897,7 +1897,7 @@ static void power_control_timeout(unsigned long data)
 		scic->power_control.requesters[i] = NULL;
 		scic->power_control.phys_waiting--;
 		scic->power_control.phys_granted_power++;
-		scic_sds_phy_consume_power_handler(sci_phy);
+		scic_sds_phy_consume_power_handler(iphy);
 	}
 
 	/*
@@ -1919,14 +1919,14 @@ done:
  */
 void scic_sds_controller_power_control_queue_insert(
 	struct scic_sds_controller *scic,
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
-	BUG_ON(sci_phy == NULL);
+	BUG_ON(iphy == NULL);
 
 	if (scic->power_control.phys_granted_power <
 	    scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
 		scic->power_control.phys_granted_power++;
-		scic_sds_phy_consume_power_handler(sci_phy);
+		scic_sds_phy_consume_power_handler(iphy);
 
 		/*
 		 * stop and start the power_control timer. When the timer fires, the
@@ -1941,7 +1941,7 @@ void scic_sds_controller_power_control_queue_insert(
 
 	} else {
 		/* Add the phy in the waiting list */
-		scic->power_control.requesters[sci_phy->phy_index] = sci_phy;
+		scic->power_control.requesters[iphy->phy_index] = iphy;
 		scic->power_control.phys_waiting++;
 	}
 }
@@ -1954,15 +1954,15 @@ void scic_sds_controller_power_control_queue_insert(
  */
 void scic_sds_controller_power_control_queue_remove(
 	struct scic_sds_controller *scic,
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
-	BUG_ON(sci_phy == NULL);
+	BUG_ON(iphy == NULL);
 
-	if (scic->power_control.requesters[sci_phy->phy_index] != NULL) {
+	if (scic->power_control.requesters[iphy->phy_index] != NULL) {
 		scic->power_control.phys_waiting--;
 	}
 
-	scic->power_control.requesters[sci_phy->phy_index] = NULL;
+	scic->power_control.requesters[iphy->phy_index] = NULL;
 }
 
 #define AFE_REGISTER_WRITE_DELAY 10
@@ -2225,7 +2225,7 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 	 * are accessed during the port initialization.
 	 */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
-		result = scic_sds_phy_initialize(&ihost->phys[i].sci,
+		result = scic_sds_phy_initialize(&ihost->phys[i],
 						 &scic->scu_registers->peg0.pe[i].tl,
 						 &scic->scu_registers->peg0.pe[i].ll);
 		if (result != SCI_SUCCESS)
@@ -2484,43 +2484,43 @@ int isci_host_init(struct isci_host *isci_host)
 }
 
 void scic_sds_controller_link_up(struct scic_sds_controller *scic,
-		struct scic_sds_port *port, struct scic_sds_phy *phy)
+		struct scic_sds_port *port, struct isci_phy *iphy)
 {
 	switch (scic->sm.current_state_id) {
 	case SCIC_STARTING:
 		sci_del_timer(&scic->phy_timer);
 		scic->phy_startup_timer_pending = false;
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
-						 port, phy);
+						 port, iphy);
 		scic_sds_controller_start_next_phy(scic);
 		break;
 	case SCIC_READY:
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
-						 port, phy);
+						 port, iphy);
 		break;
 	default:
 		dev_dbg(scic_to_dev(scic),
 			"%s: SCIC Controller linkup event from phy %d in "
-			"unexpected state %d\n", __func__, phy->phy_index,
+			"unexpected state %d\n", __func__, iphy->phy_index,
 			scic->sm.current_state_id);
 	}
 }
 
 void scic_sds_controller_link_down(struct scic_sds_controller *scic,
-		struct scic_sds_port *port, struct scic_sds_phy *phy)
+		struct scic_sds_port *port, struct isci_phy *iphy)
 {
 	switch (scic->sm.current_state_id) {
 	case SCIC_STARTING:
 	case SCIC_READY:
 		scic->port_agent.link_down_handler(scic, &scic->port_agent,
-						   port, phy);
+						   port, iphy);
 		break;
 	default:
 		dev_dbg(scic_to_dev(scic),
 			"%s: SCIC Controller linkdown event from phy %d in "
 			"unexpected state %d\n",
 			__func__,
-			phy->phy_index,
+			iphy->phy_index,
 			scic->sm.current_state_id);
 	}
 }
diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 0b26d25..1edd135 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -101,14 +101,14 @@ struct scic_power_control {
 	 * This field is an array of phys that we are waiting on. The phys are direct
 	 * mapped into requesters via struct scic_sds_phy.phy_index
 	 */
-	struct scic_sds_phy *requesters[SCI_MAX_PHYS];
+	struct isci_phy *requesters[SCI_MAX_PHYS];
 
 };
 
 struct scic_sds_port_configuration_agent;
 typedef void (*port_config_fn)(struct scic_sds_controller *,
 			       struct scic_sds_port_configuration_agent *,
-			       struct scic_sds_port *, struct scic_sds_phy *);
+			       struct scic_sds_port *, struct isci_phy *);
 
 struct scic_sds_port_configuration_agent {
 	u16 phy_configured_mask;
@@ -523,9 +523,8 @@ static inline struct device *scic_to_dev(struct scic_sds_controller *scic)
 	return &scic_to_ihost(scic)->pdev->dev;
 }
 
-static inline struct device *sciphy_to_dev(struct scic_sds_phy *sci_phy)
+static inline struct device *sciphy_to_dev(struct isci_phy *iphy)
 {
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
 	if (!iphy || !iphy->isci_port || !iphy->isci_port->isci_host)
 		return NULL;
@@ -606,21 +605,21 @@ struct isci_request *scic_request_by_tag(struct scic_sds_controller *scic,
 
 void scic_sds_controller_power_control_queue_insert(
 	struct scic_sds_controller *scic,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_controller_power_control_queue_remove(
 	struct scic_sds_controller *scic,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_controller_link_up(
 	struct scic_sds_controller *scic,
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_controller_link_down(
 	struct scic_sds_controller *scic,
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_controller_remote_device_stopped(
 	struct scic_sds_controller *scic,
@@ -651,7 +650,7 @@ void isci_host_deinit(
 void isci_host_port_link_up(
 	struct isci_host *,
 	struct scic_sds_port *,
-	struct scic_sds_phy *);
+	struct isci_phy *);
 int isci_host_dev_found(struct domain_device *);
 
 void isci_host_remote_device_start_complete(
diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 98d93ae..0e60fb7 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -62,9 +62,9 @@
 /* Maximum arbitration wait time in micro-seconds */
 #define SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME  (700)
 
-enum sas_linkrate sci_phy_linkrate(struct scic_sds_phy *sci_phy)
+enum sas_linkrate sci_phy_linkrate(struct isci_phy *iphy)
 {
-	return sci_phy->max_negotiated_speed;
+	return iphy->max_negotiated_speed;
 }
 
 /*
@@ -80,23 +80,23 @@ enum sas_linkrate sci_phy_linkrate(struct scic_sds_phy *sci_phy)
  * enum sci_status
  */
 static enum sci_status scic_sds_phy_transport_layer_initialization(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	struct scu_transport_layer_registers __iomem *transport_layer_registers)
 {
 	u32 tl_control;
 
-	sci_phy->transport_layer_registers = transport_layer_registers;
+	iphy->transport_layer_registers = transport_layer_registers;
 
 	writel(SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX,
-		&sci_phy->transport_layer_registers->stp_rni);
+		&iphy->transport_layer_registers->stp_rni);
 
 	/*
 	 * Hardware team recommends that we enable the STP prefetch for all
 	 * transports
 	 */
-	tl_control = readl(&sci_phy->transport_layer_registers->control);
+	tl_control = readl(&iphy->transport_layer_registers->control);
 	tl_control |= SCU_TLCR_GEN_BIT(STP_WRITE_DATA_PREFETCH);
-	writel(tl_control, &sci_phy->transport_layer_registers->control);
+	writel(tl_control, &iphy->transport_layer_registers->control);
 
 	return SCI_SUCCESS;
 }
@@ -109,12 +109,12 @@ static enum sci_status scic_sds_phy_transport_layer_initialization(
  * enum sci_status
  */
 static enum sci_status
-scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
+scic_sds_phy_link_layer_initialization(struct isci_phy *iphy,
 				       struct scu_link_layer_registers __iomem *link_layer_registers)
 {
 	struct scic_sds_controller *scic =
-		sci_phy->owning_port->owning_controller;
-	int phy_idx = sci_phy->phy_index;
+		iphy->owning_port->owning_controller;
+	int phy_idx = iphy->phy_index;
 	struct sci_phy_user_params *phy_user =
 		&scic->user_parameters.sds1.phys[phy_idx];
 	struct sci_phy_oem_params *phy_oem =
@@ -126,7 +126,7 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 	u32 llctl, link_rate;
 	u32 clksm_value = 0;
 
-	sci_phy->link_layer_registers = link_layer_registers;
+	iphy->link_layer_registers = link_layer_registers;
 
 	/* Set our IDENTIFY frame data */
 	#define SCI_END_DEVICE 0x01
@@ -136,32 +136,32 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 	       SCU_SAS_TIID_GEN_BIT(STP_INITIATOR) |
 	       SCU_SAS_TIID_GEN_BIT(DA_SATA_HOST) |
 	       SCU_SAS_TIID_GEN_VAL(DEVICE_TYPE, SCI_END_DEVICE),
-	       &sci_phy->link_layer_registers->transmit_identification);
+	       &iphy->link_layer_registers->transmit_identification);
 
 	/* Write the device SAS Address */
 	writel(0xFEDCBA98,
-	       &sci_phy->link_layer_registers->sas_device_name_high);
-	writel(phy_idx, &sci_phy->link_layer_registers->sas_device_name_low);
+	       &iphy->link_layer_registers->sas_device_name_high);
+	writel(phy_idx, &iphy->link_layer_registers->sas_device_name_low);
 
 	/* Write the source SAS Address */
 	writel(phy_oem->sas_address.high,
-		&sci_phy->link_layer_registers->source_sas_address_high);
+		&iphy->link_layer_registers->source_sas_address_high);
 	writel(phy_oem->sas_address.low,
-		&sci_phy->link_layer_registers->source_sas_address_low);
+		&iphy->link_layer_registers->source_sas_address_low);
 
 	/* Clear and Set the PHY Identifier */
-	writel(0, &sci_phy->link_layer_registers->identify_frame_phy_id);
+	writel(0, &iphy->link_layer_registers->identify_frame_phy_id);
 	writel(SCU_SAS_TIPID_GEN_VALUE(ID, phy_idx),
-		&sci_phy->link_layer_registers->identify_frame_phy_id);
+		&iphy->link_layer_registers->identify_frame_phy_id);
 
 	/* Change the initial state of the phy configuration register */
 	phy_configuration =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 
 	/* Hold OOB state machine in reset */
 	phy_configuration |=  SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
 	writel(phy_configuration,
-		&sci_phy->link_layer_registers->phy_configuration);
+		&iphy->link_layer_registers->phy_configuration);
 
 	/* Configure the SNW capabilities */
 	phy_cap.all = 0;
@@ -191,14 +191,14 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 	if ((parity_count % 2) != 0)
 		phy_cap.parity = 1;
 
-	writel(phy_cap.all, &sci_phy->link_layer_registers->phy_capabilities);
+	writel(phy_cap.all, &iphy->link_layer_registers->phy_capabilities);
 
 	/* Set the enable spinup period but disable the ability to send
 	 * notify enable spinup
 	 */
 	writel(SCU_ENSPINUP_GEN_VAL(COUNT,
 			phy_user->notify_enable_spin_up_insertion_frequency),
-		&sci_phy->link_layer_registers->notify_enable_spinup_control);
+		&iphy->link_layer_registers->notify_enable_spinup_control);
 
 	/* Write the ALIGN Insertion Ferequency for connected phy and
 	 * inpendent of connected state
@@ -209,11 +209,11 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 	clksm_value |= SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(GENERAL,
 			phy_user->align_insertion_frequency);
 
-	writel(clksm_value, &sci_phy->link_layer_registers->clock_skew_management);
+	writel(clksm_value, &iphy->link_layer_registers->clock_skew_management);
 
 	/* @todo Provide a way to write this register correctly */
 	writel(0x02108421,
-		&sci_phy->link_layer_registers->afe_lookup_table_control);
+		&iphy->link_layer_registers->afe_lookup_table_control);
 
 	llctl = SCU_SAS_LLCTL_GEN_VAL(NO_OUTBOUND_TASK_TIMEOUT,
 		(u8)scic->user_parameters.sds1.no_outbound_task_timeout);
@@ -230,7 +230,7 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 		break;
 	}
 	llctl |= SCU_SAS_LLCTL_GEN_VAL(MAX_LINK_RATE, link_rate);
-	writel(llctl, &sci_phy->link_layer_registers->link_layer_control);
+	writel(llctl, &iphy->link_layer_registers->link_layer_control);
 
 	if (is_a0() || is_a2()) {
 		/* Program the max ARB time for the PHY to 700us so we inter-operate with
@@ -239,14 +239,14 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 		 * generate the break.
 		 */
 		writel(SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME,
-			&sci_phy->link_layer_registers->maximum_arbitration_wait_timer_timeout);
+			&iphy->link_layer_registers->maximum_arbitration_wait_timer_timeout);
 	}
 
 	/* Disable link layer hang detection, rely on the OS timeout for I/O timeouts. */
-	writel(0, &sci_phy->link_layer_registers->link_layer_hang_detection_timeout);
+	writel(0, &iphy->link_layer_registers->link_layer_hang_detection_timeout);
 
 	/* We can exit the initial state to the stopped state */
-	sci_change_state(&sci_phy->sm, SCI_PHY_STOPPED);
+	sci_change_state(&iphy->sm, SCI_PHY_STOPPED);
 
 	return SCI_SUCCESS;
 }
@@ -254,8 +254,8 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 static void phy_sata_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
-	struct scic_sds_phy *sci_phy = container_of(tmr, typeof(*sci_phy), sata_timer);
-	struct isci_host *ihost = scic_to_ihost(sci_phy->owning_port->owning_controller);
+	struct isci_phy *iphy = container_of(tmr, typeof(*iphy), sata_timer);
+	struct isci_host *ihost = scic_to_ihost(iphy->owning_port->owning_controller);
 	unsigned long flags;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
@@ -263,13 +263,13 @@ static void phy_sata_timeout(unsigned long data)
 	if (tmr->cancel)
 		goto done;
 
-	dev_dbg(sciphy_to_dev(sci_phy),
+	dev_dbg(sciphy_to_dev(iphy),
 		 "%s: SCIC SDS Phy 0x%p did not receive signature fis before "
 		 "timeout.\n",
 		 __func__,
-		 sci_phy);
+		 iphy);
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+	sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 done:
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
@@ -287,30 +287,30 @@ done:
  * values indicate a handle/pointer to the port containing the phy.
  */
 struct scic_sds_port *phy_get_non_dummy_port(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
-	if (scic_sds_port_get_index(sci_phy->owning_port) == SCIC_SDS_DUMMY_PORT)
+	if (scic_sds_port_get_index(iphy->owning_port) == SCIC_SDS_DUMMY_PORT)
 		return NULL;
 
-	return sci_phy->owning_port;
+	return iphy->owning_port;
 }
 
 /**
  * This method will assign a port to the phy object.
- * @out]: sci_phy This parameter specifies the phy for which to assign a port
+ * @out]: iphy This parameter specifies the phy for which to assign a port
  *    object.
  *
  *
  */
 void scic_sds_phy_set_port(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	struct scic_sds_port *sci_port)
 {
-	sci_phy->owning_port = sci_port;
+	iphy->owning_port = sci_port;
 
-	if (sci_phy->bcn_received_while_port_unassigned) {
-		sci_phy->bcn_received_while_port_unassigned = false;
-		scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
+	if (iphy->bcn_received_while_port_unassigned) {
+		iphy->bcn_received_while_port_unassigned = false;
+		scic_sds_port_broadcast_change_received(iphy->owning_port, iphy);
 	}
 }
 
@@ -322,22 +322,22 @@ void scic_sds_phy_set_port(
  * enum sci_status
  */
 enum sci_status scic_sds_phy_initialize(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	struct scu_transport_layer_registers __iomem *transport_layer_registers,
 	struct scu_link_layer_registers __iomem *link_layer_registers)
 {
 	/* Perfrom the initialization of the TL hardware */
 	scic_sds_phy_transport_layer_initialization(
-			sci_phy,
+			iphy,
 			transport_layer_registers);
 
 	/* Perofrm the initialization of the PE hardware */
-	scic_sds_phy_link_layer_initialization(sci_phy, link_layer_registers);
+	scic_sds_phy_link_layer_initialization(iphy, link_layer_registers);
 
 	/*
 	 * There is nothing that needs to be done in this state just
 	 * transition to the stopped state. */
-	sci_change_state(&sci_phy->sm, SCI_PHY_STOPPED);
+	sci_change_state(&iphy->sm, SCI_PHY_STOPPED);
 
 	return SCI_SUCCESS;
 }
@@ -345,27 +345,27 @@ enum sci_status scic_sds_phy_initialize(
 /**
  * This method assigns the direct attached device ID for this phy.
  *
- * @sci_phy The phy for which the direct attached device id is to
+ * @iphy The phy for which the direct attached device id is to
  *       be assigned.
  * @device_id The direct attached device ID to assign to the phy.
  *       This will either be the RNi for the device or an invalid RNi if there
  *       is no current device assigned to the phy.
  */
 void scic_sds_phy_setup_transport(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	u32 device_id)
 {
 	u32 tl_control;
 
-	writel(device_id, &sci_phy->transport_layer_registers->stp_rni);
+	writel(device_id, &iphy->transport_layer_registers->stp_rni);
 
 	/*
 	 * The read should guarantee that the first write gets posted
 	 * before the next write
 	 */
-	tl_control = readl(&sci_phy->transport_layer_registers->control);
+	tl_control = readl(&iphy->transport_layer_registers->control);
 	tl_control |= SCU_TLCR_GEN_BIT(CLEAR_TCI_NCQ_MAPPING_TABLE);
-	writel(tl_control, &sci_phy->transport_layer_registers->control);
+	writel(tl_control, &iphy->transport_layer_registers->control);
 }
 
 /**
@@ -376,75 +376,74 @@ void scic_sds_phy_setup_transport(
  * hardware protocol engine. none
  */
 static void scic_sds_phy_suspend(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	u32 scu_sas_pcfg_value;
 
 	scu_sas_pcfg_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);
 	writel(scu_sas_pcfg_value,
-		&sci_phy->link_layer_registers->phy_configuration);
+		&iphy->link_layer_registers->phy_configuration);
 
 	scic_sds_phy_setup_transport(
-			sci_phy,
+			iphy,
 			SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
 }
 
-void scic_sds_phy_resume(struct scic_sds_phy *sci_phy)
+void scic_sds_phy_resume(struct isci_phy *iphy)
 {
 	u32 scu_sas_pcfg_value;
 
 	scu_sas_pcfg_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);
 	writel(scu_sas_pcfg_value,
-		&sci_phy->link_layer_registers->phy_configuration);
+		&iphy->link_layer_registers->phy_configuration);
 }
 
-void scic_sds_phy_get_sas_address(struct scic_sds_phy *sci_phy,
+void scic_sds_phy_get_sas_address(struct isci_phy *iphy,
 				  struct sci_sas_address *sas_address)
 {
-	sas_address->high = readl(&sci_phy->link_layer_registers->source_sas_address_high);
-	sas_address->low = readl(&sci_phy->link_layer_registers->source_sas_address_low);
+	sas_address->high = readl(&iphy->link_layer_registers->source_sas_address_high);
+	sas_address->low = readl(&iphy->link_layer_registers->source_sas_address_low);
 }
 
-void scic_sds_phy_get_attached_sas_address(struct scic_sds_phy *sci_phy,
+void scic_sds_phy_get_attached_sas_address(struct isci_phy *iphy,
 					   struct sci_sas_address *sas_address)
 {
 	struct sas_identify_frame *iaf;
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
 	iaf = &iphy->frame_rcvd.iaf;
 	memcpy(sas_address, iaf->sas_addr, SAS_ADDR_SIZE);
 }
 
-void scic_sds_phy_get_protocols(struct scic_sds_phy *sci_phy,
+void scic_sds_phy_get_protocols(struct isci_phy *iphy,
 				struct scic_phy_proto *protocols)
 {
 	protocols->all =
-		(u16)(readl(&sci_phy->
+		(u16)(readl(&iphy->
 			link_layer_registers->transmit_identification) &
 				0x0000FFFF);
 }
 
-enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy)
+enum sci_status scic_sds_phy_start(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
 
 	if (state != SCI_PHY_STOPPED) {
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+	sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy)
+enum sci_status scic_sds_phy_stop(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PHY_SUB_INITIAL:
@@ -459,43 +458,43 @@ enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy)
 	case SCI_PHY_READY:
 		break;
 	default:
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_STOPPED);
+	sci_change_state(&iphy->sm, SCI_PHY_STOPPED);
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_phy_reset(struct scic_sds_phy *sci_phy)
+enum sci_status scic_sds_phy_reset(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
 
 	if (state != SCI_PHY_READY) {
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_RESETTING);
+	sci_change_state(&iphy->sm, SCI_PHY_RESETTING);
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_phy_consume_power_handler(struct scic_sds_phy *sci_phy)
+enum sci_status scic_sds_phy_consume_power_handler(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PHY_SUB_AWAIT_SAS_POWER: {
 		u32 enable_spinup;
 
-		enable_spinup = readl(&sci_phy->link_layer_registers->notify_enable_spinup_control);
+		enable_spinup = readl(&iphy->link_layer_registers->notify_enable_spinup_control);
 		enable_spinup |= SCU_ENSPINUP_GEN_BIT(ENABLE);
-		writel(enable_spinup, &sci_phy->link_layer_registers->notify_enable_spinup_control);
+		writel(enable_spinup, &iphy->link_layer_registers->notify_enable_spinup_control);
 
 		/* Change state to the final state this substate machine has run to completion */
-		sci_change_state(&sci_phy->sm, SCI_PHY_SUB_FINAL);
+		sci_change_state(&iphy->sm, SCI_PHY_SUB_FINAL);
 
 		return SCI_SUCCESS;
 	}
@@ -504,26 +503,26 @@ enum sci_status scic_sds_phy_consume_power_handler(struct scic_sds_phy *sci_phy)
 
 		/* Release the spinup hold state and reset the OOB state machine */
 		scu_sas_pcfg_value =
-			readl(&sci_phy->link_layer_registers->phy_configuration);
+			readl(&iphy->link_layer_registers->phy_configuration);
 		scu_sas_pcfg_value &=
 			~(SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD) | SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE));
 		scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
 		writel(scu_sas_pcfg_value,
-			&sci_phy->link_layer_registers->phy_configuration);
+			&iphy->link_layer_registers->phy_configuration);
 
 		/* Now restart the OOB operation */
 		scu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
 		scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
 		writel(scu_sas_pcfg_value,
-			&sci_phy->link_layer_registers->phy_configuration);
+			&iphy->link_layer_registers->phy_configuration);
 
 		/* Change state to the final state this substate machine has run to completion */
-		sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_PHY_EN);
+		sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_PHY_EN);
 
 		return SCI_SUCCESS;
 	}
 	default:
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -545,19 +544,19 @@ enum sci_status scic_sds_phy_consume_power_handler(struct scic_sds_phy *sci_phy)
  * none
  */
 static void scic_sds_phy_start_sas_link_training(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	u32 phy_control;
 
 	phy_control =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	phy_control |= SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD);
 	writel(phy_control,
-		&sci_phy->link_layer_registers->phy_configuration);
+		&iphy->link_layer_registers->phy_configuration);
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SAS_SPEED_EN);
+	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SAS_SPEED_EN);
 
-	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SAS;
+	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SAS;
 }
 
 /**
@@ -569,11 +568,11 @@ static void scic_sds_phy_start_sas_link_training(
  * SPINUP HOLD event when the state machine was expecting a SAS PHY event. none
  */
 static void scic_sds_phy_start_sata_link_training(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
-	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_POWER);
+	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_POWER);
 
-	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
+	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
 }
 
 /**
@@ -588,33 +587,33 @@ static void scic_sds_phy_start_sata_link_training(
  *
  */
 static void scic_sds_phy_complete_link_training(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	enum sas_linkrate max_link_rate,
 	u32 next_state)
 {
-	sci_phy->max_negotiated_speed = max_link_rate;
+	iphy->max_negotiated_speed = max_link_rate;
 
-	sci_change_state(&sci_phy->sm, next_state);
+	sci_change_state(&iphy->sm, next_state);
 }
 
-enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
+enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
 					   u32 event_code)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PHY_SUB_AWAIT_OSSP_EN:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SAS_PHY_DETECTED:
-			scic_sds_phy_start_sas_link_training(sci_phy);
-			sci_phy->is_in_link_training = true;
+			scic_sds_phy_start_sas_link_training(iphy);
+			iphy->is_in_link_training = true;
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
-			scic_sds_phy_start_sata_link_training(sci_phy);
-			sci_phy->is_in_link_training = true;
+			scic_sds_phy_start_sata_link_training(iphy);
+			iphy->is_in_link_training = true;
 			break;
 		default:
-			dev_dbg(sciphy_to_dev(sci_phy),
+			dev_dbg(sciphy_to_dev(iphy),
 				"%s: PHY starting substate machine received "
 				"unexpected event_code %x\n",
 				__func__,
@@ -632,21 +631,21 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		case SCU_EVENT_SAS_15:
 		case SCU_EVENT_SAS_15_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_1_5_GBPS,
 				SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
 		case SCU_EVENT_SAS_30:
 		case SCU_EVENT_SAS_30_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_3_0_GBPS,
 				SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
 		case SCU_EVENT_SAS_60:
 		case SCU_EVENT_SAS_60_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_6_0_GBPS,
 				SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
@@ -654,14 +653,14 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			/*
 			 * We were doing SAS PHY link training and received a SATA PHY event
 			 * continue OOB/SN as if this were a SATA PHY */
-			scic_sds_phy_start_sata_link_training(sci_phy);
+			scic_sds_phy_start_sata_link_training(iphy);
 			break;
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__, event_code);
@@ -674,23 +673,23 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/* Backup the state machine */
-			scic_sds_phy_start_sas_link_training(sci_phy);
+			scic_sds_phy_start_sas_link_training(iphy);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/* We were doing SAS PHY link training and received a
 			 * SATA PHY event continue OOB/SN as if this were a
 			 * SATA PHY
 			 */
-			scic_sds_phy_start_sata_link_training(sci_phy);
+			scic_sds_phy_start_sata_link_training(iphy);
 			break;
 		case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
 		case SCU_EVENT_LINK_FAILURE:
 		case SCU_EVENT_HARD_RESET_RECEIVED:
 			/* Start the oob/sn state machine over again */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__, event_code);
@@ -701,10 +700,10 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				"%s: PHY starting substate machine received unexpected "
 				"event_code %x\n",
 				__func__,
@@ -716,7 +715,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/* These events are received every 10ms and are
@@ -728,11 +727,11 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			/* There has been a change in the phy type before OOB/SN for the
 			 * SATA finished start down the SAS link traning path.
 			 */
-			scic_sds_phy_start_sas_link_training(sci_phy);
+			scic_sds_phy_start_sas_link_training(iphy);
 			break;
 
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__, event_code);
@@ -744,7 +743,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/* These events might be received since we dont know how many may be in
@@ -752,19 +751,19 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			 */
 			break;
 		case SCU_EVENT_SATA_PHY_DETECTED:
-			sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
+			iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
 
 			/* We have received the SATA PHY notification change state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
+			sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
 			break;
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/* There has been a change in the phy type before OOB/SN for the
 			 * SATA finished start down the SAS link traning path.
 			 */
-			scic_sds_phy_start_sas_link_training(sci_phy);
+			scic_sds_phy_start_sas_link_training(iphy);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__,
@@ -783,36 +782,36 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		case SCU_EVENT_SATA_15:
 		case SCU_EVENT_SATA_15_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_1_5_GBPS,
 				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_SATA_30:
 		case SCU_EVENT_SATA_30_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_3_0_GBPS,
 				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_SATA_60:
 		case SCU_EVENT_SATA_60_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_6_0_GBPS,
 				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/*
 			 * There has been a change in the phy type before OOB/SN for the
 			 * SATA finished start down the SAS link traning path. */
-			scic_sds_phy_start_sas_link_training(sci_phy);
+			scic_sds_phy_start_sas_link_training(iphy);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__, event_code);
@@ -825,16 +824,16 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SATA_PHY_DETECTED:
 			/* Backup the state machine */
-			sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
+			sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
 			break;
 
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__,
@@ -847,20 +846,20 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_BROADCAST_CHANGE:
 			/* Broadcast change received. Notify the port. */
-			if (phy_get_non_dummy_port(sci_phy) != NULL)
-				scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
+			if (phy_get_non_dummy_port(iphy) != NULL)
+				scic_sds_port_broadcast_change_received(iphy->owning_port, iphy);
 			else
-				sci_phy->bcn_received_while_port_unassigned = true;
+				iphy->bcn_received_while_port_unassigned = true;
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%sP SCIC PHY 0x%p ready state machine received "
 				 "unexpected event_code %x\n",
-				 __func__, sci_phy, event_code);
+				 __func__, iphy, event_code);
 			return SCI_FAILURE_INVALID_STATE;
 		}
 		return SCI_SUCCESS;
@@ -868,30 +867,30 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_HARD_RESET_TRANSMITTED:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: SCIC PHY 0x%p resetting state machine received "
 				 "unexpected event_code %x\n",
-				 __func__, sci_phy, event_code);
+				 __func__, iphy, event_code);
 
 			return SCI_FAILURE_INVALID_STATE;
 			break;
 		}
 		return SCI_SUCCESS;
 	default:
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
+enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 					   u32 frame_index)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
+	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
 	enum sci_status result;
 	unsigned long flags;
 
@@ -899,7 +898,6 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 	case SCI_PHY_SUB_AWAIT_IAF_UF: {
 		u32 *frame_words;
 		struct sas_identify_frame iaf;
-		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
 		result = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
 								       frame_index,
@@ -927,10 +925,10 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 				 */
 				state = SCI_PHY_SUB_AWAIT_SAS_POWER;
 			}
-			sci_change_state(&sci_phy->sm, state);
+			sci_change_state(&iphy->sm, state);
 			result = SCI_SUCCESS;
 		} else
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				"%s: PHY starting substate machine received "
 				"unexpected frame id %x\n",
 				__func__, frame_index);
@@ -941,10 +939,9 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 	case SCI_PHY_SUB_AWAIT_SIG_FIS_UF: {
 		struct dev_to_host_fis *frame_header;
 		u32 *fis_frame_data;
-		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
 		result = scic_sds_unsolicited_frame_control_get_header(
-			&(scic_sds_phy_get_controller(sci_phy)->uf_control),
+			&(scic_sds_phy_get_controller(iphy)->uf_control),
 			frame_index,
 			(void **)&frame_header);
 
@@ -964,11 +961,11 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 			spin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);
 
 			/* got IAF we can now go to the await spinup semaphore state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_SUB_FINAL);
+			sci_change_state(&iphy->sm, SCI_PHY_SUB_FINAL);
 
 			result = SCI_SUCCESS;
 		} else
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected frame id %x\n",
 				 __func__, frame_index);
@@ -979,7 +976,7 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 		return result;
 	}
 	default:
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -988,77 +985,77 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 
 static void scic_sds_phy_starting_initial_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	/* This is just an temporary state go off to the starting state */
-	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_OSSP_EN);
+	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_OSSP_EN);
 }
 
 static void scic_sds_phy_starting_await_sas_power_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_insert(scic, sci_phy);
+	scic_sds_controller_power_control_queue_insert(scic, iphy);
 }
 
 static void scic_sds_phy_starting_await_sas_power_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_remove(scic, sci_phy);
+	scic_sds_controller_power_control_queue_remove(scic, iphy);
 }
 
 static void scic_sds_phy_starting_await_sata_power_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_insert(scic, sci_phy);
+	scic_sds_controller_power_control_queue_insert(scic, iphy);
 }
 
 static void scic_sds_phy_starting_await_sata_power_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_remove(scic, sci_phy);
+	scic_sds_controller_power_control_queue_remove(scic, iphy);
 }
 
 static void scic_sds_phy_starting_await_sata_phy_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	sci_mod_timer(&sci_phy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
+	sci_mod_timer(&iphy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
 static void scic_sds_phy_starting_await_sata_phy_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	sci_del_timer(&sci_phy->sata_timer);
+	sci_del_timer(&iphy->sata_timer);
 }
 
 static void scic_sds_phy_starting_await_sata_speed_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	sci_mod_timer(&sci_phy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
+	sci_mod_timer(&iphy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
 static void scic_sds_phy_starting_await_sata_speed_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	sci_del_timer(&sci_phy->sata_timer);
+	sci_del_timer(&iphy->sata_timer);
 }
 
 static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	if (scic_sds_port_link_detected(sci_phy->owning_port, sci_phy)) {
+	if (scic_sds_port_link_detected(iphy->owning_port, iphy)) {
 
 		/*
 		 * Clear the PE suspend condition so we can actually
@@ -1066,79 +1063,79 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_bas
 		 * The hardware will not respond to the XRDY until the PE
 		 * suspend condition is cleared.
 		 */
-		scic_sds_phy_resume(sci_phy);
+		scic_sds_phy_resume(iphy);
 
-		sci_mod_timer(&sci_phy->sata_timer,
+		sci_mod_timer(&iphy->sata_timer,
 			      SCIC_SDS_SIGNATURE_FIS_TIMEOUT);
 	} else
-		sci_phy->is_in_link_training = false;
+		iphy->is_in_link_training = false;
 }
 
 static void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	sci_del_timer(&sci_phy->sata_timer);
+	sci_del_timer(&iphy->sata_timer);
 }
 
 static void scic_sds_phy_starting_final_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	/* State machine has run to completion so exit out and change
 	 * the base state machine to the ready state
 	 */
-	sci_change_state(&sci_phy->sm, SCI_PHY_READY);
+	sci_change_state(&iphy->sm, SCI_PHY_READY);
 }
 
 /**
  *
- * @sci_phy: This is the struct scic_sds_phy object to stop.
+ * @sci_phy: This is the struct isci_phy object to stop.
  *
- * This method will stop the struct scic_sds_phy object. This does not reset the
+ * This method will stop the struct isci_phy object. This does not reset the
  * protocol engine it just suspends it and places it in a state where it will
  * not cause the end device to power up. none
  */
 static void scu_link_layer_stop_protocol_engine(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	u32 scu_sas_pcfg_value;
 	u32 enable_spinup_value;
 
 	/* Suspend the protocol engine and place it in a sata spinup hold state */
 	scu_sas_pcfg_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value |=
 		(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
 		 SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE) |
 		 SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD));
 	writel(scu_sas_pcfg_value,
-	       &sci_phy->link_layer_registers->phy_configuration);
+	       &iphy->link_layer_registers->phy_configuration);
 
 	/* Disable the notify enable spinup primitives */
-	enable_spinup_value = readl(&sci_phy->link_layer_registers->notify_enable_spinup_control);
+	enable_spinup_value = readl(&iphy->link_layer_registers->notify_enable_spinup_control);
 	enable_spinup_value &= ~SCU_ENSPINUP_GEN_BIT(ENABLE);
-	writel(enable_spinup_value, &sci_phy->link_layer_registers->notify_enable_spinup_control);
+	writel(enable_spinup_value, &iphy->link_layer_registers->notify_enable_spinup_control);
 }
 
 /**
  *
  *
- * This method will start the OOB/SN state machine for this struct scic_sds_phy object.
+ * This method will start the OOB/SN state machine for this struct isci_phy object.
  */
 static void scu_link_layer_start_oob(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	u32 scu_sas_pcfg_value;
 
 	scu_sas_pcfg_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
 	scu_sas_pcfg_value &=
 		~(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
 		SCU_SAS_PCFG_GEN_BIT(HARD_RESET));
 	writel(scu_sas_pcfg_value,
-	       &sci_phy->link_layer_registers->phy_configuration);
+	       &iphy->link_layer_registers->phy_configuration);
 }
 
 /**
@@ -1150,7 +1147,7 @@ static void scu_link_layer_start_oob(
  * hard reset bit set.
  */
 static void scu_link_layer_tx_hard_reset(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	u32 phy_configuration_value;
 
@@ -1158,91 +1155,91 @@ static void scu_link_layer_tx_hard_reset(
 	 * SAS Phys must wait for the HARD_RESET_TX event notification to transition
 	 * to the starting state. */
 	phy_configuration_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	phy_configuration_value |=
 		(SCU_SAS_PCFG_GEN_BIT(HARD_RESET) |
 		 SCU_SAS_PCFG_GEN_BIT(OOB_RESET));
 	writel(phy_configuration_value,
-	       &sci_phy->link_layer_registers->phy_configuration);
+	       &iphy->link_layer_registers->phy_configuration);
 
 	/* Now take the OOB state machine out of reset */
 	phy_configuration_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
 	phy_configuration_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
 	writel(phy_configuration_value,
-	       &sci_phy->link_layer_registers->phy_configuration);
+	       &iphy->link_layer_registers->phy_configuration);
 }
 
 static void scic_sds_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	/*
 	 * @todo We need to get to the controller to place this PE in a
 	 * reset state
 	 */
-	sci_del_timer(&sci_phy->sata_timer);
+	sci_del_timer(&iphy->sata_timer);
 
-	scu_link_layer_stop_protocol_engine(sci_phy);
+	scu_link_layer_stop_protocol_engine(iphy);
 
-	if (sci_phy->sm.previous_state_id != SCI_PHY_INITIAL)
-		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
-					      phy_get_non_dummy_port(sci_phy),
-					      sci_phy);
+	if (iphy->sm.previous_state_id != SCI_PHY_INITIAL)
+		scic_sds_controller_link_down(scic_sds_phy_get_controller(iphy),
+					      phy_get_non_dummy_port(iphy),
+					      iphy);
 }
 
 static void scic_sds_phy_starting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	scu_link_layer_stop_protocol_engine(sci_phy);
-	scu_link_layer_start_oob(sci_phy);
+	scu_link_layer_stop_protocol_engine(iphy);
+	scu_link_layer_start_oob(iphy);
 
 	/* We don't know what kind of phy we are going to be just yet */
-	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
-	sci_phy->bcn_received_while_port_unassigned = false;
+	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
+	iphy->bcn_received_while_port_unassigned = false;
 
-	if (sci_phy->sm.previous_state_id == SCI_PHY_READY)
-		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
-					      phy_get_non_dummy_port(sci_phy),
-					      sci_phy);
+	if (iphy->sm.previous_state_id == SCI_PHY_READY)
+		scic_sds_controller_link_down(scic_sds_phy_get_controller(iphy),
+					      phy_get_non_dummy_port(iphy),
+					      iphy);
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_INITIAL);
+	sci_change_state(&iphy->sm, SCI_PHY_SUB_INITIAL);
 }
 
 static void scic_sds_phy_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	scic_sds_controller_link_up(scic_sds_phy_get_controller(sci_phy),
-				    phy_get_non_dummy_port(sci_phy),
-				    sci_phy);
+	scic_sds_controller_link_up(scic_sds_phy_get_controller(iphy),
+				    phy_get_non_dummy_port(iphy),
+				    iphy);
 
 }
 
 static void scic_sds_phy_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	scic_sds_phy_suspend(sci_phy);
+	scic_sds_phy_suspend(iphy);
 }
 
 static void scic_sds_phy_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	/* The phy is being reset, therefore deactivate it from the port.  In
 	 * the resetting state we don't notify the user regarding link up and
 	 * link down notifications
 	 */
-	scic_sds_port_deactivate_phy(sci_phy->owning_port, sci_phy, false);
+	scic_sds_port_deactivate_phy(iphy->owning_port, iphy, false);
 
-	if (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
-		scu_link_layer_tx_hard_reset(sci_phy);
+	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+		scu_link_layer_tx_hard_reset(iphy);
 	} else {
 		/* The SCU does not need to have a discrete reset state so
 		 * just go back to the starting state.
 		 */
-		sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+		sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 	}
 }
 
@@ -1293,21 +1290,21 @@ static const struct sci_base_state scic_sds_phy_state_table[] = {
 	[SCI_PHY_FINAL] = { },
 };
 
-void scic_sds_phy_construct(struct scic_sds_phy *sci_phy,
+void scic_sds_phy_construct(struct isci_phy *iphy,
 			    struct scic_sds_port *owning_port, u8 phy_index)
 {
-	sci_init_sm(&sci_phy->sm, scic_sds_phy_state_table, SCI_PHY_INITIAL);
+	sci_init_sm(&iphy->sm, scic_sds_phy_state_table, SCI_PHY_INITIAL);
 
 	/* Copy the rest of the input data to our locals */
-	sci_phy->owning_port = owning_port;
-	sci_phy->phy_index = phy_index;
-	sci_phy->bcn_received_while_port_unassigned = false;
-	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
-	sci_phy->link_layer_registers = NULL;
-	sci_phy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
+	iphy->owning_port = owning_port;
+	iphy->phy_index = phy_index;
+	iphy->bcn_received_while_port_unassigned = false;
+	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
+	iphy->link_layer_registers = NULL;
+	iphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
 
 	/* Create the SIGNATURE FIS Timeout timer for this phy */
-	sci_init_timer(&sci_phy->sata_timer, phy_sata_timeout);
+	sci_init_timer(&iphy->sata_timer, phy_sata_timeout);
 }
 
 void isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)
@@ -1368,14 +1365,14 @@ int isci_phy_control(struct asd_sas_phy *sas_phy,
 	switch (func) {
 	case PHY_FUNC_DISABLE:
 		spin_lock_irqsave(&ihost->scic_lock, flags);
-		scic_sds_phy_stop(&iphy->sci);
+		scic_sds_phy_stop(iphy);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 
 	case PHY_FUNC_LINK_RESET:
 		spin_lock_irqsave(&ihost->scic_lock, flags);
-		scic_sds_phy_stop(&iphy->sci);
-		scic_sds_phy_start(&iphy->sci);
+		scic_sds_phy_stop(iphy);
+		scic_sds_phy_start(iphy);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 
diff --git a/drivers/scsi/isci/phy.h b/drivers/scsi/isci/phy.h
index 97ebee1..345fbea 100644
--- a/drivers/scsi/isci/phy.h
+++ b/drivers/scsi/isci/phy.h
@@ -84,102 +84,40 @@ enum scic_sds_phy_protocol {
 };
 
 /**
- * struct scic_sds_phy - This structure  contains or references all of the data
- *    necessary to represent the core phy object and SCU harware protocol
- *    engine.
- *
- *
+ * isci_phy - hba local phy infrastructure
+ * @sm:
+ * @protocol: attached device protocol
+ * @phy_index: physical index relative to the controller (0-3)
+ * @bcn_received_while_port_unassigned: bcn to report after port association
+ * @sata_timer: timeout SATA signature FIS arrival
  */
-struct scic_sds_phy {
-	/**
-	 * This field contains the information for the base phy state machine.
-	 */
+struct isci_phy {
 	struct sci_base_state_machine sm;
-
-	/**
-	 * This field specifies the port object that owns/contains this phy.
-	 */
 	struct scic_sds_port *owning_port;
-
-	/**
-	 * This field indicates whether the phy supports 1.5 Gb/s, 3.0 Gb/s,
-	 * or 6.0 Gb/s operation.
-	 */
 	enum sas_linkrate max_negotiated_speed;
-
-	/**
-	 * This member specifies the protocol being utilized on this phy.  This
-	 * field contains a legitamite value once the PHY has link trained with
-	 * a remote phy.
-	 */
 	enum scic_sds_phy_protocol protocol;
-
-	/**
-	 * This field specifies the index with which this phy is associated (0-3).
-	 */
 	u8 phy_index;
-
-	/**
-	 * This member indicates if this particular PHY has received a BCN while
-	 * it had no port assignement.  This BCN will be reported once the phy is
-	 * assigned to a port.
-	 */
 	bool bcn_received_while_port_unassigned;
-
-	/**
-	 * This field indicates if this PHY is currently in the process of
-	 * link training (i.e. it has started OOB, but has yet to perform
-	 * IAF exchange/Signature FIS reception).
-	 */
 	bool is_in_link_training;
-
-	/**
-	 * Timer to detect when a signature FIS timeout has occurred. The
-	 * signature FIS is the first FIS sent by an attached SATA device
-	 * after OOB/SN.
-	 */
-	struct sci_timer	sata_timer;
-
-	/**
-	 * This field is the pointer to the transport layer register for the SCU
-	 * hardware.
-	 */
+	struct sci_timer sata_timer;
 	struct scu_transport_layer_registers __iomem *transport_layer_registers;
-
-	/**
-	 * This field points to the link layer register set within the SCU.
-	 */
 	struct scu_link_layer_registers __iomem *link_layer_registers;
-
-};
-
-
-struct isci_phy {
-	struct scic_sds_phy sci;
 	struct asd_sas_phy sas_phy;
 	struct isci_port *isci_port;
 	u8 sas_addr[SAS_ADDR_SIZE];
-
 	union {
 		struct sas_identify_frame iaf;
 		struct dev_to_host_fis fis;
 	} frame_rcvd;
 };
 
-static inline struct isci_phy *to_isci_phy(struct asd_sas_phy *sas_phy)
+static inline struct isci_phy *to_iphy(struct asd_sas_phy *sas_phy)
 {
 	struct isci_phy *iphy = container_of(sas_phy, typeof(*iphy), sas_phy);
 
 	return iphy;
 }
 
-static inline struct isci_phy *sci_phy_to_iphy(struct scic_sds_phy *sci_phy)
-{
-	struct isci_phy *iphy = container_of(sci_phy, typeof(*iphy), sci);
-
-	return iphy;
-}
-
 struct scic_phy_cap {
 	union {
 		struct {
@@ -520,61 +458,61 @@ enum scic_sds_phy_states {
 	(scic_sds_port_get_controller((phy)->owning_port))
 
 void scic_sds_phy_construct(
-	struct scic_sds_phy *this_phy,
+	struct isci_phy *iphy,
 	struct scic_sds_port *owning_port,
 	u8 phy_index);
 
-struct scic_sds_port *phy_get_non_dummy_port(struct scic_sds_phy *sci_phy);
+struct scic_sds_port *phy_get_non_dummy_port(struct isci_phy *iphy);
 
 void scic_sds_phy_set_port(
-	struct scic_sds_phy *this_phy,
+	struct isci_phy *iphy,
 	struct scic_sds_port *owning_port);
 
 enum sci_status scic_sds_phy_initialize(
-	struct scic_sds_phy *this_phy,
+	struct isci_phy *iphy,
 	struct scu_transport_layer_registers __iomem *transport_layer_registers,
 	struct scu_link_layer_registers __iomem *link_layer_registers);
 
 enum sci_status scic_sds_phy_start(
-	struct scic_sds_phy *this_phy);
+	struct isci_phy *iphy);
 
 enum sci_status scic_sds_phy_stop(
-	struct scic_sds_phy *this_phy);
+	struct isci_phy *iphy);
 
 enum sci_status scic_sds_phy_reset(
-	struct scic_sds_phy *this_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_phy_resume(
-	struct scic_sds_phy *this_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_phy_setup_transport(
-	struct scic_sds_phy *this_phy,
+	struct isci_phy *iphy,
 	u32 device_id);
 
 enum sci_status scic_sds_phy_event_handler(
-	struct scic_sds_phy *this_phy,
+	struct isci_phy *iphy,
 	u32 event_code);
 
 enum sci_status scic_sds_phy_frame_handler(
-	struct scic_sds_phy *this_phy,
+	struct isci_phy *iphy,
 	u32 frame_index);
 
 enum sci_status scic_sds_phy_consume_power_handler(
-	struct scic_sds_phy *this_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_phy_get_sas_address(
-	struct scic_sds_phy *this_phy,
+	struct isci_phy *iphy,
 	struct sci_sas_address *sas_address);
 
 void scic_sds_phy_get_attached_sas_address(
-	struct scic_sds_phy *this_phy,
+	struct isci_phy *iphy,
 	struct sci_sas_address *sas_address);
 
 struct scic_phy_proto;
 void scic_sds_phy_get_protocols(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	struct scic_phy_proto *protocols);
-enum sas_linkrate sci_phy_linkrate(struct scic_sds_phy *sci_phy);
+enum sas_linkrate sci_phy_linkrate(struct isci_phy *iphy);
 
 struct isci_host;
 void isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index);
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index bd09154..d53c0b1 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -154,17 +154,17 @@ static enum sci_status scic_port_get_properties(struct scic_sds_port *port,
 
 static void scic_port_bcn_enable(struct scic_sds_port *sci_port)
 {
-	struct scic_sds_phy *sci_phy;
+	struct isci_phy *iphy;
 	u32 val;
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(sci_port->phy_table); i++) {
-		sci_phy = sci_port->phy_table[i];
-		if (!sci_phy)
+		iphy = sci_port->phy_table[i];
+		if (!iphy)
 			continue;
-		val = readl(&sci_phy->link_layer_registers->link_layer_control);
+		val = readl(&iphy->link_layer_registers->link_layer_control);
 		/* clear the bit by writing 1. */
-		writel(val, &sci_phy->link_layer_registers->link_layer_control);
+		writel(val, &iphy->link_layer_registers->link_layer_control);
 	}
 }
 
@@ -180,10 +180,9 @@ void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
 		return;
 
 	for (i = 0; i < ARRAY_SIZE(iport->sci.phy_table); i++) {
-		struct scic_sds_phy *sci_phy = iport->sci.phy_table[i];
-		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+		struct isci_phy *iphy = iport->sci.phy_table[i];
 
-		if (!sci_phy)
+		if (!iphy)
 			continue;
 
 		ihost->sas_ha.notify_port_event(&iphy->sas_phy,
@@ -194,9 +193,8 @@ void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
 
 void isci_port_bc_change_received(struct isci_host *ihost,
 				  struct scic_sds_port *sci_port,
-				  struct scic_sds_phy *sci_phy)
+				  struct isci_phy *iphy)
 {
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 	struct isci_port *iport = iphy->isci_port;
 
 	if (iport && test_bit(IPORT_BCN_BLOCKED, &iport->flags)) {
@@ -219,33 +217,32 @@ void isci_port_bc_change_received(struct isci_host *ihost,
 
 static void isci_port_link_up(struct isci_host *isci_host,
 			      struct scic_sds_port *port,
-			      struct scic_sds_phy *phy)
+			      struct isci_phy *iphy)
 {
 	unsigned long flags;
 	struct scic_port_properties properties;
-	struct isci_phy *isci_phy = sci_phy_to_iphy(phy);
 	struct isci_port *isci_port = sci_port_to_iport(port);
 	unsigned long success = true;
 
-	BUG_ON(isci_phy->isci_port != NULL);
+	BUG_ON(iphy->isci_port != NULL);
 
-	isci_phy->isci_port = isci_port;
+	iphy->isci_port = isci_port;
 
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n",
 		__func__, isci_port);
 
-	spin_lock_irqsave(&isci_phy->sas_phy.frame_rcvd_lock, flags);
+	spin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);
 
-	isci_port_change_state(isci_phy->isci_port, isci_starting);
+	isci_port_change_state(iphy->isci_port, isci_starting);
 
 	scic_port_get_properties(port, &properties);
 
-	if (phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
+	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
 		u64 attached_sas_address;
 
-		isci_phy->sas_phy.oob_mode = SATA_OOB_MODE;
-		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct dev_to_host_fis);
+		iphy->sas_phy.oob_mode = SATA_OOB_MODE;
+		iphy->sas_phy.frame_rcvd_size = sizeof(struct dev_to_host_fis);
 
 		/*
 		 * For direct-attached SATA devices, the SCI core will
@@ -259,28 +256,28 @@ static void isci_port_link_up(struct isci_host *isci_host,
 		attached_sas_address |= properties.remote.sas_address.low;
 		swab64s(&attached_sas_address);
 
-		memcpy(&isci_phy->sas_phy.attached_sas_addr,
+		memcpy(&iphy->sas_phy.attached_sas_addr,
 		       &attached_sas_address, sizeof(attached_sas_address));
-	} else if (phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
-		isci_phy->sas_phy.oob_mode = SAS_OOB_MODE;
-		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct sas_identify_frame);
+	} else if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+		iphy->sas_phy.oob_mode = SAS_OOB_MODE;
+		iphy->sas_phy.frame_rcvd_size = sizeof(struct sas_identify_frame);
 
 		/* Copy the attached SAS address from the IAF */
-		memcpy(isci_phy->sas_phy.attached_sas_addr,
-		       isci_phy->frame_rcvd.iaf.sas_addr, SAS_ADDR_SIZE);
+		memcpy(iphy->sas_phy.attached_sas_addr,
+		       iphy->frame_rcvd.iaf.sas_addr, SAS_ADDR_SIZE);
 	} else {
 		dev_err(&isci_host->pdev->dev, "%s: unkown target\n", __func__);
 		success = false;
 	}
 
-	isci_phy->sas_phy.phy->negotiated_linkrate = sci_phy_linkrate(phy);
+	iphy->sas_phy.phy->negotiated_linkrate = sci_phy_linkrate(iphy);
 
-	spin_unlock_irqrestore(&isci_phy->sas_phy.frame_rcvd_lock, flags);
+	spin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);
 
 	/* Notify libsas that we have an address frame, if indeed
 	 * we've found an SSP, SMP, or STP target */
 	if (success)
-		isci_host->sas_ha.notify_port_event(&isci_phy->sas_phy,
+		isci_host->sas_ha.notify_port_event(&iphy->sas_phy,
 						    PORTE_BYTES_DMAED);
 }
 
@@ -495,11 +492,7 @@ static bool scic_sds_port_is_phy_mask_valid(
 	return false;
 }
 
-/**
- *
- * @sci_port: This parameter specifies the port from which to return a
- *    connected phy.
- *
+/*
  * This method retrieves a currently active (i.e. connected) phy contained in
  * the port.  Currently, the lowest order phy that is connected is returned.
  * This method returns a pointer to a SCIS_SDS_PHY object. NULL This value is
@@ -507,58 +500,38 @@ static bool scic_sds_port_is_phy_mask_valid(
  * point) phys contained in the port. All other values specify a struct scic_sds_phy
  * object that is active in the port.
  */
-static struct scic_sds_phy *scic_sds_port_get_a_connected_phy(
-	struct scic_sds_port *sci_port
-	) {
+static struct isci_phy *scic_sds_port_get_a_connected_phy(struct scic_sds_port *sci_port)
+{
 	u32 index;
-	struct scic_sds_phy *phy;
+	struct isci_phy *iphy;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		/*
-		 * Ensure that the phy is both part of the port and currently
-		 * connected to the remote end-point. */
-		phy = sci_port->phy_table[index];
-		if (
-			(phy != NULL)
-			&& scic_sds_port_active_phy(sci_port, phy)
-			) {
-			return phy;
-		}
+		/* Ensure that the phy is both part of the port and currently
+		 * connected to the remote end-point.
+		 */
+		iphy = sci_port->phy_table[index];
+		if (iphy && scic_sds_port_active_phy(sci_port, iphy))
+			return iphy;
 	}
 
 	return NULL;
 }
 
-/**
- * scic_sds_port_set_phy() -
- * @out]: port The port object to which the phy assignement is being made.
- * @out]: phy The phy which is being assigned to the port.
- *
- * This method attempts to make the assignment of the phy to the port. If
- * successful the phy is assigned to the ports phy table. bool true if the phy
- * assignment can be made. false if the phy assignement can not be made. This
- * is a functional test that only fails if the phy is currently assigned to a
- * different port.
- */
-static enum sci_status scic_sds_port_set_phy(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+static enum sci_status scic_sds_port_set_phy(struct scic_sds_port *port, struct isci_phy *iphy)
 {
-	/*
-	 * Check to see if we can add this phy to a port
+	/* Check to see if we can add this phy to a port
 	 * that means that the phy is not part of a port and that the port does
-	 * not already have a phy assinged to the phy index. */
-	if (
-		(port->phy_table[phy->phy_index] == NULL)
-		&& (phy_get_non_dummy_port(phy) == NULL)
-		&& scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)
-		) {
-		/*
-		 * Phy is being added in the stopped state so we are in MPC mode
-		 * make logical port index = physical port index */
+	 * not already have a phy assinged to the phy index.
+	 */
+	if (!port->phy_table[iphy->phy_index] &&
+	    !phy_get_non_dummy_port(iphy) &&
+	    scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index)) {
+		/* Phy is being added in the stopped state so we are in MPC mode
+		 * make logical port index = physical port index
+		 */
 		port->logical_port_index = port->physical_port_index;
-		port->phy_table[phy->phy_index] = phy;
-		scic_sds_phy_set_port(phy, port);
+		port->phy_table[iphy->phy_index] = iphy;
+		scic_sds_phy_set_port(iphy, port);
 
 		return SCI_SUCCESS;
 	}
@@ -566,28 +539,18 @@ static enum sci_status scic_sds_port_set_phy(
 	return SCI_FAILURE;
 }
 
-/**
- * scic_sds_port_clear_phy() -
- * @out]: port The port from which the phy is being cleared.
- * @out]: phy The phy being cleared from the port.
- *
- * This method will clear the phy assigned to this port.  This method fails if
- * this phy is not currently assinged to this port. bool true if the phy is
- * removed from the port. false if this phy is not assined to this port.
- */
-static enum sci_status scic_sds_port_clear_phy(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+static enum sci_status scic_sds_port_clear_phy(struct scic_sds_port *port,
+					       struct isci_phy *iphy)
 {
 	/* Make sure that this phy is part of this port */
-	if (port->phy_table[phy->phy_index] == phy &&
-	    phy_get_non_dummy_port(phy) == port) {
+	if (port->phy_table[iphy->phy_index] == iphy &&
+	    phy_get_non_dummy_port(iphy) == port) {
 		struct scic_sds_controller *scic = port->owning_controller;
 		struct isci_host *ihost = scic_to_ihost(scic);
 
 		/* Yep it is assigned to this port so remove it */
-		scic_sds_phy_set_port(phy, &ihost->ports[SCI_MAX_PORTS].sci);
-		port->phy_table[phy->phy_index] = NULL;
+		scic_sds_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS].sci);
+		port->phy_table[iphy->phy_index] = NULL;
 		return SCI_SUCCESS;
 	}
 
@@ -634,20 +597,20 @@ void scic_sds_port_get_attached_sas_address(
 	struct scic_sds_port *sci_port,
 	struct sci_sas_address *sas_address)
 {
-	struct scic_sds_phy *sci_phy;
+	struct isci_phy *iphy;
 
 	/*
 	 * Ensure that the phy is both part of the port and currently
 	 * connected to the remote end-point.
 	 */
-	sci_phy = scic_sds_port_get_a_connected_phy(sci_port);
-	if (sci_phy) {
-		if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
-			scic_sds_phy_get_attached_sas_address(sci_phy,
+	iphy = scic_sds_port_get_a_connected_phy(sci_port);
+	if (iphy) {
+		if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
+			scic_sds_phy_get_attached_sas_address(iphy,
 							      sas_address);
 		} else {
-			scic_sds_phy_get_sas_address(sci_phy, sas_address);
-			sas_address->low += sci_phy->phy_index;
+			scic_sds_phy_get_sas_address(iphy, sas_address);
+			sas_address->low += iphy->phy_index;
 		}
 	} else {
 		sas_address->high = 0;
@@ -787,39 +750,38 @@ void scic_sds_port_setup_transports(
  * notifying the user that the link is up. none
  */
 static void scic_sds_port_activate_phy(struct scic_sds_port *sci_port,
-				       struct scic_sds_phy *sci_phy,
+				       struct isci_phy *iphy,
 				       bool do_notify_user)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 
-	if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
-		scic_sds_phy_resume(sci_phy);
+	if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
+		scic_sds_phy_resume(iphy);
 
-	sci_port->active_phy_mask |= 1 << sci_phy->phy_index;
+	sci_port->active_phy_mask |= 1 << iphy->phy_index;
 
-	scic_sds_controller_clear_invalid_phy(scic, sci_phy);
+	scic_sds_controller_clear_invalid_phy(scic, iphy);
 
 	if (do_notify_user == true)
-		isci_port_link_up(ihost, sci_port, sci_phy);
+		isci_port_link_up(ihost, sci_port, iphy);
 }
 
 void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
-				  struct scic_sds_phy *sci_phy,
+				  struct isci_phy *iphy,
 				  bool do_notify_user)
 {
 	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
-	sci_port->active_phy_mask &= ~(1 << sci_phy->phy_index);
+	sci_port->active_phy_mask &= ~(1 << iphy->phy_index);
 
-	sci_phy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
+	iphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
 
 	/* Re-assign the phy back to the LP as if it were a narrow port */
-	writel(sci_phy->phy_index,
-		&sci_port->port_pe_configuration_register[sci_phy->phy_index]);
+	writel(iphy->phy_index,
+		&sci_port->port_pe_configuration_register[iphy->phy_index]);
 
 	if (do_notify_user == true)
 		isci_port_link_down(ihost, iphy, iport);
@@ -834,7 +796,7 @@ void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
  * this port object. None
  */
 static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
-					  struct scic_sds_phy *sci_phy)
+					  struct isci_phy *iphy)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 
@@ -843,8 +805,8 @@ static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
 	 * not go ahead and tell the SCI_USER that we have discovered an
 	 * invalid link.
 	 */
-	if ((scic->invalid_phy_mask & (1 << sci_phy->phy_index)) == 0) {
-		scic_sds_controller_set_invalid_phy(scic, sci_phy);
+	if ((scic->invalid_phy_mask & (1 << iphy->phy_index)) == 0) {
+		scic_sds_controller_set_invalid_phy(scic, iphy);
 		dev_warn(&scic_to_ihost(scic)->pdev->dev, "Invalid link up!\n");
 	}
 }
@@ -879,7 +841,7 @@ static void port_state_machine_change(struct scic_sds_port *sci_port,
 /**
  * scic_sds_port_general_link_up_handler - phy can be assigned to port?
  * @sci_port: scic_sds_port object for which has a phy that has gone link up.
- * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
+ * @sci_phy: This is the struct isci_phy object that has gone link up.
  * @do_notify_user: This parameter specifies whether to inform the user (via
  *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
  *
@@ -890,14 +852,14 @@ static void port_state_machine_change(struct scic_sds_port *sci_port,
  * the same port. none
  */
 static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port,
-						  struct scic_sds_phy *sci_phy,
+						  struct isci_phy *iphy,
 						  bool do_notify_user)
 {
 	struct sci_sas_address port_sas_address;
 	struct sci_sas_address phy_sas_address;
 
 	scic_sds_port_get_attached_sas_address(sci_port, &port_sas_address);
-	scic_sds_phy_get_attached_sas_address(sci_phy, &phy_sas_address);
+	scic_sds_phy_get_attached_sas_address(iphy, &phy_sas_address);
 
 	/* If the SAS address of the new phy matches the SAS address of
 	 * other phys in the port OR this is the first phy in the port,
@@ -909,11 +871,11 @@ static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port
 	    sci_port->active_phy_mask == 0) {
 		struct sci_base_state_machine *sm = &sci_port->sm;
 
-		scic_sds_port_activate_phy(sci_port, sci_phy, do_notify_user);
+		scic_sds_port_activate_phy(sci_port, iphy, do_notify_user);
 		if (sm->current_state_id == SCI_PORT_RESETTING)
 			port_state_machine_change(sci_port, SCI_PORT_READY);
 	} else
-		scic_sds_port_invalid_link_up(sci_port, sci_phy);
+		scic_sds_port_invalid_link_up(sci_port, iphy);
 }
 
 
@@ -957,12 +919,12 @@ static bool scic_sds_port_is_wide(struct scic_sds_port *sci_port)
  */
 bool scic_sds_port_link_detected(
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	if ((sci_port->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
-	    (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
+	    (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
 	    scic_sds_port_is_wide(sci_port)) {
-		scic_sds_port_invalid_link_up(sci_port, sci_phy);
+		scic_sds_port_invalid_link_up(sci_port, iphy);
 
 		return false;
 	}
@@ -1045,47 +1007,26 @@ static void scic_sds_port_update_viit_entry(struct scic_sds_port *sci_port)
 	       &sci_port->viit_registers->status);
 }
 
-/**
- * This method returns the maximum allowed speed for data transfers on this
- *    port.  This maximum allowed speed evaluates to the maximum speed of the
- *    slowest phy in the port.
- * @sci_port: This parameter specifies the port for which to retrieve the
- *    maximum allowed speed.
- *
- * This method returns the maximum negotiated speed of the slowest phy in the
- * port.
- */
-enum sas_linkrate scic_sds_port_get_max_allowed_speed(
-	struct scic_sds_port *sci_port)
+enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct scic_sds_port *sci_port)
 {
 	u16 index;
+	struct isci_phy *iphy;
 	enum sas_linkrate max_allowed_speed = SAS_LINK_RATE_6_0_GBPS;
-	struct scic_sds_phy *phy = NULL;
 
 	/*
 	 * Loop through all of the phys in this port and find the phy with the
 	 * lowest maximum link rate. */
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		phy = sci_port->phy_table[index];
-		if (
-			(phy != NULL)
-			&& (scic_sds_port_active_phy(sci_port, phy) == true)
-			&& (phy->max_negotiated_speed < max_allowed_speed)
-			)
-			max_allowed_speed = phy->max_negotiated_speed;
+		iphy = sci_port->phy_table[index];
+		if (iphy && scic_sds_port_active_phy(sci_port, iphy) &&
+		    iphy->max_negotiated_speed < max_allowed_speed)
+			max_allowed_speed = iphy->max_negotiated_speed;
 	}
 
 	return max_allowed_speed;
 }
 
-/**
- *
- * @sci_port: This is the struct scic_sds_port object to suspend.
- *
- * This method will susped the port task scheduler for this port object. none
- */
-static void
-scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port)
+static void scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port)
 {
 	u32 pts_control_value;
 
@@ -1377,7 +1318,7 @@ enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port)
 static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32 timeout)
 {
 	enum sci_status status = SCI_FAILURE_INVALID_PHY;
-	struct scic_sds_phy *selected_phy = NULL;
+	struct isci_phy *iphy = NULL;
 	enum scic_sds_port_states state;
 	u32 phy_index;
 
@@ -1389,22 +1330,21 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
 	}
 
 	/* Select a phy on which we can send the hard reset request. */
-	for (phy_index = 0; phy_index < SCI_MAX_PHYS && !selected_phy; phy_index++) {
-		selected_phy = sci_port->phy_table[phy_index];
-		if (selected_phy &&
-		    !scic_sds_port_active_phy(sci_port, selected_phy)) {
+	for (phy_index = 0; phy_index < SCI_MAX_PHYS && !iphy; phy_index++) {
+		iphy = sci_port->phy_table[phy_index];
+		if (iphy && !scic_sds_port_active_phy(sci_port, iphy)) {
 			/*
 			 * We found a phy but it is not ready select
 			 * different phy
 			 */
-			selected_phy = NULL;
+			iphy = NULL;
 		}
 	}
 
 	/* If we have a phy then go ahead and start the reset procedure */
-	if (!selected_phy)
+	if (!iphy)
 		return status;
-	status = scic_sds_phy_reset(selected_phy);
+	status = scic_sds_phy_reset(iphy);
 
 	if (status != SCI_SUCCESS)
 		return status;
@@ -1412,8 +1352,7 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
 	sci_mod_timer(&sci_port->timer, timeout);
 	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
 
-	port_state_machine_change(sci_port,
-				  SCI_PORT_RESETTING);
+	port_state_machine_change(sci_port, SCI_PORT_RESETTING);
 	return SCI_SUCCESS;
 }
 
@@ -1427,7 +1366,7 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
  * status is a failure to add the phy to the port.
  */
 enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
-				      struct scic_sds_phy *sci_phy)
+				      struct isci_phy *iphy)
 {
 	enum sci_status status;
 	enum scic_sds_port_states state;
@@ -1446,32 +1385,32 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
 			/* Make sure that the PHY SAS Address matches the SAS Address
 			 * for this port
 			 */
-			scic_sds_phy_get_sas_address(sci_phy, &phy_sas_address);
+			scic_sds_phy_get_sas_address(iphy, &phy_sas_address);
 
 			if (port_sas_address.high != phy_sas_address.high ||
 			    port_sas_address.low  != phy_sas_address.low)
 				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
 		}
-		return scic_sds_port_set_phy(sci_port, sci_phy);
+		return scic_sds_port_set_phy(sci_port, iphy);
 	}
 	case SCI_PORT_SUB_WAITING:
 	case SCI_PORT_SUB_OPERATIONAL:
-		status = scic_sds_port_set_phy(sci_port, sci_phy);
+		status = scic_sds_port_set_phy(sci_port, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
 
-		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
 		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
 		port_state_machine_change(sci_port, SCI_PORT_SUB_CONFIGURING);
 
 		return status;
 	case SCI_PORT_SUB_CONFIGURING:
-		status = scic_sds_port_set_phy(sci_port, sci_phy);
+		status = scic_sds_port_set_phy(sci_port, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
-		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port.
@@ -1496,7 +1435,7 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
  * other status is a failure to add the phy to the port.
  */
 enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
-					 struct scic_sds_phy *sci_phy)
+					 struct isci_phy *iphy)
 {
 	enum sci_status status;
 	enum scic_sds_port_states state;
@@ -1505,23 +1444,23 @@ enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
 
 	switch (state) {
 	case SCI_PORT_STOPPED:
-		return scic_sds_port_clear_phy(sci_port, sci_phy);
+		return scic_sds_port_clear_phy(sci_port, iphy);
 	case SCI_PORT_SUB_OPERATIONAL:
-		status = scic_sds_port_clear_phy(sci_port, sci_phy);
+		status = scic_sds_port_clear_phy(sci_port, iphy);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+		scic_sds_port_deactivate_phy(sci_port, iphy, true);
 		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
 		port_state_machine_change(sci_port,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_CONFIGURING:
-		status = scic_sds_port_clear_phy(sci_port, sci_phy);
+		status = scic_sds_port_clear_phy(sci_port, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
-		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+		scic_sds_port_deactivate_phy(sci_port, iphy, true);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port
@@ -1537,7 +1476,7 @@ enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
 }
 
 enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
-				      struct scic_sds_phy *sci_phy)
+				      struct isci_phy *iphy)
 {
 	enum scic_sds_port_states state;
 
@@ -1547,13 +1486,13 @@ enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
 		/* Since this is the first phy going link up for the port we
 		 * can just enable it and continue
 		 */
-		scic_sds_port_activate_phy(sci_port, sci_phy, true);
+		scic_sds_port_activate_phy(sci_port, iphy, true);
 
 		port_state_machine_change(sci_port,
 					  SCI_PORT_SUB_OPERATIONAL);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
 		return SCI_SUCCESS;
 	case SCI_PORT_RESETTING:
 		/* TODO We should  make  sure  that  the phy  that  has gone
@@ -1570,7 +1509,7 @@ enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications.
 		 */
-		scic_sds_port_general_link_up_handler(sci_port, sci_phy, false);
+		scic_sds_port_general_link_up_handler(sci_port, iphy, false);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(sci_port),
@@ -1580,14 +1519,14 @@ enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
 }
 
 enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
-					struct scic_sds_phy *sci_phy)
+					struct isci_phy *iphy)
 {
 	enum scic_sds_port_states state;
 
 	state = sci_port->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+		scic_sds_port_deactivate_phy(sci_port, iphy, true);
 
 		/* If there are no active phys left in the port, then
 		 * transition the port to the WAITING state until such time
@@ -1600,7 +1539,7 @@ enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
 	case SCI_PORT_RESETTING:
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications. */
-		scic_sds_port_deactivate_phy(sci_port, sci_phy, false);
+		scic_sds_port_deactivate_phy(sci_port, iphy, false);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(sci_port),
@@ -1879,13 +1818,13 @@ enum isci_status isci_port_get_state(
 
 void scic_sds_port_broadcast_change_received(
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 
 	/* notify the user. */
-	isci_port_bc_change_received(ihost, sci_port, sci_phy);
+	isci_port_bc_change_received(ihost, sci_port, iphy);
 }
 
 int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,
diff --git a/drivers/scsi/isci/port.h b/drivers/scsi/isci/port.h
index 668f3a1..b6ce56a 100644
--- a/drivers/scsi/isci/port.h
+++ b/drivers/scsi/isci/port.h
@@ -131,7 +131,7 @@ struct scic_sds_port {
 	/**
 	 * This field is the table of phys assigned to the port.
 	 */
-	struct scic_sds_phy *phy_table[SCI_MAX_PHYS];
+	struct isci_phy *phy_table[SCI_MAX_PHYS];
 
 	/**
 	 * This field is a pointer back to the controller that owns this
@@ -328,11 +328,11 @@ enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port);
 
 enum sci_status scic_sds_port_add_phy(
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 enum sci_status scic_sds_port_remove_phy(
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_port_setup_transports(
 	struct scic_sds_port *sci_port,
@@ -342,17 +342,17 @@ void isci_port_bcn_enable(struct isci_host *, struct isci_port *);
 
 void scic_sds_port_deactivate_phy(
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	bool do_notify_user);
 
 bool scic_sds_port_link_detected(
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
-				      struct scic_sds_phy *sci_phy);
+				      struct isci_phy *iphy);
 enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
-					struct scic_sds_phy *sci_phy);
+					struct isci_phy *iphy);
 
 struct isci_request;
 struct scic_sds_remote_device;
@@ -371,7 +371,7 @@ enum sas_linkrate scic_sds_port_get_max_allowed_speed(
 
 void scic_sds_port_broadcast_change_received(
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 bool scic_sds_port_is_valid_phy_assignment(
 	struct scic_sds_port *sci_port,
diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index fcb8f03..8444fd8 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -114,7 +114,7 @@ static s32 sci_sas_address_compare(
  */
 static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
 	struct scic_sds_controller *scic,
-	struct scic_sds_phy *phy)
+	struct isci_phy *iphy)
 {
 	u8 i;
 	struct sci_sas_address port_sas_address;
@@ -127,8 +127,8 @@ static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
 	 * more phys match the sent and received SAS address as this phy in which
 	 * case it should participate in the same port.
 	 */
-	scic_sds_phy_get_sas_address(phy, &phy_sas_address);
-	scic_sds_phy_get_attached_sas_address(phy, &phy_attached_device_address);
+	scic_sds_phy_get_sas_address(iphy, &phy_sas_address);
+	scic_sds_phy_get_attached_sas_address(iphy, &phy_attached_device_address);
 
 	for (i = 0; i < scic->logical_port_entries; i++) {
 		struct isci_host *ihost = scic_to_ihost(scic);
@@ -196,8 +196,8 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
 	 * PE0 and PE3 can never have the same SAS Address unless they
 	 * are part of the same x4 wide port and we have already checked
 	 * for this condition. */
-	scic_sds_phy_get_sas_address(&ihost->phys[0].sci, &first_address);
-	scic_sds_phy_get_sas_address(&ihost->phys[3].sci, &second_address);
+	scic_sds_phy_get_sas_address(&ihost->phys[0], &first_address);
+	scic_sds_phy_get_sas_address(&ihost->phys[3], &second_address);
 
 	if (sci_sas_address_compare(first_address, second_address) == 0) {
 		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
@@ -209,8 +209,8 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
 	 * part of the same port. */
 	if (port_agent->phy_valid_port_range[0].min_index == 0 &&
 	    port_agent->phy_valid_port_range[1].min_index == 1) {
-		scic_sds_phy_get_sas_address(&ihost->phys[0].sci, &first_address);
-		scic_sds_phy_get_sas_address(&ihost->phys[2].sci, &second_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[0], &first_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[2], &second_address);
 
 		if (sci_sas_address_compare(first_address, second_address) == 0) {
 			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
@@ -223,8 +223,8 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
 	 * part of the same port. */
 	if (port_agent->phy_valid_port_range[2].min_index == 2 &&
 	    port_agent->phy_valid_port_range[3].min_index == 3) {
-		scic_sds_phy_get_sas_address(&ihost->phys[1].sci, &first_address);
-		scic_sds_phy_get_sas_address(&ihost->phys[3].sci, &second_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[1], &first_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[3], &second_address);
 
 		if (sci_sas_address_compare(first_address, second_address) == 0) {
 			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
@@ -277,7 +277,7 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 		for (phy_index = 0; phy_index < SCI_MAX_PHYS; phy_index++) {
 			if ((phy_mask & (1 << phy_index)) == 0)
 				continue;
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
 						     &sas_address);
 
 			/*
@@ -302,7 +302,7 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 		while (phy_index < SCI_MAX_PHYS) {
 			if ((phy_mask & (1 << phy_index)) == 0)
 				continue;
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
 						     &phy_assigned_address);
 
 			if (sci_sas_address_compare(sas_address, phy_assigned_address) != 0) {
@@ -316,7 +316,7 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
 
 			scic_sds_port_add_phy(&ihost->ports[port_index].sci,
-					      &ihost->phys[phy_index].sci);
+					      &ihost->phys[phy_index]);
 
 			assigned_phy_mask |= (1 << phy_index);
 		}
@@ -352,12 +352,12 @@ static void mpc_agent_timeout(unsigned long data)
 	configure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		struct scic_sds_phy *sci_phy = &ihost->phys[index].sci;
+		struct isci_phy *iphy = &ihost->phys[index];
 
 		if (configure_phy_mask & (1 << index)) {
 			port_agent->link_up_handler(scic, port_agent,
-						    phy_get_non_dummy_port(sci_phy),
-						    sci_phy);
+						    phy_get_non_dummy_port(iphy),
+						    iphy);
 		}
 	}
 
@@ -365,37 +365,22 @@ done:
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
-/**
- *
- * @controller: This is the controller object that receives the link up
- *    notification.
- * @port: This is the port object associated with the phy.  If the is no
- *    associated port this is an NULL.
- * @phy: This is the phy object which has gone ready.
- *
- * This method handles the manual port configuration link up notifications.
- * Since all ports and phys are associate at initialization time we just turn
- * around and notifiy the port object that there is a link up.  If this PHY is
- * not associated with a port there is no action taken. Is it possible to get a
- * link up notification from a phy that has no assocoated port?
- */
-static void scic_sds_mpc_agent_link_up(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+static void scic_sds_mpc_agent_link_up(struct scic_sds_controller *controller,
+				       struct scic_sds_port_configuration_agent *port_agent,
+				       struct scic_sds_port *port,
+				       struct isci_phy *iphy)
 {
-	/*
-	 * If the port has an invalid handle then the phy was not assigned to
+	/* If the port has an invalid handle then the phy was not assigned to
 	 * a port.  This is because the phy was not given the same SAS Address
-	 * as the other PHYs in the port. */
+	 * as the other PHYs in the port.
+	 */
 	if (port != NULL) {
-		port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(phy));
+		port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(iphy));
 
-		scic_sds_port_link_up(port, phy);
+		scic_sds_port_link_up(port, iphy);
 
-		if ((port->active_phy_mask & (1 << scic_sds_phy_get_index(phy))) != 0) {
-			port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(phy));
+		if ((port->active_phy_mask & (1 << scic_sds_phy_get_index(iphy))) != 0) {
+			port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(iphy));
 		}
 	}
 }
@@ -421,7 +406,7 @@ static void scic_sds_mpc_agent_link_down(
 	struct scic_sds_controller *scic,
 	struct scic_sds_port_configuration_agent *port_agent,
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	if (sci_port != NULL) {
 		/*
@@ -432,9 +417,9 @@ static void scic_sds_mpc_agent_link_down(
 		 * state.
 		 */
 		port_agent->phy_ready_mask &=
-			~(1 << scic_sds_phy_get_index(sci_phy));
+			~(1 << scic_sds_phy_get_index(iphy));
 		port_agent->phy_configured_mask &=
-			~(1 << scic_sds_phy_get_index(sci_phy));
+			~(1 << scic_sds_phy_get_index(iphy));
 
 		/*
 		 * Check to see if there are more phys waiting to be
@@ -451,7 +436,7 @@ static void scic_sds_mpc_agent_link_down(
 				      SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
 		}
 
-		scic_sds_port_link_down(sci_port, sci_phy);
+		scic_sds_port_link_down(sci_port, iphy);
 	}
 }
 
@@ -482,11 +467,11 @@ static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
 		port_index = phy_index;
 
 		/* Get the assigned SAS Address for the first PHY on the controller. */
-		scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+		scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
 					    &sas_address);
 
 		while (++phy_index < SCI_MAX_PHYS) {
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
 						     &phy_assigned_address);
 
 			/* Verify each of the SAS address are all the same for every PHY */
@@ -504,20 +489,10 @@ static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
 	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
 }
 
-/**
- *
- * @controller: This is the controller object that receives the link up
- *    notification.
- * @phy: This is the phy object which has gone link up.
- *
- * This method handles the automatic port configuration for link up
- * notifications.
- */
-static void scic_sds_apc_agent_configure_ports(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_phy *phy,
-	bool start_timer)
+static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *controller,
+					       struct scic_sds_port_configuration_agent *port_agent,
+					       struct isci_phy *iphy,
+					       bool start_timer)
 {
 	u8 port_index;
 	enum sci_status status;
@@ -525,10 +500,10 @@ static void scic_sds_apc_agent_configure_ports(
 	enum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;
 	struct isci_host *ihost = scic_to_ihost(controller);
 
-	port = scic_sds_port_configuration_agent_find_port(controller, phy);
+	port = scic_sds_port_configuration_agent_find_port(controller, iphy);
 
 	if (port != NULL) {
-		if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index))
+		if (scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index))
 			apc_activity = SCIC_SDS_APC_ADD_PHY;
 		else
 			apc_activity = SCIC_SDS_APC_SKIP_PHY;
@@ -540,20 +515,20 @@ static void scic_sds_apc_agent_configure_ports(
 		 *
 		 * Note the break when we reach the condition of the port id == phy id */
 		for (
-			port_index = port_agent->phy_valid_port_range[phy->phy_index].min_index;
-			port_index <= port_agent->phy_valid_port_range[phy->phy_index].max_index;
+			port_index = port_agent->phy_valid_port_range[iphy->phy_index].min_index;
+			port_index <= port_agent->phy_valid_port_range[iphy->phy_index].max_index;
 			port_index++
 			) {
 
 			port = &ihost->ports[port_index].sci;
 
 			/* First we must make sure that this PHY can be added to this Port. */
-			if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)) {
+			if (scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index)) {
 				/*
 				 * Port contains a PHY with a greater PHY ID than the current
 				 * PHY that has gone link up.  This phy can not be part of any
 				 * port so skip it and move on. */
-				if (port->active_phy_mask > (1 << phy->phy_index)) {
+				if (port->active_phy_mask > (1 << iphy->phy_index)) {
 					apc_activity = SCIC_SDS_APC_SKIP_PHY;
 					break;
 				}
@@ -562,7 +537,7 @@ static void scic_sds_apc_agent_configure_ports(
 				 * We have reached the end of our Port list and have not found
 				 * any reason why we should not either add the PHY to the port
 				 * or wait for more phys to become active. */
-				if (port->physical_port_index == phy->phy_index) {
+				if (port->physical_port_index == iphy->phy_index) {
 					/*
 					 * The Port either has no active PHYs.
 					 * Consider that if the port had any active PHYs we would have
@@ -608,10 +583,10 @@ static void scic_sds_apc_agent_configure_ports(
 
 	switch (apc_activity) {
 	case SCIC_SDS_APC_ADD_PHY:
-		status = scic_sds_port_add_phy(port, phy);
+		status = scic_sds_port_add_phy(port, iphy);
 
 		if (status == SCI_SUCCESS) {
-			port_agent->phy_configured_mask |= (1 << phy->phy_index);
+			port_agent->phy_configured_mask |= (1 << iphy->phy_index);
 		}
 		break;
 
@@ -651,14 +626,14 @@ static void scic_sds_apc_agent_configure_ports(
 static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 				       struct scic_sds_port_configuration_agent *port_agent,
 				       struct scic_sds_port *sci_port,
-				       struct scic_sds_phy *sci_phy)
+				       struct isci_phy *iphy)
 {
-	u8 phy_index  = sci_phy->phy_index;
+	u8 phy_index  = iphy->phy_index;
 
 	if (!sci_port) {
 		/* the phy is not the part of this port */
 		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_apc_agent_configure_ports(scic, port_agent, sci_phy, true);
+		scic_sds_apc_agent_configure_ports(scic, port_agent, iphy, true);
 	} else {
 		/* the phy is already the part of the port */
 		u32 port_state = sci_port->sm.current_state_id;
@@ -669,7 +644,7 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 		 */
 		BUG_ON(port_state != SCI_PORT_RESETTING);
 		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_port_link_up(sci_port, sci_phy);
+		scic_sds_port_link_up(sci_port, iphy);
 	}
 }
 
@@ -690,18 +665,18 @@ static void scic_sds_apc_agent_link_down(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port_configuration_agent *port_agent,
 	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+	struct isci_phy *iphy)
 {
-	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(phy));
+	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(iphy));
 
 	if (port != NULL) {
-		if (port_agent->phy_configured_mask & (1 << phy->phy_index)) {
+		if (port_agent->phy_configured_mask & (1 << iphy->phy_index)) {
 			enum sci_status status;
 
-			status = scic_sds_port_remove_phy(port, phy);
+			status = scic_sds_port_remove_phy(port, iphy);
 
 			if (status == SCI_SUCCESS) {
-				port_agent->phy_configured_mask &= ~(1 << phy->phy_index);
+				port_agent->phy_configured_mask &= ~(1 << iphy->phy_index);
 			}
 		}
 	}
@@ -739,7 +714,7 @@ static void apc_agent_timeout(unsigned long data)
 			continue;
 
 		scic_sds_apc_agent_configure_ports(scic, port_agent,
-						   &ihost->phys[index].sci, false);
+						   &ihost->phys[index], false);
 	}
 
 done:
diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index c7cb0c5..a81a864 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1389,7 +1389,7 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 	sas_port = domain_dev->port;
 	sas_phy = list_first_entry(&sas_port->phy_list, struct asd_sas_phy,
 				   port_phy_el);
-	isci_phy = to_isci_phy(sas_phy);
+	isci_phy = to_iphy(sas_phy);
 	isci_port = isci_phy->isci_port;
 
 	/* we are being called for a device on this port,
-- 
1.6.0.2

