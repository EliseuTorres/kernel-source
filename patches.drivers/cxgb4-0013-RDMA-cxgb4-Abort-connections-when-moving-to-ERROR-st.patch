From: Vipul Pandya <vipul@chelsio.com>
Date: Mon, 7 Jan 2013 13:11:51 +0000
Subject: [PATCH 013/223] RDMA/cxgb4: Abort connections when moving to ERROR
 state
Patch-mainline: v3.9-rc1
Git-commit: 91e9c07195032bbde47489b8b423053cff5f413d
References: bsc#909577 FATE#317550

If a FINI operation fails, then we need to ABORT instead of CLOSE.
Also, if we ABORT due to unexpected STREAMING data, then wake up
anybody blocked in FINI...

Signed-off-by: Vipul Pandya <vipul@chelsio.com>
Signed-off-by: Roland Dreier <roland@purestorage.com>
Acked-by: David Chang <dchang@suse.com>
Signed-off-by: John Jolly <jjolly@suse.de>
---
 drivers/infiniband/hw/cxgb4/cm.c |    1 +
 drivers/infiniband/hw/cxgb4/qp.c |    1 +
 2 files changed, 2 insertions(+)

--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@ -1438,6 +1438,7 @@ static int abort_rpl(struct c4iw_dev *de
 	mutex_lock(&ep->com.mutex);
 	switch (ep->com.state) {
 	case ABORTING:
+		c4iw_wake_up(&ep->com.wr_wait, -ECONNRESET);
 		__state_set(&ep->com, DEAD);
 		release = 1;
 		break;
--- a/drivers/infiniband/hw/cxgb4/qp.c
+++ b/drivers/infiniband/hw/cxgb4/qp.c
@@ -1390,6 +1390,7 @@ err:
 	qhp->ep = NULL;
 	set_state(qhp, C4IW_QP_STATE_ERROR);
 	free = 1;
+	abort = 1;
 	wake_up(&qhp->wait);
 	BUG_ON(!ep);
 	flush_qp(qhp);
