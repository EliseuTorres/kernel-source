From 4e22766758cb8c971c971f3d335b974aaeb235fa Mon Sep 17 00:00:00 2001
From: Alexander Duyck <alexander.h.duyck@intel.com>
Date: Tue, 12 Feb 2013 02:31:01 +0000
Subject: [PATCH v5 039/164] igb: Use rx/tx_itr_setting when setting up initial value of
 itr

Git-commit: 4e22766758cb8c971c971f3d335b974aaeb235fa
Patch-mainline: v3.10-rc1
Reference: fate#317388, bsc#909491
Target: sle11-sp4

It turns out that the InterruptThrottleRate module parameter was only
having the effect of locking the ITR at the starting ITR value. This was
because the values stored in rx_itr_setting and tx_itr_setting were being
ignored when configuring the initial itr_val of the q_vector.

Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
Tested-by: Aaron Brown <aaron.f.brown@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>

---
 drivers/net/ethernet/intel/igb/igb_main.c |   11 +++++++++++
 1 file changed, 11 insertions(+)

Index: linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/igb_main.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/drivers/net/ethernet/intel/igb/igb_main.c
+++ linux-3.0-SLE11-SP4/drivers/net/ethernet/intel/igb/igb_main.c
@@ -1181,6 +1181,17 @@ static int igb_alloc_q_vector(struct igb
 	/* initialize pointer to rings */
 	ring = q_vector->ring;
 
+	/* intialize ITR */
+	if (rxr_count) {
+		/* rx or rx/tx vector */
+		if (!adapter->rx_itr_setting || adapter->rx_itr_setting > 3)
+			q_vector->itr_val = adapter->rx_itr_setting;
+	} else {
+		/* tx only vector */
+		if (!adapter->tx_itr_setting || adapter->tx_itr_setting > 3)
+			q_vector->itr_val = adapter->tx_itr_setting;
+	}
+
 	if (txr_count) {
 		/* assign generic ring traits */
 		ring->dev = &adapter->pdev->dev;
