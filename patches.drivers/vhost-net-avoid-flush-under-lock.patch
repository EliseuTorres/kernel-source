From: Michael S. Tsirkin <mst@redhat.com>
Subject: [PATCH] vhost-net: avoid flush under lock
References: FATE#311977
Git-commit: 1680e9063ea28099a1efa8ca11cee069cc7a9bc3
Patch-mainline: v2.6.35

We flush under vq mutex when changing backends.
This creates a deadlock as workqueue being flushed
needs this lock as well.

https://bugzilla.redhat.com/show_bug.cgi?id=612421

Drop the vq mutex before flush: we have the device mutex
which is sufficient to prevent another ioctl from touching
the vq.

Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 drivers/vhost/net.c |    5 +++++
 1 file changed, 5 insertions(+)

Index: b/drivers/vhost/net.c
===================================================================
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -530,11 +530,16 @@ static long vhost_net_set_backend(struct
 	rcu_assign_pointer(vq->private_data, sock);
 	vhost_net_enable_vq(n, vq);
 done:
+	mutex_unlock(&vq->mutex);
+
 	if (oldsock) {
 		vhost_net_flush_vq(n, index);
 		fput(oldsock->file);
 	}
 
+	mutex_unlock(&n->dev.mutex);
+	return 0;
+
 err_vq:
 	mutex_unlock(&vq->mutex);
 err:
