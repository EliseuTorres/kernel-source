From: Sathya Perla <sathya.perla@emulex.com>
Date: Tue, 2 Aug 2011 19:57:42 +0000
Subject: [PATCH] be2net: no need to query link status
References: bnc#722092
Patch-mainline: v3.0
Git-commit: ea172a011d1435d9bd167265bf51cc64d026b4e7

Change in the link status generates an MCC event. This is processed and
netif_carrier_on/off is called accordingly. Don't need to query/store the
link_status state.

Signed-off-by: Sathya Perla <sathya.perla@emulex.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: David Chang <dchang@suse.com>
---
 drivers/net/benet/be.h         |    2 +-
 drivers/net/benet/be_cmds.c    |   10 +++-------
 drivers/net/benet/be_cmds.h    |    7 ++++---
 drivers/net/benet/be_ethtool.c |    9 +++------
 drivers/net/benet/be_main.c    |   37 +++++++++++--------------------------
 5 files changed, 22 insertions(+), 43 deletions(-)

--- a/drivers/net/benet/be.h
+++ b/drivers/net/benet/be.h
@@ -522,7 +522,7 @@ static inline bool be_multi_rxq(const st
 
 extern void be_cq_notify(struct be_adapter *adapter, u16 qid, bool arm,
 		u16 num_popped);
-extern void be_link_status_update(struct be_adapter *adapter, bool link_up);
+extern void be_link_status_update(struct be_adapter *adapter, u32 link_status);
 extern void be_parse_stats(struct be_adapter *adapter);
 extern int be_load_fw(struct be_adapter *adapter, u8 *func);
 #endif				/* BE_H */
--- a/drivers/net/benet/be_cmds.c
+++ b/drivers/net/benet/be_cmds.c
@@ -110,8 +110,7 @@ done:
 static void be_async_link_state_process(struct be_adapter *adapter,
 		struct be_async_event_link_state *evt)
 {
-	be_link_status_update(adapter,
-		evt->port_link_status == ASYNC_EVENT_LINK_UP);
+	be_link_status_update(adapter, evt->port_link_status);
 }
 
 /* Grp5 CoS Priority evt */
@@ -1261,8 +1260,8 @@ err:
 }
 
 /* Uses synchronous mcc */
-int be_cmd_link_status_query(struct be_adapter *adapter,
-			bool *link_up, u8 *mac_speed, u16 *link_speed, u32 dom)
+int be_cmd_link_status_query(struct be_adapter *adapter, u8 *mac_speed,
+			u16 *link_speed, u32 dom)
 {
 	struct be_mcc_wrb *wrb;
 	struct be_cmd_req_link_status *req;
@@ -1277,8 +1276,6 @@ int be_cmd_link_status_query(struct be_a
 	}
 	req = embedded_payload(wrb);
 
-	*link_up = false;
-
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0,
 			OPCODE_COMMON_NTWK_LINK_STATUS_QUERY);
 
@@ -1289,7 +1286,6 @@ int be_cmd_link_status_query(struct be_a
 	if (!status) {
 		struct be_cmd_resp_link_status *resp = embedded_payload(wrb);
 		if (resp->mac_speed != PHY_LINK_SPEED_ZERO) {
-			*link_up = true;
 			*link_speed = le16_to_cpu(resp->link_speed);
 			*mac_speed = resp->mac_speed;
 		}
--- a/drivers/net/benet/be_cmds.h
+++ b/drivers/net/benet/be_cmds.h
@@ -89,9 +89,10 @@ struct be_async_event_trailer {
 };
 
 enum {
-	ASYNC_EVENT_LINK_DOWN 	= 0x0,
-	ASYNC_EVENT_LINK_UP 	= 0x1
+	LINK_DOWN	= 0x0,
+	LINK_UP		= 0x1
 };
+#define LINK_STATUS_MASK			0x1
 
 /* When the event code of an async trailer is link-state, the mcc_compl
  * must be interpreted as follows
@@ -1442,7 +1443,7 @@ extern int be_cmd_q_destroy(struct be_ad
 extern int be_cmd_rxq_destroy(struct be_adapter *adapter,
 			struct be_queue_info *q);
 extern int be_cmd_link_status_query(struct be_adapter *adapter,
-			bool *link_up, u8 *mac_speed, u16 *link_speed, u32 dom);
+			u8 *mac_speed, u16 *link_speed, u32 dom);
 extern int be_cmd_reset(struct be_adapter *adapter);
 extern int be_cmd_get_stats(struct be_adapter *adapter,
 			struct be_dma_mem *nonemb_cmd);
--- a/drivers/net/benet/be_ethtool.c
+++ b/drivers/net/benet/be_ethtool.c
@@ -353,15 +353,13 @@ static int be_get_settings(struct net_de
 	struct be_cmd_resp_get_phy_info *resp;
 	u8 mac_speed = 0;
 	u16 link_speed = 0;
-	bool link_up = false;
 	int status;
 	u16 intf_type;
 
 	if ((adapter->link_speed < 0) || (!(netdev->flags & IFF_UP))) {
-		status = be_cmd_link_status_query(adapter, &link_up,
-						&mac_speed, &link_speed, 0);
+		status = be_cmd_link_status_query(adapter, &mac_speed,
+						&link_speed, 0);
 
-		be_link_status_update(adapter, link_up);
 		/* link_speed is in units of 10 Mbps */
 		if (link_speed) {
 			ethtool_cmd_speed_set(ecmd, link_speed*10);
@@ -617,7 +615,6 @@ static void
 be_self_test(struct net_device *netdev, struct ethtool_test *test, u64 *data)
 {
 	struct be_adapter *adapter = netdev_priv(netdev);
-	bool link_up;
 	u8 mac_speed = 0;
 	u16 qos_link_speed = 0;
 
@@ -643,7 +640,7 @@ be_self_test(struct net_device *netdev,
 		test->flags |= ETH_TEST_FL_FAILED;
 	}
 
-	if (be_cmd_link_status_query(adapter, &link_up, &mac_speed,
+	if (be_cmd_link_status_query(adapter, &mac_speed,
 				&qos_link_speed, 0) != 0) {
 		test->flags |= ETH_TEST_FL_FAILED;
 		data[4] = -1;
--- a/drivers/net/benet/be_main.c
+++ b/drivers/net/benet/be_main.c
@@ -462,21 +462,18 @@ static struct rtnl_link_stats64 *be_get_
 	return stats;
 }
 
-void be_link_status_update(struct be_adapter *adapter, bool link_up)
+void be_link_status_update(struct be_adapter *adapter, u32 link_status)
 {
 	struct net_device *netdev = adapter->netdev;
 
-	/* If link came up or went down */
-	if (adapter->link_up != link_up) {
-		adapter->link_speed = -1;
-		if (link_up) {
-			netif_carrier_on(netdev);
-			printk(KERN_INFO "%s: Link up\n", netdev->name);
-		} else {
-			netif_carrier_off(netdev);
-			printk(KERN_INFO "%s: Link down\n", netdev->name);
-		}
-		adapter->link_up = link_up;
+	/* when link status changes, link speed must be re-queried from card */
+	adapter->link_speed = -1;
+	if ((link_status & LINK_STATUS_MASK) == LINK_UP) {
+		netif_carrier_on(netdev);
+		dev_info(&adapter->pdev->dev, "%s: Link up\n", netdev->name);
+	} else {
+		netif_carrier_off(netdev);
+		dev_info(&adapter->pdev->dev, "%s: Link down\n", netdev->name);
 	}
 }
 
@@ -2217,8 +2214,6 @@ static int be_close(struct net_device *n
 
 	be_async_mcc_disable(adapter);
 
-	adapter->link_up = false;
-
 	if (!lancer_chip(adapter))
 		be_intr_set(adapter, false);
 
@@ -2296,10 +2291,7 @@ static int be_open(struct net_device *ne
 	struct be_adapter *adapter = netdev_priv(netdev);
 	struct be_eq_obj *tx_eq = &adapter->tx_eq;
 	struct be_rx_obj *rxo;
-	bool link_up;
 	int status, i;
-	u8 mac_speed;
-	u16 link_speed;
 
 	status = be_rx_queues_setup(adapter);
 	if (status)
@@ -2322,12 +2314,6 @@ static int be_open(struct net_device *ne
 	/* Now that interrupts are on we can process async mcc */
 	be_async_mcc_enable(adapter);
 
-	status = be_cmd_link_status_query(adapter, &link_up, &mac_speed,
-			&link_speed, 0);
-	if (status)
-		goto err;
-	be_link_status_update(adapter, link_up);
-
 	if (be_physfn(adapter)) {
 		status = be_vid_config(adapter, false, 0);
 		if (status)
@@ -3347,7 +3333,6 @@ static int __devinit be_probe(struct pci
 
 	if (be_physfn(adapter) && adapter->sriov_enabled) {
 		u8 mac_speed;
-		bool link_up;
 		u16 vf, lnk_speed;
 
 		if (!lancer_chip(adapter)) {
@@ -3357,8 +3342,8 @@ static int __devinit be_probe(struct pci
 		}
 
 		for (vf = 0; vf < num_vfs; vf++) {
-			status = be_cmd_link_status_query(adapter, &link_up,
-					&mac_speed, &lnk_speed, vf + 1);
+			status = be_cmd_link_status_query(adapter, &mac_speed,
+						&lnk_speed, vf + 1);
 			if (!status)
 				adapter->vf_cfg[vf].vf_tx_rate = lnk_speed * 10;
 			else
