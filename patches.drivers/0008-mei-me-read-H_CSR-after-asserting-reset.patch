From 755524e4daf468cf51820b2da00284190b54432c Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Mon, 15 Dec 2014 15:03:39 +0200
Subject: [char-misc 08/11] mei: me: read H_CSR after asserting reset
Git-commit: c40765d919d25d2d44d99c4ce39e48808f137e1e
Patch-mainline: 3.16-rc1
References: bnc#876086

commit c40765d919d25d2d44d99c4ce39e48808f137e1e upstream.

According the spec the host should read H_CSR again
after asserting reset H_RST to ensure that reset was
read by the firmware

[Backport to v3.7: adjust after refactoring]

Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/misc/mei/init.c |   15 +++++++++++++++
 1 file changed, 15 insertions(+)

--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -277,8 +277,23 @@ static void mei_hw_reset(struct mei_devi
 		mei_enable_interrupts(dev);
 	else
 		mei_disable_interrupts(dev);
+
+	/*
+	 * Host reads the H_CSR once to ensure that the
+	 * posted write to H_CSR completes.
+	 */
+	dev->host_hw_state  = mei_hcsr_read(dev);
+
+	if ((dev->host_hw_state & H_RST) == 0)
+		dev_warn(&dev->pdev->dev, "H_RST is not set = 0x%08X",
+			dev->host_hw_state);
+
+	if ((dev->host_hw_state & H_RDY) == H_RDY)
+		dev_warn(&dev->pdev->dev, "H_RDY is not cleared 0x%08X",
+			dev->host_hw_state);
 }
 
+
 /**
  * mei_me_hw_ready_wait - wait until the me(hw) has turned ready
  * or timeout is reached
