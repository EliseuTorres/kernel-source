From: Dan Williams <dan.j.williams@intel.com>
Date: Sun, 1 May 2011 16:58:46 -0700
Subject: [PATCH 148/273] isci: kill scic_sds_remote_device.state_handlers
Git-commit: 971cc2ff90875a4ca28b7da5b91a408cc8151fdc
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Remove the now unused state_handler infrastructure for remote_devices.

Reported-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/remote_device.c |  136 ++-----------------------------------
 drivers/scsi/isci/remote_device.h |   56 ---------------
 2 files changed, 5 insertions(+), 187 deletions(-)

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 0295349..a23ebe8 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -809,46 +809,10 @@ static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handl
 		isci_remote_device_ready(scic->ihost, idev);
 }
 
-static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
-	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-	},
-	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-	},
-	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-	}
-};
-
 static void scic_sds_remote_device_initial_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_INITIAL);
-
 	/* Initial state is a transitional state to the stopped state */
 	sci_base_state_machine_change_state(&sci_dev->state_machine,
 					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
@@ -953,9 +917,6 @@ static void scic_sds_remote_device_stopped_state_enter(void *object)
 	ihost = scic->ihost;
 	idev = sci_dev_to_idev(sci_dev);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
-
 	/* If we are entering from the stopping state let the SCI User know that
 	 * the stop operation has completed.
 	 */
@@ -973,9 +934,6 @@ static void scic_sds_remote_device_starting_state_enter(void *object)
 	struct isci_host *ihost = scic->ihost;
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
-
 	isci_remote_device_not_ready(ihost, idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
 }
@@ -986,10 +944,6 @@ static void scic_sds_remote_device_ready_state_enter(void *object)
 	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 
-	SET_STATE_HANDLER(sci_dev,
-			  scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_READY);
-
 	scic->remote_device_sequence[sci_dev->rnc.remote_node_index]++;
 
 	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
@@ -1016,38 +970,10 @@ static void scic_sds_remote_device_ready_state_exit(void *object)
 	}
 }
 
-static void scic_sds_remote_device_stopping_state_enter(void *object)
-{
-	struct scic_sds_remote_device *sci_dev = object;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
-		);
-}
-
-static void scic_sds_remote_device_failed_state_enter(void *object)
-{
-	struct scic_sds_remote_device *sci_dev = object;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_FAILED
-		);
-}
-
 static void scic_sds_remote_device_resetting_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_RESETTING
-		);
-
 	scic_sds_remote_node_context_suspend(
 		&sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
 }
@@ -1059,24 +985,10 @@ static void scic_sds_remote_device_resetting_state_exit(void *object)
 	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
 }
 
-static void scic_sds_remote_device_final_state_enter(void *object)
-{
-	struct scic_sds_remote_device *sci_dev = object;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_FINAL
-		);
-}
-
 static void scic_sds_stp_remote_device_ready_idle_substate_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-
 	sci_dev->working_request = NULL;
 	if (scic_sds_remote_node_context_is_ready(&sci_dev->rnc)) {
 		/*
@@ -1097,51 +1009,26 @@ static void scic_sds_stp_remote_device_ready_cmd_substate_enter(void *object)
 
 	BUG_ON(sci_dev->working_request == NULL);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
-
 	isci_remote_device_not_ready(scic->ihost, sci_dev_to_idev(sci_dev),
 				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
 }
 
-static void scic_sds_stp_remote_device_ready_ncq_substate_enter(void *object)
-{
-	struct scic_sds_remote_device *sci_dev = object;
-
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ);
-}
-
 static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
-
 	if (sci_dev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
 		isci_remote_device_not_ready(scic->ihost, idev,
 					     sci_dev->not_ready_reason);
 }
 
-static void scic_sds_stp_remote_device_ready_await_reset_substate_enter(void *object)
-{
-	struct scic_sds_remote_device *sci_dev = object;
-
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET);
-}
-
 static void scic_sds_smp_remote_device_ready_idle_substate_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-
 	isci_remote_device_ready(scic->ihost, sci_dev_to_idev(sci_dev));
 }
 
@@ -1152,9 +1039,6 @@ static void scic_sds_smp_remote_device_ready_cmd_substate_enter(void *object)
 
 	BUG_ON(sci_dev->working_request == NULL);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
-
 	isci_remote_device_not_ready(scic->ihost, sci_dev_to_idev(sci_dev),
 				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
 }
@@ -1186,15 +1070,11 @@ static const struct sci_base_state scic_sds_remote_device_state_table[] = {
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
 		.enter_state = scic_sds_stp_remote_device_ready_cmd_substate_enter,
 	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.enter_state = scic_sds_stp_remote_device_ready_ncq_substate_enter,
-	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = { },
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
 		.enter_state = scic_sds_stp_remote_device_ready_ncq_error_substate_enter,
 	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.enter_state = scic_sds_stp_remote_device_ready_await_reset_substate_enter,
-	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = { },
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
 		.enter_state = scic_sds_smp_remote_device_ready_idle_substate_enter,
 	},
@@ -1202,19 +1082,13 @@ static const struct sci_base_state scic_sds_remote_device_state_table[] = {
 		.enter_state = scic_sds_smp_remote_device_ready_cmd_substate_enter,
 		.exit_state  = scic_sds_smp_remote_device_ready_cmd_substate_exit,
 	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.enter_state = scic_sds_remote_device_stopping_state_enter,
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.enter_state = scic_sds_remote_device_failed_state_enter,
-	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = { },
+	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = { },
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
 		.enter_state = scic_sds_remote_device_resetting_state_enter,
 		.exit_state  = scic_sds_remote_device_resetting_state_exit
 	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.enter_state = scic_sds_remote_device_final_state_enter,
-	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = { },
 };
 
 /**
diff --git a/drivers/scsi/isci/remote_device.h b/drivers/scsi/isci/remote_device.h
index 1577b12..18f7f96 100644
--- a/drivers/scsi/isci/remote_device.h
+++ b/drivers/scsi/isci/remote_device.h
@@ -128,12 +128,6 @@ struct scic_sds_remote_device {
 	 * assigned in the state handlers and used in the state transition.
 	 */
 	u32 not_ready_reason;
-
-	/**
-	 * This field maintains the set of state handlers for the remote device
-	 * object.  These are changed each time the remote device enters a new state.
-	 */
-	const struct scic_sds_remote_device_state_handler *state_handlers;
 };
 
 struct isci_remote_device {
@@ -347,47 +341,6 @@ static inline bool dev_is_expander(struct domain_device *dev)
 	return dev->dev_type == EDGE_DEV || dev->dev_type == FANOUT_DEV;
 }
 
-typedef enum sci_status (*scic_sds_remote_device_request_handler_t)(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request);
-
-typedef enum sci_status (*scic_sds_remote_device_high_priority_request_complete_handler_t)(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request,
-	void *,
-	enum sci_io_status);
-
-typedef enum sci_status (*scic_sds_remote_device_handler_t)(
-	struct scic_sds_remote_device *sci_dev);
-
-typedef enum sci_status (*scic_sds_remote_device_suspend_handler_t)(
-	struct scic_sds_remote_device *sci_dev,
-	u32 suspend_type);
-
-typedef enum sci_status (*scic_sds_remote_device_resume_handler_t)(
-	struct scic_sds_remote_device *sci_dev);
-
-typedef enum sci_status (*scic_sds_remote_device_frame_handler_t)(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index);
-
-typedef enum sci_status (*scic_sds_remote_device_event_handler_t)(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code);
-
-typedef void (*scic_sds_remote_device_ready_not_ready_handler_t)(
-	struct scic_sds_remote_device *sci_dev);
-
-/**
- * struct scic_sds_remote_device_state_handler - This structure conains the
- *    state handlers that are needed to process requests for the SCU remote
- *    device objects.
- *
- *
- */
-struct scic_sds_remote_device_state_handler {
-};
-
 /**
  * scic_sds_remote_device_increment_request_count() -
  *
@@ -431,15 +384,6 @@ struct scic_sds_remote_device_state_handler {
 	scic_sds_port_get_controller(scic_sds_remote_device_get_port(sci_dev))
 
 /**
- * scic_sds_remote_device_set_state_handlers() -
- *
- * This macro sets the remote device state handlers pointer and is set on entry
- * to each device state.
- */
-#define scic_sds_remote_device_set_state_handlers(sci_dev, handlers) \
-	((sci_dev)->state_handlers = (handlers))
-
-/**
  * scic_sds_remote_device_get_port() -
  *
  * This macro returns the owning port of this device
-- 
1.6.0.2

