From: Neerav Parikh <neerav.parikh@intel.com>
Date: Wed, 4 Jun 2014 01:23:15 +0000
Subject: [PATCH v3 381/474] i40e: Add PF reset when Malicious driver event for
 PF
Patch-mainline: v3.17-rc1
Git-commit: df430b1240d3375d053230d1f943383d59f9267a
References: bsc#909484 FATE#317397

As per the spec when the PF driver receives a Malicious driver event
the queue that caused the event is already stopped and it is expected
that the function that owns the queue will reset the queue.
In some cases it may not be possible to determine the queue and it is
suggested to reset the whole function.

This patch takes the later approach when the event is owned by the PF
that owns it.

Change-ID: I40f9764a6a5e068c0ef8438db00c5aa9c2c6c1c8
Signed-off-by: Neerav Parikh <neerav.parikh@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: David Chang <dchang@suse.com>
---
 drivers/net/ethernet/intel/i40e/i40e_main.c |   25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -5822,6 +5822,7 @@ static void i40e_handle_mdd_event(struct
 {
 	struct i40e_hw *hw = &pf->hw;
 	bool mdd_detected = false;
+	bool pf_mdd_detected = false;
 	struct i40e_vf *vf;
 	u32 reg;
 	int i;
@@ -5861,6 +5862,30 @@ static void i40e_handle_mdd_event(struct
 		mdd_detected = true;
 	}
 
+	if (mdd_detected) {
+		reg = rd32(hw, I40E_PF_MDET_TX);
+		if (reg & I40E_PF_MDET_TX_VALID_MASK) {
+			wr32(hw, I40E_PF_MDET_TX, 0xFFFF);
+			dev_info(&pf->pdev->dev,
+				 "MDD TX event is for this function 0x%08x, requesting PF reset.\n",
+				 reg);
+			pf_mdd_detected = true;
+		}
+		reg = rd32(hw, I40E_PF_MDET_RX);
+		if (reg & I40E_PF_MDET_RX_VALID_MASK) {
+			wr32(hw, I40E_PF_MDET_RX, 0xFFFF);
+			dev_info(&pf->pdev->dev,
+				 "MDD RX event is for this function 0x%08x, requesting PF reset.\n",
+				 reg);
+			pf_mdd_detected = true;
+		}
+		/* Queue belongs to the PF, initiate a reset */
+		if (pf_mdd_detected) {
+			set_bit(__I40E_PF_RESET_REQUESTED, &pf->state);
+			i40e_service_event_schedule(pf);
+		}
+	}
+
 	/* see if one of the VFs needs its hand slapped */
 	for (i = 0; i < pf->num_alloc_vfs && mdd_detected; i++) {
 		vf = &(pf->vf[i]);
