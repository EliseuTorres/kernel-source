From: Dan Williams <dan.j.williams@intel.com>
Date: Tue, 10 May 2011 02:28:46 -0700
Subject: [PATCH 185/273] isci: uplevel port infrastructure
Git-commit: e2f8db509fdd354bb7a68c86515e9d2d8909ccc9
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

* Move port configuration agent implementation
* Merge core/scic_sds_port.[ch] into port.[ch]

Reported-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/Makefile                         |    4 +-
 drivers/scsi/isci/core/scic_config_parameters.h    |  249 --
 drivers/scsi/isci/core/scic_port.h                 |   97 -
 drivers/scsi/isci/core/scic_sds_port.c             | 2423 -------------------
 drivers/scsi/isci/core/scic_sds_port.h             |  435 ----
 .../isci/core/scic_sds_port_configuration_agent.c  |  827 -------
 .../isci/core/scic_sds_port_configuration_agent.h  |  107 -
 drivers/scsi/isci/host.c                           |    1 -
 drivers/scsi/isci/host.h                           |   29 +-
 drivers/scsi/isci/phy.c                            |    3 +-
 drivers/scsi/isci/phy.h                            |    1 +
 drivers/scsi/isci/port.c                           | 2451 +++++++++++++++++++-
 drivers/scsi/isci/port.h                           |  425 ++++-
 drivers/scsi/isci/port_config.c                    |  826 +++++++
 drivers/scsi/isci/probe_roms.h                     |  124 +-
 drivers/scsi/isci/remote_device.c                  |    2 -
 drivers/scsi/isci/remote_node_context.c            |    1 -
 drivers/scsi/isci/request.c                        |    1 -
 18 files changed, 3755 insertions(+), 4251 deletions(-)
 delete mode 100644 drivers/scsi/isci/core/scic_config_parameters.h
 delete mode 100644 drivers/scsi/isci/core/scic_port.h
 delete mode 100644 drivers/scsi/isci/core/scic_sds_port.c
 delete mode 100644 drivers/scsi/isci/core/scic_sds_port.h
 delete mode 100644 drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
 delete mode 100644 drivers/scsi/isci/core/scic_sds_port_configuration_agent.h
 create mode 100644 drivers/scsi/isci/port_config.c

diff --git a/drivers/scsi/isci/Makefile b/drivers/scsi/isci/Makefile
index 2830a97..48218ca 100644
--- a/drivers/scsi/isci/Makefile
+++ b/drivers/scsi/isci/Makefile
@@ -1,4 +1,3 @@
-EXTRA_CFLAGS += -Idrivers/scsi/isci/core/ -Idrivers/scsi/isci/
 obj-$(CONFIG_SCSI_ISCI) += isci.o
 isci-objs := init.o phy.o request.o sata.o \
 	     remote_device.o port.o timers.o \
@@ -10,5 +9,4 @@ isci-objs := init.o phy.o request.o sata.o \
 	     stp_request.o \
 	     ssp_request.o \
 	     smp_request.o \
-	     core/scic_sds_port.o \
-	     core/scic_sds_port_configuration_agent.o \
+	     port_config.o \
diff --git a/drivers/scsi/isci/core/scic_config_parameters.h b/drivers/scsi/isci/core/scic_config_parameters.h
deleted file mode 100644
index 15e7744..0000000
--- a/drivers/scsi/isci/core/scic_config_parameters.h
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCIC_SDS_USER_PARAMETERS_H_
-#define _SCIC_SDS_USER_PARAMETERS_H_
-
-#include "probe_roms.h"
-
-struct scic_sds_controller;
-
-/**
- *
- *
- * SCIC_SDS_PARM_PHY_SPEED These constants define the speeds utilized for a
- * phy/port.
- */
-#define SCIC_SDS_PARM_NO_SPEED   0
-
-/**
- *
- *
- * This value of 1 indicates generation 1 (i.e. 1.5 Gb/s).
- */
-#define SCIC_SDS_PARM_GEN1_SPEED 1
-
-/**
- *
- *
- * This value of 2 indicates generation 2 (i.e. 3.0 Gb/s).
- */
-#define SCIC_SDS_PARM_GEN2_SPEED 2
-
-/**
- *
- *
- * This value of 3 indicates generation 3 (i.e. 6.0 Gb/s).
- */
-#define SCIC_SDS_PARM_GEN3_SPEED 3
-
-/**
- *
- *
- * For range checks, the max speed generation
- */
-#define SCIC_SDS_PARM_MAX_SPEED SCIC_SDS_PARM_GEN3_SPEED
-
-/**
- * struct scic_sds_user_parameters - This structure delineates the various user
- *    parameters that can be changed by the core user.
- *
- *
- */
-struct scic_sds_user_parameters {
-	struct sci_phy_user_params {
-		/**
-		 * This field specifies the NOTIFY (ENABLE SPIN UP) primitive
-		 * insertion frequency for this phy index.
-		 */
-		u32 notify_enable_spin_up_insertion_frequency;
-
-		/**
-		 * This method specifies the number of transmitted DWORDs within which
-		 * to transmit a single ALIGN primitive.  This value applies regardless
-		 * of what type of device is attached or connection state.  A value of
-		 * 0 indicates that no ALIGN primitives will be inserted.
-		 */
-		u16 align_insertion_frequency;
-
-		/**
-		 * This method specifies the number of transmitted DWORDs within which
-		 * to transmit 2 ALIGN primitives.  This applies for SAS connections
-		 * only.  A minimum value of 3 is required for this field.
-		 */
-		u16 in_connection_align_insertion_frequency;
-
-		/**
-		 * This field indicates the maximum speed generation to be utilized
-		 * by phys in the supplied port.
-		 * - A value of 1 indicates generation 1 (i.e. 1.5 Gb/s).
-		 * - A value of 2 indicates generation 2 (i.e. 3.0 Gb/s).
-		 * - A value of 3 indicates generation 3 (i.e. 6.0 Gb/s).
-		 */
-		u8 max_speed_generation;
-
-	} phys[SCI_MAX_PHYS];
-
-	/**
-	 * This field specifies the maximum number of direct attached devices
-	 * that can have power supplied to them simultaneously.
-	 */
-	u8 max_number_concurrent_device_spin_up;
-
-	/**
-	 * This field specifies the number of seconds to allow a phy to consume
-	 * power before yielding to another phy.
-	 *
-	 */
-	u8 phy_spin_up_delay_interval;
-
-	/**
-	 * These timer values specifies how long a link will remain open with no
-	 * activity in increments of a microsecond, it can be in increments of
-	 * 100 microseconds if the upper most bit is set.
-	 *
-	 */
-	u16 stp_inactivity_timeout;
-	u16 ssp_inactivity_timeout;
-
-	/**
-	 * These timer values specifies how long a link will remain open in increments
-	 * of 100 microseconds.
-	 *
-	 */
-	u16 stp_max_occupancy_timeout;
-	u16 ssp_max_occupancy_timeout;
-
-	/**
-	 * This timer value specifies how long a link will remain open with no
-	 * outbound traffic in increments of a microsecond.
-	 *
-	 */
-	u8 no_outbound_task_timeout;
-
-};
-
-/**
- * This structure/union specifies the various different user parameter sets
- *    available.  Each type is specific to a hardware controller version.
- *
- * union scic_user_parameters
- */
-union scic_user_parameters {
-	/**
-	 * This field specifies the user parameters specific to the
-	 * Storage Controller Unit (SCU) Driver Standard (SDS) version
-	 * 1.
-	 */
-	struct scic_sds_user_parameters sds1;
-
-};
-
-
-/**
- *
- *
- * SCIC_SDS_OEM_PHY_MASK These constants define the valid values for phy_mask
- */
-
-/**
- *
- *
- * This is the min value assignable to a port's phy mask
- */
-#define SCIC_SDS_PARM_PHY_MASK_MIN 0x0
-
-/**
- *
- *
- * This is the max value assignable to a port's phy mask
- */
-#define SCIC_SDS_PARM_PHY_MASK_MAX 0xF
-
-#define MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT 4
-
-/**
- * This structure/union specifies the various different OEM parameter sets
- *    available.  Each type is specific to a hardware controller version.
- *
- * union scic_oem_parameters
- */
-union scic_oem_parameters {
-	/**
-	 * This field specifies the OEM parameters specific to the
-	 * Storage Controller Unit (SCU) Driver Standard (SDS) version
-	 * 1.
-	 */
-	struct scic_sds_oem_params sds1;
-};
-
-int scic_oem_parameters_validate(struct scic_sds_oem_params *oem);
-
-/**
- * scic_oem_parameters_get() - This method allows the user to retreive the OEM
- *    parameters utilized by the controller.
- * @controller: This parameter specifies the controller on which to set the
- *    user parameters.
- * @oem_parameters: This parameter specifies the OEM parameters object in which
- *    to write the core's OEM parameters.
- *
- */
-void scic_oem_parameters_get(
-	struct scic_sds_controller *controller,
-	union scic_oem_parameters *oem_parameters);
-
-
-#endif  /* _SCIC_SDS_USER_PARAMETERS_H_ */
-
diff --git a/drivers/scsi/isci/core/scic_port.h b/drivers/scsi/isci/core/scic_port.h
deleted file mode 100644
index 431dbd2..0000000
--- a/drivers/scsi/isci/core/scic_port.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCIC_PORT_H_
-#define _SCIC_PORT_H_
-
-#include "isci.h"
-#include "sas.h"
-#include "phy.h"
-
-struct scic_sds_port;
-
-enum scic_port_not_ready_reason_code {
-	SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS,
-	SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED,
-	SCIC_PORT_NOT_READY_INVALID_PORT_CONFIGURATION,
-	SCIC_PORT_NOT_READY_RECONFIGURING,
-
-	SCIC_PORT_NOT_READY_REASON_CODE_MAX
-};
-
-struct scic_port_end_point_properties {
-	struct sci_sas_address sas_address;
-	struct scic_phy_proto protocols;
-};
-
-struct scic_port_properties {
-	u32 index;
-	struct scic_port_end_point_properties local;
-	struct scic_port_end_point_properties remote;
-	u32 phy_mask;
-};
-
-enum sci_status scic_port_get_properties(
-	struct scic_sds_port *port,
-	struct scic_port_properties *properties);
-
-enum sci_status scic_port_hard_reset(
-	struct scic_sds_port *port,
-	u32 reset_timeout);
-
-void scic_port_enable_broadcast_change_notification(
-	struct scic_sds_port *port);
-
-#endif  /* _SCIC_PORT_H_ */
diff --git a/drivers/scsi/isci/core/scic_sds_port.c b/drivers/scsi/isci/core/scic_sds_port.c
deleted file mode 100644
index 11b516a..0000000
--- a/drivers/scsi/isci/core/scic_sds_port.c
+++ /dev/null
@@ -1,2423 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "host.h"
-#include "scic_port.h"
-#include "scic_sds_port.h"
-#include "remote_device.h"
-#include "remote_node_context.h"
-#include "registers.h"
-#include "timers.h"
-#include "scu_task_context.h"
-
-#define SCIC_SDS_PORT_MIN_TIMER_COUNT  (SCI_MAX_PORTS)
-#define SCIC_SDS_PORT_MAX_TIMER_COUNT  (SCI_MAX_PORTS)
-
-#define SCIC_SDS_PORT_HARD_RESET_TIMEOUT  (1000)
-#define SCU_DUMMY_INDEX    (0xFFFF)
-
-
-/**
- *
- * @sci_port: This is the port object to which the phy is being assigned.
- * @phy_index: This is the phy index that is being assigned to the port.
- *
- * This method will return a true value if the specified phy can be assigned to
- * this port The following is a list of phys for each port that are allowed: -
- * Port 0 - 3 2 1 0 - Port 1 -     1 - Port 2 - 3 2 - Port 3 - 3 This method
- * doesn't preclude all configurations.  It merely ensures that a phy is part
- * of the allowable set of phy identifiers for that port.  For example, one
- * could assign phy 3 to port 0 and no other phys.  Please refer to
- * scic_sds_port_is_phy_mask_valid() for information regarding whether the
- * phy_mask for a port can be supported. bool true if this is a valid phy
- * assignment for the port false if this is not a valid phy assignment for the
- * port
- */
-bool scic_sds_port_is_valid_phy_assignment(
-	struct scic_sds_port *sci_port,
-	u32 phy_index)
-{
-	/* Initialize to invalid value. */
-	u32 existing_phy_index = SCI_MAX_PHYS;
-	u32 index;
-
-	if ((sci_port->physical_port_index == 1) && (phy_index != 1)) {
-		return false;
-	}
-
-	if (sci_port->physical_port_index == 3 && phy_index != 3) {
-		return false;
-	}
-
-	if (
-		(sci_port->physical_port_index == 2)
-		&& ((phy_index == 0) || (phy_index == 1))
-		) {
-		return false;
-	}
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if ((sci_port->phy_table[index] != NULL)
-		    && (index != phy_index)) {
-			existing_phy_index = index;
-		}
-	}
-
-	/*
-	 * Ensure that all of the phys in the port are capable of
-	 * operating at the same maximum link rate. */
-	if (
-		(existing_phy_index < SCI_MAX_PHYS)
-		&& (sci_port->owning_controller->user_parameters.sds1.phys[
-			    phy_index].max_speed_generation !=
-		    sci_port->owning_controller->user_parameters.sds1.phys[
-			    existing_phy_index].max_speed_generation)
-		)
-		return false;
-
-	return true;
-}
-
-/**
- * This method requests a list (mask) of the phys contained in the supplied SAS
- *    port.
- * @sci_port: a handle corresponding to the SAS port for which to return the
- *    phy mask.
- *
- * Return a bit mask indicating which phys are a part of this port. Each bit
- * corresponds to a phy identifier (e.g. bit 0 = phy id 0).
- */
-static u32 scic_sds_port_get_phys(struct scic_sds_port *sci_port)
-{
-	u32 index;
-	u32 mask;
-
-	mask = 0;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
-			mask |= (1 << index);
-		}
-	}
-
-	return mask;
-}
-
-/**
- *
- * @sci_port: This is the port object for which to determine if the phy mask
- *    can be supported.
- *
- * This method will return a true value if the port's phy mask can be supported
- * by the SCU. The following is a list of valid PHY mask configurations for
- * each port: - Port 0 - [[3  2] 1] 0 - Port 1 -        [1] - Port 2 - [[3] 2]
- * - Port 3 -  [3] This method returns a boolean indication specifying if the
- * phy mask can be supported. true if this is a valid phy assignment for the
- * port false if this is not a valid phy assignment for the port
- */
-static bool scic_sds_port_is_phy_mask_valid(
-	struct scic_sds_port *sci_port,
-	u32 phy_mask)
-{
-	if (sci_port->physical_port_index == 0) {
-		if (((phy_mask & 0x0F) == 0x0F)
-		    || ((phy_mask & 0x03) == 0x03)
-		    || ((phy_mask & 0x01) == 0x01)
-		    || (phy_mask == 0))
-			return true;
-	} else if (sci_port->physical_port_index == 1) {
-		if (((phy_mask & 0x02) == 0x02)
-		    || (phy_mask == 0))
-			return true;
-	} else if (sci_port->physical_port_index == 2) {
-		if (((phy_mask & 0x0C) == 0x0C)
-		    || ((phy_mask & 0x04) == 0x04)
-		    || (phy_mask == 0))
-			return true;
-	} else if (sci_port->physical_port_index == 3) {
-		if (((phy_mask & 0x08) == 0x08)
-		    || (phy_mask == 0))
-			return true;
-	}
-
-	return false;
-}
-
-/**
- *
- * @sci_port: This parameter specifies the port from which to return a
- *    connected phy.
- *
- * This method retrieves a currently active (i.e. connected) phy contained in
- * the port.  Currently, the lowest order phy that is connected is returned.
- * This method returns a pointer to a SCIS_SDS_PHY object. NULL This value is
- * returned if there are no currently active (i.e. connected to a remote end
- * point) phys contained in the port. All other values specify a struct scic_sds_phy
- * object that is active in the port.
- */
-static struct scic_sds_phy *scic_sds_port_get_a_connected_phy(
-	struct scic_sds_port *sci_port
-	) {
-	u32 index;
-	struct scic_sds_phy *phy;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		/*
-		 * Ensure that the phy is both part of the port and currently
-		 * connected to the remote end-point. */
-		phy = sci_port->phy_table[index];
-		if (
-			(phy != NULL)
-			&& scic_sds_port_active_phy(sci_port, phy)
-			) {
-			return phy;
-		}
-	}
-
-	return NULL;
-}
-
-/**
- * scic_sds_port_set_phy() -
- * @out]: port The port object to which the phy assignement is being made.
- * @out]: phy The phy which is being assigned to the port.
- *
- * This method attempts to make the assignment of the phy to the port. If
- * successful the phy is assigned to the ports phy table. bool true if the phy
- * assignment can be made. false if the phy assignement can not be made. This
- * is a functional test that only fails if the phy is currently assigned to a
- * different port.
- */
-static enum sci_status scic_sds_port_set_phy(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	/*
-	 * Check to see if we can add this phy to a port
-	 * that means that the phy is not part of a port and that the port does
-	 * not already have a phy assinged to the phy index. */
-	if (
-		(port->phy_table[phy->phy_index] == NULL)
-		&& (scic_sds_phy_get_port(phy) == NULL)
-		&& scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)
-		) {
-		/*
-		 * Phy is being added in the stopped state so we are in MPC mode
-		 * make logical port index = physical port index */
-		port->logical_port_index = port->physical_port_index;
-		port->phy_table[phy->phy_index] = phy;
-		scic_sds_phy_set_port(phy, port);
-
-		return SCI_SUCCESS;
-	}
-
-	return SCI_FAILURE;
-}
-
-/**
- * scic_sds_port_clear_phy() -
- * @out]: port The port from which the phy is being cleared.
- * @out]: phy The phy being cleared from the port.
- *
- * This method will clear the phy assigned to this port.  This method fails if
- * this phy is not currently assinged to this port. bool true if the phy is
- * removed from the port. false if this phy is not assined to this port.
- */
-static enum sci_status scic_sds_port_clear_phy(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	/* Make sure that this phy is part of this port */
-	if (port->phy_table[phy->phy_index] == phy &&
-	    scic_sds_phy_get_port(phy) == port) {
-		struct scic_sds_controller *scic = port->owning_controller;
-		struct isci_host *ihost = scic_to_ihost(scic);
-
-		/* Yep it is assigned to this port so remove it */
-		scic_sds_phy_set_port(phy, &ihost->ports[SCI_MAX_PORTS].sci);
-		port->phy_table[phy->phy_index] = NULL;
-		return SCI_SUCCESS;
-	}
-
-	return SCI_FAILURE;
-}
-
-/**
- * scic_sds_port_add_phy() -
- * @sci_port: This parameter specifies the port in which the phy will be added.
- * @sci_phy: This parameter is the phy which is to be added to the port.
- *
- * This method will add a PHY to the selected port. This method returns an
- * enum sci_status. SCI_SUCCESS the phy has been added to the port. Any other status
- * is failre to add the phy to the port.
- */
-enum sci_status scic_sds_port_add_phy(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	return sci_port->state_handlers->add_phy_handler(
-		       sci_port, sci_phy);
-}
-
-
-/**
- * scic_sds_port_remove_phy() -
- * @sci_port: This parameter specifies the port in which the phy will be added.
- * @sci_phy: This parameter is the phy which is to be added to the port.
- *
- * This method will remove the PHY from the selected PORT. This method returns
- * an enum sci_status. SCI_SUCCESS the phy has been removed from the port. Any other
- * status is failre to add the phy to the port.
- */
-enum sci_status scic_sds_port_remove_phy(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	return sci_port->state_handlers->remove_phy_handler(
-		       sci_port, sci_phy);
-}
-
-/**
- * This method requests the SAS address for the supplied SAS port from the SCI
- *    implementation.
- * @sci_port: a handle corresponding to the SAS port for which to return the
- *    SAS address.
- * @sas_address: This parameter specifies a pointer to a SAS address structure
- *    into which the core will copy the SAS address for the port.
- *
- */
-void scic_sds_port_get_sas_address(
-	struct scic_sds_port *sci_port,
-	struct sci_sas_address *sas_address)
-{
-	u32 index;
-
-	sas_address->high = 0;
-	sas_address->low  = 0;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
-			scic_sds_phy_get_sas_address(sci_port->phy_table[index], sas_address);
-		}
-	}
-}
-
-/*
- * This function will indicate which protocols are supported by this port.
- * @sci_port: a handle corresponding to the SAS port for which to return the
- *    supported protocols.
- * @protocols: This parameter specifies a pointer to a data structure
- *    which the core will copy the protocol values for the port from the
- *    transmit_identification register.
- */
-static void
-scic_sds_port_get_protocols(struct scic_sds_port *sci_port,
-			    struct scic_phy_proto *protocols)
-{
-	u8 index;
-
-	protocols->all = 0;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
-			scic_sds_phy_get_protocols(sci_port->phy_table[index],
-						   protocols);
-		}
-	}
-}
-
-/*
- * This function requests the SAS address for the device directly attached to
- *    this SAS port.
- * @sci_port: a handle corresponding to the SAS port for which to return the
- *    SAS address.
- * @sas_address: This parameter specifies a pointer to a SAS address structure
- *    into which the core will copy the SAS address for the device directly
- *    attached to the port.
- *
- */
-void scic_sds_port_get_attached_sas_address(
-	struct scic_sds_port *sci_port,
-	struct sci_sas_address *sas_address)
-{
-	struct scic_sds_phy *sci_phy;
-
-	/*
-	 * Ensure that the phy is both part of the port and currently
-	 * connected to the remote end-point.
-	 */
-	sci_phy = scic_sds_port_get_a_connected_phy(sci_port);
-	if (sci_phy) {
-		if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
-			scic_sds_phy_get_attached_sas_address(sci_phy,
-							      sas_address);
-		} else {
-			scic_sds_phy_get_sas_address(sci_phy, sas_address);
-			sas_address->low += sci_phy->phy_index;
-		}
-	} else {
-		sas_address->high = 0;
-		sas_address->low  = 0;
-	}
-}
-
-/**
- * scic_sds_port_construct_dummy_rnc() - create dummy rnc for si workaround
- *
- * @sci_port: logical port on which we need to create the remote node context
- * @rni: remote node index for this remote node context.
- *
- * This routine will construct a dummy remote node context data structure
- * This structure will be posted to the hardware to work around a scheduler
- * error in the hardware.
- */
-static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u16 rni)
-{
-	union scu_remote_node_context *rnc;
-
-	rnc = &sci_port->owning_controller->remote_node_context_table[rni];
-
-	memset(rnc, 0, sizeof(union scu_remote_node_context));
-
-	rnc->ssp.remote_sas_address_hi = 0;
-	rnc->ssp.remote_sas_address_lo = 0;
-
-	rnc->ssp.remote_node_index = rni;
-	rnc->ssp.remote_node_port_width = 1;
-	rnc->ssp.logical_port_index = sci_port->physical_port_index;
-
-	rnc->ssp.nexus_loss_timer_enable = false;
-	rnc->ssp.check_bit = false;
-	rnc->ssp.is_valid = true;
-	rnc->ssp.is_remote_node_context = true;
-	rnc->ssp.function_number = 0;
-	rnc->ssp.arbitration_wait_time = 0;
-}
-
-/**
- * scic_sds_port_construct_dummy_task() - create dummy task for si workaround
- * @sci_port The logical port on which we need to create the
- *            remote node context.
- *            context.
- * @tci The remote node index for this remote node context.
- *
- * This routine will construct a dummy task context data structure.  This
- * structure will be posted to the hardwre to work around a scheduler error
- * in the hardware.
- *
- */
-static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u16 tci)
-{
-	struct scu_task_context *task_context;
-
-	task_context = scic_sds_controller_get_task_context_buffer(sci_port->owning_controller, tci);
-
-	memset(task_context, 0, sizeof(struct scu_task_context));
-
-	task_context->abort = 0;
-	task_context->priority = 0;
-	task_context->initiator_request = 1;
-	task_context->connection_rate = 1;
-	task_context->protocol_engine_index = 0;
-	task_context->logical_port_index = sci_port->physical_port_index;
-	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;
-	task_context->task_index = scic_sds_io_tag_get_index(tci);
-	task_context->valid = SCU_TASK_CONTEXT_VALID;
-	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
-
-	task_context->remote_node_index = sci_port->reserved_rni;
-	task_context->command_code = 0;
-
-	task_context->link_layer_control = 0;
-	task_context->do_not_dma_ssp_good_response = 1;
-	task_context->strict_ordering = 0;
-	task_context->control_frame = 0;
-	task_context->timeout_enable = 0;
-	task_context->block_guard_enable = 0;
-
-	task_context->address_modifier = 0;
-
-	task_context->task_phase = 0x01;
-}
-
-static void scic_sds_port_destroy_dummy_resources(struct scic_sds_port *sci_port)
-{
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-
-	if (sci_port->reserved_tci != SCU_DUMMY_INDEX)
-		scic_controller_free_io_tag(scic, sci_port->reserved_tci);
-
-	if (sci_port->reserved_rni != SCU_DUMMY_INDEX)
-		scic_sds_remote_node_table_release_remote_node_index(&scic->available_remote_nodes,
-								     1, sci_port->reserved_rni);
-
-	sci_port->reserved_rni = SCU_DUMMY_INDEX;
-	sci_port->reserved_tci = SCU_DUMMY_INDEX;
-}
-
-/**
- * This method performs initialization of the supplied port. Initialization
- *    includes: - state machine initialization - member variable initialization
- *    - configuring the phy_mask
- * @sci_port:
- * @transport_layer_registers:
- * @port_task_scheduler_registers:
- * @port_configuration_regsiter:
- *
- * enum sci_status SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION This value is returned
- * if the phy being added to the port
- */
-enum sci_status scic_sds_port_initialize(
-	struct scic_sds_port *sci_port,
-	void __iomem *port_task_scheduler_registers,
-	void __iomem *port_configuration_regsiter,
-	void __iomem *viit_registers)
-{
-	sci_port->port_task_scheduler_registers  = port_task_scheduler_registers;
-	sci_port->port_pe_configuration_register = port_configuration_regsiter;
-	sci_port->viit_registers                 = viit_registers;
-
-	return SCI_SUCCESS;
-}
-
-/**
- * scic_port_get_properties() - This method simply returns the properties
- *    regarding the port, such as: physical index, protocols, sas address, etc.
- * @port: this parameter specifies the port for which to retrieve the physical
- *    index.
- * @properties: This parameter specifies the properties structure into which to
- *    copy the requested information.
- *
- * Indicate if the user specified a valid port. SCI_SUCCESS This value is
- * returned if the specified port was valid. SCI_FAILURE_INVALID_PORT This
- * value is returned if the specified port is not valid.  When this value is
- * returned, no data is copied to the properties output parameter.
- */
-enum sci_status scic_port_get_properties(
-	struct scic_sds_port *port,
-	struct scic_port_properties *prop)
-{
-	if ((port == NULL) ||
-	    (port->logical_port_index == SCIC_SDS_DUMMY_PORT))
-		return SCI_FAILURE_INVALID_PORT;
-
-	prop->index    = port->logical_port_index;
-	prop->phy_mask = scic_sds_port_get_phys(port);
-	scic_sds_port_get_sas_address(port, &prop->local.sas_address);
-	scic_sds_port_get_protocols(port, &prop->local.protocols);
-	scic_sds_port_get_attached_sas_address(port, &prop->remote.sas_address);
-
-	return SCI_SUCCESS;
-}
-
-/**
- * scic_port_hard_reset() - perform port hard reset
- * @port: a handle corresponding to the SAS port to be hard reset.
- * @reset_timeout: This parameter specifies the number of milliseconds in which
- *    the port reset operation should complete.
- *
- * The SCI User callback in scic_user_callbacks_t will only be called once for
- * each phy in the SAS Port at completion of the hard reset sequence. Return a
- * status indicating whether the hard reset started successfully. SCI_SUCCESS
- * This value is returned if the hard reset operation started successfully.
- */
-enum sci_status scic_port_hard_reset(
-	struct scic_sds_port *port,
-	u32 reset_timeout)
-{
-	return port->state_handlers->reset_handler(
-		       port, reset_timeout);
-}
-
-/**
- * This method assigns the direct attached device ID for this port.
- *
- * @param[in] sci_port The port for which the direct attached device id is to
- *       be assigned.
- * @param[in] device_id The direct attached device ID to assign to the port.
- *       This will be the RNi for the device
- */
-void scic_sds_port_setup_transports(
-	struct scic_sds_port *sci_port,
-	u32 device_id)
-{
-	u8 index;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->active_phy_mask & (1 << index))
-			scic_sds_phy_setup_transport(sci_port->phy_table[index], device_id);
-	}
-}
-
-/**
- *
- * @sci_port: This is the port on which the phy should be enabled.
- * @sci_phy: This is the specific phy which to enable.
- * @do_notify_user: This parameter specifies whether to inform the user (via
- *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
- *
- * This function will activate the phy in the port.
- * Activation includes: - adding
- * the phy to the port - enabling the Protocol Engine in the silicon. -
- * notifying the user that the link is up. none
- */
-static void scic_sds_port_activate_phy(struct scic_sds_port *sci_port,
-				       struct scic_sds_phy *sci_phy,
-				       bool do_notify_user)
-{
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
-
-	if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
-		scic_sds_phy_resume(sci_phy);
-
-	sci_port->active_phy_mask |= 1 << sci_phy->phy_index;
-
-	scic_sds_controller_clear_invalid_phy(scic, sci_phy);
-
-	if (do_notify_user == true)
-		isci_port_link_up(ihost, sci_port, sci_phy);
-}
-
-void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
-				  struct scic_sds_phy *sci_phy,
-				  bool do_notify_user)
-{
-	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
-	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
-
-	sci_port->active_phy_mask &= ~(1 << sci_phy->phy_index);
-
-	sci_phy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
-
-	/* Re-assign the phy back to the LP as if it were a narrow port */
-	writel(sci_phy->phy_index,
-		&sci_port->port_pe_configuration_register[sci_phy->phy_index]);
-
-	if (do_notify_user == true)
-		isci_port_link_down(ihost, iphy, iport);
-}
-
-/**
- *
- * @sci_port: This is the port on which the phy should be disabled.
- * @sci_phy: This is the specific phy which to disabled.
- *
- * This function will disable the phy and report that the phy is not valid for
- * this port object. None
- */
-static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
-					  struct scic_sds_phy *sci_phy)
-{
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-
-	/*
-	 * Check to see if we have alreay reported this link as bad and if
-	 * not go ahead and tell the SCI_USER that we have discovered an
-	 * invalid link.
-	 */
-	if ((scic->invalid_phy_mask & (1 << sci_phy->phy_index)) == 0) {
-		scic_sds_controller_set_invalid_phy(scic, sci_phy);
-		dev_warn(&scic_to_ihost(scic)->pdev->dev, "Invalid link up!\n");
-	}
-}
-
-/**
- * scic_sds_port_general_link_up_handler - phy can be assigned to port?
- * @sci_port: scic_sds_port object for which has a phy that has gone link up.
- * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
- * @do_notify_user: This parameter specifies whether to inform the user (via
- *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
- *
- * Determine if this phy can be assigned to this
- * port . If the phy is not a valid PHY for
- * this port then the function will notify the user. A PHY can only be
- * part of a port if it's attached SAS ADDRESS is the same as all other PHYs in
- * the same port. none
- */
-static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port,
-						  struct scic_sds_phy *sci_phy,
-						  bool do_notify_user)
-{
-	struct sci_sas_address port_sas_address;
-	struct sci_sas_address phy_sas_address;
-
-	scic_sds_port_get_attached_sas_address(sci_port, &port_sas_address);
-	scic_sds_phy_get_attached_sas_address(sci_phy, &phy_sas_address);
-
-	/* If the SAS address of the new phy matches the SAS address of
-	 * other phys in the port OR this is the first phy in the port,
-	 * then activate the phy and allow it to be used for operations
-	 * in this port.
-	 */
-	if ((phy_sas_address.high == port_sas_address.high &&
-	     phy_sas_address.low  == port_sas_address.low) ||
-	    sci_port->active_phy_mask == 0) {
-		struct sci_base_state_machine *sm = &sci_port->state_machine;
-
-		scic_sds_port_activate_phy(sci_port, sci_phy, do_notify_user);
-		if (sm->current_state_id == SCI_BASE_PORT_STATE_RESETTING)
-			sci_base_state_machine_change_state(sm, SCI_BASE_PORT_STATE_READY);
-	} else
-		scic_sds_port_invalid_link_up(sci_port, sci_phy);
-}
-
-
-
-/**
- * This method returns false if the port only has a single phy object assigned.
- *     If there are no phys or more than one phy then the method will return
- *    true.
- * @sci_port: The port for which the wide port condition is to be checked.
- *
- * bool true Is returned if this is a wide ported port. false Is returned if
- * this is a narrow port.
- */
-static bool scic_sds_port_is_wide(struct scic_sds_port *sci_port)
-{
-	u32 index;
-	u32 phy_count = 0;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
-			phy_count++;
-		}
-	}
-
-	return phy_count != 1;
-}
-
-/**
- * This method is called by the PHY object when the link is detected. if the
- *    port wants the PHY to continue on to the link up state then the port
- *    layer must return true.  If the port object returns false the phy object
- *    must halt its attempt to go link up.
- * @sci_port: The port associated with the phy object.
- * @sci_phy: The phy object that is trying to go link up.
- *
- * true if the phy object can continue to the link up condition. true Is
- * returned if this phy can continue to the ready state. false Is returned if
- * can not continue on to the ready state. This notification is in place for
- * wide ports and direct attached phys.  Since there are no wide ported SATA
- * devices this could become an invalid port configuration.
- */
-bool scic_sds_port_link_detected(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	if ((sci_port->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
-	    (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
-	    scic_sds_port_is_wide(sci_port)) {
-		scic_sds_port_invalid_link_up(sci_port, sci_phy);
-
-		return false;
-	}
-
-	return true;
-}
-
-/**
- * This method is the entry point for the phy to inform the port that it is now
- *    in a ready state
- * @sci_port:
- *
- *
- */
-void scic_sds_port_link_up(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	sci_phy->is_in_link_training = false;
-
-	sci_port->state_handlers->link_up_handler(sci_port, sci_phy);
-}
-
-/**
- * This method is the entry point for the phy to inform the port that it is no
- *    longer in a ready state
- * @sci_port:
- *
- *
- */
-void scic_sds_port_link_down(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	sci_port->state_handlers->link_down_handler(sci_port, sci_phy);
-}
-
-/**
- * This method is called to start an IO request on this port.
- * @sci_port:
- * @sci_dev:
- * @sci_req:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_port_start_io(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *sci_req)
-{
-	return sci_port->state_handlers->start_io_handler(
-		       sci_port, sci_dev, sci_req);
-}
-
-/**
- * This method is called to complete an IO request to the port.
- * @sci_port:
- * @sci_dev:
- * @sci_req:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_port_complete_io(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *sci_req)
-{
-	return sci_port->state_handlers->complete_io_handler(
-		       sci_port, sci_dev, sci_req);
-}
-
-/**
- * This method is provided to timeout requests for port operations. Mostly its
- *    for the port reset operation.
- *
- *
- */
-static void scic_sds_port_timeout_handler(void *port)
-{
-	struct scic_sds_port *sci_port = port;
-	u32 current_state;
-
-	current_state = sci_base_state_machine_get_state(
-		&sci_port->state_machine);
-
-	if (current_state == SCI_BASE_PORT_STATE_RESETTING) {
-		/*
-		 * if the port is still in the resetting state then the
-		 * timeout fired before the reset completed.
-		 */
-		sci_base_state_machine_change_state(
-			&sci_port->state_machine,
-			SCI_BASE_PORT_STATE_FAILED);
-	} else if (current_state == SCI_BASE_PORT_STATE_STOPPED) {
-		/*
-		 * if the port is stopped then the start request failed
-		 * In this case stay in the stopped state.
-		 */
-		dev_err(sciport_to_dev(sci_port),
-			"%s: SCIC Port 0x%p failed to stop before tiemout.\n",
-			__func__,
-			sci_port);
-	} else if (current_state == SCI_BASE_PORT_STATE_STOPPING) {
-		/*
-		 * if the port is still stopping then the stop has not
-		 * completed
-		 */
-		isci_port_stop_complete(
-				scic_sds_port_get_controller(sci_port),
-				sci_port,
-				SCI_FAILURE_TIMEOUT);
-	} else {
-		/*
-		 * The port is in the ready state and we have a timer
-		 * reporting a timeout this should not happen.
-		 */
-		dev_err(sciport_to_dev(sci_port),
-			"%s: SCIC Port 0x%p is processing a timeout operation "
-			"in state %d.\n",
-			__func__,
-			sci_port,
-			current_state);
-	}
-}
-
-/* --------------------------------------------------------------------------- */
-
-/**
- * This function updates the hardwares VIIT entry for this port.
- *
- *
- */
-static void scic_sds_port_update_viit_entry(struct scic_sds_port *sci_port)
-{
-	struct sci_sas_address sas_address;
-
-	scic_sds_port_get_sas_address(sci_port, &sas_address);
-
-	writel(sas_address.high,
-		&sci_port->viit_registers->initiator_sas_address_hi);
-	writel(sas_address.low,
-		&sci_port->viit_registers->initiator_sas_address_lo);
-
-	/* This value get cleared just in case its not already cleared */
-	writel(0, &sci_port->viit_registers->reserved);
-
-	/* We are required to update the status register last */
-	writel(SCU_VIIT_ENTRY_ID_VIIT |
-	       SCU_VIIT_IPPT_INITIATOR |
-	       ((1 << sci_port->physical_port_index) << SCU_VIIT_ENTRY_LPVIE_SHIFT) |
-	       SCU_VIIT_STATUS_ALL_VALID,
-	       &sci_port->viit_registers->status);
-}
-
-/**
- * This method returns the maximum allowed speed for data transfers on this
- *    port.  This maximum allowed speed evaluates to the maximum speed of the
- *    slowest phy in the port.
- * @sci_port: This parameter specifies the port for which to retrieve the
- *    maximum allowed speed.
- *
- * This method returns the maximum negotiated speed of the slowest phy in the
- * port.
- */
-enum sas_linkrate scic_sds_port_get_max_allowed_speed(
-	struct scic_sds_port *sci_port)
-{
-	u16 index;
-	enum sas_linkrate max_allowed_speed = SAS_LINK_RATE_6_0_GBPS;
-	struct scic_sds_phy *phy = NULL;
-
-	/*
-	 * Loop through all of the phys in this port and find the phy with the
-	 * lowest maximum link rate. */
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		phy = sci_port->phy_table[index];
-		if (
-			(phy != NULL)
-			&& (scic_sds_port_active_phy(sci_port, phy) == true)
-			&& (phy->max_negotiated_speed < max_allowed_speed)
-			)
-			max_allowed_speed = phy->max_negotiated_speed;
-	}
-
-	return max_allowed_speed;
-}
-
-
-/**
- * This method passes the event to core user.
- * @sci_port: The port that a BCN happens.
- * @sci_phy: The phy that receives BCN.
- *
- */
-void scic_sds_port_broadcast_change_received(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
-
-	/* notify the user. */
-	isci_port_bc_change_received(ihost, sci_port, sci_phy);
-}
-
-
-/**
- * This API methhod enables the broadcast change notification from underneath
- *    hardware.
- * @sci_port: The port that a BCN had been disabled from.
- *
- */
-void scic_port_enable_broadcast_change_notification(
-	struct scic_sds_port *port)
-{
-	struct scic_sds_phy *phy;
-	u32 register_value;
-	u8 index;
-
-	/* Loop through all of the phys to enable BCN. */
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		phy = port->phy_table[index];
-		if (phy != NULL) {
-			register_value =
-				readl(&phy->link_layer_registers->link_layer_control);
-
-			/* clear the bit by writing 1. */
-			writel(register_value,
-				&phy->link_layer_registers->link_layer_control);
-		}
-	}
-}
-
-/*
- * ****************************************************************************
- * *  READY SUBSTATE HANDLERS
- * **************************************************************************** */
-
-/*
- * This method is the general ready state stop handler for the struct scic_sds_port
- * object.  This function will transition the ready substate machine to its
- * final state. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_ready_substate_stop_handler(
-	struct scic_sds_port *port)
-{
-	sci_base_state_machine_change_state(
-		&port->state_machine,
-		SCI_BASE_PORT_STATE_STOPPING
-		);
-
-	return SCI_SUCCESS;
-}
-
-/*
- * This method is the general ready substate complete io handler for the
- * struct scic_sds_port object.  This function decrments the outstanding request count
- * for this port object. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_ready_substate_complete_io_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	scic_sds_port_decrement_request_count(port);
-
-	return SCI_SUCCESS;
-}
-
-static enum sci_status scic_sds_port_ready_substate_add_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	enum sci_status status;
-
-	status = scic_sds_port_set_phy(port, phy);
-
-	if (status == SCI_SUCCESS) {
-		scic_sds_port_general_link_up_handler(port, phy, true);
-
-		port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
-
-		sci_base_state_machine_change_state(
-			&port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
-			);
-	}
-
-	return status;
-}
-
-
-static enum sci_status scic_sds_port_ready_substate_remove_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	enum sci_status status;
-
-	status = scic_sds_port_clear_phy(port, phy);
-
-	if (status == SCI_SUCCESS) {
-		scic_sds_port_deactivate_phy(port, phy, true);
-
-		port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
-
-		sci_base_state_machine_change_state(
-			&port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
-			);
-	}
-
-	return status;
-}
-
-/*
- * ****************************************************************************
- * *  READY SUBSTATE WAITING HANDLERS
- * **************************************************************************** */
-
-/**
- *
- * @sci_port: This is the struct scic_sds_port object that which has a phy that has
- *    gone link up.
- * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
- *
- * This method is the ready waiting substate link up handler for the
- * struct scic_sds_port object.  This methos will report the link up condition for
- * this port and will transition to the ready operational substate. none
- */
-static void scic_sds_port_ready_waiting_substate_link_up_handler(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	/*
-	 * Since this is the first phy going link up for the port we can just enable
-	 * it and continue. */
-	scic_sds_port_activate_phy(sci_port, sci_phy, true);
-
-	sci_base_state_machine_change_state(
-		&sci_port->ready_substate_machine,
-		SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
-		);
-}
-
-/*
- * This method is the ready waiting substate start io handler for the
- * struct scic_sds_port object. The port object can not accept new requests so the
- * request is failed. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status scic_sds_port_ready_waiting_substate_start_io_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-/*
- * ****************************************************************************
- * *  READY SUBSTATE OPERATIONAL HANDLERS
- * **************************************************************************** */
-
-/*
- * This method will casue the port to reset. enum sci_status SCI_SUCCESS
- */
-static enum
-sci_status scic_sds_port_ready_operational_substate_reset_handler(
-		struct scic_sds_port *port,
-		u32 timeout)
-{
-	enum sci_status status = SCI_FAILURE_INVALID_PHY;
-	u32 phy_index;
-	struct scic_sds_phy *selected_phy = NULL;
-
-
-	/* Select a phy on which we can send the hard reset request. */
-	for (phy_index = 0;
-	     (phy_index < SCI_MAX_PHYS) && (selected_phy == NULL);
-	     phy_index++) {
-		selected_phy = port->phy_table[phy_index];
-
-		if ((selected_phy != NULL) &&
-		    !scic_sds_port_active_phy(port, selected_phy)) {
-			/*
-			 * We found a phy but it is not ready select
-			 * different phy
-			 */
-			selected_phy = NULL;
-		}
-	}
-
-	/* If we have a phy then go ahead and start the reset procedure */
-	if (selected_phy != NULL) {
-		status = scic_sds_phy_reset(selected_phy);
-
-		if (status == SCI_SUCCESS) {
-			isci_timer_start(port->timer_handle, timeout);
-			port->not_ready_reason =
-				SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
-
-			sci_base_state_machine_change_state(
-					&port->state_machine,
-					SCI_BASE_PORT_STATE_RESETTING);
-		}
-	}
-
-	return status;
-}
-
-/**
- * scic_sds_port_ready_operational_substate_link_up_handler() -
- * @sci_port: This is the struct scic_sds_port object that which has a phy that has
- *    gone link up.
- * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
- *
- * This method is the ready operational substate link up handler for the
- * struct scic_sds_port object. This function notifies the SCI User that the phy has
- * gone link up. none
- */
-static void scic_sds_port_ready_operational_substate_link_up_handler(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
-}
-
-/**
- * scic_sds_port_ready_operational_substate_link_down_handler() -
- * @sci_port: This is the struct scic_sds_port object that which has a phy that has
- *    gone link down.
- * @sci_phy: This is the struct scic_sds_phy object that has gone link down.
- *
- * This method is the ready operational substate link down handler for the
- * struct scic_sds_port object. This function notifies the SCI User that the phy has
- * gone link down and if this is the last phy in the port the port will change
- * state to the ready waiting substate. none
- */
-static void scic_sds_port_ready_operational_substate_link_down_handler(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
-
-	/*
-	 * If there are no active phys left in the port, then transition
-	 * the port to the WAITING state until such time as a phy goes
-	 * link up. */
-	if (sci_port->active_phy_mask == 0)
-		sci_base_state_machine_change_state(&sci_port->ready_substate_machine,
-						    SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
-}
-
-/*
- * This method is the ready operational substate start io handler for the
- * struct scic_sds_port object.  This function incremetns the outstanding request
- * count for this port object. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_ready_operational_substate_start_io_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	port->started_request_count++;
-	return SCI_SUCCESS;
-}
-
-/*
- * ****************************************************************************
- * *  READY SUBSTATE OPERATIONAL HANDLERS
- * **************************************************************************** */
-
-/*
- * This is the default method for a port add phy request.  It will report a
- * warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status scic_sds_port_ready_configuring_substate_add_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	enum sci_status status;
-
-	status = scic_sds_port_set_phy(port, phy);
-
-	if (status == SCI_SUCCESS) {
-		scic_sds_port_general_link_up_handler(port, phy, true);
-
-		/*
-		 * Re-enter the configuring state since this may be the last phy in
-		 * the port. */
-		sci_base_state_machine_change_state(
-			&port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
-			);
-	}
-
-	return status;
-}
-
-/*
- * This is the default method for a port remove phy request.  It will report a
- * warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status scic_sds_port_ready_configuring_substate_remove_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	enum sci_status status;
-
-	status = scic_sds_port_clear_phy(port, phy);
-
-	if (status == SCI_SUCCESS) {
-		scic_sds_port_deactivate_phy(port, phy, true);
-
-		/*
-		 * Re-enter the configuring state since this may be the last phy in
-		 * the port. */
-		sci_base_state_machine_change_state(
-			&port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
-			);
-	}
-
-	return status;
-}
-
-/**
- * scic_sds_port_ready_configuring_substate_complete_io_handler() -
- * @port: This is the port that is being requested to complete the io request.
- * @device: This is the device on which the io is completing.
- *
- * This method will decrement the outstanding request count for this port. If
- * the request count goes to 0 then the port can be reprogrammed with its new
- * phy data.
- */
-static enum sci_status
-scic_sds_port_ready_configuring_substate_complete_io_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	scic_sds_port_decrement_request_count(port);
-
-	if (port->started_request_count == 0) {
-		sci_base_state_machine_change_state(
-			&port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
-			);
-	}
-
-	return SCI_SUCCESS;
-}
-
-static enum sci_status default_port_handler(struct scic_sds_port *sci_port,
-					    const char *func)
-{
-	dev_warn(sciport_to_dev(sci_port),
-		 "%s: in wrong state: %d\n", func,
-		 sci_base_state_machine_get_state(&sci_port->state_machine));
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status
-scic_sds_port_default_start_handler(struct scic_sds_port *sci_port)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-static enum sci_status
-scic_sds_port_default_stop_handler(struct scic_sds_port *sci_port)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-static enum sci_status
-scic_sds_port_default_destruct_handler(struct scic_sds_port *sci_port)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-static enum sci_status
-scic_sds_port_default_reset_handler(struct scic_sds_port *sci_port,
-				    u32 timeout)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-static enum sci_status
-scic_sds_port_default_add_phy_handler(struct scic_sds_port *sci_port,
-				      struct scic_sds_phy *base_phy)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-static enum sci_status
-scic_sds_port_default_remove_phy_handler(struct scic_sds_port *sci_port,
-					 struct scic_sds_phy *base_phy)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-/*
- * This is the default method for a port unsolicited frame request.  It will
- * report a warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE Is it even
- * possible to receive an unsolicited frame directed to a port object?  It
- * seems possible if we implementing virtual functions but until then?
- */
-static enum sci_status
-scic_sds_port_default_frame_handler(struct scic_sds_port *sci_port,
-				    u32 frame_index)
-{
-	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
-
-	default_port_handler(sci_port, __func__);
-	scic_sds_controller_release_frame(scic, frame_index);
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status scic_sds_port_default_event_handler(struct scic_sds_port *sci_port,
-						    u32 event_code)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-static void scic_sds_port_default_link_up_handler(struct scic_sds_port *sci_port,
-					   struct scic_sds_phy *sci_phy)
-{
-	default_port_handler(sci_port, __func__);
-}
-
-static void scic_sds_port_default_link_down_handler(struct scic_sds_port *sci_port,
-					     struct scic_sds_phy *sci_phy)
-{
-	default_port_handler(sci_port, __func__);
-}
-
-static enum sci_status scic_sds_port_default_start_io_handler(struct scic_sds_port *sci_port,
-						       struct scic_sds_remote_device *sci_dev,
-						       struct scic_sds_request *sci_req)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-static enum sci_status scic_sds_port_default_complete_io_handler(struct scic_sds_port *sci_port,
-								 struct scic_sds_remote_device *sci_dev,
-								 struct scic_sds_request *sci_req)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-
-
-static struct scic_sds_port_state_handler
-scic_sds_port_ready_substate_handler_table[SCIC_SDS_PORT_READY_MAX_SUBSTATES] = {
-	{
-		/* SCIC_SDS_PORT_READY_SUBSTATE_WAITING */
-		scic_sds_port_default_start_handler,
-		scic_sds_port_ready_substate_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_ready_substate_add_phy_handler,
-		scic_sds_port_default_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_ready_waiting_substate_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_ready_waiting_substate_start_io_handler,
-		scic_sds_port_ready_substate_complete_io_handler,
-	},
-
-	{
-		/* SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL */
-		scic_sds_port_default_start_handler,
-		scic_sds_port_ready_substate_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_ready_operational_substate_reset_handler,
-		scic_sds_port_ready_substate_add_phy_handler,
-		scic_sds_port_ready_substate_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_ready_operational_substate_link_up_handler,
-		scic_sds_port_ready_operational_substate_link_down_handler,
-		scic_sds_port_ready_operational_substate_start_io_handler,
-		scic_sds_port_ready_substate_complete_io_handler,
-	},
-
-	{
-		/* SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING */
-		scic_sds_port_default_start_handler,
-		scic_sds_port_ready_substate_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_ready_configuring_substate_add_phy_handler,
-		scic_sds_port_ready_configuring_substate_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_default_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_ready_configuring_substate_complete_io_handler
-	}
-};
-
-/**
- * scic_sds_port_set_ready_state_handlers() -
- *
- * This macro sets the port ready substate handlers.
- */
-#define scic_sds_port_set_ready_state_handlers(port, state_id) \
-	scic_sds_port_set_state_handlers(\
-		port, &scic_sds_port_ready_substate_handler_table[(state_id)] \
-		)
-
-/*
- * ******************************************************************************
- * *  PORT STATE PRIVATE METHODS
- * ****************************************************************************** */
-
-/**
- *
- * @sci_port: This is the struct scic_sds_port object to suspend.
- *
- * This method will susped the port task scheduler for this port object. none
- */
-static void
-scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port)
-{
-	u32 pts_control_value;
-
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
-	pts_control_value |= SCU_PTSxCR_GEN_BIT(SUSPEND);
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
-}
-
-/**
- * scic_sds_port_post_dummy_request() - post dummy/workaround request
- * @sci_port: port to post task
- *
- * Prevent the hardware scheduler from posting new requests to the front
- * of the scheduler queue causing a starvation problem for currently
- * ongoing requests.
- *
- */
-static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
-{
-	u32 command;
-	struct scu_task_context *task_context;
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u16 tci = sci_port->reserved_tci;
-
-	task_context = scic_sds_controller_get_task_context_buffer(scic, tci);
-
-	task_context->abort = 0;
-
-	command = SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
-		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
-		  tci;
-
-	scic_sds_controller_post_request(scic, command);
-}
-
-/**
- * This routine will abort the dummy request.  This will alow the hardware to
- * power down parts of the silicon to save power.
- *
- * @sci_port: The port on which the task must be aborted.
- *
- */
-static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
-{
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u16 tci = sci_port->reserved_tci;
-	struct scu_task_context *tc;
-	u32 command;
-
-	tc = scic_sds_controller_get_task_context_buffer(scic, tci);
-
-	tc->abort = 1;
-
-	command = SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT |
-		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
-		  tci;
-
-	scic_sds_controller_post_request(scic, command);
-}
-
-/**
- *
- * @sci_port: This is the struct scic_sds_port object to resume.
- *
- * This method will resume the port task scheduler for this port object. none
- */
-static void
-scic_sds_port_resume_port_task_scheduler(struct scic_sds_port *port)
-{
-	u32 pts_control_value;
-
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
-	pts_control_value &= ~SCU_PTSxCR_GEN_BIT(SUSPEND);
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
-}
-
-/*
- * ******************************************************************************
- * *  PORT READY SUBSTATE METHODS
- * ****************************************************************************** */
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCIC_SDS_PORT_READY_SUBSTATE_WAITING. This function checks the
- * port for any ready phys.  If there is at least one phy in a ready state then
- * the port transitions to the ready operational substate. none
- */
-static void scic_sds_port_ready_substate_waiting_enter(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	scic_sds_port_set_ready_state_handlers(
-		sci_port, SCIC_SDS_PORT_READY_SUBSTATE_WAITING
-		);
-
-	scic_sds_port_suspend_port_task_scheduler(sci_port);
-
-	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
-
-	if (sci_port->active_phy_mask != 0) {
-		/* At least one of the phys on the port is ready */
-		sci_base_state_machine_change_state(
-			&sci_port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
-			);
-	}
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This function will perform the actions required by the struct scic_sds_port
- * on entering the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function sets
- * the state handlers for the port object, notifies the SCI User that the port
- * is ready, and resumes port operations. none
- */
-static void scic_sds_port_ready_substate_operational_enter(void *object)
-{
-	u32 index;
-	struct scic_sds_port *sci_port = object;
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
-
-	scic_sds_port_set_ready_state_handlers(
-			sci_port,
-			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
-
-	isci_port_ready(ihost, iport);
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index]) {
-			writel(sci_port->physical_port_index,
-				&sci_port->port_pe_configuration_register[
-					sci_port->phy_table[index]->phy_index]);
-		}
-	}
-
-	scic_sds_port_update_viit_entry(sci_port);
-
-	scic_sds_port_resume_port_task_scheduler(sci_port);
-
-	/*
-	 * Post the dummy task for the port so the hardware can schedule
-	 * io correctly
-	 */
-	scic_sds_port_post_dummy_request(sci_port);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * exiting the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function reports
- * the port not ready and suspends the port task scheduler. none
- */
-static void scic_sds_port_ready_substate_operational_exit(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
-
-	/*
-	 * Kill the dummy task for this port if it has not yet posted
-	 * the hardware will treat this as a NOP and just return abort
-	 * complete.
-	 */
-	scic_sds_port_abort_dummy_request(sci_port);
-
-	isci_port_not_ready(ihost, iport);
-}
-
-/*
- * ******************************************************************************
- * *  PORT READY CONFIGURING METHODS
- * ****************************************************************************** */
-
-/**
- * scic_sds_port_ready_substate_configuring_enter() -
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * exiting the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function reports
- * the port not ready and suspends the port task scheduler. none
- */
-static void scic_sds_port_ready_substate_configuring_enter(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
-
-	scic_sds_port_set_ready_state_handlers(
-			sci_port,
-			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
-
-	if (sci_port->active_phy_mask == 0) {
-		isci_port_not_ready(ihost, iport);
-
-		sci_base_state_machine_change_state(
-				&sci_port->ready_substate_machine,
-				SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
-	} else if (sci_port->started_request_count == 0)
-		sci_base_state_machine_change_state(
-				&sci_port->ready_substate_machine,
-				SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
-}
-
-static void scic_sds_port_ready_substate_configuring_exit(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	scic_sds_port_suspend_port_task_scheduler(sci_port);
-}
-
-/* --------------------------------------------------------------------------- */
-
-static const struct sci_base_state scic_sds_port_ready_substate_table[] = {
-	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
-		.enter_state = scic_sds_port_ready_substate_waiting_enter,
-	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
-		.enter_state = scic_sds_port_ready_substate_operational_enter,
-		.exit_state  = scic_sds_port_ready_substate_operational_exit
-	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
-		.enter_state = scic_sds_port_ready_substate_configuring_enter,
-		.exit_state  = scic_sds_port_ready_substate_configuring_exit
-	},
-};
-
-/**
- *
- * @port: This is the struct scic_sds_port object on which the io request count will
- *    be decremented.
- * @device: This is the struct scic_sds_remote_device object to which the io request
- *    is being directed.  This parameter is not required to complete this
- *    operation.
- * @io_request: This is the request that is being completed on this port
- *    object.  This parameter is not required to complete this operation.
- *
- * This is a general complete io request handler for the struct scic_sds_port object.
- * enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_general_complete_io_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	scic_sds_port_decrement_request_count(port);
-
-	return SCI_SUCCESS;
-}
-
-/**
- * scic_sds_port_stopped_state_start_handler() - stop a port from "started"
- *
- * @port: This is the struct scic_sds_port object which is cast into a
- * struct scic_sds_port object.
- *
- * This function takes the struct scic_sds_port from a stopped state and
- * attempts to start it.  To start a port it must have no assiged devices and
- * it must have at least one phy assigned to it.  If those conditions are
- * met then the port can transition to the ready state.
- * enum sci_status
- * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
- * This struct scic_sds_port object could not be started because the port
- * configuration is not valid.
- * SCI_SUCCESS
- * the start request is successful and the struct scic_sds_port object
- * has transitioned to the SCI_BASE_PORT_STATE_READY.
- */
-static enum sci_status
-scic_sds_port_stopped_state_start_handler(struct scic_sds_port *sci_port)
-{
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
-	enum sci_status status = SCI_SUCCESS;
-	u32 phy_mask;
-
-	if (sci_port->assigned_device_count > 0) {
-		/*
-		 * @todo This is a start failure operation because
-		 * there are still devices assigned to this port.
-		 * There must be no devices assigned to a port on a
-		 * start operation.
-		 */
-		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-	}
-
-	sci_port->timer_handle =
-		isci_timer_create(ihost,
-				  sci_port,
-				  scic_sds_port_timeout_handler);
-
-	if (!sci_port->timer_handle)
-		return SCI_FAILURE_INSUFFICIENT_RESOURCES;
-
-	if (sci_port->reserved_rni == SCU_DUMMY_INDEX) {
-		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
-				&scic->available_remote_nodes, 1);
-
-		if (rni != SCU_DUMMY_INDEX)
-			scic_sds_port_construct_dummy_rnc(sci_port, rni);
-		else
-			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
-		sci_port->reserved_rni = rni;
-	}
-
-	if (sci_port->reserved_tci == SCU_DUMMY_INDEX) {
-		/* Allocate a TCI and remove the sequence nibble */
-		u16 tci = scic_controller_allocate_io_tag(scic);
-
-		if (tci != SCU_DUMMY_INDEX)
-			scic_sds_port_construct_dummy_task(sci_port, tci);
-		else
-			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
-		sci_port->reserved_tci = tci;
-	}
-
-	if (status == SCI_SUCCESS) {
-		phy_mask = scic_sds_port_get_phys(sci_port);
-
-		/*
-		 * There are one or more phys assigned to this port.  Make sure
-		 * the port's phy mask is in fact legal and supported by the
-		 * silicon.
-		 */
-		if (scic_sds_port_is_phy_mask_valid(sci_port, phy_mask) == true) {
-			sci_base_state_machine_change_state(
-				&sci_port->state_machine,
-				SCI_BASE_PORT_STATE_READY);
-
-			return SCI_SUCCESS;
-		} else
-			status = SCI_FAILURE;
-	}
-
-	if (status != SCI_SUCCESS)
-		scic_sds_port_destroy_dummy_resources(sci_port);
-
-	return status;
-}
-
-/*
- * This method takes the struct scic_sds_port that is in a stopped state and handles a
- * stop request.  This function takes no action. enum sci_status SCI_SUCCESS the
- * stop request is successful as the struct scic_sds_port object is already stopped.
- */
-static enum sci_status scic_sds_port_stopped_state_stop_handler(
-	struct scic_sds_port *port)
-{
-	/* We are already stopped so there is nothing to do here */
-	return SCI_SUCCESS;
-}
-
-/*
- * This method takes the struct scic_sds_port that is in a stopped state and handles
- * the destruct request.  The stopped state is the only state in which the
- * struct scic_sds_port can be destroyed.  This function causes the port object to
- * transition to the SCI_BASE_PORT_STATE_FINAL. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_stopped_state_destruct_handler(
-	struct scic_sds_port *port)
-{
-	sci_base_state_machine_stop(&port->state_machine);
-
-	return SCI_SUCCESS;
-}
-
-/*
- * This method takes the struct scic_sds_port that is in a stopped state and handles
- * the add phy request.  In MPC mode the only time a phy can be added to a port
- * is in the SCI_BASE_PORT_STATE_STOPPED. enum sci_status
- * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION is returned when the phy can not
- * be added to the port. SCI_SUCCESS if the phy is added to the port.
- */
-static enum sci_status scic_sds_port_stopped_state_add_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	struct sci_sas_address port_sas_address;
-
-	/* Read the port assigned SAS Address if there is one */
-	scic_sds_port_get_sas_address(port, &port_sas_address);
-
-	if (port_sas_address.high != 0 && port_sas_address.low != 0) {
-		struct sci_sas_address phy_sas_address;
-
-		/*
-		 * Make sure that the PHY SAS Address matches the SAS Address
-		 * for this port. */
-		scic_sds_phy_get_sas_address(phy, &phy_sas_address);
-
-		if (
-			(port_sas_address.high != phy_sas_address.high)
-			|| (port_sas_address.low  != phy_sas_address.low)
-			) {
-			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-		}
-	}
-
-	return scic_sds_port_set_phy(port, phy);
-}
-
-/*
- * This method takes the struct scic_sds_port that is in a stopped state and handles
- * the remove phy request.  In MPC mode the only time a phy can be removed from
- * a port is in the SCI_BASE_PORT_STATE_STOPPED. enum sci_status
- * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION is returned when the phy can not
- * be added to the port. SCI_SUCCESS if the phy is added to the port.
- */
-static enum sci_status scic_sds_port_stopped_state_remove_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	return scic_sds_port_clear_phy(port, phy);
-}
-
-/*
- * ****************************************************************************
- * *  READY STATE HANDLERS
- * **************************************************************************** */
-
-/*
- * ****************************************************************************
- * *  RESETTING STATE HANDLERS
- * **************************************************************************** */
-
-/*
- * ****************************************************************************
- * *  STOPPING STATE HANDLERS
- * **************************************************************************** */
-
-/*
- * This method takes the struct scic_sds_port that is in a stopping state and handles
- * the complete io request. Should the request count reach 0 then the port
- * object will transition to the stopped state. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_stopping_state_complete_io_handler(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	scic_sds_port_decrement_request_count(sci_port);
-
-	if (sci_port->started_request_count == 0) {
-		sci_base_state_machine_change_state(&sci_port->state_machine,
-						    SCI_BASE_PORT_STATE_STOPPED);
-	}
-
-	return SCI_SUCCESS;
-}
-
-/*
- * ****************************************************************************
- * *  RESETTING STATE HANDLERS
- * **************************************************************************** */
-
-/**
- *
- * @port: This is the port object which is being requested to stop.
- *
- * This method will stop a failed port.  This causes a transition to the
- * stopping state. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_reset_state_stop_handler(
-	struct scic_sds_port *port)
-{
-	sci_base_state_machine_change_state(
-		&port->state_machine,
-		SCI_BASE_PORT_STATE_STOPPING
-		);
-
-	return SCI_SUCCESS;
-}
-
-/*
- * This method will transition a failed port to its ready state.  The port
- * failed because a hard reset request timed out but at some time later one or
- * more phys in the port became ready. enum sci_status SCI_SUCCESS
- */
-static void scic_sds_port_reset_state_link_up_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	/*
-	 * / @todo We should make sure that the phy that has gone link up is the same
-	 * /       one on which we sent the reset.  It is possible that the phy on
-	 * /       which we sent the reset is not the one that has gone link up and we
-	 * /       want to make sure that phy being reset comes back.  Consider the
-	 * /       case where a reset is sent but before the hardware processes the
-	 * /       reset it get a link up on the port because of a hot plug event.
-	 * /       because of the reset request this phy will go link down almost
-	 * /       immediately. */
-
-	/*
-	 * In the resetting state we don't notify the user regarding
-	 * link up and link down notifications. */
-	scic_sds_port_general_link_up_handler(port, phy, false);
-}
-
-/*
- * This method process link down notifications that occur during a port reset
- * operation. Link downs can occur during the reset operation. enum sci_status
- * SCI_SUCCESS
- */
-static void scic_sds_port_reset_state_link_down_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	/*
-	 * In the resetting state we don't notify the user regarding
-	 * link up and link down notifications. */
-	scic_sds_port_deactivate_phy(port, phy, false);
-}
-
-static struct scic_sds_port_state_handler
-scic_sds_port_state_handler_table[SCI_BASE_PORT_MAX_STATES] =
-{
-	/* SCI_BASE_PORT_STATE_STOPPED */
-	{
-		scic_sds_port_stopped_state_start_handler,
-		scic_sds_port_stopped_state_stop_handler,
-		scic_sds_port_stopped_state_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_stopped_state_add_phy_handler,
-		scic_sds_port_stopped_state_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_default_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_default_complete_io_handler
-	},
-	/* SCI_BASE_PORT_STATE_STOPPING */
-	{
-		scic_sds_port_default_start_handler,
-		scic_sds_port_default_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_default_add_phy_handler,
-		scic_sds_port_default_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_default_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_stopping_state_complete_io_handler
-	},
-	/* SCI_BASE_PORT_STATE_READY */
-	{
-		scic_sds_port_default_start_handler,
-		scic_sds_port_default_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_default_add_phy_handler,
-		scic_sds_port_default_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_default_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_general_complete_io_handler
-	},
-	/* SCI_BASE_PORT_STATE_RESETTING */
-	{
-		scic_sds_port_default_start_handler,
-		scic_sds_port_reset_state_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_default_add_phy_handler,
-		scic_sds_port_default_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_reset_state_link_up_handler,
-		scic_sds_port_reset_state_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_general_complete_io_handler
-	},
-	/* SCI_BASE_PORT_STATE_FAILED */
-	{
-		scic_sds_port_default_start_handler,
-		scic_sds_port_default_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_default_add_phy_handler,
-		scic_sds_port_default_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_default_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_general_complete_io_handler
-	}
-};
-
-/*
- * ******************************************************************************
- * *  PORT STATE PRIVATE METHODS
- * ****************************************************************************** */
-
-/**
- *
- * @sci_port: This is the port object which to suspend.
- *
- * This method will enable the SCU Port Task Scheduler for this port object but
- * will leave the port task scheduler in a suspended state. none
- */
-static void
-scic_sds_port_enable_port_task_scheduler(struct scic_sds_port *port)
-{
-	u32 pts_control_value;
-
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
-	pts_control_value |= SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND);
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
-}
-
-/**
- *
- * @sci_port: This is the port object which to resume.
- *
- * This method will disable the SCU port task scheduler for this port object.
- * none
- */
-static void
-scic_sds_port_disable_port_task_scheduler(struct scic_sds_port *port)
-{
-	u32 pts_control_value;
-
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
-	pts_control_value &=
-		~(SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND));
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
-}
-
-static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
-{
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u8 phys_index = sci_port->physical_port_index;
-	union scu_remote_node_context *rnc;
-	u16 rni = sci_port->reserved_rni;
-	u32 command;
-
-	rnc = &scic->remote_node_context_table[rni];
-	rnc->ssp.is_valid = true;
-
-	command = SCU_CONTEXT_COMMAND_POST_RNC_32 |
-		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
-
-	scic_sds_controller_post_request(scic, command);
-
-	/* ensure hardware has seen the post rnc command and give it
-	 * ample time to act before sending the suspend
-	 */
-	readl(&scic->smu_registers->interrupt_status); /* flush */
-	udelay(10);
-
-	command = SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX_RX |
-		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
-
-	scic_sds_controller_post_request(scic, command);
-}
-
-static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci_port)
-{
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u8 phys_index = sci_port->physical_port_index;
-	union scu_remote_node_context *rnc;
-	u16 rni = sci_port->reserved_rni;
-	u32 command;
-
-	rnc = &scic->remote_node_context_table[rni];
-
-	rnc->ssp.is_valid = false;
-
-	/* ensure the preceding tc abort request has reached the
-	 * controller and give it ample time to act before posting the rnc
-	 * invalidate
-	 */
-	readl(&scic->smu_registers->interrupt_status); /* flush */
-	udelay(10);
-
-	command = SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE |
-		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
-
-	scic_sds_controller_post_request(scic, command);
-}
-
-/*
- * ******************************************************************************
- * *  PORT STATE METHODS
- * ****************************************************************************** */
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCI_BASE_PORT_STATE_STOPPED. This function sets the stopped
- * state handlers for the struct scic_sds_port object and disables the port task
- * scheduler in the hardware. none
- */
-static void scic_sds_port_stopped_state_enter(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	scic_sds_port_set_base_state_handlers(
-		sci_port, SCI_BASE_PORT_STATE_STOPPED
-		);
-
-	if (
-		SCI_BASE_PORT_STATE_STOPPING
-		== sci_port->state_machine.previous_state_id
-		) {
-		/*
-		 * If we enter this state becasuse of a request to stop
-		 * the port then we want to disable the hardwares port
-		 * task scheduler. */
-		scic_sds_port_disable_port_task_scheduler(sci_port);
-	}
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * exiting the SCI_BASE_STATE_STOPPED. This function enables the SCU hardware
- * port task scheduler. none
- */
-static void scic_sds_port_stopped_state_exit(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	/* Enable and suspend the port task scheduler */
-	scic_sds_port_enable_port_task_scheduler(sci_port);
-}
-
-/**
- * scic_sds_port_ready_state_enter -
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCI_BASE_PORT_STATE_READY. This function sets the ready state
- * handlers for the struct scic_sds_port object, reports the port object as
- * not ready and starts the ready substate machine. none
- */
-static void scic_sds_port_ready_state_enter(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
-	u32 prev_state;
-
-	/* Put the ready state handlers in place though they will not be there long */
-	scic_sds_port_set_base_state_handlers(sci_port, SCI_BASE_PORT_STATE_READY);
-
-	prev_state = sci_port->state_machine.previous_state_id;
-	if (prev_state  == SCI_BASE_PORT_STATE_RESETTING)
-		isci_port_hard_reset_complete(iport, SCI_SUCCESS);
-	else
-		isci_port_not_ready(ihost, iport);
-
-	/* Post and suspend the dummy remote node context for this port. */
-	scic_sds_port_post_dummy_remote_node(sci_port);
-
-	/* Start the ready substate machine */
-	sci_base_state_machine_start(&sci_port->ready_substate_machine);
-}
-
-static void scic_sds_port_ready_state_exit(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	sci_base_state_machine_stop(&sci_port->ready_substate_machine);
-	scic_sds_port_invalidate_dummy_remote_node(sci_port);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCI_BASE_PORT_STATE_RESETTING. This function sets the resetting
- * state handlers for the struct scic_sds_port object. none
- */
-static void scic_sds_port_resetting_state_enter(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	scic_sds_port_set_base_state_handlers(
-		sci_port, SCI_BASE_PORT_STATE_RESETTING
-		);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This function will perform the actions required by the
- * struct scic_sds_port on
- * exiting the SCI_BASE_STATE_RESETTING. This function does nothing. none
- */
-static inline void scic_sds_port_resetting_state_exit(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	isci_timer_stop(sci_port->timer_handle);
-}
-
-/**
- *
- * @object: This is the void object which is cast to a
- * struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCI_BASE_PORT_STATE_STOPPING. This function sets the stopping
- * state handlers for the struct scic_sds_port object. none
- */
-static void scic_sds_port_stopping_state_enter(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	scic_sds_port_set_base_state_handlers(
-		sci_port, SCI_BASE_PORT_STATE_STOPPING
-		);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This function will perform the actions required by the
- * struct scic_sds_port on
- * exiting the SCI_BASE_STATE_STOPPING. This function does nothing. none
- */
-static inline void
-scic_sds_port_stopping_state_exit(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	isci_timer_stop(sci_port->timer_handle);
-
-	scic_sds_port_destroy_dummy_resources(sci_port);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This function will perform the actions required by the
- * struct scic_sds_port on
- * entering the SCI_BASE_PORT_STATE_STOPPING. This function sets the stopping
- * state handlers for the struct scic_sds_port object. none
- */
-static void scic_sds_port_failed_state_enter(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-	struct isci_port *iport = sci_port_to_iport(sci_port);
-
-	scic_sds_port_set_base_state_handlers(sci_port,
-					      SCI_BASE_PORT_STATE_FAILED);
-
-	isci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);
-}
-
-/* --------------------------------------------------------------------------- */
-
-static const struct sci_base_state scic_sds_port_state_table[] = {
-	[SCI_BASE_PORT_STATE_STOPPED] = {
-		.enter_state = scic_sds_port_stopped_state_enter,
-		.exit_state  = scic_sds_port_stopped_state_exit
-	},
-	[SCI_BASE_PORT_STATE_STOPPING] = {
-		.enter_state = scic_sds_port_stopping_state_enter,
-		.exit_state  = scic_sds_port_stopping_state_exit
-	},
-	[SCI_BASE_PORT_STATE_READY] = {
-		.enter_state = scic_sds_port_ready_state_enter,
-		.exit_state  = scic_sds_port_ready_state_exit
-	},
-	[SCI_BASE_PORT_STATE_RESETTING] = {
-		.enter_state = scic_sds_port_resetting_state_enter,
-		.exit_state  = scic_sds_port_resetting_state_exit
-	},
-	[SCI_BASE_PORT_STATE_FAILED] = {
-		.enter_state = scic_sds_port_failed_state_enter,
-	}
-};
-
-void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
-			     struct scic_sds_controller *scic)
-{
-	sci_base_state_machine_construct(&sci_port->state_machine,
-					 sci_port,
-					 scic_sds_port_state_table,
-					 SCI_BASE_PORT_STATE_STOPPED);
-
-	sci_base_state_machine_start(&sci_port->state_machine);
-
-	sci_base_state_machine_construct(&sci_port->ready_substate_machine,
-					 sci_port,
-					 scic_sds_port_ready_substate_table,
-					 SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
-
-	sci_port->logical_port_index  = SCIC_SDS_DUMMY_PORT;
-	sci_port->physical_port_index = index;
-	sci_port->active_phy_mask     = 0;
-
-	sci_port->owning_controller = scic;
-
-	sci_port->started_request_count = 0;
-	sci_port->assigned_device_count = 0;
-
-	sci_port->reserved_rni = SCU_DUMMY_INDEX;
-	sci_port->reserved_tci = SCU_DUMMY_INDEX;
-
-	sci_port->timer_handle = NULL;
-	sci_port->port_task_scheduler_registers = NULL;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++)
-		sci_port->phy_table[index] = NULL;
-}
diff --git a/drivers/scsi/isci/core/scic_sds_port.h b/drivers/scsi/isci/core/scic_sds_port.h
deleted file mode 100644
index a351525..0000000
--- a/drivers/scsi/isci/core/scic_sds_port.h
+++ /dev/null
@@ -1,435 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCIC_SDS_PORT_H_
-#define _SCIC_SDS_PORT_H_
-
-#include <linux/kernel.h>
-#include "isci.h"
-#include "sas.h"
-#include "registers.h"
-#include "state_machine.h"
-
-struct scic_sds_controller;
-struct scic_sds_phy;
-struct scic_sds_remote_device;
-struct scic_sds_request;
-
-#define SCIC_SDS_DUMMY_PORT   0xFF
-
-/**
- * enum SCIC_SDS_PORT_READY_SUBSTATES -
- *
- * This enumeration depicts all of the states for the core port ready substate
- * machine.
- */
-enum scic_sds_port_ready_substates {
-	/**
-	 * The substate where the port is started and ready but has no
-	 * active phys.
-	 */
-	SCIC_SDS_PORT_READY_SUBSTATE_WAITING,
-
-	/**
-	 * The substate where the port is started and ready and there is
-	 * at least one phy operational.
-	 */
-	SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL,
-
-	/**
-	 * The substate where the port is started and there was an
-	 * add/remove phy event.  This state is only used in Automatic
-	 * Port Configuration Mode (APC)
-	 */
-	SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING,
-
-	SCIC_SDS_PORT_READY_MAX_SUBSTATES
-};
-
-/**
- * enum scic_sds_port_states - This enumeration depicts all the states for the
- *    common port state machine.
- *
- *
- */
-enum scic_sds_port_states {
-	/**
-	 * This state indicates that the port has successfully been stopped.
-	 * In this state no new IO operations are permitted.
-	 * This state is entered from the STOPPING state.
-	 */
-	SCI_BASE_PORT_STATE_STOPPED,
-
-	/**
-	 * This state indicates that the port is in the process of stopping.
-	 * In this state no new IO operations are permitted, but existing IO
-	 * operations are allowed to complete.
-	 * This state is entered from the READY state.
-	 */
-	SCI_BASE_PORT_STATE_STOPPING,
-
-	/**
-	 * This state indicates the port is now ready.  Thus, the user is
-	 * able to perform IO operations on this port.
-	 * This state is entered from the STARTING state.
-	 */
-	SCI_BASE_PORT_STATE_READY,
-
-	/**
-	 * This state indicates the port is in the process of performing a hard
-	 * reset.  Thus, the user is unable to perform IO operations on this
-	 * port.
-	 * This state is entered from the READY state.
-	 */
-	SCI_BASE_PORT_STATE_RESETTING,
-
-	/**
-	 * This state indicates the port has failed a reset request.  This state
-	 * is entered when a port reset request times out.
-	 * This state is entered from the RESETTING state.
-	 */
-	SCI_BASE_PORT_STATE_FAILED,
-
-	SCI_BASE_PORT_MAX_STATES
-
-};
-
-/**
- * struct scic_sds_port
- *
- * The core port object provides the the abstraction for an SCU port.
- */
-struct scic_sds_port {
-
-	/**
-	 * This field contains the information for the base port state machine.
-	 */
-	struct sci_base_state_machine state_machine;
-
-	/**
-	 * This field is the port index that is reported to the SCI USER.
-	 * This allows the actual hardware physical port to change without
-	 * the SCI USER getting a different answer for the get port index.
-	 */
-	u8 logical_port_index;
-
-	/**
-	 * This field is the port index used to program the SCU hardware.
-	 */
-	u8 physical_port_index;
-
-	/**
-	 * This field contains the active phy mask for the port.
-	 * This mask is used in conjunction with the phy state to determine
-	 * which phy to select for some port operations.
-	 */
-	u8 active_phy_mask;
-
-	u16 reserved_rni;
-	u16 reserved_tci;
-
-	/**
-	 * This field contains the count of the io requests started on this port
-	 * object.  It is used to control controller shutdown.
-	 */
-	u32 started_request_count;
-
-	/**
-	 * This field contains the number of devices assigned to this port.
-	 * It is used to control port start requests.
-	 */
-	u32 assigned_device_count;
-
-	/**
-	 * This field contains the reason for the port not going ready.  It is
-	 * assigned in the state handlers and used in the state transition.
-	 */
-	u32 not_ready_reason;
-
-	/**
-	 * This field is the table of phys assigned to the port.
-	 */
-	struct scic_sds_phy *phy_table[SCI_MAX_PHYS];
-
-	/**
-	 * This field is a pointer back to the controller that owns this
-	 * port object.
-	 */
-	struct scic_sds_controller *owning_controller;
-
-	/**
-	 * This field contains the port start/stop timer handle.
-	 */
-	void *timer_handle;
-
-	/**
-	 * This field points to the current set of state handlers for this port
-	 * object.  These state handlers are assigned at each enter state of
-	 * the state machine.
-	 */
-	struct scic_sds_port_state_handler *state_handlers;
-
-	/**
-	 * This field is the ready substate machine for the port.
-	 */
-	struct sci_base_state_machine ready_substate_machine;
-
-	/* / Memory mapped hardware register space */
-
-	/**
-	 * This field is the pointer to the port task scheduler registers
-	 * for the SCU hardware.
-	 */
-	struct scu_port_task_scheduler_registers __iomem
-		*port_task_scheduler_registers;
-
-	/**
-	 * This field is identical for all port objects and points to the port
-	 * task scheduler group PE configuration registers.
-	 * It is used to assign PEs to a port.
-	 */
-	u32 __iomem *port_pe_configuration_register;
-
-	/**
-	 * This field is the VIIT register space for ths port object.
-	 */
-	struct scu_viit_entry __iomem *viit_registers;
-
-};
-
-typedef enum sci_status (*scic_sds_port_handler_t)(struct scic_sds_port *);
-
-typedef enum sci_status (*scic_sds_port_phy_handler_t)(struct scic_sds_port *,
-						       struct scic_sds_phy *);
-
-typedef enum sci_status (*scic_sds_port_reset_handler_t)(struct scic_sds_port *,
-							 u32 timeout);
-
-typedef enum sci_status (*scic_sds_port_event_handler_t)(struct scic_sds_port *, u32);
-
-typedef enum sci_status (*scic_sds_port_frame_handler_t)(struct scic_sds_port *, u32);
-
-typedef void (*scic_sds_port_link_handler_t)(struct scic_sds_port *, struct scic_sds_phy *);
-
-typedef enum sci_status (*scic_sds_port_io_request_handler_t)(struct scic_sds_port *,
-							      struct scic_sds_remote_device *,
-							      struct scic_sds_request *);
-
-struct scic_sds_port_state_handler {
-	/**
-	 * The start_handler specifies the method invoked when a user
-	 * attempts to start a port.
-	 */
-	scic_sds_port_handler_t start_handler;
-
-	/**
-	 * The stop_handler specifies the method invoked when a user
-	 * attempts to stop a port.
-	 */
-	scic_sds_port_handler_t stop_handler;
-
-	/**
-	 * The destruct_handler specifies the method invoked when attempting to
-	 * destruct a port.
-	 */
-	scic_sds_port_handler_t destruct_handler;
-
-	/**
-	 * The reset_handler specifies the method invoked when a user
-	 * attempts to hard reset a port.
-	 */
-	scic_sds_port_reset_handler_t reset_handler;
-
-	/**
-	 * The add_phy_handler specifies the method invoked when a user
-	 * attempts to add another phy into the port.
-	 */
-	scic_sds_port_phy_handler_t add_phy_handler;
-
-	/**
-	 * The remove_phy_handler specifies the method invoked when a user
-	 * attempts to remove a phy from the port.
-	 */
-	scic_sds_port_phy_handler_t remove_phy_handler;
-
-	scic_sds_port_frame_handler_t frame_handler;
-	scic_sds_port_event_handler_t event_handler;
-
-	scic_sds_port_link_handler_t link_up_handler;
-	scic_sds_port_link_handler_t link_down_handler;
-
-	scic_sds_port_io_request_handler_t start_io_handler;
-	scic_sds_port_io_request_handler_t complete_io_handler;
-
-};
-
-/**
- * scic_sds_port_get_controller() -
- *
- * Helper macro to get the owning controller of this port
- */
-#define scic_sds_port_get_controller(this_port)	\
-	((this_port)->owning_controller)
-
-/**
- * scic_sds_port_set_base_state_handlers() -
- *
- * This macro will change the state handlers to those of the specified state id
- */
-#define scic_sds_port_set_base_state_handlers(this_port, state_id) \
-	scic_sds_port_set_state_handlers(\
-		(this_port), &scic_sds_port_state_handler_table[(state_id)])
-
-/**
- * scic_sds_port_set_state_handlers() -
- *
- * Helper macro to set the port object state handlers
- */
-#define scic_sds_port_set_state_handlers(this_port, handlers) \
-	((this_port)->state_handlers = (handlers))
-
-/**
- * scic_sds_port_get_index() -
- *
- * This macro returns the physical port index for this port object
- */
-#define scic_sds_port_get_index(this_port) \
-	((this_port)->physical_port_index)
-
-
-static inline void scic_sds_port_decrement_request_count(struct scic_sds_port *sci_port)
-{
-	if (WARN_ONCE(sci_port->started_request_count == 0,
-		       "%s: tried to decrement started_request_count past 0!?",
-			__func__))
-		/* pass */;
-	else
-		sci_port->started_request_count--;
-}
-
-#define scic_sds_port_active_phy(port, phy) \
-	(((port)->active_phy_mask & (1 << (phy)->phy_index)) != 0)
-
-void scic_sds_port_construct(
-	struct scic_sds_port *sci_port,
-	u8 port_index,
-	struct scic_sds_controller *scic);
-
-enum sci_status scic_sds_port_initialize(
-	struct scic_sds_port *sci_port,
-	void __iomem *port_task_scheduler_registers,
-	void __iomem *port_configuration_regsiter,
-	void __iomem *viit_registers);
-
-enum sci_status scic_sds_port_add_phy(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
-
-enum sci_status scic_sds_port_remove_phy(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
-
-void scic_sds_port_setup_transports(
-	struct scic_sds_port *sci_port,
-	u32 device_id);
-
-
-void scic_sds_port_deactivate_phy(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy,
-	bool do_notify_user);
-
-bool scic_sds_port_link_detected(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
-
-void scic_sds_port_link_up(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
-
-void scic_sds_port_link_down(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
-
-enum sci_status scic_sds_port_start_io(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *sci_req);
-
-enum sci_status scic_sds_port_complete_io(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *sci_req);
-
-enum sas_linkrate scic_sds_port_get_max_allowed_speed(
-	struct scic_sds_port *sci_port);
-
-void scic_sds_port_broadcast_change_received(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
-
-bool scic_sds_port_is_valid_phy_assignment(
-	struct scic_sds_port *sci_port,
-	u32 phy_index);
-
-void scic_sds_port_get_sas_address(
-	struct scic_sds_port *sci_port,
-	struct sci_sas_address *sas_address);
-
-void scic_sds_port_get_attached_sas_address(
-	struct scic_sds_port *sci_port,
-	struct sci_sas_address *sas_address);
-
-#endif /* _SCIC_SDS_PORT_H_ */
diff --git a/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c b/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
deleted file mode 100644
index a5871fd..0000000
--- a/drivers/scsi/isci/core/scic_sds_port_configuration_agent.c
+++ /dev/null
@@ -1,827 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "host.h"
-#include "scic_sds_port_configuration_agent.h"
-#include "timers.h"
-
-#define SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT    (10)
-#define SCIC_SDS_APC_RECONFIGURATION_TIMEOUT    (10)
-#define SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION  (100)
-
-enum SCIC_SDS_APC_ACTIVITY {
-	SCIC_SDS_APC_SKIP_PHY,
-	SCIC_SDS_APC_ADD_PHY,
-	SCIC_SDS_APC_START_TIMER,
-
-	SCIC_SDS_APC_ACTIVITY_MAX
-};
-
-/*
- * ******************************************************************************
- * General port configuration agent routines
- * ****************************************************************************** */
-
-/**
- *
- * @address_one: A SAS Address to be compared.
- * @address_two: A SAS Address to be compared.
- *
- * Compare the two SAS Address and if SAS Address One is greater than SAS
- * Address Two then return > 0 else if SAS Address One is less than SAS Address
- * Two return < 0 Otherwise they are the same return 0 A signed value of x > 0
- * > y where x is returned for Address One > Address Two y is returned for
- * Address One < Address Two 0 is returned ofr Address One = Address Two
- */
-static s32 sci_sas_address_compare(
-	struct sci_sas_address address_one,
-	struct sci_sas_address address_two)
-{
-	if (address_one.high > address_two.high) {
-		return 1;
-	} else if (address_one.high < address_two.high) {
-		return -1;
-	} else if (address_one.low > address_two.low) {
-		return 1;
-	} else if (address_one.low < address_two.low) {
-		return -1;
-	}
-
-	/* The two SAS Address must be identical */
-	return 0;
-}
-
-/**
- *
- * @controller: The controller object used for the port search.
- * @phy: The phy object to match.
- *
- * This routine will find a matching port for the phy.  This means that the
- * port and phy both have the same broadcast sas address and same received sas
- * address. The port address or the NULL if there is no matching
- * port. port address if the port can be found to match the phy.
- * NULL if there is no matching port for the phy.
- */
-static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
-	struct scic_sds_controller *scic,
-	struct scic_sds_phy *phy)
-{
-	u8 i;
-	struct sci_sas_address port_sas_address;
-	struct sci_sas_address port_attached_device_address;
-	struct sci_sas_address phy_sas_address;
-	struct sci_sas_address phy_attached_device_address;
-
-	/*
-	 * Since this phy can be a member of a wide port check to see if one or
-	 * more phys match the sent and received SAS address as this phy in which
-	 * case it should participate in the same port.
-	 */
-	scic_sds_phy_get_sas_address(phy, &phy_sas_address);
-	scic_sds_phy_get_attached_sas_address(phy, &phy_attached_device_address);
-
-	for (i = 0; i < scic->logical_port_entries; i++) {
-		struct isci_host *ihost = scic_to_ihost(scic);
-		struct scic_sds_port *sci_port = &ihost->ports[i].sci;
-
-		scic_sds_port_get_sas_address(sci_port, &port_sas_address);
-		scic_sds_port_get_attached_sas_address(sci_port, &port_attached_device_address);
-
-		if (sci_sas_address_compare(port_sas_address, phy_sas_address) == 0 &&
-		    sci_sas_address_compare(port_attached_device_address, phy_attached_device_address) == 0)
-			return sci_port;
-	}
-
-	return NULL;
-}
-
-/**
- *
- * @controller: This is the controller object that contains the port agent
- * @port_agent: This is the port configruation agent for the controller.
- *
- * This routine will validate the port configuration is correct for the SCU
- * hardware.  The SCU hardware allows for port configurations as follows. LP0
- * -> (PE0), (PE0, PE1), (PE0, PE1, PE2, PE3) LP1 -> (PE1) LP2 -> (PE2), (PE2,
- * PE3) LP3 -> (PE3) enum sci_status SCI_SUCCESS the port configuration is valid for
- * this port configuration agent. SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
- * the port configuration is not valid for this port configuration agent.
- */
-static enum sci_status scic_sds_port_configuration_agent_validate_ports(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent)
-{
-	struct isci_host *ihost = scic_to_ihost(controller);
-	struct sci_sas_address first_address;
-	struct sci_sas_address second_address;
-
-	/*
-	 * Sanity check the max ranges for all the phys the max index
-	 * is always equal to the port range index */
-	if (port_agent->phy_valid_port_range[0].max_index != 0 ||
-	    port_agent->phy_valid_port_range[1].max_index != 1 ||
-	    port_agent->phy_valid_port_range[2].max_index != 2 ||
-	    port_agent->phy_valid_port_range[3].max_index != 3)
-		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-
-	/*
-	 * This is a request to configure a single x4 port or at least attempt
-	 * to make all the phys into a single port */
-	if (port_agent->phy_valid_port_range[0].min_index == 0 &&
-	    port_agent->phy_valid_port_range[1].min_index == 0 &&
-	    port_agent->phy_valid_port_range[2].min_index == 0 &&
-	    port_agent->phy_valid_port_range[3].min_index == 0)
-		return SCI_SUCCESS;
-
-	/*
-	 * This is a degenerate case where phy 1 and phy 2 are assigned
-	 * to the same port this is explicitly disallowed by the hardware
-	 * unless they are part of the same x4 port and this condition was
-	 * already checked above. */
-	if (port_agent->phy_valid_port_range[2].min_index == 1) {
-		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-	}
-
-	/*
-	 * PE0 and PE3 can never have the same SAS Address unless they
-	 * are part of the same x4 wide port and we have already checked
-	 * for this condition. */
-	scic_sds_phy_get_sas_address(&ihost->phys[0].sci, &first_address);
-	scic_sds_phy_get_sas_address(&ihost->phys[3].sci, &second_address);
-
-	if (sci_sas_address_compare(first_address, second_address) == 0) {
-		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-	}
-
-	/*
-	 * PE0 and PE1 are configured into a 2x1 ports make sure that the
-	 * SAS Address for PE0 and PE2 are different since they can not be
-	 * part of the same port. */
-	if (port_agent->phy_valid_port_range[0].min_index == 0 &&
-	    port_agent->phy_valid_port_range[1].min_index == 1) {
-		scic_sds_phy_get_sas_address(&ihost->phys[0].sci, &first_address);
-		scic_sds_phy_get_sas_address(&ihost->phys[2].sci, &second_address);
-
-		if (sci_sas_address_compare(first_address, second_address) == 0) {
-			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-		}
-	}
-
-	/*
-	 * PE2 and PE3 are configured into a 2x1 ports make sure that the
-	 * SAS Address for PE1 and PE3 are different since they can not be
-	 * part of the same port. */
-	if (port_agent->phy_valid_port_range[2].min_index == 2 &&
-	    port_agent->phy_valid_port_range[3].min_index == 3) {
-		scic_sds_phy_get_sas_address(&ihost->phys[1].sci, &first_address);
-		scic_sds_phy_get_sas_address(&ihost->phys[3].sci, &second_address);
-
-		if (sci_sas_address_compare(first_address, second_address) == 0) {
-			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-		}
-	}
-
-	return SCI_SUCCESS;
-}
-
-/*
- * ******************************************************************************
- * Manual port configuration agent routines
- * ****************************************************************************** */
-
-/**
- *
- *
- * This routine will verify that all of the phys in the same port are using the
- * same SAS address.
- */
-static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent)
-{
-	struct isci_host *ihost = scic_to_ihost(controller);
-	u32 phy_mask;
-	u32 assigned_phy_mask;
-	struct sci_sas_address sas_address;
-	struct sci_sas_address phy_assigned_address;
-	u8 port_index;
-	u8 phy_index;
-
-	assigned_phy_mask = 0;
-	sas_address.high = 0;
-	sas_address.low = 0;
-
-	for (port_index = 0; port_index < SCI_MAX_PORTS; port_index++) {
-		phy_mask = controller->oem_parameters.sds1.ports[port_index].phy_mask;
-
-		if (!phy_mask)
-			continue;
-		/*
-		 * Make sure that one or more of the phys were not already assinged to
-		 * a different port. */
-		if ((phy_mask & ~assigned_phy_mask) == 0) {
-			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-		}
-
-		/* Find the starting phy index for this round through the loop */
-		for (phy_index = 0; phy_index < SCI_MAX_PHYS; phy_index++) {
-			if ((phy_mask & (1 << phy_index)) == 0)
-				continue;
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
-						     &sas_address);
-
-			/*
-			 * The phy_index can be used as the starting point for the
-			 * port range since the hardware starts all logical ports
-			 * the same as the PE index. */
-			port_agent->phy_valid_port_range[phy_index].min_index = port_index;
-			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
-
-			if (phy_index != port_index) {
-				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-			}
-
-			break;
-		}
-
-		/*
-		 * See how many additional phys are being added to this logical port.
-		 * Note: We have not moved the current phy_index so we will actually
-		 *       compare the startting phy with itself.
-		 *       This is expected and required to add the phy to the port. */
-		while (phy_index < SCI_MAX_PHYS) {
-			if ((phy_mask & (1 << phy_index)) == 0)
-				continue;
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
-						     &phy_assigned_address);
-
-			if (sci_sas_address_compare(sas_address, phy_assigned_address) != 0) {
-				/*
-				 * The phy mask specified that this phy is part of the same port
-				 * as the starting phy and it is not so fail this configuration */
-				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-			}
-
-			port_agent->phy_valid_port_range[phy_index].min_index = port_index;
-			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
-
-			scic_sds_port_add_phy(&ihost->ports[port_index].sci,
-					      &ihost->phys[phy_index].sci);
-
-			assigned_phy_mask |= (1 << phy_index);
-		}
-
-		phy_index++;
-	}
-
-	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
-}
-
-/**
- *
- *
- * This timer routine is used to allow the SCI User to rediscover or change
- * device objects before a new series of link up notifications because a link
- * down has allowed a better port configuration.
- */
-static void scic_sds_mpc_agent_timeout_handler(void *object)
-{
-	u8 index;
-	struct scic_sds_controller *scic = object;
-	struct isci_host *ihost = scic_to_ihost(scic);
-	struct scic_sds_port_configuration_agent *port_agent = &scic->port_agent;
-	u16 configure_phy_mask;
-
-	port_agent->timer_pending = false;
-
-	/* Find the mask of phys that are reported read but as yet unconfigured into a port */
-	configure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		struct scic_sds_phy *sci_phy = &ihost->phys[index].sci;
-
-		if (configure_phy_mask & (1 << index)) {
-			port_agent->link_up_handler(scic, port_agent,
-						    scic_sds_phy_get_port(sci_phy),
-						    sci_phy);
-		}
-	}
-}
-
-/**
- *
- * @controller: This is the controller object that receives the link up
- *    notification.
- * @port: This is the port object associated with the phy.  If the is no
- *    associated port this is an NULL.
- * @phy: This is the phy object which has gone ready.
- *
- * This method handles the manual port configuration link up notifications.
- * Since all ports and phys are associate at initialization time we just turn
- * around and notifiy the port object that there is a link up.  If this PHY is
- * not associated with a port there is no action taken. Is it possible to get a
- * link up notification from a phy that has no assocoated port?
- */
-static void scic_sds_mpc_agent_link_up(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	/*
-	 * If the port has an invalid handle then the phy was not assigned to
-	 * a port.  This is because the phy was not given the same SAS Address
-	 * as the other PHYs in the port. */
-	if (port != NULL) {
-		port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(phy));
-
-		scic_sds_port_link_up(port, phy);
-
-		if ((port->active_phy_mask & (1 << scic_sds_phy_get_index(phy))) != 0) {
-			port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(phy));
-		}
-	}
-}
-
-/**
- *
- * @controller: This is the controller object that receives the link down
- *    notification.
- * @port: This is the port object associated with the phy.  If the is no
- *    associated port this is an NULL.  The port is an invalid
- *    handle only if the phy was never port of this port.  This happens when
- *    the phy is not broadcasting the same SAS address as the other phys in the
- *    assigned port.
- * @phy: This is the phy object which has gone link down.
- *
- * This function handles the manual port configuration link down notifications.
- * Since all ports and phys are associated at initialization time we just turn
- * around and notifiy the port object of the link down event.  If this PHY is
- * not associated with a port there is no action taken. Is it possible to get a
- * link down notification from a phy that has no assocoated port?
- */
-static void scic_sds_mpc_agent_link_down(
-	struct scic_sds_controller *scic,
-	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	if (sci_port != NULL) {
-		/*
-		 * If we can form a new port from the remainder of the phys
-		 * then we want to start the timer to allow the SCI User to
-		 * cleanup old devices and rediscover the port before
-		 * rebuilding the port with the phys that remain in the ready
-		 * state.
-		 */
-		port_agent->phy_ready_mask &=
-			~(1 << scic_sds_phy_get_index(sci_phy));
-		port_agent->phy_configured_mask &=
-			~(1 << scic_sds_phy_get_index(sci_phy));
-
-		/*
-		 * Check to see if there are more phys waiting to be
-		 * configured into a port. If there are allow the SCI User
-		 * to tear down this port, if necessary, and then reconstruct
-		 * the port after the timeout.
-		 */
-		if ((port_agent->phy_configured_mask == 0x0000) &&
-		    (port_agent->phy_ready_mask != 0x0000) &&
-		    !port_agent->timer_pending) {
-			port_agent->timer_pending = true;
-
-			isci_timer_start(port_agent->timer,
-					 SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
-		}
-
-		scic_sds_port_link_down(sci_port, sci_phy);
-	}
-}
-
-/*
- * ******************************************************************************
- * Automatic port configuration agent routines
- * ****************************************************************************** */
-
-/**
- *
- *
- * This routine will verify that the phys are assigned a valid SAS address for
- * automatic port configuration mode.
- */
-static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent)
-{
-	u8 phy_index;
-	u8 port_index;
-	struct sci_sas_address sas_address;
-	struct sci_sas_address phy_assigned_address;
-	struct isci_host *ihost = scic_to_ihost(controller);
-
-	phy_index = 0;
-
-	while (phy_index < SCI_MAX_PHYS) {
-		port_index = phy_index;
-
-		/* Get the assigned SAS Address for the first PHY on the controller. */
-		scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
-					    &sas_address);
-
-		while (++phy_index < SCI_MAX_PHYS) {
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
-						     &phy_assigned_address);
-
-			/* Verify each of the SAS address are all the same for every PHY */
-			if (sci_sas_address_compare(sas_address, phy_assigned_address) == 0) {
-				port_agent->phy_valid_port_range[phy_index].min_index = port_index;
-				port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
-			} else {
-				port_agent->phy_valid_port_range[phy_index].min_index = phy_index;
-				port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
-				break;
-			}
-		}
-	}
-
-	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
-}
-
-/**
- *
- * @controller: This is the controller that to which the port agent is assigned.
- * @port_agent: This is the port agent that is requesting the timer start
- *    operation.
- * @phy: This is the phy that has caused the timer operation to be scheduled.
- *
- * This routine will restart the automatic port configuration timeout timer for
- * the next time period.  This could be caused by either a link down event or a
- * link up event where we can not yet tell to which port a phy belongs.
- */
-static inline void scic_sds_apc_agent_start_timer(
-	struct scic_sds_controller *scic,
-	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_phy *sci_phy,
-	u32 timeout)
-{
-	if (port_agent->timer_pending)
-		isci_timer_stop(port_agent->timer);
-
-	port_agent->timer_pending = true;
-
-	isci_timer_start(port_agent->timer, timeout);
-}
-
-/**
- *
- * @controller: This is the controller object that receives the link up
- *    notification.
- * @phy: This is the phy object which has gone link up.
- *
- * This method handles the automatic port configuration for link up
- * notifications.
- */
-static void scic_sds_apc_agent_configure_ports(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_phy *phy,
-	bool start_timer)
-{
-	u8 port_index;
-	enum sci_status status;
-	struct scic_sds_port *port;
-	enum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;
-	struct isci_host *ihost = scic_to_ihost(controller);
-
-	port = scic_sds_port_configuration_agent_find_port(controller, phy);
-
-	if (port != NULL) {
-		if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index))
-			apc_activity = SCIC_SDS_APC_ADD_PHY;
-		else
-			apc_activity = SCIC_SDS_APC_SKIP_PHY;
-	} else {
-		/*
-		 * There is no matching Port for this PHY so lets search through the
-		 * Ports and see if we can add the PHY to its own port or maybe start
-		 * the timer and wait to see if a wider port can be made.
-		 *
-		 * Note the break when we reach the condition of the port id == phy id */
-		for (
-			port_index = port_agent->phy_valid_port_range[phy->phy_index].min_index;
-			port_index <= port_agent->phy_valid_port_range[phy->phy_index].max_index;
-			port_index++
-			) {
-
-			port = &ihost->ports[port_index].sci;
-
-			/* First we must make sure that this PHY can be added to this Port. */
-			if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)) {
-				/*
-				 * Port contains a PHY with a greater PHY ID than the current
-				 * PHY that has gone link up.  This phy can not be part of any
-				 * port so skip it and move on. */
-				if (port->active_phy_mask > (1 << phy->phy_index)) {
-					apc_activity = SCIC_SDS_APC_SKIP_PHY;
-					break;
-				}
-
-				/*
-				 * We have reached the end of our Port list and have not found
-				 * any reason why we should not either add the PHY to the port
-				 * or wait for more phys to become active. */
-				if (port->physical_port_index == phy->phy_index) {
-					/*
-					 * The Port either has no active PHYs.
-					 * Consider that if the port had any active PHYs we would have
-					 * or active PHYs with
-					 * a lower PHY Id than this PHY. */
-					if (apc_activity != SCIC_SDS_APC_START_TIMER) {
-						apc_activity = SCIC_SDS_APC_ADD_PHY;
-					}
-
-					break;
-				}
-
-				/*
-				 * The current Port has no active PHYs and this PHY could be part
-				 * of this Port.  Since we dont know as yet setup to start the
-				 * timer and see if there is a better configuration. */
-				if (port->active_phy_mask == 0) {
-					apc_activity = SCIC_SDS_APC_START_TIMER;
-				}
-			} else if (port->active_phy_mask != 0) {
-				/*
-				 * The Port has an active phy and the current Phy can not
-				 * participate in this port so skip the PHY and see if
-				 * there is a better configuration. */
-				apc_activity = SCIC_SDS_APC_SKIP_PHY;
-			}
-		}
-	}
-
-	/*
-	 * Check to see if the start timer operations should instead map to an
-	 * add phy operation.  This is caused because we have been waiting to
-	 * add a phy to a port but could not becuase the automatic port
-	 * configuration engine had a choice of possible ports for the phy.
-	 * Since we have gone through a timeout we are going to restrict the
-	 * choice to the smallest possible port. */
-	if (
-		(start_timer == false)
-		&& (apc_activity == SCIC_SDS_APC_START_TIMER)
-		) {
-		apc_activity = SCIC_SDS_APC_ADD_PHY;
-	}
-
-	switch (apc_activity) {
-	case SCIC_SDS_APC_ADD_PHY:
-		status = scic_sds_port_add_phy(port, phy);
-
-		if (status == SCI_SUCCESS) {
-			port_agent->phy_configured_mask |= (1 << phy->phy_index);
-		}
-		break;
-
-	case SCIC_SDS_APC_START_TIMER:
-		scic_sds_apc_agent_start_timer(
-			controller, port_agent, phy, SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION
-			);
-		break;
-
-	case SCIC_SDS_APC_SKIP_PHY:
-	default:
-		/* do nothing the PHY can not be made part of a port at this time. */
-		break;
-	}
-}
-
-/**
- * scic_sds_apc_agent_link_up - handle apc link up events
- * @scic: This is the controller object that receives the link up
- *    notification.
- * @sci_port: This is the port object associated with the phy.  If the is no
- *    associated port this is an NULL.
- * @sci_phy: This is the phy object which has gone link up.
- *
- * This method handles the automatic port configuration for link up
- * notifications. Is it possible to get a link down notification from a phy
- * that has no assocoated port?
- */
-static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
-				       struct scic_sds_port_configuration_agent *port_agent,
-				       struct scic_sds_port *sci_port,
-				       struct scic_sds_phy *sci_phy)
-{
-	u8 phy_index  = sci_phy->phy_index;
-
-	if (!sci_port) {
-		/* the phy is not the part of this port */
-		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_apc_agent_configure_ports(scic, port_agent, sci_phy, true);
-	} else {
-		/* the phy is already the part of the port */
-		u32 port_state = sci_port->state_machine.current_state_id;
-
-		/* if the PORT'S state is resetting then the link up is from
-		 * port hard reset in this case, we need to tell the port
-		 * that link up is recieved
-		 */
-		BUG_ON(port_state != SCI_BASE_PORT_STATE_RESETTING);
-		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_port_link_up(sci_port, sci_phy);
-	}
-}
-
-/**
- *
- * @controller: This is the controller object that receives the link down
- *    notification.
- * @port: This is the port object associated with the phy.  If the is no
- *    associated port this is an NULL.
- * @phy: This is the phy object which has gone link down.
- *
- * This method handles the automatic port configuration link down
- * notifications. not associated with a port there is no action taken. Is it
- * possible to get a link down notification from a phy that has no assocoated
- * port?
- */
-static void scic_sds_apc_agent_link_down(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(phy));
-
-	if (port != NULL) {
-		if (port_agent->phy_configured_mask & (1 << phy->phy_index)) {
-			enum sci_status status;
-
-			status = scic_sds_port_remove_phy(port, phy);
-
-			if (status == SCI_SUCCESS) {
-				port_agent->phy_configured_mask &= ~(1 << phy->phy_index);
-			}
-		}
-	}
-}
-
-/* configure the phys into ports when the timer fires */
-static void scic_sds_apc_agent_timeout_handler(void *object)
-{
-	u32 index;
-	struct scic_sds_port_configuration_agent *port_agent;
-	struct scic_sds_controller *scic = object;
-	struct isci_host *ihost = scic_to_ihost(scic);
-	u16 configure_phy_mask;
-
-	port_agent = scic_sds_controller_get_port_configuration_agent(scic);
-
-	port_agent->timer_pending = false;
-
-	configure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;
-
-	if (!configure_phy_mask)
-		return;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if ((configure_phy_mask & (1 << index)) == 0)
-			continue;
-
-		scic_sds_apc_agent_configure_ports(scic, port_agent,
-						   &ihost->phys[index].sci, false);
-	}
-}
-
-/*
- * ******************************************************************************
- * Public port configuration agent routines
- * ****************************************************************************** */
-
-/**
- *
- *
- * This method will construct the port configuration agent for operation. This
- * call is universal for both manual port configuration and automatic port
- * configuration modes.
- */
-void scic_sds_port_configuration_agent_construct(
-	struct scic_sds_port_configuration_agent *port_agent)
-{
-	u32 index;
-
-	port_agent->phy_configured_mask = 0x00;
-	port_agent->phy_ready_mask = 0x00;
-
-	port_agent->link_up_handler = NULL;
-	port_agent->link_down_handler = NULL;
-
-	port_agent->timer_pending = false;
-	port_agent->timer = NULL;
-
-	for (index = 0; index < SCI_MAX_PORTS; index++) {
-		port_agent->phy_valid_port_range[index].min_index = 0;
-		port_agent->phy_valid_port_range[index].max_index = 0;
-	}
-}
-
-enum sci_status scic_sds_port_configuration_agent_initialize(
-	struct scic_sds_controller *scic,
-	struct scic_sds_port_configuration_agent *port_agent)
-{
-	enum sci_status status = SCI_SUCCESS;
-	enum scic_port_configuration_mode mode;
-	struct isci_host *ihost = scic_to_ihost(scic);
-
-	mode = scic->oem_parameters.sds1.controller.mode_type;
-
-	if (mode == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
-		status = scic_sds_mpc_agent_validate_phy_configuration(
-				scic, port_agent);
-
-		port_agent->link_up_handler = scic_sds_mpc_agent_link_up;
-		port_agent->link_down_handler = scic_sds_mpc_agent_link_down;
-
-		port_agent->timer = isci_timer_create(
-				ihost,
-				scic,
-				scic_sds_mpc_agent_timeout_handler);
-	} else {
-		status = scic_sds_apc_agent_validate_phy_configuration(
-				scic, port_agent);
-
-		port_agent->link_up_handler = scic_sds_apc_agent_link_up;
-		port_agent->link_down_handler = scic_sds_apc_agent_link_down;
-
-		port_agent->timer = isci_timer_create(
-				ihost,
-				scic,
-				scic_sds_apc_agent_timeout_handler);
-	}
-
-	/* Make sure we have actually gotten a timer */
-	if ((status == SCI_SUCCESS) && (port_agent->timer == NULL)) {
-		dev_err(scic_to_dev(scic),
-			"%s: Controller 0x%p automatic port configuration "
-			"agent could not get timer.\n",
-			__func__,
-			scic);
-
-		status = SCI_FAILURE;
-	}
-
-	return status;
-}
diff --git a/drivers/scsi/isci/core/scic_sds_port_configuration_agent.h b/drivers/scsi/isci/core/scic_sds_port_configuration_agent.h
deleted file mode 100644
index 7fd1617..0000000
--- a/drivers/scsi/isci/core/scic_sds_port_configuration_agent.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCIC_SDS_PORT_CONFIGURATION_AGENT_H_
-#define _SCIC_SDS_PORT_CONFIGURATION_AGENT_H_
-
-/**
- * This file contains the structures, constants and prototypes used for the
- *    core controller automatic port configuration engine.
- *
- *
- */
-
-#include "scic_sds_port.h"
-
-struct scic_sds_controller;
-struct scic_sds_port_configuration_agent;
-struct scic_sds_port;
-struct scic_sds_phy;
-
-typedef void (*scic_sds_port_configuration_agent_phy_handler_t)(
-	struct scic_sds_controller *,
-	struct scic_sds_port_configuration_agent *,
-	struct scic_sds_port *,
-	struct scic_sds_phy *
-	);
-
-struct SCIC_SDS_PORT_RANGE {
-	u8 min_index;
-	u8 max_index;
-};
-
-struct scic_sds_port_configuration_agent {
-	u16 phy_configured_mask;
-	u16 phy_ready_mask;
-
-	struct SCIC_SDS_PORT_RANGE phy_valid_port_range[SCI_MAX_PHYS];
-
-	bool timer_pending;
-
-	scic_sds_port_configuration_agent_phy_handler_t link_up_handler;
-	scic_sds_port_configuration_agent_phy_handler_t link_down_handler;
-
-	void *timer;
-
-};
-
-void scic_sds_port_configuration_agent_construct(
-	struct scic_sds_port_configuration_agent *port_agent);
-
-enum sci_status scic_sds_port_configuration_agent_initialize(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent);
-
-#endif /* _SCIC_SDS_PORT_CONFIGURATION_AGENT_H_ */
diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index e1930da..2bb9f10 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -61,7 +61,6 @@
 #include "probe_roms.h"
 #include "remote_device.h"
 #include "request.h"
-#include "scic_sds_port_configuration_agent.h"
 #include "scu_completion_codes.h"
 #include "scu_event_codes.h"
 #include "registers.h"
diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 9c5d121..784e135 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -55,7 +55,6 @@
 #ifndef _SCI_HOST_H_
 #define _SCI_HOST_H_
 
-#include "scic_config_parameters.h"
 #include "remote_device.h"
 #include "phy.h"
 #include "pool.h"
@@ -64,11 +63,12 @@
 #include "registers.h"
 #include "scu_unsolicited_frame.h"
 #include "unsolicited_frame_control.h"
-#include "scic_sds_port_configuration_agent.h"
+#include "probe_roms.h"
 
 struct scic_sds_request;
 struct scu_task_context;
 
+
 /**
  * struct scic_power_control -
  *
@@ -107,6 +107,24 @@ struct scic_power_control {
 
 };
 
+struct scic_sds_port_configuration_agent;
+typedef void (*port_config_fn)(struct scic_sds_controller *,
+			       struct scic_sds_port_configuration_agent *,
+			       struct scic_sds_port *, struct scic_sds_phy *);
+
+struct scic_sds_port_configuration_agent {
+	u16 phy_configured_mask;
+	u16 phy_ready_mask;
+	struct {
+		u8 min_index;
+		u8 max_index;
+	} phy_valid_port_range[SCI_MAX_PHYS];
+	bool timer_pending;
+	port_config_fn link_up_handler;
+	port_config_fn link_down_handler;
+	void *timer;
+};
+
 /**
  * struct scic_sds_controller -
  *
@@ -800,4 +818,11 @@ u16 scic_controller_allocate_io_tag(
 enum sci_status scic_controller_free_io_tag(
 	struct scic_sds_controller *scic,
 	u16 io_tag);
+
+void scic_sds_port_configuration_agent_construct(
+	struct scic_sds_port_configuration_agent *port_agent);
+
+enum sci_status scic_sds_port_configuration_agent_initialize(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent);
 #endif
diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index b92d51f..0f64605 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -57,9 +57,8 @@
 #include "host.h"
 #include "phy.h"
 #include "scu_event_codes.h"
-#include "scic_port.h"
-#include "scic_config_parameters.h"
 #include "timers.h"
+#include "probe_roms.h"
 
 /* Maximum arbitration wait time in micro-seconds */
 #define SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME  (700)
diff --git a/drivers/scsi/isci/phy.h b/drivers/scsi/isci/phy.h
index 093fd47..f180036 100644
--- a/drivers/scsi/isci/phy.h
+++ b/drivers/scsi/isci/phy.h
@@ -58,6 +58,7 @@
 #include <scsi/sas.h>
 #include <scsi/libsas.h>
 #include "state_machine.h"
+#include "sas.h"
 
 /* This is the timeout value for the SATA phy to wait for a SIGNATURE FIS
  * before restarting the starting state machine.  Technically, the old parallel
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 321935d..dbff283 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -53,11 +53,13 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <linux/workqueue.h>
 #include "isci.h"
-#include "scic_port.h"
 #include "port.h"
 #include "request.h"
+#include "timers.h"
+
+#define SCIC_SDS_PORT_HARD_RESET_TIMEOUT  (1000)
+#define SCU_DUMMY_INDEX    (0xFFFF)
 
 static void isci_port_change_state(struct isci_port *iport, enum isci_status status)
 {
@@ -73,44 +75,87 @@ static void isci_port_change_state(struct isci_port *iport, enum isci_status sta
 	spin_unlock_irqrestore(&iport->state_lock, flags);
 }
 
-void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
+/*
+ * This function will indicate which protocols are supported by this port.
+ * @sci_port: a handle corresponding to the SAS port for which to return the
+ *    supported protocols.
+ * @protocols: This parameter specifies a pointer to a data structure
+ *    which the core will copy the protocol values for the port from the
+ *    transmit_identification register.
+ */
+static void
+scic_sds_port_get_protocols(struct scic_sds_port *sci_port,
+			    struct scic_phy_proto *protocols)
 {
-	INIT_LIST_HEAD(&iport->remote_dev_list);
-	INIT_LIST_HEAD(&iport->domain_dev_list);
-	spin_lock_init(&iport->state_lock);
-	init_completion(&iport->start_complete);
-	iport->isci_host = ihost;
-	isci_port_change_state(iport, isci_freed);
+	u8 index;
+
+	protocols->all = 0;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->phy_table[index] != NULL) {
+			scic_sds_phy_get_protocols(sci_port->phy_table[index],
+						   protocols);
+		}
+	}
 }
 
 /**
- * isci_port_get_state() - This function gets the status of the port object.
- * @isci_port: This parameter points to the isci_port object
+ * This method requests a list (mask) of the phys contained in the supplied SAS
+ *    port.
+ * @sci_port: a handle corresponding to the SAS port for which to return the
+ *    phy mask.
  *
- * status of the object as a isci_status enum.
+ * Return a bit mask indicating which phys are a part of this port. Each bit
+ * corresponds to a phy identifier (e.g. bit 0 = phy id 0).
  */
-enum isci_status isci_port_get_state(
-	struct isci_port *isci_port)
+static u32 scic_sds_port_get_phys(struct scic_sds_port *sci_port)
 {
-	return isci_port->status;
+	u32 index;
+	u32 mask;
+
+	mask = 0;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->phy_table[index] != NULL) {
+			mask |= (1 << index);
+		}
+	}
+
+	return mask;
 }
 
-void isci_port_bc_change_received(struct isci_host *ihost,
-				  struct scic_sds_port *sci_port,
-				  struct scic_sds_phy *sci_phy)
+/**
+ * scic_port_get_properties() - This method simply returns the properties
+ *    regarding the port, such as: physical index, protocols, sas address, etc.
+ * @port: this parameter specifies the port for which to retrieve the physical
+ *    index.
+ * @properties: This parameter specifies the properties structure into which to
+ *    copy the requested information.
+ *
+ * Indicate if the user specified a valid port. SCI_SUCCESS This value is
+ * returned if the specified port was valid. SCI_FAILURE_INVALID_PORT This
+ * value is returned if the specified port is not valid.  When this value is
+ * returned, no data is copied to the properties output parameter.
+ */
+static enum sci_status scic_port_get_properties(struct scic_sds_port *port,
+						struct scic_port_properties *prop)
 {
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+	if ((port == NULL) ||
+	    (port->logical_port_index == SCIC_SDS_DUMMY_PORT))
+		return SCI_FAILURE_INVALID_PORT;
 
-	dev_dbg(&ihost->pdev->dev, "%s: iphy = %p, sas_phy = %p\n",
-		__func__, iphy, &iphy->sas_phy);
+	prop->index    = port->logical_port_index;
+	prop->phy_mask = scic_sds_port_get_phys(port);
+	scic_sds_port_get_sas_address(port, &prop->local.sas_address);
+	scic_sds_port_get_protocols(port, &prop->local.protocols);
+	scic_sds_port_get_attached_sas_address(port, &prop->remote.sas_address);
 
-	ihost->sas_ha.notify_port_event(&iphy->sas_phy, PORTE_BROADCAST_RCVD);
-	scic_port_enable_broadcast_change_notification(sci_port);
+	return SCI_SUCCESS;
 }
 
-void isci_port_link_up(struct isci_host *isci_host,
-		       struct scic_sds_port *port,
-		       struct scic_sds_phy *phy)
+static void isci_port_link_up(struct isci_host *isci_host,
+			      struct scic_sds_port *port,
+			      struct scic_sds_phy *phy)
 {
 	unsigned long flags;
 	struct scic_port_properties properties;
@@ -184,8 +229,9 @@ void isci_port_link_up(struct isci_host *isci_host,
  * @port: This parameter specifies the isci port with the active link.
  *
  */
-void isci_port_link_down(struct isci_host *isci_host, struct isci_phy *isci_phy,
-			 struct isci_port *isci_port)
+static void isci_port_link_down(struct isci_host *isci_host,
+				struct isci_phy *isci_phy,
+				struct isci_port *isci_port)
 {
 	struct isci_remote_device *isci_device;
 
@@ -231,37 +277,13 @@ void isci_port_link_down(struct isci_host *isci_host, struct isci_phy *isci_phy,
 
 
 /**
- * isci_port_deformed() - This function is called by libsas when a port becomes
- *    inactive.
- * @phy: This parameter specifies the libsas phy with the inactive port.
- *
- */
-void isci_port_deformed(
-	struct asd_sas_phy *phy)
-{
-	pr_debug("%s: sas_phy = %p\n", __func__, phy);
-}
-
-/**
- * isci_port_formed() - This function is called by libsas when a port becomes
- *    active.
- * @phy: This parameter specifies the libsas phy with the active port.
- *
- */
-void isci_port_formed(
-	struct asd_sas_phy *phy)
-{
-	pr_debug("%s: sas_phy = %p, sas_port = %p\n", __func__, phy, phy->port);
-}
-
-/**
  * isci_port_ready() - This function is called by the sci core when a link
  *    becomes ready.
  * @isci_host: This parameter specifies the isci host object.
  * @port: This parameter specifies the sci port with the active link.
  *
  */
-void isci_port_ready(struct isci_host *isci_host, struct isci_port *isci_port)
+static void isci_port_ready(struct isci_host *isci_host, struct isci_port *isci_port)
 {
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
@@ -279,12 +301,19 @@ void isci_port_ready(struct isci_host *isci_host, struct isci_port *isci_port)
  * @port: This parameter specifies the sci port with the active link.
  *
  */
-void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *isci_port)
+static void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *isci_port)
 {
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
 }
 
+static void isci_port_stop_complete(struct scic_sds_controller *scic,
+				    struct scic_sds_port *sci_port,
+				    enum sci_status completion_status)
+{
+	dev_dbg(&scic_to_ihost(scic)->pdev->dev, "Port stop complete\n");
+}
+
 /**
  * isci_port_hard_reset_complete() - This function is called by the sci core
  *    when the hard reset complete notification has been received.
@@ -293,8 +322,8 @@ void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *isci_por
  *    process.
  *
  */
-void isci_port_hard_reset_complete(struct isci_port *isci_port,
-				   enum sci_status completion_status)
+static void isci_port_hard_reset_complete(struct isci_port *isci_port,
+					  enum sci_status completion_status)
 {
 	dev_dbg(&isci_port->isci_host->pdev->dev,
 		"%s: isci_port = %p, completion_status=%x\n",
@@ -306,6 +335,2293 @@ void isci_port_hard_reset_complete(struct isci_port *isci_port,
 	complete_all(&isci_port->hard_reset_complete);
 }
 
+/* This method will return a true value if the specified phy can be assigned to
+ * this port The following is a list of phys for each port that are allowed: -
+ * Port 0 - 3 2 1 0 - Port 1 -     1 - Port 2 - 3 2 - Port 3 - 3 This method
+ * doesn't preclude all configurations.  It merely ensures that a phy is part
+ * of the allowable set of phy identifiers for that port.  For example, one
+ * could assign phy 3 to port 0 and no other phys.  Please refer to
+ * scic_sds_port_is_phy_mask_valid() for information regarding whether the
+ * phy_mask for a port can be supported. bool true if this is a valid phy
+ * assignment for the port false if this is not a valid phy assignment for the
+ * port
+ */
+bool scic_sds_port_is_valid_phy_assignment(struct scic_sds_port *sci_port,
+					   u32 phy_index)
+{
+	/* Initialize to invalid value. */
+	u32 existing_phy_index = SCI_MAX_PHYS;
+	u32 index;
+
+	if ((sci_port->physical_port_index == 1) && (phy_index != 1)) {
+		return false;
+	}
+
+	if (sci_port->physical_port_index == 3 && phy_index != 3) {
+		return false;
+	}
+
+	if (
+		(sci_port->physical_port_index == 2)
+		&& ((phy_index == 0) || (phy_index == 1))
+		) {
+		return false;
+	}
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if ((sci_port->phy_table[index] != NULL)
+		    && (index != phy_index)) {
+			existing_phy_index = index;
+		}
+	}
+
+	/*
+	 * Ensure that all of the phys in the port are capable of
+	 * operating at the same maximum link rate. */
+	if (
+		(existing_phy_index < SCI_MAX_PHYS)
+		&& (sci_port->owning_controller->user_parameters.sds1.phys[
+			    phy_index].max_speed_generation !=
+		    sci_port->owning_controller->user_parameters.sds1.phys[
+			    existing_phy_index].max_speed_generation)
+		)
+		return false;
+
+	return true;
+}
+
+/**
+ *
+ * @sci_port: This is the port object for which to determine if the phy mask
+ *    can be supported.
+ *
+ * This method will return a true value if the port's phy mask can be supported
+ * by the SCU. The following is a list of valid PHY mask configurations for
+ * each port: - Port 0 - [[3  2] 1] 0 - Port 1 -        [1] - Port 2 - [[3] 2]
+ * - Port 3 -  [3] This method returns a boolean indication specifying if the
+ * phy mask can be supported. true if this is a valid phy assignment for the
+ * port false if this is not a valid phy assignment for the port
+ */
+static bool scic_sds_port_is_phy_mask_valid(
+	struct scic_sds_port *sci_port,
+	u32 phy_mask)
+{
+	if (sci_port->physical_port_index == 0) {
+		if (((phy_mask & 0x0F) == 0x0F)
+		    || ((phy_mask & 0x03) == 0x03)
+		    || ((phy_mask & 0x01) == 0x01)
+		    || (phy_mask == 0))
+			return true;
+	} else if (sci_port->physical_port_index == 1) {
+		if (((phy_mask & 0x02) == 0x02)
+		    || (phy_mask == 0))
+			return true;
+	} else if (sci_port->physical_port_index == 2) {
+		if (((phy_mask & 0x0C) == 0x0C)
+		    || ((phy_mask & 0x04) == 0x04)
+		    || (phy_mask == 0))
+			return true;
+	} else if (sci_port->physical_port_index == 3) {
+		if (((phy_mask & 0x08) == 0x08)
+		    || (phy_mask == 0))
+			return true;
+	}
+
+	return false;
+}
+
+/**
+ *
+ * @sci_port: This parameter specifies the port from which to return a
+ *    connected phy.
+ *
+ * This method retrieves a currently active (i.e. connected) phy contained in
+ * the port.  Currently, the lowest order phy that is connected is returned.
+ * This method returns a pointer to a SCIS_SDS_PHY object. NULL This value is
+ * returned if there are no currently active (i.e. connected to a remote end
+ * point) phys contained in the port. All other values specify a struct scic_sds_phy
+ * object that is active in the port.
+ */
+static struct scic_sds_phy *scic_sds_port_get_a_connected_phy(
+	struct scic_sds_port *sci_port
+	) {
+	u32 index;
+	struct scic_sds_phy *phy;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		/*
+		 * Ensure that the phy is both part of the port and currently
+		 * connected to the remote end-point. */
+		phy = sci_port->phy_table[index];
+		if (
+			(phy != NULL)
+			&& scic_sds_port_active_phy(sci_port, phy)
+			) {
+			return phy;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * scic_sds_port_set_phy() -
+ * @out]: port The port object to which the phy assignement is being made.
+ * @out]: phy The phy which is being assigned to the port.
+ *
+ * This method attempts to make the assignment of the phy to the port. If
+ * successful the phy is assigned to the ports phy table. bool true if the phy
+ * assignment can be made. false if the phy assignement can not be made. This
+ * is a functional test that only fails if the phy is currently assigned to a
+ * different port.
+ */
+static enum sci_status scic_sds_port_set_phy(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	/*
+	 * Check to see if we can add this phy to a port
+	 * that means that the phy is not part of a port and that the port does
+	 * not already have a phy assinged to the phy index. */
+	if (
+		(port->phy_table[phy->phy_index] == NULL)
+		&& (scic_sds_phy_get_port(phy) == NULL)
+		&& scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)
+		) {
+		/*
+		 * Phy is being added in the stopped state so we are in MPC mode
+		 * make logical port index = physical port index */
+		port->logical_port_index = port->physical_port_index;
+		port->phy_table[phy->phy_index] = phy;
+		scic_sds_phy_set_port(phy, port);
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE;
+}
+
+/**
+ * scic_sds_port_clear_phy() -
+ * @out]: port The port from which the phy is being cleared.
+ * @out]: phy The phy being cleared from the port.
+ *
+ * This method will clear the phy assigned to this port.  This method fails if
+ * this phy is not currently assinged to this port. bool true if the phy is
+ * removed from the port. false if this phy is not assined to this port.
+ */
+static enum sci_status scic_sds_port_clear_phy(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	/* Make sure that this phy is part of this port */
+	if (port->phy_table[phy->phy_index] == phy &&
+	    scic_sds_phy_get_port(phy) == port) {
+		struct scic_sds_controller *scic = port->owning_controller;
+		struct isci_host *ihost = scic_to_ihost(scic);
+
+		/* Yep it is assigned to this port so remove it */
+		scic_sds_phy_set_port(phy, &ihost->ports[SCI_MAX_PORTS].sci);
+		port->phy_table[phy->phy_index] = NULL;
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE;
+}
+
+/**
+ * scic_sds_port_add_phy() -
+ * @sci_port: This parameter specifies the port in which the phy will be added.
+ * @sci_phy: This parameter is the phy which is to be added to the port.
+ *
+ * This method will add a PHY to the selected port. This method returns an
+ * enum sci_status. SCI_SUCCESS the phy has been added to the port. Any other status
+ * is failre to add the phy to the port.
+ */
+enum sci_status scic_sds_port_add_phy(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	return sci_port->state_handlers->add_phy_handler(
+		       sci_port, sci_phy);
+}
+
+
+/**
+ * scic_sds_port_remove_phy() -
+ * @sci_port: This parameter specifies the port in which the phy will be added.
+ * @sci_phy: This parameter is the phy which is to be added to the port.
+ *
+ * This method will remove the PHY from the selected PORT. This method returns
+ * an enum sci_status. SCI_SUCCESS the phy has been removed from the port. Any other
+ * status is failre to add the phy to the port.
+ */
+enum sci_status scic_sds_port_remove_phy(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	return sci_port->state_handlers->remove_phy_handler(
+		       sci_port, sci_phy);
+}
+
+/**
+ * This method requests the SAS address for the supplied SAS port from the SCI
+ *    implementation.
+ * @sci_port: a handle corresponding to the SAS port for which to return the
+ *    SAS address.
+ * @sas_address: This parameter specifies a pointer to a SAS address structure
+ *    into which the core will copy the SAS address for the port.
+ *
+ */
+void scic_sds_port_get_sas_address(
+	struct scic_sds_port *sci_port,
+	struct sci_sas_address *sas_address)
+{
+	u32 index;
+
+	sas_address->high = 0;
+	sas_address->low  = 0;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->phy_table[index] != NULL) {
+			scic_sds_phy_get_sas_address(sci_port->phy_table[index], sas_address);
+		}
+	}
+}
+
+/*
+ * This function requests the SAS address for the device directly attached to
+ *    this SAS port.
+ * @sci_port: a handle corresponding to the SAS port for which to return the
+ *    SAS address.
+ * @sas_address: This parameter specifies a pointer to a SAS address structure
+ *    into which the core will copy the SAS address for the device directly
+ *    attached to the port.
+ *
+ */
+void scic_sds_port_get_attached_sas_address(
+	struct scic_sds_port *sci_port,
+	struct sci_sas_address *sas_address)
+{
+	struct scic_sds_phy *sci_phy;
+
+	/*
+	 * Ensure that the phy is both part of the port and currently
+	 * connected to the remote end-point.
+	 */
+	sci_phy = scic_sds_port_get_a_connected_phy(sci_port);
+	if (sci_phy) {
+		if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
+			scic_sds_phy_get_attached_sas_address(sci_phy,
+							      sas_address);
+		} else {
+			scic_sds_phy_get_sas_address(sci_phy, sas_address);
+			sas_address->low += sci_phy->phy_index;
+		}
+	} else {
+		sas_address->high = 0;
+		sas_address->low  = 0;
+	}
+}
+
+/**
+ * scic_sds_port_construct_dummy_rnc() - create dummy rnc for si workaround
+ *
+ * @sci_port: logical port on which we need to create the remote node context
+ * @rni: remote node index for this remote node context.
+ *
+ * This routine will construct a dummy remote node context data structure
+ * This structure will be posted to the hardware to work around a scheduler
+ * error in the hardware.
+ */
+static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u16 rni)
+{
+	union scu_remote_node_context *rnc;
+
+	rnc = &sci_port->owning_controller->remote_node_context_table[rni];
+
+	memset(rnc, 0, sizeof(union scu_remote_node_context));
+
+	rnc->ssp.remote_sas_address_hi = 0;
+	rnc->ssp.remote_sas_address_lo = 0;
+
+	rnc->ssp.remote_node_index = rni;
+	rnc->ssp.remote_node_port_width = 1;
+	rnc->ssp.logical_port_index = sci_port->physical_port_index;
+
+	rnc->ssp.nexus_loss_timer_enable = false;
+	rnc->ssp.check_bit = false;
+	rnc->ssp.is_valid = true;
+	rnc->ssp.is_remote_node_context = true;
+	rnc->ssp.function_number = 0;
+	rnc->ssp.arbitration_wait_time = 0;
+}
+
+/**
+ * scic_sds_port_construct_dummy_task() - create dummy task for si workaround
+ * @sci_port The logical port on which we need to create the
+ *            remote node context.
+ *            context.
+ * @tci The remote node index for this remote node context.
+ *
+ * This routine will construct a dummy task context data structure.  This
+ * structure will be posted to the hardwre to work around a scheduler error
+ * in the hardware.
+ *
+ */
+static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u16 tci)
+{
+	struct scu_task_context *task_context;
+
+	task_context = scic_sds_controller_get_task_context_buffer(sci_port->owning_controller, tci);
+
+	memset(task_context, 0, sizeof(struct scu_task_context));
+
+	task_context->abort = 0;
+	task_context->priority = 0;
+	task_context->initiator_request = 1;
+	task_context->connection_rate = 1;
+	task_context->protocol_engine_index = 0;
+	task_context->logical_port_index = sci_port->physical_port_index;
+	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;
+	task_context->task_index = scic_sds_io_tag_get_index(tci);
+	task_context->valid = SCU_TASK_CONTEXT_VALID;
+	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
+
+	task_context->remote_node_index = sci_port->reserved_rni;
+	task_context->command_code = 0;
+
+	task_context->link_layer_control = 0;
+	task_context->do_not_dma_ssp_good_response = 1;
+	task_context->strict_ordering = 0;
+	task_context->control_frame = 0;
+	task_context->timeout_enable = 0;
+	task_context->block_guard_enable = 0;
+
+	task_context->address_modifier = 0;
+
+	task_context->task_phase = 0x01;
+}
+
+static void scic_sds_port_destroy_dummy_resources(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+
+	if (sci_port->reserved_tci != SCU_DUMMY_INDEX)
+		scic_controller_free_io_tag(scic, sci_port->reserved_tci);
+
+	if (sci_port->reserved_rni != SCU_DUMMY_INDEX)
+		scic_sds_remote_node_table_release_remote_node_index(&scic->available_remote_nodes,
+								     1, sci_port->reserved_rni);
+
+	sci_port->reserved_rni = SCU_DUMMY_INDEX;
+	sci_port->reserved_tci = SCU_DUMMY_INDEX;
+}
+
+/**
+ * This method performs initialization of the supplied port. Initialization
+ *    includes: - state machine initialization - member variable initialization
+ *    - configuring the phy_mask
+ * @sci_port:
+ * @transport_layer_registers:
+ * @port_task_scheduler_registers:
+ * @port_configuration_regsiter:
+ *
+ * enum sci_status SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION This value is returned
+ * if the phy being added to the port
+ */
+enum sci_status scic_sds_port_initialize(
+	struct scic_sds_port *sci_port,
+	void __iomem *port_task_scheduler_registers,
+	void __iomem *port_configuration_regsiter,
+	void __iomem *viit_registers)
+{
+	sci_port->port_task_scheduler_registers  = port_task_scheduler_registers;
+	sci_port->port_pe_configuration_register = port_configuration_regsiter;
+	sci_port->viit_registers                 = viit_registers;
+
+	return SCI_SUCCESS;
+}
+
+/**
+ * scic_port_hard_reset() - perform port hard reset
+ * @port: a handle corresponding to the SAS port to be hard reset.
+ * @reset_timeout: This parameter specifies the number of milliseconds in which
+ *    the port reset operation should complete.
+ *
+ * The SCI User callback in scic_user_callbacks_t will only be called once for
+ * each phy in the SAS Port at completion of the hard reset sequence. Return a
+ * status indicating whether the hard reset started successfully. SCI_SUCCESS
+ * This value is returned if the hard reset operation started successfully.
+ */
+static enum sci_status scic_port_hard_reset(struct scic_sds_port *port,
+					    u32 reset_timeout)
+{
+	return port->state_handlers->reset_handler(
+		       port, reset_timeout);
+}
+
+/**
+ * This method assigns the direct attached device ID for this port.
+ *
+ * @param[in] sci_port The port for which the direct attached device id is to
+ *       be assigned.
+ * @param[in] device_id The direct attached device ID to assign to the port.
+ *       This will be the RNi for the device
+ */
+void scic_sds_port_setup_transports(
+	struct scic_sds_port *sci_port,
+	u32 device_id)
+{
+	u8 index;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->active_phy_mask & (1 << index))
+			scic_sds_phy_setup_transport(sci_port->phy_table[index], device_id);
+	}
+}
+
+/**
+ *
+ * @sci_port: This is the port on which the phy should be enabled.
+ * @sci_phy: This is the specific phy which to enable.
+ * @do_notify_user: This parameter specifies whether to inform the user (via
+ *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
+ *
+ * This function will activate the phy in the port.
+ * Activation includes: - adding
+ * the phy to the port - enabling the Protocol Engine in the silicon. -
+ * notifying the user that the link is up. none
+ */
+static void scic_sds_port_activate_phy(struct scic_sds_port *sci_port,
+				       struct scic_sds_phy *sci_phy,
+				       bool do_notify_user)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
+		scic_sds_phy_resume(sci_phy);
+
+	sci_port->active_phy_mask |= 1 << sci_phy->phy_index;
+
+	scic_sds_controller_clear_invalid_phy(scic, sci_phy);
+
+	if (do_notify_user == true)
+		isci_port_link_up(ihost, sci_port, sci_phy);
+}
+
+void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
+				  struct scic_sds_phy *sci_phy,
+				  bool do_notify_user)
+{
+	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+	sci_port->active_phy_mask &= ~(1 << sci_phy->phy_index);
+
+	sci_phy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
+
+	/* Re-assign the phy back to the LP as if it were a narrow port */
+	writel(sci_phy->phy_index,
+		&sci_port->port_pe_configuration_register[sci_phy->phy_index]);
+
+	if (do_notify_user == true)
+		isci_port_link_down(ihost, iphy, iport);
+}
+
+/**
+ *
+ * @sci_port: This is the port on which the phy should be disabled.
+ * @sci_phy: This is the specific phy which to disabled.
+ *
+ * This function will disable the phy and report that the phy is not valid for
+ * this port object. None
+ */
+static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
+					  struct scic_sds_phy *sci_phy)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+
+	/*
+	 * Check to see if we have alreay reported this link as bad and if
+	 * not go ahead and tell the SCI_USER that we have discovered an
+	 * invalid link.
+	 */
+	if ((scic->invalid_phy_mask & (1 << sci_phy->phy_index)) == 0) {
+		scic_sds_controller_set_invalid_phy(scic, sci_phy);
+		dev_warn(&scic_to_ihost(scic)->pdev->dev, "Invalid link up!\n");
+	}
+}
+
+/**
+ * scic_sds_port_general_link_up_handler - phy can be assigned to port?
+ * @sci_port: scic_sds_port object for which has a phy that has gone link up.
+ * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
+ * @do_notify_user: This parameter specifies whether to inform the user (via
+ *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
+ *
+ * Determine if this phy can be assigned to this
+ * port . If the phy is not a valid PHY for
+ * this port then the function will notify the user. A PHY can only be
+ * part of a port if it's attached SAS ADDRESS is the same as all other PHYs in
+ * the same port. none
+ */
+static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port,
+						  struct scic_sds_phy *sci_phy,
+						  bool do_notify_user)
+{
+	struct sci_sas_address port_sas_address;
+	struct sci_sas_address phy_sas_address;
+
+	scic_sds_port_get_attached_sas_address(sci_port, &port_sas_address);
+	scic_sds_phy_get_attached_sas_address(sci_phy, &phy_sas_address);
+
+	/* If the SAS address of the new phy matches the SAS address of
+	 * other phys in the port OR this is the first phy in the port,
+	 * then activate the phy and allow it to be used for operations
+	 * in this port.
+	 */
+	if ((phy_sas_address.high == port_sas_address.high &&
+	     phy_sas_address.low  == port_sas_address.low) ||
+	    sci_port->active_phy_mask == 0) {
+		struct sci_base_state_machine *sm = &sci_port->state_machine;
+
+		scic_sds_port_activate_phy(sci_port, sci_phy, do_notify_user);
+		if (sm->current_state_id == SCI_BASE_PORT_STATE_RESETTING)
+			sci_base_state_machine_change_state(sm, SCI_BASE_PORT_STATE_READY);
+	} else
+		scic_sds_port_invalid_link_up(sci_port, sci_phy);
+}
+
+
+
+/**
+ * This method returns false if the port only has a single phy object assigned.
+ *     If there are no phys or more than one phy then the method will return
+ *    true.
+ * @sci_port: The port for which the wide port condition is to be checked.
+ *
+ * bool true Is returned if this is a wide ported port. false Is returned if
+ * this is a narrow port.
+ */
+static bool scic_sds_port_is_wide(struct scic_sds_port *sci_port)
+{
+	u32 index;
+	u32 phy_count = 0;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->phy_table[index] != NULL) {
+			phy_count++;
+		}
+	}
+
+	return phy_count != 1;
+}
+
+/**
+ * This method is called by the PHY object when the link is detected. if the
+ *    port wants the PHY to continue on to the link up state then the port
+ *    layer must return true.  If the port object returns false the phy object
+ *    must halt its attempt to go link up.
+ * @sci_port: The port associated with the phy object.
+ * @sci_phy: The phy object that is trying to go link up.
+ *
+ * true if the phy object can continue to the link up condition. true Is
+ * returned if this phy can continue to the ready state. false Is returned if
+ * can not continue on to the ready state. This notification is in place for
+ * wide ports and direct attached phys.  Since there are no wide ported SATA
+ * devices this could become an invalid port configuration.
+ */
+bool scic_sds_port_link_detected(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	if ((sci_port->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
+	    (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
+	    scic_sds_port_is_wide(sci_port)) {
+		scic_sds_port_invalid_link_up(sci_port, sci_phy);
+
+		return false;
+	}
+
+	return true;
+}
+
+/**
+ * This method is the entry point for the phy to inform the port that it is now
+ *    in a ready state
+ * @sci_port:
+ *
+ *
+ */
+void scic_sds_port_link_up(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	sci_phy->is_in_link_training = false;
+
+	sci_port->state_handlers->link_up_handler(sci_port, sci_phy);
+}
+
+/**
+ * This method is the entry point for the phy to inform the port that it is no
+ *    longer in a ready state
+ * @sci_port:
+ *
+ *
+ */
+void scic_sds_port_link_down(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	sci_port->state_handlers->link_down_handler(sci_port, sci_phy);
+}
+
+/**
+ * This method is called to start an IO request on this port.
+ * @sci_port:
+ * @sci_dev:
+ * @sci_req:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_port_start_io(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req)
+{
+	return sci_port->state_handlers->start_io_handler(
+		       sci_port, sci_dev, sci_req);
+}
+
+/**
+ * This method is called to complete an IO request to the port.
+ * @sci_port:
+ * @sci_dev:
+ * @sci_req:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_port_complete_io(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req)
+{
+	return sci_port->state_handlers->complete_io_handler(
+		       sci_port, sci_dev, sci_req);
+}
+
+/**
+ * This method is provided to timeout requests for port operations. Mostly its
+ *    for the port reset operation.
+ *
+ *
+ */
+static void scic_sds_port_timeout_handler(void *port)
+{
+	struct scic_sds_port *sci_port = port;
+	u32 current_state;
+
+	current_state = sci_base_state_machine_get_state(
+		&sci_port->state_machine);
+
+	if (current_state == SCI_BASE_PORT_STATE_RESETTING) {
+		/*
+		 * if the port is still in the resetting state then the
+		 * timeout fired before the reset completed.
+		 */
+		sci_base_state_machine_change_state(
+			&sci_port->state_machine,
+			SCI_BASE_PORT_STATE_FAILED);
+	} else if (current_state == SCI_BASE_PORT_STATE_STOPPED) {
+		/*
+		 * if the port is stopped then the start request failed
+		 * In this case stay in the stopped state.
+		 */
+		dev_err(sciport_to_dev(sci_port),
+			"%s: SCIC Port 0x%p failed to stop before tiemout.\n",
+			__func__,
+			sci_port);
+	} else if (current_state == SCI_BASE_PORT_STATE_STOPPING) {
+		/*
+		 * if the port is still stopping then the stop has not
+		 * completed
+		 */
+		isci_port_stop_complete(
+				scic_sds_port_get_controller(sci_port),
+				sci_port,
+				SCI_FAILURE_TIMEOUT);
+	} else {
+		/*
+		 * The port is in the ready state and we have a timer
+		 * reporting a timeout this should not happen.
+		 */
+		dev_err(sciport_to_dev(sci_port),
+			"%s: SCIC Port 0x%p is processing a timeout operation "
+			"in state %d.\n",
+			__func__,
+			sci_port,
+			current_state);
+	}
+}
+
+/* --------------------------------------------------------------------------- */
+
+/**
+ * This function updates the hardwares VIIT entry for this port.
+ *
+ *
+ */
+static void scic_sds_port_update_viit_entry(struct scic_sds_port *sci_port)
+{
+	struct sci_sas_address sas_address;
+
+	scic_sds_port_get_sas_address(sci_port, &sas_address);
+
+	writel(sas_address.high,
+		&sci_port->viit_registers->initiator_sas_address_hi);
+	writel(sas_address.low,
+		&sci_port->viit_registers->initiator_sas_address_lo);
+
+	/* This value get cleared just in case its not already cleared */
+	writel(0, &sci_port->viit_registers->reserved);
+
+	/* We are required to update the status register last */
+	writel(SCU_VIIT_ENTRY_ID_VIIT |
+	       SCU_VIIT_IPPT_INITIATOR |
+	       ((1 << sci_port->physical_port_index) << SCU_VIIT_ENTRY_LPVIE_SHIFT) |
+	       SCU_VIIT_STATUS_ALL_VALID,
+	       &sci_port->viit_registers->status);
+}
+
+/**
+ * This method returns the maximum allowed speed for data transfers on this
+ *    port.  This maximum allowed speed evaluates to the maximum speed of the
+ *    slowest phy in the port.
+ * @sci_port: This parameter specifies the port for which to retrieve the
+ *    maximum allowed speed.
+ *
+ * This method returns the maximum negotiated speed of the slowest phy in the
+ * port.
+ */
+enum sas_linkrate scic_sds_port_get_max_allowed_speed(
+	struct scic_sds_port *sci_port)
+{
+	u16 index;
+	enum sas_linkrate max_allowed_speed = SAS_LINK_RATE_6_0_GBPS;
+	struct scic_sds_phy *phy = NULL;
+
+	/*
+	 * Loop through all of the phys in this port and find the phy with the
+	 * lowest maximum link rate. */
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		phy = sci_port->phy_table[index];
+		if (
+			(phy != NULL)
+			&& (scic_sds_port_active_phy(sci_port, phy) == true)
+			&& (phy->max_negotiated_speed < max_allowed_speed)
+			)
+			max_allowed_speed = phy->max_negotiated_speed;
+	}
+
+	return max_allowed_speed;
+}
+
+static void scic_port_enable_broadcast_change_notification(struct scic_sds_port *port)
+{
+	struct scic_sds_phy *phy;
+	u32 register_value;
+	u8 index;
+
+	/* Loop through all of the phys to enable BCN. */
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		phy = port->phy_table[index];
+		if (phy != NULL) {
+			register_value =
+				readl(&phy->link_layer_registers->link_layer_control);
+
+			/* clear the bit by writing 1. */
+			writel(register_value,
+				&phy->link_layer_registers->link_layer_control);
+		}
+	}
+}
+
+/*
+ * ****************************************************************************
+ * *  READY SUBSTATE HANDLERS
+ * **************************************************************************** */
+
+/*
+ * This method is the general ready state stop handler for the struct scic_sds_port
+ * object.  This function will transition the ready substate machine to its
+ * final state. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_ready_substate_stop_handler(
+	struct scic_sds_port *port)
+{
+	sci_base_state_machine_change_state(
+		&port->state_machine,
+		SCI_BASE_PORT_STATE_STOPPING
+		);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method is the general ready substate complete io handler for the
+ * struct scic_sds_port object.  This function decrments the outstanding request count
+ * for this port object. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_ready_substate_complete_io_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	scic_sds_port_decrement_request_count(port);
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status scic_sds_port_ready_substate_add_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	enum sci_status status;
+
+	status = scic_sds_port_set_phy(port, phy);
+
+	if (status == SCI_SUCCESS) {
+		scic_sds_port_general_link_up_handler(port, phy, true);
+
+		port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+
+		sci_base_state_machine_change_state(
+			&port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
+			);
+	}
+
+	return status;
+}
+
+
+static enum sci_status scic_sds_port_ready_substate_remove_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	enum sci_status status;
+
+	status = scic_sds_port_clear_phy(port, phy);
+
+	if (status == SCI_SUCCESS) {
+		scic_sds_port_deactivate_phy(port, phy, true);
+
+		port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+
+		sci_base_state_machine_change_state(
+			&port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
+			);
+	}
+
+	return status;
+}
+
+/*
+ * ****************************************************************************
+ * *  READY SUBSTATE WAITING HANDLERS
+ * **************************************************************************** */
+
+/**
+ *
+ * @sci_port: This is the struct scic_sds_port object that which has a phy that has
+ *    gone link up.
+ * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
+ *
+ * This method is the ready waiting substate link up handler for the
+ * struct scic_sds_port object.  This methos will report the link up condition for
+ * this port and will transition to the ready operational substate. none
+ */
+static void scic_sds_port_ready_waiting_substate_link_up_handler(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	/*
+	 * Since this is the first phy going link up for the port we can just enable
+	 * it and continue. */
+	scic_sds_port_activate_phy(sci_port, sci_phy, true);
+
+	sci_base_state_machine_change_state(
+		&sci_port->ready_substate_machine,
+		SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
+		);
+}
+
+/*
+ * This method is the ready waiting substate start io handler for the
+ * struct scic_sds_port object. The port object can not accept new requests so the
+ * request is failed. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+static enum sci_status scic_sds_port_ready_waiting_substate_start_io_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+/*
+ * ****************************************************************************
+ * *  READY SUBSTATE OPERATIONAL HANDLERS
+ * **************************************************************************** */
+
+/*
+ * This method will casue the port to reset. enum sci_status SCI_SUCCESS
+ */
+static enum
+sci_status scic_sds_port_ready_operational_substate_reset_handler(
+		struct scic_sds_port *port,
+		u32 timeout)
+{
+	enum sci_status status = SCI_FAILURE_INVALID_PHY;
+	u32 phy_index;
+	struct scic_sds_phy *selected_phy = NULL;
+
+
+	/* Select a phy on which we can send the hard reset request. */
+	for (phy_index = 0;
+	     (phy_index < SCI_MAX_PHYS) && (selected_phy == NULL);
+	     phy_index++) {
+		selected_phy = port->phy_table[phy_index];
+
+		if ((selected_phy != NULL) &&
+		    !scic_sds_port_active_phy(port, selected_phy)) {
+			/*
+			 * We found a phy but it is not ready select
+			 * different phy
+			 */
+			selected_phy = NULL;
+		}
+	}
+
+	/* If we have a phy then go ahead and start the reset procedure */
+	if (selected_phy != NULL) {
+		status = scic_sds_phy_reset(selected_phy);
+
+		if (status == SCI_SUCCESS) {
+			isci_timer_start(port->timer_handle, timeout);
+			port->not_ready_reason =
+				SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
+
+			sci_base_state_machine_change_state(
+					&port->state_machine,
+					SCI_BASE_PORT_STATE_RESETTING);
+		}
+	}
+
+	return status;
+}
+
+/**
+ * scic_sds_port_ready_operational_substate_link_up_handler() -
+ * @sci_port: This is the struct scic_sds_port object that which has a phy that has
+ *    gone link up.
+ * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
+ *
+ * This method is the ready operational substate link up handler for the
+ * struct scic_sds_port object. This function notifies the SCI User that the phy has
+ * gone link up. none
+ */
+static void scic_sds_port_ready_operational_substate_link_up_handler(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+}
+
+/**
+ * scic_sds_port_ready_operational_substate_link_down_handler() -
+ * @sci_port: This is the struct scic_sds_port object that which has a phy that has
+ *    gone link down.
+ * @sci_phy: This is the struct scic_sds_phy object that has gone link down.
+ *
+ * This method is the ready operational substate link down handler for the
+ * struct scic_sds_port object. This function notifies the SCI User that the phy has
+ * gone link down and if this is the last phy in the port the port will change
+ * state to the ready waiting substate. none
+ */
+static void scic_sds_port_ready_operational_substate_link_down_handler(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+
+	/*
+	 * If there are no active phys left in the port, then transition
+	 * the port to the WAITING state until such time as a phy goes
+	 * link up. */
+	if (sci_port->active_phy_mask == 0)
+		sci_base_state_machine_change_state(&sci_port->ready_substate_machine,
+						    SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+}
+
+/*
+ * This method is the ready operational substate start io handler for the
+ * struct scic_sds_port object.  This function incremetns the outstanding request
+ * count for this port object. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_ready_operational_substate_start_io_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	port->started_request_count++;
+	return SCI_SUCCESS;
+}
+
+/*
+ * ****************************************************************************
+ * *  READY SUBSTATE OPERATIONAL HANDLERS
+ * **************************************************************************** */
+
+/*
+ * This is the default method for a port add phy request.  It will report a
+ * warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+static enum sci_status scic_sds_port_ready_configuring_substate_add_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	enum sci_status status;
+
+	status = scic_sds_port_set_phy(port, phy);
+
+	if (status == SCI_SUCCESS) {
+		scic_sds_port_general_link_up_handler(port, phy, true);
+
+		/*
+		 * Re-enter the configuring state since this may be the last phy in
+		 * the port. */
+		sci_base_state_machine_change_state(
+			&port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
+			);
+	}
+
+	return status;
+}
+
+/*
+ * This is the default method for a port remove phy request.  It will report a
+ * warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+static enum sci_status scic_sds_port_ready_configuring_substate_remove_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	enum sci_status status;
+
+	status = scic_sds_port_clear_phy(port, phy);
+
+	if (status == SCI_SUCCESS) {
+		scic_sds_port_deactivate_phy(port, phy, true);
+
+		/*
+		 * Re-enter the configuring state since this may be the last phy in
+		 * the port. */
+		sci_base_state_machine_change_state(
+			&port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
+			);
+	}
+
+	return status;
+}
+
+/**
+ * scic_sds_port_ready_configuring_substate_complete_io_handler() -
+ * @port: This is the port that is being requested to complete the io request.
+ * @device: This is the device on which the io is completing.
+ *
+ * This method will decrement the outstanding request count for this port. If
+ * the request count goes to 0 then the port can be reprogrammed with its new
+ * phy data.
+ */
+static enum sci_status
+scic_sds_port_ready_configuring_substate_complete_io_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	scic_sds_port_decrement_request_count(port);
+
+	if (port->started_request_count == 0) {
+		sci_base_state_machine_change_state(
+			&port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
+			);
+	}
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status default_port_handler(struct scic_sds_port *sci_port,
+					    const char *func)
+{
+	dev_warn(sciport_to_dev(sci_port),
+		 "%s: in wrong state: %d\n", func,
+		 sci_base_state_machine_get_state(&sci_port->state_machine));
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status
+scic_sds_port_default_start_handler(struct scic_sds_port *sci_port)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status
+scic_sds_port_default_stop_handler(struct scic_sds_port *sci_port)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status
+scic_sds_port_default_destruct_handler(struct scic_sds_port *sci_port)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status
+scic_sds_port_default_reset_handler(struct scic_sds_port *sci_port,
+				    u32 timeout)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status
+scic_sds_port_default_add_phy_handler(struct scic_sds_port *sci_port,
+				      struct scic_sds_phy *base_phy)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status
+scic_sds_port_default_remove_phy_handler(struct scic_sds_port *sci_port,
+					 struct scic_sds_phy *base_phy)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+/*
+ * This is the default method for a port unsolicited frame request.  It will
+ * report a warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE Is it even
+ * possible to receive an unsolicited frame directed to a port object?  It
+ * seems possible if we implementing virtual functions but until then?
+ */
+static enum sci_status
+scic_sds_port_default_frame_handler(struct scic_sds_port *sci_port,
+				    u32 frame_index)
+{
+	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
+
+	default_port_handler(sci_port, __func__);
+	scic_sds_controller_release_frame(scic, frame_index);
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status scic_sds_port_default_event_handler(struct scic_sds_port *sci_port,
+						    u32 event_code)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static void scic_sds_port_default_link_up_handler(struct scic_sds_port *sci_port,
+					   struct scic_sds_phy *sci_phy)
+{
+	default_port_handler(sci_port, __func__);
+}
+
+static void scic_sds_port_default_link_down_handler(struct scic_sds_port *sci_port,
+					     struct scic_sds_phy *sci_phy)
+{
+	default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status scic_sds_port_default_start_io_handler(struct scic_sds_port *sci_port,
+						       struct scic_sds_remote_device *sci_dev,
+						       struct scic_sds_request *sci_req)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status scic_sds_port_default_complete_io_handler(struct scic_sds_port *sci_port,
+								 struct scic_sds_remote_device *sci_dev,
+								 struct scic_sds_request *sci_req)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+
+
+static struct scic_sds_port_state_handler
+scic_sds_port_ready_substate_handler_table[SCIC_SDS_PORT_READY_MAX_SUBSTATES] = {
+	{
+		/* SCIC_SDS_PORT_READY_SUBSTATE_WAITING */
+		scic_sds_port_default_start_handler,
+		scic_sds_port_ready_substate_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_ready_substate_add_phy_handler,
+		scic_sds_port_default_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_ready_waiting_substate_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_ready_waiting_substate_start_io_handler,
+		scic_sds_port_ready_substate_complete_io_handler,
+	},
+
+	{
+		/* SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL */
+		scic_sds_port_default_start_handler,
+		scic_sds_port_ready_substate_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_ready_operational_substate_reset_handler,
+		scic_sds_port_ready_substate_add_phy_handler,
+		scic_sds_port_ready_substate_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_ready_operational_substate_link_up_handler,
+		scic_sds_port_ready_operational_substate_link_down_handler,
+		scic_sds_port_ready_operational_substate_start_io_handler,
+		scic_sds_port_ready_substate_complete_io_handler,
+	},
+
+	{
+		/* SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING */
+		scic_sds_port_default_start_handler,
+		scic_sds_port_ready_substate_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_ready_configuring_substate_add_phy_handler,
+		scic_sds_port_ready_configuring_substate_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_default_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_ready_configuring_substate_complete_io_handler
+	}
+};
+
+/**
+ * scic_sds_port_set_ready_state_handlers() -
+ *
+ * This macro sets the port ready substate handlers.
+ */
+#define scic_sds_port_set_ready_state_handlers(port, state_id) \
+	scic_sds_port_set_state_handlers(\
+		port, &scic_sds_port_ready_substate_handler_table[(state_id)] \
+		)
+
+/*
+ * ******************************************************************************
+ * *  PORT STATE PRIVATE METHODS
+ * ****************************************************************************** */
+
+/**
+ *
+ * @sci_port: This is the struct scic_sds_port object to suspend.
+ *
+ * This method will susped the port task scheduler for this port object. none
+ */
+static void
+scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port)
+{
+	u32 pts_control_value;
+
+	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value |= SCU_PTSxCR_GEN_BIT(SUSPEND);
+	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+}
+
+/**
+ * scic_sds_port_post_dummy_request() - post dummy/workaround request
+ * @sci_port: port to post task
+ *
+ * Prevent the hardware scheduler from posting new requests to the front
+ * of the scheduler queue causing a starvation problem for currently
+ * ongoing requests.
+ *
+ */
+static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
+{
+	u32 command;
+	struct scu_task_context *task_context;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	u16 tci = sci_port->reserved_tci;
+
+	task_context = scic_sds_controller_get_task_context_buffer(scic, tci);
+
+	task_context->abort = 0;
+
+	command = SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
+		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
+		  tci;
+
+	scic_sds_controller_post_request(scic, command);
+}
+
+/**
+ * This routine will abort the dummy request.  This will alow the hardware to
+ * power down parts of the silicon to save power.
+ *
+ * @sci_port: The port on which the task must be aborted.
+ *
+ */
+static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	u16 tci = sci_port->reserved_tci;
+	struct scu_task_context *tc;
+	u32 command;
+
+	tc = scic_sds_controller_get_task_context_buffer(scic, tci);
+
+	tc->abort = 1;
+
+	command = SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT |
+		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
+		  tci;
+
+	scic_sds_controller_post_request(scic, command);
+}
+
+/**
+ *
+ * @sci_port: This is the struct scic_sds_port object to resume.
+ *
+ * This method will resume the port task scheduler for this port object. none
+ */
+static void
+scic_sds_port_resume_port_task_scheduler(struct scic_sds_port *port)
+{
+	u32 pts_control_value;
+
+	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value &= ~SCU_PTSxCR_GEN_BIT(SUSPEND);
+	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+}
+
+/*
+ * ******************************************************************************
+ * *  PORT READY SUBSTATE METHODS
+ * ****************************************************************************** */
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * entering the SCIC_SDS_PORT_READY_SUBSTATE_WAITING. This function checks the
+ * port for any ready phys.  If there is at least one phy in a ready state then
+ * the port transitions to the ready operational substate. none
+ */
+static void scic_sds_port_ready_substate_waiting_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	scic_sds_port_set_ready_state_handlers(
+		sci_port, SCIC_SDS_PORT_READY_SUBSTATE_WAITING
+		);
+
+	scic_sds_port_suspend_port_task_scheduler(sci_port);
+
+	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
+
+	if (sci_port->active_phy_mask != 0) {
+		/* At least one of the phys on the port is ready */
+		sci_base_state_machine_change_state(
+			&sci_port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
+			);
+	}
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This function will perform the actions required by the struct scic_sds_port
+ * on entering the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function sets
+ * the state handlers for the port object, notifies the SCI User that the port
+ * is ready, and resumes port operations. none
+ */
+static void scic_sds_port_ready_substate_operational_enter(void *object)
+{
+	u32 index;
+	struct scic_sds_port *sci_port = object;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+
+	scic_sds_port_set_ready_state_handlers(
+			sci_port,
+			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+
+	isci_port_ready(ihost, iport);
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->phy_table[index]) {
+			writel(sci_port->physical_port_index,
+				&sci_port->port_pe_configuration_register[
+					sci_port->phy_table[index]->phy_index]);
+		}
+	}
+
+	scic_sds_port_update_viit_entry(sci_port);
+
+	scic_sds_port_resume_port_task_scheduler(sci_port);
+
+	/*
+	 * Post the dummy task for the port so the hardware can schedule
+	 * io correctly
+	 */
+	scic_sds_port_post_dummy_request(sci_port);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * exiting the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function reports
+ * the port not ready and suspends the port task scheduler. none
+ */
+static void scic_sds_port_ready_substate_operational_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+
+	/*
+	 * Kill the dummy task for this port if it has not yet posted
+	 * the hardware will treat this as a NOP and just return abort
+	 * complete.
+	 */
+	scic_sds_port_abort_dummy_request(sci_port);
+
+	isci_port_not_ready(ihost, iport);
+}
+
+/*
+ * ******************************************************************************
+ * *  PORT READY CONFIGURING METHODS
+ * ****************************************************************************** */
+
+/**
+ * scic_sds_port_ready_substate_configuring_enter() -
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * exiting the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function reports
+ * the port not ready and suspends the port task scheduler. none
+ */
+static void scic_sds_port_ready_substate_configuring_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+
+	scic_sds_port_set_ready_state_handlers(
+			sci_port,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+
+	if (sci_port->active_phy_mask == 0) {
+		isci_port_not_ready(ihost, iport);
+
+		sci_base_state_machine_change_state(
+				&sci_port->ready_substate_machine,
+				SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+	} else if (sci_port->started_request_count == 0)
+		sci_base_state_machine_change_state(
+				&sci_port->ready_substate_machine,
+				SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+}
+
+static void scic_sds_port_ready_substate_configuring_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	scic_sds_port_suspend_port_task_scheduler(sci_port);
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct sci_base_state scic_sds_port_ready_substate_table[] = {
+	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
+		.enter_state = scic_sds_port_ready_substate_waiting_enter,
+	},
+	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
+		.enter_state = scic_sds_port_ready_substate_operational_enter,
+		.exit_state  = scic_sds_port_ready_substate_operational_exit
+	},
+	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
+		.enter_state = scic_sds_port_ready_substate_configuring_enter,
+		.exit_state  = scic_sds_port_ready_substate_configuring_exit
+	},
+};
+
+/**
+ *
+ * @port: This is the struct scic_sds_port object on which the io request count will
+ *    be decremented.
+ * @device: This is the struct scic_sds_remote_device object to which the io request
+ *    is being directed.  This parameter is not required to complete this
+ *    operation.
+ * @io_request: This is the request that is being completed on this port
+ *    object.  This parameter is not required to complete this operation.
+ *
+ * This is a general complete io request handler for the struct scic_sds_port object.
+ * enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_general_complete_io_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	scic_sds_port_decrement_request_count(port);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ * scic_sds_port_stopped_state_start_handler() - stop a port from "started"
+ *
+ * @port: This is the struct scic_sds_port object which is cast into a
+ * struct scic_sds_port object.
+ *
+ * This function takes the struct scic_sds_port from a stopped state and
+ * attempts to start it.  To start a port it must have no assiged devices and
+ * it must have at least one phy assigned to it.  If those conditions are
+ * met then the port can transition to the ready state.
+ * enum sci_status
+ * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
+ * This struct scic_sds_port object could not be started because the port
+ * configuration is not valid.
+ * SCI_SUCCESS
+ * the start request is successful and the struct scic_sds_port object
+ * has transitioned to the SCI_BASE_PORT_STATE_READY.
+ */
+static enum sci_status
+scic_sds_port_stopped_state_start_handler(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	enum sci_status status = SCI_SUCCESS;
+	u32 phy_mask;
+
+	if (sci_port->assigned_device_count > 0) {
+		/*
+		 * @todo This is a start failure operation because
+		 * there are still devices assigned to this port.
+		 * There must be no devices assigned to a port on a
+		 * start operation.
+		 */
+		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+	}
+
+	sci_port->timer_handle =
+		isci_timer_create(ihost,
+				  sci_port,
+				  scic_sds_port_timeout_handler);
+
+	if (!sci_port->timer_handle)
+		return SCI_FAILURE_INSUFFICIENT_RESOURCES;
+
+	if (sci_port->reserved_rni == SCU_DUMMY_INDEX) {
+		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
+				&scic->available_remote_nodes, 1);
+
+		if (rni != SCU_DUMMY_INDEX)
+			scic_sds_port_construct_dummy_rnc(sci_port, rni);
+		else
+			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
+		sci_port->reserved_rni = rni;
+	}
+
+	if (sci_port->reserved_tci == SCU_DUMMY_INDEX) {
+		/* Allocate a TCI and remove the sequence nibble */
+		u16 tci = scic_controller_allocate_io_tag(scic);
+
+		if (tci != SCU_DUMMY_INDEX)
+			scic_sds_port_construct_dummy_task(sci_port, tci);
+		else
+			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
+		sci_port->reserved_tci = tci;
+	}
+
+	if (status == SCI_SUCCESS) {
+		phy_mask = scic_sds_port_get_phys(sci_port);
+
+		/*
+		 * There are one or more phys assigned to this port.  Make sure
+		 * the port's phy mask is in fact legal and supported by the
+		 * silicon.
+		 */
+		if (scic_sds_port_is_phy_mask_valid(sci_port, phy_mask) == true) {
+			sci_base_state_machine_change_state(
+				&sci_port->state_machine,
+				SCI_BASE_PORT_STATE_READY);
+
+			return SCI_SUCCESS;
+		} else
+			status = SCI_FAILURE;
+	}
+
+	if (status != SCI_SUCCESS)
+		scic_sds_port_destroy_dummy_resources(sci_port);
+
+	return status;
+}
+
+/*
+ * This method takes the struct scic_sds_port that is in a stopped state and handles a
+ * stop request.  This function takes no action. enum sci_status SCI_SUCCESS the
+ * stop request is successful as the struct scic_sds_port object is already stopped.
+ */
+static enum sci_status scic_sds_port_stopped_state_stop_handler(
+	struct scic_sds_port *port)
+{
+	/* We are already stopped so there is nothing to do here */
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method takes the struct scic_sds_port that is in a stopped state and handles
+ * the destruct request.  The stopped state is the only state in which the
+ * struct scic_sds_port can be destroyed.  This function causes the port object to
+ * transition to the SCI_BASE_PORT_STATE_FINAL. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_stopped_state_destruct_handler(
+	struct scic_sds_port *port)
+{
+	sci_base_state_machine_stop(&port->state_machine);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method takes the struct scic_sds_port that is in a stopped state and handles
+ * the add phy request.  In MPC mode the only time a phy can be added to a port
+ * is in the SCI_BASE_PORT_STATE_STOPPED. enum sci_status
+ * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION is returned when the phy can not
+ * be added to the port. SCI_SUCCESS if the phy is added to the port.
+ */
+static enum sci_status scic_sds_port_stopped_state_add_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	struct sci_sas_address port_sas_address;
+
+	/* Read the port assigned SAS Address if there is one */
+	scic_sds_port_get_sas_address(port, &port_sas_address);
+
+	if (port_sas_address.high != 0 && port_sas_address.low != 0) {
+		struct sci_sas_address phy_sas_address;
+
+		/*
+		 * Make sure that the PHY SAS Address matches the SAS Address
+		 * for this port. */
+		scic_sds_phy_get_sas_address(phy, &phy_sas_address);
+
+		if (
+			(port_sas_address.high != phy_sas_address.high)
+			|| (port_sas_address.low  != phy_sas_address.low)
+			) {
+			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+		}
+	}
+
+	return scic_sds_port_set_phy(port, phy);
+}
+
+/*
+ * This method takes the struct scic_sds_port that is in a stopped state and handles
+ * the remove phy request.  In MPC mode the only time a phy can be removed from
+ * a port is in the SCI_BASE_PORT_STATE_STOPPED. enum sci_status
+ * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION is returned when the phy can not
+ * be added to the port. SCI_SUCCESS if the phy is added to the port.
+ */
+static enum sci_status scic_sds_port_stopped_state_remove_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	return scic_sds_port_clear_phy(port, phy);
+}
+
+/*
+ * ****************************************************************************
+ * *  READY STATE HANDLERS
+ * **************************************************************************** */
+
+/*
+ * ****************************************************************************
+ * *  RESETTING STATE HANDLERS
+ * **************************************************************************** */
+
+/*
+ * ****************************************************************************
+ * *  STOPPING STATE HANDLERS
+ * **************************************************************************** */
+
+/*
+ * This method takes the struct scic_sds_port that is in a stopping state and handles
+ * the complete io request. Should the request count reach 0 then the port
+ * object will transition to the stopped state. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_stopping_state_complete_io_handler(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	scic_sds_port_decrement_request_count(sci_port);
+
+	if (sci_port->started_request_count == 0) {
+		sci_base_state_machine_change_state(&sci_port->state_machine,
+						    SCI_BASE_PORT_STATE_STOPPED);
+	}
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * ****************************************************************************
+ * *  RESETTING STATE HANDLERS
+ * **************************************************************************** */
+
+/**
+ *
+ * @port: This is the port object which is being requested to stop.
+ *
+ * This method will stop a failed port.  This causes a transition to the
+ * stopping state. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_reset_state_stop_handler(
+	struct scic_sds_port *port)
+{
+	sci_base_state_machine_change_state(
+		&port->state_machine,
+		SCI_BASE_PORT_STATE_STOPPING
+		);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method will transition a failed port to its ready state.  The port
+ * failed because a hard reset request timed out but at some time later one or
+ * more phys in the port became ready. enum sci_status SCI_SUCCESS
+ */
+static void scic_sds_port_reset_state_link_up_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	/*
+	 * / @todo We should make sure that the phy that has gone link up is the same
+	 * /       one on which we sent the reset.  It is possible that the phy on
+	 * /       which we sent the reset is not the one that has gone link up and we
+	 * /       want to make sure that phy being reset comes back.  Consider the
+	 * /       case where a reset is sent but before the hardware processes the
+	 * /       reset it get a link up on the port because of a hot plug event.
+	 * /       because of the reset request this phy will go link down almost
+	 * /       immediately. */
+
+	/*
+	 * In the resetting state we don't notify the user regarding
+	 * link up and link down notifications. */
+	scic_sds_port_general_link_up_handler(port, phy, false);
+}
+
+/*
+ * This method process link down notifications that occur during a port reset
+ * operation. Link downs can occur during the reset operation. enum sci_status
+ * SCI_SUCCESS
+ */
+static void scic_sds_port_reset_state_link_down_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	/*
+	 * In the resetting state we don't notify the user regarding
+	 * link up and link down notifications. */
+	scic_sds_port_deactivate_phy(port, phy, false);
+}
+
+static struct scic_sds_port_state_handler
+scic_sds_port_state_handler_table[SCI_BASE_PORT_MAX_STATES] =
+{
+	/* SCI_BASE_PORT_STATE_STOPPED */
+	{
+		scic_sds_port_stopped_state_start_handler,
+		scic_sds_port_stopped_state_stop_handler,
+		scic_sds_port_stopped_state_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_stopped_state_add_phy_handler,
+		scic_sds_port_stopped_state_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_default_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_default_complete_io_handler
+	},
+	/* SCI_BASE_PORT_STATE_STOPPING */
+	{
+		scic_sds_port_default_start_handler,
+		scic_sds_port_default_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_default_add_phy_handler,
+		scic_sds_port_default_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_default_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_stopping_state_complete_io_handler
+	},
+	/* SCI_BASE_PORT_STATE_READY */
+	{
+		scic_sds_port_default_start_handler,
+		scic_sds_port_default_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_default_add_phy_handler,
+		scic_sds_port_default_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_default_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_general_complete_io_handler
+	},
+	/* SCI_BASE_PORT_STATE_RESETTING */
+	{
+		scic_sds_port_default_start_handler,
+		scic_sds_port_reset_state_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_default_add_phy_handler,
+		scic_sds_port_default_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_reset_state_link_up_handler,
+		scic_sds_port_reset_state_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_general_complete_io_handler
+	},
+	/* SCI_BASE_PORT_STATE_FAILED */
+	{
+		scic_sds_port_default_start_handler,
+		scic_sds_port_default_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_default_add_phy_handler,
+		scic_sds_port_default_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_default_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_general_complete_io_handler
+	}
+};
+
+/*
+ * ******************************************************************************
+ * *  PORT STATE PRIVATE METHODS
+ * ****************************************************************************** */
+
+/**
+ *
+ * @sci_port: This is the port object which to suspend.
+ *
+ * This method will enable the SCU Port Task Scheduler for this port object but
+ * will leave the port task scheduler in a suspended state. none
+ */
+static void
+scic_sds_port_enable_port_task_scheduler(struct scic_sds_port *port)
+{
+	u32 pts_control_value;
+
+	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value |= SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND);
+	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+}
+
+/**
+ *
+ * @sci_port: This is the port object which to resume.
+ *
+ * This method will disable the SCU port task scheduler for this port object.
+ * none
+ */
+static void
+scic_sds_port_disable_port_task_scheduler(struct scic_sds_port *port)
+{
+	u32 pts_control_value;
+
+	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value &=
+		~(SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND));
+	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+}
+
+static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	u8 phys_index = sci_port->physical_port_index;
+	union scu_remote_node_context *rnc;
+	u16 rni = sci_port->reserved_rni;
+	u32 command;
+
+	rnc = &scic->remote_node_context_table[rni];
+	rnc->ssp.is_valid = true;
+
+	command = SCU_CONTEXT_COMMAND_POST_RNC_32 |
+		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
+
+	scic_sds_controller_post_request(scic, command);
+
+	/* ensure hardware has seen the post rnc command and give it
+	 * ample time to act before sending the suspend
+	 */
+	readl(&scic->smu_registers->interrupt_status); /* flush */
+	udelay(10);
+
+	command = SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX_RX |
+		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
+
+	scic_sds_controller_post_request(scic, command);
+}
+
+static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	u8 phys_index = sci_port->physical_port_index;
+	union scu_remote_node_context *rnc;
+	u16 rni = sci_port->reserved_rni;
+	u32 command;
+
+	rnc = &scic->remote_node_context_table[rni];
+
+	rnc->ssp.is_valid = false;
+
+	/* ensure the preceding tc abort request has reached the
+	 * controller and give it ample time to act before posting the rnc
+	 * invalidate
+	 */
+	readl(&scic->smu_registers->interrupt_status); /* flush */
+	udelay(10);
+
+	command = SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE |
+		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
+
+	scic_sds_controller_post_request(scic, command);
+}
+
+/*
+ * ******************************************************************************
+ * *  PORT STATE METHODS
+ * ****************************************************************************** */
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * entering the SCI_BASE_PORT_STATE_STOPPED. This function sets the stopped
+ * state handlers for the struct scic_sds_port object and disables the port task
+ * scheduler in the hardware. none
+ */
+static void scic_sds_port_stopped_state_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	scic_sds_port_set_base_state_handlers(
+		sci_port, SCI_BASE_PORT_STATE_STOPPED
+		);
+
+	if (
+		SCI_BASE_PORT_STATE_STOPPING
+		== sci_port->state_machine.previous_state_id
+		) {
+		/*
+		 * If we enter this state becasuse of a request to stop
+		 * the port then we want to disable the hardwares port
+		 * task scheduler. */
+		scic_sds_port_disable_port_task_scheduler(sci_port);
+	}
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * exiting the SCI_BASE_STATE_STOPPED. This function enables the SCU hardware
+ * port task scheduler. none
+ */
+static void scic_sds_port_stopped_state_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	/* Enable and suspend the port task scheduler */
+	scic_sds_port_enable_port_task_scheduler(sci_port);
+}
+
+/**
+ * scic_sds_port_ready_state_enter -
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * entering the SCI_BASE_PORT_STATE_READY. This function sets the ready state
+ * handlers for the struct scic_sds_port object, reports the port object as
+ * not ready and starts the ready substate machine. none
+ */
+static void scic_sds_port_ready_state_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+	u32 prev_state;
+
+	/* Put the ready state handlers in place though they will not be there long */
+	scic_sds_port_set_base_state_handlers(sci_port, SCI_BASE_PORT_STATE_READY);
+
+	prev_state = sci_port->state_machine.previous_state_id;
+	if (prev_state  == SCI_BASE_PORT_STATE_RESETTING)
+		isci_port_hard_reset_complete(iport, SCI_SUCCESS);
+	else
+		isci_port_not_ready(ihost, iport);
+
+	/* Post and suspend the dummy remote node context for this port. */
+	scic_sds_port_post_dummy_remote_node(sci_port);
+
+	/* Start the ready substate machine */
+	sci_base_state_machine_start(&sci_port->ready_substate_machine);
+}
+
+static void scic_sds_port_ready_state_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	sci_base_state_machine_stop(&sci_port->ready_substate_machine);
+	scic_sds_port_invalidate_dummy_remote_node(sci_port);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * entering the SCI_BASE_PORT_STATE_RESETTING. This function sets the resetting
+ * state handlers for the struct scic_sds_port object. none
+ */
+static void scic_sds_port_resetting_state_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	scic_sds_port_set_base_state_handlers(
+		sci_port, SCI_BASE_PORT_STATE_RESETTING
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This function will perform the actions required by the
+ * struct scic_sds_port on
+ * exiting the SCI_BASE_STATE_RESETTING. This function does nothing. none
+ */
+static inline void scic_sds_port_resetting_state_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	isci_timer_stop(sci_port->timer_handle);
+}
+
+/**
+ *
+ * @object: This is the void object which is cast to a
+ * struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * entering the SCI_BASE_PORT_STATE_STOPPING. This function sets the stopping
+ * state handlers for the struct scic_sds_port object. none
+ */
+static void scic_sds_port_stopping_state_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	scic_sds_port_set_base_state_handlers(
+		sci_port, SCI_BASE_PORT_STATE_STOPPING
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This function will perform the actions required by the
+ * struct scic_sds_port on
+ * exiting the SCI_BASE_STATE_STOPPING. This function does nothing. none
+ */
+static inline void
+scic_sds_port_stopping_state_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	isci_timer_stop(sci_port->timer_handle);
+
+	scic_sds_port_destroy_dummy_resources(sci_port);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This function will perform the actions required by the
+ * struct scic_sds_port on
+ * entering the SCI_BASE_PORT_STATE_STOPPING. This function sets the stopping
+ * state handlers for the struct scic_sds_port object. none
+ */
+static void scic_sds_port_failed_state_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+
+	scic_sds_port_set_base_state_handlers(sci_port,
+					      SCI_BASE_PORT_STATE_FAILED);
+
+	isci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct sci_base_state scic_sds_port_state_table[] = {
+	[SCI_BASE_PORT_STATE_STOPPED] = {
+		.enter_state = scic_sds_port_stopped_state_enter,
+		.exit_state  = scic_sds_port_stopped_state_exit
+	},
+	[SCI_BASE_PORT_STATE_STOPPING] = {
+		.enter_state = scic_sds_port_stopping_state_enter,
+		.exit_state  = scic_sds_port_stopping_state_exit
+	},
+	[SCI_BASE_PORT_STATE_READY] = {
+		.enter_state = scic_sds_port_ready_state_enter,
+		.exit_state  = scic_sds_port_ready_state_exit
+	},
+	[SCI_BASE_PORT_STATE_RESETTING] = {
+		.enter_state = scic_sds_port_resetting_state_enter,
+		.exit_state  = scic_sds_port_resetting_state_exit
+	},
+	[SCI_BASE_PORT_STATE_FAILED] = {
+		.enter_state = scic_sds_port_failed_state_enter,
+	}
+};
+
+void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
+			     struct scic_sds_controller *scic)
+{
+	sci_base_state_machine_construct(&sci_port->state_machine,
+					 sci_port,
+					 scic_sds_port_state_table,
+					 SCI_BASE_PORT_STATE_STOPPED);
+
+	sci_base_state_machine_start(&sci_port->state_machine);
+
+	sci_base_state_machine_construct(&sci_port->ready_substate_machine,
+					 sci_port,
+					 scic_sds_port_ready_substate_table,
+					 SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+
+	sci_port->logical_port_index  = SCIC_SDS_DUMMY_PORT;
+	sci_port->physical_port_index = index;
+	sci_port->active_phy_mask     = 0;
+
+	sci_port->owning_controller = scic;
+
+	sci_port->started_request_count = 0;
+	sci_port->assigned_device_count = 0;
+
+	sci_port->reserved_rni = SCU_DUMMY_INDEX;
+	sci_port->reserved_tci = SCU_DUMMY_INDEX;
+
+	sci_port->timer_handle = NULL;
+	sci_port->port_task_scheduler_registers = NULL;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++)
+		sci_port->phy_table[index] = NULL;
+}
+
+void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
+{
+	INIT_LIST_HEAD(&iport->remote_dev_list);
+	INIT_LIST_HEAD(&iport->domain_dev_list);
+	spin_lock_init(&iport->state_lock);
+	init_completion(&iport->start_complete);
+	iport->isci_host = ihost;
+	isci_port_change_state(iport, isci_freed);
+}
+
+/**
+ * isci_port_get_state() - This function gets the status of the port object.
+ * @isci_port: This parameter points to the isci_port object
+ *
+ * status of the object as a isci_status enum.
+ */
+enum isci_status isci_port_get_state(
+	struct isci_port *isci_port)
+{
+	return isci_port->status;
+}
+
+static void isci_port_bc_change_received(struct isci_host *ihost,
+					 struct scic_sds_port *sci_port,
+					 struct scic_sds_phy *sci_phy)
+{
+	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+	dev_dbg(&ihost->pdev->dev, "%s: iphy = %p, sas_phy = %p\n",
+		__func__, iphy, &iphy->sas_phy);
+
+	ihost->sas_ha.notify_port_event(&iphy->sas_phy, PORTE_BROADCAST_RCVD);
+	scic_port_enable_broadcast_change_notification(sci_port);
+}
+
+void scic_sds_port_broadcast_change_received(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	/* notify the user. */
+	isci_port_bc_change_received(ihost, sci_port, sci_phy);
+}
+
 int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,
 				 struct isci_phy *iphy)
 {
@@ -359,9 +2675,24 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	return ret;
 }
 
-void isci_port_stop_complete(struct scic_sds_controller *scic,
-					  struct scic_sds_port *sci_port,
-					  enum sci_status completion_status)
+/**
+ * isci_port_deformed() - This function is called by libsas when a port becomes
+ *    inactive.
+ * @phy: This parameter specifies the libsas phy with the inactive port.
+ *
+ */
+void isci_port_deformed(struct asd_sas_phy *phy)
 {
-	dev_dbg(&scic_to_ihost(scic)->pdev->dev, "Port stop complete\n");
+	pr_debug("%s: sas_phy = %p\n", __func__, phy);
+}
+
+/**
+ * isci_port_formed() - This function is called by libsas when a port becomes
+ *    active.
+ * @phy: This parameter specifies the libsas phy with the active port.
+ *
+ */
+void isci_port_formed(struct asd_sas_phy *phy)
+{
+	pr_debug("%s: sas_phy = %p, sas_port = %p\n", __func__, phy, phy->port);
 }
diff --git a/drivers/scsi/isci/port.h b/drivers/scsi/isci/port.h
index 59505cb..ea41dce 100644
--- a/drivers/scsi/isci/port.h
+++ b/drivers/scsi/isci/port.h
@@ -58,7 +58,10 @@
 
 #include <scsi/libsas.h>
 #include "isci.h"
-#include "scic_sds_port.h"
+#include "sas.h"
+#include "phy.h"
+
+#define SCIC_SDS_DUMMY_PORT   0xFF
 
 struct isci_phy;
 struct isci_host;
@@ -73,6 +76,111 @@ enum isci_status {
 };
 
 /**
+ * struct scic_sds_port
+ *
+ * The core port object provides the the abstraction for an SCU port.
+ */
+struct scic_sds_port {
+
+	/**
+	 * This field contains the information for the base port state machine.
+	 */
+	struct sci_base_state_machine state_machine;
+
+	/**
+	 * This field is the port index that is reported to the SCI USER.
+	 * This allows the actual hardware physical port to change without
+	 * the SCI USER getting a different answer for the get port index.
+	 */
+	u8 logical_port_index;
+
+	/**
+	 * This field is the port index used to program the SCU hardware.
+	 */
+	u8 physical_port_index;
+
+	/**
+	 * This field contains the active phy mask for the port.
+	 * This mask is used in conjunction with the phy state to determine
+	 * which phy to select for some port operations.
+	 */
+	u8 active_phy_mask;
+
+	u16 reserved_rni;
+	u16 reserved_tci;
+
+	/**
+	 * This field contains the count of the io requests started on this port
+	 * object.  It is used to control controller shutdown.
+	 */
+	u32 started_request_count;
+
+	/**
+	 * This field contains the number of devices assigned to this port.
+	 * It is used to control port start requests.
+	 */
+	u32 assigned_device_count;
+
+	/**
+	 * This field contains the reason for the port not going ready.  It is
+	 * assigned in the state handlers and used in the state transition.
+	 */
+	u32 not_ready_reason;
+
+	/**
+	 * This field is the table of phys assigned to the port.
+	 */
+	struct scic_sds_phy *phy_table[SCI_MAX_PHYS];
+
+	/**
+	 * This field is a pointer back to the controller that owns this
+	 * port object.
+	 */
+	struct scic_sds_controller *owning_controller;
+
+	/**
+	 * This field contains the port start/stop timer handle.
+	 */
+	void *timer_handle;
+
+	/**
+	 * This field points to the current set of state handlers for this port
+	 * object.  These state handlers are assigned at each enter state of
+	 * the state machine.
+	 */
+	struct scic_sds_port_state_handler *state_handlers;
+
+	/**
+	 * This field is the ready substate machine for the port.
+	 */
+	struct sci_base_state_machine ready_substate_machine;
+
+	/* / Memory mapped hardware register space */
+
+	/**
+	 * This field is the pointer to the port task scheduler registers
+	 * for the SCU hardware.
+	 */
+	struct scu_port_task_scheduler_registers __iomem
+		*port_task_scheduler_registers;
+
+	/**
+	 * This field is identical for all port objects and points to the port
+	 * task scheduler group PE configuration registers.
+	 * It is used to assign PEs to a port.
+	 */
+	u32 __iomem *port_pe_configuration_register;
+
+	/**
+	 * This field is the VIIT register space for ths port object.
+	 */
+	struct scu_viit_entry __iomem *viit_registers;
+
+};
+
+
+
+/**
  * struct isci_port - This class represents the port object used to internally
  *    represent libsas port objects. It also keeps a list of remote device
  *    objects.
@@ -99,54 +207,301 @@ static inline struct isci_port *sci_port_to_iport(struct scic_sds_port *sci_port
 	return iport;
 }
 
-enum isci_status isci_port_get_state(
-	struct isci_port *isci_port);
+enum scic_port_not_ready_reason_code {
+	SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS,
+	SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED,
+	SCIC_PORT_NOT_READY_INVALID_PORT_CONFIGURATION,
+	SCIC_PORT_NOT_READY_RECONFIGURING,
+
+	SCIC_PORT_NOT_READY_REASON_CODE_MAX
+};
+
+struct scic_port_end_point_properties {
+	struct sci_sas_address sas_address;
+	struct scic_phy_proto protocols;
+};
+
+struct scic_port_properties {
+	u32 index;
+	struct scic_port_end_point_properties local;
+	struct scic_port_end_point_properties remote;
+	u32 phy_mask;
+};
+
+/**
+ * enum SCIC_SDS_PORT_READY_SUBSTATES -
+ *
+ * This enumeration depicts all of the states for the core port ready substate
+ * machine.
+ */
+enum scic_sds_port_ready_substates {
+	/**
+	 * The substate where the port is started and ready but has no
+	 * active phys.
+	 */
+	SCIC_SDS_PORT_READY_SUBSTATE_WAITING,
+
+	/**
+	 * The substate where the port is started and ready and there is
+	 * at least one phy operational.
+	 */
+	SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL,
+
+	/**
+	 * The substate where the port is started and there was an
+	 * add/remove phy event.  This state is only used in Automatic
+	 * Port Configuration Mode (APC)
+	 */
+	SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING,
+
+	SCIC_SDS_PORT_READY_MAX_SUBSTATES
+};
+
+/**
+ * enum scic_sds_port_states - This enumeration depicts all the states for the
+ *    common port state machine.
+ *
+ *
+ */
+enum scic_sds_port_states {
+	/**
+	 * This state indicates that the port has successfully been stopped.
+	 * In this state no new IO operations are permitted.
+	 * This state is entered from the STOPPING state.
+	 */
+	SCI_BASE_PORT_STATE_STOPPED,
+
+	/**
+	 * This state indicates that the port is in the process of stopping.
+	 * In this state no new IO operations are permitted, but existing IO
+	 * operations are allowed to complete.
+	 * This state is entered from the READY state.
+	 */
+	SCI_BASE_PORT_STATE_STOPPING,
+
+	/**
+	 * This state indicates the port is now ready.  Thus, the user is
+	 * able to perform IO operations on this port.
+	 * This state is entered from the STARTING state.
+	 */
+	SCI_BASE_PORT_STATE_READY,
+
+	/**
+	 * This state indicates the port is in the process of performing a hard
+	 * reset.  Thus, the user is unable to perform IO operations on this
+	 * port.
+	 * This state is entered from the READY state.
+	 */
+	SCI_BASE_PORT_STATE_RESETTING,
+
+	/**
+	 * This state indicates the port has failed a reset request.  This state
+	 * is entered when a port reset request times out.
+	 * This state is entered from the RESETTING state.
+	 */
+	SCI_BASE_PORT_STATE_FAILED,
+
+	SCI_BASE_PORT_MAX_STATES
+
+};
+
+struct scic_sds_remote_device;
+struct scic_sds_request;
+
+typedef enum sci_status (*scic_sds_port_handler_t)(struct scic_sds_port *);
 
-void isci_port_formed(
-	struct asd_sas_phy *);
+typedef enum sci_status (*scic_sds_port_phy_handler_t)(struct scic_sds_port *,
+						       struct scic_sds_phy *);
 
-void isci_port_deformed(
-	struct asd_sas_phy *);
+typedef enum sci_status (*scic_sds_port_reset_handler_t)(struct scic_sds_port *,
+							 u32 timeout);
 
-void isci_port_bc_change_received(
-	struct isci_host *isci_host,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy);
+typedef enum sci_status (*scic_sds_port_event_handler_t)(struct scic_sds_port *, u32);
 
-void isci_port_link_up(
-	struct isci_host *isci_host,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy);
+typedef enum sci_status (*scic_sds_port_frame_handler_t)(struct scic_sds_port *, u32);
 
-void isci_port_link_down(
-	struct isci_host *isci_host,
-	struct isci_phy *isci_phy,
-	struct isci_port *port);
+typedef void (*scic_sds_port_link_handler_t)(struct scic_sds_port *, struct scic_sds_phy *);
 
-void isci_port_ready(
-	struct isci_host *isci_host,
+typedef enum sci_status (*scic_sds_port_io_request_handler_t)(struct scic_sds_port *,
+							      struct scic_sds_remote_device *,
+							      struct scic_sds_request *);
+
+struct scic_sds_port_state_handler {
+	/**
+	 * The start_handler specifies the method invoked when a user
+	 * attempts to start a port.
+	 */
+	scic_sds_port_handler_t start_handler;
+
+	/**
+	 * The stop_handler specifies the method invoked when a user
+	 * attempts to stop a port.
+	 */
+	scic_sds_port_handler_t stop_handler;
+
+	/**
+	 * The destruct_handler specifies the method invoked when attempting to
+	 * destruct a port.
+	 */
+	scic_sds_port_handler_t destruct_handler;
+
+	/**
+	 * The reset_handler specifies the method invoked when a user
+	 * attempts to hard reset a port.
+	 */
+	scic_sds_port_reset_handler_t reset_handler;
+
+	/**
+	 * The add_phy_handler specifies the method invoked when a user
+	 * attempts to add another phy into the port.
+	 */
+	scic_sds_port_phy_handler_t add_phy_handler;
+
+	/**
+	 * The remove_phy_handler specifies the method invoked when a user
+	 * attempts to remove a phy from the port.
+	 */
+	scic_sds_port_phy_handler_t remove_phy_handler;
+
+	scic_sds_port_frame_handler_t frame_handler;
+	scic_sds_port_event_handler_t event_handler;
+
+	scic_sds_port_link_handler_t link_up_handler;
+	scic_sds_port_link_handler_t link_down_handler;
+
+	scic_sds_port_io_request_handler_t start_io_handler;
+	scic_sds_port_io_request_handler_t complete_io_handler;
+
+};
+
+/**
+ * scic_sds_port_get_controller() -
+ *
+ * Helper macro to get the owning controller of this port
+ */
+#define scic_sds_port_get_controller(this_port)	\
+	((this_port)->owning_controller)
+
+/**
+ * scic_sds_port_set_base_state_handlers() -
+ *
+ * This macro will change the state handlers to those of the specified state id
+ */
+#define scic_sds_port_set_base_state_handlers(this_port, state_id) \
+	scic_sds_port_set_state_handlers(\
+		(this_port), &scic_sds_port_state_handler_table[(state_id)])
+
+/**
+ * scic_sds_port_set_state_handlers() -
+ *
+ * Helper macro to set the port object state handlers
+ */
+#define scic_sds_port_set_state_handlers(this_port, handlers) \
+	((this_port)->state_handlers = (handlers))
+
+/**
+ * scic_sds_port_get_index() -
+ *
+ * This macro returns the physical port index for this port object
+ */
+#define scic_sds_port_get_index(this_port) \
+	((this_port)->physical_port_index)
+
+
+static inline void scic_sds_port_decrement_request_count(struct scic_sds_port *sci_port)
+{
+	if (WARN_ONCE(sci_port->started_request_count == 0,
+		       "%s: tried to decrement started_request_count past 0!?",
+			__func__))
+		/* pass */;
+	else
+		sci_port->started_request_count--;
+}
+
+#define scic_sds_port_active_phy(port, phy) \
+	(((port)->active_phy_mask & (1 << (phy)->phy_index)) != 0)
+
+void scic_sds_port_construct(
+	struct scic_sds_port *sci_port,
+	u8 port_index,
+	struct scic_sds_controller *scic);
+
+enum sci_status scic_sds_port_initialize(
+	struct scic_sds_port *sci_port,
+	void __iomem *port_task_scheduler_registers,
+	void __iomem *port_configuration_regsiter,
+	void __iomem *viit_registers);
+
+enum sci_status scic_sds_port_add_phy(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
+
+enum sci_status scic_sds_port_remove_phy(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
+
+void scic_sds_port_setup_transports(
+	struct scic_sds_port *sci_port,
+	u32 device_id);
+
+
+void scic_sds_port_deactivate_phy(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy,
+	bool do_notify_user);
+
+bool scic_sds_port_link_detected(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
+
+void scic_sds_port_link_up(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
+
+void scic_sds_port_link_down(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
+
+enum sci_status scic_sds_port_start_io(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req);
+
+enum sci_status scic_sds_port_complete_io(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req);
+
+enum sas_linkrate scic_sds_port_get_max_allowed_speed(
+	struct scic_sds_port *sci_port);
+
+void scic_sds_port_broadcast_change_received(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
+
+bool scic_sds_port_is_valid_phy_assignment(
+	struct scic_sds_port *sci_port,
+	u32 phy_index);
+
+void scic_sds_port_get_sas_address(
+	struct scic_sds_port *sci_port,
+	struct sci_sas_address *sas_address);
+
+void scic_sds_port_get_attached_sas_address(
+	struct scic_sds_port *sci_port,
+	struct sci_sas_address *sas_address);
+
+enum isci_status isci_port_get_state(
 	struct isci_port *isci_port);
 
-void isci_port_not_ready(
-	struct isci_host *isci_host,
-	struct isci_port *port);
+void isci_port_formed(struct asd_sas_phy *);
+void isci_port_deformed(struct asd_sas_phy *);
 
 void isci_port_init(
 	struct isci_port *port,
 	struct isci_host *host,
 	int index);
 
-void isci_port_hard_reset_complete(
-	struct isci_port *isci_port,
-	enum sci_status completion_status);
-
 int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,
 				 struct isci_phy *iphy);
-
-void isci_port_stop_complete(
-		struct scic_sds_controller *scic,
-		struct scic_sds_port *sci_port,
-		enum sci_status completion_status);
-
 #endif /* !defined(_ISCI_PORT_H_) */
-
diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
new file mode 100644
index 0000000..028ffa3
--- /dev/null
+++ b/drivers/scsi/isci/port_config.c
@@ -0,0 +1,826 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "host.h"
+#include "timers.h"
+
+#define SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT    (10)
+#define SCIC_SDS_APC_RECONFIGURATION_TIMEOUT    (10)
+#define SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION  (100)
+
+enum SCIC_SDS_APC_ACTIVITY {
+	SCIC_SDS_APC_SKIP_PHY,
+	SCIC_SDS_APC_ADD_PHY,
+	SCIC_SDS_APC_START_TIMER,
+
+	SCIC_SDS_APC_ACTIVITY_MAX
+};
+
+/*
+ * ******************************************************************************
+ * General port configuration agent routines
+ * ****************************************************************************** */
+
+/**
+ *
+ * @address_one: A SAS Address to be compared.
+ * @address_two: A SAS Address to be compared.
+ *
+ * Compare the two SAS Address and if SAS Address One is greater than SAS
+ * Address Two then return > 0 else if SAS Address One is less than SAS Address
+ * Two return < 0 Otherwise they are the same return 0 A signed value of x > 0
+ * > y where x is returned for Address One > Address Two y is returned for
+ * Address One < Address Two 0 is returned ofr Address One = Address Two
+ */
+static s32 sci_sas_address_compare(
+	struct sci_sas_address address_one,
+	struct sci_sas_address address_two)
+{
+	if (address_one.high > address_two.high) {
+		return 1;
+	} else if (address_one.high < address_two.high) {
+		return -1;
+	} else if (address_one.low > address_two.low) {
+		return 1;
+	} else if (address_one.low < address_two.low) {
+		return -1;
+	}
+
+	/* The two SAS Address must be identical */
+	return 0;
+}
+
+/**
+ *
+ * @controller: The controller object used for the port search.
+ * @phy: The phy object to match.
+ *
+ * This routine will find a matching port for the phy.  This means that the
+ * port and phy both have the same broadcast sas address and same received sas
+ * address. The port address or the NULL if there is no matching
+ * port. port address if the port can be found to match the phy.
+ * NULL if there is no matching port for the phy.
+ */
+static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
+	struct scic_sds_controller *scic,
+	struct scic_sds_phy *phy)
+{
+	u8 i;
+	struct sci_sas_address port_sas_address;
+	struct sci_sas_address port_attached_device_address;
+	struct sci_sas_address phy_sas_address;
+	struct sci_sas_address phy_attached_device_address;
+
+	/*
+	 * Since this phy can be a member of a wide port check to see if one or
+	 * more phys match the sent and received SAS address as this phy in which
+	 * case it should participate in the same port.
+	 */
+	scic_sds_phy_get_sas_address(phy, &phy_sas_address);
+	scic_sds_phy_get_attached_sas_address(phy, &phy_attached_device_address);
+
+	for (i = 0; i < scic->logical_port_entries; i++) {
+		struct isci_host *ihost = scic_to_ihost(scic);
+		struct scic_sds_port *sci_port = &ihost->ports[i].sci;
+
+		scic_sds_port_get_sas_address(sci_port, &port_sas_address);
+		scic_sds_port_get_attached_sas_address(sci_port, &port_attached_device_address);
+
+		if (sci_sas_address_compare(port_sas_address, phy_sas_address) == 0 &&
+		    sci_sas_address_compare(port_attached_device_address, phy_attached_device_address) == 0)
+			return sci_port;
+	}
+
+	return NULL;
+}
+
+/**
+ *
+ * @controller: This is the controller object that contains the port agent
+ * @port_agent: This is the port configruation agent for the controller.
+ *
+ * This routine will validate the port configuration is correct for the SCU
+ * hardware.  The SCU hardware allows for port configurations as follows. LP0
+ * -> (PE0), (PE0, PE1), (PE0, PE1, PE2, PE3) LP1 -> (PE1) LP2 -> (PE2), (PE2,
+ * PE3) LP3 -> (PE3) enum sci_status SCI_SUCCESS the port configuration is valid for
+ * this port configuration agent. SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
+ * the port configuration is not valid for this port configuration agent.
+ */
+static enum sci_status scic_sds_port_configuration_agent_validate_ports(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent)
+{
+	struct isci_host *ihost = scic_to_ihost(controller);
+	struct sci_sas_address first_address;
+	struct sci_sas_address second_address;
+
+	/*
+	 * Sanity check the max ranges for all the phys the max index
+	 * is always equal to the port range index */
+	if (port_agent->phy_valid_port_range[0].max_index != 0 ||
+	    port_agent->phy_valid_port_range[1].max_index != 1 ||
+	    port_agent->phy_valid_port_range[2].max_index != 2 ||
+	    port_agent->phy_valid_port_range[3].max_index != 3)
+		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+
+	/*
+	 * This is a request to configure a single x4 port or at least attempt
+	 * to make all the phys into a single port */
+	if (port_agent->phy_valid_port_range[0].min_index == 0 &&
+	    port_agent->phy_valid_port_range[1].min_index == 0 &&
+	    port_agent->phy_valid_port_range[2].min_index == 0 &&
+	    port_agent->phy_valid_port_range[3].min_index == 0)
+		return SCI_SUCCESS;
+
+	/*
+	 * This is a degenerate case where phy 1 and phy 2 are assigned
+	 * to the same port this is explicitly disallowed by the hardware
+	 * unless they are part of the same x4 port and this condition was
+	 * already checked above. */
+	if (port_agent->phy_valid_port_range[2].min_index == 1) {
+		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+	}
+
+	/*
+	 * PE0 and PE3 can never have the same SAS Address unless they
+	 * are part of the same x4 wide port and we have already checked
+	 * for this condition. */
+	scic_sds_phy_get_sas_address(&ihost->phys[0].sci, &first_address);
+	scic_sds_phy_get_sas_address(&ihost->phys[3].sci, &second_address);
+
+	if (sci_sas_address_compare(first_address, second_address) == 0) {
+		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+	}
+
+	/*
+	 * PE0 and PE1 are configured into a 2x1 ports make sure that the
+	 * SAS Address for PE0 and PE2 are different since they can not be
+	 * part of the same port. */
+	if (port_agent->phy_valid_port_range[0].min_index == 0 &&
+	    port_agent->phy_valid_port_range[1].min_index == 1) {
+		scic_sds_phy_get_sas_address(&ihost->phys[0].sci, &first_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[2].sci, &second_address);
+
+		if (sci_sas_address_compare(first_address, second_address) == 0) {
+			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+		}
+	}
+
+	/*
+	 * PE2 and PE3 are configured into a 2x1 ports make sure that the
+	 * SAS Address for PE1 and PE3 are different since they can not be
+	 * part of the same port. */
+	if (port_agent->phy_valid_port_range[2].min_index == 2 &&
+	    port_agent->phy_valid_port_range[3].min_index == 3) {
+		scic_sds_phy_get_sas_address(&ihost->phys[1].sci, &first_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[3].sci, &second_address);
+
+		if (sci_sas_address_compare(first_address, second_address) == 0) {
+			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+		}
+	}
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * ******************************************************************************
+ * Manual port configuration agent routines
+ * ****************************************************************************** */
+
+/**
+ *
+ *
+ * This routine will verify that all of the phys in the same port are using the
+ * same SAS address.
+ */
+static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent)
+{
+	struct isci_host *ihost = scic_to_ihost(controller);
+	u32 phy_mask;
+	u32 assigned_phy_mask;
+	struct sci_sas_address sas_address;
+	struct sci_sas_address phy_assigned_address;
+	u8 port_index;
+	u8 phy_index;
+
+	assigned_phy_mask = 0;
+	sas_address.high = 0;
+	sas_address.low = 0;
+
+	for (port_index = 0; port_index < SCI_MAX_PORTS; port_index++) {
+		phy_mask = controller->oem_parameters.sds1.ports[port_index].phy_mask;
+
+		if (!phy_mask)
+			continue;
+		/*
+		 * Make sure that one or more of the phys were not already assinged to
+		 * a different port. */
+		if ((phy_mask & ~assigned_phy_mask) == 0) {
+			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+		}
+
+		/* Find the starting phy index for this round through the loop */
+		for (phy_index = 0; phy_index < SCI_MAX_PHYS; phy_index++) {
+			if ((phy_mask & (1 << phy_index)) == 0)
+				continue;
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+						     &sas_address);
+
+			/*
+			 * The phy_index can be used as the starting point for the
+			 * port range since the hardware starts all logical ports
+			 * the same as the PE index. */
+			port_agent->phy_valid_port_range[phy_index].min_index = port_index;
+			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
+
+			if (phy_index != port_index) {
+				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+			}
+
+			break;
+		}
+
+		/*
+		 * See how many additional phys are being added to this logical port.
+		 * Note: We have not moved the current phy_index so we will actually
+		 *       compare the startting phy with itself.
+		 *       This is expected and required to add the phy to the port. */
+		while (phy_index < SCI_MAX_PHYS) {
+			if ((phy_mask & (1 << phy_index)) == 0)
+				continue;
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+						     &phy_assigned_address);
+
+			if (sci_sas_address_compare(sas_address, phy_assigned_address) != 0) {
+				/*
+				 * The phy mask specified that this phy is part of the same port
+				 * as the starting phy and it is not so fail this configuration */
+				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+			}
+
+			port_agent->phy_valid_port_range[phy_index].min_index = port_index;
+			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
+
+			scic_sds_port_add_phy(&ihost->ports[port_index].sci,
+					      &ihost->phys[phy_index].sci);
+
+			assigned_phy_mask |= (1 << phy_index);
+		}
+
+		phy_index++;
+	}
+
+	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
+}
+
+/**
+ *
+ *
+ * This timer routine is used to allow the SCI User to rediscover or change
+ * device objects before a new series of link up notifications because a link
+ * down has allowed a better port configuration.
+ */
+static void scic_sds_mpc_agent_timeout_handler(void *object)
+{
+	u8 index;
+	struct scic_sds_controller *scic = object;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct scic_sds_port_configuration_agent *port_agent = &scic->port_agent;
+	u16 configure_phy_mask;
+
+	port_agent->timer_pending = false;
+
+	/* Find the mask of phys that are reported read but as yet unconfigured into a port */
+	configure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		struct scic_sds_phy *sci_phy = &ihost->phys[index].sci;
+
+		if (configure_phy_mask & (1 << index)) {
+			port_agent->link_up_handler(scic, port_agent,
+						    scic_sds_phy_get_port(sci_phy),
+						    sci_phy);
+		}
+	}
+}
+
+/**
+ *
+ * @controller: This is the controller object that receives the link up
+ *    notification.
+ * @port: This is the port object associated with the phy.  If the is no
+ *    associated port this is an NULL.
+ * @phy: This is the phy object which has gone ready.
+ *
+ * This method handles the manual port configuration link up notifications.
+ * Since all ports and phys are associate at initialization time we just turn
+ * around and notifiy the port object that there is a link up.  If this PHY is
+ * not associated with a port there is no action taken. Is it possible to get a
+ * link up notification from a phy that has no assocoated port?
+ */
+static void scic_sds_mpc_agent_link_up(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent,
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	/*
+	 * If the port has an invalid handle then the phy was not assigned to
+	 * a port.  This is because the phy was not given the same SAS Address
+	 * as the other PHYs in the port. */
+	if (port != NULL) {
+		port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(phy));
+
+		scic_sds_port_link_up(port, phy);
+
+		if ((port->active_phy_mask & (1 << scic_sds_phy_get_index(phy))) != 0) {
+			port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(phy));
+		}
+	}
+}
+
+/**
+ *
+ * @controller: This is the controller object that receives the link down
+ *    notification.
+ * @port: This is the port object associated with the phy.  If the is no
+ *    associated port this is an NULL.  The port is an invalid
+ *    handle only if the phy was never port of this port.  This happens when
+ *    the phy is not broadcasting the same SAS address as the other phys in the
+ *    assigned port.
+ * @phy: This is the phy object which has gone link down.
+ *
+ * This function handles the manual port configuration link down notifications.
+ * Since all ports and phys are associated at initialization time we just turn
+ * around and notifiy the port object of the link down event.  If this PHY is
+ * not associated with a port there is no action taken. Is it possible to get a
+ * link down notification from a phy that has no assocoated port?
+ */
+static void scic_sds_mpc_agent_link_down(
+	struct scic_sds_controller *scic,
+	struct scic_sds_port_configuration_agent *port_agent,
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	if (sci_port != NULL) {
+		/*
+		 * If we can form a new port from the remainder of the phys
+		 * then we want to start the timer to allow the SCI User to
+		 * cleanup old devices and rediscover the port before
+		 * rebuilding the port with the phys that remain in the ready
+		 * state.
+		 */
+		port_agent->phy_ready_mask &=
+			~(1 << scic_sds_phy_get_index(sci_phy));
+		port_agent->phy_configured_mask &=
+			~(1 << scic_sds_phy_get_index(sci_phy));
+
+		/*
+		 * Check to see if there are more phys waiting to be
+		 * configured into a port. If there are allow the SCI User
+		 * to tear down this port, if necessary, and then reconstruct
+		 * the port after the timeout.
+		 */
+		if ((port_agent->phy_configured_mask == 0x0000) &&
+		    (port_agent->phy_ready_mask != 0x0000) &&
+		    !port_agent->timer_pending) {
+			port_agent->timer_pending = true;
+
+			isci_timer_start(port_agent->timer,
+					 SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
+		}
+
+		scic_sds_port_link_down(sci_port, sci_phy);
+	}
+}
+
+/*
+ * ******************************************************************************
+ * Automatic port configuration agent routines
+ * ****************************************************************************** */
+
+/**
+ *
+ *
+ * This routine will verify that the phys are assigned a valid SAS address for
+ * automatic port configuration mode.
+ */
+static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent)
+{
+	u8 phy_index;
+	u8 port_index;
+	struct sci_sas_address sas_address;
+	struct sci_sas_address phy_assigned_address;
+	struct isci_host *ihost = scic_to_ihost(controller);
+
+	phy_index = 0;
+
+	while (phy_index < SCI_MAX_PHYS) {
+		port_index = phy_index;
+
+		/* Get the assigned SAS Address for the first PHY on the controller. */
+		scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+					    &sas_address);
+
+		while (++phy_index < SCI_MAX_PHYS) {
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+						     &phy_assigned_address);
+
+			/* Verify each of the SAS address are all the same for every PHY */
+			if (sci_sas_address_compare(sas_address, phy_assigned_address) == 0) {
+				port_agent->phy_valid_port_range[phy_index].min_index = port_index;
+				port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
+			} else {
+				port_agent->phy_valid_port_range[phy_index].min_index = phy_index;
+				port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
+				break;
+			}
+		}
+	}
+
+	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
+}
+
+/**
+ *
+ * @controller: This is the controller that to which the port agent is assigned.
+ * @port_agent: This is the port agent that is requesting the timer start
+ *    operation.
+ * @phy: This is the phy that has caused the timer operation to be scheduled.
+ *
+ * This routine will restart the automatic port configuration timeout timer for
+ * the next time period.  This could be caused by either a link down event or a
+ * link up event where we can not yet tell to which port a phy belongs.
+ */
+static inline void scic_sds_apc_agent_start_timer(
+	struct scic_sds_controller *scic,
+	struct scic_sds_port_configuration_agent *port_agent,
+	struct scic_sds_phy *sci_phy,
+	u32 timeout)
+{
+	if (port_agent->timer_pending)
+		isci_timer_stop(port_agent->timer);
+
+	port_agent->timer_pending = true;
+
+	isci_timer_start(port_agent->timer, timeout);
+}
+
+/**
+ *
+ * @controller: This is the controller object that receives the link up
+ *    notification.
+ * @phy: This is the phy object which has gone link up.
+ *
+ * This method handles the automatic port configuration for link up
+ * notifications.
+ */
+static void scic_sds_apc_agent_configure_ports(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent,
+	struct scic_sds_phy *phy,
+	bool start_timer)
+{
+	u8 port_index;
+	enum sci_status status;
+	struct scic_sds_port *port;
+	enum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;
+	struct isci_host *ihost = scic_to_ihost(controller);
+
+	port = scic_sds_port_configuration_agent_find_port(controller, phy);
+
+	if (port != NULL) {
+		if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index))
+			apc_activity = SCIC_SDS_APC_ADD_PHY;
+		else
+			apc_activity = SCIC_SDS_APC_SKIP_PHY;
+	} else {
+		/*
+		 * There is no matching Port for this PHY so lets search through the
+		 * Ports and see if we can add the PHY to its own port or maybe start
+		 * the timer and wait to see if a wider port can be made.
+		 *
+		 * Note the break when we reach the condition of the port id == phy id */
+		for (
+			port_index = port_agent->phy_valid_port_range[phy->phy_index].min_index;
+			port_index <= port_agent->phy_valid_port_range[phy->phy_index].max_index;
+			port_index++
+			) {
+
+			port = &ihost->ports[port_index].sci;
+
+			/* First we must make sure that this PHY can be added to this Port. */
+			if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)) {
+				/*
+				 * Port contains a PHY with a greater PHY ID than the current
+				 * PHY that has gone link up.  This phy can not be part of any
+				 * port so skip it and move on. */
+				if (port->active_phy_mask > (1 << phy->phy_index)) {
+					apc_activity = SCIC_SDS_APC_SKIP_PHY;
+					break;
+				}
+
+				/*
+				 * We have reached the end of our Port list and have not found
+				 * any reason why we should not either add the PHY to the port
+				 * or wait for more phys to become active. */
+				if (port->physical_port_index == phy->phy_index) {
+					/*
+					 * The Port either has no active PHYs.
+					 * Consider that if the port had any active PHYs we would have
+					 * or active PHYs with
+					 * a lower PHY Id than this PHY. */
+					if (apc_activity != SCIC_SDS_APC_START_TIMER) {
+						apc_activity = SCIC_SDS_APC_ADD_PHY;
+					}
+
+					break;
+				}
+
+				/*
+				 * The current Port has no active PHYs and this PHY could be part
+				 * of this Port.  Since we dont know as yet setup to start the
+				 * timer and see if there is a better configuration. */
+				if (port->active_phy_mask == 0) {
+					apc_activity = SCIC_SDS_APC_START_TIMER;
+				}
+			} else if (port->active_phy_mask != 0) {
+				/*
+				 * The Port has an active phy and the current Phy can not
+				 * participate in this port so skip the PHY and see if
+				 * there is a better configuration. */
+				apc_activity = SCIC_SDS_APC_SKIP_PHY;
+			}
+		}
+	}
+
+	/*
+	 * Check to see if the start timer operations should instead map to an
+	 * add phy operation.  This is caused because we have been waiting to
+	 * add a phy to a port but could not becuase the automatic port
+	 * configuration engine had a choice of possible ports for the phy.
+	 * Since we have gone through a timeout we are going to restrict the
+	 * choice to the smallest possible port. */
+	if (
+		(start_timer == false)
+		&& (apc_activity == SCIC_SDS_APC_START_TIMER)
+		) {
+		apc_activity = SCIC_SDS_APC_ADD_PHY;
+	}
+
+	switch (apc_activity) {
+	case SCIC_SDS_APC_ADD_PHY:
+		status = scic_sds_port_add_phy(port, phy);
+
+		if (status == SCI_SUCCESS) {
+			port_agent->phy_configured_mask |= (1 << phy->phy_index);
+		}
+		break;
+
+	case SCIC_SDS_APC_START_TIMER:
+		scic_sds_apc_agent_start_timer(
+			controller, port_agent, phy, SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION
+			);
+		break;
+
+	case SCIC_SDS_APC_SKIP_PHY:
+	default:
+		/* do nothing the PHY can not be made part of a port at this time. */
+		break;
+	}
+}
+
+/**
+ * scic_sds_apc_agent_link_up - handle apc link up events
+ * @scic: This is the controller object that receives the link up
+ *    notification.
+ * @sci_port: This is the port object associated with the phy.  If the is no
+ *    associated port this is an NULL.
+ * @sci_phy: This is the phy object which has gone link up.
+ *
+ * This method handles the automatic port configuration for link up
+ * notifications. Is it possible to get a link down notification from a phy
+ * that has no assocoated port?
+ */
+static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
+				       struct scic_sds_port_configuration_agent *port_agent,
+				       struct scic_sds_port *sci_port,
+				       struct scic_sds_phy *sci_phy)
+{
+	u8 phy_index  = sci_phy->phy_index;
+
+	if (!sci_port) {
+		/* the phy is not the part of this port */
+		port_agent->phy_ready_mask |= 1 << phy_index;
+		scic_sds_apc_agent_configure_ports(scic, port_agent, sci_phy, true);
+	} else {
+		/* the phy is already the part of the port */
+		u32 port_state = sci_port->state_machine.current_state_id;
+
+		/* if the PORT'S state is resetting then the link up is from
+		 * port hard reset in this case, we need to tell the port
+		 * that link up is recieved
+		 */
+		BUG_ON(port_state != SCI_BASE_PORT_STATE_RESETTING);
+		port_agent->phy_ready_mask |= 1 << phy_index;
+		scic_sds_port_link_up(sci_port, sci_phy);
+	}
+}
+
+/**
+ *
+ * @controller: This is the controller object that receives the link down
+ *    notification.
+ * @port: This is the port object associated with the phy.  If the is no
+ *    associated port this is an NULL.
+ * @phy: This is the phy object which has gone link down.
+ *
+ * This method handles the automatic port configuration link down
+ * notifications. not associated with a port there is no action taken. Is it
+ * possible to get a link down notification from a phy that has no assocoated
+ * port?
+ */
+static void scic_sds_apc_agent_link_down(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent,
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(phy));
+
+	if (port != NULL) {
+		if (port_agent->phy_configured_mask & (1 << phy->phy_index)) {
+			enum sci_status status;
+
+			status = scic_sds_port_remove_phy(port, phy);
+
+			if (status == SCI_SUCCESS) {
+				port_agent->phy_configured_mask &= ~(1 << phy->phy_index);
+			}
+		}
+	}
+}
+
+/* configure the phys into ports when the timer fires */
+static void scic_sds_apc_agent_timeout_handler(void *object)
+{
+	u32 index;
+	struct scic_sds_port_configuration_agent *port_agent;
+	struct scic_sds_controller *scic = object;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	u16 configure_phy_mask;
+
+	port_agent = scic_sds_controller_get_port_configuration_agent(scic);
+
+	port_agent->timer_pending = false;
+
+	configure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;
+
+	if (!configure_phy_mask)
+		return;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if ((configure_phy_mask & (1 << index)) == 0)
+			continue;
+
+		scic_sds_apc_agent_configure_ports(scic, port_agent,
+						   &ihost->phys[index].sci, false);
+	}
+}
+
+/*
+ * ******************************************************************************
+ * Public port configuration agent routines
+ * ****************************************************************************** */
+
+/**
+ *
+ *
+ * This method will construct the port configuration agent for operation. This
+ * call is universal for both manual port configuration and automatic port
+ * configuration modes.
+ */
+void scic_sds_port_configuration_agent_construct(
+	struct scic_sds_port_configuration_agent *port_agent)
+{
+	u32 index;
+
+	port_agent->phy_configured_mask = 0x00;
+	port_agent->phy_ready_mask = 0x00;
+
+	port_agent->link_up_handler = NULL;
+	port_agent->link_down_handler = NULL;
+
+	port_agent->timer_pending = false;
+	port_agent->timer = NULL;
+
+	for (index = 0; index < SCI_MAX_PORTS; index++) {
+		port_agent->phy_valid_port_range[index].min_index = 0;
+		port_agent->phy_valid_port_range[index].max_index = 0;
+	}
+}
+
+enum sci_status scic_sds_port_configuration_agent_initialize(
+	struct scic_sds_controller *scic,
+	struct scic_sds_port_configuration_agent *port_agent)
+{
+	enum sci_status status = SCI_SUCCESS;
+	enum scic_port_configuration_mode mode;
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	mode = scic->oem_parameters.sds1.controller.mode_type;
+
+	if (mode == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
+		status = scic_sds_mpc_agent_validate_phy_configuration(
+				scic, port_agent);
+
+		port_agent->link_up_handler = scic_sds_mpc_agent_link_up;
+		port_agent->link_down_handler = scic_sds_mpc_agent_link_down;
+
+		port_agent->timer = isci_timer_create(
+				ihost,
+				scic,
+				scic_sds_mpc_agent_timeout_handler);
+	} else {
+		status = scic_sds_apc_agent_validate_phy_configuration(
+				scic, port_agent);
+
+		port_agent->link_up_handler = scic_sds_apc_agent_link_up;
+		port_agent->link_down_handler = scic_sds_apc_agent_link_down;
+
+		port_agent->timer = isci_timer_create(
+				ihost,
+				scic,
+				scic_sds_apc_agent_timeout_handler);
+	}
+
+	/* Make sure we have actually gotten a timer */
+	if ((status == SCI_SUCCESS) && (port_agent->timer == NULL)) {
+		dev_err(scic_to_dev(scic),
+			"%s: Controller 0x%p automatic port configuration "
+			"agent could not get timer.\n",
+			__func__,
+			scic);
+
+		status = SCI_FAILURE;
+	}
+
+	return status;
+}
diff --git a/drivers/scsi/isci/probe_roms.h b/drivers/scsi/isci/probe_roms.h
index f4ef19a..7e3e6d7 100644
--- a/drivers/scsi/isci/probe_roms.h
+++ b/drivers/scsi/isci/probe_roms.h
@@ -60,15 +60,117 @@
 #include <linux/pci.h>
 #include "isci.h"
 
-struct isci_orom *isci_request_oprom(struct pci_dev *pdev);
+#define SCIC_SDS_PARM_NO_SPEED   0
+
+/* generation 1 (i.e. 1.5 Gb/s) */
+#define SCIC_SDS_PARM_GEN1_SPEED 1
+
+/* generation 2 (i.e. 3.0 Gb/s) */
+#define SCIC_SDS_PARM_GEN2_SPEED 2
+
+/* generation 3 (i.e. 6.0 Gb/s) */
+#define SCIC_SDS_PARM_GEN3_SPEED 3
+#define SCIC_SDS_PARM_MAX_SPEED SCIC_SDS_PARM_GEN3_SPEED
+
+/* parameters that can be set by module parameters */
+struct scic_sds_user_parameters {
+	struct sci_phy_user_params {
+		/**
+		 * This field specifies the NOTIFY (ENABLE SPIN UP) primitive
+		 * insertion frequency for this phy index.
+		 */
+		u32 notify_enable_spin_up_insertion_frequency;
+
+		/**
+		 * This method specifies the number of transmitted DWORDs within which
+		 * to transmit a single ALIGN primitive.  This value applies regardless
+		 * of what type of device is attached or connection state.  A value of
+		 * 0 indicates that no ALIGN primitives will be inserted.
+		 */
+		u16 align_insertion_frequency;
+
+		/**
+		 * This method specifies the number of transmitted DWORDs within which
+		 * to transmit 2 ALIGN primitives.  This applies for SAS connections
+		 * only.  A minimum value of 3 is required for this field.
+		 */
+		u16 in_connection_align_insertion_frequency;
+
+		/**
+		 * This field indicates the maximum speed generation to be utilized
+		 * by phys in the supplied port.
+		 * - A value of 1 indicates generation 1 (i.e. 1.5 Gb/s).
+		 * - A value of 2 indicates generation 2 (i.e. 3.0 Gb/s).
+		 * - A value of 3 indicates generation 3 (i.e. 6.0 Gb/s).
+		 */
+		u8 max_speed_generation;
+
+	} phys[SCI_MAX_PHYS];
+
+	/**
+	 * This field specifies the maximum number of direct attached devices
+	 * that can have power supplied to them simultaneously.
+	 */
+	u8 max_number_concurrent_device_spin_up;
+
+	/**
+	 * This field specifies the number of seconds to allow a phy to consume
+	 * power before yielding to another phy.
+	 *
+	 */
+	u8 phy_spin_up_delay_interval;
+
+	/**
+	 * These timer values specifies how long a link will remain open with no
+	 * activity in increments of a microsecond, it can be in increments of
+	 * 100 microseconds if the upper most bit is set.
+	 *
+	 */
+	u16 stp_inactivity_timeout;
+	u16 ssp_inactivity_timeout;
+
+	/**
+	 * These timer values specifies how long a link will remain open in increments
+	 * of 100 microseconds.
+	 *
+	 */
+	u16 stp_max_occupancy_timeout;
+	u16 ssp_max_occupancy_timeout;
+
+	/**
+	 * This timer value specifies how long a link will remain open with no
+	 * outbound traffic in increments of a microsecond.
+	 *
+	 */
+	u8 no_outbound_task_timeout;
+
+};
+
+/* XXX kill this union */
+union scic_user_parameters {
+	/**
+	 * This field specifies the user parameters specific to the
+	 * Storage Controller Unit (SCU) Driver Standard (SDS) version
+	 * 1.
+	 */
+	struct scic_sds_user_parameters sds1;
+};
+
+#define SCIC_SDS_PARM_PHY_MASK_MIN 0x0
+#define SCIC_SDS_PARM_PHY_MASK_MAX 0xF
+#define MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT 4
+
+struct scic_sds_oem_params;
+int scic_oem_parameters_validate(struct scic_sds_oem_params *oem);
 
 union scic_oem_parameters;
-struct isci_orom;
+void scic_oem_parameters_get(struct scic_sds_controller *scic,
+			     union scic_oem_parameters *oem);
 
-enum sci_status isci_parse_oem_parameters(
-	union scic_oem_parameters *oem_params,
-	struct isci_orom *orom,
-	int scu_index);
+struct isci_orom;
+struct isci_orom *isci_request_oprom(struct pci_dev *pdev);
+enum sci_status isci_parse_oem_parameters(union scic_oem_parameters *oem,
+					  struct isci_orom *orom, int scu_index);
 struct isci_orom *isci_request_firmware(struct pci_dev *pdev, const struct firmware *fw);
 struct isci_orom *isci_get_efi_var(struct pci_dev *pdev);
 
@@ -153,6 +255,16 @@ struct scic_sds_oem_params {
 	} phys[SCI_MAX_PHYS];
 } __attribute__ ((packed));
 
+/* XXX kill this union */
+union scic_oem_parameters {
+	/**
+	 * This field specifies the OEM parameters specific to the
+	 * Storage Controller Unit (SCU) Driver Standard (SDS) version
+	 * 1.
+	 */
+	struct scic_sds_oem_params sds1;
+};
+
 struct isci_orom {
 	struct sci_bios_oem_param_block_hdr hdr;
 	struct scic_sds_oem_params ctrl[SCI_MAX_CONTROLLERS];
diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 2baa215..0bb639d 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -57,8 +57,6 @@
 #include "port.h"
 #include "remote_device.h"
 #include "request.h"
-#include "scic_port.h"
-#include "scic_sds_port.h"
 #include "remote_node_context.h"
 #include "scu_event_codes.h"
 #include "task.h"
diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 35231e7..aef258b 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -55,7 +55,6 @@
 
 #include "host.h"
 #include "state_machine.h"
-#include "scic_sds_port.h"
 #include "remote_device.h"
 #include "remote_node_context.h"
 #include "scu_event_codes.h"
diff --git a/drivers/scsi/isci/request.c b/drivers/scsi/isci/request.c
index 857ad06..48e2dac 100644
--- a/drivers/scsi/isci/request.c
+++ b/drivers/scsi/isci/request.c
@@ -54,7 +54,6 @@
  */
 
 #include "isci.h"
-#include "scic_port.h"
 #include "task.h"
 #include "request.h"
 #include "sata.h"
-- 
1.6.0.2

