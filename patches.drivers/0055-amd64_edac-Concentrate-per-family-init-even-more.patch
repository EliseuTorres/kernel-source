From: Borislav Petkov <borislav.petkov@amd.com>
Subject: amd64_edac: Concentrate per-family init even more
References: fate#309907
Git-commit: b8cfa02f833a614e80f851747c4ce14989a4cfd0
Patch-mainline: v2.6.38-rc1

Signed-off-by: Thomas Renninger <trenn@suse.de>

Move the remaining per-family init code into the proper place and
simplify the rest of the initialization. Reorganize error handling in
amd64_init_one_instance().

Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>
---
 drivers/edac/amd64_edac.c |   31 +++++++++++++++----------------
 drivers/edac/amd64_edac.h |   15 ++-------------
 2 files changed, 17 insertions(+), 29 deletions(-)

diff --git a/drivers/edac/amd64_edac.c b/drivers/edac/amd64_edac.c
index 0c9d2cd..fd1665c 100644
--- a/drivers/edac/amd64_edac.c
+++ b/drivers/edac/amd64_edac.c
@@ -2572,11 +2572,13 @@ static struct amd64_family_type *amd64_per_family_init(struct amd64_pvt *pvt)
 	switch (fam) {
 	case 0xf:
 		fam_type		= &amd64_family_types[K8_CPUS];
+		pvt->ops		= &amd64_family_types[K8_CPUS].ops;
 		pvt->ctl_name		= fam_type->ctl_name;
 		pvt->min_scrubrate	= K8_MIN_SCRUB_RATE_BITS;
 		break;
 	case 0x10:
 		fam_type		= &amd64_family_types[F10_CPUS];
+		pvt->ops		= &amd64_family_types[F10_CPUS].ops;
 		pvt->ctl_name		= fam_type->ctl_name;
 		pvt->min_scrubrate	= F10_MIN_SCRUB_RATE_BITS;
 		break;
@@ -2586,6 +2588,8 @@ static struct amd64_family_type *amd64_per_family_init(struct amd64_pvt *pvt)
 		return NULL;
 	}
 
+	pvt->ext_model = boot_cpu_data.x86_model >> 4;
+
 	amd64_printk(KERN_INFO, "%s %s detected.\n", pvt->ctl_name,
 		     (fam == 0xf ?
 				(pvt->ext_model >= K8_REV_F  ? "revF or later"
@@ -2606,8 +2610,7 @@ static struct amd64_family_type *amd64_per_family_init(struct amd64_pvt *pvt)
  * later come back in a finish-setup function to perform that final
  * initialization. See also amd64_init_2nd_stage() for that.
  */
-static int amd64_probe_one_instance(struct pci_dev *dram_f2_ctl,
-				    int mc_type_index)
+static int amd64_probe_one_instance(struct pci_dev *dram_f2_ctl)
 {
 	struct amd64_pvt *pvt = NULL;
 	struct amd64_family_type *fam_type = NULL;
@@ -2618,12 +2621,8 @@ static int amd64_probe_one_instance(struct pci_dev *dram_f2_ctl,
 	if (!pvt)
 		goto err_exit;
 
-	pvt->mc_node_id = get_node_id(dram_f2_ctl);
-
-	pvt->dram_f2_ctl	= dram_f2_ctl;
-	pvt->ext_model		= boot_cpu_data.x86_model >> 4;
-	pvt->mc_type_index	= mc_type_index;
-	pvt->ops		= family_ops(mc_type_index);
+	pvt->mc_node_id	 = get_node_id(dram_f2_ctl);
+	pvt->dram_f2_ctl = dram_f2_ctl;
 
 	ret = -EINVAL;
 	fam_type = amd64_per_family_init(pvt);
@@ -2742,20 +2741,22 @@ err_exit:
 
 
 static int __devinit amd64_init_one_instance(struct pci_dev *pdev,
-				 const struct pci_device_id *mc_type)
+					     const struct pci_device_id *mc_type)
 {
 	int ret = 0;
 
 	debugf0("(MC node=%d)\n", get_node_id(pdev));
 
 	ret = pci_enable_device(pdev);
-	if (ret < 0)
-		ret = -EIO;
-	else
-		ret = amd64_probe_one_instance(pdev, mc_type->driver_data);
+	if (ret < 0) {
+		debugf0("ret=%d\n", ret);
+		return -EIO;
+	}
 
+	ret = amd64_probe_one_instance(pdev);
 	if (ret < 0)
-		debugf0("ret=%d\n", ret);
+		amd64_printk(KERN_ERR, "Error probing instance: %d\n",
+					get_node_id(pdev));
 
 	return ret;
 }
@@ -2804,7 +2805,6 @@ static const struct pci_device_id amd64_pci_table[] __devinitdata = {
 		.subdevice	= PCI_ANY_ID,
 		.class		= 0,
 		.class_mask	= 0,
-		.driver_data	= K8_CPUS
 	},
 	{
 		.vendor		= PCI_VENDOR_ID_AMD,
@@ -2813,7 +2813,6 @@ static const struct pci_device_id amd64_pci_table[] __devinitdata = {
 		.subdevice	= PCI_ANY_ID,
 		.class		= 0,
 		.class_mask	= 0,
-		.driver_data	= F10_CPUS
 	},
 	{0, }
 };
diff --git a/drivers/edac/amd64_edac.h b/drivers/edac/amd64_edac.h
index b03962e..81de79d 100644
--- a/drivers/edac/amd64_edac.h
+++ b/drivers/edac/amd64_edac.h
@@ -383,6 +383,8 @@ struct error_injection {
 };
 
 struct amd64_pvt {
+	struct low_ops *ops;
+
 	/* pci_device handles which we utilize */
 	struct pci_dev *addr_f1_ctl;
 	struct pci_dev *dram_f2_ctl;
@@ -390,9 +392,6 @@ struct amd64_pvt {
 
 	int mc_node_id;		/* MC index of this MC node */
 	int ext_model;		/* extended model value of this node */
-
-	struct low_ops *ops;	/* pointer to per PCI Device ID func table */
-
 	int channel_count;
 
 	/* Raw registers */
@@ -458,9 +457,6 @@ struct amd64_pvt {
 	u32 nbctl_mcgctl_saved;		/* When true, following 2 are valid */
 	u32 old_nbctl;
 
-	/* MC Type Index value: socket F vs Family 10h */
-	u32 mc_type_index;
-
 	/* DCT per-family scrubrate setting */
 	u32 min_scrubrate;
 
@@ -521,13 +517,6 @@ struct amd64_family_type {
 	struct low_ops ops;
 };
 
-static struct amd64_family_type amd64_family_types[];
-
-static inline struct low_ops *family_ops(int index)
-{
-	return &amd64_family_types[index].ops;
-}
-
 static inline int amd64_read_pci_cfg_dword(struct pci_dev *pdev, int offset,
 					   u32 *val, const char *func)
 {
-- 
1.7.5.3

