From: John Soni Jose <sony.john-n@emulex.com>
Date: Thu, 30 Aug 2012 18:26:37 +0530
Subject: [PATCH 23/27] be2iscsi: Fix Logging mechanism for the driver.
Git-commit: 99bc5d55c06cbf9ac2d8ab7fb8348c4abce5fbaf
References: FATE#313820
Patch-mainline: v3.7-rc1

 New log level mechanism for different events. These
 log levels can be set at driver load time/run time. The
 log level is set for each Scsi_host.

 Fixed few multi-line print warning to get over the new checkpatch.pl
 warnings on multi-line strings.

Signed-off-by: John Soni Jose <sony.john-n@emulex.com>
Signed-off-by: Jayamohan Kallickal <jayamohan.kallickal@emulex.com>
Acked-by: Lee Duncan <lduncan@suse.com>
---
 drivers/scsi/be2iscsi/be_cmds.c  |  118 ++++--
 drivers/scsi/be2iscsi/be_iscsi.c |  244 ++++++++----
 drivers/scsi/be2iscsi/be_main.c  |  824 ++++++++++++++++++++++++--------------
 drivers/scsi/be2iscsi/be_main.h  |   37 +-
 drivers/scsi/be2iscsi/be_mgmt.c  |  157 +++++---
 5 files changed, 875 insertions(+), 505 deletions(-)

diff --git a/drivers/scsi/be2iscsi/be_cmds.c b/drivers/scsi/be2iscsi/be_cmds.c
index d2e9e93..d0058e3 100644
--- a/drivers/scsi/be2iscsi/be_cmds.c
+++ b/drivers/scsi/be2iscsi/be_cmds.c
@@ -48,7 +48,8 @@ int beiscsi_pci_soft_reset(struct beiscsi_hba *phba)
 	}
 
 	if (sreset & BE2_SET_RESET) {
-		printk(KERN_ERR "Soft Reset  did not deassert\n");
+		printk(KERN_ERR DRV_NAME
+		       " Soft Reset  did not deassert\n");
 		return -EIO;
 	}
 	pconline1 = BE2_MPU_IRAM_ONLINE;
@@ -67,7 +68,8 @@ int beiscsi_pci_soft_reset(struct beiscsi_hba *phba)
 		i++;
 	}
 	if (sreset & BE2_SET_RESET) {
-		printk(KERN_ERR "MPU Online Soft Reset did not deassert\n");
+		printk(KERN_ERR DRV_NAME
+		       " MPU Online Soft Reset did not deassert\n");
 		return -EIO;
 	}
 	return 0;
@@ -93,8 +95,9 @@ int be_chk_reset_complete(struct beiscsi_hba *phba)
 	}
 
 	if ((status & 0x80000000) || (!num_loop)) {
-		printk(KERN_ERR "Failed in be_chk_reset_complete"
-		"status = 0x%x\n", status);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BC_%d : Failed in be_chk_reset_complete"
+			    "status = 0x%x\n", status);
 		return -EIO;
 	}
 
@@ -169,6 +172,7 @@ static int be_mcc_compl_process(struct be_ctrl_info *ctrl,
 				struct be_mcc_compl *compl)
 {
 	u16 compl_status, extd_status;
+	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
 
 	be_dws_le_to_cpu(compl, 4);
 
@@ -177,9 +181,12 @@ static int be_mcc_compl_process(struct be_ctrl_info *ctrl,
 	if (compl_status != MCC_STATUS_SUCCESS) {
 		extd_status = (compl->status >> CQE_STATUS_EXTD_SHIFT) &
 						CQE_STATUS_EXTD_MASK;
-		dev_err(&ctrl->pdev->dev,
-			"error in cmd completion: status(compl/extd)=%d/%d\n",
-			compl_status, extd_status);
+
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+			    "BC_%d : error in cmd completion: status(compl/extd)=%d/%d\n",
+			    compl_status, extd_status);
+
 		return -EBUSY;
 	}
 	return 0;
@@ -233,22 +240,29 @@ void beiscsi_async_link_state_process(struct beiscsi_hba *phba,
 {
 	switch (evt->port_link_status) {
 	case ASYNC_EVENT_LINK_DOWN:
-		SE_DEBUG(DBG_LVL_1, "Link Down on Physical Port %d\n",
-				     evt->physical_port);
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,
+			    "BC_%d : Link Down on Physical Port %d\n",
+			    evt->physical_port);
+
 		phba->state |= BE_ADAPTER_LINK_DOWN;
 		iscsi_host_for_each_session(phba->shost,
 					    be2iscsi_fail_session);
 		break;
 	case ASYNC_EVENT_LINK_UP:
 		phba->state = BE_ADAPTER_UP;
-		SE_DEBUG(DBG_LVL_1, "Link UP on Physical Port %d\n",
-						evt->physical_port);
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,
+			    "BC_%d : Link UP on Physical Port %d\n",
+			    evt->physical_port);
 		break;
 	default:
-		SE_DEBUG(DBG_LVL_1, "Unexpected Async Notification %d on"
-				    "Physical Port %d\n",
-				     evt->port_link_status,
-				     evt->physical_port);
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,
+			    "BC_%d : Unexpected Async Notification %d on"
+			    "Physical Port %d\n",
+			    evt->port_link_status,
+			    evt->physical_port);
 	}
 }
 
@@ -279,9 +293,11 @@ int beiscsi_process_mcc(struct beiscsi_hba *phba)
 				beiscsi_async_link_state_process(phba,
 				   (struct be_async_event_link_state *) compl);
 			else
-				SE_DEBUG(DBG_LVL_1,
-					 " Unsupported Async Event, flags"
-					 " = 0x%08x\n", compl->flags);
+				beiscsi_log(phba, KERN_ERR,
+					    BEISCSI_LOG_CONFIG |
+					    BEISCSI_LOG_MBOX,
+					    "BC_%d : Unsupported Async Event, flags"
+					    " = 0x%08x\n", compl->flags);
 
 		} else if (compl->flags & CQE_FLAGS_COMPLETED_MASK) {
 				status = be_mcc_compl_process(ctrl, compl);
@@ -312,7 +328,10 @@ static int be_mcc_wait_compl(struct beiscsi_hba *phba)
 		udelay(100);
 	}
 	if (i == mcc_timeout) {
-		dev_err(&phba->pcidev->dev, "mccq poll timed out\n");
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+			    "BC_%d : mccq poll timed out\n");
+
 		return -EBUSY;
 	}
 	return 0;
@@ -338,7 +357,11 @@ static int be_mbox_db_ready_wait(struct be_ctrl_info *ctrl)
 			break;
 
 		if (cnt > 12000000) {
-			dev_err(&ctrl->pdev->dev, "mbox_db poll timed out\n");
+			struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+				    "BC_%d : mbox_db poll timed out\n");
+
 			return -EBUSY;
 		}
 
@@ -360,6 +383,7 @@ int be_mbox_notify(struct be_ctrl_info *ctrl)
 	struct be_dma_mem *mbox_mem = &ctrl->mbox_mem;
 	struct be_mcc_mailbox *mbox = mbox_mem->va;
 	struct be_mcc_compl *compl = &mbox->compl;
+	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
 
 	val &= ~MPU_MAILBOX_DB_RDY_MASK;
 	val |= MPU_MAILBOX_DB_HI_MASK;
@@ -368,7 +392,10 @@ int be_mbox_notify(struct be_ctrl_info *ctrl)
 
 	status = be_mbox_db_ready_wait(ctrl);
 	if (status != 0) {
-		SE_DEBUG(DBG_LVL_1, " be_mbox_db_ready_wait failed\n");
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+			    "BC_%d : be_mbox_db_ready_wait failed\n");
+
 		return status;
 	}
 	val = 0;
@@ -379,18 +406,27 @@ int be_mbox_notify(struct be_ctrl_info *ctrl)
 
 	status = be_mbox_db_ready_wait(ctrl);
 	if (status != 0) {
-		SE_DEBUG(DBG_LVL_1, " be_mbox_db_ready_wait failed\n");
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+			    "BC_%d : be_mbox_db_ready_wait failed\n");
+
 		return status;
 	}
 	if (be_mcc_compl_is_new(compl)) {
 		status = be_mcc_compl_process(ctrl, &mbox->compl);
 		be_mcc_compl_use(compl);
 		if (status) {
-			SE_DEBUG(DBG_LVL_1, "After be_mcc_compl_process\n");
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+				    "BC_%d : After be_mcc_compl_process\n");
+
 			return status;
 		}
 	} else {
-		dev_err(&ctrl->pdev->dev, "invalid mailbox completion\n");
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+			    "BC_%d : Invalid Mailbox Completion\n");
+
 		return -EBUSY;
 	}
 	return 0;
@@ -436,7 +472,10 @@ static int be_mbox_notify_wait(struct beiscsi_hba *phba)
 		if (status)
 			return status;
 	} else {
-		dev_err(&phba->pcidev->dev, "invalid mailbox completion\n");
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+			    "BC_%d : invalid mailbox completion\n");
+
 		return -EBUSY;
 	}
 	return 0;
@@ -528,7 +567,6 @@ int beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl,
 	struct be_dma_mem *q_mem = &eq->dma_mem;
 	int status;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_cmd_eq_create\n");
 	spin_lock(&ctrl->mbox_lock);
 	memset(wrb, 0, sizeof(*wrb));
 
@@ -563,10 +601,10 @@ int beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl,
 int be_cmd_fw_initialize(struct be_ctrl_info *ctrl)
 {
 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
 	int status;
 	u8 *endian_check;
 
-	SE_DEBUG(DBG_LVL_8, "In be_cmd_fw_initialize\n");
 	spin_lock(&ctrl->mbox_lock);
 	memset(wrb, 0, sizeof(*wrb));
 
@@ -583,7 +621,8 @@ int be_cmd_fw_initialize(struct be_ctrl_info *ctrl)
 
 	status = be_mbox_notify(ctrl);
 	if (status)
-		SE_DEBUG(DBG_LVL_1, "be_cmd_fw_initialize Failed\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BC_%d : be_cmd_fw_initialize Failed\n");
 
 	spin_unlock(&ctrl->mbox_lock);
 	return status;
@@ -596,11 +635,11 @@ int beiscsi_cmd_cq_create(struct be_ctrl_info *ctrl,
 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
 	struct be_cmd_req_cq_create *req = embedded_payload(wrb);
 	struct be_cmd_resp_cq_create *resp = embedded_payload(wrb);
+	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
 	struct be_dma_mem *q_mem = &cq->dma_mem;
 	void *ctxt = &req->context;
 	int status;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_cmd_cq_create\n");
 	spin_lock(&ctrl->mbox_lock);
 	memset(wrb, 0, sizeof(*wrb));
 
@@ -608,8 +647,6 @@ int beiscsi_cmd_cq_create(struct be_ctrl_info *ctrl,
 
 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
 			OPCODE_COMMON_CQ_CREATE, sizeof(*req));
-	if (!q_mem->va)
-		SE_DEBUG(DBG_LVL_1, "uninitialized q_mem->va\n");
 
 	req->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));
 
@@ -633,8 +670,10 @@ int beiscsi_cmd_cq_create(struct be_ctrl_info *ctrl,
 		cq->id = le16_to_cpu(resp->cq_id);
 		cq->created = true;
 	} else
-		SE_DEBUG(DBG_LVL_1, "In be_cmd_cq_create, status=ox%08x\n",
-			status);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BC_%d : In be_cmd_cq_create, status=ox%08x\n",
+			    status);
+
 	spin_unlock(&ctrl->mbox_lock);
 
 	return status;
@@ -700,10 +739,14 @@ int beiscsi_cmd_q_destroy(struct be_ctrl_info *ctrl, struct be_queue_info *q,
 {
 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
 	struct be_cmd_req_q_destroy *req = embedded_payload(wrb);
+	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
 	u8 subsys = 0, opcode = 0;
 	int status;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_cmd_q_destroy\n");
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "BC_%d : In beiscsi_cmd_q_destroy "
+		    "queue_type : %d\n", queue_type);
+
 	spin_lock(&ctrl->mbox_lock);
 	memset(wrb, 0, sizeof(*wrb));
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
@@ -759,7 +802,6 @@ int be_cmd_create_default_pdu_queue(struct be_ctrl_info *ctrl,
 	void *ctxt = &req->context;
 	int status;
 
-	SE_DEBUG(DBG_LVL_8, "In be_cmd_create_default_pdu_queue\n");
 	spin_lock(&ctrl->mbox_lock);
 	memset(wrb, 0, sizeof(*wrb));
 
@@ -830,6 +872,7 @@ int be_cmd_iscsi_post_sgl_pages(struct be_ctrl_info *ctrl,
 {
 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
 	struct be_post_sgl_pages_req *req = embedded_payload(wrb);
+	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
 	int status;
 	unsigned int curr_pages;
 	u32 internal_page_offset = 0;
@@ -860,8 +903,9 @@ int be_cmd_iscsi_post_sgl_pages(struct be_ctrl_info *ctrl,
 
 		status = be_mbox_notify(ctrl);
 		if (status) {
-			SE_DEBUG(DBG_LVL_1,
-				 "FW CMD to map iscsi frags failed.\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BC_%d : FW CMD to map iscsi frags failed.\n");
+
 			goto error;
 		}
 	} while (num_pages > 0);
diff --git a/drivers/scsi/be2iscsi/be_iscsi.c b/drivers/scsi/be2iscsi/be_iscsi.c
index d6fd318..d950f74 100644
--- a/drivers/scsi/be2iscsi/be_iscsi.c
+++ b/drivers/scsi/be2iscsi/be_iscsi.c
@@ -50,21 +50,27 @@ struct iscsi_cls_session *beiscsi_session_create(struct iscsi_endpoint *ep,
 	struct beiscsi_session *beiscsi_sess;
 	struct beiscsi_io_task *io_task;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_session_create\n");
 
 	if (!ep) {
-		SE_DEBUG(DBG_LVL_1, "beiscsi_session_create: invalid ep\n");
+		printk(KERN_ERR
+		       "beiscsi_session_create: invalid ep\n");
 		return NULL;
 	}
 	beiscsi_ep = ep->dd_data;
 	phba = beiscsi_ep->phba;
 	shost = phba->shost;
+
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_session_create\n");
+
 	if (cmds_max > beiscsi_ep->phba->params.wrbs_per_cxn) {
-		shost_printk(KERN_ERR, shost, "Cannot handle %d cmds."
-			     "Max cmds per session supported is %d. Using %d. "
-			     "\n", cmds_max,
-			      beiscsi_ep->phba->params.wrbs_per_cxn,
-			      beiscsi_ep->phba->params.wrbs_per_cxn);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Cannot handle %d cmds."
+			    "Max cmds per session supported is %d. Using %d."
+			    "\n", cmds_max,
+			    beiscsi_ep->phba->params.wrbs_per_cxn,
+			    beiscsi_ep->phba->params.wrbs_per_cxn);
+
 		cmds_max = beiscsi_ep->phba->params.wrbs_per_cxn;
 	}
 
@@ -102,7 +108,7 @@ void beiscsi_session_destroy(struct iscsi_cls_session *cls_session)
 	struct iscsi_session *sess = cls_session->dd_data;
 	struct beiscsi_session *beiscsi_sess = sess->dd_data;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_session_destroy\n");
+	printk(KERN_INFO "In beiscsi_session_destroy\n");
 	pci_pool_destroy(beiscsi_sess->bhs_pool);
 	iscsi_session_teardown(cls_session);
 }
@@ -123,11 +129,13 @@ beiscsi_conn_create(struct iscsi_cls_session *cls_session, u32 cid)
 	struct iscsi_session *sess;
 	struct beiscsi_session *beiscsi_sess;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_conn_create ,cid"
-		 "from iscsi layer=%d\n", cid);
 	shost = iscsi_session_to_shost(cls_session);
 	phba = iscsi_host_priv(shost);
 
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_conn_create ,cid"
+		    "from iscsi layer=%d\n", cid);
+
 	cls_conn = iscsi_conn_setup(cls_session, sizeof(*beiscsi_conn), cid);
 	if (!cls_conn)
 		return NULL;
@@ -154,12 +162,15 @@ static int beiscsi_bindconn_cid(struct beiscsi_hba *phba,
 				unsigned int cid)
 {
 	if (phba->conn_table[cid]) {
-		SE_DEBUG(DBG_LVL_1,
-			 "Connection table already occupied. Detected clash\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Connection table already occupied. Detected clash\n");
+
 		return -EINVAL;
 	} else {
-		SE_DEBUG(DBG_LVL_8, "phba->conn_table[%d]=%p(beiscsi_conn)\n",
-			 cid, beiscsi_conn);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+			    "BS_%d : phba->conn_table[%d]=%p(beiscsi_conn)\n",
+			    cid, beiscsi_conn);
+
 		phba->conn_table[cid] = beiscsi_conn;
 	}
 	return 0;
@@ -184,7 +195,6 @@ int beiscsi_conn_bind(struct iscsi_cls_session *cls_session,
 	struct beiscsi_endpoint *beiscsi_ep;
 	struct iscsi_endpoint *ep;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_conn_bind\n");
 	ep = iscsi_lookup_endpoint(transport_fd);
 	if (!ep)
 		return -EINVAL;
@@ -195,17 +205,21 @@ int beiscsi_conn_bind(struct iscsi_cls_session *cls_session,
 		return -EINVAL;
 
 	if (beiscsi_ep->phba != phba) {
-		SE_DEBUG(DBG_LVL_8,
-			 "beiscsi_ep->hba=%p not equal to phba=%p\n",
-			 beiscsi_ep->phba, phba);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : beiscsi_ep->hba=%p not equal to phba=%p\n",
+			    beiscsi_ep->phba, phba);
+
 		return -EEXIST;
 	}
 
 	beiscsi_conn->beiscsi_conn_cid = beiscsi_ep->ep_cid;
 	beiscsi_conn->ep = beiscsi_ep;
 	beiscsi_ep->conn = beiscsi_conn;
-	SE_DEBUG(DBG_LVL_8, "beiscsi_conn=%p conn=%p ep_cid=%d\n",
-		 beiscsi_conn, conn, beiscsi_ep->ep_cid);
+
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : beiscsi_conn=%p conn=%p ep_cid=%d\n",
+		    beiscsi_conn, conn, beiscsi_ep->ep_cid);
+
 	return beiscsi_bindconn_cid(phba, beiscsi_conn, beiscsi_ep->ep_cid);
 }
 
@@ -219,8 +233,9 @@ static int beiscsi_create_ipv4_iface(struct beiscsi_hba *phba)
 					      ISCSI_IFACE_TYPE_IPV4,
 					      0, 0);
 	if (!phba->ipv4_iface) {
-		shost_printk(KERN_ERR, phba->shost, "Could not "
-			     "create default IPv4 address.\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Could not "
+			    "create default IPv4 address.\n");
 		return -ENODEV;
 	}
 
@@ -237,8 +252,9 @@ static int beiscsi_create_ipv6_iface(struct beiscsi_hba *phba)
 					      ISCSI_IFACE_TYPE_IPV6,
 					      0, 0);
 	if (!phba->ipv6_iface) {
-		shost_printk(KERN_ERR, phba->shost, "Could not "
-			     "create default IPv6 address.\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Could not "
+			    "create default IPv6 address.\n");
 		return -ENODEV;
 	}
 
@@ -299,12 +315,14 @@ beiscsi_set_static_ip(struct Scsi_Host *shost,
 			iface_ip = nla_data(nla);
 		break;
 	default:
-		shost_printk(KERN_ERR, shost, "Unsupported param %d\n",
-			     iface_param->param);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Unsupported param %d\n",
+			    iface_param->param);
 	}
 
 	if (!iface_ip || !iface_subnet) {
-		shost_printk(KERN_ERR, shost, "IP and Subnet Mask required\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : IP and Subnet Mask required\n");
 		return -EINVAL;
 	}
 
@@ -335,8 +353,9 @@ beiscsi_set_ipv4(struct Scsi_Host *shost,
 			ret = beiscsi_set_static_ip(shost, iface_param,
 						    data, dt_len);
 		else
-			shost_printk(KERN_ERR, shost, "Invalid BOOTPROTO: %d\n",
-					iface_param->value[0]);
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+				    "BS_%d : Invalid BOOTPROTO: %d\n",
+				    iface_param->value[0]);
 		break;
 	case ISCSI_NET_PARAM_IFACE_ENABLE:
 		if (iface_param->value[0] == ISCSI_IFACE_ENABLE)
@@ -350,8 +369,9 @@ beiscsi_set_ipv4(struct Scsi_Host *shost,
 					    data, dt_len);
 		break;
 	default:
-		shost_printk(KERN_ERR, shost, "Param %d not supported\n",
-			     iface_param->param);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Param %d not supported\n",
+			    iface_param->param);
 	}
 
 	return ret;
@@ -379,8 +399,9 @@ beiscsi_set_ipv6(struct Scsi_Host *shost,
 				  ISCSI_BOOTPROTO_STATIC);
 		break;
 	default:
-		shost_printk(KERN_ERR, shost, "Param %d not supported\n",
-			     iface_param->param);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Param %d not supported\n",
+			    iface_param->param);
 	}
 
 	return ret;
@@ -390,6 +411,7 @@ int be2iscsi_iface_set_param(struct Scsi_Host *shost,
 		void *data, uint32_t dt_len)
 {
 	struct iscsi_iface_param_info *iface_param = NULL;
+	struct beiscsi_hba *phba = iscsi_host_priv(shost);
 	struct nlattr *attrib;
 	uint32_t rm_len = dt_len;
 	int ret = 0 ;
@@ -404,9 +426,11 @@ int be2iscsi_iface_set_param(struct Scsi_Host *shost,
 		 * BE2ISCSI only supports 1 interface
 		 */
 		if (iface_param->iface_num) {
-			shost_printk(KERN_ERR, shost, "Invalid iface_num %d."
-				     "Only iface_num 0 is supported.\n",
-				     iface_param->iface_num);
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+				    "BS_%d : Invalid iface_num %d."
+				    "Only iface_num 0 is supported.\n",
+				    iface_param->iface_num);
+
 			return -EINVAL;
 		}
 
@@ -420,9 +444,9 @@ int be2iscsi_iface_set_param(struct Scsi_Host *shost,
 					       data, dt_len);
 			break;
 		default:
-			shost_printk(KERN_ERR, shost,
-				     "Invalid iface type :%d passed\n",
-				     iface_param->iface_type);
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+				    "BS_%d : Invalid iface type :%d passed\n",
+				    iface_param->iface_type);
 			break;
 		}
 
@@ -518,7 +542,10 @@ int beiscsi_ep_get_param(struct iscsi_endpoint *ep,
 	struct beiscsi_endpoint *beiscsi_ep = ep->dd_data;
 	int len = 0;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_ep_get_param, param= %d\n", param);
+	beiscsi_log(beiscsi_ep->phba, KERN_INFO,
+		    BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_ep_get_param,"
+		    " param= %d\n", param);
 
 	switch (param) {
 	case ISCSI_PARAM_CONN_PORT:
@@ -541,9 +568,14 @@ int beiscsi_set_param(struct iscsi_cls_conn *cls_conn,
 {
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_session *session = conn->session;
+	struct beiscsi_hba *phba = NULL;
 	int ret;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_conn_set_param, param= %d\n", param);
+	phba = ((struct beiscsi_conn *)conn->dd_data)->phba;
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_conn_set_param,"
+		    " param= %d\n", param);
+
 	ret = iscsi_set_param(cls_conn, param, buf, buflen);
 	if (ret)
 		return ret;
@@ -593,7 +625,9 @@ static int beiscsi_get_initname(char *buf, struct beiscsi_hba *phba)
 
 	tag = be_cmd_get_initname(phba);
 	if (!tag) {
-		SE_DEBUG(DBG_LVL_1, "Getting Initiator Name Failed\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Getting Initiator Name Failed\n");
+
 		return -EBUSY;
 	} else
 		wait_event_interruptible(phba->ctrl.mcc_wait[tag],
@@ -604,9 +638,12 @@ static int beiscsi_get_initname(char *buf, struct beiscsi_hba *phba)
 	status = phba->ctrl.mcc_numtag[tag] & 0x000000FF;
 
 	if (status || extd_status) {
-		SE_DEBUG(DBG_LVL_1, "MailBox Command Failed with "
-				"status = %d extd_status = %d\n",
-				status, extd_status);
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+			    "BS_%d : MailBox Command Failed with "
+			    "status = %d extd_status = %d\n",
+			    status, extd_status);
+
 		free_mcc_tag(&phba->ctrl, tag);
 		return -EAGAIN;
 	}
@@ -631,20 +668,24 @@ int beiscsi_get_host_param(struct Scsi_Host *shost,
 	struct beiscsi_hba *phba = iscsi_host_priv(shost);
 	int status = 0;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_get_host_param, param= %d\n", param);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_get_host_param,"
+		    " param= %d\n", param);
+
 	switch (param) {
 	case ISCSI_HOST_PARAM_HWADDRESS:
 		status = beiscsi_get_macaddr(buf, phba);
 		if (status < 0) {
-			SE_DEBUG(DBG_LVL_1, "beiscsi_get_macaddr Failed\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+				    "BS_%d : beiscsi_get_macaddr Failed\n");
 			return status;
 		}
 		break;
 	case ISCSI_HOST_PARAM_INITIATOR_NAME:
 		status = beiscsi_get_initname(buf, phba);
 		if (status < 0) {
-			SE_DEBUG(DBG_LVL_1,
-					"Retreiving Initiator Name Failed\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+				    "BS_%d : Retreiving Initiator Name Failed\n");
 			return status;
 		}
 		break;
@@ -682,8 +723,12 @@ void beiscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn,
 			    struct iscsi_stats *stats)
 {
 	struct iscsi_conn *conn = cls_conn->dd_data;
+	struct beiscsi_hba *phba = NULL;
+
+	phba = ((struct beiscsi_conn *)conn->dd_data)->phba;
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_conn_get_stats\n");
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_conn_get_stats\n");
 	stats->txdata_octets = conn->txdata_octets;
 	stats->rxdata_octets = conn->rxdata_octets;
 	stats->dataout_pdus = conn->dataout_pdus_cnt;
@@ -743,11 +788,16 @@ int beiscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 	struct beiscsi_endpoint *beiscsi_ep;
 	struct beiscsi_offload_params params;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_conn_start\n");
+	beiscsi_log(beiscsi_conn->phba, KERN_INFO,
+		    BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_conn_start\n");
+
 	memset(&params, 0, sizeof(struct beiscsi_offload_params));
 	beiscsi_ep = beiscsi_conn->ep;
 	if (!beiscsi_ep)
-		SE_DEBUG(DBG_LVL_1, "In beiscsi_conn_start , no beiscsi_ep\n");
+		beiscsi_log(beiscsi_conn->phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG,
+			    "BS_%d : In beiscsi_conn_start , no beiscsi_ep\n");
 
 	beiscsi_conn->login_in_progress = 0;
 	beiscsi_set_params_for_offld(beiscsi_conn, &params);
@@ -821,19 +871,27 @@ static int beiscsi_open_conn(struct iscsi_endpoint *ep,
 	unsigned int tag, wrb_num;
 	int ret = -ENOMEM;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_open_conn\n");
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_open_conn\n");
+
 	beiscsi_ep->ep_cid = beiscsi_get_cid(phba);
 	if (beiscsi_ep->ep_cid == 0xFFFF) {
-		SE_DEBUG(DBG_LVL_1, "No free cid available\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : No free cid available\n");
 		return ret;
 	}
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_open_conn, ep_cid=%d\n",
-		 beiscsi_ep->ep_cid);
+
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_open_conn, ep_cid=%d\n",
+		    beiscsi_ep->ep_cid);
+
 	phba->ep_array[beiscsi_ep->ep_cid -
 		       phba->fw_config.iscsi_cid_start] = ep;
 	if (beiscsi_ep->ep_cid > (phba->fw_config.iscsi_cid_start +
 				  phba->params.cxns_per_ctrl * 2)) {
-		SE_DEBUG(DBG_LVL_1, "Failed in allocate iscsi cid\n");
+
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Failed in allocate iscsi cid\n");
 		goto free_ep;
 	}
 
@@ -842,9 +900,11 @@ static int beiscsi_open_conn(struct iscsi_endpoint *ep,
 				sizeof(struct tcp_connect_and_offload_in),
 				&nonemb_cmd.dma);
 	if (nonemb_cmd.va == NULL) {
-		SE_DEBUG(DBG_LVL_1,
-			 "Failed to allocate memory for mgmt_open_connection"
-			 "\n");
+
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Failed to allocate memory for"
+			    " mgmt_open_connection\n");
+
 		beiscsi_put_cid(phba, beiscsi_ep->ep_cid);
 		return -ENOMEM;
 	}
@@ -852,9 +912,10 @@ static int beiscsi_open_conn(struct iscsi_endpoint *ep,
 	memset(nonemb_cmd.va, 0, nonemb_cmd.size);
 	tag = mgmt_open_connection(phba, dst_addr, beiscsi_ep, &nonemb_cmd);
 	if (!tag) {
-		SE_DEBUG(DBG_LVL_1,
-			 "mgmt_open_connection Failed for cid=%d\n",
-			 beiscsi_ep->ep_cid);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : mgmt_open_connection Failed for cid=%d\n",
+			    beiscsi_ep->ep_cid);
+
 		beiscsi_put_cid(phba, beiscsi_ep->ep_cid);
 		pci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,
 				    nonemb_cmd.va, nonemb_cmd.dma);
@@ -867,9 +928,12 @@ static int beiscsi_open_conn(struct iscsi_endpoint *ep,
 	extd_status = (phba->ctrl.mcc_numtag[tag] & 0x0000FF00) >> 8;
 	status = phba->ctrl.mcc_numtag[tag] & 0x000000FF;
 	if (status || extd_status) {
-		SE_DEBUG(DBG_LVL_1, "mgmt_open_connection Failed"
-				    " status = %d extd_status = %d\n",
-				    status, extd_status);
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+			    "BS_%d : mgmt_open_connection Failed"
+			    " status = %d extd_status = %d\n",
+			    status, extd_status);
+
 		free_mcc_tag(&phba->ctrl, tag);
 		pci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,
 			    nonemb_cmd.va, nonemb_cmd.dma);
@@ -882,7 +946,8 @@ static int beiscsi_open_conn(struct iscsi_endpoint *ep,
 		beiscsi_ep = ep->dd_data;
 		beiscsi_ep->fw_handle = ptcpcnct_out->connection_handle;
 		beiscsi_ep->cid_vld = 1;
-		SE_DEBUG(DBG_LVL_8, "mgmt_open_connection Success\n");
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+			    "BS_%d : mgmt_open_connection Success\n");
 	}
 	pci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,
 			    nonemb_cmd.va, nonemb_cmd.dma);
@@ -910,18 +975,19 @@ beiscsi_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,
 	struct iscsi_endpoint *ep;
 	int ret;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_ep_connect\n");
 	if (shost)
 		phba = iscsi_host_priv(shost);
 	else {
 		ret = -ENXIO;
-		SE_DEBUG(DBG_LVL_1, "shost is NULL\n");
+		printk(KERN_ERR
+		       "beiscsi_ep_connect shost is NULL\n");
 		return ERR_PTR(ret);
 	}
 
 	if (phba->state != BE_ADAPTER_UP) {
 		ret = -EBUSY;
-		SE_DEBUG(DBG_LVL_1, "The Adapter state is Not UP\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : The Adapter state is Not UP\n");
 		return ERR_PTR(ret);
 	}
 
@@ -936,7 +1002,8 @@ beiscsi_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,
 	beiscsi_ep->openiscsi_ep = ep;
 	ret = beiscsi_open_conn(ep, NULL, dst_addr, non_blocking);
 	if (ret) {
-		SE_DEBUG(DBG_LVL_1, "Failed in beiscsi_open_conn\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Failed in beiscsi_open_conn\n");
 		goto free_ep;
 	}
 
@@ -958,7 +1025,9 @@ int beiscsi_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)
 {
 	struct beiscsi_endpoint *beiscsi_ep = ep->dd_data;
 
-	SE_DEBUG(DBG_LVL_8, "In  beiscsi_ep_poll\n");
+	beiscsi_log(beiscsi_ep->phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : In  beiscsi_ep_poll\n");
+
 	if (beiscsi_ep->cid_vld == 1)
 		return 1;
 	else
@@ -978,8 +1047,10 @@ static int beiscsi_close_conn(struct  beiscsi_endpoint *beiscsi_ep, int flag)
 
 	tag = mgmt_upload_connection(phba, beiscsi_ep->ep_cid, flag);
 	if (!tag) {
-		SE_DEBUG(DBG_LVL_8, "upload failed for cid 0x%x\n",
-			 beiscsi_ep->ep_cid);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+			    "BS_%d : upload failed for cid 0x%x\n",
+			    beiscsi_ep->ep_cid);
+
 		ret = -EAGAIN;
 	} else {
 		wait_event_interruptible(phba->ctrl.mcc_wait[tag],
@@ -1000,7 +1071,8 @@ static int beiscsi_unbind_conn_to_cid(struct beiscsi_hba *phba,
 	if (phba->conn_table[cid])
 		phba->conn_table[cid] = NULL;
 	else {
-		SE_DEBUG(DBG_LVL_8, "Connection table Not occupied.\n");
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+			    "BS_%d : Connection table Not occupied.\n");
 		return -EINVAL;
 	}
 	return 0;
@@ -1022,27 +1094,31 @@ void beiscsi_ep_disconnect(struct iscsi_endpoint *ep)
 
 	beiscsi_ep = ep->dd_data;
 	phba = beiscsi_ep->phba;
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_ep_disconnect for ep_cid = %d\n",
-			     beiscsi_ep->ep_cid);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_ep_disconnect for ep_cid = %d\n",
+		    beiscsi_ep->ep_cid);
 
 	if (!beiscsi_ep->conn) {
-		SE_DEBUG(DBG_LVL_8, "In beiscsi_ep_disconnect, no "
-			 "beiscsi_ep\n");
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+			    "BS_%d : In beiscsi_ep_disconnect, no "
+			    "beiscsi_ep\n");
 		return;
 	}
 	beiscsi_conn = beiscsi_ep->conn;
 	iscsi_suspend_queue(beiscsi_conn->conn);
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_ep_disconnect ep_cid = %d\n",
-		 beiscsi_ep->ep_cid);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BS_%d : In beiscsi_ep_disconnect ep_cid = %d\n",
+		    beiscsi_ep->ep_cid);
 
 	tag = mgmt_invalidate_connection(phba, beiscsi_ep,
 					    beiscsi_ep->ep_cid, 1,
 					    savecfg_flag);
 	if (!tag) {
-		SE_DEBUG(DBG_LVL_1,
-			 "mgmt_invalidate_connection Failed for cid=%d\n",
-			  beiscsi_ep->ep_cid);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BS_%d : mgmt_invalidate_connection"
+			    " Failed for cid=%d\n",
+			    beiscsi_ep->ep_cid);
 	} else {
 		wait_event_interruptible(phba->ctrl.mcc_wait[tag],
 					 phba->ctrl.mcc_numtag[tag]);
diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index bc8a1c5..c9b9f5b 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -55,9 +55,105 @@ MODULE_LICENSE("GPL");
 module_param(be_iopoll_budget, int, 0);
 module_param(enable_msix, int, 0);
 module_param(be_max_phys_size, uint, S_IRUGO);
-MODULE_PARM_DESC(be_max_phys_size, "Maximum Size (In Kilobytes) of physically"
-				   "contiguous memory that can be allocated."
-				   "Range is 16 - 128");
+MODULE_PARM_DESC(be_max_phys_size,
+		"Maximum Size (In Kilobytes) of physically contiguous "
+		"memory that can be allocated. Range is 16 - 128");
+
+#define beiscsi_disp_param(_name)\
+ssize_t	\
+beiscsi_##_name##_disp(struct device *dev,\
+			struct device_attribute *attrib, char *buf)	\
+{	\
+	struct Scsi_Host *shost = class_to_shost(dev);\
+	struct beiscsi_hba *phba = iscsi_host_priv(shost); \
+	uint32_t param_val = 0;	\
+	param_val = phba->attr_##_name;\
+	return snprintf(buf, PAGE_SIZE, "%d\n",\
+			phba->attr_##_name);\
+}
+
+#define beiscsi_change_param(_name, _minval, _maxval, _defaval)\
+int \
+beiscsi_##_name##_change(struct beiscsi_hba *phba, uint32_t val)\
+{\
+	if (val >= _minval && val <= _maxval) {\
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\
+			    "BA_%d : beiscsi_"#_name" updated "\
+			    "from 0x%x ==> 0x%x\n",\
+			    phba->attr_##_name, val); \
+		phba->attr_##_name = val;\
+		return 0;\
+	} \
+	beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT, \
+		    "BA_%d beiscsi_"#_name" attribute "\
+		    "cannot be updated to 0x%x, "\
+		    "range allowed is ["#_minval" - "#_maxval"]\n", val);\
+		return -EINVAL;\
+}
+
+#define beiscsi_store_param(_name)  \
+ssize_t \
+beiscsi_##_name##_store(struct device *dev,\
+			 struct device_attribute *attr, const char *buf,\
+			 size_t count) \
+{ \
+	struct Scsi_Host  *shost = class_to_shost(dev);\
+	struct beiscsi_hba *phba = iscsi_host_priv(shost);\
+	uint32_t param_val = 0;\
+	if (!isdigit(buf[0]))\
+		return -EINVAL;\
+	if (sscanf(buf, "%i", &param_val) != 1)\
+		return -EINVAL;\
+	if (beiscsi_##_name##_change(phba, param_val) == 0) \
+		return strlen(buf);\
+	else \
+		return -EINVAL;\
+}
+
+#define beiscsi_init_param(_name, _minval, _maxval, _defval) \
+int \
+beiscsi_##_name##_init(struct beiscsi_hba *phba, uint32_t val) \
+{ \
+	if (val >= _minval && val <= _maxval) {\
+		phba->attr_##_name = val;\
+		return 0;\
+	} \
+	beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\
+		    "BA_%d beiscsi_"#_name" attribute " \
+		    "cannot be updated to 0x%x, "\
+		    "range allowed is ["#_minval" - "#_maxval"]\n", val);\
+	phba->attr_##_name = _defval;\
+	return -EINVAL;\
+}
+
+#define BEISCSI_RW_ATTR(_name, _minval, _maxval, _defval, _descp) \
+static uint beiscsi_##_name = _defval;\
+module_param(beiscsi_##_name, uint, S_IRUGO);\
+MODULE_PARM_DESC(beiscsi_##_name, _descp);\
+beiscsi_disp_param(_name)\
+beiscsi_change_param(_name, _minval, _maxval, _defval)\
+beiscsi_store_param(_name)\
+beiscsi_init_param(_name, _minval, _maxval, _defval)\
+DEVICE_ATTR(beiscsi_##_name, S_IRUGO | S_IWUSR,\
+	      beiscsi_##_name##_disp, beiscsi_##_name##_store)
+
+/*
+ * When new log level added update the
+ * the MAX allowed value for log_enable
+ */
+BEISCSI_RW_ATTR(log_enable, 0x00,
+		0xFF, 0x00, "Enable logging Bit Mask\n"
+		"\t\t\t\tInitialization Events	: 0x01\n"
+		"\t\t\t\tMailbox Events		: 0x02\n"
+		"\t\t\t\tMiscellaneous Events	: 0x04\n"
+		"\t\t\t\tError Handling		: 0x08\n"
+		"\t\t\t\tIO Path Events		: 0x10\n"
+		"\t\t\t\tConfiguration Path	: 0x20\n");
+
+struct device_attribute *beiscsi_attrs[] = {
+	&dev_attr_beiscsi_log_enable,
+	NULL,
+};
 
 static int beiscsi_slave_configure(struct scsi_device *sdev)
 {
@@ -110,9 +206,9 @@ static int beiscsi_eh_abort(struct scsi_cmnd *sc)
 				sizeof(struct invalidate_commands_params_in),
 				&nonemb_cmd.dma);
 	if (nonemb_cmd.va == NULL) {
-		SE_DEBUG(DBG_LVL_1,
-			 "Failed to allocate memory for"
-			 "mgmt_invalidate_icds\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_EH,
+			    "BM_%d : Failed to allocate memory for"
+			    "mgmt_invalidate_icds\n");
 		return FAILED;
 	}
 	nonemb_cmd.size = sizeof(struct invalidate_commands_params_in);
@@ -120,9 +216,9 @@ static int beiscsi_eh_abort(struct scsi_cmnd *sc)
 	tag = mgmt_invalidate_icds(phba, inv_tbl, num_invalidate,
 				   cid, &nonemb_cmd);
 	if (!tag) {
-		shost_printk(KERN_WARNING, phba->shost,
-			     "mgmt_invalidate_icds could not be"
-			     " submitted\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_EH,
+			    "BM_%d : mgmt_invalidate_icds could not be"
+			    "submitted\n");
 		pci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,
 				    nonemb_cmd.va, nonemb_cmd.dma);
 
@@ -186,9 +282,9 @@ static int beiscsi_eh_device_reset(struct scsi_cmnd *sc)
 				sizeof(struct invalidate_commands_params_in),
 				&nonemb_cmd.dma);
 	if (nonemb_cmd.va == NULL) {
-		SE_DEBUG(DBG_LVL_1,
-			 "Failed to allocate memory for"
-			 "mgmt_invalidate_icds\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_EH,
+			    "BM_%d : Failed to allocate memory for"
+			    "mgmt_invalidate_icds\n");
 		return FAILED;
 	}
 	nonemb_cmd.size = sizeof(struct invalidate_commands_params_in);
@@ -196,9 +292,9 @@ static int beiscsi_eh_device_reset(struct scsi_cmnd *sc)
 	tag = mgmt_invalidate_icds(phba, inv_tbl, num_invalidate,
 				   cid, &nonemb_cmd);
 	if (!tag) {
-		shost_printk(KERN_WARNING, phba->shost,
-			     "mgmt_invalidate_icds could not be"
-			     " submitted\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_EH,
+			    "BM_%d : mgmt_invalidate_icds could not be"
+			    " submitted\n");
 		pci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,
 				    nonemb_cmd.va, nonemb_cmd.dma);
 		return FAILED;
@@ -387,6 +483,7 @@ static DEFINE_PCI_DEVICE_TABLE(beiscsi_pci_id_table) = {
 };
 MODULE_DEVICE_TABLE(pci, beiscsi_pci_id_table);
 
+
 static struct scsi_host_template beiscsi_sht = {
 	.module = THIS_MODULE,
 	.name = "Emulex 10Gbe open-iscsi Initiator Driver",
@@ -398,6 +495,7 @@ static struct scsi_host_template beiscsi_sht = {
 	.eh_abort_handler = beiscsi_eh_abort,
 	.eh_device_reset_handler = beiscsi_eh_device_reset,
 	.eh_target_reset_handler = iscsi_eh_session_reset,
+	.shost_attrs = beiscsi_attrs,
 	.sg_tablesize = BEISCSI_SGLIST_ELEMENTS,
 	.can_queue = BE2_IO_DEPTH,
 	.this_id = -1,
@@ -417,8 +515,8 @@ static struct beiscsi_hba *beiscsi_hba_alloc(struct pci_dev *pcidev)
 
 	shost = iscsi_host_alloc(&beiscsi_sht, sizeof(*phba), 0);
 	if (!shost) {
-		dev_err(&pcidev->dev, "beiscsi_hba_alloc -"
-			"iscsi_host_alloc failed\n");
+		dev_err(&pcidev->dev,
+			"beiscsi_hba_alloc - iscsi_host_alloc failed\n");
 		return NULL;
 	}
 	shost->dma_boundary = pcidev->dma_mask;
@@ -508,8 +606,8 @@ static int beiscsi_enable_pci(struct pci_dev *pcidev)
 
 	ret = pci_enable_device(pcidev);
 	if (ret) {
-		dev_err(&pcidev->dev, "beiscsi_enable_pci - enable device "
-			"failed. Returning -ENODEV\n");
+		dev_err(&pcidev->dev,
+			"beiscsi_enable_pci - enable device failed\n");
 		return ret;
 	}
 
@@ -574,8 +672,9 @@ static void beiscsi_get_params(struct beiscsi_hba *phba)
 				    + BE2_TMFS) / 512) + 1) * 512;
 	phba->params.num_eq_entries = (phba->params.num_eq_entries < 1024)
 				? 1024 : phba->params.num_eq_entries;
-	SE_DEBUG(DBG_LVL_8, "phba->params.num_eq_entries=%d\n",
-			     phba->params.num_eq_entries);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "BM_%d : phba->params.num_eq_entries=%d\n",
+		    phba->params.num_eq_entries);
 	phba->params.num_cq_entries =
 	    (((BE2_CMDS_PER_CXN * 2 +  phba->fw_config.iscsi_cid_count * 2
 				    + BE2_TMFS) / 512) + 1) * 512;
@@ -619,8 +718,6 @@ static irqreturn_t be_isr_mcc(int irq, void *dev_id)
 	phba =  pbe_eq->phba;
 	mcc = &phba->ctrl.mcc_obj.cq;
 	eqe = queue_tail_node(eq);
-	if (!eqe)
-		SE_DEBUG(DBG_LVL_1, "eqe is NULL\n");
 
 	num_eq_processed = 0;
 
@@ -665,8 +762,6 @@ static irqreturn_t be_isr_msix(int irq, void *dev_id)
 	eq = &pbe_eq->q;
 	cq = pbe_eq->cq;
 	eqe = queue_tail_node(eq);
-	if (!eqe)
-		SE_DEBUG(DBG_LVL_1, "eqe is NULL\n");
 
 	phba = pbe_eq->phba;
 	num_eq_processed = 0;
@@ -741,8 +836,6 @@ static irqreturn_t be_isr(int irq, void *dev_id)
 	mcc = &phba->ctrl.mcc_obj.cq;
 	index = 0;
 	eqe = queue_tail_node(eq);
-	if (!eqe)
-		SE_DEBUG(DBG_LVL_1, "eqe is NULL\n");
 
 	num_ioeq_processed = 0;
 	num_mcceq_processed = 0;
@@ -839,9 +932,10 @@ static int beiscsi_init_irqs(struct beiscsi_hba *phba)
 					  phba->msi_name[i],
 					  &phwi_context->be_eq[i]);
 			if (ret) {
-				shost_printk(KERN_ERR, phba->shost,
-					     "beiscsi_init_irqs-Failed to"
-					     "register msix for i = %d\n", i);
+				beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+					    "BM_%d : beiscsi_init_irqs-Failed to"
+					    "register msix for i = %d\n",
+					    i);
 				kfree(phba->msi_name[i]);
 				goto free_msix_irqs;
 			}
@@ -857,8 +951,9 @@ static int beiscsi_init_irqs(struct beiscsi_hba *phba)
 		ret = request_irq(msix_vec, be_isr_mcc, 0, phba->msi_name[i],
 				  &phwi_context->be_eq[i]);
 		if (ret) {
-			shost_printk(KERN_ERR, phba->shost, "beiscsi_init_irqs-"
-				     "Failed to register beiscsi_msix_mcc\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT ,
+				    "BM_%d : beiscsi_init_irqs-"
+				    "Failed to register beiscsi_msix_mcc\n");
 			kfree(phba->msi_name[i]);
 			goto free_msix_irqs;
 		}
@@ -867,8 +962,9 @@ static int beiscsi_init_irqs(struct beiscsi_hba *phba)
 		ret = request_irq(pcidev->irq, be_isr, IRQF_SHARED,
 				  "beiscsi", phba);
 		if (ret) {
-			shost_printk(KERN_ERR, phba->shost, "beiscsi_init_irqs-"
-				     "Failed to register irq\\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : beiscsi_init_irqs-"
+				    "Failed to register irq\\n");
 			return ret;
 		}
 	}
@@ -919,7 +1015,9 @@ beiscsi_process_async_pdu(struct beiscsi_conn *beiscsi_conn,
 	case ISCSI_OP_REJECT:
 		WARN_ON(!pbuffer);
 		WARN_ON(!(buf_len == 48));
-		SE_DEBUG(DBG_LVL_1, "In ISCSI_OP_REJECT\n");
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,
+			    "BM_%d : In ISCSI_OP_REJECT\n");
 		break;
 	case ISCSI_OP_LOGIN_RSP:
 	case ISCSI_OP_TEXT_RSP:
@@ -929,11 +1027,12 @@ beiscsi_process_async_pdu(struct beiscsi_conn *beiscsi_conn,
 		login_hdr->itt = io_task->libiscsi_itt;
 		break;
 	default:
-		shost_printk(KERN_WARNING, phba->shost,
-			     "Unrecognized opcode 0x%x in async msg\n",
-			     (ppdu->
+		beiscsi_log(phba, KERN_WARNING,
+			    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+			    "BM_%d : Unrecognized opcode 0x%x in async msg\n",
+			    (ppdu->
 			     dw[offsetof(struct amap_pdu_base, opcode) / 32]
-						& PDUBASE_OPCODE_MASK));
+			     & PDUBASE_OPCODE_MASK));
 		return 1;
 	}
 
@@ -948,9 +1047,11 @@ static struct sgl_handle *alloc_io_sgl_handle(struct beiscsi_hba *phba)
 	struct sgl_handle *psgl_handle;
 
 	if (phba->io_sgl_hndl_avbl) {
-		SE_DEBUG(DBG_LVL_8,
-			 "In alloc_io_sgl_handle,io_sgl_alloc_index=%d\n",
-			 phba->io_sgl_alloc_index);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_IO,
+			    "BM_%d : In alloc_io_sgl_handle,"
+			    " io_sgl_alloc_index=%d\n",
+			    phba->io_sgl_alloc_index);
+
 		psgl_handle = phba->io_sgl_hndl_base[phba->
 						io_sgl_alloc_index];
 		phba->io_sgl_hndl_base[phba->io_sgl_alloc_index] = NULL;
@@ -968,17 +1069,20 @@ static struct sgl_handle *alloc_io_sgl_handle(struct beiscsi_hba *phba)
 static void
 free_io_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle)
 {
-	SE_DEBUG(DBG_LVL_8, "In free_,io_sgl_free_index=%d\n",
-		 phba->io_sgl_free_index);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_IO,
+		    "BM_%d : In free_,io_sgl_free_index=%d\n",
+		    phba->io_sgl_free_index);
+
 	if (phba->io_sgl_hndl_base[phba->io_sgl_free_index]) {
 		/*
 		 * this can happen if clean_task is called on a task that
 		 * failed in xmit_task or alloc_pdu.
 		 */
-		 SE_DEBUG(DBG_LVL_8,
-			 "Double Free in IO SGL io_sgl_free_index=%d,"
-			 "value there=%p\n", phba->io_sgl_free_index,
-			 phba->io_sgl_hndl_base[phba->io_sgl_free_index]);
+		 beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_IO,
+			     "BM_%d : Double Free in IO SGL io_sgl_free_index=%d,"
+			     "value there=%p\n", phba->io_sgl_free_index,
+			     phba->io_sgl_hndl_base
+			     [phba->io_sgl_free_index]);
 		return;
 	}
 	phba->io_sgl_hndl_base[phba->io_sgl_free_index] = psgl_handle;
@@ -1040,11 +1144,12 @@ free_wrb_handle(struct beiscsi_hba *phba, struct hwi_wrb_context *pwrb_context,
 	else
 		pwrb_context->free_index++;
 
-	SE_DEBUG(DBG_LVL_8,
-		 "FREE WRB: pwrb_handle=%p free_index=0x%x"
-		 "wrb_handles_available=%d\n",
-		 pwrb_handle, pwrb_context->free_index,
-		 pwrb_context->wrb_handles_available);
+	beiscsi_log(phba, KERN_INFO,
+		    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+		    "BM_%d : FREE WRB: pwrb_handle=%p free_index=0x%x"
+		    "wrb_handles_available=%d\n",
+		    pwrb_handle, pwrb_context->free_index,
+		    pwrb_context->wrb_handles_available);
 }
 
 static struct sgl_handle *alloc_mgmt_sgl_handle(struct beiscsi_hba *phba)
@@ -1054,8 +1159,11 @@ static struct sgl_handle *alloc_mgmt_sgl_handle(struct beiscsi_hba *phba)
 	if (phba->eh_sgl_hndl_avbl) {
 		psgl_handle = phba->eh_sgl_hndl_base[phba->eh_sgl_alloc_index];
 		phba->eh_sgl_hndl_base[phba->eh_sgl_alloc_index] = NULL;
-		SE_DEBUG(DBG_LVL_8, "mgmt_sgl_alloc_index=%d=0x%x\n",
-			 phba->eh_sgl_alloc_index, phba->eh_sgl_alloc_index);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+			    "BM_%d : mgmt_sgl_alloc_index=%d=0x%x\n",
+			    phba->eh_sgl_alloc_index,
+			    phba->eh_sgl_alloc_index);
+
 		phba->eh_sgl_hndl_avbl--;
 		if (phba->eh_sgl_alloc_index ==
 		    (phba->params.icds_per_ctrl - phba->params.ios_per_ctrl -
@@ -1072,16 +1180,20 @@ void
 free_mgmt_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle)
 {
 
-	SE_DEBUG(DBG_LVL_8, "In  free_mgmt_sgl_handle,eh_sgl_free_index=%d\n",
-			     phba->eh_sgl_free_index);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BM_%d : In  free_mgmt_sgl_handle,"
+		    "eh_sgl_free_index=%d\n",
+		    phba->eh_sgl_free_index);
+
 	if (phba->eh_sgl_hndl_base[phba->eh_sgl_free_index]) {
 		/*
 		 * this can happen if clean_task is called on a task that
 		 * failed in xmit_task or alloc_pdu.
 		 */
-		SE_DEBUG(DBG_LVL_8,
-			 "Double Free in eh SGL ,eh_sgl_free_index=%d\n",
-			 phba->eh_sgl_free_index);
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
+			    "BM_%d : Double Free in eh SGL ,"
+			    "eh_sgl_free_index=%d\n",
+			    phba->eh_sgl_free_index);
 		return;
 	}
 	phba->eh_sgl_hndl_base[phba->eh_sgl_free_index] = psgl_handle;
@@ -1323,9 +1435,10 @@ static void hwi_complete_cmd(struct beiscsi_conn *beiscsi_conn,
 		break;
 
 	case HWH_TYPE_LOGIN:
-		SE_DEBUG(DBG_LVL_1,
-			 "\t\t No HWH_TYPE_LOGIN Expected in hwi_complete_cmd"
-			 "- Solicited path\n");
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,
+			    "BM_%d :\t\t No HWH_TYPE_LOGIN Expected in"
+			    " hwi_complete_cmd- Solicited path\n");
 		break;
 
 	case HWH_TYPE_NOP:
@@ -1333,13 +1446,14 @@ static void hwi_complete_cmd(struct beiscsi_conn *beiscsi_conn,
 		break;
 
 	default:
-		shost_printk(KERN_WARNING, phba->shost,
-				"In hwi_complete_cmd, unknown type = %d"
-				"wrb_index 0x%x CID 0x%x\n", type,
-				((psol->dw[offsetof(struct amap_iscsi_wrb,
-				type) / 32] & SOL_WRB_INDEX_MASK) >> 16),
-				((psol->dw[offsetof(struct amap_sol_cqe,
-				cid) / 32] & SOL_CID_MASK) >> 6));
+		beiscsi_log(phba, KERN_WARNING,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,
+			    "BM_%d : In hwi_complete_cmd, unknown type = %d"
+			    "wrb_index 0x%x CID 0x%x\n", type,
+			    ((psol->dw[offsetof(struct amap_iscsi_wrb,
+			    type) / 32] & SOL_WRB_INDEX_MASK) >> 16),
+			    ((psol->dw[offsetof(struct amap_sol_cqe,
+			    cid) / 32] & SOL_CID_MASK) >> 6));
 		break;
 	}
 
@@ -1394,10 +1508,11 @@ hwi_get_async_handle(struct beiscsi_hba *phba,
 		break;
 	default:
 		pbusy_list = NULL;
-		shost_printk(KERN_WARNING, phba->shost,
-			"Unexpected code=%d\n",
-			 pdpdu_cqe->dw[offsetof(struct amap_i_t_dpdu_cqe,
-					code) / 32] & PDUCQE_CODE_MASK);
+		beiscsi_log(phba, KERN_WARNING,
+			    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+			    "BM_%d : Unexpected code=%d\n",
+			    pdpdu_cqe->dw[offsetof(struct amap_i_t_dpdu_cqe,
+			    code) / 32] & PDUCQE_CODE_MASK);
 		return NULL;
 	}
 
@@ -1422,8 +1537,9 @@ hwi_get_async_handle(struct beiscsi_hba *phba,
 }
 
 static unsigned int
-hwi_update_async_writables(struct hwi_async_pdu_context *pasync_ctx,
-			   unsigned int is_header, unsigned int cq_index)
+hwi_update_async_writables(struct beiscsi_hba *phba,
+			    struct hwi_async_pdu_context *pasync_ctx,
+			    unsigned int is_header, unsigned int cq_index)
 {
 	struct list_head *pbusy_list;
 	struct async_pdu_handle *pasync_handle;
@@ -1460,9 +1576,10 @@ hwi_update_async_writables(struct hwi_async_pdu_context *pasync_ctx,
 	}
 
 	if (!writables) {
-		SE_DEBUG(DBG_LVL_1,
-			 "Duplicate notification received - index 0x%x!!\n",
-			 cq_index);
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,
+			    "BM_%d : Duplicate notification received - index 0x%x!!\n",
+			    cq_index);
 		WARN_ON(1);
 	}
 
@@ -1613,8 +1730,8 @@ static void hwi_flush_default_pdu_buffer(struct beiscsi_hba *phba,
 					     pdpdu_cqe, &cq_index);
 	BUG_ON(pasync_handle->is_header != 0);
 	if (pasync_handle->consumed == 0)
-		hwi_update_async_writables(pasync_ctx, pasync_handle->is_header,
-					   cq_index);
+		hwi_update_async_writables(phba, pasync_ctx,
+					   pasync_handle->is_header, cq_index);
 
 	hwi_free_async_msg(phba, pasync_handle->cri);
 	hwi_post_async_buffers(phba, pasync_handle->is_header);
@@ -1742,8 +1859,9 @@ static void hwi_process_default_pdu_ring(struct beiscsi_conn *beiscsi_conn,
 					     pdpdu_cqe, &cq_index);
 
 	if (pasync_handle->consumed == 0)
-		hwi_update_async_writables(pasync_ctx, pasync_handle->is_header,
-					   cq_index);
+		hwi_update_async_writables(phba, pasync_ctx,
+					   pasync_handle->is_header, cq_index);
+
 	hwi_gather_async_pdu(beiscsi_conn, phba, pasync_handle);
 	hwi_post_async_buffers(phba, pasync_handle->is_header);
 }
@@ -1771,9 +1889,10 @@ static void  beiscsi_process_mcc_isr(struct beiscsi_hba *phba)
 				beiscsi_async_link_state_process(phba,
 				(struct be_async_event_link_state *) mcc_compl);
 			else
-				SE_DEBUG(DBG_LVL_1,
-					" Unsupported Async Event, flags"
-					" = 0x%08x\n", mcc_compl->flags);
+				beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_MBOX,
+					    "BM_%d :  Unsupported Async Event, flags"
+					    " = 0x%08x\n",
+					    mcc_compl->flags);
 		} else if (mcc_compl->flags & CQE_FLAGS_COMPLETED_MASK) {
 			be_mcc_compl_process_isr(&phba->ctrl, mcc_compl);
 			atomic_dec(&phba->ctrl.mcc_obj.q.used);
@@ -1832,26 +1951,36 @@ static unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq)
 			hwi_complete_cmd(beiscsi_conn, phba, sol);
 			break;
 		case DRIVERMSG_NOTIFY:
-			SE_DEBUG(DBG_LVL_8, "Received DRIVERMSG_NOTIFY\n");
+			beiscsi_log(phba, KERN_INFO,
+				    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+				    "BM_%d : Received DRIVERMSG_NOTIFY\n");
+
 			dmsg = (struct dmsg_cqe *)sol;
 			hwi_complete_drvr_msgs(beiscsi_conn, phba, sol);
 			break;
 		case UNSOL_HDR_NOTIFY:
-			SE_DEBUG(DBG_LVL_8, "Received UNSOL_HDR_ NOTIFY\n");
+			beiscsi_log(phba, KERN_INFO,
+				    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+				    "BM_%d : Received UNSOL_HDR_ NOTIFY\n");
+
 			hwi_process_default_pdu_ring(beiscsi_conn, phba,
 					     (struct i_t_dpdu_cqe *)sol);
 			break;
 		case UNSOL_DATA_NOTIFY:
-			SE_DEBUG(DBG_LVL_8, "Received UNSOL_DATA_NOTIFY\n");
+			beiscsi_log(phba, KERN_INFO,
+				    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,
+				    "BM_%d : Received UNSOL_DATA_NOTIFY\n");
+
 			hwi_process_default_pdu_ring(beiscsi_conn, phba,
 					     (struct i_t_dpdu_cqe *)sol);
 			break;
 		case CXN_INVALIDATE_INDEX_NOTIFY:
 		case CMD_INVALIDATED_NOTIFY:
 		case CXN_INVALIDATE_NOTIFY:
-			SE_DEBUG(DBG_LVL_1,
-				 "Ignoring CQ Error notification for cmd/cxn"
-				 "invalidate\n");
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+				    "BM_%d : Ignoring CQ Error notification for"
+				    " cmd/cxn invalidate\n");
 			break;
 		case SOL_CMD_KILLED_DATA_DIGEST_ERR:
 		case CMD_KILLED_INVALID_STATSN_RCVD:
@@ -1861,17 +1990,20 @@ static unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq)
 		case CMD_CXN_KILLED_ITT_INVALID:
 		case CMD_CXN_KILLED_SEQ_OUTOFORDER:
 		case CMD_CXN_KILLED_INVALID_DATASN_RCVD:
-			SE_DEBUG(DBG_LVL_1,
-				 "CQ Error notification for cmd.. "
-				 "code %d cid 0x%x\n",
-				 sol->dw[offsetof(struct amap_sol_cqe, code) /
-				 32] & CQE_CODE_MASK,
-				 (sol->dw[offsetof(struct amap_sol_cqe, cid) /
-				 32] & SOL_CID_MASK));
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,
+				    "BM_%d : CQ Error notification for cmd.. "
+				    "code %d cid 0x%x\n",
+				    sol->dw[offsetof(struct amap_sol_cqe,
+				    code) / 32] & CQE_CODE_MASK,
+				    sol->dw[offsetof(struct amap_sol_cqe,
+				    cid) / 32] & SOL_CID_MASK);
 			break;
 		case UNSOL_DATA_DIGEST_ERROR_NOTIFY:
-			SE_DEBUG(DBG_LVL_1,
-				 "Digest error on def pdu ring, dropping..\n");
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+				    "BM_%d : Digest error on def pdu ring,"
+				    " dropping..\n");
 			hwi_flush_default_pdu_buffer(phba, beiscsi_conn,
 					     (struct i_t_dpdu_cqe *) sol);
 			break;
@@ -1889,33 +2021,38 @@ static unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq)
 		case CXN_KILLED_OVER_RUN_RESIDUAL:
 		case CXN_KILLED_UNDER_RUN_RESIDUAL:
 		case CXN_KILLED_CMND_DATA_NOT_ON_SAME_CONN:
-			SE_DEBUG(DBG_LVL_1, "CQ Error %d, reset CID "
-				 "0x%x...\n",
-				 sol->dw[offsetof(struct amap_sol_cqe, code) /
-				 32] & CQE_CODE_MASK,
-				 (sol->dw[offsetof(struct amap_sol_cqe, cid) /
-				 32] & CQE_CID_MASK));
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+				    "BM_%d : CQ Error %d, reset CID 0x%x...\n",
+				    sol->dw[offsetof(struct amap_sol_cqe,
+				    code) / 32] & CQE_CODE_MASK,
+				    sol->dw[offsetof(struct amap_sol_cqe,
+				    cid) / 32] & CQE_CID_MASK);
 			iscsi_conn_failure(beiscsi_conn->conn,
 					   ISCSI_ERR_CONN_FAILED);
 			break;
 		case CXN_KILLED_RST_SENT:
 		case CXN_KILLED_RST_RCVD:
-			SE_DEBUG(DBG_LVL_1, "CQ Error %d, reset"
-				"received/sent on CID 0x%x...\n",
-				 sol->dw[offsetof(struct amap_sol_cqe, code) /
-				 32] & CQE_CODE_MASK,
-				 (sol->dw[offsetof(struct amap_sol_cqe, cid) /
-				 32] & CQE_CID_MASK));
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+				    "BM_%d : CQ Error %d, reset"
+				    "received/sent on CID 0x%x...\n",
+				    sol->dw[offsetof(struct amap_sol_cqe,
+					code) / 32] & CQE_CODE_MASK,
+				    sol->dw[offsetof(struct amap_sol_cqe,
+					cid) / 32] & CQE_CID_MASK);
 			iscsi_conn_failure(beiscsi_conn->conn,
 					   ISCSI_ERR_CONN_FAILED);
 			break;
 		default:
-			SE_DEBUG(DBG_LVL_1, "CQ Error Invalid code= %d "
-				 "received on CID 0x%x...\n",
-				 sol->dw[offsetof(struct amap_sol_cqe, code) /
-				 32] & CQE_CODE_MASK,
-				 (sol->dw[offsetof(struct amap_sol_cqe, cid) /
-				 32] & CQE_CID_MASK));
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+				    "BM_%d : CQ Error Invalid code= %d "
+				    "received on CID 0x%x...\n",
+				    sol->dw[offsetof(struct amap_sol_cqe,
+				    code) / 32] & CQE_CODE_MASK,
+				    sol->dw[offsetof(struct amap_sol_cqe,
+				    cid) / 32] & CQE_CID_MASK);
 			break;
 		}
 
@@ -1974,7 +2111,10 @@ static int be_iopoll(struct blk_iopoll *iop, int budget)
 	if (ret < budget) {
 		phba = pbe_eq->phba;
 		blk_iopoll_complete(iop);
-		SE_DEBUG(DBG_LVL_8, "rearm pbe_eq->q.id =%d\n", pbe_eq->q.id);
+		beiscsi_log(phba, KERN_INFO,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_IO,
+			    "BM_%d : rearm pbe_eq->q.id =%d\n",
+			    pbe_eq->q.id);
 		hwi_ring_eq_db(phba, pbe_eq->q.id, 0, 0, 1, 1);
 	}
 	return ret;
@@ -2345,16 +2485,16 @@ static int beiscsi_init_wrb_handle(struct beiscsi_hba *phba)
 				kzalloc(sizeof(struct wrb_handle *) *
 					phba->params.wrbs_per_cxn, GFP_KERNEL);
 		if (!pwrb_context->pwrb_handle_base) {
-			shost_printk(KERN_ERR, phba->shost,
-					"Mem Alloc Failed. Failing to load\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : Mem Alloc Failed. Failing to load\n");
 			goto init_wrb_hndl_failed;
 		}
 		pwrb_context->pwrb_handle_basestd =
 				kzalloc(sizeof(struct wrb_handle *) *
 					phba->params.wrbs_per_cxn, GFP_KERNEL);
 		if (!pwrb_context->pwrb_handle_basestd) {
-			shost_printk(KERN_ERR, phba->shost,
-					"Mem Alloc Failed. Failing to load\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : Mem Alloc Failed. Failing to load\n");
 			goto init_wrb_hndl_failed;
 		}
 		if (!num_cxn_wrbh) {
@@ -2435,12 +2575,13 @@ static void hwi_init_async_pdu_ctx(struct beiscsi_hba *phba)
 	mem_descr = (struct be_mem_descriptor *)phba->init_mem;
 	mem_descr += HWI_MEM_ASYNC_HEADER_BUF;
 	if (mem_descr->mem_array[0].virtual_address) {
-		SE_DEBUG(DBG_LVL_8,
-			 "hwi_init_async_pdu_ctx HWI_MEM_ASYNC_HEADER_BUF"
-			 "va=%p\n", mem_descr->mem_array[0].virtual_address);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d : hwi_init_async_pdu_ctx"
+			    " HWI_MEM_ASYNC_HEADER_BUF va=%p\n",
+			    mem_descr->mem_array[0].virtual_address);
 	} else
-		shost_printk(KERN_WARNING, phba->shost,
-			     "No Virtual address\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+			    "BM_%d : No Virtual address\n");
 
 	pasync_ctx->async_header.va_base =
 			mem_descr->mem_array[0].virtual_address;
@@ -2451,24 +2592,27 @@ static void hwi_init_async_pdu_ctx(struct beiscsi_hba *phba)
 	mem_descr = (struct be_mem_descriptor *)phba->init_mem;
 	mem_descr += HWI_MEM_ASYNC_HEADER_RING;
 	if (mem_descr->mem_array[0].virtual_address) {
-		SE_DEBUG(DBG_LVL_8,
-			 "hwi_init_async_pdu_ctx HWI_MEM_ASYNC_HEADER_RING"
-			 "va=%p\n", mem_descr->mem_array[0].virtual_address);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d : hwi_init_async_pdu_ctx"
+			    " HWI_MEM_ASYNC_HEADER_RING va=%p\n",
+			    mem_descr->mem_array[0].virtual_address);
 	} else
-		shost_printk(KERN_WARNING, phba->shost,
-			    "No Virtual address\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+			    "BM_%d : No Virtual address\n");
+
 	pasync_ctx->async_header.ring_base =
 			mem_descr->mem_array[0].virtual_address;
 
 	mem_descr = (struct be_mem_descriptor *)phba->init_mem;
 	mem_descr += HWI_MEM_ASYNC_HEADER_HANDLE;
 	if (mem_descr->mem_array[0].virtual_address) {
-		SE_DEBUG(DBG_LVL_8,
-			 "hwi_init_async_pdu_ctx HWI_MEM_ASYNC_HEADER_HANDLE"
-			 "va=%p\n", mem_descr->mem_array[0].virtual_address);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d : hwi_init_async_pdu_ctx"
+			    " HWI_MEM_ASYNC_HEADER_HANDLE va=%p\n",
+			    mem_descr->mem_array[0].virtual_address);
 	} else
-		shost_printk(KERN_WARNING, phba->shost,
-			    "No Virtual address\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+			    "BM_%d : No Virtual address\n");
 
 	pasync_ctx->async_header.handle_base =
 			mem_descr->mem_array[0].virtual_address;
@@ -2479,12 +2623,13 @@ static void hwi_init_async_pdu_ctx(struct beiscsi_hba *phba)
 	mem_descr = (struct be_mem_descriptor *)phba->init_mem;
 	mem_descr += HWI_MEM_ASYNC_DATA_RING;
 	if (mem_descr->mem_array[0].virtual_address) {
-		SE_DEBUG(DBG_LVL_8,
-			 "hwi_init_async_pdu_ctx HWI_MEM_ASYNC_DATA_RING"
-			 "va=%p\n", mem_descr->mem_array[0].virtual_address);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d : hwi_init_async_pdu_ctx"
+			    " HWI_MEM_ASYNC_DATA_RING va=%p\n",
+			    mem_descr->mem_array[0].virtual_address);
 	} else
-		shost_printk(KERN_WARNING, phba->shost,
-			     "No Virtual address\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+			    "BM_%d : No Virtual address\n");
 
 	pasync_ctx->async_data.ring_base =
 			mem_descr->mem_array[0].virtual_address;
@@ -2492,8 +2637,8 @@ static void hwi_init_async_pdu_ctx(struct beiscsi_hba *phba)
 	mem_descr = (struct be_mem_descriptor *)phba->init_mem;
 	mem_descr += HWI_MEM_ASYNC_DATA_HANDLE;
 	if (!mem_descr->mem_array[0].virtual_address)
-		shost_printk(KERN_WARNING, phba->shost,
-			    "No Virtual address\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+			    "BM_%d : No Virtual address\n");
 
 	pasync_ctx->async_data.handle_base =
 			mem_descr->mem_array[0].virtual_address;
@@ -2508,12 +2653,14 @@ static void hwi_init_async_pdu_ctx(struct beiscsi_hba *phba)
 	mem_descr = (struct be_mem_descriptor *)phba->init_mem;
 	mem_descr += HWI_MEM_ASYNC_DATA_BUF;
 	if (mem_descr->mem_array[0].virtual_address) {
-		SE_DEBUG(DBG_LVL_8,
-			 "hwi_init_async_pdu_ctx HWI_MEM_ASYNC_DATA_BUF"
-			 "va=%p\n", mem_descr->mem_array[0].virtual_address);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d : hwi_init_async_pdu_ctx"
+			    " HWI_MEM_ASYNC_DATA_BUF va=%p\n",
+			    mem_descr->mem_array[0].virtual_address);
 	} else
-		shost_printk(KERN_WARNING, phba->shost,
-			    "No Virtual address\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+			    "BM_%d : No Virtual address\n");
+
 	idx = 0;
 	pasync_ctx->async_data.va_base =
 			mem_descr->mem_array[idx].virtual_address;
@@ -2654,7 +2801,7 @@ static int beiscsi_create_eqs(struct beiscsi_hba *phba,
 			     struct hwi_context_memory *phwi_context)
 {
 	unsigned int i, num_eq_pages;
-	int ret, eq_for_mcc;
+	int ret = 0, eq_for_mcc;
 	struct be_queue_info *eq;
 	struct be_dma_mem *mem;
 	void *eq_vaddress;
@@ -2681,8 +2828,8 @@ static int beiscsi_create_eqs(struct beiscsi_hba *phba,
 		ret = be_fill_queue(eq, phba->params.num_eq_entries,
 				    sizeof(struct be_eq_entry), eq_vaddress);
 		if (ret) {
-			shost_printk(KERN_ERR, phba->shost,
-				     "be_fill_queue Failed for EQ\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : be_fill_queue Failed for EQ\n");
 			goto create_eq_error;
 		}
 
@@ -2690,12 +2837,15 @@ static int beiscsi_create_eqs(struct beiscsi_hba *phba,
 		ret = beiscsi_cmd_eq_create(&phba->ctrl, eq,
 					    phwi_context->cur_eqd);
 		if (ret) {
-			shost_printk(KERN_ERR, phba->shost,
-				     "beiscsi_cmd_eq_create"
-				     "Failedfor EQ\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : beiscsi_cmd_eq_create"
+				    "Failed for EQ\n");
 			goto create_eq_error;
 		}
-		SE_DEBUG(DBG_LVL_8, "eqid = %d\n", phwi_context->be_eq[i].q.id);
+
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d : eqid = %d\n",
+			    phwi_context->be_eq[i].q.id);
 	}
 	return 0;
 create_eq_error:
@@ -2714,7 +2864,7 @@ static int beiscsi_create_cqs(struct beiscsi_hba *phba,
 			     struct hwi_context_memory *phwi_context)
 {
 	unsigned int i, num_cq_pages;
-	int ret;
+	int ret = 0;
 	struct be_queue_info *cq, *eq;
 	struct be_dma_mem *mem;
 	struct be_eq_obj *pbe_eq;
@@ -2739,8 +2889,9 @@ static int beiscsi_create_cqs(struct beiscsi_hba *phba,
 		ret = be_fill_queue(cq, phba->params.num_cq_entries,
 				    sizeof(struct sol_cqe), cq_vaddress);
 		if (ret) {
-			shost_printk(KERN_ERR, phba->shost,
-				     "be_fill_queue Failed for ISCSI CQ\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : be_fill_queue Failed "
+				    "for ISCSI CQ\n");
 			goto create_cq_error;
 		}
 
@@ -2748,14 +2899,14 @@ static int beiscsi_create_cqs(struct beiscsi_hba *phba,
 		ret = beiscsi_cmd_cq_create(&phba->ctrl, cq, eq, false,
 					    false, 0);
 		if (ret) {
-			shost_printk(KERN_ERR, phba->shost,
-				     "beiscsi_cmd_eq_create"
-				     "Failed for ISCSI CQ\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : beiscsi_cmd_eq_create"
+				    "Failed for ISCSI CQ\n");
 			goto create_cq_error;
 		}
-		SE_DEBUG(DBG_LVL_8, "iscsi cq_id is %d for eq_id %d\n",
-						 cq->id, eq->id);
-		SE_DEBUG(DBG_LVL_8, "ISCSI CQ CREATED\n");
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d : iscsi cq_id is %d for eq_id %d\n"
+			    "iSCSI CQ CREATED\n", cq->id, eq->id);
 	}
 	return 0;
 
@@ -2796,8 +2947,8 @@ beiscsi_create_def_hdr(struct beiscsi_hba *phba,
 			    sizeof(struct phys_addr),
 			    sizeof(struct phys_addr), dq_vaddress);
 	if (ret) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "be_fill_queue Failed for DEF PDU HDR\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : be_fill_queue Failed for DEF PDU HDR\n");
 		return ret;
 	}
 	mem->dma = (unsigned long)mem_descr->mem_array[idx].
@@ -2806,13 +2957,15 @@ beiscsi_create_def_hdr(struct beiscsi_hba *phba,
 					      def_pdu_ring_sz,
 					      phba->params.defpdu_hdr_sz);
 	if (ret) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "be_cmd_create_default_pdu_queue Failed DEFHDR\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : be_cmd_create_default_pdu_queue Failed DEFHDR\n");
 		return ret;
 	}
 	phwi_ctrlr->default_pdu_hdr.id = phwi_context->be_def_hdrq.id;
-	SE_DEBUG(DBG_LVL_8, "iscsi def pdu id is %d\n",
-		 phwi_context->be_def_hdrq.id);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "BM_%d : iscsi def pdu id is %d\n",
+		    phwi_context->be_def_hdrq.id);
+
 	hwi_post_async_buffers(phba, 1);
 	return 0;
 }
@@ -2841,8 +2994,8 @@ beiscsi_create_def_data(struct beiscsi_hba *phba,
 			    sizeof(struct phys_addr),
 			    sizeof(struct phys_addr), dq_vaddress);
 	if (ret) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "be_fill_queue Failed for DEF PDU DATA\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : be_fill_queue Failed for DEF PDU DATA\n");
 		return ret;
 	}
 	mem->dma = (unsigned long)mem_descr->mem_array[idx].
@@ -2851,16 +3004,20 @@ beiscsi_create_def_data(struct beiscsi_hba *phba,
 					      def_pdu_ring_sz,
 					      phba->params.defpdu_data_sz);
 	if (ret) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "be_cmd_create_default_pdu_queue Failed"
-			     " for DEF PDU DATA\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d be_cmd_create_default_pdu_queue"
+			    " Failed for DEF PDU DATA\n");
 		return ret;
 	}
 	phwi_ctrlr->default_pdu_data.id = phwi_context->be_def_dataq.id;
-	SE_DEBUG(DBG_LVL_8, "iscsi def data id is %d\n",
-		 phwi_context->be_def_dataq.id);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "BM_%d : iscsi def data id is %d\n",
+		    phwi_context->be_def_dataq.id);
+
 	hwi_post_async_buffers(phba, 0);
-	SE_DEBUG(DBG_LVL_8, "DEFAULT PDU DATA RING CREATED\n");
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "BM_%d : DEFAULT PDU DATA RING CREATED\n");
+
 	return 0;
 }
 
@@ -2886,13 +3043,14 @@ beiscsi_post_pages(struct beiscsi_hba *phba)
 						(pm_arr->size / PAGE_SIZE));
 		page_offset += pm_arr->size / PAGE_SIZE;
 		if (status != 0) {
-			shost_printk(KERN_ERR, phba->shost,
-				     "post sgl failed.\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : post sgl failed.\n");
 			return status;
 		}
 		pm_arr++;
 	}
-	SE_DEBUG(DBG_LVL_8, "POSTED PAGES\n");
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "BM_%d : POSTED PAGES\n");
 	return 0;
 }
 
@@ -2942,8 +3100,8 @@ beiscsi_create_wrb_rings(struct beiscsi_hba *phba,
 	pwrb_arr = kmalloc(sizeof(*pwrb_arr) * phba->params.cxns_per_ctrl,
 			   GFP_KERNEL);
 	if (!pwrb_arr) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "Memory alloc failed in create wrb ring.\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : Memory alloc failed in create wrb ring.\n");
 		return -ENOMEM;
 	}
 	wrb_vaddr = mem_descr->mem_array[idx].virtual_address;
@@ -2987,8 +3145,8 @@ beiscsi_create_wrb_rings(struct beiscsi_hba *phba,
 		status = be_cmd_wrbq_create(&phba->ctrl, &sgl,
 					    &phwi_context->be_wrbq[i]);
 		if (status != 0) {
-			shost_printk(KERN_ERR, phba->shost,
-				     "wrbq create failed.");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : wrbq create failed.");
 			kfree(pwrb_arr);
 			return status;
 		}
@@ -3124,7 +3282,6 @@ static int find_num_cpus(void)
 	if (num_cpus >= MAX_CPUS)
 		num_cpus = MAX_CPUS - 1;
 
-	SE_DEBUG(DBG_LVL_8, "num_cpus = %d\n", num_cpus);
 	return num_cpus;
 }
 
@@ -3147,7 +3304,8 @@ static int hwi_init_port(struct beiscsi_hba *phba)
 
 	status = beiscsi_create_eqs(phba, phwi_context);
 	if (status != 0) {
-		shost_printk(KERN_ERR, phba->shost, "EQ not created\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : EQ not created\n");
 		goto error;
 	}
 
@@ -3157,51 +3315,55 @@ static int hwi_init_port(struct beiscsi_hba *phba)
 
 	status = mgmt_check_supported_fw(ctrl, phba);
 	if (status != 0) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "Unsupported fw version\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : Unsupported fw version\n");
 		goto error;
 	}
 
 	status = beiscsi_create_cqs(phba, phwi_context);
 	if (status != 0) {
-		shost_printk(KERN_ERR, phba->shost, "CQ not created\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : CQ not created\n");
 		goto error;
 	}
 
 	status = beiscsi_create_def_hdr(phba, phwi_context, phwi_ctrlr,
 					def_pdu_ring_sz);
 	if (status != 0) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "Default Header not created\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : Default Header not created\n");
 		goto error;
 	}
 
 	status = beiscsi_create_def_data(phba, phwi_context,
 					 phwi_ctrlr, def_pdu_ring_sz);
 	if (status != 0) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "Default Data not created\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : Default Data not created\n");
 		goto error;
 	}
 
 	status = beiscsi_post_pages(phba);
 	if (status != 0) {
-		shost_printk(KERN_ERR, phba->shost, "Post SGL Pages Failed\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : Post SGL Pages Failed\n");
 		goto error;
 	}
 
 	status = beiscsi_create_wrb_rings(phba,	phwi_context, phwi_ctrlr);
 	if (status != 0) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "WRB Rings not created\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : WRB Rings not created\n");
 		goto error;
 	}
 
-	SE_DEBUG(DBG_LVL_8, "hwi_init_port success\n");
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "BM_%d : hwi_init_port success\n");
 	return 0;
 
 error:
-	shost_printk(KERN_ERR, phba->shost, "hwi_init_port failed");
+	beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+		    "BM_%d : hwi_init_port failed");
 	hwi_cleanup(phba);
 	return status;
 }
@@ -3214,12 +3376,13 @@ static int hwi_init_controller(struct beiscsi_hba *phba)
 	if (1 == phba->init_mem[HWI_MEM_ADDN_CONTEXT].num_elements) {
 		phwi_ctrlr->phwi_ctxt = (struct hwi_context_memory *)phba->
 		    init_mem[HWI_MEM_ADDN_CONTEXT].mem_array[0].virtual_address;
-		SE_DEBUG(DBG_LVL_8, " phwi_ctrlr->phwi_ctxt=%p\n",
-			 phwi_ctrlr->phwi_ctxt);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d :  phwi_ctrlr->phwi_ctxt=%p\n",
+			    phwi_ctrlr->phwi_ctxt);
 	} else {
-		shost_printk(KERN_ERR, phba->shost,
-			     "HWI_MEM_ADDN_CONTEXT is more than one element."
-			     "Failing to load\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : HWI_MEM_ADDN_CONTEXT is more "
+			    "than one element.Failing to load\n");
 		return -ENOMEM;
 	}
 
@@ -3229,8 +3392,9 @@ static int hwi_init_controller(struct beiscsi_hba *phba)
 
 	hwi_init_async_pdu_ctx(phba);
 	if (hwi_init_port(phba) != 0) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "hwi_init_controller failed\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : hwi_init_controller failed\n");
+
 		return -ENOMEM;
 	}
 	return 0;
@@ -3265,15 +3429,18 @@ static int beiscsi_init_controller(struct beiscsi_hba *phba)
 
 	ret = beiscsi_get_memory(phba);
 	if (ret < 0) {
-		shost_printk(KERN_ERR, phba->shost, "beiscsi_dev_probe -"
-			     "Failed in beiscsi_alloc_memory\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : beiscsi_dev_probe -"
+			    "Failed in beiscsi_alloc_memory\n");
 		return ret;
 	}
 
 	ret = hwi_init_controller(phba);
 	if (ret)
 		goto free_init;
-	SE_DEBUG(DBG_LVL_8, "Return success from beiscsi_init_controller");
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "BM_%d : Return success from beiscsi_init_controller");
+
 	return 0;
 
 free_init:
@@ -3298,8 +3465,8 @@ static int beiscsi_init_sgl_handle(struct beiscsi_hba *phba)
 						 phba->params.ios_per_ctrl,
 						 GFP_KERNEL);
 		if (!phba->io_sgl_hndl_base) {
-			shost_printk(KERN_ERR, phba->shost,
-				     "Mem Alloc Failed. Failing to load\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : Mem Alloc Failed. Failing to load\n");
 			return -ENOMEM;
 		}
 		phba->eh_sgl_hndl_base = kzalloc(sizeof(struct sgl_handle *) *
@@ -3308,14 +3475,14 @@ static int beiscsi_init_sgl_handle(struct beiscsi_hba *phba)
 						 GFP_KERNEL);
 		if (!phba->eh_sgl_hndl_base) {
 			kfree(phba->io_sgl_hndl_base);
-			shost_printk(KERN_ERR, phba->shost,
-				     "Mem Alloc Failed. Failing to load\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : Mem Alloc Failed. Failing to load\n");
 			return -ENOMEM;
 		}
 	} else {
-		shost_printk(KERN_ERR, phba->shost,
-			     "HWI_MEM_SGLH is more than one element."
-			     "Failing to load\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : HWI_MEM_SGLH is more than one element."
+			    "Failing to load\n");
 		return -ENOMEM;
 	}
 
@@ -3341,15 +3508,18 @@ static int beiscsi_init_sgl_handle(struct beiscsi_hba *phba)
 		}
 		idx++;
 	}
-	SE_DEBUG(DBG_LVL_8,
-		 "phba->io_sgl_hndl_avbl=%d"
-		 "phba->eh_sgl_hndl_avbl=%d\n",
-		 phba->io_sgl_hndl_avbl,
-		 phba->eh_sgl_hndl_avbl);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "BM_%d : phba->io_sgl_hndl_avbl=%d"
+		    "phba->eh_sgl_hndl_avbl=%d\n",
+		    phba->io_sgl_hndl_avbl,
+		    phba->eh_sgl_hndl_avbl);
+
 	mem_descr_sg = phba->init_mem;
 	mem_descr_sg += HWI_MEM_SGE;
-	SE_DEBUG(DBG_LVL_8, "\n mem_descr_sg->num_elements=%d\n",
-		 mem_descr_sg->num_elements);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "\n BM_%d : mem_descr_sg->num_elements=%d\n",
+		    mem_descr_sg->num_elements);
+
 	arr_index = 0;
 	idx = 0;
 	while (idx < mem_descr_sg->num_elements) {
@@ -3387,17 +3557,17 @@ static int hba_setup_cid_tbls(struct beiscsi_hba *phba)
 	phba->cid_array = kzalloc(sizeof(void *) * phba->params.cxns_per_ctrl,
 				  GFP_KERNEL);
 	if (!phba->cid_array) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "Failed to allocate memory in "
-			     "hba_setup_cid_tbls\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : Failed to allocate memory in "
+			    "hba_setup_cid_tbls\n");
 		return -ENOMEM;
 	}
 	phba->ep_array = kzalloc(sizeof(struct iscsi_endpoint *) *
 				 phba->params.cxns_per_ctrl * 2, GFP_KERNEL);
 	if (!phba->ep_array) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "Failed to allocate memory in "
-			     "hba_setup_cid_tbls\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : Failed to allocate memory in "
+			    "hba_setup_cid_tbls\n");
 		kfree(phba->cid_array);
 		return -ENOMEM;
 	}
@@ -3430,18 +3600,22 @@ static void hwi_enable_intr(struct beiscsi_hba *phba)
 	enabled = reg & MEMBAR_CTRL_INT_CTRL_HOSTINTR_MASK;
 	if (!enabled) {
 		reg |= MEMBAR_CTRL_INT_CTRL_HOSTINTR_MASK;
-		SE_DEBUG(DBG_LVL_8, "reg =x%08x addr=%p\n", reg, addr);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d : reg =x%08x addr=%p\n", reg, addr);
 		iowrite32(reg, addr);
 	}
 
 	if (!phba->msix_enabled) {
 		eq = &phwi_context->be_eq[0].q;
-		SE_DEBUG(DBG_LVL_8, "eq->id=%d\n", eq->id);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d : eq->id=%d\n", eq->id);
+
 		hwi_ring_eq_db(phba, eq->id, 0, 0, 1, 1);
 	} else {
 		for (i = 0; i <= phba->num_cpus; i++) {
 			eq = &phwi_context->be_eq[i].q;
-			SE_DEBUG(DBG_LVL_8, "eq->id=%d\n", eq->id);
+			beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+				    "BM_%d : eq->id=%d\n", eq->id);
 			hwi_ring_eq_db(phba, eq->id, 0, 0, 1, 1);
 		}
 	}
@@ -3459,8 +3633,8 @@ static void hwi_disable_intr(struct beiscsi_hba *phba)
 		reg &= ~MEMBAR_CTRL_INT_CTRL_HOSTINTR_MASK;
 		iowrite32(reg, addr);
 	} else
-		shost_printk(KERN_WARNING, phba->shost,
-			     "In hwi_disable_intr, Already Disabled\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+			    "BM_%d : In hwi_disable_intr, Already Disabled\n");
 }
 
 /**
@@ -3487,16 +3661,20 @@ static int beiscsi_get_boot_info(struct beiscsi_hba *phba)
 	/* Get the session handle of the boot target */
 	ret = be_mgmt_get_boot_shandle(phba, &s_handle);
 	if (ret) {
-		SE_DEBUG(DBG_LVL_1, "No boot session\n");
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
+			    "BM_%d : No boot session\n");
 		return ret;
 	}
 	nonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev,
 				sizeof(*session_resp),
 				&nonemb_cmd.dma);
 	if (nonemb_cmd.va == NULL) {
-		SE_DEBUG(DBG_LVL_1,
-			 "Failed to allocate memory for"
-			 "beiscsi_get_session_info\n");
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
+			    "BM_%d : Failed to allocate memory for"
+			    "beiscsi_get_session_info\n");
+
 		return -ENOMEM;
 	}
 
@@ -3504,8 +3682,11 @@ static int beiscsi_get_boot_info(struct beiscsi_hba *phba)
 	tag = mgmt_get_session_info(phba, s_handle,
 				    &nonemb_cmd);
 	if (!tag) {
-		SE_DEBUG(DBG_LVL_1, "beiscsi_get_session_info"
-			" Failed\n");
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
+			    "BM_%d : beiscsi_get_session_info"
+			    " Failed\n");
+
 		goto boot_freemem;
 	} else
 		wait_event_interruptible(phba->ctrl.mcc_wait[tag],
@@ -3515,9 +3696,12 @@ static int beiscsi_get_boot_info(struct beiscsi_hba *phba)
 	extd_status = (phba->ctrl.mcc_numtag[tag] & 0x0000FF00) >> 8;
 	status = phba->ctrl.mcc_numtag[tag] & 0x000000FF;
 	if (status || extd_status) {
-		SE_DEBUG(DBG_LVL_1, "beiscsi_get_session_info Failed"
-				    " status = %d extd_status = %d\n",
-				    status, extd_status);
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
+			    "BM_%d : beiscsi_get_session_info Failed"
+			    " status = %d extd_status = %d\n",
+			    status, extd_status);
+
 		free_mcc_tag(&phba->ctrl, tag);
 		goto boot_freemem;
 	}
@@ -3597,22 +3781,22 @@ static int beiscsi_init_port(struct beiscsi_hba *phba)
 
 	ret = beiscsi_init_controller(phba);
 	if (ret < 0) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "beiscsi_dev_probe - Failed in"
-			     "beiscsi_init_controller\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : beiscsi_dev_probe - Failed in"
+			    "beiscsi_init_controller\n");
 		return ret;
 	}
 	ret = beiscsi_init_sgl_handle(phba);
 	if (ret < 0) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "beiscsi_dev_probe - Failed in"
-			     "beiscsi_init_sgl_handle\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : beiscsi_dev_probe - Failed in"
+			    "beiscsi_init_sgl_handle\n");
 		goto do_cleanup_ctrlr;
 	}
 
 	if (hba_setup_cid_tbls(phba)) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "Failed in hba_setup_cid_tbls\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : Failed in hba_setup_cid_tbls\n");
 		kfree(phba->io_sgl_hndl_base);
 		kfree(phba->eh_sgl_hndl_base);
 		goto do_cleanup_ctrlr;
@@ -3664,8 +3848,8 @@ static void beiscsi_clean_port(struct beiscsi_hba *phba)
 
 	mgmt_status = mgmt_epfw_cleanup(phba, CMD_CONNECTION_CHUTE_0);
 	if (mgmt_status)
-		shost_printk(KERN_WARNING, phba->shost,
-			     "mgmt_epfw_cleanup FAILED\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+			    "BM_%d : mgmt_epfw_cleanup FAILED\n");
 
 	hwi_purge_eq(phba);
 	hwi_cleanup(phba);
@@ -3946,7 +4130,9 @@ free_hndls:
 	pci_pool_free(beiscsi_sess->bhs_pool, io_task->cmd_bhs,
 		      io_task->bhs_pa.u.a64.address);
 	io_task->cmd_bhs = NULL;
-	SE_DEBUG(DBG_LVL_1, "Alloc of SGL_ICD Failed\n");
+	beiscsi_log(phba, KERN_ERR,
+		    BEISCSI_LOG_IO | BEISCSI_LOG_CONFIG,
+		    "BM_%d : Alloc of SGL_ICD Failed\n");
 	return -ENOMEM;
 }
 
@@ -4064,8 +4250,10 @@ static int beiscsi_mtask(struct iscsi_task *task)
 		break;
 
 	default:
-		SE_DEBUG(DBG_LVL_1, "opcode =%d Not supported\n",
-			 task->hdr->opcode & ISCSI_OPCODE_MASK);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BM_%d : opcode =%d Not supported\n",
+			    task->hdr->opcode & ISCSI_OPCODE_MASK);
+
 		return -EINVAL;
 	}
 
@@ -4097,17 +4285,22 @@ static int beiscsi_task_xmit(struct iscsi_task *task)
 	io_task->scsi_cmnd = sc;
 	num_sg = scsi_dma_map(sc);
 	if (num_sg < 0) {
-		SE_DEBUG(DBG_LVL_1, " scsi_dma_map Failed\n")
+		struct iscsi_conn *conn = task->conn;
+		struct beiscsi_hba *phba = NULL;
+
+		phba = ((struct beiscsi_conn *)conn->dd_data)->phba;
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_IO,
+			    "BM_%d : scsi_dma_map Failed\n");
+
 		return num_sg;
 	}
 	xferlen = scsi_bufflen(sc);
 	sg = scsi_sglist(sc);
-	if (sc->sc_data_direction == DMA_TO_DEVICE) {
+	if (sc->sc_data_direction == DMA_TO_DEVICE)
 		writedir = 1;
-		SE_DEBUG(DBG_LVL_4, "task->imm_count=0x%08x\n",
-			 task->imm_count);
-	} else
+	 else
 		writedir = 0;
+
 	return beiscsi_iotask(task, sg, num_sg, xferlen, writedir);
 }
 
@@ -4136,14 +4329,17 @@ static int beiscsi_bsg_request(struct bsg_job *job)
 					job->request_payload.payload_len,
 					&nonemb_cmd.dma);
 		if (nonemb_cmd.va == NULL) {
-			SE_DEBUG(DBG_LVL_1, "Failed to allocate memory for "
-				 "beiscsi_bsg_request\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+				    "BM_%d : Failed to allocate memory for "
+				    "beiscsi_bsg_request\n");
 			return -EIO;
 		}
 		tag = mgmt_vendor_specific_fw_cmd(&phba->ctrl, phba, job,
 						  &nonemb_cmd);
 		if (!tag) {
-			SE_DEBUG(DBG_LVL_1, "be_cmd_get_mac_addr Failed\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+				    "BM_%d : be_cmd_get_mac_addr Failed\n");
+
 			pci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,
 					    nonemb_cmd.va, nonemb_cmd.dma);
 			return -EAGAIN;
@@ -4165,22 +4361,31 @@ static int beiscsi_bsg_request(struct bsg_job *job)
 		pci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,
 				    nonemb_cmd.va, nonemb_cmd.dma);
 		if (status || extd_status) {
-			SE_DEBUG(DBG_LVL_1, "be_cmd_get_mac_addr Failed"
-				 " status = %d extd_status = %d\n",
-				 status, extd_status);
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+				    "BM_%d : be_cmd_get_mac_addr Failed"
+				    " status = %d extd_status = %d\n",
+				    status, extd_status);
+
 			return -EIO;
 		}
 		break;
 
 	default:
-		SE_DEBUG(DBG_LVL_1, "Unsupported bsg command: 0x%x\n",
-			 bsg_req->msgcode);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+				"BM_%d : Unsupported bsg command: 0x%x\n",
+				bsg_req->msgcode);
 		break;
 	}
 
 	return rc;
 }
 
+void beiscsi_hba_attrs_init(struct beiscsi_hba *phba)
+{
+	/* Set the logging parameter */
+	beiscsi_log_enable_init(phba, beiscsi_log_enable);
+}
+
 static void beiscsi_quiesce(struct beiscsi_hba *phba)
 {
 	struct hwi_controller *phwi_ctrlr;
@@ -4290,18 +4495,21 @@ static int __devinit beiscsi_dev_probe(struct pci_dev *pcidev,
 
 	ret = beiscsi_enable_pci(pcidev);
 	if (ret < 0) {
-		dev_err(&pcidev->dev, "beiscsi_dev_probe-"
-			" Failed to enable pci device\n");
+		dev_err(&pcidev->dev,
+			"beiscsi_dev_probe - Failed to enable pci device\n");
 		return ret;
 	}
 
 	phba = beiscsi_hba_alloc(pcidev);
 	if (!phba) {
-		dev_err(&pcidev->dev, "beiscsi_dev_probe-"
-			" Failed in beiscsi_hba_alloc\n");
+		dev_err(&pcidev->dev,
+			"beiscsi_dev_probe - Failed in beiscsi_hba_alloc\n");
 		goto disable_pci;
 	}
 
+	/* Initialize Driver configuration Paramters */
+	beiscsi_hba_attrs_init(phba);
+
 	switch (pcidev->device) {
 	case BE_DEVICE_ID1:
 	case OC_DEVICE_ID1:
@@ -4321,7 +4529,9 @@ static int __devinit beiscsi_dev_probe(struct pci_dev *pcidev,
 	else
 		num_cpus = 1;
 	phba->num_cpus = num_cpus;
-	SE_DEBUG(DBG_LVL_8, "num_cpus = %d\n", phba->num_cpus);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "BM_%d : num_cpus = %d\n",
+		    phba->num_cpus);
 
 	if (enable_msix) {
 		beiscsi_msix_enable(phba);
@@ -4330,8 +4540,9 @@ static int __devinit beiscsi_dev_probe(struct pci_dev *pcidev,
 	}
 	ret = be_ctrl_init(phba, pcidev);
 	if (ret) {
-		shost_printk(KERN_ERR, phba->shost, "beiscsi_dev_probe-"
-				"Failed in be_ctrl_init\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : beiscsi_dev_probe-"
+			    "Failed in be_ctrl_init\n");
 		goto hba_free;
 	}
 
@@ -4340,19 +4551,19 @@ static int __devinit beiscsi_dev_probe(struct pci_dev *pcidev,
 		value = readl((void *)real_offset);
 		if (value & 0x00010000) {
 			gcrashmode++;
-			shost_printk(KERN_ERR, phba->shost,
-				"Loading Driver in crashdump mode\n");
+			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+				    "BM_%d : Loading Driver in crashdump mode\n");
 			ret = beiscsi_cmd_reset_function(phba);
 			if (ret) {
-				shost_printk(KERN_ERR, phba->shost,
-					"Reset Failed. Aborting Crashdump\n");
+				beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+					    "BM_%d : Reset Failed. Aborting Crashdump\n");
 				goto hba_free;
 			}
 			ret = be_chk_reset_complete(phba);
 			if (ret) {
-				shost_printk(KERN_ERR, phba->shost,
-					"Failed to get out of reset."
-					"Aborting Crashdump\n");
+				beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+					    "BM_%d : Failed to get out of reset."
+					    "Aborting Crashdump\n");
 				goto hba_free;
 			}
 		} else {
@@ -4367,8 +4578,8 @@ static int __devinit beiscsi_dev_probe(struct pci_dev *pcidev,
 	spin_lock_init(&phba->isr_lock);
 	ret = mgmt_get_fw_config(&phba->ctrl, phba);
 	if (ret != 0) {
-		shost_printk(KERN_ERR, phba->shost,
-			     "Error getting fw config\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : Error getting fw config\n");
 		goto free_port;
 	}
 	phba->shost->max_id = phba->fw_config.iscsi_cid_count;
@@ -4376,8 +4587,9 @@ static int __devinit beiscsi_dev_probe(struct pci_dev *pcidev,
 	phba->shost->can_queue = phba->params.ios_per_ctrl;
 	ret = beiscsi_init_port(phba);
 	if (ret < 0) {
-		shost_printk(KERN_ERR, phba->shost, "beiscsi_dev_probe-"
-			     "Failed in beiscsi_init_port\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : beiscsi_dev_probe-"
+			    "Failed in beiscsi_init_port\n");
 		goto free_port;
 	}
 
@@ -4394,8 +4606,9 @@ static int __devinit beiscsi_dev_probe(struct pci_dev *pcidev,
 		 phba->shost->host_no);
 	phba->wq = alloc_workqueue(phba->wq_name, WQ_MEM_RECLAIM, 1);
 	if (!phba->wq) {
-		shost_printk(KERN_ERR, phba->shost, "beiscsi_dev_probe-"
-				"Failed to allocate work queue\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : beiscsi_dev_probe-"
+			    "Failed to allocate work queue\n");
 		goto free_twq;
 	}
 
@@ -4413,8 +4626,9 @@ static int __devinit beiscsi_dev_probe(struct pci_dev *pcidev,
 	}
 	ret = beiscsi_init_irqs(phba);
 	if (ret < 0) {
-		shost_printk(KERN_ERR, phba->shost, "beiscsi_dev_probe-"
-			     "Failed to beiscsi_init_irqs\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : beiscsi_dev_probe-"
+			    "Failed to beiscsi_init_irqs\n");
 		goto free_blkenbld;
 	}
 	hwi_enable_intr(phba);
@@ -4424,11 +4638,13 @@ static int __devinit beiscsi_dev_probe(struct pci_dev *pcidev,
 		 * log error but continue, because we may not be using
 		 * iscsi boot.
 		 */
-		shost_printk(KERN_ERR, phba->shost, "Could not set up "
-			     "iSCSI boot info.\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BM_%d : Could not set up "
+			    "iSCSI boot info.\n");
 
 	beiscsi_create_def_ifaces(phba);
-	SE_DEBUG(DBG_LVL_8, "\n\n\n SUCCESS - DRIVER LOADED\n\n\n");
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+		    "\n\n\n BM_%d : SUCCESS - DRIVER LOADED\n\n\n");
 	return 0;
 
 free_blkenbld:
@@ -4516,19 +4732,17 @@ static int __init beiscsi_module_init(void)
 	beiscsi_scsi_transport =
 			iscsi_register_transport(&beiscsi_iscsi_transport);
 	if (!beiscsi_scsi_transport) {
-		SE_DEBUG(DBG_LVL_1,
-			 "beiscsi_module_init - Unable to  register beiscsi"
-			 "transport.\n");
+		printk(KERN_ERR
+		       "beiscsi_module_init - Unable to  register beiscsi transport.\n");
 		return -ENOMEM;
 	}
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_module_init, tt=%p\n",
-		 &beiscsi_iscsi_transport);
+	printk(KERN_INFO "In beiscsi_module_init, tt=%p\n",
+	       &beiscsi_iscsi_transport);
 
 	ret = pci_register_driver(&beiscsi_pci_driver);
 	if (ret) {
-		SE_DEBUG(DBG_LVL_1,
-			 "beiscsi_module_init - Unable to  register"
-			 "beiscsi pci driver.\n");
+		printk(KERN_ERR
+		       "beiscsi_module_init - Unable to  register beiscsi pci driver.\n");
 		goto unregister_iscsi_transport;
 	}
 	return 0;
diff --git a/drivers/scsi/be2iscsi/be_main.h b/drivers/scsi/be2iscsi/be_main.h
index 909e0bc..0f86ef9 100644
--- a/drivers/scsi/be2iscsi/be_main.h
+++ b/drivers/scsi/be2iscsi/be_main.h
@@ -24,6 +24,8 @@
 #include <linux/pci.h>
 #include <linux/if_ether.h>
 #include <linux/in.h>
+#include <linux/ctype.h>
+#include <linux/module.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
@@ -85,23 +87,6 @@
 #define IIOC_SCSI_DATA                  0x05	/* Write Operation */
 
 #define INVALID_SESS_HANDLE	0xFFFFFFFF
-#define DBG_LVL				0x00000001
-#define DBG_LVL_1			0x00000001
-#define DBG_LVL_2			0x00000002
-#define DBG_LVL_3			0x00000004
-#define DBG_LVL_4			0x00000008
-#define DBG_LVL_5			0x00000010
-#define DBG_LVL_6			0x00000020
-#define DBG_LVL_7			0x00000040
-#define DBG_LVL_8			0x00000080
-
-#define SE_DEBUG(debug_mask, fmt, args...)		\
-do {							\
-	if (debug_mask & DBG_LVL) {			\
-		printk(KERN_ERR "(%s():%d):", __func__, __LINE__);\
-		printk(fmt, ##args);			\
-	}						\
-} while (0);
 
 #define BE_ADAPTER_UP		0x00000000
 #define BE_ADAPTER_LINK_DOWN	0x00000001
@@ -352,6 +337,8 @@ struct beiscsi_hba {
 	struct mgmt_session_info boot_sess;
 	struct invalidate_command_table inv_tbl[128];
 
+	unsigned int attr_log_enable;
+
 };
 
 struct beiscsi_session {
@@ -861,4 +848,20 @@ struct hwi_context_memory {
 	struct hwi_async_pdu_context *pasync_ctx;
 };
 
+/* Logging related definitions */
+#define BEISCSI_LOG_INIT	0x0001	/* Initialization events */
+#define BEISCSI_LOG_MBOX	0x0002	/* Mailbox Events */
+#define BEISCSI_LOG_MISC	0x0004	/* Miscllaneous Events */
+#define BEISCSI_LOG_EH		0x0008	/* Error Handler */
+#define BEISCSI_LOG_IO		0x0010	/* IO Code Path */
+#define BEISCSI_LOG_CONFIG	0x0020	/* CONFIG Code Path */
+
+#define beiscsi_log(phba, level, mask, fmt, arg...) \
+do { \
+	uint32_t log_value = phba->attr_log_enable; \
+		if (((mask) & log_value) || (level[1] <= '3')) \
+			shost_printk(level, phba->shost, \
+				     fmt, __LINE__, ##arg); \
+} while (0)
+
 #endif
diff --git a/drivers/scsi/be2iscsi/be_mgmt.c b/drivers/scsi/be2iscsi/be_mgmt.c
index 203fff3..50a7372 100644
--- a/drivers/scsi/be2iscsi/be_mgmt.c
+++ b/drivers/scsi/be2iscsi/be_mgmt.c
@@ -42,7 +42,10 @@ unsigned int mgmt_reopen_session(struct beiscsi_hba *phba,
 	struct be_cmd_reopen_session_req *req;
 	unsigned int tag = 0;
 
-	SE_DEBUG(DBG_LVL_8, "In bescsi_get_boot_target\n");
+	beiscsi_log(phba, KERN_INFO,
+		    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+		    "BG_%d : In bescsi_get_boot_target\n");
+
 	spin_lock(&ctrl->mbox_lock);
 	tag = alloc_mcc_tag(phba);
 	if (!tag) {
@@ -74,7 +77,10 @@ unsigned int mgmt_get_boot_target(struct beiscsi_hba *phba)
 	struct be_cmd_get_boot_target_req *req;
 	unsigned int tag = 0;
 
-	SE_DEBUG(DBG_LVL_8, "In bescsi_get_boot_target\n");
+	beiscsi_log(phba, KERN_INFO,
+		    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+		    "BG_%d : In bescsi_get_boot_target\n");
+
 	spin_lock(&ctrl->mbox_lock);
 	tag = alloc_mcc_tag(phba);
 	if (!tag) {
@@ -106,7 +112,10 @@ unsigned int mgmt_get_session_info(struct beiscsi_hba *phba,
 	struct be_cmd_get_session_resp *resp;
 	struct be_sge *sge;
 
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_get_session_info\n");
+	beiscsi_log(phba, KERN_INFO,
+		    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+		    "BG_%d : In beiscsi_get_session_info\n");
+
 	spin_lock(&ctrl->mbox_lock);
 	tag = alloc_mcc_tag(phba);
 	if (!tag) {
@@ -165,16 +174,16 @@ int mgmt_get_fw_config(struct be_ctrl_info *ctrl,
 		phba->fw_config.iscsi_cid_count =
 					pfw_cfg->ulp[0].sq_count;
 		if (phba->fw_config.iscsi_cid_count > (BE2_MAX_SESSIONS / 2)) {
-			SE_DEBUG(DBG_LVL_8,
-				"FW reported MAX CXNS as %d\t"
-				"Max Supported = %d.\n",
-				phba->fw_config.iscsi_cid_count,
-				BE2_MAX_SESSIONS);
+			beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+				    "BG_%d : FW reported MAX CXNS as %d\t"
+				    "Max Supported = %d.\n",
+				    phba->fw_config.iscsi_cid_count,
+				    BE2_MAX_SESSIONS);
 			phba->fw_config.iscsi_cid_count = BE2_MAX_SESSIONS / 2;
 		}
 	} else {
-		shost_printk(KERN_WARNING, phba->shost,
-			     "Failed in mgmt_get_fw_config\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+			    "BG_%d : Failed in mgmt_get_fw_config\n");
 	}
 
 	spin_unlock(&ctrl->mbox_lock);
@@ -194,9 +203,9 @@ int mgmt_check_supported_fw(struct be_ctrl_info *ctrl,
 				sizeof(struct be_mgmt_controller_attributes),
 				&nonemb_cmd.dma);
 	if (nonemb_cmd.va == NULL) {
-		SE_DEBUG(DBG_LVL_1,
-			 "Failed to allocate memory for mgmt_check_supported_fw"
-			 "\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BG_%d : Failed to allocate memory for "
+			    "mgmt_check_supported_fw\n");
 		return -ENOMEM;
 	}
 	nonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);
@@ -213,18 +222,23 @@ int mgmt_check_supported_fw(struct be_ctrl_info *ctrl,
 	status = be_mbox_notify(ctrl);
 	if (!status) {
 		struct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;
-		SE_DEBUG(DBG_LVL_8, "Firmware version of CMD: %s\n",
-			resp->params.hba_attribs.flashrom_version_string);
-		SE_DEBUG(DBG_LVL_8, "Firmware version is : %s\n",
-			resp->params.hba_attribs.firmware_version_string);
-		SE_DEBUG(DBG_LVL_8,
-			"Developer Build, not performing version check...\n");
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BG_%d : Firmware Version of CMD : %s\n"
+			    "Firmware Version is : %s\n"
+			    "Developer Build, not performing version check...\n",
+			    resp->params.hba_attribs
+			    .flashrom_version_string,
+			    resp->params.hba_attribs.
+			    firmware_version_string);
+
 		phba->fw_config.iscsi_features =
 				resp->params.hba_attribs.iscsi_features;
-		SE_DEBUG(DBG_LVL_8, " phba->fw_config.iscsi_features = %d\n",
-				      phba->fw_config.iscsi_features);
+		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+			    "BM_%d : phba->fw_config.iscsi_features = %d\n",
+			    phba->fw_config.iscsi_features);
 	} else
-		SE_DEBUG(DBG_LVL_1, " Failed in mgmt_check_supported_fw\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+			    "BG_%d :  Failed in mgmt_check_supported_fw\n");
 	spin_unlock(&ctrl->mbox_lock);
 	if (nonemb_cmd.va)
 		pci_free_consistent(ctrl->pdev, nonemb_cmd.size,
@@ -273,9 +287,10 @@ unsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl,
 			   OPCODE_COMMON_READ_FLASH, sizeof(*req));
 		break;
 	default:
-		shost_printk(KERN_WARNING, phba->shost,
-			     "Unsupported cmd = 0x%x\n\n", bsg_req->rqst_data.
-			     h_vendor.vendor_cmd[0]);
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
+			    "BG_%d : Unsupported cmd = 0x%x\n\n",
+			    bsg_req->rqst_data.h_vendor.vendor_cmd[0]);
+
 		spin_unlock(&ctrl->mbox_lock);
 		return -ENOSYS;
 	}
@@ -319,8 +334,8 @@ int mgmt_epfw_cleanup(struct beiscsi_hba *phba, unsigned short chute)
 
 	status =  be_mcc_notify_wait(phba);
 	if (status)
-		shost_printk(KERN_WARNING, phba->shost,
-			     " mgmt_epfw_cleanup , FAILED\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+			    "BG_%d : mgmt_epfw_cleanup , FAILED\n");
 	spin_unlock(&ctrl->mbox_lock);
 	return status;
 }
@@ -503,8 +518,9 @@ int mgmt_open_connection(struct beiscsi_hba *phba,
 		       &daddr_in6->sin6_addr.in6_u.u6_addr8, 16);
 		beiscsi_ep->ip_type = BE2_IPV6;
 	} else{
-		shost_printk(KERN_ERR, phba->shost, "unknown addr family %d\n",
-			     dst_addr->sa_family);
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BG_%d : unknown addr family %d\n",
+			    dst_addr->sa_family);
 		spin_unlock(&ctrl->mbox_lock);
 		free_mcc_tag(&phba->ctrl, tag);
 		return -EINVAL;
@@ -515,7 +531,8 @@ int mgmt_open_connection(struct beiscsi_hba *phba,
 	if (phba->nxt_cqid == phba->num_cpus)
 		phba->nxt_cqid = 0;
 	req->cq_id = phwi_context->be_cq[i].id;
-	SE_DEBUG(DBG_LVL_8, "i=%d cq_id=%d\n", i, req->cq_id);
+	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+		    "BG_%d : i=%d cq_id=%d\n", i, req->cq_id);
 	req->defq_id = def_hdr_id;
 	req->hdr_ring_id = def_hdr_id;
 	req->data_ring_id = def_data_id;
@@ -550,8 +567,8 @@ unsigned int mgmt_get_all_if_id(struct beiscsi_hba *phba)
 	if (!status)
 		phba->interface_handle = pbe_allid->if_hndl_list[0];
 	else {
-		shost_printk(KERN_WARNING, phba->shost,
-			     "Failed in mgmt_get_all_if_id\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
+			    "BG_%d : Failed in mgmt_get_all_if_id\n");
 	}
 	spin_unlock(&ctrl->mbox_lock);
 
@@ -594,9 +611,10 @@ static int mgmt_exec_nonemb_cmd(struct beiscsi_hba *phba,
 	extd_status = (phba->ctrl.mcc_numtag[tag] & 0x0000FF00) >> 8;
 	status = phba->ctrl.mcc_numtag[tag] & 0x000000FF;
 	if (status || extd_status) {
-		SE_DEBUG(DBG_LVL_1,
-			 "mgmt_exec_nonemb_cmd Failed status = %d"
-			 "extd_status = %d\n", status, extd_status);
+		beiscsi_log(phba, KERN_ERR,
+			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+			    "BG_%d : mgmt_exec_nonemb_cmd Failed status = %d"
+			    "extd_status = %d\n", status, extd_status);
 		rc = -EIO;
 		goto free_tag;
 	}
@@ -617,7 +635,8 @@ static int mgmt_alloc_cmd_data(struct beiscsi_hba *phba, struct be_dma_mem *cmd,
 {
 	cmd->va = pci_alloc_consistent(phba->ctrl.pdev, size, &cmd->dma);
 	if (!cmd->va) {
-		SE_DEBUG(DBG_LVL_1, "Failed to allocate memory for if info\n");
+		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
+			    "BG_%d : Failed to allocate memory for if info\n");
 		return -ENOMEM;
 	}
 	memset(cmd->va, 0, size);
@@ -673,8 +692,8 @@ mgmt_static_ip_modify(struct beiscsi_hba *phba,
 
 	rc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);
 	if (rc < 0)
-		shost_printk(KERN_WARNING, phba->shost,
-			     "Failed to Modify existing IP Address\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
+			    "BG_%d : Failed to Modify existing IP Address\n");
 	return rc;
 }
 
@@ -728,8 +747,8 @@ int mgmt_set_ip(struct beiscsi_hba *phba,
 
 	if (boot_proto == ISCSI_BOOTPROTO_DHCP) {
 		if (if_info.dhcp_state) {
-			shost_printk(KERN_WARNING, phba->shost,
-				     "DHCP Already Enabled\n");
+			beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
+				    "BG_%d : DHCP Already Enabled\n");
 			return 0;
 		}
 		/* The ip_param->len is 1 in DHCP case. Setting
@@ -756,8 +775,9 @@ int mgmt_set_ip(struct beiscsi_hba *phba,
 
 			rc = mgmt_exec_nonemb_cmd(phba, &nonemb_cmd, NULL, 0);
 			if (rc < 0) {
-				shost_printk(KERN_WARNING, phba->shost,
-					     "Failed to Delete existing dhcp\n");
+				beiscsi_log(phba, KERN_WARNING,
+					    BEISCSI_LOG_CONFIG,
+					    "BG_%d : Failed to Delete existing dhcp\n");
 				return rc;
 			}
 		}
@@ -776,8 +796,8 @@ int mgmt_set_ip(struct beiscsi_hba *phba,
 		memset(&gtway_addr_set, 0, sizeof(gtway_addr_set));
 		rc = mgmt_get_gateway(phba, BE2_IPV4, &gtway_addr_set);
 		if (rc) {
-			shost_printk(KERN_WARNING, phba->shost,
-				     "Failed to Get Gateway Addr\n");
+			beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
+				    "BG_%d : Failed to Get Gateway Addr\n");
 			return rc;
 		}
 
@@ -787,8 +807,9 @@ int mgmt_set_ip(struct beiscsi_hba *phba,
 						 IP_ACTION_DEL, IP_V4_LEN);
 
 			if (rc) {
-				shost_printk(KERN_WARNING, phba->shost,
-					     "Failed to clear Gateway Addr Set\n");
+				beiscsi_log(phba, KERN_WARNING,
+					    BEISCSI_LOG_CONFIG,
+					    "BG_%d : Failed to clear Gateway Addr Set\n");
 				return rc;
 			}
 		}
@@ -827,8 +848,8 @@ int mgmt_set_gateway(struct beiscsi_hba *phba,
 	memset(&gtway_addr_set, 0, sizeof(gtway_addr_set));
 	rt_val = mgmt_get_gateway(phba, BE2_IPV4, &gtway_addr_set);
 	if (rt_val) {
-		shost_printk(KERN_WARNING, phba->shost,
-			     "Failed to Get Gateway Addr\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
+			    "BG_%d : Failed to Get Gateway Addr\n");
 		return rt_val;
 	}
 
@@ -837,8 +858,8 @@ int mgmt_set_gateway(struct beiscsi_hba *phba,
 		rt_val = mgmt_modify_gateway(phba, gtway_addr, IP_ACTION_DEL,
 					     gateway_param->len);
 		if (rt_val) {
-			shost_printk(KERN_WARNING, phba->shost,
-				     "Failed to clear Gateway Addr Set\n");
+			beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
+				    "BG_%d : Failed to clear Gateway Addr Set\n");
 			return rt_val;
 		}
 	}
@@ -848,8 +869,8 @@ int mgmt_set_gateway(struct beiscsi_hba *phba,
 				     gateway_param->len);
 
 	if (rt_val)
-		shost_printk(KERN_WARNING, phba->shost,
-			     "Failed to Set Gateway Addr\n");
+		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
+			    "BG_%d : Failed to Set Gateway Addr\n");
 
 	return rt_val;
 }
@@ -970,7 +991,9 @@ int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba,
 		/* Get the Boot Target Session Handle and Count*/
 		tag = mgmt_get_boot_target(phba);
 		if (!tag) {
-			SE_DEBUG(DBG_LVL_1, "mgmt_get_boot_target Failed\n");
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,
+				    "BG_%d : Getting Boot Target Info Failed\n");
 			return -EAGAIN;
 		} else
 			wait_event_interruptible(phba->ctrl.mcc_wait[tag],
@@ -980,9 +1003,11 @@ int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba,
 		extd_status = (phba->ctrl.mcc_numtag[tag] & 0x0000FF00) >> 8;
 		status = phba->ctrl.mcc_numtag[tag] & 0x000000FF;
 		if (status || extd_status) {
-			SE_DEBUG(DBG_LVL_1, "mgmt_get_boot_target Failed"
-					    " status = %d extd_status = %d\n",
-					    status, extd_status);
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
+				    "BG_%d : mgmt_get_boot_target Failed"
+				    " status = %d extd_status = %d\n",
+				    status, extd_status);
 			free_mcc_tag(&phba->ctrl, tag);
 			return -EBUSY;
 		}
@@ -992,7 +1017,9 @@ int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba,
 
 		/* Check if the there are any Boot targets configured */
 		if (!boot_resp->boot_session_count) {
-			SE_DEBUG(DBG_LVL_8, "No boot targets configured\n");
+			beiscsi_log(phba, KERN_INFO,
+				    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
+				    "BG_%d  ;No boot targets configured\n");
 			return -ENXIO;
 		}
 
@@ -1006,7 +1033,9 @@ int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba,
 		tag = mgmt_reopen_session(phba, BE_REOPEN_BOOT_SESSIONS,
 					  INVALID_SESS_HANDLE);
 		if (!tag) {
-			SE_DEBUG(DBG_LVL_1, "mgmt_reopen_session Failed\n");
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
+				    "BG_%d : mgmt_reopen_session Failed\n");
 			return -EAGAIN;
 		} else
 			wait_event_interruptible(phba->ctrl.mcc_wait[tag],
@@ -1016,9 +1045,11 @@ int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba,
 		extd_status = (phba->ctrl.mcc_numtag[tag] & 0x0000FF00) >> 8;
 		status = phba->ctrl.mcc_numtag[tag] & 0x000000FF;
 		if (status || extd_status) {
-			SE_DEBUG(DBG_LVL_1, "mgmt_reopen_session Failed"
-					    " status = %d extd_status = %d\n",
-					    status, extd_status);
+			beiscsi_log(phba, KERN_ERR,
+				    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
+				    "BG_%d : mgmt_reopen_session Failed"
+				    " status = %d extd_status = %d\n",
+				    status, extd_status);
 			free_mcc_tag(&phba->ctrl, tag);
 			return -EBUSY;
 		}
@@ -1027,6 +1058,8 @@ int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba,
 	} while (--boot_retry);
 
 	/* Couldn't log into the boot target */
-	SE_DEBUG(DBG_LVL_1, "Login to Boot Target Failed\n");
+	beiscsi_log(phba, KERN_ERR,
+		    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,
+		    "BG_%d : Login to Boot Target Failed\n");
 	return -ENXIO;
 }
-- 
1.7.2




