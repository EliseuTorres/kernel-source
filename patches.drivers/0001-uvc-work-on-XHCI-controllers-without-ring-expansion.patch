From 63a5ee9685caed7ba6152ded0e6c41728e3a5408 Mon Sep 17 00:00:00 2001
From: Oliver Neukum <oneukum@suse.de>
Date: Wed, 25 Feb 2015 14:42:31 +0100
Subject: [PATCH] uvc: work on XHCI controllers without ring expansion
References: bnc#915045
Git-Commit: 63a5ee9685caed7ba6152ded0e6c41728e3a5408
Patch-Mainline: Never (rendered moot by feature not in SLE11SP3)

Without ring expansion the space on the XHCI control rings
is limited. The amount of buffers uvc uses must be limited
and additional buffers only used on hardware that really needs
it.

Signed-off-by: Oliver Neukum <oneukum@suse.de>
---
 drivers/media/video/uvc/uvc_v4l2.c  | 19 ++++++++++++++++++-
 drivers/media/video/uvc/uvc_video.c | 16 ++++++++++++++--
 2 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/drivers/media/video/uvc/uvc_v4l2.c b/drivers/media/video/uvc/uvc_v4l2.c
index 5afdbb7..e582381 100644
--- a/drivers/media/video/uvc/uvc_v4l2.c
+++ b/drivers/media/video/uvc/uvc_v4l2.c
@@ -561,6 +561,20 @@ static void uvc_v4l2_ioctl_warn(void)
 	warned = 1;
 }
 
+static int uvc_max_buffers(struct uvc_streaming *stream)
+{
+	int vid, pid;
+
+	vid = stream->dev->udev->descriptor.idVendor;
+	pid = stream->dev->udev->descriptor.idProduct;
+
+	if (vid == 0x04ca && pid == 0x7024)
+		return UVC_MAX_VIDEO_BUFFERS;
+	if (vid == 0x05c8 && pid == 0x035d)
+		return UVC_MAX_VIDEO_BUFFERS;
+	return UVC_MAX_VIDEO_BUFFERS / 4;
+}
+
 static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 {
 	struct video_device *vdev = video_devdata(file);
@@ -946,6 +960,7 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 	case VIDIOC_REQBUFS:
 	{
 		struct v4l2_requestbuffers *rb = arg;
+		int bc, rbc;
 
 		if (rb->type != stream->type ||
 		    rb->memory != V4L2_MEMORY_MMAP)
@@ -955,7 +970,9 @@ static long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)
 			return ret;
 
 		mutex_lock(&stream->mutex);
-		ret = uvc_alloc_buffers(&stream->queue, rb->count,
+		bc = uvc_max_buffers(stream);
+		rbc = rb->count;
+		ret = uvc_alloc_buffers(&stream->queue, min(bc, rbc),
 					stream->ctrl.dwMaxVideoFrameSize);
 		mutex_unlock(&stream->mutex);
 		if (ret < 0)
diff --git a/drivers/media/video/uvc/uvc_video.c b/drivers/media/video/uvc/uvc_video.c
index 6f147de..cadaeeb 100644
--- a/drivers/media/video/uvc/uvc_video.c
+++ b/drivers/media/video/uvc/uvc_video.c
@@ -799,6 +799,16 @@ static void uvc_free_urb_buffers(struct uvc_streaming *stream)
 	stream->urb_size = 0;
 }
 
+static bool needs_more_packets(struct uvc_streaming *stream)
+{
+	int vid, pid;
+
+	vid = stream->dev->udev->descriptor.idVendor;
+	pid = stream->dev->udev->descriptor.idProduct;
+
+	return (vid == 0x04ca && pid == 0x7024) || (vid == 0x05c8 && pid == 0x035d);
+}
+
 /*
  * Allocate transfer buffers. This function can be called with buffers
  * already allocated when resuming from suspend, in which case it will
@@ -815,6 +825,7 @@ static int uvc_alloc_urb_buffers(struct uvc_streaming *stream,
 {
 	unsigned int npackets;
 	unsigned int i;
+	int mp;
 
 	/* Buffers are already allocated, bail out. */
 	if (stream->urb_size)
@@ -823,9 +834,10 @@ static int uvc_alloc_urb_buffers(struct uvc_streaming *stream,
 	/* Compute the number of packets. Bulk endpoints might transfer UVC
 	 * payloads across multiple URBs.
 	 */
+	mp = needs_more_packets(stream) ? UVC_MAX_PACKETS : UVC_MAX_PACKETS / 4;
 	npackets = DIV_ROUND_UP(size, psize);
-	if (npackets > UVC_MAX_PACKETS)
-		npackets = UVC_MAX_PACKETS;
+	if (npackets > mp)
+		npackets = mp;
 
 	/* Retry allocations until one succeed. */
 	for (; npackets > 1; npackets /= 2) {
-- 
1.8.4.5

