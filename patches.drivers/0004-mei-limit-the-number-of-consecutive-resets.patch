From 572b5d2b1557060578bca0a5e0921e3a019d9c0e Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Wed, 3 Dec 2014 17:18:45 +0200
Subject: [char-misc 04/11] mei: limit the number of consecutive resets
Git-commit: 6adb8efb024a7e413b93b22848fc13395b1a438a
Patch-mainline: 3.14-rc1
References: bnc#876086

commit 6adb8efb024a7e413b93b22848fc13395b1a438a upstream

give up reseting after 3 unsuccessful tries

[Backported to 3.7: files were moved]

Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/misc/mei/init.c      |    7 +++++++
 drivers/misc/mei/interrupt.c |    6 ++++--
 drivers/misc/mei/mei_dev.h   |    7 +++++++
 3 files changed, 18 insertions(+), 2 deletions(-)

--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -304,6 +304,13 @@ void mei_reset(struct mei_device *dev, i
 
 	dev->need_reset = false;
 
+	dev->reset_count++;
+	if (dev->reset_count > MEI_MAX_CONSEC_RESET) {
+		dev_err(&dev->pdev->dev, "reset: reached maximal consecutive resets: disabling the device\n");
+		dev->dev_state = MEI_DEV_DISABLED;
+		return;
+	}
+
 	if (dev->dev_state != MEI_DEV_INITIALIZING) {
 		if (dev->dev_state != MEI_DEV_DISABLED &&
 		    dev->dev_state != MEI_DEV_POWER_DOWN)
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -728,6 +728,7 @@ static void mei_irq_thread_read_bus_mess
 					 */
 					bitmap_set(dev->host_clients_map, 0, 3);
 					dev->dev_state = MEI_DEV_ENABLED;
+					dev->reset_count = 0;
 
 					/* if wd initialization fails, initialization the AMTHI client,
 					 * otherwise the AMTHI client will be initialized after the WD client connect response
@@ -1434,8 +1435,9 @@ void mei_timer(struct work_struct *work)
 		}
 	}
 out:
-	schedule_delayed_work(&dev->timer_work, 2 * HZ);
-	mutex_unlock(&dev->device_lock);
+	 if (dev->dev_state != MEI_DEV_DISABLED)
+		schedule_delayed_work(&dev->timer_work, 2 * HZ);
+	 mutex_unlock(&dev->device_lock);
 }
 
 /**
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -61,6 +61,11 @@ extern const u8 mei_wd_state_independenc
 #define MEI_CLIENTS_MAX 256
 
 /*
+ * maximum number of consecutive resets
+ */
+#define MEI_MAX_CONSEC_RESET  3
+
+/*
  * Number of File descriptors/handles
  * that can be opened to the driver.
  *
@@ -182,6 +187,7 @@ struct mei_io_list {
 /**
  * struct mei_deive -  MEI private device struct
  * @hbuf_depth - depth of host(write) buffer
+ * @reset_count - limits the number of consecutive resets
  */
 struct mei_device {
 	struct pci_dev *pdev;	/* pointer to pci device struct */
@@ -230,6 +236,7 @@ struct mei_device {
 	/*
 	 * mei device  states
 	 */
+	unsigned long reset_count;
 	enum mei_dev_state dev_state;
 	enum mei_init_clients_states init_clients_state;
 	u16 init_clients_timer;
