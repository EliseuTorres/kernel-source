From: Dan Williams <dan.j.williams@intel.com>
Date: Fri, 22 Apr 2011 19:18:03 -0700
Subject: [PATCH 112/273] isci: move remote_device handling out of the core
Git-commit: 88f3b62ac131e2549b6c262cacbd47e8cca42d6e
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Now that the core/lldd remote_device data structures are nominally unified
merge the corresponding sources into the top-level directory.  Also move the
remote_node_context infrastructure which has no analog at the lldd level.

Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/Makefile                         |    9 +-
 drivers/scsi/isci/core/scic_remote_device.h        |  282 ----
 drivers/scsi/isci/core/scic_sds_controller.c       |    3 +-
 drivers/scsi/isci/core/scic_sds_controller.h       |    2 +-
 drivers/scsi/isci/core/scic_sds_phy.c              |    2 +-
 drivers/scsi/isci/core/scic_sds_port.c             |    4 +-
 drivers/scsi/isci/core/scic_sds_remote_device.c    | 1664 --------------------
 drivers/scsi/isci/core/scic_sds_remote_device.h    |  694 --------
 .../scsi/isci/core/scic_sds_remote_node_context.c  | 1227 ---------------
 .../scsi/isci/core/scic_sds_remote_node_context.h  |  301 ----
 .../scsi/isci/core/scic_sds_remote_node_table.c    |  600 -------
 .../scsi/isci/core/scic_sds_remote_node_table.h    |  195 ---
 drivers/scsi/isci/core/scic_sds_request.c          |    3 +-
 .../scsi/isci/core/scic_sds_smp_remote_device.c    |  315 ----
 drivers/scsi/isci/core/scic_sds_smp_request.c      |    3 +-
 .../scsi/isci/core/scic_sds_stp_packet_request.c   |    3 +-
 .../scsi/isci/core/scic_sds_stp_remote_device.c    |  818 ----------
 drivers/scsi/isci/core/scic_sds_stp_request.c      |    3 +-
 drivers/scsi/isci/core/scu_remote_node_context.h   |  229 ---
 drivers/scsi/isci/host.c                           |    4 +-
 drivers/scsi/isci/host.h                           |    1 -
 drivers/scsi/isci/init.c                           |    1 -
 drivers/scsi/isci/port.c                           |    1 -
 drivers/scsi/isci/port.h                           |    1 +
 drivers/scsi/isci/probe_roms.c                     |    1 -
 drivers/scsi/isci/remote_device.c                  | 1636 ++++++++++++++++++-
 drivers/scsi/isci/remote_device.h                  |  742 +++++++++-
 drivers/scsi/isci/remote_node_context.c            | 1226 ++++++++++++++
 drivers/scsi/isci/remote_node_context.h            |  301 ++++
 drivers/scsi/isci/remote_node_table.c              |  600 +++++++
 drivers/scsi/isci/remote_node_table.h              |  195 +++
 drivers/scsi/isci/request.c                        |    1 -
 drivers/scsi/isci/sata.c                           |    3 +-
 drivers/scsi/isci/scu_remote_node_context.h        |  229 +++
 drivers/scsi/isci/smp_remote_device.c              |  314 ++++
 drivers/scsi/isci/stp_remote_device.c              |  817 ++++++++++
 drivers/scsi/isci/task.c                           |    5 +-
 37 files changed, 6001 insertions(+), 6434 deletions(-)
 delete mode 100644 drivers/scsi/isci/core/scic_remote_device.h
 delete mode 100644 drivers/scsi/isci/core/scic_sds_remote_device.c
 delete mode 100644 drivers/scsi/isci/core/scic_sds_remote_device.h
 delete mode 100644 drivers/scsi/isci/core/scic_sds_remote_node_context.c
 delete mode 100644 drivers/scsi/isci/core/scic_sds_remote_node_context.h
 delete mode 100644 drivers/scsi/isci/core/scic_sds_remote_node_table.c
 delete mode 100644 drivers/scsi/isci/core/scic_sds_remote_node_table.h
 delete mode 100644 drivers/scsi/isci/core/scic_sds_smp_remote_device.c
 delete mode 100644 drivers/scsi/isci/core/scic_sds_stp_remote_device.c
 delete mode 100644 drivers/scsi/isci/core/scu_remote_node_context.h
 create mode 100644 drivers/scsi/isci/remote_node_context.c
 create mode 100644 drivers/scsi/isci/remote_node_context.h
 create mode 100644 drivers/scsi/isci/remote_node_table.c
 create mode 100644 drivers/scsi/isci/remote_node_table.h
 create mode 100644 drivers/scsi/isci/scu_remote_node_context.h
 create mode 100644 drivers/scsi/isci/smp_remote_device.c
 create mode 100644 drivers/scsi/isci/stp_remote_device.c

diff --git a/drivers/scsi/isci/Makefile b/drivers/scsi/isci/Makefile
index 522e7a7..ccc8c53 100644
--- a/drivers/scsi/isci/Makefile
+++ b/drivers/scsi/isci/Makefile
@@ -10,20 +10,19 @@ obj-$(CONFIG_SCSI_ISCI) += isci.o
 isci-objs := init.o phy.o request.o sata.o \
 	     remote_device.o port.o timers.o \
 	     host.o task.o probe_roms.o \
+	     stp_remote_device.o \
+	     smp_remote_device.o \
+	     remote_node_context.o \
+	     remote_node_table.o \
 	     core/scic_sds_controller.o  \
-	     core/scic_sds_remote_device.o    \
 	     core/scic_sds_request.o \
 	     core/scic_sds_stp_request.o \
 	     core/scic_sds_stp_packet_request.o \
-	     core/scic_sds_stp_remote_device.o \
 	     core/scic_sds_port.o \
 	     core/scic_sds_port_configuration_agent.o \
 	     core/scic_sds_phy.o \
 	     core/scic_sds_ssp_request.o \
-	     core/scic_sds_remote_node_context.o \
 	     core/scic_sds_smp_request.o \
-	     core/scic_sds_smp_remote_device.o \
-	     core/scic_sds_remote_node_table.o \
 	     core/scic_sds_unsolicited_frame_control.o \
 	     core/sci_base_state_machine.o \
 	     core/sci_util.o
diff --git a/drivers/scsi/isci/core/scic_remote_device.h b/drivers/scsi/isci/core/scic_remote_device.h
deleted file mode 100644
index 23e90af..0000000
--- a/drivers/scsi/isci/core/scic_remote_device.h
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCIC_REMOTE_DEVICE_H_
-#define _SCIC_REMOTE_DEVICE_H_
-
-/**
- * This file contains all of the interface methods that can be called by an
- *    SCIC user on the device object.
- *
- *
- */
-
-
-#include "sci_status.h"
-#include "intel_sas.h"
-
-struct scic_sds_port;
-struct scic_sds_remote_device;
-
-/**
- *
- *
- *
- */
-enum scic_remote_device_not_ready_reason_code {
-	SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED,
-	SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED,
-	SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED,
-	SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED,
-	SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED,
-
-	SCIC_REMOTE_DEVICE_NOT_READY_REASON_CODE_MAX
-
-};
-
-/**
- * scic_remote_device_construct() - This method will perform the construction
- *    common to all remote device objects.
- * @sci_port: SAS/SATA port through which this device is accessed.
- * @sci_dev: remote device to construct
- *
- * It isn't necessary to call scic_remote_device_destruct() for device objects
- * that have only called this method for construction. Once subsequent
- * construction methods have been invoked (e.g.
- * scic_remote_device_da_construct()), then destruction should occur. none
- */
-void scic_remote_device_construct(struct scic_sds_port *sci_port,
-				  struct scic_sds_remote_device *sci_dev);
-
-/**
- * scic_remote_device_da_construct() - This method will construct a
- *    SCIC_REMOTE_DEVICE object for a direct attached (da) device.  The
- *    information (e.g. IAF, Signature FIS, etc.) necessary to build the device
- *    is known to the SCI Core since it is contained in the scic_phy object.
- * @remote_device: This parameter specifies the remote device to be destructed.
- *
- * The user must have previously called scic_remote_device_construct() Remote
- * device objects are a limited resource.  As such, they must be protected.
- * Thus calls to construct and destruct are mutually exclusive and
- * non-reentrant. Indicate if the remote device was successfully constructed.
- * SCI_SUCCESS Returned if the device was successfully constructed.
- * SCI_FAILURE_DEVICE_EXISTS Returned if the device has already been
- * constructed.  If it's an additional phy for the target, then call
- * scic_remote_device_da_add_phy(). SCI_FAILURE_UNSUPPORTED_PROTOCOL Returned
- * if the supplied parameters necessitate creation of a remote device for which
- * the protocol is not supported by the underlying controller hardware.
- * SCI_FAILURE_INSUFFICIENT_RESOURCES This value is returned if the core
- * controller associated with the supplied parameters is unable to support
- * additional remote devices.
- */
-enum sci_status scic_remote_device_da_construct(
-	struct scic_sds_remote_device *remote_device);
-
-/**
- * scic_remote_device_ea_construct() - This method will construct an
- *    SCIC_REMOTE_DEVICE object for an expander attached (ea) device from an
- *    SMP Discover Response.
- * @remote_device: This parameter specifies the remote device to be destructed.
- * @discover_response: This parameter specifies the SMP Discovery Response to
- *    be used in device creation.
- *
- * The user must have previously called scic_remote_device_construct() Remote
- * device objects are a limited resource.  As such, they must be protected.
- * Thus calls to construct and destruct are mutually exclusive and
- * non-reentrant. Indicate if the remote device was successfully constructed.
- * SCI_SUCCESS Returned if the device was successfully constructed.
- * SCI_FAILURE_DEVICE_EXISTS Returned if the device has already been
- * constructed.  If it's an additional phy for the target, then call
- * scic_ea_remote_device_add_phy(). SCI_FAILURE_UNSUPPORTED_PROTOCOL Returned
- * if the supplied parameters necessitate creation of a remote device for which
- * the protocol is not supported by the underlying controller hardware.
- * SCI_FAILURE_INSUFFICIENT_RESOURCES This value is returned if the core
- * controller associated with the supplied parameters is unable to support
- * additional remote devices.
- */
-enum sci_status scic_remote_device_ea_construct(
-	struct scic_sds_remote_device *remote_device,
-	struct smp_response_discover *discover_response);
-
-/**
- * scic_remote_device_destruct() - This method is utilized to free up a core's
- *    remote device object.
- * @remote_device: This parameter specifies the remote device to be destructed.
- *
- * Remote device objects are a limited resource.  As such, they must be
- * protected.  Thus calls to construct and destruct are mutually exclusive and
- * non-reentrant. The return value shall indicate if the device was
- * successfully destructed or if some failure occurred. enum sci_status This value
- * is returned if the device is successfully destructed.
- * SCI_FAILURE_INVALID_REMOTE_DEVICE This value is returned if the supplied
- * device isn't valid (e.g. it's already been destoryed, the handle isn't
- * valid, etc.).
- */
-enum sci_status scic_remote_device_destruct(
-	struct scic_sds_remote_device *remote_device);
-
-
-
-
-
-/**
- * scic_remote_device_start() - This method will start the supplied remote
- *    device.  This method enables normal IO requests to flow through to the
- *    remote device.
- * @remote_device: This parameter specifies the device to be started.
- * @timeout: This parameter specifies the number of milliseconds in which the
- *    start operation should complete.
- *
- * An indication of whether the device was successfully started. SCI_SUCCESS
- * This value is returned if the device was successfully started.
- * SCI_FAILURE_INVALID_PHY This value is returned if the user attempts to start
- * the device when there have been no phys added to it.
- */
-enum sci_status scic_remote_device_start(
-	struct scic_sds_remote_device *remote_device,
-	u32 timeout);
-
-/**
- * scic_remote_device_stop() - This method will stop both transmission and
- *    reception of link activity for the supplied remote device.  This method
- *    disables normal IO requests from flowing through to the remote device.
- * @remote_device: This parameter specifies the device to be stopped.
- * @timeout: This parameter specifies the number of milliseconds in which the
- *    stop operation should complete.
- *
- * An indication of whether the device was successfully stopped. SCI_SUCCESS
- * This value is returned if the transmission and reception for the device was
- * successfully stopped.
- */
-enum sci_status scic_remote_device_stop(
-	struct scic_sds_remote_device *remote_device,
-	u32 timeout);
-
-/**
- * scic_remote_device_reset() - This method will reset the device making it
- *    ready for operation. This method must be called anytime the device is
- *    reset either through a SMP phy control or a port hard reset request.
- * @remote_device: This parameter specifies the device to be reset.
- *
- * This method does not actually cause the device hardware to be reset. This
- * method resets the software object so that it will be operational after a
- * device hardware reset completes. An indication of whether the device reset
- * was accepted. SCI_SUCCESS This value is returned if the device reset is
- * started.
- */
-enum sci_status scic_remote_device_reset(
-	struct scic_sds_remote_device *remote_device);
-
-/**
- * scic_remote_device_reset_complete() - This method informs the device object
- *    that the reset operation is complete and the device can resume operation
- *    again.
- * @remote_device: This parameter specifies the device which is to be informed
- *    of the reset complete operation.
- *
- * An indication that the device is resuming operation. SCI_SUCCESS the device
- * is resuming operation.
- */
-enum sci_status scic_remote_device_reset_complete(
-	struct scic_sds_remote_device *remote_device);
-
-
-
-/**
- * scic_remote_device_get_connection_rate() - This method simply returns the
- *    link rate at which communications to the remote device occur.
- * @remote_device: This parameter specifies the device for which to get the
- *    connection rate.
- *
- * Return the link rate at which we transfer for the supplied remote device.
- */
-enum sas_linkrate scic_remote_device_get_connection_rate(
-	struct scic_sds_remote_device *remote_device);
-
-/**
- * scic_remote_device_get_protocols() - This method will indicate which
- *    protocols are supported by this remote device.
- * @remote_device: This parameter specifies the device for which to return the
- *    protocol.
- * @protocols: This parameter specifies the output values, from the remote
- *    device object, which indicate the protocols supported by the supplied
- *    remote_device.
- *
- * The type of protocols supported by this device.  The values are returned as
- * part of a bit mask in order to allow for multi-protocol support.
- */
-void scic_remote_device_get_protocols(
-	struct scic_sds_remote_device *remote_device,
-	struct smp_discover_response_protocols *protocols);
-
-
-#if !defined(DISABLE_ATAPI)
-/**
- * scic_remote_device_is_atapi() -
- * @this_device: The device whose type is to be decided.
- *
- * This method first decide whether a device is a stp target, then decode the
- * signature fis of a DA STP device to tell whether it is a standard end disk
- * or an ATAPI device. bool Indicate a device is ATAPI device or not.
- */
-bool scic_remote_device_is_atapi(
-	struct scic_sds_remote_device *device_handle);
-#else /* !defined(DISABLE_ATAPI) */
-#define scic_remote_device_is_atapi(device_handle) false
-#endif /* !defined(DISABLE_ATAPI) */
-
-
-#endif  /* _SCIC_REMOTE_DEVICE_H_ */
-
diff --git a/drivers/scsi/isci/core/scic_sds_controller.c b/drivers/scsi/isci/core/scic_sds_controller.c
index 63f4cd1..c684d9e 100644
--- a/drivers/scsi/isci/core/scic_sds_controller.c
+++ b/drivers/scsi/isci/core/scic_sds_controller.c
@@ -57,13 +57,12 @@
 #include "scic_controller.h"
 #include "scic_phy.h"
 #include "scic_port.h"
-#include "scic_remote_device.h"
 #include "scic_sds_controller.h"
 #include "scu_registers.h"
 #include "scic_sds_phy.h"
 #include "scic_sds_port_configuration_agent.h"
 #include "scic_sds_port.h"
-#include "scic_sds_remote_device.h"
+#include "remote_device.h"
 #include "scic_sds_request.h"
 #include "sci_environment.h"
 #include "sci_util.h"
diff --git a/drivers/scsi/isci/core/scic_sds_controller.h b/drivers/scsi/isci/core/scic_sds_controller.h
index 4bb9a43..e15c4e2 100644
--- a/drivers/scsi/isci/core/scic_sds_controller.h
+++ b/drivers/scsi/isci/core/scic_sds_controller.h
@@ -73,7 +73,7 @@
 #include "scic_config_parameters.h"
 #include "scic_sds_port.h"
 #include "scic_sds_phy.h"
-#include "scic_sds_remote_node_table.h"
+#include "remote_node_table.h"
 #include "scu_registers.h"
 #include "scu_constants.h"
 #include "scu_remote_node_context.h"
diff --git a/drivers/scsi/isci/core/scic_sds_phy.c b/drivers/scsi/isci/core/scic_sds_phy.c
index 34bd3b2..0901846 100644
--- a/drivers/scsi/isci/core/scic_sds_phy.c
+++ b/drivers/scsi/isci/core/scic_sds_phy.c
@@ -61,7 +61,7 @@
 #include "scic_sds_controller.h"
 #include "scic_sds_phy.h"
 #include "scic_sds_port.h"
-#include "scic_sds_remote_node_context.h"
+#include "remote_node_context.h"
 #include "sci_environment.h"
 #include "sci_util.h"
 #include "scu_event_codes.h"
diff --git a/drivers/scsi/isci/core/scic_sds_port.c b/drivers/scsi/isci/core/scic_sds_port.c
index a8d7e51..b07e48e 100644
--- a/drivers/scsi/isci/core/scic_sds_port.c
+++ b/drivers/scsi/isci/core/scic_sds_port.c
@@ -60,8 +60,8 @@
 #include "scic_sds_controller.h"
 #include "scic_sds_phy.h"
 #include "scic_sds_port.h"
-#include "scic_sds_remote_device.h"
-#include "scic_sds_remote_node_context.h"
+#include "remote_device.h"
+#include "remote_node_context.h"
 #include "scic_sds_request.h"
 #include "sci_environment.h"
 #include "scu_registers.h"
diff --git a/drivers/scsi/isci/core/scic_sds_remote_device.c b/drivers/scsi/isci/core/scic_sds_remote_device.c
deleted file mode 100644
index d314e2b..0000000
--- a/drivers/scsi/isci/core/scic_sds_remote_device.c
+++ /dev/null
@@ -1,1664 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "intel_sas.h"
-#include "scic_controller.h"
-#include "scic_phy.h"
-#include "scic_port.h"
-#include "scic_remote_device.h"
-#include "scic_sds_controller.h"
-#include "scic_sds_phy.h"
-#include "scic_sds_port.h"
-#include "scic_sds_remote_device.h"
-#include "scic_sds_remote_node_context.h"
-#include "scic_sds_request.h"
-#include "sci_environment.h"
-#include "sci_util.h"
-#include "scu_event_codes.h"
-
-
-#define SCIC_SDS_REMOTE_DEVICE_RESET_TIMEOUT  (1000)
-
-enum sci_status scic_remote_device_da_construct(
-	struct scic_sds_remote_device *sci_dev)
-{
-	enum sci_status status;
-	u16 remote_node_index;
-	struct sci_sas_identify_address_frame_protocols protocols;
-
-	/*
-	 * This information is request to determine how many remote node context
-	 * entries will be needed to store the remote node.
-	 */
-	scic_sds_port_get_attached_protocols(sci_dev->owning_port, &protocols);
-	sci_dev->target_protocols.u.all = protocols.u.all;
-	sci_dev->is_direct_attached = true;
-#if !defined(DISABLE_ATAPI)
-	sci_dev->is_atapi = scic_sds_remote_device_is_atapi(sci_dev);
-#endif
-
-	status = scic_sds_controller_allocate_remote_node_context(
-		sci_dev->owning_port->owning_controller,
-		sci_dev,
-		&remote_node_index);
-
-	if (status == SCI_SUCCESS) {
-		sci_dev->rnc.remote_node_index = remote_node_index;
-
-		scic_sds_port_get_attached_sas_address(
-			sci_dev->owning_port, &sci_dev->device_address);
-
-		if (sci_dev->target_protocols.u.bits.attached_ssp_target) {
-			sci_dev->has_ready_substate_machine = false;
-		} else if (sci_dev->target_protocols.u.bits.attached_stp_target) {
-			sci_dev->has_ready_substate_machine = true;
-
-			sci_base_state_machine_construct(
-				&sci_dev->ready_substate_machine,
-				&sci_dev->parent,
-				scic_sds_stp_remote_device_ready_substate_table,
-				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-		} else if (sci_dev->target_protocols.u.bits.attached_smp_target) {
-			sci_dev->has_ready_substate_machine = true;
-
-			/* add the SMP ready substate machine construction here */
-			sci_base_state_machine_construct(
-				&sci_dev->ready_substate_machine,
-				&sci_dev->parent,
-				scic_sds_smp_remote_device_ready_substate_table,
-				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-		}
-
-		sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(
-			sci_dev->owning_port);
-
-		/* / @todo Should I assign the port width by reading all of the phys on the port? */
-		sci_dev->device_port_width = 1;
-	}
-
-	return status;
-}
-
-
-static void scic_sds_remote_device_get_info_from_smp_discover_response(
-	struct scic_sds_remote_device *sci_dev,
-	struct smp_response_discover *discover_response)
-{
-	/* decode discover_response to set sas_address to sci_dev. */
-	sci_dev->device_address.high =
-		discover_response->attached_sas_address.high;
-
-	sci_dev->device_address.low =
-		discover_response->attached_sas_address.low;
-
-	sci_dev->target_protocols.u.all = discover_response->protocols.u.all;
-}
-
-
-enum sci_status scic_remote_device_ea_construct(
-	struct scic_sds_remote_device *sci_dev,
-	struct smp_response_discover *discover_response)
-{
-	enum sci_status status;
-	struct scic_sds_controller *scic;
-
-	scic = scic_sds_port_get_controller(sci_dev->owning_port);
-
-	scic_sds_remote_device_get_info_from_smp_discover_response(
-		sci_dev, discover_response);
-
-	status = scic_sds_controller_allocate_remote_node_context(
-		scic, sci_dev, &sci_dev->rnc.remote_node_index);
-
-	if (status == SCI_SUCCESS) {
-		if (sci_dev->target_protocols.u.bits.attached_ssp_target) {
-			sci_dev->has_ready_substate_machine = false;
-		} else if (sci_dev->target_protocols.u.bits.attached_smp_target) {
-			sci_dev->has_ready_substate_machine = true;
-
-			/* add the SMP ready substate machine construction here */
-			sci_base_state_machine_construct(
-				&sci_dev->ready_substate_machine,
-				&sci_dev->parent,
-				scic_sds_smp_remote_device_ready_substate_table,
-				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-		} else if (sci_dev->target_protocols.u.bits.attached_stp_target) {
-			sci_dev->has_ready_substate_machine = true;
-
-			sci_base_state_machine_construct(
-				&sci_dev->ready_substate_machine,
-				&sci_dev->parent,
-				scic_sds_stp_remote_device_ready_substate_table,
-				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-		}
-
-		/*
-		 * For SAS-2 the physical link rate is actually a logical link
-		 * rate that incorporates multiplexing.  The SCU doesn't
-		 * incorporate multiplexing and for the purposes of the
-		 * connection the logical link rate is that same as the
-		 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
-		 * one another, so this code works for both situations. */
-		sci_dev->connection_rate = min_t(u16,
-			scic_sds_port_get_max_allowed_speed(sci_dev->owning_port),
-			discover_response->u2.sas1_1.negotiated_physical_link_rate
-			);
-
-		/* / @todo Should I assign the port width by reading all of the phys on the port? */
-		sci_dev->device_port_width = 1;
-	}
-
-	return status;
-}
-
-enum sci_status scic_remote_device_destruct(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return sci_dev->state_handlers->destruct_handler(sci_dev);
-}
-
-
-enum sci_status scic_remote_device_start(
-	struct scic_sds_remote_device *sci_dev,
-	u32 timeout)
-{
-	return sci_dev->state_handlers->start_handler(sci_dev);
-}
-
-
-enum sci_status scic_remote_device_stop(
-	struct scic_sds_remote_device *sci_dev,
-	u32 timeout)
-{
-	return sci_dev->state_handlers->stop_handler(sci_dev);
-}
-
-
-enum sci_status scic_remote_device_reset(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return sci_dev->state_handlers->reset_handler(sci_dev);
-}
-
-
-enum sci_status scic_remote_device_reset_complete(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return sci_dev->state_handlers->reset_complete_handler(sci_dev);
-}
-
-
-enum sas_linkrate scic_remote_device_get_connection_rate(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return sci_dev->connection_rate;
-}
-
-
-void scic_remote_device_get_protocols(
-	struct scic_sds_remote_device *sci_dev,
-	struct smp_discover_response_protocols *pr)
-{
-	pr->u.all = sci_dev->target_protocols.u.all;
-}
-
-#if !defined(DISABLE_ATAPI)
-bool scic_remote_device_is_atapi(struct scic_sds_remote_device *sci_dev)
-{
-	return sci_dev->is_atapi;
-}
-#endif
-
-
-/*
- * *****************************************************************************
- * *  SCU DRIVER STANDARD (SDS) REMOTE DEVICE IMPLEMENTATIONS
- * ***************************************************************************** */
-
-/**
- *
- *
- * Remote device timer requirements
- */
-#define SCIC_SDS_REMOTE_DEVICE_MINIMUM_TIMER_COUNT (0)
-#define SCIC_SDS_REMOTE_DEVICE_MAXIMUM_TIMER_COUNT (SCI_MAX_REMOTE_DEVICES)
-
-
-/**
- *
- * @sci_dev: The remote device for which the suspend is being requested.
- *
- * This method invokes the remote device suspend state handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_suspend(
-	struct scic_sds_remote_device *sci_dev,
-	u32 suspend_type)
-{
-	return sci_dev->state_handlers->suspend_handler(sci_dev, suspend_type);
-}
-
-/**
- *
- * @sci_dev: The remote device for which the resume is being requested.
- *
- * This method invokes the remote device resume state handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_resume(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return sci_dev->state_handlers->resume_handler(sci_dev);
-}
-
-/**
- *
- * @sci_dev: The remote device for which the event handling is being
- *    requested.
- * @frame_index: This is the frame index that is being processed.
- *
- * This method invokes the frame handler for the remote device state machine
- * enum sci_status
- */
-enum sci_status scic_sds_remote_device_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
-{
-	return sci_dev->state_handlers->frame_handler(sci_dev, frame_index);
-}
-
-/**
- *
- * @sci_dev: The remote device for which the event handling is being
- *    requested.
- * @event_code: This is the event code that is to be processed.
- *
- * This method invokes the remote device event handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code)
-{
-	return sci_dev->state_handlers->event_handler(sci_dev, event_code);
-}
-
-/**
- *
- * @controller: The controller that is starting the io request.
- * @sci_dev: The remote device for which the start io handling is being
- *    requested.
- * @io_request: The io request that is being started.
- *
- * This method invokes the remote device start io handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_start_io(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *io_request)
-{
-	return sci_dev->state_handlers->start_io_handler(
-		       sci_dev, io_request);
-}
-
-/**
- *
- * @controller: The controller that is completing the io request.
- * @sci_dev: The remote device for which the complete io handling is being
- *    requested.
- * @io_request: The io request that is being completed.
- *
- * This method invokes the remote device complete io handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_complete_io(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *io_request)
-{
-	return sci_dev->state_handlers->complete_io_handler(
-		       sci_dev, io_request);
-}
-
-/**
- *
- * @controller: The controller that is starting the task request.
- * @sci_dev: The remote device for which the start task handling is being
- *    requested.
- * @io_request: The task request that is being started.
- *
- * This method invokes the remote device start task handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_start_task(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *io_request)
-{
-	return sci_dev->state_handlers->start_task_handler(
-		       sci_dev, io_request);
-}
-
-/**
- *
- * @controller: The controller that is completing the task request.
- * @sci_dev: The remote device for which the complete task handling is
- *    being requested.
- * @io_request: The task request that is being completed.
- *
- * This method invokes the remote device complete task handler. enum sci_status
- */
-
-/**
- *
- * @sci_dev:
- * @request:
- *
- * This method takes the request and bulids an appropriate SCU context for the
- * request and then requests the controller to post the request. none
- */
-void scic_sds_remote_device_post_request(
-	struct scic_sds_remote_device *sci_dev,
-	u32 request)
-{
-	u32 context;
-
-	context = scic_sds_remote_device_build_command_context(sci_dev, request);
-
-	scic_sds_controller_post_request(
-		scic_sds_remote_device_get_controller(sci_dev),
-		context
-		);
-}
-
-#if !defined(DISABLE_ATAPI)
-/**
- *
- * @sci_dev: The device to be checked.
- *
- * This method check the signature fis of a stp device to decide whether a
- * device is atapi or not. true if a device is atapi device. False if a device
- * is not atapi.
- */
-bool scic_sds_remote_device_is_atapi(
-	struct scic_sds_remote_device *sci_dev)
-{
-	if (!sci_dev->target_protocols.u.bits.attached_stp_target)
-		return false;
-	else if (sci_dev->is_direct_attached) {
-		struct scic_sds_phy *phy;
-		struct scic_sata_phy_properties properties;
-		struct sata_fis_reg_d2h *signature_fis;
-		phy = scic_sds_port_get_a_connected_phy(sci_dev->owning_port);
-		scic_sata_phy_get_properties(phy, &properties);
-
-		/* decode the signature fis. */
-		signature_fis = &(properties.signature_fis);
-
-		if ((signature_fis->sector_count  == 0x01)
-		    && (signature_fis->lba_low       == 0x01)
-		    && (signature_fis->lba_mid       == 0x14)
-		    && (signature_fis->lba_high      == 0xEB)
-		    && ((signature_fis->device & 0x5F) == 0x00)
-		    ) {
-			/* An ATA device supporting the PACKET command set. */
-			return true;
-		} else
-			return false;
-	} else {
-		/* Expander supported ATAPI device is not currently supported. */
-		return false;
-	}
-}
-#endif
-
-/**
- *
- * @user_parameter: This is cast to a remote device object.
- *
- * This method is called once the remote node context is ready to be freed.
- * The remote device can now report that its stop operation is complete. none
- */
-static void scic_sds_cb_remote_device_rnc_destruct_complete(
-	void *user_parameter)
-{
-	struct scic_sds_remote_device *sci_dev;
-
-	sci_dev = (struct scic_sds_remote_device *)user_parameter;
-
-	BUG_ON(sci_dev->started_request_count != 0);
-
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
-}
-
-/**
- *
- * @user_parameter: This is cast to a remote device object.
- *
- * This method is called once the remote node context has transisitioned to a
- * ready state.  This is the indication that the remote device object can also
- * transition to ready. none
- */
-static void scic_sds_remote_device_resume_complete_handler(
-	void *user_parameter)
-{
-	struct scic_sds_remote_device *sci_dev;
-
-	sci_dev = (struct scic_sds_remote_device *)user_parameter;
-
-	if (
-		sci_base_state_machine_get_state(&sci_dev->state_machine)
-		!= SCI_BASE_REMOTE_DEVICE_STATE_READY
-		) {
-		sci_base_state_machine_change_state(
-			&sci_dev->state_machine,
-			SCI_BASE_REMOTE_DEVICE_STATE_READY
-			);
-	}
-}
-
-/**
- *
- * @device: This parameter specifies the device for which the request is being
- *    started.
- * @request: This parameter specifies the request being started.
- * @status: This parameter specifies the current start operation status.
- *
- * This method will perform the STP request start processing common to IO
- * requests and task requests of all types. none
- */
-void scic_sds_remote_device_start_request(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *sci_req,
-	enum sci_status status)
-{
-	/* We still have a fault in starting the io complete it on the port */
-	if (status == SCI_SUCCESS)
-		scic_sds_remote_device_increment_request_count(sci_dev);
-	else{
-		sci_dev->owning_port->state_handlers->complete_io_handler(
-			sci_dev->owning_port, sci_dev, sci_req
-			);
-	}
-}
-
-
-/**
- *
- * @request: This parameter specifies the request being continued.
- *
- * This method will continue to post tc for a STP request. This method usually
- * serves as a callback when RNC gets resumed during a task management
- * sequence. none
- */
-void scic_sds_remote_device_continue_request(void *dev)
-{
-	struct scic_sds_remote_device *sci_dev = dev;
-
-	/* we need to check if this request is still valid to continue. */
-	if (sci_dev->working_request)
-		scic_controller_continue_io(sci_dev->working_request);
-}
-
-/**
- *
- * @user_parameter: This is cast to a remote device object.
- *
- * This method is called once the remote node context has reached a suspended
- * state. The remote device can now report that its suspend operation is
- * complete. none
- */
-
-/**
- * This method will terminate all of the IO requests in the controllers IO
- *    request table that were targeted for this device.
- * @sci_dev: This parameter specifies the remote device for which to
- *    attempt to terminate all requests.
- *
- * This method returns an indication as to whether all requests were
- * successfully terminated.  If a single request fails to be terminated, then
- * this method will return the failure.
- */
-static enum sci_status scic_sds_remote_device_terminate_requests(
-	struct scic_sds_remote_device *sci_dev)
-{
-	enum sci_status status           = SCI_SUCCESS;
-	enum sci_status terminate_status = SCI_SUCCESS;
-	struct scic_sds_request *sci_req;
-	u32 index;
-	u32 request_count    = sci_dev->started_request_count;
-
-	for (index = 0;
-	     (index < SCI_MAX_IO_REQUESTS) && (request_count > 0);
-	     index++) {
-		sci_req = sci_dev->owning_port->owning_controller->io_request_table[index];
-
-		if ((sci_req != NULL) && (sci_req->target_device == sci_dev)) {
-			terminate_status = scic_controller_terminate_request(
-				sci_dev->owning_port->owning_controller,
-				sci_dev,
-				sci_req
-				);
-
-			if (terminate_status != SCI_SUCCESS)
-				status = terminate_status;
-
-			request_count--;
-		}
-	}
-
-	return status;
-}
-
-static enum sci_status
-default_device_handler(struct scic_sds_remote_device *sci_dev,
-		       const char *func)
-{
-	dev_warn(scirdev_to_dev(sci_dev),
-		 "%s: in wrong state: %d\n", func,
-		 sci_base_state_machine_get_state(&sci_dev->state_machine));
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-enum sci_status scic_sds_remote_device_default_start_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-static enum sci_status scic_sds_remote_device_default_stop_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-enum sci_status scic_sds_remote_device_default_fail_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-enum sci_status scic_sds_remote_device_default_destruct_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-enum sci_status scic_sds_remote_device_default_reset_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-enum sci_status scic_sds_remote_device_default_reset_complete_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-enum sci_status scic_sds_remote_device_default_suspend_handler(
-	struct scic_sds_remote_device *sci_dev, u32 suspend_type)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-enum sci_status scic_sds_remote_device_default_resume_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-/**
- *
- * @device: The struct scic_sds_remote_device which is then cast into a
- *    struct scic_sds_remote_device.
- * @event_code: The event code that the struct scic_sds_controller wants the device
- *    object to process.
- *
- * This method is the default event handler.  It will call the RNC state
- * machine handler for any RNC events otherwise it will log a warning and
- * returns a failure. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status  scic_sds_remote_device_core_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code,
-	bool is_ready_state)
-{
-	enum sci_status status;
-
-	switch (scu_get_event_type(event_code)) {
-	case SCU_EVENT_TYPE_RNC_OPS_MISC:
-	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
-	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
-		status = scic_sds_remote_node_context_event_handler(&sci_dev->rnc, event_code);
-		break;
-	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
-
-		if (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {
-			status = SCI_SUCCESS;
-
-			/* Suspend the associated RNC */
-			scic_sds_remote_node_context_suspend(&sci_dev->rnc,
-							      SCI_SOFTWARE_SUSPENSION,
-							      NULL, NULL);
-
-			dev_dbg(scirdev_to_dev(sci_dev),
-				"%s: device: %p event code: %x: %s\n",
-				__func__, sci_dev, event_code,
-				(is_ready_state)
-				? "I_T_Nexus_Timeout event"
-				: "I_T_Nexus_Timeout event in wrong state");
-
-			break;
-		}
-	/* Else, fall through and treat as unhandled... */
-
-	default:
-		dev_dbg(scirdev_to_dev(sci_dev),
-			"%s: device: %p event code: %x: %s\n",
-			__func__, sci_dev, event_code,
-			(is_ready_state)
-			? "unexpected event"
-			: "unexpected event in wrong state");
-		status = SCI_FAILURE_INVALID_STATE;
-		break;
-	}
-
-	return status;
-}
-/**
- *
- * @device: The struct scic_sds_remote_device which is then cast into a
- *    struct scic_sds_remote_device.
- * @event_code: The event code that the struct scic_sds_controller wants the device
- *    object to process.
- *
- * This method is the default event handler.  It will call the RNC state
- * machine handler for any RNC events otherwise it will log a warning and
- * returns a failure. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status  scic_sds_remote_device_default_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code)
-{
-	return scic_sds_remote_device_core_event_handler(sci_dev,
-							  event_code,
-							  false);
-}
-
-/**
- *
- * @device: The struct scic_sds_remote_device which is then cast into a
- *    struct scic_sds_remote_device.
- * @frame_index: The frame index for which the struct scic_sds_controller wants this
- *    device object to process.
- *
- * This method is the default unsolicited frame handler.  It logs a warning,
- * releases the frame and returns a failure. enum sci_status
- * SCI_FAILURE_INVALID_STATE
- */
-enum sci_status scic_sds_remote_device_default_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
-{
-	dev_warn(scirdev_to_dev(sci_dev),
-		 "%s: SCIC Remote Device requested to handle frame %x "
-		 "while in wrong state %d\n",
-		 __func__,
-		 frame_index,
-		 sci_base_state_machine_get_state(
-			 &sci_dev->state_machine));
-
-	/* Return the frame back to the controller */
-	scic_sds_controller_release_frame(
-		scic_sds_remote_device_get_controller(sci_dev), frame_index
-		);
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-enum sci_status scic_sds_remote_device_default_start_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-enum sci_status scic_sds_remote_device_default_complete_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-enum sci_status scic_sds_remote_device_default_continue_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
-/**
- *
- * @device: The struct scic_sds_remote_device which is then cast into a
- *    struct scic_sds_remote_device.
- * @frame_index: The frame index for which the struct scic_sds_controller wants this
- *    device object to process.
- *
- * This method is a general ssp frame handler.  In most cases the device object
- * needs to route the unsolicited frame processing to the io request object.
- * This method decodes the tag for the io request object and routes the
- * unsolicited frame to that object. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-enum sci_status scic_sds_remote_device_general_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
-{
-	enum sci_status result;
-	struct sci_ssp_frame_header *frame_header;
-	struct scic_sds_request *io_request;
-
-	result = scic_sds_unsolicited_frame_control_get_header(
-		&(scic_sds_remote_device_get_controller(sci_dev)->uf_control),
-		frame_index,
-		(void **)&frame_header
-		);
-
-	if (SCI_SUCCESS == result) {
-		io_request = scic_sds_controller_get_io_request_from_tag(
-			scic_sds_remote_device_get_controller(sci_dev), frame_header->tag);
-
-		if ((io_request == NULL)
-		    || (io_request->target_device != sci_dev)) {
-			/*
-			 * We could not map this tag to a valid IO request
-			 * Just toss the frame and continue */
-			scic_sds_controller_release_frame(
-				scic_sds_remote_device_get_controller(sci_dev), frame_index
-				);
-		} else {
-			/* The IO request is now in charge of releasing the frame */
-			result = io_request->state_handlers->frame_handler(
-				io_request, frame_index);
-		}
-	}
-
-	return result;
-}
-
-/**
- *
- * @[in]: sci_dev This is the device object that is receiving the event.
- * @[in]: event_code The event code to process.
- *
- * This is a common method for handling events reported to the remote device
- * from the controller object. enum sci_status
- */
-enum sci_status scic_sds_remote_device_general_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code)
-{
-	return scic_sds_remote_device_core_event_handler(sci_dev,
-							  event_code,
-							  true);
-}
-
-/*
- * *****************************************************************************
- * *  STOPPED STATE HANDLERS
- * ***************************************************************************** */
-
-/**
- *
- * @device:
- *
- * This method takes the struct scic_sds_remote_device from a stopped state and
- * attempts to start it.   The RNC buffer for the device is constructed and the
- * device state machine is transitioned to the
- * SCIC_BASE_REMOTE_DEVICE_STATE_STARTING. enum sci_status SCI_SUCCESS if there is
- * an RNC buffer available to construct the remote device.
- * SCI_FAILURE_INSUFFICIENT_RESOURCES if there is no RNC buffer available in
- * which to construct the remote device.
- */
-static enum sci_status scic_sds_remote_device_stopped_state_start_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	enum sci_status status;
-
-	status = scic_sds_remote_node_context_resume(&sci_dev->rnc,
-			scic_sds_remote_device_resume_complete_handler, sci_dev);
-
-	if (status == SCI_SUCCESS)
-		sci_base_state_machine_change_state(&sci_dev->state_machine,
-						    SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
-
-	return status;
-}
-
-static enum sci_status scic_sds_remote_device_stopped_state_stop_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return SCI_SUCCESS;
-}
-
-/**
- *
- * @sci_dev: The struct scic_sds_remote_device which is cast into a
- *    struct scic_sds_remote_device.
- *
- * This method will destruct a struct scic_sds_remote_device that is in a stopped
- * state.  This is the only state from which a destruct request will succeed.
- * The RNi for this struct scic_sds_remote_device is returned to the free pool and the
- * device object transitions to the SCI_BASE_REMOTE_DEVICE_STATE_FINAL.
- * enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_device_stopped_state_destruct_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	struct scic_sds_controller *scic;
-
-	scic = scic_sds_remote_device_get_controller(sci_dev);
-	scic_sds_controller_free_remote_node_context(scic, sci_dev,
-						     sci_dev->rnc.remote_node_index);
-	sci_dev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
-
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_FINAL);
-
-	return SCI_SUCCESS;
-}
-
-/*
- * *****************************************************************************
- * *  STARTING STATE HANDLERS
- * ***************************************************************************** */
-
-static enum sci_status scic_sds_remote_device_starting_state_stop_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	/*
-	 * This device has not yet started so there had better be no IO requests
-	 */
-	BUG_ON(sci_dev->started_request_count != 0);
-
-	/*
-	 * Destroy the remote node context
-	 */
-	scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-		scic_sds_cb_remote_device_rnc_destruct_complete, sci_dev);
-
-	/*
-	 * Transition to the stopping state and wait for the remote node to
-	 * complete being posted and invalidated.
-	 */
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
-
-	return SCI_SUCCESS;
-}
-
-enum sci_status scic_sds_remote_device_ready_state_stop_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	enum sci_status status = SCI_SUCCESS;
-
-	/* Request the parent state machine to transition to the stopping state */
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
-
-	if (sci_dev->started_request_count == 0) {
-		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-			scic_sds_cb_remote_device_rnc_destruct_complete,
-			sci_dev);
-	} else
-		status = scic_sds_remote_device_terminate_requests(sci_dev);
-
-	return status;
-}
-
-/**
- *
- * @device: The struct scic_sds_remote_device object which is cast to a
- *    struct scic_sds_remote_device object.
- *
- * This is the ready state device reset handler enum sci_status
- */
-enum sci_status scic_sds_remote_device_ready_state_reset_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	/* Request the parent state machine to transition to the stopping state */
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_RESETTING);
-
-	return SCI_SUCCESS;
-}
-
-/*
- * This method will attempt to start a task request for this device object. The
- * remote device object will issue the start request for the task and if
- * successful it will start the request for the port object then increment its
- * own requet count. enum sci_status SCI_SUCCESS if the task request is started for
- * this device object. SCI_FAILURE_INSUFFICIENT_RESOURCES if the io request
- * object could not get the resources to start.
- */
-static enum sci_status scic_sds_remote_device_ready_state_start_task_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status result;
-
-	/* See if the port is in a state where we can start the IO request */
-	result = scic_sds_port_start_io(
-		scic_sds_remote_device_get_port(sci_dev), sci_dev, request);
-
-	if (result == SCI_SUCCESS) {
-		result = scic_sds_remote_node_context_start_task(&sci_dev->rnc,
-								 request);
-		if (result == SCI_SUCCESS)
-			result = scic_sds_request_start(request);
-
-		scic_sds_remote_device_start_request(sci_dev, request, result);
-	}
-
-	return result;
-}
-
-/*
- * This method will attempt to start an io request for this device object. The
- * remote device object will issue the start request for the io and if
- * successful it will start the request for the port object then increment its
- * own requet count. enum sci_status SCI_SUCCESS if the io request is started for
- * this device object. SCI_FAILURE_INSUFFICIENT_RESOURCES if the io request
- * object could not get the resources to start.
- */
-static enum sci_status scic_sds_remote_device_ready_state_start_io_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status result;
-
-	/* See if the port is in a state where we can start the IO request */
-	result = scic_sds_port_start_io(
-		scic_sds_remote_device_get_port(sci_dev), sci_dev, request);
-
-	if (result == SCI_SUCCESS) {
-		result = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
-		if (result == SCI_SUCCESS)
-			result = scic_sds_request_start(request);
-
-		scic_sds_remote_device_start_request(sci_dev, request, result);
-	}
-
-	return result;
-}
-
-/*
- * This method will complete the request for the remote device object.  The
- * method will call the completion handler for the request object and if
- * successful it will complete the request on the port object then decrement
- * its own started_request_count. enum sci_status
- */
-static enum sci_status scic_sds_remote_device_ready_state_complete_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status result;
-
-	result = scic_sds_request_complete(request);
-
-	if (result != SCI_SUCCESS)
-		return result;
-
-	/* See if the port is in a state
-	 * where we can start the IO request */
-	result = scic_sds_port_complete_io(
-			scic_sds_remote_device_get_port(sci_dev),
-			sci_dev, request);
-
-	if (result == SCI_SUCCESS)
-		scic_sds_remote_device_decrement_request_count(sci_dev);
-
-	return result;
-}
-
-/*
- * *****************************************************************************
- * *  STOPPING STATE HANDLERS
- * ***************************************************************************** */
-
-/**
- *
- * @sci_dev: The struct scic_sds_remote_device which is cast into a
- *    struct scic_sds_remote_device.
- *
- * This method will stop a struct scic_sds_remote_device that is already in the
- * SCI_BASE_REMOTE_DEVICE_STATE_STOPPING state. This is not considered an error
- * since we allow a stop request on a device that is alreay stopping or
- * stopped. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_device_stopping_state_stop_handler(
-	struct scic_sds_remote_device *device)
-{
-	/*
-	 * All requests should have been terminated, but if there is an
-	 * attempt to stop a device already in the stopping state, then
-	 * try again to terminate. */
-	return scic_sds_remote_device_terminate_requests(device);
-}
-
-
-/**
- *
- * @device: The device object for which the request is completing.
- * @request: The task request that is being completed.
- *
- * This method completes requests for this struct scic_sds_remote_device while it is
- * in the SCI_BASE_REMOTE_DEVICE_STATE_STOPPING state. This method calls the
- * complete method for the request object and if that is successful the port
- * object is called to complete the task request. Then the device object itself
- * completes the task request. If struct scic_sds_remote_device started_request_count
- * goes to 0 and the invalidate RNC request has completed the device object can
- * transition to the SCI_BASE_REMOTE_DEVICE_STATE_STOPPED. enum sci_status
- */
-static enum sci_status scic_sds_remote_device_stopping_state_complete_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status status = SCI_SUCCESS;
-
-	status = scic_sds_request_complete(request);
-
-	if (status != SCI_SUCCESS)
-		return status;
-
-	status = scic_sds_port_complete_io(scic_sds_remote_device_get_port(sci_dev),
-					   sci_dev, request);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	scic_sds_remote_device_decrement_request_count(sci_dev);
-
-	if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
-		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-						      scic_sds_cb_remote_device_rnc_destruct_complete,
-						      sci_dev);
-	return SCI_SUCCESS;
-}
-
-/**
- *
- * @device: The struct scic_sds_remote_device which is to be cast into a
- *    struct scic_sds_remote_device object.
- *
- * This method will complete the reset operation when the device is in the
- * resetting state. enum sci_status
- */
-static enum sci_status scic_sds_remote_device_resetting_state_reset_complete_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-
-	sci_base_state_machine_change_state(
-		&sci_dev->state_machine,
-		SCI_BASE_REMOTE_DEVICE_STATE_READY
-		);
-
-	return SCI_SUCCESS;
-}
-
-/**
- *
- * @device: The struct scic_sds_remote_device which is to be cast into a
- *    struct scic_sds_remote_device object.
- *
- * This method will stop the remote device while in the resetting state.
- * enum sci_status
- */
-static enum sci_status scic_sds_remote_device_resetting_state_stop_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	sci_base_state_machine_change_state(
-		&sci_dev->state_machine,
-		SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
-		);
-
-	return SCI_SUCCESS;
-}
-
-/*
- * This method completes requests for this struct scic_sds_remote_device while it is
- * in the SCI_BASE_REMOTE_DEVICE_STATE_RESETTING state. This method calls the
- * complete method for the request object and if that is successful the port
- * object is called to complete the task request. Then the device object itself
- * completes the task request. enum sci_status
- */
-static enum sci_status scic_sds_remote_device_resetting_state_complete_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status status = SCI_SUCCESS;
-
-	status = scic_sds_request_complete(request);
-
-	if (status == SCI_SUCCESS) {
-		status = scic_sds_port_complete_io(
-				scic_sds_remote_device_get_port(sci_dev),
-				sci_dev, request);
-
-		if (status == SCI_SUCCESS) {
-			scic_sds_remote_device_decrement_request_count(sci_dev);
-		}
-	}
-
-	return status;
-}
-
-/*
- * *****************************************************************************
- * *  FAILED STATE HANDLERS
- * ***************************************************************************** */
-
-/**
- *
- * @device: The struct scic_sds_remote_device which is to be cast into a
- *    struct scic_sds_remote_device object.
- *
- * This method handles the remove request for a failed struct scic_sds_remote_device
- * object. The method will transition the device object to the
- * SCIC_BASE_REMOTE_DEVICE_STATE_STOPPING. enum sci_status SCI_SUCCESS
- */
-
-/* --------------------------------------------------------------------------- */
-
-static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
-	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_default_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_default_event_handler,
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.start_handler		= scic_sds_remote_device_stopped_state_start_handler,
-		.stop_handler		= scic_sds_remote_device_stopped_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_stopped_state_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_default_event_handler,
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_starting_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_general_event_handler,
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_ready_state_start_io_handler,
-		.complete_io_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_ready_state_start_task_handler,
-		.complete_task_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_general_event_handler,
-		.frame_handler		= scic_sds_remote_device_general_frame_handler,
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_stopping_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_general_event_handler,
-		.frame_handler		= scic_sds_remote_device_general_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_default_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_default_event_handler,
-		.frame_handler		= scic_sds_remote_device_general_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_resetting_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_resetting_state_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_default_event_handler,
-		.frame_handler		= scic_sds_remote_device_general_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_default_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_default_event_handler,
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
-	}
-};
-
-/**
- *
- * @object: This is the struct sci_base_object that is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the enter method for the SCI_BASE_REMOTE_DEVICE_STATE_INITIAL it
- * immediatly transitions the remote device object to the stopped state. none
- */
-static void scic_sds_remote_device_initial_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
-
-	sci_dev = container_of(object, typeof(*sci_dev), parent);
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_INITIAL);
-
-	/* Initial state is a transitional state to the stopped state */
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
-}
-
-/**
- *
- * @object: This is the struct sci_base_object that is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the enter function for the SCI_BASE_REMOTE_DEVICE_STATE_INITIAL it
- * sets the stopped state handlers and if this state is entered from the
- * SCI_BASE_REMOTE_DEVICE_STATE_STOPPING then the SCI User is informed that the
- * device stop is complete. none
- */
-static void scic_sds_remote_device_stopped_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev;
-	struct scic_sds_controller *scic;
-	struct isci_remote_device *idev;
-	struct isci_host *ihost;
-	u32 prev_state;
-
-	sci_dev = container_of(object, typeof(*sci_dev), parent);
-	scic = scic_sds_remote_device_get_controller(sci_dev);
-	ihost = sci_object_get_association(scic);
-	idev = sci_object_get_association(sci_dev);
-
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
-
-	/* If we are entering from the stopping state let the SCI User know that
-	 * the stop operation has completed.
-	 */
-	prev_state = sci_dev->state_machine.previous_state_id;
-	if (prev_state == SCI_BASE_REMOTE_DEVICE_STATE_STOPPING)
-		isci_remote_device_stop_complete(ihost, idev, SCI_SUCCESS);
-
-	scic_sds_controller_remote_device_stopped(scic, sci_dev);
-}
-
-/**
- *
- * @object: This is the struct sci_base_object that is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the enter function for the SCI_BASE_REMOTE_DEVICE_STATE_STARTING it
- * sets the starting state handlers, sets the device not ready, and posts the
- * remote node context to the hardware. none
- */
-static void scic_sds_remote_device_starting_state_enter(struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = sci_object_get_association(scic);
-	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
-
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
-
-	isci_remote_device_not_ready(ihost, idev,
-				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
-}
-
-static void scic_sds_remote_device_starting_state_exit(struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = sci_object_get_association(scic);
-	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
-
-	/*
-	 * @todo Check the device object for the proper return code for this
-	 * callback
-	 */
-	isci_remote_device_start_complete(ihost, idev, SCI_SUCCESS);
-}
-
-/**
- *
- * @object: This is the struct sci_base_object that is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the enter function for the SCI_BASE_REMOTE_DEVICE_STATE_READY it sets
- * the ready state handlers, and starts the ready substate machine. none
- */
-static void scic_sds_remote_device_ready_state_enter(struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = sci_object_get_association(scic);
-	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
-
-	SET_STATE_HANDLER(sci_dev,
-			  scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_READY);
-
-	scic->remote_device_sequence[sci_dev->rnc.remote_node_index]++;
-
-	if (sci_dev->has_ready_substate_machine)
-		sci_base_state_machine_start(&sci_dev->ready_substate_machine);
-	else
-		isci_remote_device_ready(ihost, idev);
-}
-
-/**
- *
- * @object: This is the struct sci_base_object that is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the exit function for the SCI_BASE_REMOTE_DEVICE_STATE_READY it does
- * nothing. none
- */
-static void scic_sds_remote_device_ready_state_exit(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
-	if (sci_dev->has_ready_substate_machine)
-		sci_base_state_machine_stop(&sci_dev->ready_substate_machine);
-	else {
-		struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-		struct isci_host *ihost = sci_object_get_association(scic);
-		struct isci_remote_device *idev = sci_object_get_association(sci_dev);
-
-		isci_remote_device_not_ready(ihost, idev,
-					     SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);
-	}
-}
-
-/**
- *
- * @object: This is the struct sci_base_object that is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the enter method for the SCI_BASE_REMOTE_DEVICE_STATE_STOPPING it
- * sets the stopping state handlers and posts an RNC invalidate request to the
- * SCU hardware. none
- */
-static void scic_sds_remote_device_stopping_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
-		);
-}
-
-/**
- *
- * @object: This is the struct sci_base_object that is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the enter method for the SCI_BASE_REMOTE_DEVICE_STATE_FAILED it sets
- * the stopping state handlers. none
- */
-static void scic_sds_remote_device_failed_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_FAILED
-		);
-}
-
-/**
- *
- * @object: This is the struct sci_base_object that is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the enter method for the SCI_BASE_REMOTE_DEVICE_STATE_RESETTING it
- * sets the resetting state handlers. none
- */
-static void scic_sds_remote_device_resetting_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_RESETTING
-		);
-
-	scic_sds_remote_node_context_suspend(
-		&sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
-}
-
-/**
- *
- * @object: This is the struct sci_base_object that is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the exit method for the SCI_BASE_REMOTE_DEVICE_STATE_RESETTING it
- * does nothing. none
- */
-static void scic_sds_remote_device_resetting_state_exit(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
-
-	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
-}
-
-/**
- *
- * @object: This is the struct sci_base_object that is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the enter method for the SCI_BASE_REMOTE_DEVICE_STATE_FINAL it sets
- * the final state handlers. none
- */
-static void scic_sds_remote_device_final_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_FINAL
-		);
-}
-
-/* --------------------------------------------------------------------------- */
-
-static const struct sci_base_state scic_sds_remote_device_state_table[] = {
-	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.enter_state = scic_sds_remote_device_initial_state_enter,
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.enter_state = scic_sds_remote_device_stopped_state_enter,
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.enter_state = scic_sds_remote_device_starting_state_enter,
-		.exit_state  = scic_sds_remote_device_starting_state_exit
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.enter_state = scic_sds_remote_device_ready_state_enter,
-		.exit_state  = scic_sds_remote_device_ready_state_exit
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.enter_state = scic_sds_remote_device_stopping_state_enter,
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.enter_state = scic_sds_remote_device_failed_state_enter,
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.enter_state = scic_sds_remote_device_resetting_state_enter,
-		.exit_state  = scic_sds_remote_device_resetting_state_exit
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.enter_state = scic_sds_remote_device_final_state_enter,
-	},
-};
-
-void scic_remote_device_construct(struct scic_sds_port *sci_port,
-				  struct scic_sds_remote_device *sci_dev)
-{
-	sci_dev->owning_port = sci_port;
-	sci_dev->started_request_count = 0;
-	sci_dev->parent.private = NULL;
-
-	sci_base_state_machine_construct(
-		&sci_dev->state_machine,
-		&sci_dev->parent,
-		scic_sds_remote_device_state_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_INITIAL
-		);
-
-	sci_base_state_machine_start(
-		&sci_dev->state_machine
-		);
-
-	scic_sds_remote_node_context_construct(&sci_dev->rnc,
-					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
-
-	sci_object_set_association(&sci_dev->rnc, sci_dev);
-}
diff --git a/drivers/scsi/isci/core/scic_sds_remote_device.h b/drivers/scsi/isci/core/scic_sds_remote_device.h
deleted file mode 100644
index bff44b8..0000000
--- a/drivers/scsi/isci/core/scic_sds_remote_device.h
+++ /dev/null
@@ -1,694 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCIC_SDS_REMOTE_DEVICE_H_
-#define _SCIC_SDS_REMOTE_DEVICE_H_
-
-#include "intel_sas.h"
-#include "scu_remote_node_context.h"
-#include "scic_sds_remote_node_context.h"
-#include <scsi/libsas.h>
-
-/**
- * enum scic_sds_remote_device_states - This enumeration depicts all the states
- *    for the common remote device state machine.
- *
- *
- */
-enum scic_sds_remote_device_states {
-	/**
-	 * Simply the initial state for the base remote device state machine.
-	 */
-	SCI_BASE_REMOTE_DEVICE_STATE_INITIAL,
-
-	/**
-	 * This state indicates that the remote device has successfully been
-	 * stopped.  In this state no new IO operations are permitted.
-	 * This state is entered from the INITIAL state.
-	 * This state is entered from the STOPPING state.
-	 */
-	SCI_BASE_REMOTE_DEVICE_STATE_STOPPED,
-
-	/**
-	 * This state indicates the the remote device is in the process of
-	 * becoming ready (i.e. starting).  In this state no new IO operations
-	 * are permitted.
-	 * This state is entered from the STOPPED state.
-	 */
-	SCI_BASE_REMOTE_DEVICE_STATE_STARTING,
-
-	/**
-	 * This state indicates the remote device is now ready.  Thus, the user
-	 * is able to perform IO operations on the remote device.
-	 * This state is entered from the STARTING state.
-	 */
-	SCI_BASE_REMOTE_DEVICE_STATE_READY,
-
-	/**
-	 * This state indicates that the remote device is in the process of
-	 * stopping.  In this state no new IO operations are permitted, but
-	 * existing IO operations are allowed to complete.
-	 * This state is entered from the READY state.
-	 * This state is entered from the FAILED state.
-	 */
-	SCI_BASE_REMOTE_DEVICE_STATE_STOPPING,
-
-	/**
-	 * This state indicates that the remote device has failed.
-	 * In this state no new IO operations are permitted.
-	 * This state is entered from the INITIALIZING state.
-	 * This state is entered from the READY state.
-	 */
-	SCI_BASE_REMOTE_DEVICE_STATE_FAILED,
-
-	/**
-	 * This state indicates the device is being reset.
-	 * In this state no new IO operations are permitted.
-	 * This state is entered from the READY state.
-	 */
-	SCI_BASE_REMOTE_DEVICE_STATE_RESETTING,
-
-	/**
-	 * Simply the final state for the base remote device state machine.
-	 */
-	SCI_BASE_REMOTE_DEVICE_STATE_FINAL,
-};
-
-/**
- * enum scic_sds_ssp_remote_device_ready_substates -
- *
- * This is the enumeration of the ready substates for the
- * struct scic_sds_remote_device.
- */
-enum scic_sds_ssp_remote_device_ready_substates {
-	/**
-	 * This is the initial state for the remote device ready substate.
-	 */
-	SCIC_SDS_SSP_REMOTE_DEVICE_READY_SUBSTATE_INITIAL,
-
-	/**
-	 * This is the ready operational substate for the remote device.
-	 * This is the normal operational state for a remote device.
-	 */
-	SCIC_SDS_SSP_REMOTE_DEVICE_READY_SUBSTATE_OPERATIONAL,
-
-	/**
-	 * This is the suspended state for the remote device. This is the state
-	 * that the device is placed in when a RNC suspend is received by
-	 * the SCU hardware.
-	 */
-	SCIC_SDS_SSP_REMOTE_DEVICE_READY_SUBSTATE_SUSPENDED,
-
-	/**
-	 * This is the final state that the device is placed in before a change
-	 * to the base state machine.
-	 */
-	SCIC_SDS_SSP_REMOTE_DEVICE_READY_SUBSTATE_FINAL,
-
-	SCIC_SDS_SSP_REMOTE_DEVICE_READY_MAX_SUBSTATES
-};
-
-/**
- * enum scic_sds_stp_remote_device_ready_substates -
- *
- * This is the enumeration for the struct scic_sds_remote_device ready substates
- * for the STP remote device.
- */
-enum scic_sds_stp_remote_device_ready_substates {
-	/**
-	 * This is the idle substate for the stp remote device.  When there are no
-	 * active IO for the device it is is in this state.
-	 */
-	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE,
-
-	/**
-	 * This is the command state for for the STP remote device.  This state is
-	 * entered when the device is processing a non-NCQ command.  The device object
-	 * will fail any new start IO requests until this command is complete.
-	 */
-	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD,
-
-	/**
-	 * This is the NCQ state for the STP remote device.  This state is entered
-	 * when the device is processing an NCQ reuqest.  It will remain in this state
-	 * so long as there is one or more NCQ requests being processed.
-	 */
-	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ,
-
-	/**
-	 * This is the NCQ error state for the STP remote device.  This state is
-	 * entered when an SDB error FIS is received by the device object while in the
-	 * NCQ state.  The device object will only accept a READ LOG command while in
-	 * this state.
-	 */
-	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR,
-
-#if !defined(DISABLE_ATAPI)
-	/**
-	 * This is the ATAPI error state for the STP ATAPI remote device.  This state is
-	 * entered when ATAPI device sends error status FIS without data while the device
-	 * object is in CMD state. A suspension event is expected in this state. The device
-	 * object will resume right away.
-	 */
-	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR,
-#endif
-
-	/**
-	 * This is the READY substate indicates the device is waiting for the RESET task
-	 * coming to be recovered from certain hardware specific error.
-	 */
-	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET,
-};
-
-/**
- * enum scic_sds_smp_remote_device_ready_substates -
- *
- * This is the enumeration of the ready substates for the SMP REMOTE DEVICE.
- */
-enum scic_sds_smp_remote_device_ready_substates {
-	/**
-	 * This is the ready operational substate for the remote device.  This is the
-	 * normal operational state for a remote device.
-	 */
-	SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE,
-
-	/**
-	 * This is the suspended state for the remote device.  This is the state that
-	 * the device is placed in when a RNC suspend is received by the SCU hardware.
-	 */
-	SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD,
-};
-
-/**
- * struct scic_sds_remote_device - This structure contains the data for an SCU
- *    implementation of the SCU Core device data.
- *
- *
- */
-struct scic_sds_remote_device {
-	/**
-	 * The field specifies that the parent object for the base remote
-	 * device is the base object itself.
-	 */
-	struct sci_base_object parent;
-
-	/**
-	 * This field contains the information for the base remote device state
-	 * machine.
-	 */
-	struct sci_base_state_machine state_machine;
-
-	/**
-	 * This field is the programmed device port width.  This value is
-	 * written to the RCN data structure to tell the SCU how many open
-	 * connections this device can have.
-	 */
-	u32 device_port_width;
-
-	/**
-	 * This field is the programmed connection rate for this remote device.  It is
-	 * used to program the TC with the maximum allowed connection rate.
-	 */
-	enum sas_linkrate connection_rate;
-
-	/**
-	 * This field contains the allowed target protocols for this remote device.
-	 */
-	struct smp_discover_response_protocols target_protocols;
-
-	/**
-	 * This field contains the device SAS address.
-	 */
-	struct sci_sas_address device_address;
-
-	/**
-	 * This filed is assinged the value of true if the device is directly
-	 * attached to the port.
-	 */
-	bool is_direct_attached;
-
-#if !defined(DISABLE_ATAPI)
-	/**
-	 * This filed is assinged the value of true if the device is an ATAPI
-	 * device.
-	 */
-	bool is_atapi;
-#endif
-
-	/**
-	 * This filed contains a pointer back to the port to which this device
-	 * is assigned.
-	 */
-	struct scic_sds_port *owning_port;
-
-	/**
-	 * This field contains the SCU silicon remote node context specific
-	 * information.
-	 */
-	struct scic_sds_remote_node_context rnc;
-
-	/**
-	 * This field contains the stated request count for the remote device.  The
-	 * device can not reach the SCI_BASE_REMOTE_DEVICE_STATE_STOPPED until all
-	 * requests are complete and the rnc_posted value is false.
-	 */
-	u32 started_request_count;
-
-	/**
-	 * This field contains a pointer to the working request object.  It is only
-	 * used only for SATA requests since the unsolicited frames we get from the
-	 * hardware have no Tag value to look up the io request object.
-	 */
-	struct scic_sds_request *working_request;
-
-	/**
-	 * This field contains the reason for the remote device going not_ready.  It is
-	 * assigned in the state handlers and used in the state transition.
-	 */
-	u32 not_ready_reason;
-
-	/**
-	 * This field is true if this remote device has an initialzied ready substate
-	 * machine. SSP devices do not have a ready substate machine and STP devices
-	 * have a ready substate machine.
-	 */
-	bool has_ready_substate_machine;
-
-	/**
-	 * This field contains the state machine for the ready substate machine for
-	 * this struct scic_sds_remote_device object.
-	 */
-	struct sci_base_state_machine ready_substate_machine;
-
-	/**
-	 * This field maintains the set of state handlers for the remote device
-	 * object.  These are changed each time the remote device enters a new state.
-	 */
-	const struct scic_sds_remote_device_state_handler *state_handlers;
-};
-
-static inline struct scic_sds_remote_device *rnc_to_dev(struct scic_sds_remote_node_context *rnc)
-{
-	struct scic_sds_remote_device *sci_dev;
-
-	sci_dev = container_of(rnc, typeof(*sci_dev), rnc);
-
-	return sci_dev;
-}
-
-typedef enum sci_status (*scic_sds_remote_device_request_handler_t)(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request);
-
-typedef enum sci_status (*scic_sds_remote_device_high_priority_request_complete_handler_t)(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request,
-	void *,
-	enum sci_io_status);
-
-typedef enum sci_status (*scic_sds_remote_device_handler_t)(
-	struct scic_sds_remote_device *sci_dev);
-
-typedef enum sci_status (*scic_sds_remote_device_suspend_handler_t)(
-	struct scic_sds_remote_device *sci_dev,
-	u32 suspend_type);
-
-typedef enum sci_status (*scic_sds_remote_device_resume_handler_t)(
-	struct scic_sds_remote_device *sci_dev);
-
-typedef enum sci_status (*scic_sds_remote_device_frame_handler_t)(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index);
-
-typedef enum sci_status (*scic_sds_remote_device_event_handler_t)(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code);
-
-typedef void (*scic_sds_remote_device_ready_not_ready_handler_t)(
-	struct scic_sds_remote_device *sci_dev);
-
-/**
- * struct scic_sds_remote_device_state_handler - This structure conains the
- *    state handlers that are needed to process requests for the SCU remote
- *    device objects.
- *
- *
- */
-struct scic_sds_remote_device_state_handler {
-	/**
-	 * The start_handler specifies the method invoked when a user
-	 * attempts to start a remote device.
-	 */
-	scic_sds_remote_device_handler_t start_handler;
-
-	/**
-	 * The stop_handler specifies the method invoked when a user attempts to
-	 * stop a remote device.
-	 */
-	scic_sds_remote_device_handler_t stop_handler;
-
-	/**
-	 * The fail_handler specifies the method invoked when a remote device
-	 * failure has occurred.  A failure may be due to an inability to
-	 * initialize/configure the device.
-	 */
-	scic_sds_remote_device_handler_t fail_handler;
-
-	/**
-	 * The destruct_handler specifies the method invoked when attempting to
-	 * destruct a remote device.
-	 */
-	scic_sds_remote_device_handler_t destruct_handler;
-
-	/**
-	 * The reset handler specifies the method invloked when requesting to
-	 * reset a remote device.
-	 */
-	scic_sds_remote_device_handler_t reset_handler;
-
-	/**
-	 * The reset complete handler specifies the method invloked when
-	 * reporting that a reset has completed to the remote device.
-	 */
-	scic_sds_remote_device_handler_t reset_complete_handler;
-
-	/**
-	 * The start_io_handler specifies the method invoked when a user
-	 * attempts to start an IO request for a remote device.
-	 */
-	scic_sds_remote_device_request_handler_t start_io_handler;
-
-	/**
-	 * The complete_io_handler specifies the method invoked when a user
-	 * attempts to complete an IO request for a remote device.
-	 */
-	scic_sds_remote_device_request_handler_t complete_io_handler;
-
-	/**
-	 * The continue_io_handler specifies the method invoked when a user
-	 * attempts to continue an IO request for a remote device.
-	 */
-	scic_sds_remote_device_request_handler_t continue_io_handler;
-
-	/**
-	 * The start_task_handler specifies the method invoked when a user
-	 * attempts to start a task management request for a remote device.
-	 */
-	scic_sds_remote_device_request_handler_t start_task_handler;
-
-	/**
-	 * The complete_task_handler specifies the method invoked when a user
-	 * attempts to complete a task management request for a remote device.
-	 */
-	scic_sds_remote_device_request_handler_t complete_task_handler;
-
-
-	scic_sds_remote_device_suspend_handler_t suspend_handler;
-	scic_sds_remote_device_resume_handler_t resume_handler;
-	scic_sds_remote_device_event_handler_t event_handler;
-	scic_sds_remote_device_frame_handler_t frame_handler;
-};
-
-extern const struct sci_base_state scic_sds_ssp_remote_device_ready_substate_table[];
-extern const struct sci_base_state scic_sds_stp_remote_device_ready_substate_table[];
-extern const struct sci_base_state scic_sds_smp_remote_device_ready_substate_table[];
-
-/**
- * scic_sds_remote_device_increment_request_count() -
- *
- * This macro incrments the request count for this device
- */
-#define scic_sds_remote_device_increment_request_count(sci_dev) \
-	((sci_dev)->started_request_count++)
-
-/**
- * scic_sds_remote_device_decrement_request_count() -
- *
- * This macro decrements the request count for this device.  This count will
- * never decrment past 0.
- */
-#define scic_sds_remote_device_decrement_request_count(sci_dev) \
-	((sci_dev)->started_request_count > 0 ? \
-	 (sci_dev)->started_request_count-- : 0)
-
-/**
- * scic_sds_remote_device_get_request_count() -
- *
- * This is a helper macro to return the current device request count.
- */
-#define scic_sds_remote_device_get_request_count(sci_dev) \
-	((sci_dev)->started_request_count)
-
-/**
- * scic_sds_remote_device_get_port() -
- *
- * This macro returns the owning port of this remote device obejct.
- */
-#define scic_sds_remote_device_get_port(sci_dev) \
-	((sci_dev)->owning_port)
-
-/**
- * scic_sds_remote_device_get_controller() -
- *
- * This macro returns the controller object that contains this device object
- */
-#define scic_sds_remote_device_get_controller(sci_dev) \
-	scic_sds_port_get_controller(scic_sds_remote_device_get_port(sci_dev))
-
-/**
- * scic_sds_remote_device_set_state_handlers() -
- *
- * This macro sets the remote device state handlers pointer and is set on entry
- * to each device state.
- */
-#define scic_sds_remote_device_set_state_handlers(sci_dev, handlers) \
-	((sci_dev)->state_handlers = (handlers))
-
-/**
- * scic_sds_remote_device_get_port() -
- *
- * This macro returns the owning port of this device
- */
-#define scic_sds_remote_device_get_port(sci_dev) \
-	((sci_dev)->owning_port)
-
-/**
- * scic_sds_remote_device_get_sequence() -
- *
- * This macro returns the remote device sequence value
- */
-#define scic_sds_remote_device_get_sequence(sci_dev) \
-	(\
-		scic_sds_remote_device_get_controller(sci_dev)-> \
-		remote_device_sequence[(sci_dev)->rnc.remote_node_index] \
-	)
-
-/**
- * scic_sds_remote_device_get_controller_peg() -
- *
- * This macro returns the controllers protocol engine group
- */
-#define scic_sds_remote_device_get_controller_peg(sci_dev) \
-	(\
-		scic_sds_controller_get_protocol_engine_group(\
-			scic_sds_port_get_controller(\
-				scic_sds_remote_device_get_port(sci_dev) \
-				) \
-			) \
-	)
-
-/**
- * scic_sds_remote_device_get_port_index() -
- *
- * This macro returns the port index for the devices owning port
- */
-#define scic_sds_remote_device_get_port_index(sci_dev) \
-	(scic_sds_port_get_index(scic_sds_remote_device_get_port(sci_dev)))
-
-/**
- * scic_sds_remote_device_get_index() -
- *
- * This macro returns the remote node index for this device object
- */
-#define scic_sds_remote_device_get_index(sci_dev) \
-	((sci_dev)->rnc.remote_node_index)
-
-/**
- * scic_sds_remote_device_build_command_context() -
- *
- * This macro builds a remote device context for the SCU post request operation
- */
-#define scic_sds_remote_device_build_command_context(device, command) \
-	((command) \
-	 | (scic_sds_remote_device_get_controller_peg((device)) << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) \
-	 | (scic_sds_remote_device_get_port_index((device)) << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) \
-	 | (scic_sds_remote_device_get_index((device)))	\
-	)
-
-/**
- * scic_sds_remote_device_set_working_request() -
- *
- * This macro makes the working request assingment for the remote device
- * object. To clear the working request use this macro with a NULL request
- * object.
- */
-#define scic_sds_remote_device_set_working_request(device, request) \
-	((device)->working_request = (request))
-
-enum sci_status scic_sds_remote_device_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index);
-
-enum sci_status scic_sds_remote_device_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code);
-
-enum sci_status scic_sds_remote_device_start_io(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *io_request);
-
-enum sci_status scic_sds_remote_device_complete_io(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *io_request);
-
-enum sci_status scic_sds_remote_device_resume(
-	struct scic_sds_remote_device *sci_dev);
-
-enum sci_status scic_sds_remote_device_suspend(
-	struct scic_sds_remote_device *sci_dev,
-	u32 suspend_type);
-
-enum sci_status scic_sds_remote_device_start_task(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *io_request);
-
-void scic_sds_remote_device_post_request(
-	struct scic_sds_remote_device *sci_dev,
-	u32 request);
-
-#if !defined(DISABLE_ATAPI)
-bool scic_sds_remote_device_is_atapi(
-	struct scic_sds_remote_device *sci_dev);
-#else /* !defined(DISABLE_ATAPI) */
-#define scic_sds_remote_device_is_atapi(sci_dev) false
-#endif /* !defined(DISABLE_ATAPI) */
-
-void scic_sds_remote_device_start_request(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *sci_req,
-	enum sci_status status);
-
-void scic_sds_remote_device_continue_request(void *sci_dev);
-
-enum sci_status scic_sds_remote_device_default_start_handler(
-	struct scic_sds_remote_device *sci_dev);
-
-enum sci_status scic_sds_remote_device_default_fail_handler(
-	struct scic_sds_remote_device *sci_dev);
-
-enum sci_status scic_sds_remote_device_default_destruct_handler(
-	struct scic_sds_remote_device *sci_dev);
-
-enum sci_status scic_sds_remote_device_default_reset_handler(
-	struct scic_sds_remote_device *device);
-
-enum sci_status scic_sds_remote_device_default_reset_complete_handler(
-	struct scic_sds_remote_device *device);
-
-enum sci_status scic_sds_remote_device_default_start_request_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request);
-
-enum sci_status scic_sds_remote_device_default_complete_request_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request);
-
-enum sci_status scic_sds_remote_device_default_continue_request_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request);
-
-enum sci_status scic_sds_remote_device_default_suspend_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 suspend_type);
-
-enum sci_status scic_sds_remote_device_default_resume_handler(
-	struct scic_sds_remote_device *sci_dev);
-
-
-enum sci_status scic_sds_remote_device_default_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index);
-
-enum sci_status scic_sds_remote_device_ready_state_stop_handler(
-	struct scic_sds_remote_device *device);
-
-enum sci_status scic_sds_remote_device_ready_state_reset_handler(
-	struct scic_sds_remote_device *device);
-
-enum sci_status scic_sds_remote_device_general_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index);
-
-enum sci_status scic_sds_remote_device_general_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code);
-
-enum sci_status scic_sds_ssp_remote_device_ready_suspended_substate_resume_handler(
-	struct scic_sds_remote_device *sci_dev);
-
-#endif /* _SCIC_SDS_REMOTE_DEVICE_H_ */
diff --git a/drivers/scsi/isci/core/scic_sds_remote_node_context.c b/drivers/scsi/isci/core/scic_sds_remote_node_context.c
deleted file mode 100644
index e1d58f8..0000000
--- a/drivers/scsi/isci/core/scic_sds_remote_node_context.c
+++ /dev/null
@@ -1,1227 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "sci_base_state_machine.h"
-#include "scic_remote_device.h"
-#include "scic_sds_controller.h"
-#include "scic_sds_port.h"
-#include "scic_sds_remote_device.h"
-#include "scic_sds_remote_node_context.h"
-#include "sci_environment.h"
-#include "sci_util.h"
-#include "scu_event_codes.h"
-#include "scu_task_context.h"
-
-
-/**
- *
- * @sci_rnc: The RNC for which the is posted request is being made.
- *
- * This method will return true if the RNC is not in the initial state.  In all
- * other states the RNC is considered active and this will return true. The
- * destroy request of the state machine drives the RNC back to the initial
- * state.  If the state machine changes then this routine will also have to be
- * changed. bool true if the state machine is not in the initial state false if
- * the state machine is in the initial state
- */
-
-/**
- *
- * @sci_rnc: The state of the remote node context object to check.
- *
- * This method will return true if the remote node context is in a READY state
- * otherwise it will return false bool true if the remote node context is in
- * the ready state. false if the remote node context is not in the ready state.
- */
-bool scic_sds_remote_node_context_is_ready(
-	struct scic_sds_remote_node_context *sci_rnc)
-{
-	u32 current_state = sci_base_state_machine_get_state(&sci_rnc->state_machine);
-
-	if (current_state == SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE) {
-		return true;
-	}
-
-	return false;
-}
-
-/**
- *
- * @sci_dev: The remote device to use to construct the RNC buffer.
- * @rnc: The buffer into which the remote device data will be copied.
- *
- * This method will construct the RNC buffer for this remote device object. none
- */
-static void scic_sds_remote_node_context_construct_buffer(
-	struct scic_sds_remote_node_context *sci_rnc)
-{
-	union scu_remote_node_context *rnc;
-	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
-	struct scic_sds_controller *scic;
-
-	scic = scic_sds_remote_device_get_controller(sci_dev);
-
-	rnc = scic_sds_controller_get_remote_node_context_buffer(
-		scic, sci_rnc->remote_node_index);
-
-	memset(rnc, 0, sizeof(union scu_remote_node_context)
-		* scic_sds_remote_device_node_count(sci_dev));
-
-	rnc->ssp.remote_node_index = sci_rnc->remote_node_index;
-	rnc->ssp.remote_node_port_width = sci_dev->device_port_width;
-	rnc->ssp.logical_port_index =
-		scic_sds_remote_device_get_port_index(sci_dev);
-
-	rnc->ssp.remote_sas_address_hi = SCIC_SWAP_DWORD(sci_dev->device_address.high);
-	rnc->ssp.remote_sas_address_lo = SCIC_SWAP_DWORD(sci_dev->device_address.low);
-
-	rnc->ssp.nexus_loss_timer_enable = true;
-	rnc->ssp.check_bit               = false;
-	rnc->ssp.is_valid                = false;
-	rnc->ssp.is_remote_node_context  = true;
-	rnc->ssp.function_number         = 0;
-
-	rnc->ssp.arbitration_wait_time = 0;
-
-
-	if (
-		sci_dev->target_protocols.u.bits.attached_sata_device
-		|| sci_dev->target_protocols.u.bits.attached_stp_target
-		) {
-		rnc->ssp.connection_occupancy_timeout =
-			scic->user_parameters.sds1.stp_max_occupancy_timeout;
-		rnc->ssp.connection_inactivity_timeout =
-			scic->user_parameters.sds1.stp_inactivity_timeout;
-	} else {
-		rnc->ssp.connection_occupancy_timeout  =
-			scic->user_parameters.sds1.ssp_max_occupancy_timeout;
-		rnc->ssp.connection_inactivity_timeout =
-			scic->user_parameters.sds1.ssp_inactivity_timeout;
-	}
-
-	rnc->ssp.initial_arbitration_wait_time = 0;
-
-	/* Open Address Frame Parameters */
-	rnc->ssp.oaf_connection_rate = sci_dev->connection_rate;
-	rnc->ssp.oaf_features = 0;
-	rnc->ssp.oaf_source_zone_group = 0;
-	rnc->ssp.oaf_more_compatibility_features = 0;
-}
-
-/**
- *
- * @sci_rnc:
- * @callback:
- * @callback_parameter:
- *
- * This method will setup the remote node context object so it will transition
- * to its ready state.  If the remote node context is already setup to
- * transition to its final state then this function does nothing. none
- */
-static void scic_sds_remote_node_context_setup_to_resume(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	if (sci_rnc->destination_state != SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
-		sci_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY;
-		sci_rnc->user_callback     = callback;
-		sci_rnc->user_cookie       = callback_parameter;
-	}
-}
-
-/**
- *
- * @sci_rnc:
- * @callback:
- * @callback_parameter:
- *
- * This method will setup the remote node context object so it will transistion
- * to its final state. none
- */
-static void scic_sds_remote_node_context_setup_to_destory(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	sci_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL;
-	sci_rnc->user_callback     = callback;
-	sci_rnc->user_cookie       = callback_parameter;
-}
-
-/**
- *
- * @sci_rnc:
- * @callback:
- *
- * This method will continue to resume a remote node context.  This is used in
- * the states where a resume is requested while a resume is in progress.
- */
-static enum sci_status scic_sds_remote_node_context_continue_to_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY) {
-		sci_rnc->user_callback = callback;
-		sci_rnc->user_cookie   = callback_parameter;
-
-		return SCI_SUCCESS;
-	}
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-/* --------------------------------------------------------------------------- */
-
-static enum sci_status scic_sds_remote_node_context_default_destruct_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to stop while "
-		 "in unexpected state %d\n",
-		 __func__,
-		 sci_rnc,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	/*
-	 * We have decided that the destruct request on the remote node context can not fail
-	 * since it is either in the initial/destroyed state or is can be destroyed. */
-	return SCI_SUCCESS;
-}
-
-static enum sci_status scic_sds_remote_node_context_default_suspend_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 suspend_type,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to suspend "
-		 "while in wrong state %d\n",
-		 __func__,
-		 sci_rnc,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status scic_sds_remote_node_context_default_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to resume "
-		 "while in wrong state %d\n",
-		 __func__,
-		 sci_rnc,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status scic_sds_remote_node_context_default_start_io_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to start io "
-		 "0x%p while in wrong state %d\n",
-		 __func__,
-		 sci_rnc,
-		 sci_req,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
-}
-
-static enum sci_status scic_sds_remote_node_context_default_start_task_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to start "
-		 "task 0x%p while in wrong state %d\n",
-		 __func__,
-		 sci_rnc,
-		 sci_req,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	return SCI_FAILURE;
-}
-
-static enum sci_status scic_sds_remote_node_context_default_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to process "
-		 "event 0x%x while in wrong state %d\n",
-		 __func__,
-		 sci_rnc,
-		 event_code,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-/**
- *
- * @sci_rnc: The rnc for which the task request is targeted.
- * @sci_req: The request which is going to be started.
- *
- * This method determines if the task request can be started by the SCU
- * hardware. When the RNC is in the ready state any task can be started.
- * enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_node_context_success_start_task_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	return SCI_SUCCESS;
-}
-
-/**
- *
- * @sci_rnc:
- * @callback:
- * @callback_parameter:
- *
- * This method handles destruct calls from the various state handlers.  The
- * remote node context can be requested to destroy from any state. If there was
- * a user callback it is always replaced with the request to destroy user
- * callback. enum sci_status
- */
-static enum sci_status scic_sds_remote_node_context_general_destruct_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	scic_sds_remote_node_context_setup_to_destory(
-		sci_rnc, callback, callback_parameter
-		);
-
-	sci_base_state_machine_change_state(
-		&sci_rnc->state_machine,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
-		);
-
-	return SCI_SUCCESS;
-}
-
-/* --------------------------------------------------------------------------- */
-
-static enum sci_status scic_sds_remote_node_context_initial_state_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	if (sci_rnc->remote_node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
-		scic_sds_remote_node_context_setup_to_resume(
-			sci_rnc, callback, callback_parameter
-			);
-
-		scic_sds_remote_node_context_construct_buffer(sci_rnc);
-
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
-			);
-
-		return SCI_SUCCESS;
-	}
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-/* --------------------------------------------------------------------------- */
-
-static enum sci_status scic_sds_remote_node_context_posting_state_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_POST_RNC_COMPLETE:
-		status = SCI_SUCCESS;
-
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
-			);
-		break;
-
-	default:
-		status = SCI_FAILURE;
-		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: SCIC Remote Node Context 0x%p requested to "
-			 "process unexpected event 0x%x while in posting "
-			 "state\n",
-			 __func__,
-			 sci_rnc,
-			 event_code);
-		break;
-	}
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
-static enum sci_status scic_sds_remote_node_context_invalidating_state_destruct_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	scic_sds_remote_node_context_setup_to_destory(
-		sci_rnc, callback, callback_parameter
-		);
-
-	return SCI_SUCCESS;
-}
-
-static enum sci_status scic_sds_remote_node_context_invalidating_state_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	if (scu_get_event_code(event_code) == SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE) {
-		status = SCI_SUCCESS;
-
-		if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
-			sci_base_state_machine_change_state(
-				&sci_rnc->state_machine,
-				SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
-				);
-		} else {
-			sci_base_state_machine_change_state(
-				&sci_rnc->state_machine,
-				SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
-				);
-		}
-	} else {
-		switch (scu_get_event_type(event_code)) {
-		case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
-		case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
-			/*
-			 * We really dont care if the hardware is going to suspend
-			 * the device since it's being invalidated anyway */
-			dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-				"%s: SCIC Remote Node Context 0x%p was "
-				"suspeneded by hardware while being "
-				"invalidated.\n",
-				__func__,
-				sci_rnc);
-			status = SCI_SUCCESS;
-			break;
-
-		default:
-			dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-				 "%s: SCIC Remote Node Context 0x%p "
-				 "requested to process event 0x%x while "
-				 "in state %d.\n",
-				 __func__,
-				 sci_rnc,
-				 event_code,
-				 sci_base_state_machine_get_state(
-					 &sci_rnc->state_machine));
-			status = SCI_FAILURE;
-			break;
-		}
-	}
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
-
-static enum sci_status scic_sds_remote_node_context_resuming_state_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	if (scu_get_event_code(event_code) == SCU_EVENT_POST_RCN_RELEASE) {
-		status = SCI_SUCCESS;
-
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
-			);
-	} else {
-		switch (scu_get_event_type(event_code)) {
-		case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
-		case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
-			/*
-			 * We really dont care if the hardware is going to suspend
-			 * the device since it's being resumed anyway */
-			dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-				"%s: SCIC Remote Node Context 0x%p was "
-				"suspeneded by hardware while being resumed.\n",
-				__func__,
-				sci_rnc);
-			status = SCI_SUCCESS;
-			break;
-
-		default:
-			dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-				 "%s: SCIC Remote Node Context 0x%p requested "
-				 "to process event 0x%x while in state %d.\n",
-				 __func__,
-				 sci_rnc,
-				 event_code,
-				 sci_base_state_machine_get_state(
-					 &sci_rnc->state_machine));
-			status = SCI_FAILURE;
-			break;
-		}
-	}
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
-/**
- *
- * @sci_rnc: The remote node context object being suspended.
- * @callback: The callback when the suspension is complete.
- * @callback_parameter: The parameter that is to be passed into the callback.
- *
- * This method will handle the suspend requests from the ready state.
- * SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_node_context_ready_state_suspend_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 suspend_type,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	sci_rnc->user_callback   = callback;
-	sci_rnc->user_cookie     = callback_parameter;
-	sci_rnc->suspension_code = suspend_type;
-
-	if (suspend_type == SCI_SOFTWARE_SUSPENSION) {
-		scic_sds_remote_device_post_request(rnc_to_dev(sci_rnc),
-						    SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX);
-	}
-
-	sci_base_state_machine_change_state(
-		&sci_rnc->state_machine,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE
-		);
-
-	return SCI_SUCCESS;
-}
-
-/**
- *
- * @sci_rnc: The rnc for which the io request is targeted.
- * @sci_req: The request which is going to be started.
- *
- * This method determines if the io request can be started by the SCU hardware.
- * When the RNC is in the ready state any io request can be started. enum sci_status
- * SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_node_context_ready_state_start_io_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	return SCI_SUCCESS;
-}
-
-
-static enum sci_status scic_sds_remote_node_context_ready_state_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	switch (scu_get_event_type(event_code)) {
-	case SCU_EVENT_TL_RNC_SUSPEND_TX:
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
-			);
-
-		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
-		status = SCI_SUCCESS;
-		break;
-
-	case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
-			);
-
-		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
-		status = SCI_SUCCESS;
-		break;
-
-	default:
-		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			"%s: SCIC Remote Node Context 0x%p requested to "
-			"process event 0x%x while in state %d.\n",
-			__func__,
-			sci_rnc,
-			event_code,
-			sci_base_state_machine_get_state(
-				&sci_rnc->state_machine));
-
-		status = SCI_FAILURE;
-		break;
-	}
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
-static enum sci_status scic_sds_remote_node_context_tx_suspended_state_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	enum sci_status status;
-	struct smp_discover_response_protocols protocols;
-
-	scic_sds_remote_node_context_setup_to_resume(
-		sci_rnc, callback, callback_parameter
-		);
-
-	/* TODO: consider adding a resume action of NONE, INVALIDATE, WRITE_TLCR */
-
-	scic_remote_device_get_protocols(rnc_to_dev(sci_rnc), &protocols);
-
-	if (
-		(protocols.u.bits.attached_ssp_target == 1)
-		|| (protocols.u.bits.attached_smp_target == 1)
-		) {
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
-			);
-
-		status = SCI_SUCCESS;
-	} else if (protocols.u.bits.attached_stp_target == 1) {
-		if (rnc_to_dev(sci_rnc)->is_direct_attached) {
-			/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
-			sci_base_state_machine_change_state(
-				&sci_rnc->state_machine,
-				SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
-				);
-		} else {
-			sci_base_state_machine_change_state(
-				&sci_rnc->state_machine,
-				SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
-				);
-		}
-
-		status = SCI_SUCCESS;
-	} else {
-		status = SCI_FAILURE;
-	}
-
-	return status;
-}
-
-/**
- *
- * @sci_rnc: The remote node context which is to receive the task request.
- * @sci_req: The task request to be transmitted to to the remote target
- *    device.
- *
- * This method will report a success or failure attempt to start a new task
- * request to the hardware.  Since all task requests are sent on the high
- * priority queue they can be sent when the RCN is in a TX suspend state.
- * enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_node_context_suspended_start_task_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	scic_sds_remote_node_context_resume(sci_rnc, NULL, NULL);
-
-	return SCI_SUCCESS;
-}
-
-/* --------------------------------------------------------------------------- */
-
-static enum sci_status scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	scic_sds_remote_node_context_setup_to_resume(
-		sci_rnc, callback, callback_parameter
-		);
-
-	sci_base_state_machine_change_state(
-		&sci_rnc->state_machine,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
-		);
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-/* --------------------------------------------------------------------------- */
-
-/**
- *
- *
- *
- */
-static enum sci_status scic_sds_remote_node_context_await_suspension_state_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	scic_sds_remote_node_context_setup_to_resume(
-		sci_rnc, callback, callback_parameter
-		);
-
-	return SCI_SUCCESS;
-}
-
-/**
- *
- * @sci_rnc: The remote node context which is to receive the task request.
- * @sci_req: The task request to be transmitted to to the remote target
- *    device.
- *
- * This method will report a success or failure attempt to start a new task
- * request to the hardware.  Since all task requests are sent on the high
- * priority queue they can be sent when the RCN is in a TX suspend state.
- * enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_node_context_await_suspension_state_start_task_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	return SCI_SUCCESS;
-}
-
-static enum sci_status scic_sds_remote_node_context_await_suspension_state_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	switch (scu_get_event_type(event_code)) {
-	case SCU_EVENT_TL_RNC_SUSPEND_TX:
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
-			);
-
-		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
-		status = SCI_SUCCESS;
-		break;
-
-	case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
-			);
-
-		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
-		status = SCI_SUCCESS;
-		break;
-
-	default:
-		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: SCIC Remote Node Context 0x%p requested to "
-			 "process event 0x%x while in state %d.\n",
-			 __func__,
-			 sci_rnc,
-			 event_code,
-			 sci_base_state_machine_get_state(
-				 &sci_rnc->state_machine));
-
-		status = SCI_FAILURE;
-		break;
-	}
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
-static struct scic_sds_remote_node_context_handlers
-scic_sds_remote_node_context_state_handler_table[
-	SCIC_SDS_REMOTE_NODE_CONTEXT_MAX_STATES] =
-{
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE */
-	{
-		scic_sds_remote_node_context_default_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_initial_state_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_default_start_task_handler,
-		scic_sds_remote_node_context_default_event_handler
-	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_continue_to_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_default_start_task_handler,
-		scic_sds_remote_node_context_posting_state_event_handler
-	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE */
-	{
-		scic_sds_remote_node_context_invalidating_state_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_continue_to_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_default_start_task_handler,
-		scic_sds_remote_node_context_invalidating_state_event_handler
-	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_continue_to_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_success_start_task_handler,
-		scic_sds_remote_node_context_resuming_state_event_handler
-	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_ready_state_suspend_handler,
-		scic_sds_remote_node_context_default_resume_handler,
-		scic_sds_remote_node_context_ready_state_start_io_handler,
-		scic_sds_remote_node_context_success_start_task_handler,
-		scic_sds_remote_node_context_ready_state_event_handler
-	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_tx_suspended_state_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_suspended_start_task_handler,
-		scic_sds_remote_node_context_default_event_handler
-	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_suspended_start_task_handler,
-		scic_sds_remote_node_context_default_event_handler
-	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_await_suspension_state_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_await_suspension_state_start_task_handler,
-		scic_sds_remote_node_context_await_suspension_state_event_handler
-	}
-};
-
-/*
- * *****************************************************************************
- * * REMOTE NODE CONTEXT PRIVATE METHODS
- * ***************************************************************************** */
-
-/**
- *
- *
- * This method just calls the user callback function and then resets the
- * callback.
- */
-static void scic_sds_remote_node_context_notify_user(
-	struct scic_sds_remote_node_context *rnc)
-{
-	if (rnc->user_callback != NULL) {
-		(*rnc->user_callback)(rnc->user_cookie);
-
-		rnc->user_callback = NULL;
-		rnc->user_cookie = NULL;
-	}
-}
-
-/**
- *
- *
- * This method will continue the remote node context state machine by
- * requesting to resume the remote node context state machine from its current
- * state.
- */
-static void scic_sds_remote_node_context_continue_state_transitions(
-	struct scic_sds_remote_node_context *rnc)
-{
-	if (rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY) {
-		rnc->state_handlers->resume_handler(
-			rnc, rnc->user_callback, rnc->user_cookie
-			);
-	}
-}
-
-/**
- *
- * @sci_rnc: The remote node context object that is to be validated.
- *
- * This method will mark the rnc buffer as being valid and post the request to
- * the hardware. none
- */
-static void scic_sds_remote_node_context_validate_context_buffer(
-	struct scic_sds_remote_node_context *sci_rnc)
-{
-	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
-	union scu_remote_node_context *rnc_buffer;
-
-	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
-		scic_sds_remote_device_get_controller(sci_dev),
-		sci_rnc->remote_node_index
-		);
-
-	rnc_buffer->ssp.is_valid = true;
-
-	if (!sci_dev->is_direct_attached &&
-	    sci_dev->target_protocols.u.bits.attached_stp_target) {
-		scic_sds_remote_device_post_request(sci_dev,
-						    SCU_CONTEXT_COMMAND_POST_RNC_96);
-	} else {
-		scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_32);
-
-		if (sci_dev->is_direct_attached) {
-			scic_sds_port_setup_transports(sci_dev->owning_port,
-						       sci_rnc->remote_node_index);
-		}
-	}
-}
-
-/**
- *
- * @sci_rnc: The remote node context object that is to be invalidated.
- *
- * This method will update the RNC buffer and post the invalidate request. none
- */
-static void scic_sds_remote_node_context_invalidate_context_buffer(
-	struct scic_sds_remote_node_context *sci_rnc)
-{
-	union scu_remote_node_context *rnc_buffer;
-
-	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
-		scic_sds_remote_device_get_controller(rnc_to_dev(sci_rnc)),
-		sci_rnc->remote_node_index);
-
-	rnc_buffer->ssp.is_valid = false;
-
-	scic_sds_remote_device_post_request(rnc_to_dev(sci_rnc),
-					    SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE);
-}
-
-/*
- * *****************************************************************************
- * * REMOTE NODE CONTEXT STATE ENTER AND EXIT METHODS
- * ***************************************************************************** */
-
-/**
- *
- *
- *
- */
-static void scic_sds_remote_node_context_initial_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
-
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
-		);
-
-	/*
-	 * Check to see if we have gotten back to the initial state because someone
-	 * requested to destroy the remote node context object. */
-	if (
-		rnc->state_machine.previous_state_id
-		== SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
-		) {
-		rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
-
-		scic_sds_remote_node_context_notify_user(rnc);
-	}
-}
-
-/**
- *
- *
- *
- */
-static void scic_sds_remote_node_context_posting_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_node_context *sci_rnc;
-
-	sci_rnc = (struct scic_sds_remote_node_context *)object;
-
-	SET_STATE_HANDLER(
-		sci_rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
-		);
-
-	scic_sds_remote_node_context_validate_context_buffer(sci_rnc);
-}
-
-/**
- *
- *
- *
- */
-static void scic_sds_remote_node_context_invalidating_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
-
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
-		);
-
-	scic_sds_remote_node_context_invalidate_context_buffer(rnc);
-}
-
-/**
- *
- *
- *
- */
-static void scic_sds_remote_node_context_resuming_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_node_context *rnc;
-	struct smp_discover_response_protocols protocols;
-	struct scic_sds_remote_device *sci_dev;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
-	sci_dev = rnc_to_dev(rnc);
-
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
-		);
-
-	/*
-	 * For direct attached SATA devices we need to clear the TLCR
-	 * NCQ to TCi tag mapping on the phy and in cases where we
-	 * resume because of a target reset we also need to update
-	 * the STPTLDARNI register with the RNi of the device
-	 */
-	scic_remote_device_get_protocols(sci_dev, &protocols);
-
-	if (protocols.u.bits.attached_stp_target == 1 &&
-	    sci_dev->is_direct_attached) {
-		scic_sds_port_setup_transports(sci_dev->owning_port,
-					       rnc->remote_node_index);
-	}
-
-	scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
-}
-
-/**
- *
- *
- *
- */
-static void scic_sds_remote_node_context_ready_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
-
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
-		);
-
-	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
-
-	if (rnc->user_callback != NULL) {
-		scic_sds_remote_node_context_notify_user(rnc);
-	}
-}
-
-/**
- *
- *
- *
- */
-static void scic_sds_remote_node_context_tx_suspended_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
-
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
-		);
-
-	scic_sds_remote_node_context_continue_state_transitions(rnc);
-}
-
-/**
- *
- *
- *
- */
-static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
-
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
-		);
-
-	scic_sds_remote_node_context_continue_state_transitions(rnc);
-}
-
-/**
- *
- *
- *
- */
-static void scic_sds_remote_node_context_await_suspension_state_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
-
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE
-		);
-}
-
-/* --------------------------------------------------------------------------- */
-
-static const struct sci_base_state scic_sds_remote_node_context_state_table[] = {
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE] = {
-		.enter_state = scic_sds_remote_node_context_initial_state_enter,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE] = {
-		.enter_state = scic_sds_remote_node_context_posting_state_enter,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE] = {
-		.enter_state = scic_sds_remote_node_context_invalidating_state_enter,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE] = {
-		.enter_state = scic_sds_remote_node_context_resuming_state_enter,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE] = {
-		.enter_state = scic_sds_remote_node_context_ready_state_enter,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE] = {
-		.enter_state = scic_sds_remote_node_context_tx_suspended_state_enter,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE] = {
-		.enter_state = scic_sds_remote_node_context_tx_rx_suspended_state_enter,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = {
-		.enter_state = scic_sds_remote_node_context_await_suspension_state_enter,
-	},
-};
-
-void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context *rnc,
-					    u16 remote_node_index)
-{
-	memset(rnc, 0, sizeof(struct scic_sds_remote_node_context));
-
-	rnc->remote_node_index = remote_node_index;
-	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
-
-	sci_base_state_machine_construct(
-		&rnc->state_machine,
-		&rnc->parent,
-		scic_sds_remote_node_context_state_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
-		);
-
-	sci_base_state_machine_start(&rnc->state_machine);
-}
diff --git a/drivers/scsi/isci/core/scic_sds_remote_node_context.h b/drivers/scsi/isci/core/scic_sds_remote_node_context.h
deleted file mode 100644
index b3f2546..0000000
--- a/drivers/scsi/isci/core/scic_sds_remote_node_context.h
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCIC_SDS_REMOTE_NODE_CONTEXT_H_
-#define _SCIC_SDS_REMOTE_NODE_CONTEXT_H_
-
-/**
- * This file contains the structures, constants, and prototypes associated with
- *    the remote node context in the silicon.  It exists to model and manage
- *    the remote node context in the silicon.
- *
- *
- */
-
-#include "sci_base_state.h"
-#include "sci_base_state_machine.h"
-
-/**
- *
- *
- * This constant represents an invalid remote device id, it is used to program
- * the STPDARNI register so the driver knows when it has received a SIGNATURE
- * FIS from the SCU.
- */
-#define SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX    0x0FFF
-
-#define SCU_HARDWARE_SUSPENSION  (0)
-#define SCI_SOFTWARE_SUSPENSION  (1)
-
-struct scic_sds_request;
-struct scic_sds_remote_device;
-struct scic_sds_remote_node_context;
-
-typedef void (*scics_sds_remote_node_context_callback)(void *);
-
-typedef enum sci_status (*scic_sds_remote_node_context_operation)(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter
-	);
-
-typedef enum sci_status (*scic_sds_remote_node_context_suspend_operation)(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 suspension_type,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter
-	);
-
-typedef enum sci_status (*scic_sds_remote_node_context_io_request)(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req
-	);
-
-typedef enum sci_status (*scic_sds_remote_node_context_event_handler)(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code
-	);
-
-struct scic_sds_remote_node_context_handlers {
-	/**
-	 * This handle is invoked to stop the RNC.  The callback is invoked when after
-	 * the hardware notification that the RNC has been invalidated.
-	 */
-	scic_sds_remote_node_context_operation destruct_handler;
-
-	/**
-	 * This handler is invoked when there is a request to suspend  the RNC.  The
-	 * callback is invoked after the hardware notification that the remote node is
-	 * suspended.
-	 */
-	scic_sds_remote_node_context_suspend_operation suspend_handler;
-
-	/**
-	 * This handler is invoked when there is a request to resume the RNC.  The
-	 * callback is invoked when after the RNC has reached the ready state.
-	 */
-	scic_sds_remote_node_context_operation resume_handler;
-
-	/**
-	 * This handler is invoked when there is a request to start an io request
-	 * operation.
-	 */
-	scic_sds_remote_node_context_io_request start_io_handler;
-
-	/**
-	 * This handler is invoked when there is a request to start a task request
-	 * operation.
-	 */
-	scic_sds_remote_node_context_io_request start_task_handler;
-
-	/**
-	 * This handler is invoked where there is an RNC event that must be processed.
-	 */
-	scic_sds_remote_node_context_event_handler event_handler;
-
-};
-
-/**
- * This is the enumeration of the remote node context states.
- */
-enum scis_sds_remote_node_context_states {
-	/**
-	 * This state is the initial state for a remote node context.  On a resume
-	 * request the remote node context will transition to the posting state.
-	 */
-	SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE,
-
-	/**
-	 * This is a transition state that posts the RNi to the hardware. Once the RNC
-	 * is posted the remote node context will be made ready.
-	 */
-	SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE,
-
-	/**
-	 * This is a transition state that will post an RNC invalidate to the
-	 * hardware.  Once the invalidate is complete the remote node context will
-	 * transition to the posting state.
-	 */
-	SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE,
-
-	/**
-	 * This is a transition state that will post an RNC resume to the hardare.
-	 * Once the event notification of resume complete is received the remote node
-	 * context will transition to the ready state.
-	 */
-	SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE,
-
-	/**
-	 * This is the state that the remote node context must be in to accept io
-	 * request operations.
-	 */
-	SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE,
-
-	/**
-	 * This is the state that the remote node context transitions to when it gets
-	 * a TX suspend notification from the hardware.
-	 */
-	SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE,
-
-	/**
-	 * This is the state that the remote node context transitions to when it gets
-	 * a TX RX suspend notification from the hardware.
-	 */
-	SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE,
-
-	/**
-	 * This state is a wait state for the remote node context that waits for a
-	 * suspend notification from the hardware.  This state is entered when either
-	 * there is a request to supend the remote node context or when there is a TC
-	 * completion where the remote node will be suspended by the hardware.
-	 */
-	SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE,
-
-	SCIC_SDS_REMOTE_NODE_CONTEXT_MAX_STATES
-
-};
-
-/**
- *
- *
- * This enumeration is used to define the end destination state for the remote
- * node context.
- */
-enum scic_sds_remote_node_context_destination_state {
-	SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED,
-	SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY,
-	SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL
-};
-
-/**
- * struct scic_sds_remote_node_context - This structure contains the data
- *    associated with the remote node context object.  The remote node context
- *    (RNC) object models the the remote device information necessary to manage
- *    the silicon RNC.
- */
-struct scic_sds_remote_node_context {
-	/*
-	 * parent object
-	 */
-	struct sci_base_object parent;
-
-	/**
-	 * This field indicates the remote node index (RNI) associated with
-	 * this RNC.
-	 */
-	u16 remote_node_index;
-
-	/**
-	 * This field is the recored suspension code or the reason for the remote node
-	 * context suspension.
-	 */
-	u32 suspension_code;
-
-	/**
-	 * This field is true if the remote node context is resuming from its current
-	 * state.  This can cause an automatic resume on receiving a suspension
-	 * notification.
-	 */
-	enum scic_sds_remote_node_context_destination_state destination_state;
-
-	/**
-	 * This field contains the callback function that the user requested to be
-	 * called when the requested state transition is complete.
-	 */
-	scics_sds_remote_node_context_callback user_callback;
-
-	/**
-	 * This field contains the parameter that is called when the user requested
-	 * state transition is completed.
-	 */
-	void *user_cookie;
-
-	/**
-	 * This field contains the data for the object's state machine.
-	 */
-	struct sci_base_state_machine state_machine;
-
-	struct scic_sds_remote_node_context_handlers *state_handlers;
-};
-
-void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context *rnc,
-					    u16 remote_node_index);
-
-
-bool scic_sds_remote_node_context_is_ready(
-	struct scic_sds_remote_node_context *sci_rnc);
-
-#define scic_sds_remote_node_context_get_remote_node_index(rcn)	\
-	((rnc)->remote_node_index)
-
-#define scic_sds_remote_node_context_event_handler(rnc, event_code) \
-	((rnc)->state_handlers->event_handler(rnc, event_code))
-
-#define scic_sds_remote_node_context_resume(rnc, callback, parameter) \
-	((rnc)->state_handlers->resume_handler(rnc, callback, parameter))
-
-#define scic_sds_remote_node_context_suspend(rnc, suspend_type, callback, parameter) \
-	((rnc)->state_handlers->suspend_handler(rnc, suspend_type, callback, parameter))
-
-#define scic_sds_remote_node_context_destruct(rnc, callback, parameter)	\
-	((rnc)->state_handlers->destruct_handler(rnc, callback, parameter))
-
-#define scic_sds_remote_node_context_start_io(rnc, request) \
-	((rnc)->state_handlers->start_io_handler(rnc, request))
-
-#define scic_sds_remote_node_context_start_task(rnc, task) \
-	((rnc)->state_handlers->start_task_handler(rnc, task))
-
-#endif  /* _SCIC_SDS_REMOTE_NODE_CONTEXT_H_ */
diff --git a/drivers/scsi/isci/core/scic_sds_remote_node_table.c b/drivers/scsi/isci/core/scic_sds_remote_node_table.c
deleted file mode 100644
index 77919a2..0000000
--- a/drivers/scsi/isci/core/scic_sds_remote_node_table.c
+++ /dev/null
@@ -1,600 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * This file contains the implementation of the SCIC_SDS_REMOTE_NODE_TABLE
- *    public, protected, and private methods.
- *
- *
- */
-#include "sci_util.h"
-#include "sci_environment.h"
-#include "scic_sds_remote_node_table.h"
-#include "scic_sds_remote_node_context.h"
-
-/**
- *
- * @remote_node_table: This is the remote node index table from which the
- *    selection will be made.
- * @group_table_index: This is the index to the group table from which to
- *    search for an available selection.
- *
- * This routine will find the bit position in absolute bit terms of the next 32
- * + bit position.  If there are available bits in the first u32 then it is
- * just bit position. u32 This is the absolute bit position for an available
- * group.
- */
-static u32 scic_sds_remote_node_table_get_group_index(
-	struct scic_remote_node_table *remote_node_table,
-	u32 group_table_index)
-{
-	u32 dword_index;
-	u32 *group_table;
-	u32 bit_index;
-
-	group_table = remote_node_table->remote_node_groups[group_table_index];
-
-	for (dword_index = 0; dword_index < remote_node_table->group_array_size; dword_index++) {
-		if (group_table[dword_index] != 0) {
-			for (bit_index = 0; bit_index < 32; bit_index++) {
-				if ((group_table[dword_index] & (1 << bit_index)) != 0) {
-					return (dword_index * 32) + bit_index;
-				}
-			}
-		}
-	}
-
-	return SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX;
-}
-
-/**
- *
- * @out]: remote_node_table This the remote node table in which to clear the
- *    selector.
- * @set_index: This is the remote node selector in which the change will be
- *    made.
- * @group_index: This is the bit index in the table to be modified.
- *
- * This method will clear the group index entry in the specified group index
- * table. none
- */
-static void scic_sds_remote_node_table_clear_group_index(
-	struct scic_remote_node_table *remote_node_table,
-	u32 group_table_index,
-	u32 group_index)
-{
-	u32 dword_index;
-	u32 bit_index;
-	u32 *group_table;
-
-	BUG_ON(group_table_index >= SCU_STP_REMOTE_NODE_COUNT);
-	BUG_ON(group_index >= (u32)(remote_node_table->group_array_size * 32));
-
-	dword_index = group_index / 32;
-	bit_index   = group_index % 32;
-	group_table = remote_node_table->remote_node_groups[group_table_index];
-
-	group_table[dword_index] = group_table[dword_index] & ~(1 << bit_index);
-}
-
-/**
- *
- * @out]: remote_node_table This the remote node table in which to set the
- *    selector.
- * @group_table_index: This is the remote node selector in which the change
- *    will be made.
- * @group_index: This is the bit position in the table to be modified.
- *
- * This method will set the group index bit entry in the specified gropu index
- * table. none
- */
-static void scic_sds_remote_node_table_set_group_index(
-	struct scic_remote_node_table *remote_node_table,
-	u32 group_table_index,
-	u32 group_index)
-{
-	u32 dword_index;
-	u32 bit_index;
-	u32 *group_table;
-
-	BUG_ON(group_table_index >= SCU_STP_REMOTE_NODE_COUNT);
-	BUG_ON(group_index >= (u32)(remote_node_table->group_array_size * 32));
-
-	dword_index = group_index / 32;
-	bit_index   = group_index % 32;
-	group_table = remote_node_table->remote_node_groups[group_table_index];
-
-	group_table[dword_index] = group_table[dword_index] | (1 << bit_index);
-}
-
-/**
- *
- * @out]: remote_node_table This is the remote node table in which to modify
- *    the remote node availability.
- * @remote_node_index: This is the remote node index that is being returned to
- *    the table.
- *
- * This method will set the remote to available in the remote node allocation
- * table. none
- */
-static void scic_sds_remote_node_table_set_node_index(
-	struct scic_remote_node_table *remote_node_table,
-	u32 remote_node_index)
-{
-	u32 dword_location;
-	u32 dword_remainder;
-	u32 slot_normalized;
-	u32 slot_position;
-
-	BUG_ON(
-		(remote_node_table->available_nodes_array_size * SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD)
-		<= (remote_node_index / SCU_STP_REMOTE_NODE_COUNT)
-		);
-
-	dword_location  = remote_node_index / SCIC_SDS_REMOTE_NODES_PER_DWORD;
-	dword_remainder = remote_node_index % SCIC_SDS_REMOTE_NODES_PER_DWORD;
-	slot_normalized = (dword_remainder / SCU_STP_REMOTE_NODE_COUNT) * sizeof(u32);
-	slot_position   = remote_node_index % SCU_STP_REMOTE_NODE_COUNT;
-
-	remote_node_table->available_remote_nodes[dword_location] |=
-		1 << (slot_normalized + slot_position);
-}
-
-/**
- *
- * @out]: remote_node_table This is the remote node table from which to clear
- *    the available remote node bit.
- * @remote_node_index: This is the remote node index which is to be cleared
- *    from the table.
- *
- * This method clears the remote node index from the table of available remote
- * nodes. none
- */
-static void scic_sds_remote_node_table_clear_node_index(
-	struct scic_remote_node_table *remote_node_table,
-	u32 remote_node_index)
-{
-	u32 dword_location;
-	u32 dword_remainder;
-	u32 slot_position;
-	u32 slot_normalized;
-
-	BUG_ON(
-		(remote_node_table->available_nodes_array_size * SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD)
-		<= (remote_node_index / SCU_STP_REMOTE_NODE_COUNT)
-		);
-
-	dword_location  = remote_node_index / SCIC_SDS_REMOTE_NODES_PER_DWORD;
-	dword_remainder = remote_node_index % SCIC_SDS_REMOTE_NODES_PER_DWORD;
-	slot_normalized = (dword_remainder / SCU_STP_REMOTE_NODE_COUNT) * sizeof(u32);
-	slot_position   = remote_node_index % SCU_STP_REMOTE_NODE_COUNT;
-
-	remote_node_table->available_remote_nodes[dword_location] &=
-		~(1 << (slot_normalized + slot_position));
-}
-
-/**
- *
- * @out]: remote_node_table The remote node table from which the slot will be
- *    cleared.
- * @group_index: The index for the slot that is to be cleared.
- *
- * This method clears the entire table slot at the specified slot index. none
- */
-static void scic_sds_remote_node_table_clear_group(
-	struct scic_remote_node_table *remote_node_table,
-	u32 group_index)
-{
-	u32 dword_location;
-	u32 dword_remainder;
-	u32 dword_value;
-
-	BUG_ON(
-		(remote_node_table->available_nodes_array_size * SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD)
-		<= (group_index / SCU_STP_REMOTE_NODE_COUNT)
-		);
-
-	dword_location  = group_index / SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
-	dword_remainder = group_index % SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
-
-	dword_value = remote_node_table->available_remote_nodes[dword_location];
-	dword_value &= ~(SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE << (dword_remainder * 4));
-	remote_node_table->available_remote_nodes[dword_location] = dword_value;
-}
-
-/**
- *
- * @remote_node_table:
- *
- * THis method sets an entire remote node group in the remote node table.
- */
-static void scic_sds_remote_node_table_set_group(
-	struct scic_remote_node_table *remote_node_table,
-	u32 group_index)
-{
-	u32 dword_location;
-	u32 dword_remainder;
-	u32 dword_value;
-
-	BUG_ON(
-		(remote_node_table->available_nodes_array_size * SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD)
-		<= (group_index / SCU_STP_REMOTE_NODE_COUNT)
-		);
-
-	dword_location  = group_index / SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
-	dword_remainder = group_index % SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
-
-	dword_value = remote_node_table->available_remote_nodes[dword_location];
-	dword_value |= (SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE << (dword_remainder * 4));
-	remote_node_table->available_remote_nodes[dword_location] = dword_value;
-}
-
-/**
- *
- * @remote_node_table: This is the remote node table that for which the group
- *    value is to be returned.
- * @group_index: This is the group index to use to find the group value.
- *
- * This method will return the group value for the specified group index. The
- * bit values at the specified remote node group index.
- */
-static u8 scic_sds_remote_node_table_get_group_value(
-	struct scic_remote_node_table *remote_node_table,
-	u32 group_index)
-{
-	u32 dword_location;
-	u32 dword_remainder;
-	u32 dword_value;
-
-	dword_location  = group_index / SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
-	dword_remainder = group_index % SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
-
-	dword_value = remote_node_table->available_remote_nodes[dword_location];
-	dword_value &= (SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE << (dword_remainder * 4));
-	dword_value = dword_value >> (dword_remainder * 4);
-
-	return (u8)dword_value;
-}
-
-/**
- *
- * @out]: remote_node_table The remote that which is to be initialized.
- * @remote_node_entries: The number of entries to put in the table.
- *
- * This method will initialize the remote node table for use. none
- */
-void scic_sds_remote_node_table_initialize(
-	struct scic_remote_node_table *remote_node_table,
-	u32 remote_node_entries)
-{
-	u32 index;
-
-	/*
-	 * Initialize the raw data we could improve the speed by only initializing
-	 * those entries that we are actually going to be used */
-	memset(
-		remote_node_table->available_remote_nodes,
-		0x00,
-		sizeof(remote_node_table->available_remote_nodes)
-		);
-
-	memset(
-		remote_node_table->remote_node_groups,
-		0x00,
-		sizeof(remote_node_table->remote_node_groups)
-		);
-
-	/* Initialize the available remote node sets */
-	remote_node_table->available_nodes_array_size = (u16)
-							(remote_node_entries / SCIC_SDS_REMOTE_NODES_PER_DWORD)
-							+ ((remote_node_entries % SCIC_SDS_REMOTE_NODES_PER_DWORD) != 0);
-
-
-	/* Initialize each full DWORD to a FULL SET of remote nodes */
-	for (index = 0; index < remote_node_entries; index++) {
-		scic_sds_remote_node_table_set_node_index(remote_node_table, index);
-	}
-
-	remote_node_table->group_array_size = (u16)
-					      (remote_node_entries / (SCU_STP_REMOTE_NODE_COUNT * 32))
-					      + ((remote_node_entries % (SCU_STP_REMOTE_NODE_COUNT * 32)) != 0);
-
-	for (index = 0; index < (remote_node_entries / SCU_STP_REMOTE_NODE_COUNT); index++) {
-		/*
-		 * These are all guaranteed to be full slot values so fill them in the
-		 * available sets of 3 remote nodes */
-		scic_sds_remote_node_table_set_group_index(remote_node_table, 2, index);
-	}
-
-	/* Now fill in any remainders that we may find */
-	if ((remote_node_entries % SCU_STP_REMOTE_NODE_COUNT) == 2) {
-		scic_sds_remote_node_table_set_group_index(remote_node_table, 1, index);
-	} else if ((remote_node_entries % SCU_STP_REMOTE_NODE_COUNT) == 1) {
-		scic_sds_remote_node_table_set_group_index(remote_node_table, 0, index);
-	}
-}
-
-/**
- *
- * @out]: remote_node_table The remote node table from which to allocate a
- *    remote node.
- * @table_index: The group index that is to be used for the search.
- *
- * This method will allocate a single RNi from the remote node table.  The
- * table index will determine from which remote node group table to search.
- * This search may fail and another group node table can be specified.  The
- * function is designed to allow a serach of the available single remote node
- * group up to the triple remote node group.  If an entry is found in the
- * specified table the remote node is removed and the remote node groups are
- * updated. The RNi value or an invalid remote node context if an RNi can not
- * be found.
- */
-static u16 scic_sds_remote_node_table_allocate_single_remote_node(
-	struct scic_remote_node_table *remote_node_table,
-	u32 group_table_index)
-{
-	u8 index;
-	u8 group_value;
-	u32 group_index;
-	u16 remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
-
-	group_index = scic_sds_remote_node_table_get_group_index(
-		remote_node_table, group_table_index);
-
-	/* We could not find an available slot in the table selector 0 */
-	if (group_index != SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX) {
-		group_value = scic_sds_remote_node_table_get_group_value(
-			remote_node_table, group_index);
-
-		for (index = 0; index < SCU_STP_REMOTE_NODE_COUNT; index++) {
-			if (((1 << index) & group_value) != 0) {
-				/* We have selected a bit now clear it */
-				remote_node_index = (u16)(group_index * SCU_STP_REMOTE_NODE_COUNT
-							  + index);
-
-				scic_sds_remote_node_table_clear_group_index(
-					remote_node_table, group_table_index, group_index
-					);
-
-				scic_sds_remote_node_table_clear_node_index(
-					remote_node_table, remote_node_index
-					);
-
-				if (group_table_index > 0) {
-					scic_sds_remote_node_table_set_group_index(
-						remote_node_table, group_table_index - 1, group_index
-						);
-				}
-
-				break;
-			}
-		}
-	}
-
-	return remote_node_index;
-}
-
-/**
- *
- * @remote_node_table: This is the remote node table from which to allocate the
- *    remote node entries.
- * @group_table_index: THis is the group table index which must equal two (2)
- *    for this operation.
- *
- * This method will allocate three consecutive remote node context entries. If
- * there are no remaining triple entries the function will return a failure.
- * The remote node index that represents three consecutive remote node entries
- * or an invalid remote node context if none can be found.
- */
-static u16 scic_sds_remote_node_table_allocate_triple_remote_node(
-	struct scic_remote_node_table *remote_node_table,
-	u32 group_table_index)
-{
-	u32 group_index;
-	u16 remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
-
-	group_index = scic_sds_remote_node_table_get_group_index(
-		remote_node_table, group_table_index);
-
-	if (group_index != SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX) {
-		remote_node_index = (u16)group_index * SCU_STP_REMOTE_NODE_COUNT;
-
-		scic_sds_remote_node_table_clear_group_index(
-			remote_node_table, group_table_index, group_index
-			);
-
-		scic_sds_remote_node_table_clear_group(
-			remote_node_table, group_index
-			);
-	}
-
-	return remote_node_index;
-}
-
-/**
- *
- * @remote_node_table: This is the remote node table from which the remote node
- *    allocation is to take place.
- * @remote_node_count: This is ther remote node count which is one of
- *    SCU_SSP_REMOTE_NODE_COUNT(1) or SCU_STP_REMOTE_NODE_COUNT(3).
- *
- * This method will allocate a remote node that mataches the remote node count
- * specified by the caller.  Valid values for remote node count is
- * SCU_SSP_REMOTE_NODE_COUNT(1) or SCU_STP_REMOTE_NODE_COUNT(3). u16 This is
- * the remote node index that is returned or an invalid remote node context.
- */
-u16 scic_sds_remote_node_table_allocate_remote_node(
-	struct scic_remote_node_table *remote_node_table,
-	u32 remote_node_count)
-{
-	u16 remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
-
-	if (remote_node_count == SCU_SSP_REMOTE_NODE_COUNT) {
-		remote_node_index =
-			scic_sds_remote_node_table_allocate_single_remote_node(
-				remote_node_table, 0);
-
-		if (remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
-			remote_node_index =
-				scic_sds_remote_node_table_allocate_single_remote_node(
-					remote_node_table, 1);
-		}
-
-		if (remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
-			remote_node_index =
-				scic_sds_remote_node_table_allocate_single_remote_node(
-					remote_node_table, 2);
-		}
-	} else if (remote_node_count == SCU_STP_REMOTE_NODE_COUNT) {
-		remote_node_index =
-			scic_sds_remote_node_table_allocate_triple_remote_node(
-				remote_node_table, 2);
-	}
-
-	return remote_node_index;
-}
-
-/**
- *
- * @remote_node_table:
- *
- * This method will free a single remote node index back to the remote node
- * table.  This routine will update the remote node groups
- */
-static void scic_sds_remote_node_table_release_single_remote_node(
-	struct scic_remote_node_table *remote_node_table,
-	u16 remote_node_index)
-{
-	u32 group_index;
-	u8 group_value;
-
-	group_index = remote_node_index / SCU_STP_REMOTE_NODE_COUNT;
-
-	group_value = scic_sds_remote_node_table_get_group_value(remote_node_table, group_index);
-
-	/*
-	 * Assert that we are not trying to add an entry to a slot that is already
-	 * full. */
-	BUG_ON(group_value == SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE);
-
-	if (group_value == 0x00) {
-		/*
-		 * There are no entries in this slot so it must be added to the single
-		 * slot table. */
-		scic_sds_remote_node_table_set_group_index(remote_node_table, 0, group_index);
-	} else if ((group_value & (group_value - 1)) == 0) {
-		/*
-		 * There is only one entry in this slot so it must be moved from the
-		 * single slot table to the dual slot table */
-		scic_sds_remote_node_table_clear_group_index(remote_node_table, 0, group_index);
-		scic_sds_remote_node_table_set_group_index(remote_node_table, 1, group_index);
-	} else {
-		/*
-		 * There are two entries in the slot so it must be moved from the dual
-		 * slot table to the tripple slot table. */
-		scic_sds_remote_node_table_clear_group_index(remote_node_table, 1, group_index);
-		scic_sds_remote_node_table_set_group_index(remote_node_table, 2, group_index);
-	}
-
-	scic_sds_remote_node_table_set_node_index(remote_node_table, remote_node_index);
-}
-
-/**
- *
- * @remote_node_table: This is the remote node table to which the remote node
- *    index is to be freed.
- *
- * This method will release a group of three consecutive remote nodes back to
- * the free remote nodes.
- */
-static void scic_sds_remote_node_table_release_triple_remote_node(
-	struct scic_remote_node_table *remote_node_table,
-	u16 remote_node_index)
-{
-	u32 group_index;
-
-	group_index = remote_node_index / SCU_STP_REMOTE_NODE_COUNT;
-
-	scic_sds_remote_node_table_set_group_index(
-		remote_node_table, 2, group_index
-		);
-
-	scic_sds_remote_node_table_set_group(remote_node_table, group_index);
-}
-
-/**
- *
- * @remote_node_table: The remote node table to which the remote node index is
- *    to be freed.
- * @remote_node_count: This is the count of consecutive remote nodes that are
- *    to be freed.
- *
- * This method will release the remote node index back into the remote node
- * table free pool.
- */
-void scic_sds_remote_node_table_release_remote_node_index(
-	struct scic_remote_node_table *remote_node_table,
-	u32 remote_node_count,
-	u16 remote_node_index)
-{
-	if (remote_node_count == SCU_SSP_REMOTE_NODE_COUNT) {
-		scic_sds_remote_node_table_release_single_remote_node(
-			remote_node_table, remote_node_index);
-	} else if (remote_node_count == SCU_STP_REMOTE_NODE_COUNT) {
-		scic_sds_remote_node_table_release_triple_remote_node(
-			remote_node_table, remote_node_index);
-	}
-}
-
diff --git a/drivers/scsi/isci/core/scic_sds_remote_node_table.h b/drivers/scsi/isci/core/scic_sds_remote_node_table.h
deleted file mode 100644
index 9c02a6c..0000000
--- a/drivers/scsi/isci/core/scic_sds_remote_node_table.h
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCIC_SDS_REMOTE_NODE_TABLE_H_
-#define _SCIC_SDS_REMOTE_NODE_TABLE_H_
-
-/**
- * This file contains the structures, constants and prototypes used for the
- *    remote node table.
- *
- *
- */
-
-#include "sci_controller_constants.h"
-
-/**
- *
- *
- * Remote node sets are sets of remote node index in the remtoe node table The
- * SCU hardware requires that STP remote node entries take three consecutive
- * remote node index so the table is arranged in sets of three. The bits are
- * used as 0111 0111 to make a byte and the bits define the set of three remote
- * nodes to use as a sequence.
- */
-#define SCIC_SDS_REMOTE_NODE_SETS_PER_BYTE 2
-
-/**
- *
- *
- * Since the remote node table is organized as DWORDS take the remote node sets
- * in bytes and represent them in DWORDs. The lowest ordered bits are the ones
- * used in case full DWORD is not being used. i.e. 0000 0000 0000 0000 0111
- * 0111 0111 0111 // if only a single WORD is in use in the DWORD.
- */
-#define SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD \
-	(sizeof(u32) * SCIC_SDS_REMOTE_NODE_SETS_PER_BYTE)
-/**
- *
- *
- * This is a count of the numeber of remote nodes that can be represented in a
- * byte
- */
-#define SCIC_SDS_REMOTE_NODES_PER_BYTE	\
-	(SCU_STP_REMOTE_NODE_COUNT * SCIC_SDS_REMOTE_NODE_SETS_PER_BYTE)
-
-/**
- *
- *
- * This is a count of the number of remote nodes that can be represented in a
- * DWROD
- */
-#define SCIC_SDS_REMOTE_NODES_PER_DWORD	\
-	(sizeof(u32) * SCIC_SDS_REMOTE_NODES_PER_BYTE)
-
-/**
- *
- *
- * This is the number of bits in a remote node group
- */
-#define SCIC_SDS_REMOTE_NODES_BITS_PER_GROUP   4
-
-#define SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX      (0xFFFFFFFF)
-#define SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE    (0x07)
-#define SCIC_SDS_REMOTE_NODE_TABLE_EMPTY_SLOT_VALUE   (0x00)
-
-/**
- *
- *
- * Expander attached sata remote node count
- */
-#define SCU_STP_REMOTE_NODE_COUNT        3
-
-/**
- *
- *
- * Expander or direct attached ssp remote node count
- */
-#define SCU_SSP_REMOTE_NODE_COUNT        1
-
-/**
- *
- *
- * Direct attached STP remote node count
- */
-#define SCU_SATA_REMOTE_NODE_COUNT       1
-
-/**
- * struct scic_remote_node_table -
- *
- *
- */
-struct scic_remote_node_table {
-	/**
-	 * This field contains the array size in dwords
-	 */
-	u16 available_nodes_array_size;
-
-	/**
-	 * This field contains the array size of the
-	 */
-	u16 group_array_size;
-
-	/**
-	 * This field is the array of available remote node entries in bits.
-	 * Because of the way STP remote node data is allocated on the SCU hardware
-	 * the remote nodes must occupy three consecutive remote node context
-	 * entries.  For ease of allocation and de-allocation we have broken the
-	 * sets of three into a single nibble.  When the STP RNi is allocated all
-	 * of the bits in the nibble are cleared.  This math results in a table size
-	 * of MAX_REMOTE_NODES / CONSECUTIVE RNi ENTRIES for STP / 2 entries per byte.
-	 */
-	u32 available_remote_nodes[
-		(SCI_MAX_REMOTE_DEVICES / SCIC_SDS_REMOTE_NODES_PER_DWORD)
-		+ ((SCI_MAX_REMOTE_DEVICES % SCIC_SDS_REMOTE_NODES_PER_DWORD) != 0)];
-
-	/**
-	 * This field is the nibble selector for the above table.  There are three
-	 * possible selectors each for fast lookup when trying to find one, two or
-	 * three remote node entries.
-	 */
-	u32 remote_node_groups[
-		SCU_STP_REMOTE_NODE_COUNT][
-		(SCI_MAX_REMOTE_DEVICES / (32 * SCU_STP_REMOTE_NODE_COUNT))
-		+ ((SCI_MAX_REMOTE_DEVICES % (32 * SCU_STP_REMOTE_NODE_COUNT)) != 0)];
-
-};
-
-/* --------------------------------------------------------------------------- */
-
-void scic_sds_remote_node_table_initialize(
-	struct scic_remote_node_table *remote_node_table,
-	u32 remote_node_entries);
-
-u16 scic_sds_remote_node_table_allocate_remote_node(
-	struct scic_remote_node_table *remote_node_table,
-	u32 remote_node_count);
-
-void scic_sds_remote_node_table_release_remote_node_index(
-	struct scic_remote_node_table *remote_node_table,
-	u32 remote_node_count,
-	u16 remote_node_index);
-
-#endif /* _SCIC_SDS_REMOTE_NODE_TABLE_H_ */
diff --git a/drivers/scsi/isci/core/scic_sds_request.c b/drivers/scsi/isci/core/scic_sds_request.c
index 63ebbf3..dfb9412 100644
--- a/drivers/scsi/isci/core/scic_sds_request.c
+++ b/drivers/scsi/isci/core/scic_sds_request.c
@@ -59,11 +59,10 @@
 #include "intel_sat.h"
 #include "scic_controller.h"
 #include "scic_io_request.h"
-#include "scic_remote_device.h"
 #include "scic_sds_controller.h"
 #include "scu_registers.h"
 #include "scic_sds_port.h"
-#include "scic_sds_remote_device.h"
+#include "remote_device.h"
 #include "scic_sds_request.h"
 #include "scic_sds_smp_request.h"
 #include "scic_sds_stp_request.h"
diff --git a/drivers/scsi/isci/core/scic_sds_smp_remote_device.c b/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
deleted file mode 100644
index cd55c0a..0000000
--- a/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "scic_remote_device.h"
-#include "scic_sds_controller.h"
-#include "scic_sds_port.h"
-#include "scic_sds_remote_device.h"
-#include "scic_sds_request.h"
-#include "sci_environment.h"
-#include "sci_util.h"
-#include "scu_event_codes.h"
-#include "scu_task_context.h"
-
-/*
- * *****************************************************************************
- * *  SMP REMOTE DEVICE READY IDLE SUBSTATE HANDLERS
- * ***************************************************************************** */
-
-/**
- *
- * @[in]: device The device the io is sent to.
- * @[in]: request The io to start.
- *
- * This method will handle the start io operation for a SMP device that is in
- * the idle state. enum sci_status
- */
-static enum sci_status scic_sds_smp_remote_device_ready_idle_substate_start_io_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	enum sci_status status;
-
-	/* Will the port allow the io request to start? */
-	status = device->owning_port->state_handlers->start_io_handler(
-			device->owning_port, device, request);
-
-	if (status == SCI_SUCCESS) {
-		status = scic_sds_remote_node_context_start_io(&device->rnc, request);
-
-		if (status == SCI_SUCCESS)
-			status = scic_sds_request_start(request);
-
-		if (status == SCI_SUCCESS) {
-			device->working_request = request;
-
-			sci_base_state_machine_change_state(
-				&device->ready_substate_machine,
-				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD
-				);
-		}
-
-		scic_sds_remote_device_start_request(device, request, status);
-	}
-
-	return status;
-}
-
-
-/*
- * ******************************************************************************
- * * SMP REMOTE DEVICE READY SUBSTATE CMD HANDLERS
- * ****************************************************************************** */
-/**
- *
- * @device: This is the device object that is receiving the IO.
- * @request: The io to start.
- *
- * This device is already handling a command it can not accept new commands
- * until this one is complete. enum sci_status
- */
-static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-
-/**
- * this is the complete_io_handler for smp device at ready cmd substate.
- * @device: This is the device object that is receiving the IO.
- * @request: The io to start.
- *
- * enum sci_status
- */
-static enum sci_status
-scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	enum sci_status status;
-	struct scic_sds_request *sci_req;
-
-	sci_req = (struct scic_sds_request *)request;
-
-	status = scic_sds_io_request_complete(sci_req);
-
-	if (status == SCI_SUCCESS) {
-		status = scic_sds_port_complete_io(
-			device->owning_port, device, sci_req);
-
-		if (status == SCI_SUCCESS) {
-			scic_sds_remote_device_decrement_request_count(device);
-			sci_base_state_machine_change_state(
-				&device->ready_substate_machine,
-				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE
-				);
-		} else
-			dev_err(scirdev_to_dev(device),
-				"%s: SCIC SDS Remote Device 0x%p io request "
-				"0x%p could not be completd on the port 0x%p "
-				"failed with status %d.\n",
-				__func__,
-				device,
-				sci_req,
-				device->owning_port,
-				status);
-	}
-
-	return status;
-}
-
-/**
- * This is frame handler for smp device ready cmd substate.
- * @sci_dev: This is the device object that is receiving the frame.
- * @frame_index: The index for the frame received.
- *
- * enum sci_status
- */
-static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
-{
-	enum sci_status status;
-
-	/*
-	 * / The device does not process any UF received from the hardware while
-	 * / in this state.  All unsolicited frames are forwarded to the io request
-	 * / object. */
-	status = scic_sds_io_request_frame_handler(
-		sci_dev->working_request,
-		frame_index
-		);
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
-static const struct scic_sds_remote_device_state_handler scic_sds_smp_remote_device_ready_substate_handler_table[] = {
-	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_smp_remote_device_ready_idle_substate_start_io_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_general_event_handler,
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
-	},
-	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler,
-		.complete_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_general_event_handler,
-		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
-	}
-};
-
-/**
- *
- * @object: This is the struct sci_base_object which is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE enter method.
- * This function sets the ready cmd substate handlers and reports the device as
- * ready. none
- */
-static void scic_sds_smp_remote_device_ready_idle_substate_enter(struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = sci_object_get_association(scic);
-	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
-
-	SET_STATE_HANDLER(sci_dev,
-			  scic_sds_smp_remote_device_ready_substate_handler_table,
-			  SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-
-	isci_remote_device_ready(ihost, idev);
-}
-
-/**
- *
- * @object: This is the struct sci_base_object which is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD enter method. This
- * function sets the remote device objects ready cmd substate handlers, and
- * notify core user that the device is not ready. none
- */
-static void scic_sds_smp_remote_device_ready_cmd_substate_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = sci_object_get_association(scic);
-	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
-
-	BUG_ON(sci_dev->working_request == NULL);
-
-	SET_STATE_HANDLER(sci_dev,
-			  scic_sds_smp_remote_device_ready_substate_handler_table,
-			  SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
-
-	isci_remote_device_not_ready(ihost, idev,
-				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
-}
-
-/**
- *
- * @object: This is the struct sci_base_object which is cast into a
- *    struct scic_sds_remote_device.
- *
- * This is the SCIC_SDS_SSP_REMOTE_DEVICE_READY_SUBSTATE_CMD exit method. none
- */
-static void scic_sds_smp_remote_device_ready_cmd_substate_exit(struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
-	sci_dev->working_request = NULL;
-}
-
-/* --------------------------------------------------------------------------- */
-
-const struct sci_base_state scic_sds_smp_remote_device_ready_substate_table[] = {
-	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.enter_state = scic_sds_smp_remote_device_ready_idle_substate_enter,
-	},
-	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.enter_state = scic_sds_smp_remote_device_ready_cmd_substate_enter,
-		.exit_state  = scic_sds_smp_remote_device_ready_cmd_substate_exit,
-	},
-};
diff --git a/drivers/scsi/isci/core/scic_sds_smp_request.c b/drivers/scsi/isci/core/scic_sds_smp_request.c
index 3274d62..1790f25 100644
--- a/drivers/scsi/isci/core/scic_sds_smp_request.c
+++ b/drivers/scsi/isci/core/scic_sds_smp_request.c
@@ -56,9 +56,8 @@
 #include "intel_sas.h"
 #include "sci_base_state_machine.h"
 #include "scic_controller.h"
-#include "scic_remote_device.h"
 #include "scic_sds_controller.h"
-#include "scic_sds_remote_device.h"
+#include "remote_device.h"
 #include "scic_sds_request.h"
 #include "scic_sds_smp_request.h"
 #include "sci_environment.h"
diff --git a/drivers/scsi/isci/core/scic_sds_stp_packet_request.c b/drivers/scsi/isci/core/scic_sds_stp_packet_request.c
index e4d2bf5..1cb77bb 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_packet_request.c
+++ b/drivers/scsi/isci/core/scic_sds_stp_packet_request.c
@@ -61,9 +61,8 @@
 #include "sati_translator_sequence.h"
 #include "sci_base_state.h"
 #include "scic_controller.h"
-#include "scic_remote_device.h"
 #include "scic_sds_controller.h"
-#include "scic_sds_remote_device.h"
+#include "remote_device.h"
 #include "scic_sds_request.h"
 #include "scic_sds_stp_packet_request.h"
 #include "scic_user_callback.h"
diff --git a/drivers/scsi/isci/core/scic_sds_stp_remote_device.c b/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
deleted file mode 100644
index 848cb47..0000000
--- a/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
+++ /dev/null
@@ -1,818 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "intel_ata.h"
-#include "intel_sata.h"
-#include "intel_sat.h"
-#include "sci_base_state.h"
-#include "scic_remote_device.h"
-#include "scic_sds_controller.h"
-#include "scic_sds_port.h"
-#include "scic_sds_remote_device.h"
-#include "scic_sds_request.h"
-#include "sci_environment.h"
-#include "sci_util.h"
-#include "scu_event_codes.h"
-
-/**
- * This method will perform the STP request completion processing common to IO
- *    requests and task requests of all types
- * @device: This parameter specifies the device for which the request is being
- *    completed.
- * @request: This parameter specifies the request being completed.
- *
- * This method returns an indication as to whether the request processing
- * completed successfully.
- */
-static enum sci_status scic_sds_stp_remote_device_complete_request(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	enum sci_status status;
-
-	status = scic_sds_io_request_complete(request);
-
-	if (status == SCI_SUCCESS) {
-		status = scic_sds_port_complete_io(
-			device->owning_port, device, request);
-
-		if (status == SCI_SUCCESS) {
-			scic_sds_remote_device_decrement_request_count(device);
-			if (request->sci_status == SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {
-				/*
-				 * This request causes hardware error, device needs to be Lun Reset.
-				 * So here we force the state machine to IDLE state so the rest IOs
-				 * can reach RNC state handler, these IOs will be completed by RNC with
-				 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE". */
-				sci_base_state_machine_change_state(
-					&device->ready_substate_machine,
-					SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET
-					);
-			} else if (scic_sds_remote_device_get_request_count(device) == 0) {
-				sci_base_state_machine_change_state(
-					&device->ready_substate_machine,
-					SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE
-					);
-			}
-		}
-	}
-
-	if (status != SCI_SUCCESS)
-		dev_err(scirdev_to_dev(device),
-			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
-			"could not complete\n",
-			__func__,
-			device->owning_port,
-			device,
-			request,
-			status);
-
-	return status;
-}
-
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY COMMON SUBSTATE HANDLERS
- * ***************************************************************************** */
-
-/**
- * This is the READY NCQ substate handler to start task management request. In
- *    this routine, we suspend and resume the RNC.
- * @device: The target device a task management request towards to.
- * @request: The task request.
- *
- * enum sci_status Always return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS status to
- * let controller_start_task_handler know that the controller can't post TC for
- * task request yet, instead, when RNC gets resumed, a controller_continue_task
- * callback will be called.
- */
-static enum sci_status scic_sds_stp_remote_device_ready_substate_start_request_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	enum sci_status status;
-
-	/* Will the port allow the io request to start? */
-	status = device->owning_port->state_handlers->start_io_handler(
-		device->owning_port, device, request);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	status = scic_sds_remote_node_context_start_task(&device->rnc, request);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	status = request->state_handlers->start_handler(request);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	/*
-	 * Note: If the remote device state is not IDLE this will replace
-	 * the request that probably resulted in the task management request.
-	 */
-	device->working_request = request;
-	sci_base_state_machine_change_state(&device->ready_substate_machine,
-			SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
-
-	/*
-	 * The remote node context must cleanup the TCi to NCQ mapping table.
-	 * The only way to do this correctly is to either write to the TLCR
-	 * register or to invalidate and repost the RNC. In either case the
-	 * remote node context state machine will take the correct action when
-	 * the remote node context is suspended and later resumed.
-	 */
-	scic_sds_remote_node_context_suspend(&device->rnc,
-			SCI_SOFTWARE_SUSPENSION, NULL, NULL);
-	scic_sds_remote_node_context_resume(&device->rnc,
-			scic_sds_remote_device_continue_request,
-			device);
-
-out:
-	scic_sds_remote_device_start_request(device, request, status);
-	/*
-	 * We need to let the controller start request handler know that it can't
-	 * post TC yet. We will provide a callback function to post TC when RNC gets
-	 * resumed.
-	 */
-	return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
-}
-
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY IDLE SUBSTATE HANDLERS
- * ***************************************************************************** */
-
-/**
- * This method will handle the start io operation for a sata device that is in
- *    the command idle state. - Evalute the type of IO request to be started -
- *    If its an NCQ request change to NCQ substate - If its any other command
- *    change to the CMD substate
- * @device:
- * @request:
- *
- * If this is a softreset we may want to have a different substate.
- * enum sci_status
- */
-static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_start_io_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status status;
-	struct isci_request *isci_request =
-		(struct isci_request *)sci_object_get_association(request);
-
-
-	/* Will the port allow the io request to start? */
-	status = sci_dev->owning_port->state_handlers->start_io_handler(
-			sci_dev->owning_port, sci_dev, request);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	status = request->state_handlers->start_handler(request);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	if (isci_sata_get_sat_protocol(isci_request) == SAT_PROTOCOL_FPDMA) {
-		sci_base_state_machine_change_state(&sci_dev->ready_substate_machine,
-				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ);
-	} else {
-		sci_dev->working_request = request;
-		sci_base_state_machine_change_state(&sci_dev->ready_substate_machine,
-				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
-	}
-out:
-	scic_sds_remote_device_start_request(sci_dev, request, status);
-	return status;
-}
-
-
-/**
- *
- * @[in]: device The device received event.
- * @[in]: event_code The event code.
- *
- * This method will handle the event for a sata device that is in the idle
- * state. We pick up suspension events to handle specifically to this state. We
- * resume the RNC right away. enum sci_status
- */
-static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	status = scic_sds_remote_device_general_event_handler(sci_dev, event_code);
-
-	if (status == SCI_SUCCESS) {
-		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX
-		    || scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {
-			status = scic_sds_remote_node_context_resume(
-				&sci_dev->rnc, NULL, NULL);
-		}
-	}
-
-	return status;
-}
-
-
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY NCQ SUBSTATE HANDLERS
- * ***************************************************************************** */
-
-static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status status;
-	struct isci_request *isci_request =
-		(struct isci_request *)sci_object_get_association(request);
-
-	if (isci_sata_get_sat_protocol(isci_request) == SAT_PROTOCOL_FPDMA) {
-		status = sci_dev->owning_port->state_handlers->start_io_handler(
-				sci_dev->owning_port,
-				sci_dev,
-				request);
-		if (status != SCI_SUCCESS)
-			return status;
-
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
-		if (status != SCI_SUCCESS)
-			return status;
-
-		status = request->state_handlers->start_handler(request);
-
-		scic_sds_remote_device_start_request(sci_dev, request, status);
-	} else
-		status = SCI_FAILURE_INVALID_STATE;
-
-	return status;
-}
-
-
-/**
- * This method will handle events received while the STP device is in the ready
- *    command substate.
- * @sci_dev: This is the device object that is receiving the event.
- * @event_code: The event code to process.
- *
- * enum sci_status
- */
-
-static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
-{
-	enum sci_status status;
-	struct sata_fis_header *frame_header;
-
-	status = scic_sds_unsolicited_frame_control_get_header(
-		&(scic_sds_remote_device_get_controller(sci_dev)->uf_control),
-		frame_index,
-		(void **)&frame_header
-		);
-
-	if (status == SCI_SUCCESS) {
-		if (frame_header->fis_type == SATA_FIS_TYPE_SETDEVBITS &&
-		    (frame_header->status & ATA_STATUS_REG_ERROR_BIT)) {
-			sci_dev->not_ready_reason =
-				SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
-
-			/*
-			 * / @todo Check sactive and complete associated IO
-			 * if any.
-			 */
-
-			sci_base_state_machine_change_state(
-				&sci_dev->ready_substate_machine,
-				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR
-				);
-		} else if (frame_header->fis_type == SATA_FIS_TYPE_REGD2H &&
-			   (frame_header->status & ATA_STATUS_REG_ERROR_BIT)) {
-
-			/*
-			 * Some devices return D2H FIS when an NCQ error is detected.
-			 * Treat this like an SDB error FIS ready reason.
-			 */
-			sci_dev->not_ready_reason =
-				SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
-
-			sci_base_state_machine_change_state(
-				&sci_dev->ready_substate_machine,
-				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR
-				);
-		} else {
-			status = SCI_FAILURE;
-		}
-
-		scic_sds_controller_release_frame(
-			scic_sds_remote_device_get_controller(sci_dev), frame_index
-			);
-	}
-
-	return status;
-}
-
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY CMD SUBSTATE HANDLERS
- * ***************************************************************************** */
-
-/**
- * This device is already handling a command it can not accept new commands
- *    until this one is complete.
- * @device:
- * @request:
- *
- * enum sci_status
- */
-static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 suspend_type)
-{
-	enum sci_status status;
-
-	status = scic_sds_remote_node_context_suspend(&sci_dev->rnc,
-						      suspend_type, NULL, NULL);
-
-	return status;
-}
-
-static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
-{
-	enum sci_status status;
-
-	/*
-	 * / The device doe not process any UF received from the hardware while
-	 * / in this state.  All unsolicited frames are forwarded to the io request
-	 * / object. */
-	status = scic_sds_io_request_frame_handler(
-		sci_dev->working_request,
-		frame_index
-		);
-
-	return status;
-}
-
-
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY NCQ SUBSTATE HANDLERS
- * ***************************************************************************** */
-
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY NCQ ERROR SUBSTATE HANDLERS
- * ***************************************************************************** */
-
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY AWAIT RESET SUBSTATE HANDLERS
- * ***************************************************************************** */
-static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
-}
-
-
-
-/**
- * This method will perform the STP request (both io or task) completion
- *    processing for await reset state.
- * @device: This parameter specifies the device for which the request is being
- *    completed.
- * @request: This parameter specifies the request being completed.
- *
- * This method returns an indication as to whether the request processing
- * completed successfully.
- */
-static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	struct scic_sds_request *sci_req = (struct scic_sds_request *)request;
-	enum sci_status status;
-
-	status = scic_sds_io_request_complete(sci_req);
-
-	if (status == SCI_SUCCESS) {
-		status = scic_sds_port_complete_io(
-			device->owning_port, device, sci_req
-			);
-
-		if (status == SCI_SUCCESS)
-			scic_sds_remote_device_decrement_request_count(device);
-	}
-
-	if (status != SCI_SUCCESS)
-		dev_err(scirdev_to_dev(device),
-			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
-			"could not complete\n",
-			__func__,
-			device->owning_port,
-			device,
-			sci_req,
-			status);
-
-	return status;
-}
-
-#if !defined(DISABLE_ATAPI)
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY ATAPI ERROR SUBSTATE HANDLERS
- * ***************************************************************************** */
-
-/**
- *
- * @[in]: device The device received event.
- * @[in]: event_code The event code.
- *
- * This method will handle the event for a ATAPI device that is in the ATAPI
- * ERROR state. We pick up suspension events to handle specifically to this
- * state. We resume the RNC right away. We then complete the outstanding IO to
- * this device. enum sci_status
- */
-enum sci_status scic_sds_stp_remote_device_ready_atapi_error_substate_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	status = scic_sds_remote_device_general_event_handler(sci_dev, event_code);
-
-	if (status == SCI_SUCCESS) {
-		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX
-		    || scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {
-			status = scic_sds_remote_node_context_resume(
-				sci_dev->rnc,
-				sci_dev->working_request->state_handlers->parent.complete_handler,
-				(void *)sci_dev->working_request
-				);
-		}
-	}
-
-	return status;
-}
-#endif /* !defined(DISABLE_ATAPI) */
-
-/* --------------------------------------------------------------------------- */
-
-static const struct scic_sds_remote_device_state_handler scic_sds_stp_remote_device_ready_substate_handler_table[] = {
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_stp_remote_device_ready_idle_substate_start_io_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
-		.event_handler			= scic_sds_stp_remote_device_ready_idle_substate_event_handler,
-		.frame_handler			= scic_sds_remote_device_default_frame_handler
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler,
-		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
-		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
-		.suspend_handler		= scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler,
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
-		.event_handler			= scic_sds_remote_device_general_event_handler,
-		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler,
-		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
-		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
-		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
-		.event_handler			= scic_sds_remote_device_general_event_handler,
-		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
-		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
-		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
-		.event_handler			= scic_sds_remote_device_general_event_handler,
-		.frame_handler			= scic_sds_remote_device_general_frame_handler
-	},
-#if !defined(DISABLE_ATAPI)
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
-		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
-		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
-		.event_handler			= scic_sds_stp_remote_device_ready_atapi_error_substate_event_handler,
-		.frame_handler			= scic_sds_remote_device_general_frame_handler
-	},
-#endif
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler,
-		.complete_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
-		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
-		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
-		.event_handler			= scic_sds_remote_device_general_event_handler,
-		.frame_handler			= scic_sds_remote_device_general_frame_handler
-	}
-};
-
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY SUBSTATE PRIVATE METHODS
- * ***************************************************************************** */
-
-static void
-scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *user_cookie)
-{
-	struct scic_sds_remote_device *sci_dev = user_cookie;
-	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = sci_object_get_association(scic);
-
-	/*
-	 * For NCQ operation we do not issue a
-	 * scic_cb_remote_device_not_ready().  As a result, avoid sending
-	 * the ready notification.
-	 */
-	if (sci_dev->ready_substate_machine.previous_state_id !=
-			SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ)
-		isci_remote_device_ready(ihost, idev);
-}
-
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY IDLE SUBSTATE
- * ***************************************************************************** */
-
-/**
- *
- * @device: This is the SCI base object which is cast into a
- *    struct scic_sds_remote_device object.
- *
- */
-static void scic_sds_stp_remote_device_ready_idle_substate_enter(
-	struct sci_base_object *device)
-{
-	struct scic_sds_remote_device *sci_dev;
-
-	sci_dev = (struct scic_sds_remote_device *)device;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_stp_remote_device_ready_substate_handler_table,
-		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE
-		);
-
-	sci_dev->working_request = NULL;
-
-	if (scic_sds_remote_node_context_is_ready(&sci_dev->rnc)) {
-		/*
-		 * Since the RNC is ready, it's alright to finish completion
-		 * processing (e.g. signal the remote device is ready). */
-		scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(
-			sci_dev
-			);
-	} else {
-		scic_sds_remote_node_context_resume(
-			&sci_dev->rnc,
-			scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler,
-			sci_dev);
-	}
-}
-
-static void scic_sds_stp_remote_device_ready_cmd_substate_enter(struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = sci_object_get_association(scic);
-	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
-
-	BUG_ON(sci_dev->working_request == NULL);
-
-	SET_STATE_HANDLER(sci_dev,
-			  scic_sds_stp_remote_device_ready_substate_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
-
-	isci_remote_device_not_ready(ihost, idev,
-				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
-}
-
-static void scic_sds_stp_remote_device_ready_ncq_substate_enter(struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
-	SET_STATE_HANDLER(sci_dev,
-			  scic_sds_stp_remote_device_ready_substate_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ);
-}
-
-static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_object *object)
-{
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = sci_object_get_association(scic);
-	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
-
-	SET_STATE_HANDLER(sci_dev,
-			  scic_sds_stp_remote_device_ready_substate_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
-
-	if (sci_dev->not_ready_reason ==
-		SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
-		isci_remote_device_not_ready(ihost, idev, sci_dev->not_ready_reason);
-}
-
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY AWAIT RESET SUBSTATE
- * ***************************************************************************** */
-
-/**
- * The enter routine to READY AWAIT RESET substate.
- * @device: This is the SCI base object which is cast into a
- *    struct scic_sds_remote_device object.
- *
- */
-static void scic_sds_stp_remote_device_ready_await_reset_substate_enter(
-	struct sci_base_object *device)
-{
-	struct scic_sds_remote_device *sci_dev;
-
-	sci_dev = (struct scic_sds_remote_device *)device;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_stp_remote_device_ready_substate_handler_table,
-		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET
-		);
-}
-
-#if !defined(DISABLE_ATAPI)
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY ATAPI ERROR SUBSTATE
- * ***************************************************************************** */
-
-/**
- * The enter routine to READY ATAPI ERROR substate.
- * @device: This is the SCI base object which is cast into a
- *    struct scic_sds_remote_device object.
- *
- */
-void scic_sds_stp_remote_device_ready_atapi_error_substate_enter(
-	struct sci_base_object *device)
-{
-	struct scic_sds_remote_device *sci_dev;
-
-	sci_dev = (struct scic_sds_remote_device *)device;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_stp_remote_device_ready_substate_handler_table,
-		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR
-		);
-}
-#endif /* !defined(DISABLE_ATAPI) */
-
-/* --------------------------------------------------------------------------- */
-
-const struct sci_base_state scic_sds_stp_remote_device_ready_substate_table[] = {
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.enter_state = scic_sds_stp_remote_device_ready_idle_substate_enter,
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.enter_state = scic_sds_stp_remote_device_ready_cmd_substate_enter,
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.enter_state = scic_sds_stp_remote_device_ready_ncq_substate_enter,
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.enter_state = scic_sds_stp_remote_device_ready_ncq_error_substate_enter,
-	},
-#if !defined(DISABLE_ATAPI)
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR] = {
-		.enter_state = scic_sds_stp_remote_device_ready_atapi_error_substate_enter,
-	},
-#endif
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.enter_state = scic_sds_stp_remote_device_ready_await_reset_substate_enter,
-	},
-};
diff --git a/drivers/scsi/isci/core/scic_sds_stp_request.c b/drivers/scsi/isci/core/scic_sds_stp_request.c
index ab01f8d..59c5f1b 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_request.c
+++ b/drivers/scsi/isci/core/scic_sds_stp_request.c
@@ -60,9 +60,8 @@
 #include "sci_base_state.h"
 #include "sci_base_state_machine.h"
 #include "scic_io_request.h"
-#include "scic_remote_device.h"
 #include "scic_sds_controller.h"
-#include "scic_sds_remote_device.h"
+#include "remote_device.h"
 #include "scic_sds_request.h"
 #include "scic_sds_stp_pio_request.h"
 #include "scic_sds_stp_request.h"
diff --git a/drivers/scsi/isci/core/scu_remote_node_context.h b/drivers/scsi/isci/core/scu_remote_node_context.h
deleted file mode 100644
index 33745ad..0000000
--- a/drivers/scsi/isci/core/scu_remote_node_context.h
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __SCU_REMOTE_NODE_CONTEXT_HEADER__
-#define __SCU_REMOTE_NODE_CONTEXT_HEADER__
-
-/**
- * This file contains the structures and constatns used by the SCU hardware to
- *    describe a remote node context.
- *
- *
- */
-
-/**
- * struct ssp_remote_node_context - This structure contains the SCU hardware
- *    definition for an SSP remote node.
- *
- *
- */
-struct ssp_remote_node_context {
-	/* WORD 0 */
-
-	/**
-	 * This field is the remote node index assigned for this remote node. All
-	 * remote nodes must have a unique remote node index. The value of the remote
-	 * node index can not exceed the maximum number of remote nodes reported in
-	 * the SCU device context capacity register.
-	 */
-	u32 remote_node_index:12;
-	u32 reserved0_1:4;
-
-	/**
-	 * This field tells the SCU hardware how many simultaneous connections that
-	 * this remote node will support.
-	 */
-	u32 remote_node_port_width:4;
-
-	/**
-	 * This field tells the SCU hardware which logical port to associate with this
-	 * remote node.
-	 */
-	u32 logical_port_index:3;
-	u32 reserved0_2:5;
-
-	/**
-	 * This field will enable the I_T nexus loss timer for this remote node.
-	 */
-	u32 nexus_loss_timer_enable:1;
-
-	/**
-	 * This field is the for driver debug only and is not used.
-	 */
-	u32 check_bit:1;
-
-	/**
-	 * This field must be set to true when the hardware DMAs the remote node
-	 * context to the hardware SRAM.  When the remote node is being invalidated
-	 * this field must be set to false.
-	 */
-	u32 is_valid:1;
-
-	/**
-	 * This field must be set to true.
-	 */
-	u32 is_remote_node_context:1;
-
-	/* WORD 1 - 2 */
-
-	/**
-	 * This is the low word of the remote device SAS Address
-	 */
-	u32 remote_sas_address_lo;
-
-	/**
-	 * This field is the high word of the remote device SAS Address
-	 */
-	u32 remote_sas_address_hi;
-
-	/* WORD 3 */
-	/**
-	 * This field reprensets the function number assigned to this remote device.
-	 * This value must match the virtual function number that is being used to
-	 * communicate to the device.
-	 */
-	u32 function_number:8;
-	u32 reserved3_1:8;
-
-	/**
-	 * This field provides the driver a way to cheat on the arbitration wait time
-	 * for this remote node.
-	 */
-	u32 arbitration_wait_time:16;
-
-	/* WORD 4 */
-	/**
-	 * This field tells the SCU hardware how long this device may occupy the
-	 * connection before it must be closed.
-	 */
-	u32 connection_occupancy_timeout:16;
-
-	/**
-	 * This field tells the SCU hardware how long to maintain a connection when
-	 * there are no frames being transmitted on the link.
-	 */
-	u32 connection_inactivity_timeout:16;
-
-	/* WORD  5 */
-	/**
-	 * This field allows the driver to cheat on the arbitration wait time for this
-	 * remote node.
-	 */
-	u32 initial_arbitration_wait_time:16;
-
-	/**
-	 * This field is tells the hardware what to program for the connection rate in
-	 * the open address frame.  See the SAS spec for valid values.
-	 */
-	u32 oaf_connection_rate:4;
-
-	/**
-	 * This field tells the SCU hardware what to program for the features in the
-	 * open address frame.  See the SAS spec for valid values.
-	 */
-	u32 oaf_features:4;
-
-	/**
-	 * This field tells the SCU hardware what to use for the source zone group in
-	 * the open address frame.  See the SAS spec for more details on zoning.
-	 */
-	u32 oaf_source_zone_group:8;
-
-	/* WORD 6 */
-	/**
-	 * This field tells the SCU hardware what to use as the more capibilities in
-	 * the open address frame. See the SAS Spec for details.
-	 */
-	u32 oaf_more_compatibility_features;
-
-	/* WORD 7 */
-	u32 reserved7;
-
-};
-
-/**
- * struct stp_remote_node_context - This structure contains the SCU hardware
- *    definition for a STP remote node.
- *
- * STP Targets are not yet supported so this definition is a placeholder until
- * we do support them.
- */
-struct stp_remote_node_context {
-	/**
-	 * Placeholder data for the STP remote node.
-	 */
-	u32 data[8];
-
-};
-
-/**
- * This union combines the SAS and SATA remote node definitions.
- *
- * union scu_remote_node_context
- */
-union scu_remote_node_context {
-	/**
-	 * SSP Remote Node
-	 */
-	struct ssp_remote_node_context ssp;
-
-	/**
-	 * STP Remote Node
-	 */
-	struct stp_remote_node_context stp;
-
-};
-
-#endif /* __SCU_REMOTE_NODE_CONTEXT_HEADER__ */
diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 3aceb92..676bcdb 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -55,14 +55,12 @@
 
 #include "isci.h"
 #include "scic_io_request.h"
-#include "scic_remote_device.h"
 #include "scic_port.h"
-
 #include "port.h"
 #include "request.h"
 #include "host.h"
 #include "probe_roms.h"
-#include "core/scic_sds_controller.h"
+#include "scic_sds_controller.h"
 
 irqreturn_t isci_msix_isr(int vec, void *data)
 {
diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 21bd7d8..8dc8d1c 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -61,7 +61,6 @@
 /*#include "task.h"*/
 #include "timers.h"
 #include "remote_device.h"
-#include "scic_remote_device.h"
 
 #define DRV_NAME "isci"
 #define SCI_PCI_BAR_COUNT 2
diff --git a/drivers/scsi/isci/init.c b/drivers/scsi/isci/init.c
index a23ea2c..f7ca9e8 100644
--- a/drivers/scsi/isci/init.c
+++ b/drivers/scsi/isci/init.c
@@ -62,7 +62,6 @@
 #include "isci.h"
 #include "task.h"
 #include "sci_controller_constants.h"
-#include "scic_remote_device.h"
 #include "sci_environment.h"
 #include "probe_roms.h"
 
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index cf78cf0..430b29e 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -63,7 +63,6 @@
 #include <linux/workqueue.h>
 #include "isci.h"
 #include "scic_io_request.h"
-#include "scic_remote_device.h"
 #include "scic_phy.h"
 #include "scic_sds_phy.h"
 #include "scic_port.h"
diff --git a/drivers/scsi/isci/port.h b/drivers/scsi/isci/port.h
index 76546fd..eeac7bb 100644
--- a/drivers/scsi/isci/port.h
+++ b/drivers/scsi/isci/port.h
@@ -64,6 +64,7 @@
 
 struct isci_phy;
 struct isci_host;
+struct scic_sds_phy;
 
 
 enum isci_status {
diff --git a/drivers/scsi/isci/probe_roms.c b/drivers/scsi/isci/probe_roms.c
index 2df8d8e..933d811 100644
--- a/drivers/scsi/isci/probe_roms.c
+++ b/drivers/scsi/isci/probe_roms.c
@@ -33,7 +33,6 @@
 #include "isci.h"
 #include "task.h"
 #include "sci_controller_constants.h"
-#include "scic_remote_device.h"
 #include "sci_environment.h"
 #include "probe_roms.h"
 
diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 1553221..6b9ea90 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -52,18 +52,1169 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
+#include "intel_sas.h"
 #include "isci.h"
-#include "scic_io_request.h"
-#include "scic_remote_device.h"
-#include "scic_phy.h"
-#include "scic_port.h"
 #include "port.h"
 #include "remote_device.h"
 #include "request.h"
+#include "scic_controller.h"
+#include "scic_io_request.h"
+#include "scic_phy.h"
+#include "scic_port.h"
+#include "scic_sds_controller.h"
+#include "scic_sds_phy.h"
+#include "scic_sds_port.h"
+#include "remote_node_context.h"
+#include "scic_sds_request.h"
+#include "sci_environment.h"
+#include "sci_util.h"
+#include "scu_event_codes.h"
 #include "task.h"
 
+enum sci_status scic_remote_device_stop(
+	struct scic_sds_remote_device *sci_dev,
+	u32 timeout)
+{
+	return sci_dev->state_handlers->stop_handler(sci_dev);
+}
+
+
+enum sci_status scic_remote_device_reset(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return sci_dev->state_handlers->reset_handler(sci_dev);
+}
+
+
+enum sci_status scic_remote_device_reset_complete(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return sci_dev->state_handlers->reset_complete_handler(sci_dev);
+}
+
+
+enum sas_linkrate scic_remote_device_get_connection_rate(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return sci_dev->connection_rate;
+}
+
+
+void scic_remote_device_get_protocols(
+	struct scic_sds_remote_device *sci_dev,
+	struct smp_discover_response_protocols *pr)
+{
+	pr->u.all = sci_dev->target_protocols.u.all;
+}
+
+#if !defined(DISABLE_ATAPI)
+bool scic_remote_device_is_atapi(struct scic_sds_remote_device *sci_dev)
+{
+	return sci_dev->is_atapi;
+}
+#endif
+
+
+/**
+ *
+ *
+ * Remote device timer requirements
+ */
+#define SCIC_SDS_REMOTE_DEVICE_MINIMUM_TIMER_COUNT (0)
+#define SCIC_SDS_REMOTE_DEVICE_MAXIMUM_TIMER_COUNT (SCI_MAX_REMOTE_DEVICES)
+
+
+/**
+ *
+ * @sci_dev: The remote device for which the suspend is being requested.
+ *
+ * This method invokes the remote device suspend state handler. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_suspend(
+	struct scic_sds_remote_device *sci_dev,
+	u32 suspend_type)
+{
+	return sci_dev->state_handlers->suspend_handler(sci_dev, suspend_type);
+}
+
+/**
+ *
+ * @sci_dev: The remote device for which the event handling is being
+ *    requested.
+ * @frame_index: This is the frame index that is being processed.
+ *
+ * This method invokes the frame handler for the remote device state machine
+ * enum sci_status
+ */
+enum sci_status scic_sds_remote_device_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	return sci_dev->state_handlers->frame_handler(sci_dev, frame_index);
+}
+
+/**
+ *
+ * @sci_dev: The remote device for which the event handling is being
+ *    requested.
+ * @event_code: This is the event code that is to be processed.
+ *
+ * This method invokes the remote device event handler. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code)
+{
+	return sci_dev->state_handlers->event_handler(sci_dev, event_code);
+}
+
+/**
+ *
+ * @controller: The controller that is starting the io request.
+ * @sci_dev: The remote device for which the start io handling is being
+ *    requested.
+ * @io_request: The io request that is being started.
+ *
+ * This method invokes the remote device start io handler. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_start_io(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *io_request)
+{
+	return sci_dev->state_handlers->start_io_handler(
+		       sci_dev, io_request);
+}
+
+/**
+ *
+ * @controller: The controller that is completing the io request.
+ * @sci_dev: The remote device for which the complete io handling is being
+ *    requested.
+ * @io_request: The io request that is being completed.
+ *
+ * This method invokes the remote device complete io handler. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_complete_io(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *io_request)
+{
+	return sci_dev->state_handlers->complete_io_handler(
+		       sci_dev, io_request);
+}
+
+/**
+ *
+ * @controller: The controller that is starting the task request.
+ * @sci_dev: The remote device for which the start task handling is being
+ *    requested.
+ * @io_request: The task request that is being started.
+ *
+ * This method invokes the remote device start task handler. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_start_task(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *io_request)
+{
+	return sci_dev->state_handlers->start_task_handler(
+		       sci_dev, io_request);
+}
+
+/**
+ *
+ * @controller: The controller that is completing the task request.
+ * @sci_dev: The remote device for which the complete task handling is
+ *    being requested.
+ * @io_request: The task request that is being completed.
+ *
+ * This method invokes the remote device complete task handler. enum sci_status
+ */
+
+/**
+ *
+ * @sci_dev:
+ * @request:
+ *
+ * This method takes the request and bulids an appropriate SCU context for the
+ * request and then requests the controller to post the request. none
+ */
+void scic_sds_remote_device_post_request(
+	struct scic_sds_remote_device *sci_dev,
+	u32 request)
+{
+	u32 context;
+
+	context = scic_sds_remote_device_build_command_context(sci_dev, request);
+
+	scic_sds_controller_post_request(
+		scic_sds_remote_device_get_controller(sci_dev),
+		context
+		);
+}
+
+#if !defined(DISABLE_ATAPI)
+/**
+ *
+ * @sci_dev: The device to be checked.
+ *
+ * This method check the signature fis of a stp device to decide whether a
+ * device is atapi or not. true if a device is atapi device. False if a device
+ * is not atapi.
+ */
+bool scic_sds_remote_device_is_atapi(
+	struct scic_sds_remote_device *sci_dev)
+{
+	if (!sci_dev->target_protocols.u.bits.attached_stp_target)
+		return false;
+	else if (sci_dev->is_direct_attached) {
+		struct scic_sds_phy *phy;
+		struct scic_sata_phy_properties properties;
+		struct sata_fis_reg_d2h *signature_fis;
+		phy = scic_sds_port_get_a_connected_phy(sci_dev->owning_port);
+		scic_sata_phy_get_properties(phy, &properties);
+
+		/* decode the signature fis. */
+		signature_fis = &(properties.signature_fis);
+
+		if ((signature_fis->sector_count  == 0x01)
+		    && (signature_fis->lba_low       == 0x01)
+		    && (signature_fis->lba_mid       == 0x14)
+		    && (signature_fis->lba_high      == 0xEB)
+		    && ((signature_fis->device & 0x5F) == 0x00)
+		    ) {
+			/* An ATA device supporting the PACKET command set. */
+			return true;
+		} else
+			return false;
+	} else {
+		/* Expander supported ATAPI device is not currently supported. */
+		return false;
+	}
+}
+#endif
+
+/**
+ *
+ * @user_parameter: This is cast to a remote device object.
+ *
+ * This method is called once the remote node context is ready to be freed.
+ * The remote device can now report that its stop operation is complete. none
+ */
+static void scic_sds_cb_remote_device_rnc_destruct_complete(
+	void *user_parameter)
+{
+	struct scic_sds_remote_device *sci_dev;
+
+	sci_dev = (struct scic_sds_remote_device *)user_parameter;
+
+	BUG_ON(sci_dev->started_request_count != 0);
+
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
+}
+
+/**
+ *
+ * @user_parameter: This is cast to a remote device object.
+ *
+ * This method is called once the remote node context has transisitioned to a
+ * ready state.  This is the indication that the remote device object can also
+ * transition to ready. none
+ */
+static void scic_sds_remote_device_resume_complete_handler(
+	void *user_parameter)
+{
+	struct scic_sds_remote_device *sci_dev;
+
+	sci_dev = (struct scic_sds_remote_device *)user_parameter;
+
+	if (
+		sci_base_state_machine_get_state(&sci_dev->state_machine)
+		!= SCI_BASE_REMOTE_DEVICE_STATE_READY
+		) {
+		sci_base_state_machine_change_state(
+			&sci_dev->state_machine,
+			SCI_BASE_REMOTE_DEVICE_STATE_READY
+			);
+	}
+}
+
+/**
+ *
+ * @device: This parameter specifies the device for which the request is being
+ *    started.
+ * @request: This parameter specifies the request being started.
+ * @status: This parameter specifies the current start operation status.
+ *
+ * This method will perform the STP request start processing common to IO
+ * requests and task requests of all types. none
+ */
+void scic_sds_remote_device_start_request(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req,
+	enum sci_status status)
+{
+	/* We still have a fault in starting the io complete it on the port */
+	if (status == SCI_SUCCESS)
+		scic_sds_remote_device_increment_request_count(sci_dev);
+	else{
+		sci_dev->owning_port->state_handlers->complete_io_handler(
+			sci_dev->owning_port, sci_dev, sci_req
+			);
+	}
+}
+
+
+/**
+ *
+ * @request: This parameter specifies the request being continued.
+ *
+ * This method will continue to post tc for a STP request. This method usually
+ * serves as a callback when RNC gets resumed during a task management
+ * sequence. none
+ */
+void scic_sds_remote_device_continue_request(void *dev)
+{
+	struct scic_sds_remote_device *sci_dev = dev;
 
+	/* we need to check if this request is still valid to continue. */
+	if (sci_dev->working_request)
+		scic_controller_continue_io(sci_dev->working_request);
+}
+
+/**
+ * This method will terminate all of the IO requests in the controllers IO
+ *    request table that were targeted for this device.
+ * @sci_dev: This parameter specifies the remote device for which to
+ *    attempt to terminate all requests.
+ *
+ * This method returns an indication as to whether all requests were
+ * successfully terminated.  If a single request fails to be terminated, then
+ * this method will return the failure.
+ */
+static enum sci_status scic_sds_remote_device_terminate_requests(
+	struct scic_sds_remote_device *sci_dev)
+{
+	enum sci_status status           = SCI_SUCCESS;
+	enum sci_status terminate_status = SCI_SUCCESS;
+	struct scic_sds_request *sci_req;
+	u32 index;
+	u32 request_count    = sci_dev->started_request_count;
+
+	for (index = 0;
+	     (index < SCI_MAX_IO_REQUESTS) && (request_count > 0);
+	     index++) {
+		sci_req = sci_dev->owning_port->owning_controller->io_request_table[index];
+
+		if ((sci_req != NULL) && (sci_req->target_device == sci_dev)) {
+			terminate_status = scic_controller_terminate_request(
+				sci_dev->owning_port->owning_controller,
+				sci_dev,
+				sci_req
+				);
+
+			if (terminate_status != SCI_SUCCESS)
+				status = terminate_status;
+
+			request_count--;
+		}
+	}
+
+	return status;
+}
+
+static enum sci_status
+default_device_handler(struct scic_sds_remote_device *sci_dev,
+		       const char *func)
+{
+	dev_warn(scirdev_to_dev(sci_dev),
+		 "%s: in wrong state: %d\n", func,
+		 sci_base_state_machine_get_state(&sci_dev->state_machine));
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+enum sci_status scic_sds_remote_device_default_start_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+static enum sci_status scic_sds_remote_device_default_stop_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_fail_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_destruct_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_reset_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_reset_complete_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_suspend_handler(
+	struct scic_sds_remote_device *sci_dev, u32 suspend_type)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_resume_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is then cast into a
+ *    struct scic_sds_remote_device.
+ * @event_code: The event code that the struct scic_sds_controller wants the device
+ *    object to process.
+ *
+ * This method is the default event handler.  It will call the RNC state
+ * machine handler for any RNC events otherwise it will log a warning and
+ * returns a failure. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+static enum sci_status  scic_sds_remote_device_core_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code,
+	bool is_ready_state)
+{
+	enum sci_status status;
+
+	switch (scu_get_event_type(event_code)) {
+	case SCU_EVENT_TYPE_RNC_OPS_MISC:
+	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
+	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
+		status = scic_sds_remote_node_context_event_handler(&sci_dev->rnc, event_code);
+		break;
+	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
+
+		if (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {
+			status = SCI_SUCCESS;
+
+			/* Suspend the associated RNC */
+			scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+							      SCI_SOFTWARE_SUSPENSION,
+							      NULL, NULL);
+
+			dev_dbg(scirdev_to_dev(sci_dev),
+				"%s: device: %p event code: %x: %s\n",
+				__func__, sci_dev, event_code,
+				(is_ready_state)
+				? "I_T_Nexus_Timeout event"
+				: "I_T_Nexus_Timeout event in wrong state");
+
+			break;
+		}
+	/* Else, fall through and treat as unhandled... */
+
+	default:
+		dev_dbg(scirdev_to_dev(sci_dev),
+			"%s: device: %p event code: %x: %s\n",
+			__func__, sci_dev, event_code,
+			(is_ready_state)
+			? "unexpected event"
+			: "unexpected event in wrong state");
+		status = SCI_FAILURE_INVALID_STATE;
+		break;
+	}
+
+	return status;
+}
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is then cast into a
+ *    struct scic_sds_remote_device.
+ * @event_code: The event code that the struct scic_sds_controller wants the device
+ *    object to process.
+ *
+ * This method is the default event handler.  It will call the RNC state
+ * machine handler for any RNC events otherwise it will log a warning and
+ * returns a failure. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+static enum sci_status  scic_sds_remote_device_default_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code)
+{
+	return scic_sds_remote_device_core_event_handler(sci_dev,
+							  event_code,
+							  false);
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is then cast into a
+ *    struct scic_sds_remote_device.
+ * @frame_index: The frame index for which the struct scic_sds_controller wants this
+ *    device object to process.
+ *
+ * This method is the default unsolicited frame handler.  It logs a warning,
+ * releases the frame and returns a failure. enum sci_status
+ * SCI_FAILURE_INVALID_STATE
+ */
+enum sci_status scic_sds_remote_device_default_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	dev_warn(scirdev_to_dev(sci_dev),
+		 "%s: SCIC Remote Device requested to handle frame %x "
+		 "while in wrong state %d\n",
+		 __func__,
+		 frame_index,
+		 sci_base_state_machine_get_state(
+			 &sci_dev->state_machine));
+
+	/* Return the frame back to the controller */
+	scic_sds_controller_release_frame(
+		scic_sds_remote_device_get_controller(sci_dev), frame_index
+		);
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+enum sci_status scic_sds_remote_device_default_start_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_complete_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_continue_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is then cast into a
+ *    struct scic_sds_remote_device.
+ * @frame_index: The frame index for which the struct scic_sds_controller wants this
+ *    device object to process.
+ *
+ * This method is a general ssp frame handler.  In most cases the device object
+ * needs to route the unsolicited frame processing to the io request object.
+ * This method decodes the tag for the io request object and routes the
+ * unsolicited frame to that object. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+enum sci_status scic_sds_remote_device_general_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	enum sci_status result;
+	struct sci_ssp_frame_header *frame_header;
+	struct scic_sds_request *io_request;
+
+	result = scic_sds_unsolicited_frame_control_get_header(
+		&(scic_sds_remote_device_get_controller(sci_dev)->uf_control),
+		frame_index,
+		(void **)&frame_header
+		);
+
+	if (SCI_SUCCESS == result) {
+		io_request = scic_sds_controller_get_io_request_from_tag(
+			scic_sds_remote_device_get_controller(sci_dev), frame_header->tag);
+
+		if ((io_request == NULL)
+		    || (io_request->target_device != sci_dev)) {
+			/*
+			 * We could not map this tag to a valid IO request
+			 * Just toss the frame and continue */
+			scic_sds_controller_release_frame(
+				scic_sds_remote_device_get_controller(sci_dev), frame_index
+				);
+		} else {
+			/* The IO request is now in charge of releasing the frame */
+			result = io_request->state_handlers->frame_handler(
+				io_request, frame_index);
+		}
+	}
+
+	return result;
+}
+
+/**
+ *
+ * @[in]: sci_dev This is the device object that is receiving the event.
+ * @[in]: event_code The event code to process.
+ *
+ * This is a common method for handling events reported to the remote device
+ * from the controller object. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_general_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code)
+{
+	return scic_sds_remote_device_core_event_handler(sci_dev,
+							  event_code,
+							  true);
+}
+
+/*
+ * *****************************************************************************
+ * *  STOPPED STATE HANDLERS
+ * ***************************************************************************** */
+
+/**
+ *
+ * @device:
+ *
+ * This method takes the struct scic_sds_remote_device from a stopped state and
+ * attempts to start it.   The RNC buffer for the device is constructed and the
+ * device state machine is transitioned to the
+ * SCIC_BASE_REMOTE_DEVICE_STATE_STARTING. enum sci_status SCI_SUCCESS if there is
+ * an RNC buffer available to construct the remote device.
+ * SCI_FAILURE_INSUFFICIENT_RESOURCES if there is no RNC buffer available in
+ * which to construct the remote device.
+ */
+static enum sci_status scic_sds_remote_device_stopped_state_start_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	enum sci_status status;
+
+	status = scic_sds_remote_node_context_resume(&sci_dev->rnc,
+			scic_sds_remote_device_resume_complete_handler, sci_dev);
+
+	if (status == SCI_SUCCESS)
+		sci_base_state_machine_change_state(&sci_dev->state_machine,
+						    SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
+
+	return status;
+}
+
+static enum sci_status scic_sds_remote_device_stopped_state_stop_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @sci_dev: The struct scic_sds_remote_device which is cast into a
+ *    struct scic_sds_remote_device.
+ *
+ * This method will destruct a struct scic_sds_remote_device that is in a stopped
+ * state.  This is the only state from which a destruct request will succeed.
+ * The RNi for this struct scic_sds_remote_device is returned to the free pool and the
+ * device object transitions to the SCI_BASE_REMOTE_DEVICE_STATE_FINAL.
+ * enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_device_stopped_state_destruct_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	struct scic_sds_controller *scic;
+
+	scic = scic_sds_remote_device_get_controller(sci_dev);
+	scic_sds_controller_free_remote_node_context(scic, sci_dev,
+						     sci_dev->rnc.remote_node_index);
+	sci_dev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
+
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_FINAL);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * *****************************************************************************
+ * *  STARTING STATE HANDLERS
+ * ***************************************************************************** */
+
+static enum sci_status scic_sds_remote_device_starting_state_stop_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	/*
+	 * This device has not yet started so there had better be no IO requests
+	 */
+	BUG_ON(sci_dev->started_request_count != 0);
+
+	/*
+	 * Destroy the remote node context
+	 */
+	scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+		scic_sds_cb_remote_device_rnc_destruct_complete, sci_dev);
+
+	/*
+	 * Transition to the stopping state and wait for the remote node to
+	 * complete being posted and invalidated.
+	 */
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
+
+	return SCI_SUCCESS;
+}
+
+enum sci_status scic_sds_remote_device_ready_state_stop_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	enum sci_status status = SCI_SUCCESS;
+
+	/* Request the parent state machine to transition to the stopping state */
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
+
+	if (sci_dev->started_request_count == 0) {
+		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+			scic_sds_cb_remote_device_rnc_destruct_complete,
+			sci_dev);
+	} else
+		status = scic_sds_remote_device_terminate_requests(sci_dev);
+
+	return status;
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device object which is cast to a
+ *    struct scic_sds_remote_device object.
+ *
+ * This is the ready state device reset handler enum sci_status
+ */
+enum sci_status scic_sds_remote_device_ready_state_reset_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	/* Request the parent state machine to transition to the stopping state */
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_RESETTING);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method will attempt to start a task request for this device object. The
+ * remote device object will issue the start request for the task and if
+ * successful it will start the request for the port object then increment its
+ * own requet count. enum sci_status SCI_SUCCESS if the task request is started for
+ * this device object. SCI_FAILURE_INSUFFICIENT_RESOURCES if the io request
+ * object could not get the resources to start.
+ */
+static enum sci_status scic_sds_remote_device_ready_state_start_task_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status result;
+
+	/* See if the port is in a state where we can start the IO request */
+	result = scic_sds_port_start_io(
+		scic_sds_remote_device_get_port(sci_dev), sci_dev, request);
+
+	if (result == SCI_SUCCESS) {
+		result = scic_sds_remote_node_context_start_task(&sci_dev->rnc,
+								 request);
+		if (result == SCI_SUCCESS)
+			result = scic_sds_request_start(request);
+
+		scic_sds_remote_device_start_request(sci_dev, request, result);
+	}
+
+	return result;
+}
+
+/*
+ * This method will attempt to start an io request for this device object. The
+ * remote device object will issue the start request for the io and if
+ * successful it will start the request for the port object then increment its
+ * own requet count. enum sci_status SCI_SUCCESS if the io request is started for
+ * this device object. SCI_FAILURE_INSUFFICIENT_RESOURCES if the io request
+ * object could not get the resources to start.
+ */
+static enum sci_status scic_sds_remote_device_ready_state_start_io_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status result;
+
+	/* See if the port is in a state where we can start the IO request */
+	result = scic_sds_port_start_io(
+		scic_sds_remote_device_get_port(sci_dev), sci_dev, request);
+
+	if (result == SCI_SUCCESS) {
+		result = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
+		if (result == SCI_SUCCESS)
+			result = scic_sds_request_start(request);
+
+		scic_sds_remote_device_start_request(sci_dev, request, result);
+	}
+
+	return result;
+}
+
+/*
+ * This method will complete the request for the remote device object.  The
+ * method will call the completion handler for the request object and if
+ * successful it will complete the request on the port object then decrement
+ * its own started_request_count. enum sci_status
+ */
+static enum sci_status scic_sds_remote_device_ready_state_complete_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status result;
+
+	result = scic_sds_request_complete(request);
+
+	if (result != SCI_SUCCESS)
+		return result;
+
+	/* See if the port is in a state
+	 * where we can start the IO request */
+	result = scic_sds_port_complete_io(
+			scic_sds_remote_device_get_port(sci_dev),
+			sci_dev, request);
+
+	if (result == SCI_SUCCESS)
+		scic_sds_remote_device_decrement_request_count(sci_dev);
+
+	return result;
+}
+
+/*
+ * *****************************************************************************
+ * *  STOPPING STATE HANDLERS
+ * ***************************************************************************** */
+
+/**
+ *
+ * @sci_dev: The struct scic_sds_remote_device which is cast into a
+ *    struct scic_sds_remote_device.
+ *
+ * This method will stop a struct scic_sds_remote_device that is already in the
+ * SCI_BASE_REMOTE_DEVICE_STATE_STOPPING state. This is not considered an error
+ * since we allow a stop request on a device that is alreay stopping or
+ * stopped. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_device_stopping_state_stop_handler(
+	struct scic_sds_remote_device *device)
+{
+	/*
+	 * All requests should have been terminated, but if there is an
+	 * attempt to stop a device already in the stopping state, then
+	 * try again to terminate. */
+	return scic_sds_remote_device_terminate_requests(device);
+}
+
+
+/**
+ *
+ * @device: The device object for which the request is completing.
+ * @request: The task request that is being completed.
+ *
+ * This method completes requests for this struct scic_sds_remote_device while it is
+ * in the SCI_BASE_REMOTE_DEVICE_STATE_STOPPING state. This method calls the
+ * complete method for the request object and if that is successful the port
+ * object is called to complete the task request. Then the device object itself
+ * completes the task request. If struct scic_sds_remote_device started_request_count
+ * goes to 0 and the invalidate RNC request has completed the device object can
+ * transition to the SCI_BASE_REMOTE_DEVICE_STATE_STOPPED. enum sci_status
+ */
+static enum sci_status scic_sds_remote_device_stopping_state_complete_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status status = SCI_SUCCESS;
+
+	status = scic_sds_request_complete(request);
+
+	if (status != SCI_SUCCESS)
+		return status;
+
+	status = scic_sds_port_complete_io(scic_sds_remote_device_get_port(sci_dev),
+					   sci_dev, request);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	scic_sds_remote_device_decrement_request_count(sci_dev);
+
+	if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
+		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+						      scic_sds_cb_remote_device_rnc_destruct_complete,
+						      sci_dev);
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is to be cast into a
+ *    struct scic_sds_remote_device object.
+ *
+ * This method will complete the reset operation when the device is in the
+ * resetting state. enum sci_status
+ */
+static enum sci_status scic_sds_remote_device_resetting_state_reset_complete_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+
+	sci_base_state_machine_change_state(
+		&sci_dev->state_machine,
+		SCI_BASE_REMOTE_DEVICE_STATE_READY
+		);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is to be cast into a
+ *    struct scic_sds_remote_device object.
+ *
+ * This method will stop the remote device while in the resetting state.
+ * enum sci_status
+ */
+static enum sci_status scic_sds_remote_device_resetting_state_stop_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	sci_base_state_machine_change_state(
+		&sci_dev->state_machine,
+		SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
+		);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method completes requests for this struct scic_sds_remote_device while it is
+ * in the SCI_BASE_REMOTE_DEVICE_STATE_RESETTING state. This method calls the
+ * complete method for the request object and if that is successful the port
+ * object is called to complete the task request. Then the device object itself
+ * completes the task request. enum sci_status
+ */
+static enum sci_status scic_sds_remote_device_resetting_state_complete_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status status = SCI_SUCCESS;
+
+	status = scic_sds_request_complete(request);
+
+	if (status == SCI_SUCCESS) {
+		status = scic_sds_port_complete_io(
+				scic_sds_remote_device_get_port(sci_dev),
+				sci_dev, request);
+
+		if (status == SCI_SUCCESS) {
+			scic_sds_remote_device_decrement_request_count(sci_dev);
+		}
+	}
+
+	return status;
+}
+
+static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
+	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_default_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
+		.start_handler		= scic_sds_remote_device_stopped_state_start_handler,
+		.stop_handler		= scic_sds_remote_device_stopped_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_stopped_state_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_starting_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_ready_state_start_io_handler,
+		.complete_io_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_ready_state_start_task_handler,
+		.complete_task_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_stopping_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_default_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_resetting_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_resetting_state_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_default_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	}
+};
+
+static void scic_sds_remote_device_initial_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	sci_dev = container_of(object, typeof(*sci_dev), parent);
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_INITIAL);
+
+	/* Initial state is a transitional state to the stopped state */
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
+}
+
+/**
+ * isci_remote_device_change_state() - This function gets the status of the
+ *    remote_device object.
+ * @isci_device: This parameter points to the isci_remote_device object
+ *
+ * status of the object as a isci_status enum.
+ */
+void isci_remote_device_change_state(
+	struct isci_remote_device *isci_device,
+	enum isci_status status)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&isci_device->state_lock, flags);
+	isci_device->status = status;
+	spin_unlock_irqrestore(&isci_device->state_lock, flags);
+}
+
+/**
+ * scic_remote_device_destruct() - free remote node context and destruct
+ * @remote_device: This parameter specifies the remote device to be destructed.
+ *
+ * Remote device objects are a limited resource.  As such, they must be
+ * protected.  Thus calls to construct and destruct are mutually exclusive and
+ * non-reentrant. The return value shall indicate if the device was
+ * successfully destructed or if some failure occurred. enum sci_status This value
+ * is returned if the device is successfully destructed.
+ * SCI_FAILURE_INVALID_REMOTE_DEVICE This value is returned if the supplied
+ * device isn't valid (e.g. it's already been destoryed, the handle isn't
+ * valid, etc.).
+ */
+static enum sci_status scic_remote_device_destruct(struct scic_sds_remote_device *sci_dev)
+{
+	return sci_dev->state_handlers->destruct_handler(sci_dev);
+}
 
 /**
  * isci_remote_device_deconstruct() - This function frees an isci_remote_device.
@@ -98,6 +1249,418 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 	wake_up(&ihost->eventq);
 }
 
+/**
+ * isci_remote_device_stop_complete() - This function is called by the scic
+ *    when the remote device stop has completed. We mark the isci device as not
+ *    ready and remove the isci remote device.
+ * @ihost: This parameter specifies the isci host object.
+ * @idev: This parameter specifies the remote device.
+ * @status: This parameter specifies status of the completion.
+ *
+ */
+static void isci_remote_device_stop_complete(struct isci_host *ihost,
+					     struct isci_remote_device *idev)
+{
+	dev_dbg(&ihost->pdev->dev, "%s: complete idev = %p\n", __func__, idev);
+
+	isci_remote_device_change_state(idev, isci_stopped);
+
+	/* after stop, we can tear down resources. */
+	isci_remote_device_deconstruct(ihost, idev);
+}
+
+static void scic_sds_remote_device_stopped_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev;
+	struct scic_sds_controller *scic;
+	struct isci_remote_device *idev;
+	struct isci_host *ihost;
+	u32 prev_state;
+
+	sci_dev = container_of(object, typeof(*sci_dev), parent);
+	scic = scic_sds_remote_device_get_controller(sci_dev);
+	ihost = sci_object_get_association(scic);
+	idev = sci_object_get_association(sci_dev);
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
+
+	/* If we are entering from the stopping state let the SCI User know that
+	 * the stop operation has completed.
+	 */
+	prev_state = sci_dev->state_machine.previous_state_id;
+	if (prev_state == SCI_BASE_REMOTE_DEVICE_STATE_STOPPING)
+		isci_remote_device_stop_complete(ihost, idev);
+
+	scic_sds_controller_remote_device_stopped(scic, sci_dev);
+}
+
+static void scic_sds_remote_device_starting_state_enter(struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
+
+	isci_remote_device_not_ready(ihost, idev,
+				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
+}
+
+static void scic_sds_remote_device_ready_state_enter(struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
+	SET_STATE_HANDLER(sci_dev,
+			  scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_READY);
+
+	scic->remote_device_sequence[sci_dev->rnc.remote_node_index]++;
+
+	if (sci_dev->has_ready_substate_machine)
+		sci_base_state_machine_start(&sci_dev->ready_substate_machine);
+	else
+		isci_remote_device_ready(ihost, idev);
+}
+
+static void scic_sds_remote_device_ready_state_exit(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	if (sci_dev->has_ready_substate_machine)
+		sci_base_state_machine_stop(&sci_dev->ready_substate_machine);
+	else {
+		struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+		struct isci_host *ihost = sci_object_get_association(scic);
+		struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
+		isci_remote_device_not_ready(ihost, idev,
+					     SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);
+	}
+}
+
+static void scic_sds_remote_device_stopping_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_remote_device_state_handler_table,
+		SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
+		);
+}
+
+static void scic_sds_remote_device_failed_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_remote_device_state_handler_table,
+		SCI_BASE_REMOTE_DEVICE_STATE_FAILED
+		);
+}
+
+static void scic_sds_remote_device_resetting_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_remote_device_state_handler_table,
+		SCI_BASE_REMOTE_DEVICE_STATE_RESETTING
+		);
+
+	scic_sds_remote_node_context_suspend(
+		&sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
+}
+
+static void scic_sds_remote_device_resetting_state_exit(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
+}
+
+static void scic_sds_remote_device_final_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_remote_device_state_handler_table,
+		SCI_BASE_REMOTE_DEVICE_STATE_FINAL
+		);
+}
+
+
+static const struct sci_base_state scic_sds_remote_device_state_table[] = {
+	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
+		.enter_state = scic_sds_remote_device_initial_state_enter,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
+		.enter_state = scic_sds_remote_device_stopped_state_enter,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
+		.enter_state = scic_sds_remote_device_starting_state_enter,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
+		.enter_state = scic_sds_remote_device_ready_state_enter,
+		.exit_state  = scic_sds_remote_device_ready_state_exit
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
+		.enter_state = scic_sds_remote_device_stopping_state_enter,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
+		.enter_state = scic_sds_remote_device_failed_state_enter,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
+		.enter_state = scic_sds_remote_device_resetting_state_enter,
+		.exit_state  = scic_sds_remote_device_resetting_state_exit
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
+		.enter_state = scic_sds_remote_device_final_state_enter,
+	},
+};
+
+/**
+ * scic_remote_device_construct() - This method will perform the construction
+ *    common to all remote device objects.
+ * @sci_port: SAS/SATA port through which this device is accessed.
+ * @sci_dev: remote device to construct
+ *
+ * It isn't necessary to call scic_remote_device_destruct() for device objects
+ * that have only called this method for construction. Once subsequent
+ * construction methods have been invoked (e.g.
+ * scic_remote_device_da_construct()), then destruction should occur. none
+ */
+static void scic_remote_device_construct(struct scic_sds_port *sci_port,
+				  struct scic_sds_remote_device *sci_dev)
+{
+	sci_dev->owning_port = sci_port;
+	sci_dev->started_request_count = 0;
+	sci_dev->parent.private = NULL;
+
+	sci_base_state_machine_construct(
+		&sci_dev->state_machine,
+		&sci_dev->parent,
+		scic_sds_remote_device_state_table,
+		SCI_BASE_REMOTE_DEVICE_STATE_INITIAL
+		);
+
+	sci_base_state_machine_start(
+		&sci_dev->state_machine
+		);
+
+	scic_sds_remote_node_context_construct(&sci_dev->rnc,
+					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
+
+	sci_object_set_association(&sci_dev->rnc, sci_dev);
+}
+
+/**
+ * scic_remote_device_da_construct() - This method will construct a
+ *    SCIC_REMOTE_DEVICE object for a direct attached (da) device.  The
+ *    information (e.g. IAF, Signature FIS, etc.) necessary to build the device
+ *    is known to the SCI Core since it is contained in the scic_phy object.
+ * @remote_device: This parameter specifies the remote device to be destructed.
+ *
+ * The user must have previously called scic_remote_device_construct() Remote
+ * device objects are a limited resource.  As such, they must be protected.
+ * Thus calls to construct and destruct are mutually exclusive and
+ * non-reentrant. Indicate if the remote device was successfully constructed.
+ * SCI_SUCCESS Returned if the device was successfully constructed.
+ * SCI_FAILURE_DEVICE_EXISTS Returned if the device has already been
+ * constructed.  If it's an additional phy for the target, then call
+ * scic_remote_device_da_add_phy(). SCI_FAILURE_UNSUPPORTED_PROTOCOL Returned
+ * if the supplied parameters necessitate creation of a remote device for which
+ * the protocol is not supported by the underlying controller hardware.
+ * SCI_FAILURE_INSUFFICIENT_RESOURCES This value is returned if the core
+ * controller associated with the supplied parameters is unable to support
+ * additional remote devices.
+ */
+static enum sci_status scic_remote_device_da_construct(struct scic_sds_remote_device *sci_dev)
+{
+	enum sci_status status;
+	u16 remote_node_index;
+	struct sci_sas_identify_address_frame_protocols protocols;
+
+	/*
+	 * This information is request to determine how many remote node context
+	 * entries will be needed to store the remote node.
+	 */
+	scic_sds_port_get_attached_protocols(sci_dev->owning_port, &protocols);
+	sci_dev->target_protocols.u.all = protocols.u.all;
+	sci_dev->is_direct_attached = true;
+#if !defined(DISABLE_ATAPI)
+	sci_dev->is_atapi = scic_sds_remote_device_is_atapi(sci_dev);
+#endif
+
+	status = scic_sds_controller_allocate_remote_node_context(
+		sci_dev->owning_port->owning_controller,
+		sci_dev,
+		&remote_node_index);
+
+	if (status == SCI_SUCCESS) {
+		sci_dev->rnc.remote_node_index = remote_node_index;
+
+		scic_sds_port_get_attached_sas_address(
+			sci_dev->owning_port, &sci_dev->device_address);
+
+		if (sci_dev->target_protocols.u.bits.attached_ssp_target) {
+			sci_dev->has_ready_substate_machine = false;
+		} else if (sci_dev->target_protocols.u.bits.attached_stp_target) {
+			sci_dev->has_ready_substate_machine = true;
+
+			sci_base_state_machine_construct(
+				&sci_dev->ready_substate_machine,
+				&sci_dev->parent,
+				scic_sds_stp_remote_device_ready_substate_table,
+				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		} else if (sci_dev->target_protocols.u.bits.attached_smp_target) {
+			sci_dev->has_ready_substate_machine = true;
+
+			/* add the SMP ready substate machine construction here */
+			sci_base_state_machine_construct(
+				&sci_dev->ready_substate_machine,
+				&sci_dev->parent,
+				scic_sds_smp_remote_device_ready_substate_table,
+				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		}
+
+		sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(
+			sci_dev->owning_port);
+
+		/* / @todo Should I assign the port width by reading all of the phys on the port? */
+		sci_dev->device_port_width = 1;
+	}
+
+	return status;
+}
+
+static void scic_sds_remote_device_get_info_from_smp_discover_response(
+	struct scic_sds_remote_device *sci_dev,
+	struct smp_response_discover *discover_response)
+{
+	/* decode discover_response to set sas_address to sci_dev. */
+	sci_dev->device_address.high =
+		discover_response->attached_sas_address.high;
+
+	sci_dev->device_address.low =
+		discover_response->attached_sas_address.low;
+
+	sci_dev->target_protocols.u.all = discover_response->protocols.u.all;
+}
+
+/**
+ * scic_remote_device_ea_construct() - This method will construct an
+ *    SCIC_REMOTE_DEVICE object for an expander attached (ea) device from an
+ *    SMP Discover Response.
+ * @remote_device: This parameter specifies the remote device to be destructed.
+ * @discover_response: This parameter specifies the SMP Discovery Response to
+ *    be used in device creation.
+ *
+ * The user must have previously called scic_remote_device_construct() Remote
+ * device objects are a limited resource.  As such, they must be protected.
+ * Thus calls to construct and destruct are mutually exclusive and
+ * non-reentrant. Indicate if the remote device was successfully constructed.
+ * SCI_SUCCESS Returned if the device was successfully constructed.
+ * SCI_FAILURE_DEVICE_EXISTS Returned if the device has already been
+ * constructed.  If it's an additional phy for the target, then call
+ * scic_ea_remote_device_add_phy(). SCI_FAILURE_UNSUPPORTED_PROTOCOL Returned
+ * if the supplied parameters necessitate creation of a remote device for which
+ * the protocol is not supported by the underlying controller hardware.
+ * SCI_FAILURE_INSUFFICIENT_RESOURCES This value is returned if the core
+ * controller associated with the supplied parameters is unable to support
+ * additional remote devices.
+ */
+static enum sci_status scic_remote_device_ea_construct(struct scic_sds_remote_device *sci_dev,
+						       struct smp_response_discover *discover_response)
+{
+	enum sci_status status;
+	struct scic_sds_controller *scic;
+
+	scic = scic_sds_port_get_controller(sci_dev->owning_port);
+
+	scic_sds_remote_device_get_info_from_smp_discover_response(
+		sci_dev, discover_response);
+
+	status = scic_sds_controller_allocate_remote_node_context(
+		scic, sci_dev, &sci_dev->rnc.remote_node_index);
+
+	if (status == SCI_SUCCESS) {
+		if (sci_dev->target_protocols.u.bits.attached_ssp_target) {
+			sci_dev->has_ready_substate_machine = false;
+		} else if (sci_dev->target_protocols.u.bits.attached_smp_target) {
+			sci_dev->has_ready_substate_machine = true;
+
+			/* add the SMP ready substate machine construction here */
+			sci_base_state_machine_construct(
+				&sci_dev->ready_substate_machine,
+				&sci_dev->parent,
+				scic_sds_smp_remote_device_ready_substate_table,
+				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		} else if (sci_dev->target_protocols.u.bits.attached_stp_target) {
+			sci_dev->has_ready_substate_machine = true;
+
+			sci_base_state_machine_construct(
+				&sci_dev->ready_substate_machine,
+				&sci_dev->parent,
+				scic_sds_stp_remote_device_ready_substate_table,
+				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		}
+
+		/*
+		 * For SAS-2 the physical link rate is actually a logical link
+		 * rate that incorporates multiplexing.  The SCU doesn't
+		 * incorporate multiplexing and for the purposes of the
+		 * connection the logical link rate is that same as the
+		 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
+		 * one another, so this code works for both situations. */
+		sci_dev->connection_rate = min_t(u16,
+			scic_sds_port_get_max_allowed_speed(sci_dev->owning_port),
+			discover_response->u2.sas1_1.negotiated_physical_link_rate
+			);
+
+		/* / @todo Should I assign the port width by reading all of the phys on the port? */
+		sci_dev->device_port_width = 1;
+	}
+
+	return status;
+}
+
+/**
+ * scic_remote_device_start() - This method will start the supplied remote
+ *    device.  This method enables normal IO requests to flow through to the
+ *    remote device.
+ * @remote_device: This parameter specifies the device to be started.
+ * @timeout: This parameter specifies the number of milliseconds in which the
+ *    start operation should complete.
+ *
+ * An indication of whether the device was successfully started. SCI_SUCCESS
+ * This value is returned if the device was successfully started.
+ * SCI_FAILURE_INVALID_PHY This value is returned if the user attempts to start
+ * the device when there have been no phys added to it.
+ */
+static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *sci_dev,
+					 u32 timeout)
+{
+	return sci_dev->state_handlers->start_handler(sci_dev);
+}
 
 /**
  * isci_remote_device_construct() - This function calls the scic remote device
@@ -307,51 +1870,6 @@ void isci_remote_device_not_ready(struct isci_host *ihost,
 }
 
 /**
- * isci_remote_device_stop_complete() - This function is called by the scic
- *    when the remote device stop has completed. We mark the isci device as not
- *    ready and remove the isci remote device.
- * @isci_host: This parameter specifies the isci host object.
- * @isci_device: This parameter specifies the remote device.
- * @status: This parameter specifies status of the completion.
- *
- */
-void isci_remote_device_stop_complete(
-	struct isci_host *isci_host,
-	struct isci_remote_device *isci_device,
-	enum sci_status status)
-{
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: complete isci_device = %p, status = 0x%x\n",
-		__func__,
-		isci_device,
-		status);
-
-	isci_remote_device_change_state(isci_device, isci_stopped);
-
-	/* after stop, we can tear down resources. */
-	isci_remote_device_deconstruct(isci_host, isci_device);
-
-}
-
-/**
- * isci_remote_device_start_complete() - This function is called by the scic
- *    when the remote device start has completed
- * @isci_host: This parameter specifies the isci host object.
- * @isci_device: This parameter specifies the remote device.
- * @status: This parameter specifies status of the completion.
- *
- */
-void isci_remote_device_start_complete(
-	struct isci_host *isci_host,
-	struct isci_remote_device *isci_device,
-	enum sci_status status)
-{
-
-
-}
-
-
-/**
  * isci_remote_device_stop() - This function is called internally to stop the
  *    remote device.
  * @isci_host: This parameter specifies the isci host object.
@@ -572,21 +2090,3 @@ void isci_device_clear_reset_pending(struct isci_host *ihost, struct isci_remote
 	}
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
-
-/**
- * isci_remote_device_change_state() - This function gets the status of the
- *    remote_device object.
- * @isci_device: This parameter points to the isci_remote_device object
- *
- * status of the object as a isci_status enum.
- */
-void isci_remote_device_change_state(
-	struct isci_remote_device *isci_device,
-	enum isci_status status)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&isci_device->state_lock, flags);
-	isci_device->status = status;
-	spin_unlock_irqrestore(&isci_device->state_lock, flags);
-}
diff --git a/drivers/scsi/isci/remote_device.h b/drivers/scsi/isci/remote_device.h
index aeda395..9d8fcbf 100644
--- a/drivers/scsi/isci/remote_device.h
+++ b/drivers/scsi/isci/remote_device.h
@@ -53,11 +53,127 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#if !defined(_ISCI_REMOTE_DEVICE_H_)
+#ifndef _ISCI_REMOTE_DEVICE_H_
 #define _ISCI_REMOTE_DEVICE_H_
-#include "scic_sds_remote_device.h"
+#include <scsi/libsas.h>
+#include "sci_status.h"
+#include "intel_sas.h"
+#include "scu_remote_node_context.h"
+#include "remote_node_context.h"
+#include "port.h"
 
-struct isci_host;
+enum scic_remote_device_not_ready_reason_code {
+	SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED,
+	SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED,
+	SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED,
+	SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED,
+	SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED,
+
+	SCIC_REMOTE_DEVICE_NOT_READY_REASON_CODE_MAX
+
+};
+
+struct scic_sds_remote_device {
+	/**
+	 * The field specifies that the parent object for the base remote
+	 * device is the base object itself.
+	 */
+	struct sci_base_object parent;
+
+	/**
+	 * This field contains the information for the base remote device state
+	 * machine.
+	 */
+	struct sci_base_state_machine state_machine;
+
+	/**
+	 * This field is the programmed device port width.  This value is
+	 * written to the RCN data structure to tell the SCU how many open
+	 * connections this device can have.
+	 */
+	u32 device_port_width;
+
+	/**
+	 * This field is the programmed connection rate for this remote device.  It is
+	 * used to program the TC with the maximum allowed connection rate.
+	 */
+	enum sas_linkrate connection_rate;
+
+	/**
+	 * This field contains the allowed target protocols for this remote device.
+	 */
+	struct smp_discover_response_protocols target_protocols;
+
+	/**
+	 * This field contains the device SAS address.
+	 */
+	struct sci_sas_address device_address;
+
+	/**
+	 * This filed is assinged the value of true if the device is directly
+	 * attached to the port.
+	 */
+	bool is_direct_attached;
+
+#if !defined(DISABLE_ATAPI)
+	/**
+	 * This filed is assinged the value of true if the device is an ATAPI
+	 * device.
+	 */
+	bool is_atapi;
+#endif
+
+	/**
+	 * This filed contains a pointer back to the port to which this device
+	 * is assigned.
+	 */
+	struct scic_sds_port *owning_port;
+
+	/**
+	 * This field contains the SCU silicon remote node context specific
+	 * information.
+	 */
+	struct scic_sds_remote_node_context rnc;
+
+	/**
+	 * This field contains the stated request count for the remote device.  The
+	 * device can not reach the SCI_BASE_REMOTE_DEVICE_STATE_STOPPED until all
+	 * requests are complete and the rnc_posted value is false.
+	 */
+	u32 started_request_count;
+
+	/**
+	 * This field contains a pointer to the working request object.  It is only
+	 * used only for SATA requests since the unsolicited frames we get from the
+	 * hardware have no Tag value to look up the io request object.
+	 */
+	struct scic_sds_request *working_request;
+
+	/**
+	 * This field contains the reason for the remote device going not_ready.  It is
+	 * assigned in the state handlers and used in the state transition.
+	 */
+	u32 not_ready_reason;
+
+	/**
+	 * This field is true if this remote device has an initialzied ready substate
+	 * machine. SSP devices do not have a ready substate machine and STP devices
+	 * have a ready substate machine.
+	 */
+	bool has_ready_substate_machine;
+
+	/**
+	 * This field contains the state machine for the ready substate machine for
+	 * this struct scic_sds_remote_device object.
+	 */
+	struct sci_base_state_machine ready_substate_machine;
+
+	/**
+	 * This field maintains the set of state handlers for the remote device
+	 * object.  These are changed each time the remote device enters a new state.
+	 */
+	const struct scic_sds_remote_device_state_handler *state_handlers;
+};
 
 struct isci_remote_device {
 	enum isci_status status;
@@ -75,12 +191,6 @@ struct isci_remote_device {
 
 #define ISCI_REMOTE_DEVICE_START_TIMEOUT 5000
 
-void isci_remote_device_start_complete(struct isci_host *ihost,
-				       struct isci_remote_device *idev,
-				       enum sci_status);
-void isci_remote_device_stop_complete(struct isci_host *ihost,
-				      struct isci_remote_device *idev,
-				      enum sci_status);
 enum sci_status isci_remote_device_stop(struct isci_host *ihost,
 					struct isci_remote_device *idev);
 void isci_remote_device_nuke_requests(struct isci_host *ihost,
@@ -97,5 +207,619 @@ void isci_device_clear_reset_pending(struct isci_host *ihost,
 				     struct isci_remote_device *idev);
 void isci_remote_device_change_state(struct isci_remote_device *idev,
 				     enum isci_status status);
+/**
+ * scic_remote_device_stop() - This method will stop both transmission and
+ *    reception of link activity for the supplied remote device.  This method
+ *    disables normal IO requests from flowing through to the remote device.
+ * @remote_device: This parameter specifies the device to be stopped.
+ * @timeout: This parameter specifies the number of milliseconds in which the
+ *    stop operation should complete.
+ *
+ * An indication of whether the device was successfully stopped. SCI_SUCCESS
+ * This value is returned if the transmission and reception for the device was
+ * successfully stopped.
+ */
+enum sci_status scic_remote_device_stop(
+	struct scic_sds_remote_device *remote_device,
+	u32 timeout);
+
+/**
+ * scic_remote_device_reset() - This method will reset the device making it
+ *    ready for operation. This method must be called anytime the device is
+ *    reset either through a SMP phy control or a port hard reset request.
+ * @remote_device: This parameter specifies the device to be reset.
+ *
+ * This method does not actually cause the device hardware to be reset. This
+ * method resets the software object so that it will be operational after a
+ * device hardware reset completes. An indication of whether the device reset
+ * was accepted. SCI_SUCCESS This value is returned if the device reset is
+ * started.
+ */
+enum sci_status scic_remote_device_reset(
+	struct scic_sds_remote_device *remote_device);
+
+/**
+ * scic_remote_device_reset_complete() - This method informs the device object
+ *    that the reset operation is complete and the device can resume operation
+ *    again.
+ * @remote_device: This parameter specifies the device which is to be informed
+ *    of the reset complete operation.
+ *
+ * An indication that the device is resuming operation. SCI_SUCCESS the device
+ * is resuming operation.
+ */
+enum sci_status scic_remote_device_reset_complete(
+	struct scic_sds_remote_device *remote_device);
+
+
+
+/**
+ * scic_remote_device_get_connection_rate() - This method simply returns the
+ *    link rate at which communications to the remote device occur.
+ * @remote_device: This parameter specifies the device for which to get the
+ *    connection rate.
+ *
+ * Return the link rate at which we transfer for the supplied remote device.
+ */
+enum sas_linkrate scic_remote_device_get_connection_rate(
+	struct scic_sds_remote_device *remote_device);
+
+/**
+ * scic_remote_device_get_protocols() - This method will indicate which
+ *    protocols are supported by this remote device.
+ * @remote_device: This parameter specifies the device for which to return the
+ *    protocol.
+ * @protocols: This parameter specifies the output values, from the remote
+ *    device object, which indicate the protocols supported by the supplied
+ *    remote_device.
+ *
+ * The type of protocols supported by this device.  The values are returned as
+ * part of a bit mask in order to allow for multi-protocol support.
+ */
+void scic_remote_device_get_protocols(
+	struct scic_sds_remote_device *remote_device,
+	struct smp_discover_response_protocols *protocols);
+
+
+#if !defined(DISABLE_ATAPI)
+/**
+ * scic_remote_device_is_atapi() -
+ * @this_device: The device whose type is to be decided.
+ *
+ * This method first decide whether a device is a stp target, then decode the
+ * signature fis of a DA STP device to tell whether it is a standard end disk
+ * or an ATAPI device. bool Indicate a device is ATAPI device or not.
+ */
+bool scic_remote_device_is_atapi(
+	struct scic_sds_remote_device *device_handle);
+#else /* !defined(DISABLE_ATAPI) */
+#define scic_remote_device_is_atapi(device_handle) false
+#endif /* !defined(DISABLE_ATAPI) */
+
+
+
+/**
+ * enum scic_sds_remote_device_states - This enumeration depicts all the states
+ *    for the common remote device state machine.
+ *
+ *
+ */
+enum scic_sds_remote_device_states {
+	/**
+	 * Simply the initial state for the base remote device state machine.
+	 */
+	SCI_BASE_REMOTE_DEVICE_STATE_INITIAL,
+
+	/**
+	 * This state indicates that the remote device has successfully been
+	 * stopped.  In this state no new IO operations are permitted.
+	 * This state is entered from the INITIAL state.
+	 * This state is entered from the STOPPING state.
+	 */
+	SCI_BASE_REMOTE_DEVICE_STATE_STOPPED,
+
+	/**
+	 * This state indicates the the remote device is in the process of
+	 * becoming ready (i.e. starting).  In this state no new IO operations
+	 * are permitted.
+	 * This state is entered from the STOPPED state.
+	 */
+	SCI_BASE_REMOTE_DEVICE_STATE_STARTING,
+
+	/**
+	 * This state indicates the remote device is now ready.  Thus, the user
+	 * is able to perform IO operations on the remote device.
+	 * This state is entered from the STARTING state.
+	 */
+	SCI_BASE_REMOTE_DEVICE_STATE_READY,
+
+	/**
+	 * This state indicates that the remote device is in the process of
+	 * stopping.  In this state no new IO operations are permitted, but
+	 * existing IO operations are allowed to complete.
+	 * This state is entered from the READY state.
+	 * This state is entered from the FAILED state.
+	 */
+	SCI_BASE_REMOTE_DEVICE_STATE_STOPPING,
+
+	/**
+	 * This state indicates that the remote device has failed.
+	 * In this state no new IO operations are permitted.
+	 * This state is entered from the INITIALIZING state.
+	 * This state is entered from the READY state.
+	 */
+	SCI_BASE_REMOTE_DEVICE_STATE_FAILED,
+
+	/**
+	 * This state indicates the device is being reset.
+	 * In this state no new IO operations are permitted.
+	 * This state is entered from the READY state.
+	 */
+	SCI_BASE_REMOTE_DEVICE_STATE_RESETTING,
+
+	/**
+	 * Simply the final state for the base remote device state machine.
+	 */
+	SCI_BASE_REMOTE_DEVICE_STATE_FINAL,
+};
+
+/**
+ * enum scic_sds_ssp_remote_device_ready_substates -
+ *
+ * This is the enumeration of the ready substates for the
+ * struct scic_sds_remote_device.
+ */
+enum scic_sds_ssp_remote_device_ready_substates {
+	/**
+	 * This is the initial state for the remote device ready substate.
+	 */
+	SCIC_SDS_SSP_REMOTE_DEVICE_READY_SUBSTATE_INITIAL,
+
+	/**
+	 * This is the ready operational substate for the remote device.
+	 * This is the normal operational state for a remote device.
+	 */
+	SCIC_SDS_SSP_REMOTE_DEVICE_READY_SUBSTATE_OPERATIONAL,
+
+	/**
+	 * This is the suspended state for the remote device. This is the state
+	 * that the device is placed in when a RNC suspend is received by
+	 * the SCU hardware.
+	 */
+	SCIC_SDS_SSP_REMOTE_DEVICE_READY_SUBSTATE_SUSPENDED,
+
+	/**
+	 * This is the final state that the device is placed in before a change
+	 * to the base state machine.
+	 */
+	SCIC_SDS_SSP_REMOTE_DEVICE_READY_SUBSTATE_FINAL,
+
+	SCIC_SDS_SSP_REMOTE_DEVICE_READY_MAX_SUBSTATES
+};
+
+/**
+ * enum scic_sds_stp_remote_device_ready_substates -
+ *
+ * This is the enumeration for the struct scic_sds_remote_device ready substates
+ * for the STP remote device.
+ */
+enum scic_sds_stp_remote_device_ready_substates {
+	/**
+	 * This is the idle substate for the stp remote device.  When there are no
+	 * active IO for the device it is is in this state.
+	 */
+	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE,
+
+	/**
+	 * This is the command state for for the STP remote device.  This state is
+	 * entered when the device is processing a non-NCQ command.  The device object
+	 * will fail any new start IO requests until this command is complete.
+	 */
+	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD,
+
+	/**
+	 * This is the NCQ state for the STP remote device.  This state is entered
+	 * when the device is processing an NCQ reuqest.  It will remain in this state
+	 * so long as there is one or more NCQ requests being processed.
+	 */
+	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ,
+
+	/**
+	 * This is the NCQ error state for the STP remote device.  This state is
+	 * entered when an SDB error FIS is received by the device object while in the
+	 * NCQ state.  The device object will only accept a READ LOG command while in
+	 * this state.
+	 */
+	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR,
+
+#if !defined(DISABLE_ATAPI)
+	/**
+	 * This is the ATAPI error state for the STP ATAPI remote device.  This state is
+	 * entered when ATAPI device sends error status FIS without data while the device
+	 * object is in CMD state. A suspension event is expected in this state. The device
+	 * object will resume right away.
+	 */
+	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR,
+#endif
+
+	/**
+	 * This is the READY substate indicates the device is waiting for the RESET task
+	 * coming to be recovered from certain hardware specific error.
+	 */
+	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET,
+};
+
+/**
+ * enum scic_sds_smp_remote_device_ready_substates -
+ *
+ * This is the enumeration of the ready substates for the SMP REMOTE DEVICE.
+ */
+enum scic_sds_smp_remote_device_ready_substates {
+	/**
+	 * This is the ready operational substate for the remote device.  This is the
+	 * normal operational state for a remote device.
+	 */
+	SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE,
+
+	/**
+	 * This is the suspended state for the remote device.  This is the state that
+	 * the device is placed in when a RNC suspend is received by the SCU hardware.
+	 */
+	SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD,
+};
+
+static inline struct scic_sds_remote_device *rnc_to_dev(struct scic_sds_remote_node_context *rnc)
+{
+	struct scic_sds_remote_device *sci_dev;
+
+	sci_dev = container_of(rnc, typeof(*sci_dev), rnc);
+
+	return sci_dev;
+}
+
+typedef enum sci_status (*scic_sds_remote_device_request_handler_t)(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request);
+
+typedef enum sci_status (*scic_sds_remote_device_high_priority_request_complete_handler_t)(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request,
+	void *,
+	enum sci_io_status);
+
+typedef enum sci_status (*scic_sds_remote_device_handler_t)(
+	struct scic_sds_remote_device *sci_dev);
+
+typedef enum sci_status (*scic_sds_remote_device_suspend_handler_t)(
+	struct scic_sds_remote_device *sci_dev,
+	u32 suspend_type);
+
+typedef enum sci_status (*scic_sds_remote_device_resume_handler_t)(
+	struct scic_sds_remote_device *sci_dev);
+
+typedef enum sci_status (*scic_sds_remote_device_frame_handler_t)(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index);
+
+typedef enum sci_status (*scic_sds_remote_device_event_handler_t)(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code);
+
+typedef void (*scic_sds_remote_device_ready_not_ready_handler_t)(
+	struct scic_sds_remote_device *sci_dev);
+
+/**
+ * struct scic_sds_remote_device_state_handler - This structure conains the
+ *    state handlers that are needed to process requests for the SCU remote
+ *    device objects.
+ *
+ *
+ */
+struct scic_sds_remote_device_state_handler {
+	/**
+	 * The start_handler specifies the method invoked when a user
+	 * attempts to start a remote device.
+	 */
+	scic_sds_remote_device_handler_t start_handler;
+
+	/**
+	 * The stop_handler specifies the method invoked when a user attempts to
+	 * stop a remote device.
+	 */
+	scic_sds_remote_device_handler_t stop_handler;
+
+	/**
+	 * The fail_handler specifies the method invoked when a remote device
+	 * failure has occurred.  A failure may be due to an inability to
+	 * initialize/configure the device.
+	 */
+	scic_sds_remote_device_handler_t fail_handler;
+
+	/**
+	 * The destruct_handler specifies the method invoked when attempting to
+	 * destruct a remote device.
+	 */
+	scic_sds_remote_device_handler_t destruct_handler;
+
+	/**
+	 * The reset handler specifies the method invloked when requesting to
+	 * reset a remote device.
+	 */
+	scic_sds_remote_device_handler_t reset_handler;
+
+	/**
+	 * The reset complete handler specifies the method invloked when
+	 * reporting that a reset has completed to the remote device.
+	 */
+	scic_sds_remote_device_handler_t reset_complete_handler;
+
+	/**
+	 * The start_io_handler specifies the method invoked when a user
+	 * attempts to start an IO request for a remote device.
+	 */
+	scic_sds_remote_device_request_handler_t start_io_handler;
+
+	/**
+	 * The complete_io_handler specifies the method invoked when a user
+	 * attempts to complete an IO request for a remote device.
+	 */
+	scic_sds_remote_device_request_handler_t complete_io_handler;
+
+	/**
+	 * The continue_io_handler specifies the method invoked when a user
+	 * attempts to continue an IO request for a remote device.
+	 */
+	scic_sds_remote_device_request_handler_t continue_io_handler;
+
+	/**
+	 * The start_task_handler specifies the method invoked when a user
+	 * attempts to start a task management request for a remote device.
+	 */
+	scic_sds_remote_device_request_handler_t start_task_handler;
+
+	/**
+	 * The complete_task_handler specifies the method invoked when a user
+	 * attempts to complete a task management request for a remote device.
+	 */
+	scic_sds_remote_device_request_handler_t complete_task_handler;
+
+
+	scic_sds_remote_device_suspend_handler_t suspend_handler;
+	scic_sds_remote_device_resume_handler_t resume_handler;
+	scic_sds_remote_device_event_handler_t event_handler;
+	scic_sds_remote_device_frame_handler_t frame_handler;
+};
+
+extern const struct sci_base_state scic_sds_ssp_remote_device_ready_substate_table[];
+extern const struct sci_base_state scic_sds_stp_remote_device_ready_substate_table[];
+extern const struct sci_base_state scic_sds_smp_remote_device_ready_substate_table[];
+
+/**
+ * scic_sds_remote_device_increment_request_count() -
+ *
+ * This macro incrments the request count for this device
+ */
+#define scic_sds_remote_device_increment_request_count(sci_dev) \
+	((sci_dev)->started_request_count++)
+
+/**
+ * scic_sds_remote_device_decrement_request_count() -
+ *
+ * This macro decrements the request count for this device.  This count will
+ * never decrment past 0.
+ */
+#define scic_sds_remote_device_decrement_request_count(sci_dev) \
+	((sci_dev)->started_request_count > 0 ? \
+	 (sci_dev)->started_request_count-- : 0)
+
+/**
+ * scic_sds_remote_device_get_request_count() -
+ *
+ * This is a helper macro to return the current device request count.
+ */
+#define scic_sds_remote_device_get_request_count(sci_dev) \
+	((sci_dev)->started_request_count)
+
+/**
+ * scic_sds_remote_device_get_port() -
+ *
+ * This macro returns the owning port of this remote device obejct.
+ */
+#define scic_sds_remote_device_get_port(sci_dev) \
+	((sci_dev)->owning_port)
+
+/**
+ * scic_sds_remote_device_get_controller() -
+ *
+ * This macro returns the controller object that contains this device object
+ */
+#define scic_sds_remote_device_get_controller(sci_dev) \
+	scic_sds_port_get_controller(scic_sds_remote_device_get_port(sci_dev))
+
+/**
+ * scic_sds_remote_device_set_state_handlers() -
+ *
+ * This macro sets the remote device state handlers pointer and is set on entry
+ * to each device state.
+ */
+#define scic_sds_remote_device_set_state_handlers(sci_dev, handlers) \
+	((sci_dev)->state_handlers = (handlers))
+
+/**
+ * scic_sds_remote_device_get_port() -
+ *
+ * This macro returns the owning port of this device
+ */
+#define scic_sds_remote_device_get_port(sci_dev) \
+	((sci_dev)->owning_port)
+
+/**
+ * scic_sds_remote_device_get_sequence() -
+ *
+ * This macro returns the remote device sequence value
+ */
+#define scic_sds_remote_device_get_sequence(sci_dev) \
+	(\
+		scic_sds_remote_device_get_controller(sci_dev)-> \
+		remote_device_sequence[(sci_dev)->rnc.remote_node_index] \
+	)
+
+/**
+ * scic_sds_remote_device_get_controller_peg() -
+ *
+ * This macro returns the controllers protocol engine group
+ */
+#define scic_sds_remote_device_get_controller_peg(sci_dev) \
+	(\
+		scic_sds_controller_get_protocol_engine_group(\
+			scic_sds_port_get_controller(\
+				scic_sds_remote_device_get_port(sci_dev) \
+				) \
+			) \
+	)
+
+/**
+ * scic_sds_remote_device_get_port_index() -
+ *
+ * This macro returns the port index for the devices owning port
+ */
+#define scic_sds_remote_device_get_port_index(sci_dev) \
+	(scic_sds_port_get_index(scic_sds_remote_device_get_port(sci_dev)))
+
+/**
+ * scic_sds_remote_device_get_index() -
+ *
+ * This macro returns the remote node index for this device object
+ */
+#define scic_sds_remote_device_get_index(sci_dev) \
+	((sci_dev)->rnc.remote_node_index)
+
+/**
+ * scic_sds_remote_device_build_command_context() -
+ *
+ * This macro builds a remote device context for the SCU post request operation
+ */
+#define scic_sds_remote_device_build_command_context(device, command) \
+	((command) \
+	 | (scic_sds_remote_device_get_controller_peg((device)) << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) \
+	 | (scic_sds_remote_device_get_port_index((device)) << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) \
+	 | (scic_sds_remote_device_get_index((device)))	\
+	)
+
+/**
+ * scic_sds_remote_device_set_working_request() -
+ *
+ * This macro makes the working request assingment for the remote device
+ * object. To clear the working request use this macro with a NULL request
+ * object.
+ */
+#define scic_sds_remote_device_set_working_request(device, request) \
+	((device)->working_request = (request))
+
+enum sci_status scic_sds_remote_device_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index);
+
+enum sci_status scic_sds_remote_device_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code);
+
+enum sci_status scic_sds_remote_device_start_io(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *io_request);
+
+enum sci_status scic_sds_remote_device_complete_io(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *io_request);
+
+enum sci_status scic_sds_remote_device_resume(
+	struct scic_sds_remote_device *sci_dev);
+
+enum sci_status scic_sds_remote_device_suspend(
+	struct scic_sds_remote_device *sci_dev,
+	u32 suspend_type);
+
+enum sci_status scic_sds_remote_device_start_task(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *io_request);
+
+void scic_sds_remote_device_post_request(
+	struct scic_sds_remote_device *sci_dev,
+	u32 request);
+
+#if !defined(DISABLE_ATAPI)
+bool scic_sds_remote_device_is_atapi(
+	struct scic_sds_remote_device *sci_dev);
+#else /* !defined(DISABLE_ATAPI) */
+#define scic_sds_remote_device_is_atapi(sci_dev) false
+#endif /* !defined(DISABLE_ATAPI) */
+
+void scic_sds_remote_device_start_request(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req,
+	enum sci_status status);
+
+void scic_sds_remote_device_continue_request(void *sci_dev);
+
+enum sci_status scic_sds_remote_device_default_start_handler(
+	struct scic_sds_remote_device *sci_dev);
+
+enum sci_status scic_sds_remote_device_default_fail_handler(
+	struct scic_sds_remote_device *sci_dev);
+
+enum sci_status scic_sds_remote_device_default_destruct_handler(
+	struct scic_sds_remote_device *sci_dev);
+
+enum sci_status scic_sds_remote_device_default_reset_handler(
+	struct scic_sds_remote_device *device);
+
+enum sci_status scic_sds_remote_device_default_reset_complete_handler(
+	struct scic_sds_remote_device *device);
+
+enum sci_status scic_sds_remote_device_default_start_request_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request);
+
+enum sci_status scic_sds_remote_device_default_complete_request_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request);
+
+enum sci_status scic_sds_remote_device_default_continue_request_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request);
+
+enum sci_status scic_sds_remote_device_default_suspend_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 suspend_type);
+
+enum sci_status scic_sds_remote_device_default_resume_handler(
+	struct scic_sds_remote_device *sci_dev);
+
+
+enum sci_status scic_sds_remote_device_default_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index);
+
+enum sci_status scic_sds_remote_device_ready_state_stop_handler(
+	struct scic_sds_remote_device *device);
+
+enum sci_status scic_sds_remote_device_ready_state_reset_handler(
+	struct scic_sds_remote_device *device);
+
+enum sci_status scic_sds_remote_device_general_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index);
+
+enum sci_status scic_sds_remote_device_general_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code);
+
+enum sci_status scic_sds_ssp_remote_device_ready_suspended_substate_resume_handler(
+	struct scic_sds_remote_device *sci_dev);
+
+
 
 #endif /* !defined(_ISCI_REMOTE_DEVICE_H_) */
diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
new file mode 100644
index 0000000..bdf0b51
--- /dev/null
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -0,0 +1,1226 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "sci_base_state_machine.h"
+#include "scic_sds_controller.h"
+#include "scic_sds_port.h"
+#include "remote_device.h"
+#include "remote_node_context.h"
+#include "sci_environment.h"
+#include "sci_util.h"
+#include "scu_event_codes.h"
+#include "scu_task_context.h"
+
+
+/**
+ *
+ * @sci_rnc: The RNC for which the is posted request is being made.
+ *
+ * This method will return true if the RNC is not in the initial state.  In all
+ * other states the RNC is considered active and this will return true. The
+ * destroy request of the state machine drives the RNC back to the initial
+ * state.  If the state machine changes then this routine will also have to be
+ * changed. bool true if the state machine is not in the initial state false if
+ * the state machine is in the initial state
+ */
+
+/**
+ *
+ * @sci_rnc: The state of the remote node context object to check.
+ *
+ * This method will return true if the remote node context is in a READY state
+ * otherwise it will return false bool true if the remote node context is in
+ * the ready state. false if the remote node context is not in the ready state.
+ */
+bool scic_sds_remote_node_context_is_ready(
+	struct scic_sds_remote_node_context *sci_rnc)
+{
+	u32 current_state = sci_base_state_machine_get_state(&sci_rnc->state_machine);
+
+	if (current_state == SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE) {
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ *
+ * @sci_dev: The remote device to use to construct the RNC buffer.
+ * @rnc: The buffer into which the remote device data will be copied.
+ *
+ * This method will construct the RNC buffer for this remote device object. none
+ */
+static void scic_sds_remote_node_context_construct_buffer(
+	struct scic_sds_remote_node_context *sci_rnc)
+{
+	union scu_remote_node_context *rnc;
+	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
+	struct scic_sds_controller *scic;
+
+	scic = scic_sds_remote_device_get_controller(sci_dev);
+
+	rnc = scic_sds_controller_get_remote_node_context_buffer(
+		scic, sci_rnc->remote_node_index);
+
+	memset(rnc, 0, sizeof(union scu_remote_node_context)
+		* scic_sds_remote_device_node_count(sci_dev));
+
+	rnc->ssp.remote_node_index = sci_rnc->remote_node_index;
+	rnc->ssp.remote_node_port_width = sci_dev->device_port_width;
+	rnc->ssp.logical_port_index =
+		scic_sds_remote_device_get_port_index(sci_dev);
+
+	rnc->ssp.remote_sas_address_hi = SCIC_SWAP_DWORD(sci_dev->device_address.high);
+	rnc->ssp.remote_sas_address_lo = SCIC_SWAP_DWORD(sci_dev->device_address.low);
+
+	rnc->ssp.nexus_loss_timer_enable = true;
+	rnc->ssp.check_bit               = false;
+	rnc->ssp.is_valid                = false;
+	rnc->ssp.is_remote_node_context  = true;
+	rnc->ssp.function_number         = 0;
+
+	rnc->ssp.arbitration_wait_time = 0;
+
+
+	if (
+		sci_dev->target_protocols.u.bits.attached_sata_device
+		|| sci_dev->target_protocols.u.bits.attached_stp_target
+		) {
+		rnc->ssp.connection_occupancy_timeout =
+			scic->user_parameters.sds1.stp_max_occupancy_timeout;
+		rnc->ssp.connection_inactivity_timeout =
+			scic->user_parameters.sds1.stp_inactivity_timeout;
+	} else {
+		rnc->ssp.connection_occupancy_timeout  =
+			scic->user_parameters.sds1.ssp_max_occupancy_timeout;
+		rnc->ssp.connection_inactivity_timeout =
+			scic->user_parameters.sds1.ssp_inactivity_timeout;
+	}
+
+	rnc->ssp.initial_arbitration_wait_time = 0;
+
+	/* Open Address Frame Parameters */
+	rnc->ssp.oaf_connection_rate = sci_dev->connection_rate;
+	rnc->ssp.oaf_features = 0;
+	rnc->ssp.oaf_source_zone_group = 0;
+	rnc->ssp.oaf_more_compatibility_features = 0;
+}
+
+/**
+ *
+ * @sci_rnc:
+ * @callback:
+ * @callback_parameter:
+ *
+ * This method will setup the remote node context object so it will transition
+ * to its ready state.  If the remote node context is already setup to
+ * transition to its final state then this function does nothing. none
+ */
+static void scic_sds_remote_node_context_setup_to_resume(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	if (sci_rnc->destination_state != SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
+		sci_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY;
+		sci_rnc->user_callback     = callback;
+		sci_rnc->user_cookie       = callback_parameter;
+	}
+}
+
+/**
+ *
+ * @sci_rnc:
+ * @callback:
+ * @callback_parameter:
+ *
+ * This method will setup the remote node context object so it will transistion
+ * to its final state. none
+ */
+static void scic_sds_remote_node_context_setup_to_destory(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	sci_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL;
+	sci_rnc->user_callback     = callback;
+	sci_rnc->user_cookie       = callback_parameter;
+}
+
+/**
+ *
+ * @sci_rnc:
+ * @callback:
+ *
+ * This method will continue to resume a remote node context.  This is used in
+ * the states where a resume is requested while a resume is in progress.
+ */
+static enum sci_status scic_sds_remote_node_context_continue_to_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY) {
+		sci_rnc->user_callback = callback;
+		sci_rnc->user_cookie   = callback_parameter;
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_default_destruct_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to stop while "
+		 "in unexpected state %d\n",
+		 __func__,
+		 sci_rnc,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	/*
+	 * We have decided that the destruct request on the remote node context can not fail
+	 * since it is either in the initial/destroyed state or is can be destroyed. */
+	return SCI_SUCCESS;
+}
+
+static enum sci_status scic_sds_remote_node_context_default_suspend_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 suspend_type,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to suspend "
+		 "while in wrong state %d\n",
+		 __func__,
+		 sci_rnc,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status scic_sds_remote_node_context_default_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to resume "
+		 "while in wrong state %d\n",
+		 __func__,
+		 sci_rnc,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status scic_sds_remote_node_context_default_start_io_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to start io "
+		 "0x%p while in wrong state %d\n",
+		 __func__,
+		 sci_rnc,
+		 sci_req,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
+}
+
+static enum sci_status scic_sds_remote_node_context_default_start_task_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to start "
+		 "task 0x%p while in wrong state %d\n",
+		 __func__,
+		 sci_rnc,
+		 sci_req,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	return SCI_FAILURE;
+}
+
+static enum sci_status scic_sds_remote_node_context_default_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to process "
+		 "event 0x%x while in wrong state %d\n",
+		 __func__,
+		 sci_rnc,
+		 event_code,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+/**
+ *
+ * @sci_rnc: The rnc for which the task request is targeted.
+ * @sci_req: The request which is going to be started.
+ *
+ * This method determines if the task request can be started by the SCU
+ * hardware. When the RNC is in the ready state any task can be started.
+ * enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_node_context_success_start_task_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @sci_rnc:
+ * @callback:
+ * @callback_parameter:
+ *
+ * This method handles destruct calls from the various state handlers.  The
+ * remote node context can be requested to destroy from any state. If there was
+ * a user callback it is always replaced with the request to destroy user
+ * callback. enum sci_status
+ */
+static enum sci_status scic_sds_remote_node_context_general_destruct_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	scic_sds_remote_node_context_setup_to_destory(
+		sci_rnc, callback, callback_parameter
+		);
+
+	sci_base_state_machine_change_state(
+		&sci_rnc->state_machine,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
+		);
+
+	return SCI_SUCCESS;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_initial_state_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	if (sci_rnc->remote_node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
+		scic_sds_remote_node_context_setup_to_resume(
+			sci_rnc, callback, callback_parameter
+			);
+
+		scic_sds_remote_node_context_construct_buffer(sci_rnc);
+
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
+			);
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_posting_state_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_POST_RNC_COMPLETE:
+		status = SCI_SUCCESS;
+
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
+			);
+		break;
+
+	default:
+		status = SCI_FAILURE;
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: SCIC Remote Node Context 0x%p requested to "
+			 "process unexpected event 0x%x while in posting "
+			 "state\n",
+			 __func__,
+			 sci_rnc,
+			 event_code);
+		break;
+	}
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_invalidating_state_destruct_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	scic_sds_remote_node_context_setup_to_destory(
+		sci_rnc, callback, callback_parameter
+		);
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status scic_sds_remote_node_context_invalidating_state_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	if (scu_get_event_code(event_code) == SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE) {
+		status = SCI_SUCCESS;
+
+		if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
+			sci_base_state_machine_change_state(
+				&sci_rnc->state_machine,
+				SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
+				);
+		} else {
+			sci_base_state_machine_change_state(
+				&sci_rnc->state_machine,
+				SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
+				);
+		}
+	} else {
+		switch (scu_get_event_type(event_code)) {
+		case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
+		case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
+			/*
+			 * We really dont care if the hardware is going to suspend
+			 * the device since it's being invalidated anyway */
+			dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+				"%s: SCIC Remote Node Context 0x%p was "
+				"suspeneded by hardware while being "
+				"invalidated.\n",
+				__func__,
+				sci_rnc);
+			status = SCI_SUCCESS;
+			break;
+
+		default:
+			dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+				 "%s: SCIC Remote Node Context 0x%p "
+				 "requested to process event 0x%x while "
+				 "in state %d.\n",
+				 __func__,
+				 sci_rnc,
+				 event_code,
+				 sci_base_state_machine_get_state(
+					 &sci_rnc->state_machine));
+			status = SCI_FAILURE;
+			break;
+		}
+	}
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+
+static enum sci_status scic_sds_remote_node_context_resuming_state_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	if (scu_get_event_code(event_code) == SCU_EVENT_POST_RCN_RELEASE) {
+		status = SCI_SUCCESS;
+
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
+			);
+	} else {
+		switch (scu_get_event_type(event_code)) {
+		case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
+		case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
+			/*
+			 * We really dont care if the hardware is going to suspend
+			 * the device since it's being resumed anyway */
+			dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+				"%s: SCIC Remote Node Context 0x%p was "
+				"suspeneded by hardware while being resumed.\n",
+				__func__,
+				sci_rnc);
+			status = SCI_SUCCESS;
+			break;
+
+		default:
+			dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+				 "%s: SCIC Remote Node Context 0x%p requested "
+				 "to process event 0x%x while in state %d.\n",
+				 __func__,
+				 sci_rnc,
+				 event_code,
+				 sci_base_state_machine_get_state(
+					 &sci_rnc->state_machine));
+			status = SCI_FAILURE;
+			break;
+		}
+	}
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+/**
+ *
+ * @sci_rnc: The remote node context object being suspended.
+ * @callback: The callback when the suspension is complete.
+ * @callback_parameter: The parameter that is to be passed into the callback.
+ *
+ * This method will handle the suspend requests from the ready state.
+ * SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_node_context_ready_state_suspend_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 suspend_type,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	sci_rnc->user_callback   = callback;
+	sci_rnc->user_cookie     = callback_parameter;
+	sci_rnc->suspension_code = suspend_type;
+
+	if (suspend_type == SCI_SOFTWARE_SUSPENSION) {
+		scic_sds_remote_device_post_request(rnc_to_dev(sci_rnc),
+						    SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX);
+	}
+
+	sci_base_state_machine_change_state(
+		&sci_rnc->state_machine,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE
+		);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @sci_rnc: The rnc for which the io request is targeted.
+ * @sci_req: The request which is going to be started.
+ *
+ * This method determines if the io request can be started by the SCU hardware.
+ * When the RNC is in the ready state any io request can be started. enum sci_status
+ * SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_node_context_ready_state_start_io_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	return SCI_SUCCESS;
+}
+
+
+static enum sci_status scic_sds_remote_node_context_ready_state_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	switch (scu_get_event_type(event_code)) {
+	case SCU_EVENT_TL_RNC_SUSPEND_TX:
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
+			);
+
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+		status = SCI_SUCCESS;
+		break;
+
+	case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
+			);
+
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+		status = SCI_SUCCESS;
+		break;
+
+	default:
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			"%s: SCIC Remote Node Context 0x%p requested to "
+			"process event 0x%x while in state %d.\n",
+			__func__,
+			sci_rnc,
+			event_code,
+			sci_base_state_machine_get_state(
+				&sci_rnc->state_machine));
+
+		status = SCI_FAILURE;
+		break;
+	}
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_tx_suspended_state_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	enum sci_status status;
+	struct smp_discover_response_protocols protocols;
+
+	scic_sds_remote_node_context_setup_to_resume(
+		sci_rnc, callback, callback_parameter
+		);
+
+	/* TODO: consider adding a resume action of NONE, INVALIDATE, WRITE_TLCR */
+
+	scic_remote_device_get_protocols(rnc_to_dev(sci_rnc), &protocols);
+
+	if (
+		(protocols.u.bits.attached_ssp_target == 1)
+		|| (protocols.u.bits.attached_smp_target == 1)
+		) {
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
+			);
+
+		status = SCI_SUCCESS;
+	} else if (protocols.u.bits.attached_stp_target == 1) {
+		if (rnc_to_dev(sci_rnc)->is_direct_attached) {
+			/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
+			sci_base_state_machine_change_state(
+				&sci_rnc->state_machine,
+				SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
+				);
+		} else {
+			sci_base_state_machine_change_state(
+				&sci_rnc->state_machine,
+				SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
+				);
+		}
+
+		status = SCI_SUCCESS;
+	} else {
+		status = SCI_FAILURE;
+	}
+
+	return status;
+}
+
+/**
+ *
+ * @sci_rnc: The remote node context which is to receive the task request.
+ * @sci_req: The task request to be transmitted to to the remote target
+ *    device.
+ *
+ * This method will report a success or failure attempt to start a new task
+ * request to the hardware.  Since all task requests are sent on the high
+ * priority queue they can be sent when the RCN is in a TX suspend state.
+ * enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_node_context_suspended_start_task_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	scic_sds_remote_node_context_resume(sci_rnc, NULL, NULL);
+
+	return SCI_SUCCESS;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	scic_sds_remote_node_context_setup_to_resume(
+		sci_rnc, callback, callback_parameter
+		);
+
+	sci_base_state_machine_change_state(
+		&sci_rnc->state_machine,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
+		);
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+/* --------------------------------------------------------------------------- */
+
+/**
+ *
+ *
+ *
+ */
+static enum sci_status scic_sds_remote_node_context_await_suspension_state_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	scic_sds_remote_node_context_setup_to_resume(
+		sci_rnc, callback, callback_parameter
+		);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @sci_rnc: The remote node context which is to receive the task request.
+ * @sci_req: The task request to be transmitted to to the remote target
+ *    device.
+ *
+ * This method will report a success or failure attempt to start a new task
+ * request to the hardware.  Since all task requests are sent on the high
+ * priority queue they can be sent when the RCN is in a TX suspend state.
+ * enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_node_context_await_suspension_state_start_task_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	return SCI_SUCCESS;
+}
+
+static enum sci_status scic_sds_remote_node_context_await_suspension_state_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	switch (scu_get_event_type(event_code)) {
+	case SCU_EVENT_TL_RNC_SUSPEND_TX:
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
+			);
+
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+		status = SCI_SUCCESS;
+		break;
+
+	case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
+			);
+
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+		status = SCI_SUCCESS;
+		break;
+
+	default:
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: SCIC Remote Node Context 0x%p requested to "
+			 "process event 0x%x while in state %d.\n",
+			 __func__,
+			 sci_rnc,
+			 event_code,
+			 sci_base_state_machine_get_state(
+				 &sci_rnc->state_machine));
+
+		status = SCI_FAILURE;
+		break;
+	}
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static struct scic_sds_remote_node_context_handlers
+scic_sds_remote_node_context_state_handler_table[
+	SCIC_SDS_REMOTE_NODE_CONTEXT_MAX_STATES] =
+{
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE */
+	{
+		scic_sds_remote_node_context_default_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_initial_state_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_default_start_task_handler,
+		scic_sds_remote_node_context_default_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_continue_to_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_default_start_task_handler,
+		scic_sds_remote_node_context_posting_state_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE */
+	{
+		scic_sds_remote_node_context_invalidating_state_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_continue_to_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_default_start_task_handler,
+		scic_sds_remote_node_context_invalidating_state_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_continue_to_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_success_start_task_handler,
+		scic_sds_remote_node_context_resuming_state_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_ready_state_suspend_handler,
+		scic_sds_remote_node_context_default_resume_handler,
+		scic_sds_remote_node_context_ready_state_start_io_handler,
+		scic_sds_remote_node_context_success_start_task_handler,
+		scic_sds_remote_node_context_ready_state_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_tx_suspended_state_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_suspended_start_task_handler,
+		scic_sds_remote_node_context_default_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_suspended_start_task_handler,
+		scic_sds_remote_node_context_default_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_await_suspension_state_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_await_suspension_state_start_task_handler,
+		scic_sds_remote_node_context_await_suspension_state_event_handler
+	}
+};
+
+/*
+ * *****************************************************************************
+ * * REMOTE NODE CONTEXT PRIVATE METHODS
+ * ***************************************************************************** */
+
+/**
+ *
+ *
+ * This method just calls the user callback function and then resets the
+ * callback.
+ */
+static void scic_sds_remote_node_context_notify_user(
+	struct scic_sds_remote_node_context *rnc)
+{
+	if (rnc->user_callback != NULL) {
+		(*rnc->user_callback)(rnc->user_cookie);
+
+		rnc->user_callback = NULL;
+		rnc->user_cookie = NULL;
+	}
+}
+
+/**
+ *
+ *
+ * This method will continue the remote node context state machine by
+ * requesting to resume the remote node context state machine from its current
+ * state.
+ */
+static void scic_sds_remote_node_context_continue_state_transitions(
+	struct scic_sds_remote_node_context *rnc)
+{
+	if (rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY) {
+		rnc->state_handlers->resume_handler(
+			rnc, rnc->user_callback, rnc->user_cookie
+			);
+	}
+}
+
+/**
+ *
+ * @sci_rnc: The remote node context object that is to be validated.
+ *
+ * This method will mark the rnc buffer as being valid and post the request to
+ * the hardware. none
+ */
+static void scic_sds_remote_node_context_validate_context_buffer(
+	struct scic_sds_remote_node_context *sci_rnc)
+{
+	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
+	union scu_remote_node_context *rnc_buffer;
+
+	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
+		scic_sds_remote_device_get_controller(sci_dev),
+		sci_rnc->remote_node_index
+		);
+
+	rnc_buffer->ssp.is_valid = true;
+
+	if (!sci_dev->is_direct_attached &&
+	    sci_dev->target_protocols.u.bits.attached_stp_target) {
+		scic_sds_remote_device_post_request(sci_dev,
+						    SCU_CONTEXT_COMMAND_POST_RNC_96);
+	} else {
+		scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_32);
+
+		if (sci_dev->is_direct_attached) {
+			scic_sds_port_setup_transports(sci_dev->owning_port,
+						       sci_rnc->remote_node_index);
+		}
+	}
+}
+
+/**
+ *
+ * @sci_rnc: The remote node context object that is to be invalidated.
+ *
+ * This method will update the RNC buffer and post the invalidate request. none
+ */
+static void scic_sds_remote_node_context_invalidate_context_buffer(
+	struct scic_sds_remote_node_context *sci_rnc)
+{
+	union scu_remote_node_context *rnc_buffer;
+
+	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
+		scic_sds_remote_device_get_controller(rnc_to_dev(sci_rnc)),
+		sci_rnc->remote_node_index);
+
+	rnc_buffer->ssp.is_valid = false;
+
+	scic_sds_remote_device_post_request(rnc_to_dev(sci_rnc),
+					    SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE);
+}
+
+/*
+ * *****************************************************************************
+ * * REMOTE NODE CONTEXT STATE ENTER AND EXIT METHODS
+ * ***************************************************************************** */
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_initial_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
+		);
+
+	/*
+	 * Check to see if we have gotten back to the initial state because someone
+	 * requested to destroy the remote node context object. */
+	if (
+		rnc->state_machine.previous_state_id
+		== SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
+		) {
+		rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
+
+		scic_sds_remote_node_context_notify_user(rnc);
+	}
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_posting_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *sci_rnc;
+
+	sci_rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		sci_rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
+		);
+
+	scic_sds_remote_node_context_validate_context_buffer(sci_rnc);
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_invalidating_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
+		);
+
+	scic_sds_remote_node_context_invalidate_context_buffer(rnc);
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_resuming_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+	struct smp_discover_response_protocols protocols;
+	struct scic_sds_remote_device *sci_dev;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+	sci_dev = rnc_to_dev(rnc);
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
+		);
+
+	/*
+	 * For direct attached SATA devices we need to clear the TLCR
+	 * NCQ to TCi tag mapping on the phy and in cases where we
+	 * resume because of a target reset we also need to update
+	 * the STPTLDARNI register with the RNi of the device
+	 */
+	scic_remote_device_get_protocols(sci_dev, &protocols);
+
+	if (protocols.u.bits.attached_stp_target == 1 &&
+	    sci_dev->is_direct_attached) {
+		scic_sds_port_setup_transports(sci_dev->owning_port,
+					       rnc->remote_node_index);
+	}
+
+	scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_ready_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
+		);
+
+	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
+
+	if (rnc->user_callback != NULL) {
+		scic_sds_remote_node_context_notify_user(rnc);
+	}
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_tx_suspended_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
+		);
+
+	scic_sds_remote_node_context_continue_state_transitions(rnc);
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
+		);
+
+	scic_sds_remote_node_context_continue_state_transitions(rnc);
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_await_suspension_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE
+		);
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct sci_base_state scic_sds_remote_node_context_state_table[] = {
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE] = {
+		.enter_state = scic_sds_remote_node_context_initial_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE] = {
+		.enter_state = scic_sds_remote_node_context_posting_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE] = {
+		.enter_state = scic_sds_remote_node_context_invalidating_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE] = {
+		.enter_state = scic_sds_remote_node_context_resuming_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE] = {
+		.enter_state = scic_sds_remote_node_context_ready_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE] = {
+		.enter_state = scic_sds_remote_node_context_tx_suspended_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE] = {
+		.enter_state = scic_sds_remote_node_context_tx_rx_suspended_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = {
+		.enter_state = scic_sds_remote_node_context_await_suspension_state_enter,
+	},
+};
+
+void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context *rnc,
+					    u16 remote_node_index)
+{
+	memset(rnc, 0, sizeof(struct scic_sds_remote_node_context));
+
+	rnc->remote_node_index = remote_node_index;
+	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
+
+	sci_base_state_machine_construct(
+		&rnc->state_machine,
+		&rnc->parent,
+		scic_sds_remote_node_context_state_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
+		);
+
+	sci_base_state_machine_start(&rnc->state_machine);
+}
diff --git a/drivers/scsi/isci/remote_node_context.h b/drivers/scsi/isci/remote_node_context.h
new file mode 100644
index 0000000..b3f2546
--- /dev/null
+++ b/drivers/scsi/isci/remote_node_context.h
@@ -0,0 +1,301 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _SCIC_SDS_REMOTE_NODE_CONTEXT_H_
+#define _SCIC_SDS_REMOTE_NODE_CONTEXT_H_
+
+/**
+ * This file contains the structures, constants, and prototypes associated with
+ *    the remote node context in the silicon.  It exists to model and manage
+ *    the remote node context in the silicon.
+ *
+ *
+ */
+
+#include "sci_base_state.h"
+#include "sci_base_state_machine.h"
+
+/**
+ *
+ *
+ * This constant represents an invalid remote device id, it is used to program
+ * the STPDARNI register so the driver knows when it has received a SIGNATURE
+ * FIS from the SCU.
+ */
+#define SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX    0x0FFF
+
+#define SCU_HARDWARE_SUSPENSION  (0)
+#define SCI_SOFTWARE_SUSPENSION  (1)
+
+struct scic_sds_request;
+struct scic_sds_remote_device;
+struct scic_sds_remote_node_context;
+
+typedef void (*scics_sds_remote_node_context_callback)(void *);
+
+typedef enum sci_status (*scic_sds_remote_node_context_operation)(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter
+	);
+
+typedef enum sci_status (*scic_sds_remote_node_context_suspend_operation)(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 suspension_type,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter
+	);
+
+typedef enum sci_status (*scic_sds_remote_node_context_io_request)(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req
+	);
+
+typedef enum sci_status (*scic_sds_remote_node_context_event_handler)(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code
+	);
+
+struct scic_sds_remote_node_context_handlers {
+	/**
+	 * This handle is invoked to stop the RNC.  The callback is invoked when after
+	 * the hardware notification that the RNC has been invalidated.
+	 */
+	scic_sds_remote_node_context_operation destruct_handler;
+
+	/**
+	 * This handler is invoked when there is a request to suspend  the RNC.  The
+	 * callback is invoked after the hardware notification that the remote node is
+	 * suspended.
+	 */
+	scic_sds_remote_node_context_suspend_operation suspend_handler;
+
+	/**
+	 * This handler is invoked when there is a request to resume the RNC.  The
+	 * callback is invoked when after the RNC has reached the ready state.
+	 */
+	scic_sds_remote_node_context_operation resume_handler;
+
+	/**
+	 * This handler is invoked when there is a request to start an io request
+	 * operation.
+	 */
+	scic_sds_remote_node_context_io_request start_io_handler;
+
+	/**
+	 * This handler is invoked when there is a request to start a task request
+	 * operation.
+	 */
+	scic_sds_remote_node_context_io_request start_task_handler;
+
+	/**
+	 * This handler is invoked where there is an RNC event that must be processed.
+	 */
+	scic_sds_remote_node_context_event_handler event_handler;
+
+};
+
+/**
+ * This is the enumeration of the remote node context states.
+ */
+enum scis_sds_remote_node_context_states {
+	/**
+	 * This state is the initial state for a remote node context.  On a resume
+	 * request the remote node context will transition to the posting state.
+	 */
+	SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE,
+
+	/**
+	 * This is a transition state that posts the RNi to the hardware. Once the RNC
+	 * is posted the remote node context will be made ready.
+	 */
+	SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE,
+
+	/**
+	 * This is a transition state that will post an RNC invalidate to the
+	 * hardware.  Once the invalidate is complete the remote node context will
+	 * transition to the posting state.
+	 */
+	SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE,
+
+	/**
+	 * This is a transition state that will post an RNC resume to the hardare.
+	 * Once the event notification of resume complete is received the remote node
+	 * context will transition to the ready state.
+	 */
+	SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE,
+
+	/**
+	 * This is the state that the remote node context must be in to accept io
+	 * request operations.
+	 */
+	SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE,
+
+	/**
+	 * This is the state that the remote node context transitions to when it gets
+	 * a TX suspend notification from the hardware.
+	 */
+	SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE,
+
+	/**
+	 * This is the state that the remote node context transitions to when it gets
+	 * a TX RX suspend notification from the hardware.
+	 */
+	SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE,
+
+	/**
+	 * This state is a wait state for the remote node context that waits for a
+	 * suspend notification from the hardware.  This state is entered when either
+	 * there is a request to supend the remote node context or when there is a TC
+	 * completion where the remote node will be suspended by the hardware.
+	 */
+	SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE,
+
+	SCIC_SDS_REMOTE_NODE_CONTEXT_MAX_STATES
+
+};
+
+/**
+ *
+ *
+ * This enumeration is used to define the end destination state for the remote
+ * node context.
+ */
+enum scic_sds_remote_node_context_destination_state {
+	SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED,
+	SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY,
+	SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL
+};
+
+/**
+ * struct scic_sds_remote_node_context - This structure contains the data
+ *    associated with the remote node context object.  The remote node context
+ *    (RNC) object models the the remote device information necessary to manage
+ *    the silicon RNC.
+ */
+struct scic_sds_remote_node_context {
+	/*
+	 * parent object
+	 */
+	struct sci_base_object parent;
+
+	/**
+	 * This field indicates the remote node index (RNI) associated with
+	 * this RNC.
+	 */
+	u16 remote_node_index;
+
+	/**
+	 * This field is the recored suspension code or the reason for the remote node
+	 * context suspension.
+	 */
+	u32 suspension_code;
+
+	/**
+	 * This field is true if the remote node context is resuming from its current
+	 * state.  This can cause an automatic resume on receiving a suspension
+	 * notification.
+	 */
+	enum scic_sds_remote_node_context_destination_state destination_state;
+
+	/**
+	 * This field contains the callback function that the user requested to be
+	 * called when the requested state transition is complete.
+	 */
+	scics_sds_remote_node_context_callback user_callback;
+
+	/**
+	 * This field contains the parameter that is called when the user requested
+	 * state transition is completed.
+	 */
+	void *user_cookie;
+
+	/**
+	 * This field contains the data for the object's state machine.
+	 */
+	struct sci_base_state_machine state_machine;
+
+	struct scic_sds_remote_node_context_handlers *state_handlers;
+};
+
+void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context *rnc,
+					    u16 remote_node_index);
+
+
+bool scic_sds_remote_node_context_is_ready(
+	struct scic_sds_remote_node_context *sci_rnc);
+
+#define scic_sds_remote_node_context_get_remote_node_index(rcn)	\
+	((rnc)->remote_node_index)
+
+#define scic_sds_remote_node_context_event_handler(rnc, event_code) \
+	((rnc)->state_handlers->event_handler(rnc, event_code))
+
+#define scic_sds_remote_node_context_resume(rnc, callback, parameter) \
+	((rnc)->state_handlers->resume_handler(rnc, callback, parameter))
+
+#define scic_sds_remote_node_context_suspend(rnc, suspend_type, callback, parameter) \
+	((rnc)->state_handlers->suspend_handler(rnc, suspend_type, callback, parameter))
+
+#define scic_sds_remote_node_context_destruct(rnc, callback, parameter)	\
+	((rnc)->state_handlers->destruct_handler(rnc, callback, parameter))
+
+#define scic_sds_remote_node_context_start_io(rnc, request) \
+	((rnc)->state_handlers->start_io_handler(rnc, request))
+
+#define scic_sds_remote_node_context_start_task(rnc, task) \
+	((rnc)->state_handlers->start_task_handler(rnc, task))
+
+#endif  /* _SCIC_SDS_REMOTE_NODE_CONTEXT_H_ */
diff --git a/drivers/scsi/isci/remote_node_table.c b/drivers/scsi/isci/remote_node_table.c
new file mode 100644
index 0000000..8886146
--- /dev/null
+++ b/drivers/scsi/isci/remote_node_table.c
@@ -0,0 +1,600 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * This file contains the implementation of the SCIC_SDS_REMOTE_NODE_TABLE
+ *    public, protected, and private methods.
+ *
+ *
+ */
+#include "sci_util.h"
+#include "sci_environment.h"
+#include "remote_node_table.h"
+#include "remote_node_context.h"
+
+/**
+ *
+ * @remote_node_table: This is the remote node index table from which the
+ *    selection will be made.
+ * @group_table_index: This is the index to the group table from which to
+ *    search for an available selection.
+ *
+ * This routine will find the bit position in absolute bit terms of the next 32
+ * + bit position.  If there are available bits in the first u32 then it is
+ * just bit position. u32 This is the absolute bit position for an available
+ * group.
+ */
+static u32 scic_sds_remote_node_table_get_group_index(
+	struct scic_remote_node_table *remote_node_table,
+	u32 group_table_index)
+{
+	u32 dword_index;
+	u32 *group_table;
+	u32 bit_index;
+
+	group_table = remote_node_table->remote_node_groups[group_table_index];
+
+	for (dword_index = 0; dword_index < remote_node_table->group_array_size; dword_index++) {
+		if (group_table[dword_index] != 0) {
+			for (bit_index = 0; bit_index < 32; bit_index++) {
+				if ((group_table[dword_index] & (1 << bit_index)) != 0) {
+					return (dword_index * 32) + bit_index;
+				}
+			}
+		}
+	}
+
+	return SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX;
+}
+
+/**
+ *
+ * @out]: remote_node_table This the remote node table in which to clear the
+ *    selector.
+ * @set_index: This is the remote node selector in which the change will be
+ *    made.
+ * @group_index: This is the bit index in the table to be modified.
+ *
+ * This method will clear the group index entry in the specified group index
+ * table. none
+ */
+static void scic_sds_remote_node_table_clear_group_index(
+	struct scic_remote_node_table *remote_node_table,
+	u32 group_table_index,
+	u32 group_index)
+{
+	u32 dword_index;
+	u32 bit_index;
+	u32 *group_table;
+
+	BUG_ON(group_table_index >= SCU_STP_REMOTE_NODE_COUNT);
+	BUG_ON(group_index >= (u32)(remote_node_table->group_array_size * 32));
+
+	dword_index = group_index / 32;
+	bit_index   = group_index % 32;
+	group_table = remote_node_table->remote_node_groups[group_table_index];
+
+	group_table[dword_index] = group_table[dword_index] & ~(1 << bit_index);
+}
+
+/**
+ *
+ * @out]: remote_node_table This the remote node table in which to set the
+ *    selector.
+ * @group_table_index: This is the remote node selector in which the change
+ *    will be made.
+ * @group_index: This is the bit position in the table to be modified.
+ *
+ * This method will set the group index bit entry in the specified gropu index
+ * table. none
+ */
+static void scic_sds_remote_node_table_set_group_index(
+	struct scic_remote_node_table *remote_node_table,
+	u32 group_table_index,
+	u32 group_index)
+{
+	u32 dword_index;
+	u32 bit_index;
+	u32 *group_table;
+
+	BUG_ON(group_table_index >= SCU_STP_REMOTE_NODE_COUNT);
+	BUG_ON(group_index >= (u32)(remote_node_table->group_array_size * 32));
+
+	dword_index = group_index / 32;
+	bit_index   = group_index % 32;
+	group_table = remote_node_table->remote_node_groups[group_table_index];
+
+	group_table[dword_index] = group_table[dword_index] | (1 << bit_index);
+}
+
+/**
+ *
+ * @out]: remote_node_table This is the remote node table in which to modify
+ *    the remote node availability.
+ * @remote_node_index: This is the remote node index that is being returned to
+ *    the table.
+ *
+ * This method will set the remote to available in the remote node allocation
+ * table. none
+ */
+static void scic_sds_remote_node_table_set_node_index(
+	struct scic_remote_node_table *remote_node_table,
+	u32 remote_node_index)
+{
+	u32 dword_location;
+	u32 dword_remainder;
+	u32 slot_normalized;
+	u32 slot_position;
+
+	BUG_ON(
+		(remote_node_table->available_nodes_array_size * SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD)
+		<= (remote_node_index / SCU_STP_REMOTE_NODE_COUNT)
+		);
+
+	dword_location  = remote_node_index / SCIC_SDS_REMOTE_NODES_PER_DWORD;
+	dword_remainder = remote_node_index % SCIC_SDS_REMOTE_NODES_PER_DWORD;
+	slot_normalized = (dword_remainder / SCU_STP_REMOTE_NODE_COUNT) * sizeof(u32);
+	slot_position   = remote_node_index % SCU_STP_REMOTE_NODE_COUNT;
+
+	remote_node_table->available_remote_nodes[dword_location] |=
+		1 << (slot_normalized + slot_position);
+}
+
+/**
+ *
+ * @out]: remote_node_table This is the remote node table from which to clear
+ *    the available remote node bit.
+ * @remote_node_index: This is the remote node index which is to be cleared
+ *    from the table.
+ *
+ * This method clears the remote node index from the table of available remote
+ * nodes. none
+ */
+static void scic_sds_remote_node_table_clear_node_index(
+	struct scic_remote_node_table *remote_node_table,
+	u32 remote_node_index)
+{
+	u32 dword_location;
+	u32 dword_remainder;
+	u32 slot_position;
+	u32 slot_normalized;
+
+	BUG_ON(
+		(remote_node_table->available_nodes_array_size * SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD)
+		<= (remote_node_index / SCU_STP_REMOTE_NODE_COUNT)
+		);
+
+	dword_location  = remote_node_index / SCIC_SDS_REMOTE_NODES_PER_DWORD;
+	dword_remainder = remote_node_index % SCIC_SDS_REMOTE_NODES_PER_DWORD;
+	slot_normalized = (dword_remainder / SCU_STP_REMOTE_NODE_COUNT) * sizeof(u32);
+	slot_position   = remote_node_index % SCU_STP_REMOTE_NODE_COUNT;
+
+	remote_node_table->available_remote_nodes[dword_location] &=
+		~(1 << (slot_normalized + slot_position));
+}
+
+/**
+ *
+ * @out]: remote_node_table The remote node table from which the slot will be
+ *    cleared.
+ * @group_index: The index for the slot that is to be cleared.
+ *
+ * This method clears the entire table slot at the specified slot index. none
+ */
+static void scic_sds_remote_node_table_clear_group(
+	struct scic_remote_node_table *remote_node_table,
+	u32 group_index)
+{
+	u32 dword_location;
+	u32 dword_remainder;
+	u32 dword_value;
+
+	BUG_ON(
+		(remote_node_table->available_nodes_array_size * SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD)
+		<= (group_index / SCU_STP_REMOTE_NODE_COUNT)
+		);
+
+	dword_location  = group_index / SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
+	dword_remainder = group_index % SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
+
+	dword_value = remote_node_table->available_remote_nodes[dword_location];
+	dword_value &= ~(SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE << (dword_remainder * 4));
+	remote_node_table->available_remote_nodes[dword_location] = dword_value;
+}
+
+/**
+ *
+ * @remote_node_table:
+ *
+ * THis method sets an entire remote node group in the remote node table.
+ */
+static void scic_sds_remote_node_table_set_group(
+	struct scic_remote_node_table *remote_node_table,
+	u32 group_index)
+{
+	u32 dword_location;
+	u32 dword_remainder;
+	u32 dword_value;
+
+	BUG_ON(
+		(remote_node_table->available_nodes_array_size * SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD)
+		<= (group_index / SCU_STP_REMOTE_NODE_COUNT)
+		);
+
+	dword_location  = group_index / SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
+	dword_remainder = group_index % SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
+
+	dword_value = remote_node_table->available_remote_nodes[dword_location];
+	dword_value |= (SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE << (dword_remainder * 4));
+	remote_node_table->available_remote_nodes[dword_location] = dword_value;
+}
+
+/**
+ *
+ * @remote_node_table: This is the remote node table that for which the group
+ *    value is to be returned.
+ * @group_index: This is the group index to use to find the group value.
+ *
+ * This method will return the group value for the specified group index. The
+ * bit values at the specified remote node group index.
+ */
+static u8 scic_sds_remote_node_table_get_group_value(
+	struct scic_remote_node_table *remote_node_table,
+	u32 group_index)
+{
+	u32 dword_location;
+	u32 dword_remainder;
+	u32 dword_value;
+
+	dword_location  = group_index / SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
+	dword_remainder = group_index % SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD;
+
+	dword_value = remote_node_table->available_remote_nodes[dword_location];
+	dword_value &= (SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE << (dword_remainder * 4));
+	dword_value = dword_value >> (dword_remainder * 4);
+
+	return (u8)dword_value;
+}
+
+/**
+ *
+ * @out]: remote_node_table The remote that which is to be initialized.
+ * @remote_node_entries: The number of entries to put in the table.
+ *
+ * This method will initialize the remote node table for use. none
+ */
+void scic_sds_remote_node_table_initialize(
+	struct scic_remote_node_table *remote_node_table,
+	u32 remote_node_entries)
+{
+	u32 index;
+
+	/*
+	 * Initialize the raw data we could improve the speed by only initializing
+	 * those entries that we are actually going to be used */
+	memset(
+		remote_node_table->available_remote_nodes,
+		0x00,
+		sizeof(remote_node_table->available_remote_nodes)
+		);
+
+	memset(
+		remote_node_table->remote_node_groups,
+		0x00,
+		sizeof(remote_node_table->remote_node_groups)
+		);
+
+	/* Initialize the available remote node sets */
+	remote_node_table->available_nodes_array_size = (u16)
+							(remote_node_entries / SCIC_SDS_REMOTE_NODES_PER_DWORD)
+							+ ((remote_node_entries % SCIC_SDS_REMOTE_NODES_PER_DWORD) != 0);
+
+
+	/* Initialize each full DWORD to a FULL SET of remote nodes */
+	for (index = 0; index < remote_node_entries; index++) {
+		scic_sds_remote_node_table_set_node_index(remote_node_table, index);
+	}
+
+	remote_node_table->group_array_size = (u16)
+					      (remote_node_entries / (SCU_STP_REMOTE_NODE_COUNT * 32))
+					      + ((remote_node_entries % (SCU_STP_REMOTE_NODE_COUNT * 32)) != 0);
+
+	for (index = 0; index < (remote_node_entries / SCU_STP_REMOTE_NODE_COUNT); index++) {
+		/*
+		 * These are all guaranteed to be full slot values so fill them in the
+		 * available sets of 3 remote nodes */
+		scic_sds_remote_node_table_set_group_index(remote_node_table, 2, index);
+	}
+
+	/* Now fill in any remainders that we may find */
+	if ((remote_node_entries % SCU_STP_REMOTE_NODE_COUNT) == 2) {
+		scic_sds_remote_node_table_set_group_index(remote_node_table, 1, index);
+	} else if ((remote_node_entries % SCU_STP_REMOTE_NODE_COUNT) == 1) {
+		scic_sds_remote_node_table_set_group_index(remote_node_table, 0, index);
+	}
+}
+
+/**
+ *
+ * @out]: remote_node_table The remote node table from which to allocate a
+ *    remote node.
+ * @table_index: The group index that is to be used for the search.
+ *
+ * This method will allocate a single RNi from the remote node table.  The
+ * table index will determine from which remote node group table to search.
+ * This search may fail and another group node table can be specified.  The
+ * function is designed to allow a serach of the available single remote node
+ * group up to the triple remote node group.  If an entry is found in the
+ * specified table the remote node is removed and the remote node groups are
+ * updated. The RNi value or an invalid remote node context if an RNi can not
+ * be found.
+ */
+static u16 scic_sds_remote_node_table_allocate_single_remote_node(
+	struct scic_remote_node_table *remote_node_table,
+	u32 group_table_index)
+{
+	u8 index;
+	u8 group_value;
+	u32 group_index;
+	u16 remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
+
+	group_index = scic_sds_remote_node_table_get_group_index(
+		remote_node_table, group_table_index);
+
+	/* We could not find an available slot in the table selector 0 */
+	if (group_index != SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX) {
+		group_value = scic_sds_remote_node_table_get_group_value(
+			remote_node_table, group_index);
+
+		for (index = 0; index < SCU_STP_REMOTE_NODE_COUNT; index++) {
+			if (((1 << index) & group_value) != 0) {
+				/* We have selected a bit now clear it */
+				remote_node_index = (u16)(group_index * SCU_STP_REMOTE_NODE_COUNT
+							  + index);
+
+				scic_sds_remote_node_table_clear_group_index(
+					remote_node_table, group_table_index, group_index
+					);
+
+				scic_sds_remote_node_table_clear_node_index(
+					remote_node_table, remote_node_index
+					);
+
+				if (group_table_index > 0) {
+					scic_sds_remote_node_table_set_group_index(
+						remote_node_table, group_table_index - 1, group_index
+						);
+				}
+
+				break;
+			}
+		}
+	}
+
+	return remote_node_index;
+}
+
+/**
+ *
+ * @remote_node_table: This is the remote node table from which to allocate the
+ *    remote node entries.
+ * @group_table_index: THis is the group table index which must equal two (2)
+ *    for this operation.
+ *
+ * This method will allocate three consecutive remote node context entries. If
+ * there are no remaining triple entries the function will return a failure.
+ * The remote node index that represents three consecutive remote node entries
+ * or an invalid remote node context if none can be found.
+ */
+static u16 scic_sds_remote_node_table_allocate_triple_remote_node(
+	struct scic_remote_node_table *remote_node_table,
+	u32 group_table_index)
+{
+	u32 group_index;
+	u16 remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
+
+	group_index = scic_sds_remote_node_table_get_group_index(
+		remote_node_table, group_table_index);
+
+	if (group_index != SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX) {
+		remote_node_index = (u16)group_index * SCU_STP_REMOTE_NODE_COUNT;
+
+		scic_sds_remote_node_table_clear_group_index(
+			remote_node_table, group_table_index, group_index
+			);
+
+		scic_sds_remote_node_table_clear_group(
+			remote_node_table, group_index
+			);
+	}
+
+	return remote_node_index;
+}
+
+/**
+ *
+ * @remote_node_table: This is the remote node table from which the remote node
+ *    allocation is to take place.
+ * @remote_node_count: This is ther remote node count which is one of
+ *    SCU_SSP_REMOTE_NODE_COUNT(1) or SCU_STP_REMOTE_NODE_COUNT(3).
+ *
+ * This method will allocate a remote node that mataches the remote node count
+ * specified by the caller.  Valid values for remote node count is
+ * SCU_SSP_REMOTE_NODE_COUNT(1) or SCU_STP_REMOTE_NODE_COUNT(3). u16 This is
+ * the remote node index that is returned or an invalid remote node context.
+ */
+u16 scic_sds_remote_node_table_allocate_remote_node(
+	struct scic_remote_node_table *remote_node_table,
+	u32 remote_node_count)
+{
+	u16 remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
+
+	if (remote_node_count == SCU_SSP_REMOTE_NODE_COUNT) {
+		remote_node_index =
+			scic_sds_remote_node_table_allocate_single_remote_node(
+				remote_node_table, 0);
+
+		if (remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
+			remote_node_index =
+				scic_sds_remote_node_table_allocate_single_remote_node(
+					remote_node_table, 1);
+		}
+
+		if (remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
+			remote_node_index =
+				scic_sds_remote_node_table_allocate_single_remote_node(
+					remote_node_table, 2);
+		}
+	} else if (remote_node_count == SCU_STP_REMOTE_NODE_COUNT) {
+		remote_node_index =
+			scic_sds_remote_node_table_allocate_triple_remote_node(
+				remote_node_table, 2);
+	}
+
+	return remote_node_index;
+}
+
+/**
+ *
+ * @remote_node_table:
+ *
+ * This method will free a single remote node index back to the remote node
+ * table.  This routine will update the remote node groups
+ */
+static void scic_sds_remote_node_table_release_single_remote_node(
+	struct scic_remote_node_table *remote_node_table,
+	u16 remote_node_index)
+{
+	u32 group_index;
+	u8 group_value;
+
+	group_index = remote_node_index / SCU_STP_REMOTE_NODE_COUNT;
+
+	group_value = scic_sds_remote_node_table_get_group_value(remote_node_table, group_index);
+
+	/*
+	 * Assert that we are not trying to add an entry to a slot that is already
+	 * full. */
+	BUG_ON(group_value == SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE);
+
+	if (group_value == 0x00) {
+		/*
+		 * There are no entries in this slot so it must be added to the single
+		 * slot table. */
+		scic_sds_remote_node_table_set_group_index(remote_node_table, 0, group_index);
+	} else if ((group_value & (group_value - 1)) == 0) {
+		/*
+		 * There is only one entry in this slot so it must be moved from the
+		 * single slot table to the dual slot table */
+		scic_sds_remote_node_table_clear_group_index(remote_node_table, 0, group_index);
+		scic_sds_remote_node_table_set_group_index(remote_node_table, 1, group_index);
+	} else {
+		/*
+		 * There are two entries in the slot so it must be moved from the dual
+		 * slot table to the tripple slot table. */
+		scic_sds_remote_node_table_clear_group_index(remote_node_table, 1, group_index);
+		scic_sds_remote_node_table_set_group_index(remote_node_table, 2, group_index);
+	}
+
+	scic_sds_remote_node_table_set_node_index(remote_node_table, remote_node_index);
+}
+
+/**
+ *
+ * @remote_node_table: This is the remote node table to which the remote node
+ *    index is to be freed.
+ *
+ * This method will release a group of three consecutive remote nodes back to
+ * the free remote nodes.
+ */
+static void scic_sds_remote_node_table_release_triple_remote_node(
+	struct scic_remote_node_table *remote_node_table,
+	u16 remote_node_index)
+{
+	u32 group_index;
+
+	group_index = remote_node_index / SCU_STP_REMOTE_NODE_COUNT;
+
+	scic_sds_remote_node_table_set_group_index(
+		remote_node_table, 2, group_index
+		);
+
+	scic_sds_remote_node_table_set_group(remote_node_table, group_index);
+}
+
+/**
+ *
+ * @remote_node_table: The remote node table to which the remote node index is
+ *    to be freed.
+ * @remote_node_count: This is the count of consecutive remote nodes that are
+ *    to be freed.
+ *
+ * This method will release the remote node index back into the remote node
+ * table free pool.
+ */
+void scic_sds_remote_node_table_release_remote_node_index(
+	struct scic_remote_node_table *remote_node_table,
+	u32 remote_node_count,
+	u16 remote_node_index)
+{
+	if (remote_node_count == SCU_SSP_REMOTE_NODE_COUNT) {
+		scic_sds_remote_node_table_release_single_remote_node(
+			remote_node_table, remote_node_index);
+	} else if (remote_node_count == SCU_STP_REMOTE_NODE_COUNT) {
+		scic_sds_remote_node_table_release_triple_remote_node(
+			remote_node_table, remote_node_index);
+	}
+}
+
diff --git a/drivers/scsi/isci/remote_node_table.h b/drivers/scsi/isci/remote_node_table.h
new file mode 100644
index 0000000..9c02a6c
--- /dev/null
+++ b/drivers/scsi/isci/remote_node_table.h
@@ -0,0 +1,195 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _SCIC_SDS_REMOTE_NODE_TABLE_H_
+#define _SCIC_SDS_REMOTE_NODE_TABLE_H_
+
+/**
+ * This file contains the structures, constants and prototypes used for the
+ *    remote node table.
+ *
+ *
+ */
+
+#include "sci_controller_constants.h"
+
+/**
+ *
+ *
+ * Remote node sets are sets of remote node index in the remtoe node table The
+ * SCU hardware requires that STP remote node entries take three consecutive
+ * remote node index so the table is arranged in sets of three. The bits are
+ * used as 0111 0111 to make a byte and the bits define the set of three remote
+ * nodes to use as a sequence.
+ */
+#define SCIC_SDS_REMOTE_NODE_SETS_PER_BYTE 2
+
+/**
+ *
+ *
+ * Since the remote node table is organized as DWORDS take the remote node sets
+ * in bytes and represent them in DWORDs. The lowest ordered bits are the ones
+ * used in case full DWORD is not being used. i.e. 0000 0000 0000 0000 0111
+ * 0111 0111 0111 // if only a single WORD is in use in the DWORD.
+ */
+#define SCIC_SDS_REMOTE_NODE_SETS_PER_DWORD \
+	(sizeof(u32) * SCIC_SDS_REMOTE_NODE_SETS_PER_BYTE)
+/**
+ *
+ *
+ * This is a count of the numeber of remote nodes that can be represented in a
+ * byte
+ */
+#define SCIC_SDS_REMOTE_NODES_PER_BYTE	\
+	(SCU_STP_REMOTE_NODE_COUNT * SCIC_SDS_REMOTE_NODE_SETS_PER_BYTE)
+
+/**
+ *
+ *
+ * This is a count of the number of remote nodes that can be represented in a
+ * DWROD
+ */
+#define SCIC_SDS_REMOTE_NODES_PER_DWORD	\
+	(sizeof(u32) * SCIC_SDS_REMOTE_NODES_PER_BYTE)
+
+/**
+ *
+ *
+ * This is the number of bits in a remote node group
+ */
+#define SCIC_SDS_REMOTE_NODES_BITS_PER_GROUP   4
+
+#define SCIC_SDS_REMOTE_NODE_TABLE_INVALID_INDEX      (0xFFFFFFFF)
+#define SCIC_SDS_REMOTE_NODE_TABLE_FULL_SLOT_VALUE    (0x07)
+#define SCIC_SDS_REMOTE_NODE_TABLE_EMPTY_SLOT_VALUE   (0x00)
+
+/**
+ *
+ *
+ * Expander attached sata remote node count
+ */
+#define SCU_STP_REMOTE_NODE_COUNT        3
+
+/**
+ *
+ *
+ * Expander or direct attached ssp remote node count
+ */
+#define SCU_SSP_REMOTE_NODE_COUNT        1
+
+/**
+ *
+ *
+ * Direct attached STP remote node count
+ */
+#define SCU_SATA_REMOTE_NODE_COUNT       1
+
+/**
+ * struct scic_remote_node_table -
+ *
+ *
+ */
+struct scic_remote_node_table {
+	/**
+	 * This field contains the array size in dwords
+	 */
+	u16 available_nodes_array_size;
+
+	/**
+	 * This field contains the array size of the
+	 */
+	u16 group_array_size;
+
+	/**
+	 * This field is the array of available remote node entries in bits.
+	 * Because of the way STP remote node data is allocated on the SCU hardware
+	 * the remote nodes must occupy three consecutive remote node context
+	 * entries.  For ease of allocation and de-allocation we have broken the
+	 * sets of three into a single nibble.  When the STP RNi is allocated all
+	 * of the bits in the nibble are cleared.  This math results in a table size
+	 * of MAX_REMOTE_NODES / CONSECUTIVE RNi ENTRIES for STP / 2 entries per byte.
+	 */
+	u32 available_remote_nodes[
+		(SCI_MAX_REMOTE_DEVICES / SCIC_SDS_REMOTE_NODES_PER_DWORD)
+		+ ((SCI_MAX_REMOTE_DEVICES % SCIC_SDS_REMOTE_NODES_PER_DWORD) != 0)];
+
+	/**
+	 * This field is the nibble selector for the above table.  There are three
+	 * possible selectors each for fast lookup when trying to find one, two or
+	 * three remote node entries.
+	 */
+	u32 remote_node_groups[
+		SCU_STP_REMOTE_NODE_COUNT][
+		(SCI_MAX_REMOTE_DEVICES / (32 * SCU_STP_REMOTE_NODE_COUNT))
+		+ ((SCI_MAX_REMOTE_DEVICES % (32 * SCU_STP_REMOTE_NODE_COUNT)) != 0)];
+
+};
+
+/* --------------------------------------------------------------------------- */
+
+void scic_sds_remote_node_table_initialize(
+	struct scic_remote_node_table *remote_node_table,
+	u32 remote_node_entries);
+
+u16 scic_sds_remote_node_table_allocate_remote_node(
+	struct scic_remote_node_table *remote_node_table,
+	u32 remote_node_count);
+
+void scic_sds_remote_node_table_release_remote_node_index(
+	struct scic_remote_node_table *remote_node_table,
+	u32 remote_node_count,
+	u16 remote_node_index);
+
+#endif /* _SCIC_SDS_REMOTE_NODE_TABLE_H_ */
diff --git a/drivers/scsi/isci/request.c b/drivers/scsi/isci/request.c
index 8d2125b..ff5c05a 100644
--- a/drivers/scsi/isci/request.c
+++ b/drivers/scsi/isci/request.c
@@ -54,7 +54,6 @@
  */
 
 #include "isci.h"
-#include "scic_remote_device.h"
 #include "scic_io_request.h"
 #include "scic_task_request.h"
 #include "scic_port.h"
diff --git a/drivers/scsi/isci/sata.c b/drivers/scsi/isci/sata.c
index c941d90..53ce0c2 100644
--- a/drivers/scsi/isci/sata.c
+++ b/drivers/scsi/isci/sata.c
@@ -54,8 +54,7 @@
  */
 
 #include "isci.h"
-#include "scic_remote_device.h"
-#include "scic_sds_remote_device.h"
+#include "remote_device.h"
 #include "scic_io_request.h"
 #include "scic_task_request.h"
 #include "task.h"
diff --git a/drivers/scsi/isci/scu_remote_node_context.h b/drivers/scsi/isci/scu_remote_node_context.h
new file mode 100644
index 0000000..33745ad
--- /dev/null
+++ b/drivers/scsi/isci/scu_remote_node_context.h
@@ -0,0 +1,229 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SCU_REMOTE_NODE_CONTEXT_HEADER__
+#define __SCU_REMOTE_NODE_CONTEXT_HEADER__
+
+/**
+ * This file contains the structures and constatns used by the SCU hardware to
+ *    describe a remote node context.
+ *
+ *
+ */
+
+/**
+ * struct ssp_remote_node_context - This structure contains the SCU hardware
+ *    definition for an SSP remote node.
+ *
+ *
+ */
+struct ssp_remote_node_context {
+	/* WORD 0 */
+
+	/**
+	 * This field is the remote node index assigned for this remote node. All
+	 * remote nodes must have a unique remote node index. The value of the remote
+	 * node index can not exceed the maximum number of remote nodes reported in
+	 * the SCU device context capacity register.
+	 */
+	u32 remote_node_index:12;
+	u32 reserved0_1:4;
+
+	/**
+	 * This field tells the SCU hardware how many simultaneous connections that
+	 * this remote node will support.
+	 */
+	u32 remote_node_port_width:4;
+
+	/**
+	 * This field tells the SCU hardware which logical port to associate with this
+	 * remote node.
+	 */
+	u32 logical_port_index:3;
+	u32 reserved0_2:5;
+
+	/**
+	 * This field will enable the I_T nexus loss timer for this remote node.
+	 */
+	u32 nexus_loss_timer_enable:1;
+
+	/**
+	 * This field is the for driver debug only and is not used.
+	 */
+	u32 check_bit:1;
+
+	/**
+	 * This field must be set to true when the hardware DMAs the remote node
+	 * context to the hardware SRAM.  When the remote node is being invalidated
+	 * this field must be set to false.
+	 */
+	u32 is_valid:1;
+
+	/**
+	 * This field must be set to true.
+	 */
+	u32 is_remote_node_context:1;
+
+	/* WORD 1 - 2 */
+
+	/**
+	 * This is the low word of the remote device SAS Address
+	 */
+	u32 remote_sas_address_lo;
+
+	/**
+	 * This field is the high word of the remote device SAS Address
+	 */
+	u32 remote_sas_address_hi;
+
+	/* WORD 3 */
+	/**
+	 * This field reprensets the function number assigned to this remote device.
+	 * This value must match the virtual function number that is being used to
+	 * communicate to the device.
+	 */
+	u32 function_number:8;
+	u32 reserved3_1:8;
+
+	/**
+	 * This field provides the driver a way to cheat on the arbitration wait time
+	 * for this remote node.
+	 */
+	u32 arbitration_wait_time:16;
+
+	/* WORD 4 */
+	/**
+	 * This field tells the SCU hardware how long this device may occupy the
+	 * connection before it must be closed.
+	 */
+	u32 connection_occupancy_timeout:16;
+
+	/**
+	 * This field tells the SCU hardware how long to maintain a connection when
+	 * there are no frames being transmitted on the link.
+	 */
+	u32 connection_inactivity_timeout:16;
+
+	/* WORD  5 */
+	/**
+	 * This field allows the driver to cheat on the arbitration wait time for this
+	 * remote node.
+	 */
+	u32 initial_arbitration_wait_time:16;
+
+	/**
+	 * This field is tells the hardware what to program for the connection rate in
+	 * the open address frame.  See the SAS spec for valid values.
+	 */
+	u32 oaf_connection_rate:4;
+
+	/**
+	 * This field tells the SCU hardware what to program for the features in the
+	 * open address frame.  See the SAS spec for valid values.
+	 */
+	u32 oaf_features:4;
+
+	/**
+	 * This field tells the SCU hardware what to use for the source zone group in
+	 * the open address frame.  See the SAS spec for more details on zoning.
+	 */
+	u32 oaf_source_zone_group:8;
+
+	/* WORD 6 */
+	/**
+	 * This field tells the SCU hardware what to use as the more capibilities in
+	 * the open address frame. See the SAS Spec for details.
+	 */
+	u32 oaf_more_compatibility_features;
+
+	/* WORD 7 */
+	u32 reserved7;
+
+};
+
+/**
+ * struct stp_remote_node_context - This structure contains the SCU hardware
+ *    definition for a STP remote node.
+ *
+ * STP Targets are not yet supported so this definition is a placeholder until
+ * we do support them.
+ */
+struct stp_remote_node_context {
+	/**
+	 * Placeholder data for the STP remote node.
+	 */
+	u32 data[8];
+
+};
+
+/**
+ * This union combines the SAS and SATA remote node definitions.
+ *
+ * union scu_remote_node_context
+ */
+union scu_remote_node_context {
+	/**
+	 * SSP Remote Node
+	 */
+	struct ssp_remote_node_context ssp;
+
+	/**
+	 * STP Remote Node
+	 */
+	struct stp_remote_node_context stp;
+
+};
+
+#endif /* __SCU_REMOTE_NODE_CONTEXT_HEADER__ */
diff --git a/drivers/scsi/isci/smp_remote_device.c b/drivers/scsi/isci/smp_remote_device.c
new file mode 100644
index 0000000..718ddaf
--- /dev/null
+++ b/drivers/scsi/isci/smp_remote_device.c
@@ -0,0 +1,314 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "scic_sds_controller.h"
+#include "scic_sds_port.h"
+#include "remote_device.h"
+#include "scic_sds_request.h"
+#include "sci_environment.h"
+#include "sci_util.h"
+#include "scu_event_codes.h"
+#include "scu_task_context.h"
+
+/*
+ * *****************************************************************************
+ * *  SMP REMOTE DEVICE READY IDLE SUBSTATE HANDLERS
+ * ***************************************************************************** */
+
+/**
+ *
+ * @[in]: device The device the io is sent to.
+ * @[in]: request The io to start.
+ *
+ * This method will handle the start io operation for a SMP device that is in
+ * the idle state. enum sci_status
+ */
+static enum sci_status scic_sds_smp_remote_device_ready_idle_substate_start_io_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	enum sci_status status;
+
+	/* Will the port allow the io request to start? */
+	status = device->owning_port->state_handlers->start_io_handler(
+			device->owning_port, device, request);
+
+	if (status == SCI_SUCCESS) {
+		status = scic_sds_remote_node_context_start_io(&device->rnc, request);
+
+		if (status == SCI_SUCCESS)
+			status = scic_sds_request_start(request);
+
+		if (status == SCI_SUCCESS) {
+			device->working_request = request;
+
+			sci_base_state_machine_change_state(
+				&device->ready_substate_machine,
+				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD
+				);
+		}
+
+		scic_sds_remote_device_start_request(device, request, status);
+	}
+
+	return status;
+}
+
+
+/*
+ * ******************************************************************************
+ * * SMP REMOTE DEVICE READY SUBSTATE CMD HANDLERS
+ * ****************************************************************************** */
+/**
+ *
+ * @device: This is the device object that is receiving the IO.
+ * @request: The io to start.
+ *
+ * This device is already handling a command it can not accept new commands
+ * until this one is complete. enum sci_status
+ */
+static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+
+/**
+ * this is the complete_io_handler for smp device at ready cmd substate.
+ * @device: This is the device object that is receiving the IO.
+ * @request: The io to start.
+ *
+ * enum sci_status
+ */
+static enum sci_status
+scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	enum sci_status status;
+	struct scic_sds_request *sci_req;
+
+	sci_req = (struct scic_sds_request *)request;
+
+	status = scic_sds_io_request_complete(sci_req);
+
+	if (status == SCI_SUCCESS) {
+		status = scic_sds_port_complete_io(
+			device->owning_port, device, sci_req);
+
+		if (status == SCI_SUCCESS) {
+			scic_sds_remote_device_decrement_request_count(device);
+			sci_base_state_machine_change_state(
+				&device->ready_substate_machine,
+				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE
+				);
+		} else
+			dev_err(scirdev_to_dev(device),
+				"%s: SCIC SDS Remote Device 0x%p io request "
+				"0x%p could not be completd on the port 0x%p "
+				"failed with status %d.\n",
+				__func__,
+				device,
+				sci_req,
+				device->owning_port,
+				status);
+	}
+
+	return status;
+}
+
+/**
+ * This is frame handler for smp device ready cmd substate.
+ * @sci_dev: This is the device object that is receiving the frame.
+ * @frame_index: The index for the frame received.
+ *
+ * enum sci_status
+ */
+static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	enum sci_status status;
+
+	/*
+	 * / The device does not process any UF received from the hardware while
+	 * / in this state.  All unsolicited frames are forwarded to the io request
+	 * / object. */
+	status = scic_sds_io_request_frame_handler(
+		sci_dev->working_request,
+		frame_index
+		);
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct scic_sds_remote_device_state_handler scic_sds_smp_remote_device_ready_substate_handler_table[] = {
+	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_smp_remote_device_ready_idle_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
+	}
+};
+
+/**
+ *
+ * @object: This is the struct sci_base_object which is cast into a
+ *    struct scic_sds_remote_device.
+ *
+ * This is the SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE enter method.
+ * This function sets the ready cmd substate handlers and reports the device as
+ * ready. none
+ */
+static void scic_sds_smp_remote_device_ready_idle_substate_enter(struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
+	SET_STATE_HANDLER(sci_dev,
+			  scic_sds_smp_remote_device_ready_substate_handler_table,
+			  SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+
+	isci_remote_device_ready(ihost, idev);
+}
+
+/**
+ *
+ * @object: This is the struct sci_base_object which is cast into a
+ *    struct scic_sds_remote_device.
+ *
+ * This is the SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD enter method. This
+ * function sets the remote device objects ready cmd substate handlers, and
+ * notify core user that the device is not ready. none
+ */
+static void scic_sds_smp_remote_device_ready_cmd_substate_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
+	BUG_ON(sci_dev->working_request == NULL);
+
+	SET_STATE_HANDLER(sci_dev,
+			  scic_sds_smp_remote_device_ready_substate_handler_table,
+			  SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+
+	isci_remote_device_not_ready(ihost, idev,
+				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
+}
+
+/**
+ *
+ * @object: This is the struct sci_base_object which is cast into a
+ *    struct scic_sds_remote_device.
+ *
+ * This is the SCIC_SDS_SSP_REMOTE_DEVICE_READY_SUBSTATE_CMD exit method. none
+ */
+static void scic_sds_smp_remote_device_ready_cmd_substate_exit(struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	sci_dev->working_request = NULL;
+}
+
+/* --------------------------------------------------------------------------- */
+
+const struct sci_base_state scic_sds_smp_remote_device_ready_substate_table[] = {
+	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
+		.enter_state = scic_sds_smp_remote_device_ready_idle_substate_enter,
+	},
+	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
+		.enter_state = scic_sds_smp_remote_device_ready_cmd_substate_enter,
+		.exit_state  = scic_sds_smp_remote_device_ready_cmd_substate_exit,
+	},
+};
diff --git a/drivers/scsi/isci/stp_remote_device.c b/drivers/scsi/isci/stp_remote_device.c
new file mode 100644
index 0000000..b81f21f
--- /dev/null
+++ b/drivers/scsi/isci/stp_remote_device.c
@@ -0,0 +1,817 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "intel_ata.h"
+#include "intel_sata.h"
+#include "intel_sat.h"
+#include "sci_base_state.h"
+#include "scic_sds_controller.h"
+#include "scic_sds_port.h"
+#include "remote_device.h"
+#include "scic_sds_request.h"
+#include "sci_environment.h"
+#include "sci_util.h"
+#include "scu_event_codes.h"
+
+/**
+ * This method will perform the STP request completion processing common to IO
+ *    requests and task requests of all types
+ * @device: This parameter specifies the device for which the request is being
+ *    completed.
+ * @request: This parameter specifies the request being completed.
+ *
+ * This method returns an indication as to whether the request processing
+ * completed successfully.
+ */
+static enum sci_status scic_sds_stp_remote_device_complete_request(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	enum sci_status status;
+
+	status = scic_sds_io_request_complete(request);
+
+	if (status == SCI_SUCCESS) {
+		status = scic_sds_port_complete_io(
+			device->owning_port, device, request);
+
+		if (status == SCI_SUCCESS) {
+			scic_sds_remote_device_decrement_request_count(device);
+			if (request->sci_status == SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {
+				/*
+				 * This request causes hardware error, device needs to be Lun Reset.
+				 * So here we force the state machine to IDLE state so the rest IOs
+				 * can reach RNC state handler, these IOs will be completed by RNC with
+				 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE". */
+				sci_base_state_machine_change_state(
+					&device->ready_substate_machine,
+					SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET
+					);
+			} else if (scic_sds_remote_device_get_request_count(device) == 0) {
+				sci_base_state_machine_change_state(
+					&device->ready_substate_machine,
+					SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE
+					);
+			}
+		}
+	}
+
+	if (status != SCI_SUCCESS)
+		dev_err(scirdev_to_dev(device),
+			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
+			"could not complete\n",
+			__func__,
+			device->owning_port,
+			device,
+			request,
+			status);
+
+	return status;
+}
+
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY COMMON SUBSTATE HANDLERS
+ * ***************************************************************************** */
+
+/**
+ * This is the READY NCQ substate handler to start task management request. In
+ *    this routine, we suspend and resume the RNC.
+ * @device: The target device a task management request towards to.
+ * @request: The task request.
+ *
+ * enum sci_status Always return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS status to
+ * let controller_start_task_handler know that the controller can't post TC for
+ * task request yet, instead, when RNC gets resumed, a controller_continue_task
+ * callback will be called.
+ */
+static enum sci_status scic_sds_stp_remote_device_ready_substate_start_request_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	enum sci_status status;
+
+	/* Will the port allow the io request to start? */
+	status = device->owning_port->state_handlers->start_io_handler(
+		device->owning_port, device, request);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	status = scic_sds_remote_node_context_start_task(&device->rnc, request);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	status = request->state_handlers->start_handler(request);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	/*
+	 * Note: If the remote device state is not IDLE this will replace
+	 * the request that probably resulted in the task management request.
+	 */
+	device->working_request = request;
+	sci_base_state_machine_change_state(&device->ready_substate_machine,
+			SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+
+	/*
+	 * The remote node context must cleanup the TCi to NCQ mapping table.
+	 * The only way to do this correctly is to either write to the TLCR
+	 * register or to invalidate and repost the RNC. In either case the
+	 * remote node context state machine will take the correct action when
+	 * the remote node context is suspended and later resumed.
+	 */
+	scic_sds_remote_node_context_suspend(&device->rnc,
+			SCI_SOFTWARE_SUSPENSION, NULL, NULL);
+	scic_sds_remote_node_context_resume(&device->rnc,
+			scic_sds_remote_device_continue_request,
+			device);
+
+out:
+	scic_sds_remote_device_start_request(device, request, status);
+	/*
+	 * We need to let the controller start request handler know that it can't
+	 * post TC yet. We will provide a callback function to post TC when RNC gets
+	 * resumed.
+	 */
+	return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
+}
+
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY IDLE SUBSTATE HANDLERS
+ * ***************************************************************************** */
+
+/**
+ * This method will handle the start io operation for a sata device that is in
+ *    the command idle state. - Evalute the type of IO request to be started -
+ *    If its an NCQ request change to NCQ substate - If its any other command
+ *    change to the CMD substate
+ * @device:
+ * @request:
+ *
+ * If this is a softreset we may want to have a different substate.
+ * enum sci_status
+ */
+static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_start_io_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status status;
+	struct isci_request *isci_request =
+		(struct isci_request *)sci_object_get_association(request);
+
+
+	/* Will the port allow the io request to start? */
+	status = sci_dev->owning_port->state_handlers->start_io_handler(
+			sci_dev->owning_port, sci_dev, request);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	status = request->state_handlers->start_handler(request);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	if (isci_sata_get_sat_protocol(isci_request) == SAT_PROTOCOL_FPDMA) {
+		sci_base_state_machine_change_state(&sci_dev->ready_substate_machine,
+				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ);
+	} else {
+		sci_dev->working_request = request;
+		sci_base_state_machine_change_state(&sci_dev->ready_substate_machine,
+				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+	}
+out:
+	scic_sds_remote_device_start_request(sci_dev, request, status);
+	return status;
+}
+
+
+/**
+ *
+ * @[in]: device The device received event.
+ * @[in]: event_code The event code.
+ *
+ * This method will handle the event for a sata device that is in the idle
+ * state. We pick up suspension events to handle specifically to this state. We
+ * resume the RNC right away. enum sci_status
+ */
+static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	status = scic_sds_remote_device_general_event_handler(sci_dev, event_code);
+
+	if (status == SCI_SUCCESS) {
+		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX
+		    || scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {
+			status = scic_sds_remote_node_context_resume(
+				&sci_dev->rnc, NULL, NULL);
+		}
+	}
+
+	return status;
+}
+
+
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY NCQ SUBSTATE HANDLERS
+ * ***************************************************************************** */
+
+static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status status;
+	struct isci_request *isci_request =
+		(struct isci_request *)sci_object_get_association(request);
+
+	if (isci_sata_get_sat_protocol(isci_request) == SAT_PROTOCOL_FPDMA) {
+		status = sci_dev->owning_port->state_handlers->start_io_handler(
+				sci_dev->owning_port,
+				sci_dev,
+				request);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		status = request->state_handlers->start_handler(request);
+
+		scic_sds_remote_device_start_request(sci_dev, request, status);
+	} else
+		status = SCI_FAILURE_INVALID_STATE;
+
+	return status;
+}
+
+
+/**
+ * This method will handle events received while the STP device is in the ready
+ *    command substate.
+ * @sci_dev: This is the device object that is receiving the event.
+ * @event_code: The event code to process.
+ *
+ * enum sci_status
+ */
+
+static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	enum sci_status status;
+	struct sata_fis_header *frame_header;
+
+	status = scic_sds_unsolicited_frame_control_get_header(
+		&(scic_sds_remote_device_get_controller(sci_dev)->uf_control),
+		frame_index,
+		(void **)&frame_header
+		);
+
+	if (status == SCI_SUCCESS) {
+		if (frame_header->fis_type == SATA_FIS_TYPE_SETDEVBITS &&
+		    (frame_header->status & ATA_STATUS_REG_ERROR_BIT)) {
+			sci_dev->not_ready_reason =
+				SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
+
+			/*
+			 * / @todo Check sactive and complete associated IO
+			 * if any.
+			 */
+
+			sci_base_state_machine_change_state(
+				&sci_dev->ready_substate_machine,
+				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR
+				);
+		} else if (frame_header->fis_type == SATA_FIS_TYPE_REGD2H &&
+			   (frame_header->status & ATA_STATUS_REG_ERROR_BIT)) {
+
+			/*
+			 * Some devices return D2H FIS when an NCQ error is detected.
+			 * Treat this like an SDB error FIS ready reason.
+			 */
+			sci_dev->not_ready_reason =
+				SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
+
+			sci_base_state_machine_change_state(
+				&sci_dev->ready_substate_machine,
+				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR
+				);
+		} else {
+			status = SCI_FAILURE;
+		}
+
+		scic_sds_controller_release_frame(
+			scic_sds_remote_device_get_controller(sci_dev), frame_index
+			);
+	}
+
+	return status;
+}
+
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY CMD SUBSTATE HANDLERS
+ * ***************************************************************************** */
+
+/**
+ * This device is already handling a command it can not accept new commands
+ *    until this one is complete.
+ * @device:
+ * @request:
+ *
+ * enum sci_status
+ */
+static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 suspend_type)
+{
+	enum sci_status status;
+
+	status = scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+						      suspend_type, NULL, NULL);
+
+	return status;
+}
+
+static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	enum sci_status status;
+
+	/*
+	 * / The device doe not process any UF received from the hardware while
+	 * / in this state.  All unsolicited frames are forwarded to the io request
+	 * / object. */
+	status = scic_sds_io_request_frame_handler(
+		sci_dev->working_request,
+		frame_index
+		);
+
+	return status;
+}
+
+
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY NCQ SUBSTATE HANDLERS
+ * ***************************************************************************** */
+
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY NCQ ERROR SUBSTATE HANDLERS
+ * ***************************************************************************** */
+
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY AWAIT RESET SUBSTATE HANDLERS
+ * ***************************************************************************** */
+static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
+}
+
+
+
+/**
+ * This method will perform the STP request (both io or task) completion
+ *    processing for await reset state.
+ * @device: This parameter specifies the device for which the request is being
+ *    completed.
+ * @request: This parameter specifies the request being completed.
+ *
+ * This method returns an indication as to whether the request processing
+ * completed successfully.
+ */
+static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)request;
+	enum sci_status status;
+
+	status = scic_sds_io_request_complete(sci_req);
+
+	if (status == SCI_SUCCESS) {
+		status = scic_sds_port_complete_io(
+			device->owning_port, device, sci_req
+			);
+
+		if (status == SCI_SUCCESS)
+			scic_sds_remote_device_decrement_request_count(device);
+	}
+
+	if (status != SCI_SUCCESS)
+		dev_err(scirdev_to_dev(device),
+			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
+			"could not complete\n",
+			__func__,
+			device->owning_port,
+			device,
+			sci_req,
+			status);
+
+	return status;
+}
+
+#if !defined(DISABLE_ATAPI)
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY ATAPI ERROR SUBSTATE HANDLERS
+ * ***************************************************************************** */
+
+/**
+ *
+ * @[in]: device The device received event.
+ * @[in]: event_code The event code.
+ *
+ * This method will handle the event for a ATAPI device that is in the ATAPI
+ * ERROR state. We pick up suspension events to handle specifically to this
+ * state. We resume the RNC right away. We then complete the outstanding IO to
+ * this device. enum sci_status
+ */
+enum sci_status scic_sds_stp_remote_device_ready_atapi_error_substate_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	status = scic_sds_remote_device_general_event_handler(sci_dev, event_code);
+
+	if (status == SCI_SUCCESS) {
+		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX
+		    || scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {
+			status = scic_sds_remote_node_context_resume(
+				sci_dev->rnc,
+				sci_dev->working_request->state_handlers->parent.complete_handler,
+				(void *)sci_dev->working_request
+				);
+		}
+	}
+
+	return status;
+}
+#endif /* !defined(DISABLE_ATAPI) */
+
+/* --------------------------------------------------------------------------- */
+
+static const struct scic_sds_remote_device_state_handler scic_sds_stp_remote_device_ready_substate_handler_table[] = {
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_stp_remote_device_ready_idle_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_stp_remote_device_ready_idle_substate_event_handler,
+		.frame_handler			= scic_sds_remote_device_default_frame_handler
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
+		.suspend_handler		= scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_remote_device_general_event_handler,
+		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
+		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_remote_device_general_event_handler,
+		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
+		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_remote_device_general_event_handler,
+		.frame_handler			= scic_sds_remote_device_general_frame_handler
+	},
+#if !defined(DISABLE_ATAPI)
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
+		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_stp_remote_device_ready_atapi_error_substate_event_handler,
+		.frame_handler			= scic_sds_remote_device_general_frame_handler
+	},
+#endif
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
+		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_remote_device_general_event_handler,
+		.frame_handler			= scic_sds_remote_device_general_frame_handler
+	}
+};
+
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY SUBSTATE PRIVATE METHODS
+ * ***************************************************************************** */
+
+static void
+scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *user_cookie)
+{
+	struct scic_sds_remote_device *sci_dev = user_cookie;
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+
+	/*
+	 * For NCQ operation we do not issue a
+	 * scic_cb_remote_device_not_ready().  As a result, avoid sending
+	 * the ready notification.
+	 */
+	if (sci_dev->ready_substate_machine.previous_state_id !=
+			SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ)
+		isci_remote_device_ready(ihost, idev);
+}
+
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY IDLE SUBSTATE
+ * ***************************************************************************** */
+
+/**
+ *
+ * @device: This is the SCI base object which is cast into a
+ *    struct scic_sds_remote_device object.
+ *
+ */
+static void scic_sds_stp_remote_device_ready_idle_substate_enter(
+	struct sci_base_object *device)
+{
+	struct scic_sds_remote_device *sci_dev;
+
+	sci_dev = (struct scic_sds_remote_device *)device;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_stp_remote_device_ready_substate_handler_table,
+		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE
+		);
+
+	sci_dev->working_request = NULL;
+
+	if (scic_sds_remote_node_context_is_ready(&sci_dev->rnc)) {
+		/*
+		 * Since the RNC is ready, it's alright to finish completion
+		 * processing (e.g. signal the remote device is ready). */
+		scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(
+			sci_dev
+			);
+	} else {
+		scic_sds_remote_node_context_resume(
+			&sci_dev->rnc,
+			scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler,
+			sci_dev);
+	}
+}
+
+static void scic_sds_stp_remote_device_ready_cmd_substate_enter(struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
+	BUG_ON(sci_dev->working_request == NULL);
+
+	SET_STATE_HANDLER(sci_dev,
+			  scic_sds_stp_remote_device_ready_substate_handler_table,
+			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+
+	isci_remote_device_not_ready(ihost, idev,
+				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
+}
+
+static void scic_sds_stp_remote_device_ready_ncq_substate_enter(struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	SET_STATE_HANDLER(sci_dev,
+			  scic_sds_stp_remote_device_ready_substate_handler_table,
+			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ);
+}
+
+static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
+	SET_STATE_HANDLER(sci_dev,
+			  scic_sds_stp_remote_device_ready_substate_handler_table,
+			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
+
+	if (sci_dev->not_ready_reason ==
+		SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
+		isci_remote_device_not_ready(ihost, idev, sci_dev->not_ready_reason);
+}
+
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY AWAIT RESET SUBSTATE
+ * ***************************************************************************** */
+
+/**
+ * The enter routine to READY AWAIT RESET substate.
+ * @device: This is the SCI base object which is cast into a
+ *    struct scic_sds_remote_device object.
+ *
+ */
+static void scic_sds_stp_remote_device_ready_await_reset_substate_enter(
+	struct sci_base_object *device)
+{
+	struct scic_sds_remote_device *sci_dev;
+
+	sci_dev = (struct scic_sds_remote_device *)device;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_stp_remote_device_ready_substate_handler_table,
+		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET
+		);
+}
+
+#if !defined(DISABLE_ATAPI)
+/*
+ * *****************************************************************************
+ * *  STP REMOTE DEVICE READY ATAPI ERROR SUBSTATE
+ * ***************************************************************************** */
+
+/**
+ * The enter routine to READY ATAPI ERROR substate.
+ * @device: This is the SCI base object which is cast into a
+ *    struct scic_sds_remote_device object.
+ *
+ */
+void scic_sds_stp_remote_device_ready_atapi_error_substate_enter(
+	struct sci_base_object *device)
+{
+	struct scic_sds_remote_device *sci_dev;
+
+	sci_dev = (struct scic_sds_remote_device *)device;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_stp_remote_device_ready_substate_handler_table,
+		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR
+		);
+}
+#endif /* !defined(DISABLE_ATAPI) */
+
+/* --------------------------------------------------------------------------- */
+
+const struct sci_base_state scic_sds_stp_remote_device_ready_substate_table[] = {
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
+		.enter_state = scic_sds_stp_remote_device_ready_idle_substate_enter,
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
+		.enter_state = scic_sds_stp_remote_device_ready_cmd_substate_enter,
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
+		.enter_state = scic_sds_stp_remote_device_ready_ncq_substate_enter,
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
+		.enter_state = scic_sds_stp_remote_device_ready_ncq_error_substate_enter,
+	},
+#if !defined(DISABLE_ATAPI)
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR] = {
+		.enter_state = scic_sds_stp_remote_device_ready_atapi_error_substate_enter,
+	},
+#endif
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
+		.enter_state = scic_sds_stp_remote_device_ready_await_reset_substate_enter,
+	},
+};
diff --git a/drivers/scsi/isci/task.c b/drivers/scsi/isci/task.c
index f54f523..e011d66 100644
--- a/drivers/scsi/isci/task.c
+++ b/drivers/scsi/isci/task.c
@@ -56,10 +56,9 @@
 #include <linux/completion.h>
 #include <linux/irqflags.h>
 #include "scic_task_request.h"
-#include "scic_remote_device.h"
 #include "scic_io_request.h"
-#include "scic_sds_remote_device.h"
-#include "scic_sds_remote_node_context.h"
+#include "remote_device.h"
+#include "remote_node_context.h"
 #include "isci.h"
 #include "request.h"
 #include "sata.h"
-- 
1.6.0.2

