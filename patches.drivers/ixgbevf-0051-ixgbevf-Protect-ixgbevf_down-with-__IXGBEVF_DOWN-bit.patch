From: Mark Rustad <mark.d.rustad@intel.com>
Date: Tue, 4 Mar 2014 03:02:18 +0000
Subject: ixgbevf: Protect ixgbevf_down with __IXGBEVF_DOWN bit
Patch-mainline: v3.15-rc1
Git-commit: 5b346dc97567270a5c0f02a390a1d1bb65237cea
References: bug#909488 FATE#317387

The ixgbevf_down function can now prevent multiple executions by
doing test_and_set_bit on __IXGBEVF_DOWN. This did not work before
introduction of the __IXGBEVF_REMOVING bit, because of overloading
of __IXGBEVF_DOWN. Also add smp_mb__before_clear_bit call before
clearing the __IXGBEVF_DOWN bit.

Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

--- a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
+++ b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
@@ -1604,6 +1604,7 @@ static void ixgbevf_up_complete(struct i
 
 	spin_unlock_bh(&adapter->mbx_lock);
 
+	smp_mb__before_clear_bit();
 	clear_bit(__IXGBEVF_DOWN, &adapter->state);
 	ixgbevf_napi_enable_all(adapter);
 
@@ -1728,7 +1729,8 @@ void ixgbevf_down(struct ixgbevf_adapter
 	int i;
 
 	/* signal that we are down to the interrupt handler */
-	set_bit(__IXGBEVF_DOWN, &adapter->state);
+	if (test_and_set_bit(__IXGBEVF_DOWN, &adapter->state))
+		return; /* do nothing if already down */
 
 	/* disable all enabled rx queues */
 	for (i = 0; i < adapter->num_rx_queues; i++)
