From: Mauro Carvalho Chehab <mchehab@redhat.com>
Subject: i7core_edac: Add a code to probe Xeon 55xx bus
References: fate#311968
Git-commit: d1fd4fb69eeeb7db0693df58b9116db498d5bfe1
Patch-mainline: v2.6.35-rc2


Signed-off-by: Thomas Renninger <trenn@suse.de>

This code changes the detection procedure of i7core_edac. Instead of
directly probing for MC registers, it probes for another register found
on Nehalem. If found, it tries to pick the first MC PCI BUS. This should
work fine with Xeon 35xx, but, on Xeon 55xx, this is at bus 254 and 255
that are not properly detected by the non-legacy PCI methods.

The new detection code scans specifically at buses 254 and 255 for the
Xeon 55xx devices.

This code has not tested yet. After working, a change at the code will
be needed, since the i7core is not yet ready for working with 2 sets of
MC.

Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

---
 arch/x86/pci/legacy.c      |    1 +
 drivers/edac/i7core_edac.c |   17 +++++++++++++----
 include/linux/pci.h        |    1 +
 include/linux/pci_ids.h    |    1 +
 4 files changed, 16 insertions(+), 4 deletions(-)

Index: linux-2.6.32-SLE11-SP1/arch/x86/pci/legacy.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/pci/legacy.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/pci/legacy.c
@@ -60,6 +60,7 @@ void pcibios_scan_specific_bus(int busn)
 		}
 	}
 }
+EXPORT_SYMBOL_GPL(pcibios_scan_specific_bus);
 
 int __init pci_subsys_init(void)
 {
Index: linux-2.6.32-SLE11-SP1/drivers/edac/i7core_edac.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/edac/i7core_edac.c
+++ linux-2.6.32-SLE11-SP1/drivers/edac/i7core_edac.c
@@ -231,15 +231,15 @@ struct i7core_dev_info {
 	.dev_id = (device_id)
 
 struct pci_id_descr pci_devs[] = {
+		/* Generic Non-core registers */
+	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NOCORE)  },
+
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
 	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS)  }, /* if RDIMM is supported */
 	{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_I7_MC_TEST) },
 
-		/* Generic Non-core registers */
-	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NOCORE)  },
-
 		/* Channel 0 */
 	{ PCI_DESCR(4, 0, PCI_DEVICE_ID_INTEL_I7_MC_CH0_CTRL) },
 	{ PCI_DESCR(4, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH0_ADDR) },
@@ -265,7 +265,7 @@ struct pci_id_descr pci_devs[] = {
  * This should match the first device at pci_devs table
  */
 static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7_MCR)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_X58_HUB_MGMT)},
 	{0,}			/* 0 terminated list. */
 };
 
@@ -1079,6 +1079,15 @@ static int i7core_get_devices(void)
 	for (i = 0; i < N_DEVS; i++) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 					pci_devs[i].dev_id, NULL);
+
+		if (!pdev && !i) {
+			pcibios_scan_specific_bus(254);
+			pcibios_scan_specific_bus(255);
+
+			pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+						pci_devs[i].dev_id, NULL);
+		}
+
 		if (likely(pdev))
 			pci_devs[i].pdev = pdev;
 		else {
Index: linux-2.6.32-SLE11-SP1/include/linux/pci.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/pci.h
+++ linux-2.6.32-SLE11-SP1/include/linux/pci.h
@@ -586,6 +586,7 @@ void pci_fixup_cardbus(struct pci_bus *)
 
 /* Generic PCI functions used internally */
 
+void pcibios_scan_specific_bus(int busn);
 extern struct pci_bus *pci_find_bus(int domain, int busnr);
 void pci_bus_add_devices(const struct pci_bus *bus);
 struct pci_bus *pci_scan_bus_parented(struct device *parent, int bus,
Index: linux-2.6.32-SLE11-SP1/include/linux/pci_ids.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/pci_ids.h
+++ linux-2.6.32-SLE11-SP1/include/linux/pci_ids.h
@@ -2561,6 +2561,7 @@
 #define PCI_DEVICE_ID_INTEL_IOAT_TBG5	0x342a
 #define PCI_DEVICE_ID_INTEL_IOAT_TBG6	0x342b
 #define PCI_DEVICE_ID_INTEL_IOAT_TBG7	0x342c
+#define PCI_DEVICE_ID_INTEL_X58_HUB_MGMT 0x342e
 #define PCI_DEVICE_ID_INTEL_IOAT_TBG0	0x3430
 #define PCI_DEVICE_ID_INTEL_IOAT_TBG1	0x3431
 #define PCI_DEVICE_ID_INTEL_IOAT_TBG2	0x3432
