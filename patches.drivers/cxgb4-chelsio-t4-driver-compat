From: Pranjal Joshi <pjoshi@chelsio.com>
References: bnc#694966, FATE#311470
Subject: cxgb4: Chelsio T4 driver (compat)
Patch-mainline: Never, compatibility patches

 This patch contains the changes needed to make the upstream cxgb4 driver
 work properly with the SLE11 SP2 kernel.

Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 drivers/net/cxgb4/cxgb4.h        |    2 
 drivers/net/cxgb4/cxgb4_compat.h |  249 +++++++++++++++++++++++++++++++++++++++
 drivers/net/cxgb4/cxgb4_main.c   |  139 ++++++++-------------
 drivers/net/cxgb4/sge.c          |   39 ++++--
 4 files changed, 334 insertions(+), 95 deletions(-)

--- a/drivers/net/cxgb4/cxgb4.h
+++ b/drivers/net/cxgb4/cxgb4.h
@@ -44,6 +44,7 @@
 #include <linux/spinlock.h>
 #include <linux/timer.h>
 #include <asm/io.h>
+#include "cxgb4_compat.h"
 #include "cxgb4_uld.h"
 #include "t4_hw.h"
 
@@ -295,6 +296,7 @@ struct port_info {
 	u8     first_qset;            /* index of first qset */
 	u8     rss_mode;
 	struct link_config link_cfg;
+	struct net_device_stats netstats;
 	u16   *rss;
 };
 
--- /dev/null
+++ b/drivers/net/cxgb4/cxgb4_compat.h
@@ -0,0 +1,249 @@
+/*
+ * This file is part of the Chelsio T4 Ethernet driver for Linux.
+ *
+ * Copyright (c) 2003-2010 Chelsio Communications, Inc. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __CXGB4_COMPAT_H__
+#define __CXGB4_COMPAT_H__
+
+#include <linux/ethtool.h>
+#include <linux/in6.h>
+#include <linux/ctype.h>
+#include <net/sch_generic.h>
+
+#define IPV4_FLOW       0x10
+#define IPV6_FLOW       0x11
+
+#define __devnet(nd)                            \
+        ((nd)                                   \
+         ? ((nd)->dev.parent            \
+            ?                           \
+            : 0)                                \
+         : 0)
+
+#ifndef netdev_printk
+#define netdev_printk(level, netdev, format, arg...)                    \
+        printk(level "%s %s %s: " format , (netdev)->name ,             \
+               (__devnet(netdev)                                        \
+                ? __devnet(netdev)->driver->name                        \
+                : "") ,                                                 \
+               (__devnet(netdev)                                        \
+                ? __devnet(netdev)->bus->name                           \
+                : "") , ## arg)
+#endif
+
+#ifndef netdev_info
+#define netdev_info(netdev, format, arg...)     \
+        netdev_printk(KERN_INFO , netdev , format , ## arg)
+#endif
+
+#ifndef netdev_uc_count
+#define netdev_uc_count(netdev)                 0
+#endif
+#ifndef netdev_for_each_uc_addr
+#define netdev_for_each_uc_addr(ha, dev)        if (0)
+#endif
+
+#define dev_addr_list   dev_mc_list
+#ifndef netdev_for_each_mc_addr
+#define netdev_for_each_mc_addr(d, dev)         \
+        for ((d) = (dev)->mc_list; (d); (d) = (d)->next)
+#endif
+
+#if 0 // defined in PCIe patches
+static inline u32 pci_pcie_cap(struct pci_dev *pci)
+{
+        return pci_find_capability(pci, PCI_CAP_ID_EXP);
+}
+#endif
+
+static inline char *skip_spaces(const char *str)
+{
+        while (isspace(*str))
+                ++str;
+        return (char *)str;
+}
+
+static inline char *strim(char *s)
+{
+        size_t size;
+        char *end;
+
+        s = skip_spaces(s);
+        size = strlen(s);
+        if (!size)
+                return s;
+
+        end = s + size - 1;
+        while (end >= s && isspace(*end))
+                end--;
+        *(end + 1) = '\0';
+
+        return s;
+}
+
+enum ethtool_flags_ext {
+        ETH_FLAG_RXHASH         = (1 << 28),
+};
+
+
+#define ethtool_op_set_flags compat_ethtool_op_set_flags
+
+static const u32 flags_dup_features =
+        (ETH_FLAG_LRO | ETH_FLAG_NTUPLE | ETH_FLAG_RXHASH);
+
+
+static inline int compat_ethtool_op_set_flags(struct net_device *dev, u32 data, u32 supported)
+{
+       if (data & ~supported)
+                 return -EINVAL;
+
+       dev->features = ((dev->features & ~flags_dup_features) |
+                         (data & flags_dup_features));
+       return 0;
+}
+
+#define PCI_VPD_INFO_FLD_HDR_SIZE       3
+
+#define PCI_VPD_LRDT                    0x80    /* Large Resource Data Type */
+#define PCI_VPD_LRDT_ID(x)              (x | PCI_VPD_LRDT)
+
+/* Large Resource Data Type Tag Item Names */
+#define PCI_VPD_LTIN_ID_STRING          0x02    /* Identifier String */
+#define PCI_VPD_LTIN_RO_DATA            0x10    /* Read-Only Data */
+#define PCI_VPD_LTIN_RW_DATA            0x11    /* Read-Write Data */
+
+#define PCI_VPD_LRDT_ID_STRING          PCI_VPD_LRDT_ID(PCI_VPD_LTIN_ID_STRING)
+#define PCI_VPD_LRDT_RO_DATA            PCI_VPD_LRDT_ID(PCI_VPD_LTIN_RO_DATA)
+#define PCI_VPD_LRDT_RW_DATA            PCI_VPD_LRDT_ID(PCI_VPD_LTIN_RW_DATA)
+
+/* Small Resource Data Type Tag Item Names */
+#define PCI_VPD_STIN_END                0x78    /* End */
+
+#define PCI_VPD_SRDT_END                PCI_VPD_STIN_END
+
+#define PCI_VPD_SRDT_TIN_MASK           0x78
+#define PCI_VPD_SRDT_LEN_MASK           0x07
+
+#define PCI_VPD_LRDT_TAG_SIZE           3
+#define PCI_VPD_SRDT_TAG_SIZE           1
+
+
+/**
+* pci_vpd_lrdt_size - Extracts the Large Resource Data Type length
+* @lrdt: Pointer to the beginning of the Large Resource Data Type tag
+*
+* Returns the extracted Large Resource Data Type length.
+*/
+static inline u16 pci_vpd_lrdt_size(const u8 *lrdt)
+{
+        return (u16)lrdt[1] + ((u16)lrdt[2] << 8);
+}
+
+/**
+ * pci_vpd_srdt_size - Extracts the Small Resource Data Type length
+ * @lrdt: Pointer to the beginning of the Small Resource Data Type tag
+ *
+ * Returns the extracted Small Resource Data Type length.
+ */
+static inline u8 pci_vpd_srdt_size(const u8 *srdt)
+{
+        return (*srdt) & PCI_VPD_SRDT_LEN_MASK;
+}
+
+
+
+static inline u8 pci_vpd_info_field_size(const u8 *info_field)
+{
+        return info_field[2];
+}
+
+static inline int pci_vpd_find_info_keyword(const u8 *buf, unsigned int off,
+                                        unsigned int len, const char *kw)
+{
+        int i;
+
+        for (i = off; i + PCI_VPD_INFO_FLD_HDR_SIZE <= off + len;) {
+                if (buf[i + 0] == kw[0] &&
+                    buf[i + 1] == kw[1])
+                        return i;
+
+                i += PCI_VPD_INFO_FLD_HDR_SIZE +
+                        pci_vpd_info_field_size(&buf[i]);
+        }
+
+        return -ENOENT;
+}
+
+static inline int pci_vpd_find_tag(const u8 *buf, unsigned int off, unsigned int len, u8 rdt)
+{
+        int i;
+
+        for (i = off; i < len; ) {
+                u8 val = buf[i];
+
+                if (val & PCI_VPD_LRDT) {
+                        /* Don't return success of the tag isn't complete */
+                        if (i + PCI_VPD_LRDT_TAG_SIZE > len)
+                                break;
+
+                        if (val == rdt)
+                                return i;
+
+                        i += PCI_VPD_LRDT_TAG_SIZE +
+                             pci_vpd_lrdt_size(&buf[i]);
+                } else {
+                        u8 tag = val & ~PCI_VPD_SRDT_LEN_MASK;
+
+                        if (tag == rdt)
+                                return i;
+
+                        if (tag == PCI_VPD_SRDT_END)
+                                break;
+
+                        i += PCI_VPD_SRDT_TAG_SIZE +
+                             pci_vpd_srdt_size(&buf[i]);
+                }
+        }
+
+        return -ENOENT;
+}
+
+#define NUMA_NO_NODE    (-1)
+
+static inline int netdev_queue_numa_node_read(const struct netdev_queue *q)
+{
+        return NUMA_NO_NODE;
+}
+
+
+#endif /* __CXGB4_COMPAT_H__ */
--- a/drivers/net/cxgb4/cxgb4_main.c
+++ b/drivers/net/cxgb4/cxgb4_main.c
@@ -330,9 +330,9 @@ static int set_addr_filters(const struct
 	u16 filt_idx[7];
 	const u8 *addr[7];
 	int ret, naddr = 0;
+	const struct dev_addr_list *d;
 	const struct netdev_hw_addr *ha;
 	int uc_cnt = netdev_uc_count(dev);
-	int mc_cnt = netdev_mc_count(dev);
 	const struct port_info *pi = netdev_priv(dev);
 	unsigned int mb = pi->adapter->fn;
 
@@ -351,23 +351,25 @@ static int set_addr_filters(const struct
 	}
 
 	/* next set up the multicast addresses */
-	netdev_for_each_mc_addr(ha, dev) {
-		addr[naddr++] = ha->addr;
-		if (--mc_cnt == 0 || naddr >= ARRAY_SIZE(addr)) {
-			ret = t4_alloc_mac_filt(pi->adapter, mb, pi->viid, free,
-					naddr, addr, filt_idx, &mhash, sleep);
-			if (ret < 0)
-				return ret;
+	netdev_for_each_mc_addr(d, dev) {
+                addr[naddr++] = d->dmi_addr;
+                if (naddr >= ARRAY_SIZE(addr) || d->next == NULL) {
+                        ret = t4_alloc_mac_filt(pi->adapter, mb, pi->viid, free,
+                                        naddr, addr, filt_idx, &mhash, sleep);
+                        if (ret < 0)
+                                return ret;
+
+                        free = false;
+                        naddr = 0;
+                }
+        }
 
-			free = false;
-			naddr = 0;
-		}
-	}
 
 	return t4_set_addr_hash(pi->adapter, mb, pi->viid, uhash != 0,
 				uhash | mhash, sleep);
 }
 
+
 /*
  * Set Rx properties of a port, such as promiscruity, address filters, and MTU.
  * If @mtu is -1 it is left unchanged.
@@ -1900,34 +1902,6 @@ static int set_flags(struct net_device *
 	return err;
 }
 
-static int get_rss_table(struct net_device *dev, struct ethtool_rxfh_indir *p)
-{
-	const struct port_info *pi = netdev_priv(dev);
-	unsigned int n = min_t(unsigned int, p->size, pi->rss_size);
-
-	p->size = pi->rss_size;
-	while (n--)
-		p->ring_index[n] = pi->rss[n];
-	return 0;
-}
-
-static int set_rss_table(struct net_device *dev,
-			 const struct ethtool_rxfh_indir *p)
-{
-	unsigned int i;
-	struct port_info *pi = netdev_priv(dev);
-
-	if (p->size != pi->rss_size)
-		return -EINVAL;
-	for (i = 0; i < p->size; i++)
-		if (p->ring_index[i] >= pi->nqsets)
-			return -EINVAL;
-	for (i = 0; i < p->size; i++)
-		pi->rss[i] = p->ring_index[i];
-	if (pi->adapter->flags & FULL_INIT_DONE)
-		return write_rss(pi, pi->rss);
-	return 0;
-}
 
 static int get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,
 		     void *rules)
@@ -2024,8 +1998,6 @@ static struct ethtool_ops cxgb_ethtool_o
 	.set_tso           = set_tso,
 	.set_flags         = set_flags,
 	.get_rxnfc         = get_rxnfc,
-	.get_rxfh_indir    = get_rss_table,
-	.set_rxfh_indir    = set_rss_table,
 	.flash_device      = set_flash,
 };
 
@@ -2734,46 +2706,46 @@ static int cxgb_close(struct net_device
 	return t4_enable_vi(adapter, adapter->fn, pi->viid, false, false);
 }
 
-static struct rtnl_link_stats64 *cxgb_get_stats(struct net_device *dev,
-						struct rtnl_link_stats64 *ns)
+static struct net_device_stats *cxgb_get_stats(struct net_device *dev)
 {
-	struct port_stats stats;
-	struct port_info *p = netdev_priv(dev);
-	struct adapter *adapter = p->adapter;
-
-	spin_lock(&adapter->stats_lock);
-	t4_get_port_stats(adapter, p->tx_chan, &stats);
-	spin_unlock(&adapter->stats_lock);
-
-	ns->tx_bytes   = stats.tx_octets;
-	ns->tx_packets = stats.tx_frames;
-	ns->rx_bytes   = stats.rx_octets;
-	ns->rx_packets = stats.rx_frames;
-	ns->multicast  = stats.rx_mcast_frames;
-
-	/* detailed rx_errors */
-	ns->rx_length_errors = stats.rx_jabber + stats.rx_too_long +
-			       stats.rx_runt;
-	ns->rx_over_errors   = 0;
-	ns->rx_crc_errors    = stats.rx_fcs_err;
-	ns->rx_frame_errors  = stats.rx_symbol_err;
-	ns->rx_fifo_errors   = stats.rx_ovflow0 + stats.rx_ovflow1 +
-			       stats.rx_ovflow2 + stats.rx_ovflow3 +
-			       stats.rx_trunc0 + stats.rx_trunc1 +
-			       stats.rx_trunc2 + stats.rx_trunc3;
-	ns->rx_missed_errors = 0;
-
-	/* detailed tx_errors */
-	ns->tx_aborted_errors   = 0;
-	ns->tx_carrier_errors   = 0;
-	ns->tx_fifo_errors      = 0;
-	ns->tx_heartbeat_errors = 0;
-	ns->tx_window_errors    = 0;
-
-	ns->tx_errors = stats.tx_error_frames;
-	ns->rx_errors = stats.rx_symbol_err + stats.rx_fcs_err +
-		ns->rx_length_errors + stats.rx_len_err + ns->rx_fifo_errors;
-	return ns;
+        struct port_stats stats;
+        struct port_info *p = netdev_priv(dev);
+        struct adapter *adapter = p->adapter;
+        struct net_device_stats *ns = &p->netstats;
+
+        spin_lock(&adapter->stats_lock);
+        t4_get_port_stats(adapter, p->tx_chan, &stats);
+        spin_unlock(&adapter->stats_lock);
+
+        ns->tx_bytes   = stats.tx_octets;
+        ns->tx_packets = stats.tx_frames;
+        ns->rx_bytes   = stats.rx_octets;
+        ns->rx_packets = stats.rx_frames;
+        ns->multicast  = stats.rx_mcast_frames;
+
+        /* detailed rx_errors */
+        ns->rx_length_errors = stats.rx_jabber + stats.rx_too_long +
+                               stats.rx_runt;
+        ns->rx_over_errors   = 0;
+        ns->rx_crc_errors    = stats.rx_fcs_err;
+        ns->rx_frame_errors  = stats.rx_symbol_err;
+        ns->rx_fifo_errors   = stats.rx_ovflow0 + stats.rx_ovflow1 +
+                               stats.rx_ovflow2 + stats.rx_ovflow3 +
+                               stats.rx_trunc0 + stats.rx_trunc1 +
+                               stats.rx_trunc2 + stats.rx_trunc3;
+        ns->rx_missed_errors = 0;
+
+        /* detailed tx_errors */
+        ns->tx_aborted_errors   = 0;
+        ns->tx_carrier_errors   = 0;
+        ns->tx_fifo_errors      = 0;
+        ns->tx_heartbeat_errors = 0;
+        ns->tx_window_errors    = 0;
+
+        ns->tx_errors = stats.tx_error_frames;
+        ns->rx_errors = stats.rx_symbol_err + stats.rx_fcs_err +
+                ns->rx_length_errors + stats.rx_len_err + ns->rx_fifo_errors;
+        return ns;
 }
 
 static int cxgb_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
@@ -2875,7 +2847,7 @@ static const struct net_device_ops cxgb4
 	.ndo_open             = cxgb_open,
 	.ndo_stop             = cxgb_close,
 	.ndo_start_xmit       = t4_eth_xmit,
-	.ndo_get_stats64      = cxgb_get_stats,
+	.ndo_get_stats        = cxgb_get_stats,
 	.ndo_set_rx_mode      = cxgb_set_rxmode,
 	.ndo_set_mac_address  = cxgb_set_mac_addr,
 	.ndo_validate_addr    = eth_validate_addr,
@@ -3668,7 +3640,7 @@ static int __devinit init_one(struct pci
 
 		netdev->features |= NETIF_F_SG | TSO_FLAGS;
 		netdev->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
-		netdev->features |= NETIF_F_GRO | NETIF_F_RXHASH | highdma;
+		netdev->features |= NETIF_F_GRO |  highdma;
 		netdev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
 		netdev->vlan_features = netdev->features & VLAN_FEAT;
 
@@ -3722,7 +3694,6 @@ static int __devinit init_one(struct pci
 	for_each_port(adapter, i) {
 		pi = adap2pinfo(adapter, i);
 		netif_set_real_num_tx_queues(adapter->port[i], pi->nqsets);
-		netif_set_real_num_rx_queues(adapter->port[i], pi->nqsets);
 
 		err = register_netdev(adapter->port[i]);
 		if (err)
--- a/drivers/net/cxgb4/sge.c
+++ b/drivers/net/cxgb4/sge.c
@@ -230,7 +230,6 @@ out_err:
 	return -ENOMEM;
 }
 
-#ifdef CONFIG_NEED_DMA_MAP_STATE
 static void unmap_skb(struct device *dev, const struct sk_buff *skb,
 		      const dma_addr_t *addr)
 {
@@ -257,7 +256,25 @@ static void deferred_unmap_destructor(st
 {
 	unmap_skb(skb->dev->dev.parent, skb, (dma_addr_t *)skb->head);
 }
-#endif
+
+/**
+ *	need_skb_unmap - does the platform need unmapping of sk_buffs?
+ *
+ *	Returns true if the platfrom needs sk_buff unmapping.  The compiler
+ *	optimizes away unecessary code if this returns true.
+ */
+static inline int need_skb_unmap(void)
+{
+	/*
+	 * This structure is used to tell if the platfrom needs buffer
+	 * unmapping by checking if DECLARE_PCI_UNMAP_ADDR defines anything.
+	 */
+	struct dummy {
+		DECLARE_PCI_UNMAP_ADDR(addr);
+	};
+
+	return sizeof(struct dummy) != 0;
+}
 
 static void unmap_sgl(struct device *dev, const struct sk_buff *skb,
 		      const struct ulptx_sgl *sgl, const struct sge_txq *q)
@@ -335,10 +352,12 @@ static void free_tx_desc(struct adapter
 	unsigned int cidx = q->cidx;
 	struct device *dev = adap->pdev_dev;
 
+	const int need_unmap = need_skb_unmap() && unmap;
+
 	d = &q->sdesc[cidx];
 	while (n--) {
 		if (d->skb) {                       /* an SGL is present */
-			if (unmap)
+			if (need_unmap)
 				unmap_sgl(dev, d->skb, d->sgl, q);
 			kfree_skb(d->skb);
 			d->skb = NULL;
@@ -1282,10 +1301,12 @@ static void service_ofldq(struct sge_ofl
 			write_sgl(skb, &q->q, (void *)pos + hdr_len,
 				  pos + flits, hdr_len,
 				  (dma_addr_t *)skb->head);
-#ifdef CONFIG_NEED_DMA_MAP_STATE
-			skb->dev = q->adap->port[0];
-			skb->destructor = deferred_unmap_destructor;
-#endif
+
+			if (need_skb_unmap()) {
+				skb->dev = q->adap->port[0];
+				skb->destructor = deferred_unmap_destructor;
+			}
+
 			last_desc = q->q.pidx + ndesc - 1;
 			if (last_desc >= q->q.size)
 				last_desc -= q->q.size;
@@ -1527,8 +1548,6 @@ static void do_gro(struct sge_eth_rxq *r
 	skb->truesize += skb->data_len;
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 	skb_record_rx_queue(skb, rxq->rspq.idx);
-	if (rxq->rspq.netdev->features & NETIF_F_RXHASH)
-		skb->rxhash = (__force u32)pkt->rsshdr.hash_val;
 
 	if (unlikely(pkt->vlan_ex)) {
 		__vlan_hwaccel_put_tag(skb, ntohs(pkt->vlan));
@@ -1581,8 +1600,6 @@ int t4_ethrx_handler(struct sge_rspq *q,
 	__skb_pull(skb, RX_PKT_PAD);      /* remove ethernet header padding */
 	skb->protocol = eth_type_trans(skb, q->netdev);
 	skb_record_rx_queue(skb, q->idx);
-	if (skb->dev->features & NETIF_F_RXHASH)
-		skb->rxhash = (__force u32)pkt->rsshdr.hash_val;
 
 	pi = netdev_priv(skb->dev);
 	rxq->stats.pkts++;
