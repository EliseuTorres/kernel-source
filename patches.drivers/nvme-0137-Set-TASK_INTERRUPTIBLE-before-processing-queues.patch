From: Arjan van de Ven <arjan@linux.intel.com>
Date: Wed, 1 May 2013 16:38:23 -0400
Subject: NVMe: Set TASK_INTERRUPTIBLE before processing queues
References: bnc#913030,FATE#317455
Patch-Mainline: v3.11
Git-commit: 564a232c059913d91b491e04c2b2d670b8f94615

The kthread has two tasks; handling timeouts (for which it runs once per
second), and submitting queued BIOs.  If a BIO happens to be queued after
the thread has processed the queue but before it calls schedule_timeout(),
the thread will sleep for a second before submitting it, which can cause
performance problems in some rare cases (that will become more common in
a subsequent patch).

Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
Tested-by: Keith Busch <keith.busch@intel.com>
Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/block/nvme-core.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/drivers/block/nvme-core.c b/drivers/block/nvme-core.c
index de8af20..fb4120f 100644
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@ -1297,7 +1297,7 @@ static int nvme_kthread(void *data)
 	struct nvme_dev *dev;
 
 	while (!kthread_should_stop()) {
-		__set_current_state(TASK_RUNNING);
+		set_current_state(TASK_INTERRUPTIBLE);
 		spin_lock(&dev_list_lock);
 		list_for_each_entry(dev, &dev_list, node) {
 			int i;
@@ -1314,7 +1314,6 @@ static int nvme_kthread(void *data)
 			}
 		}
 		spin_unlock(&dev_list_lock);
-		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(round_jiffies_relative(HZ));
 	}
 	return 0;
-- 
1.8.5.2

