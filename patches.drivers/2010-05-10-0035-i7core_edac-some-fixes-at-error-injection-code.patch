From: Mauro Carvalho Chehab <mchehab@redhat.com>
Subject: i7core_edac: some fixes at error injection code
References: fate#311968
Git-commit: 276b824c3095b09e8cb76f5709f56e9c6818ae85
Patch-mainline: v2.6.35-rc2


Signed-off-by: Thomas Renninger <trenn@suse.de>

Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

---
 drivers/edac/i7core_edac.c |  111 ++++++++++++++++++++-------------------------
 1 file changed, 50 insertions(+), 61 deletions(-)

Index: linux-2.6.32-SLE11-SP1/drivers/edac/i7core_edac.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/edac/i7core_edac.c
+++ linux-2.6.32-SLE11-SP1/drivers/edac/i7core_edac.c
@@ -33,18 +33,6 @@
 
 #include "edac_core.h"
 
-/* To use the new pci_[read/write]_config_qword instead of two dword */
-#define USE_QWORD 0
-
-/* trenn: Temporary function which gets removed with later patches.
-   Code may be broken for some patches, but at least compiles for bisecting */
-static inline int pci_write_config_qword(struct pci_dev *dev, int where,
-					 u64 val)
-{ return 0; }
-static inline int pci_read_config_qword(struct pci_dev *dev, int where,
-					u64 *val)
-{ return 0; }
-
 /*
  * Alter this version for the module when modifications are made
  */
@@ -656,7 +644,7 @@ static ssize_t i7core_inject_socket_stor
 	int rc;
 
 	rc = strict_strtoul(data, 10, &value);
-	if ((rc < 0) || (value > pvt->sockets))
+	if ((rc < 0) || (value >= pvt->sockets))
 		return 0;
 
 	pvt->inject.section = (u32) value;
@@ -813,7 +801,7 @@ static ssize_t i7core_inject_addrmatch_s
 			else
 				return cmd - data;
 		} else if (!strcasecmp(cmd, "dimm")) {
-			if (value < 4)
+			if (value < 3)
 				pvt->inject.dimm = value;
 			else
 				return cmd - data;
@@ -823,7 +811,7 @@ static ssize_t i7core_inject_addrmatch_s
 			else
 				return cmd - data;
 		} else if (!strcasecmp(cmd, "bank")) {
-			if (value < 4)
+			if (value < 32)
 				pvt->inject.bank = value;
 			else
 				return cmd - data;
@@ -880,6 +868,28 @@ static ssize_t i7core_inject_addrmatch_s
 		       channel, dimm, bank, rank, page, col);
 }
 
+static int write_and_test(struct pci_dev *dev, int where, u32 val)
+{
+	u32 read;
+	int count;
+
+	for (count = 0; count < 10; count++) {
+		if (count)
+			msleep (100);
+		pci_write_config_dword(dev, where, val);
+		pci_read_config_dword(dev, where, &read);
+
+		if (read == val)
+			return 0;
+	}
+
+	debugf0("Error Injection Register 0x%02x: Tried to write 0x%08x, "
+		"but read: 0x%08x\n", where, val, read);
+
+	return -EINVAL;
+}
+
+
 /*
  * This routine prepares the Memory Controller for error injection.
  * The error will be injected when some process tries to write to the
@@ -959,70 +969,49 @@ static ssize_t i7core_inject_enable_stor
 	else
 		mask |= (pvt->inject.col & 0x3fffL);
 
-	/* Unlock writes to registers */
+	/*
+	 * bit    0: REPEAT_EN
+	 * bits 1-2: MASK_HALF_CACHELINE
+	 * bit    3: INJECT_ECC
+	 * bit    4: INJECT_ADDR_PARITY
+	 */
+
+	injectmask = (pvt->inject.type & 1) |
+		     (pvt->inject.section & 0x3) << 1 |
+		     (pvt->inject.type & 0x6) << (3 - 1);
+
+	/* Unlock writes to registers - this register is write only */
 	pci_write_config_dword(pvt->pci_noncore[pvt->inject.socket],
 			       MC_CFG_CONTROL, 0x2);
-	msleep(100);
 
+#if 0
 	/* Zeroes error count registers */
 	pci_write_config_dword(pvt->pci_mcr[pvt->inject.socket][4],
 			       MC_TEST_ERR_RCV1, 0);
 	pci_write_config_dword(pvt->pci_mcr[pvt->inject.socket][4],
 			       MC_TEST_ERR_RCV0, 0);
 	pvt->ce_count_available[pvt->inject.socket] = 0;
+#endif
 
-
-#if USE_QWORD
-	pci_write_config_qword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, mask);
-#else
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ADDR_MATCH, mask);
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH + 4, mask >> 32L);
-#endif
-
-#if 1
-#if USE_QWORD
-	u64 rdmask;
-	pci_read_config_qword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ADDR_MATCH, &rdmask);
-	debugf0("Inject addr match write 0x%016llx, read: 0x%016llx\n",
-		mask, rdmask);
-#else
-	u32 rdmask1, rdmask2;
 
-	pci_read_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ADDR_MATCH, &rdmask1);
-	pci_read_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ADDR_MATCH + 4, &rdmask2);
-
-	debugf0("Inject addr match write 0x%016llx, read: 0x%08x 0x%08x\n",
-		mask, rdmask1, rdmask2);
-#endif
-#endif
-
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, pvt->inject.eccmask);
 
+	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+			       MC_CHANNEL_ERROR_MASK, injectmask);
+
 	/*
-	 * bit    0: REPEAT_EN
-	 * bits 1-2: MASK_HALF_CACHELINE
-	 * bit    3: INJECT_ECC
-	 * bit    4: INJECT_ADDR_PARITY
+	 * This is something undocumented, based on my tests
+	 * Without writing 8 to this register, errors aren't injected. Not sure
+	 * why.
 	 */
+	pci_write_config_dword(pvt->pci_noncore[pvt->inject.socket],
+			       MC_CFG_CONTROL, 8);
 
-	injectmask = (pvt->inject.type & 1) |
-		     (pvt->inject.section & 0x3) << 1 |
-		     (pvt->inject.type & 0x6) << (3 - 1);
-
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ERROR_MASK, injectmask);
-
-#if 0
-	/* lock writes to registers */
-	pci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, 0);
-#endif
 	debugf0("Error inject addr match 0x%016llx, ecc 0x%08x,"
 		" inject 0x%08x\n",
 		mask, pvt->inject.eccmask, injectmask);
