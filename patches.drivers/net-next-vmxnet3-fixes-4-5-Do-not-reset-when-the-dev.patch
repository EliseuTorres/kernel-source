From: Shreyas Bhatewara <sbhatewara@vmware.com>
Date: Mon, 19 Jul 2010 07:02:13 +0000
Subject: [PATCH] net-next: vmxnet3 fixes [4/5] Do not reset when the device is
 not opened
References: bnc#624020
Patch-mainline: 2.6.36-rc2
Git-commit: d9a5f210c5ef338295cf1c29d98825722351bed7

Hold rtnl_lock to get the right link state.

While asynchronously resetting the device, hold rtnl_lock to get the
right value from netif_running. If a reset is scheduled, and the device
goes thru close and open, it may happen that reset and open may run in
parallel. Holding rtnl_lock will avoid this.

Signed-off-by: Shreyas Bhatewara <sbhatewara@vmware.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Brandon Philips <bphilips@suse.de>

---
 drivers/net/vmxnet3/vmxnet3_drv.c |    2 ++
 1 file changed, 2 insertions(+)

Index: linux-2.6.32-SLE11-SP1/drivers/net/vmxnet3/vmxnet3_drv.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/net/vmxnet3/vmxnet3_drv.c
+++ linux-2.6.32-SLE11-SP1/drivers/net/vmxnet3/vmxnet3_drv.c
@@ -2218,6 +2218,7 @@ vmxnet3_reset_work(struct work_struct *d
 		return;
 
 	/* if the device is closed, we must leave it alone */
+	rtnl_lock();
 	if (netif_running(adapter->netdev)) {
 		printk(KERN_INFO "%s: resetting\n", adapter->netdev->name);
 		vmxnet3_quiesce_dev(adapter);
@@ -2226,6 +2227,7 @@ vmxnet3_reset_work(struct work_struct *d
 	} else {
 		printk(KERN_INFO "%s: already closed\n", adapter->netdev->name);
 	}
+	rtnl_unlock();
 
 	clear_bit(VMXNET3_STATE_BIT_RESETTING, &adapter->state);
 }
