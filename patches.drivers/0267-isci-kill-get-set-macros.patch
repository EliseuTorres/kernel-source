From: Dan Williams <dan.j.williams@intel.com>
Date: Fri, 1 Jul 2011 02:25:15 -0700
Subject: [PATCH 267/273] isci: kill 'get/set' macros
Git-commit: 34a991587a5cc9f78960c2c9beea217866458c41
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Most of these simple dereference macros are longer than their open coded
equivalent.  Deleting enum sci_controller_mode is thrown in for good
measure.

Reported-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/host.c                |    8 +-
 drivers/scsi/isci/host.h                |   20 +--
 drivers/scsi/isci/isci.h                |    5 -
 drivers/scsi/isci/phy.c                 |   33 ++--
 drivers/scsi/isci/phy.h                 |   17 --
 drivers/scsi/isci/port.c                |    4 +-
 drivers/scsi/isci/port.h                |   17 --
 drivers/scsi/isci/port_config.c         |   14 +-
 drivers/scsi/isci/remote_device.c       |   43 ++---
 drivers/scsi/isci/remote_device.h       |   97 ++--------
 drivers/scsi/isci/remote_node_context.c |    2 +-
 drivers/scsi/isci/remote_node_context.h |    3 -
 drivers/scsi/isci/request.c             |  328 ++++++++++++-------------------
 drivers/scsi/isci/request.h             |   73 -------
 drivers/scsi/isci/task.c                |    2 +-
 15 files changed, 188 insertions(+), 478 deletions(-)

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index f31f64e..88e7313 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -2627,7 +2627,7 @@ enum sci_status sci_controller_start_io(struct isci_host *ihost,
 		return status;
 
 	set_bit(IREQ_ACTIVE, &ireq->flags);
-	sci_controller_post_request(ihost, sci_request_get_post_context(ireq));
+	sci_controller_post_request(ihost, ireq->post_context);
 	return SCI_SUCCESS;
 }
 
@@ -2707,7 +2707,7 @@ enum sci_status sci_controller_continue_io(struct isci_request *ireq)
 	}
 
 	set_bit(IREQ_ACTIVE, &ireq->flags);
-	sci_controller_post_request(ihost, sci_request_get_post_context(ireq));
+	sci_controller_post_request(ihost, ireq->post_context);
 	return SCI_SUCCESS;
 }
 
@@ -2747,9 +2747,7 @@ enum sci_task_status sci_controller_start_task(struct isci_host *ihost,
 		return SCI_SUCCESS;
 	case SCI_SUCCESS:
 		set_bit(IREQ_ACTIVE, &ireq->flags);
-
-		sci_controller_post_request(ihost,
-			sci_request_get_post_context(ireq));
+		sci_controller_post_request(ihost, ireq->post_context);
 		break;
 	default:
 		break;
diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index d87f21d..a72d2be 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -172,6 +172,7 @@ struct isci_host {
 	/* XXX kill */
 	bool phy_startup_timer_pending;
 	u32 next_phy_to_start;
+	/* XXX convert to unsigned long and use bitops */
 	u8 invalid_phy_mask;
 
 	/* TODO attempt dynamic interrupt coalescing scheme */
@@ -359,13 +360,8 @@ static inline struct isci_host *dev_to_ihost(struct domain_device *dev)
 	return dev->port->ha->lldd_ha;
 }
 
-/**
- * sci_controller_get_protocol_engine_group() -
- *
- * This macro returns the protocol engine group for this controller object.
- * Presently we only support protocol engine group 0 so just return that
- */
-#define sci_controller_get_protocol_engine_group(controller) 0
+/* we always use protocol engine group zero */
+#define ISCI_PEG 0
 
 /* see sci_controller_io_tag_allocate|free for how seq and tci are built */
 #define ISCI_TAG(seq, tci) (((u16) (seq)) << 12 | tci)
@@ -386,16 +382,6 @@ static inline int sci_remote_device_node_count(struct isci_remote_device *idev)
 }
 
 /**
- * sci_controller_set_invalid_phy() -
- *
- * This macro will set the bit in the invalid phy mask for this controller
- * object.  This is used to control messages reported for invalid link up
- * notifications.
- */
-#define sci_controller_set_invalid_phy(controller, phy) \
-	((controller)->invalid_phy_mask |= (1 << (phy)->phy_index))
-
-/**
  * sci_controller_clear_invalid_phy() -
  *
  * This macro will clear the bit in the invalid phy mask for this controller
diff --git a/drivers/scsi/isci/isci.h b/drivers/scsi/isci/isci.h
index 3afccfc..d1de633 100644
--- a/drivers/scsi/isci/isci.h
+++ b/drivers/scsi/isci/isci.h
@@ -73,11 +73,6 @@
 
 #define SCI_CONTROLLER_INVALID_IO_TAG 0xFFFF
 
-enum sci_controller_mode {
-	SCI_MODE_SPEED,
-	SCI_MODE_SIZE /* deprecated */
-};
-
 #define SCI_MAX_PHYS  (4UL)
 #define SCI_MAX_PORTS SCI_MAX_PHYS
 #define SCI_MAX_SMP_PHYS  (384) /* not silicon constrained */
diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 0df9f71..e56080a 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -265,10 +265,11 @@ done:
  * port (i.e. it's contained in the dummy port). !NULL All other
  * values indicate a handle/pointer to the port containing the phy.
  */
-struct isci_port *phy_get_non_dummy_port(
-	struct isci_phy *iphy)
+struct isci_port *phy_get_non_dummy_port(struct isci_phy *iphy)
 {
-	if (sci_port_get_index(iphy->owning_port) == SCIC_SDS_DUMMY_PORT)
+	struct isci_port *iport = iphy->owning_port;
+
+	if (iport->physical_port_index == SCIC_SDS_DUMMY_PORT)
 		return NULL;
 
 	return iphy->owning_port;
@@ -858,10 +859,9 @@ enum sci_status sci_phy_frame_handler(struct isci_phy *iphy, u32 frame_index)
 		struct dev_to_host_fis *frame_header;
 		u32 *fis_frame_data;
 
-		result = sci_unsolicited_frame_control_get_header(
-			&(sci_phy_get_controller(iphy)->uf_control),
-			frame_index,
-			(void **)&frame_header);
+		result = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
+								  frame_index,
+								  (void **)&frame_header);
 
 		if (result != SCI_SUCCESS)
 			return result;
@@ -1090,6 +1090,8 @@ static void scu_link_layer_tx_hard_reset(
 static void sci_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct isci_port *iport = iphy->owning_port;
+	struct isci_host *ihost = iport->owning_controller;
 
 	/*
 	 * @todo We need to get to the controller to place this PE in a
@@ -1100,14 +1102,14 @@ static void sci_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 	scu_link_layer_stop_protocol_engine(iphy);
 
 	if (iphy->sm.previous_state_id != SCI_PHY_INITIAL)
-		sci_controller_link_down(sci_phy_get_controller(iphy),
-					      phy_get_non_dummy_port(iphy),
-					      iphy);
+		sci_controller_link_down(ihost, phy_get_non_dummy_port(iphy), iphy);
 }
 
 static void sci_phy_starting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct isci_port *iport = iphy->owning_port;
+	struct isci_host *ihost = iport->owning_controller;
 
 	scu_link_layer_stop_protocol_engine(iphy);
 	scu_link_layer_start_oob(iphy);
@@ -1117,9 +1119,7 @@ static void sci_phy_starting_state_enter(struct sci_base_state_machine *sm)
 	iphy->bcn_received_while_port_unassigned = false;
 
 	if (iphy->sm.previous_state_id == SCI_PHY_READY)
-		sci_controller_link_down(sci_phy_get_controller(iphy),
-					      phy_get_non_dummy_port(iphy),
-					      iphy);
+		sci_controller_link_down(ihost, phy_get_non_dummy_port(iphy), iphy);
 
 	sci_change_state(&iphy->sm, SCI_PHY_SUB_INITIAL);
 }
@@ -1127,11 +1127,10 @@ static void sci_phy_starting_state_enter(struct sci_base_state_machine *sm)
 static void sci_phy_ready_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct isci_port *iport = iphy->owning_port;
+	struct isci_host *ihost = iport->owning_controller;
 
-	sci_controller_link_up(sci_phy_get_controller(iphy),
-				    phy_get_non_dummy_port(iphy),
-				    iphy);
-
+	sci_controller_link_up(ihost, phy_get_non_dummy_port(iphy), iphy);
 }
 
 static void sci_phy_ready_state_exit(struct sci_base_state_machine *sm)
diff --git a/drivers/scsi/isci/phy.h b/drivers/scsi/isci/phy.h
index 5d2c1b4..67699c8 100644
--- a/drivers/scsi/isci/phy.h
+++ b/drivers/scsi/isci/phy.h
@@ -440,23 +440,6 @@ enum sci_phy_states {
 	SCI_PHY_FINAL,
 };
 
-/**
- * sci_phy_get_index() -
- *
- * This macro returns the phy index for the specified phy
- */
-#define sci_phy_get_index(phy) \
-	((phy)->phy_index)
-
-/**
- * sci_phy_get_controller() - This macro returns the controller for this
- *    phy
- *
- *
- */
-#define sci_phy_get_controller(phy) \
-	(sci_port_get_controller((phy)->owning_port))
-
 void sci_phy_construct(
 	struct isci_phy *iphy,
 	struct isci_port *iport,
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 1822ed6..8f6f9b7 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -654,7 +654,7 @@ static void sci_port_activate_phy(struct isci_port *iport, struct isci_phy *iphy
 void sci_port_deactivate_phy(struct isci_port *iport, struct isci_phy *iphy,
 			     bool do_notify_user)
 {
-	struct isci_host *ihost = sci_port_get_controller(iport);
+	struct isci_host *ihost = iport->owning_controller;
 
 	iport->active_phy_mask &= ~(1 << iphy->phy_index);
 
@@ -678,7 +678,7 @@ static void sci_port_invalid_link_up(struct isci_port *iport, struct isci_phy *i
 	 * invalid link.
 	 */
 	if ((ihost->invalid_phy_mask & (1 << iphy->phy_index)) == 0) {
-		sci_controller_set_invalid_phy(ihost, iphy);
+		ihost->invalid_phy_mask |= 1 << iphy->phy_index;
 		dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
 	}
 }
diff --git a/drivers/scsi/isci/port.h b/drivers/scsi/isci/port.h
index 4c4ab81..b50ecd4 100644
--- a/drivers/scsi/isci/port.h
+++ b/drivers/scsi/isci/port.h
@@ -210,23 +210,6 @@ enum sci_port_states {
 
 };
 
-/**
- * sci_port_get_controller() -
- *
- * Helper macro to get the owning controller of this port
- */
-#define sci_port_get_controller(this_port)	\
-	((this_port)->owning_controller)
-
-/**
- * sci_port_get_index() -
- *
- * This macro returns the physical port index for this port object
- */
-#define sci_port_get_index(this_port) \
-	((this_port)->physical_port_index)
-
-
 static inline void sci_port_decrement_request_count(struct isci_port *iport)
 {
 	if (WARN_ONCE(iport->started_request_count == 0,
diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index c8b16db..486b113 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -367,10 +367,10 @@ static void sci_mpc_agent_link_up(struct isci_host *ihost,
 	if (!iport)
 		return;
 
-	port_agent->phy_ready_mask |= (1 << sci_phy_get_index(iphy));
+	port_agent->phy_ready_mask |= (1 << iphy->phy_index);
 	sci_port_link_up(iport, iphy);
-	if ((iport->active_phy_mask & (1 << sci_phy_get_index(iphy))))
-		port_agent->phy_configured_mask |= (1 << sci_phy_get_index(iphy));
+	if ((iport->active_phy_mask & (1 << iphy->phy_index)))
+		port_agent->phy_configured_mask |= (1 << iphy->phy_index);
 }
 
 /**
@@ -404,10 +404,8 @@ static void sci_mpc_agent_link_down(
 		 * rebuilding the port with the phys that remain in the ready
 		 * state.
 		 */
-		port_agent->phy_ready_mask &=
-			~(1 << sci_phy_get_index(iphy));
-		port_agent->phy_configured_mask &=
-			~(1 << sci_phy_get_index(iphy));
+		port_agent->phy_ready_mask &= ~(1 << iphy->phy_index);
+		port_agent->phy_configured_mask &= ~(1 << iphy->phy_index);
 
 		/*
 		 * Check to see if there are more phys waiting to be
@@ -643,7 +641,7 @@ static void sci_apc_agent_link_down(
 	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
-	port_agent->phy_ready_mask &= ~(1 << sci_phy_get_index(iphy));
+	port_agent->phy_ready_mask &= ~(1 << iphy->phy_index);
 
 	if (!iport)
 		return;
diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 8c752ab..85e54f5 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -456,7 +456,7 @@ static void sci_remote_device_start_request(struct isci_remote_device *idev,
 		sci_port_complete_io(iport, idev, ireq);
 	else {
 		kref_get(&idev->kref);
-		sci_remote_device_increment_request_count(idev);
+		idev->started_request_count++;
 	}
 }
 
@@ -636,7 +636,7 @@ enum sci_status sci_remote_device_complete_io(struct isci_host *ihost,
 			 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE".
 			 */
 			sci_change_state(sm, SCI_STP_DEV_AWAIT_RESET);
-		} else if (sci_remote_device_get_request_count(idev) == 0)
+		} else if (idev->started_request_count == 0)
 			sci_change_state(sm, SCI_STP_DEV_IDLE);
 		break;
 	case SCI_SMP_DEV_CMD:
@@ -650,10 +650,10 @@ enum sci_status sci_remote_device_complete_io(struct isci_host *ihost,
 		if (status != SCI_SUCCESS)
 			break;
 
-		if (sci_remote_device_get_request_count(idev) == 0)
+		if (idev->started_request_count == 0)
 			sci_remote_node_context_destruct(&idev->rnc,
-							      rnc_destruct_done,
-							      idev);
+							 rnc_destruct_done,
+							 idev);
 		break;
 	}
 
@@ -761,26 +761,17 @@ enum sci_status sci_remote_device_start_task(struct isci_host *ihost,
 	return status;
 }
 
-/**
- *
- * @sci_dev:
- * @request:
- *
- * This method takes the request and bulids an appropriate SCU context for the
- * request and then requests the controller to post the request. none
- */
-void sci_remote_device_post_request(
-	struct isci_remote_device *idev,
-	u32 request)
+void sci_remote_device_post_request(struct isci_remote_device *idev, u32 request)
 {
+	struct isci_port *iport = idev->owning_port;
 	u32 context;
 
-	context = sci_remote_device_build_command_context(idev, request);
+	context = request |
+		  (ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
+		  (iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
+		  idev->rnc.remote_node_index;
 
-	sci_controller_post_request(
-		sci_remote_device_get_controller(idev),
-		context
-		);
+	sci_controller_post_request(iport->owning_controller, context);
 }
 
 /* called once the remote node context has transisitioned to a
@@ -893,7 +884,7 @@ static void sci_remote_device_stopped_state_enter(struct sci_base_state_machine
 static void sci_remote_device_starting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = sci_remote_device_get_controller(idev);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	isci_remote_device_not_ready(ihost, idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
@@ -961,7 +952,7 @@ static void sci_stp_remote_device_ready_idle_substate_enter(struct sci_base_stat
 static void sci_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = sci_remote_device_get_controller(idev);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	BUG_ON(idev->working_request == NULL);
 
@@ -972,7 +963,7 @@ static void sci_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state
 static void sci_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = sci_remote_device_get_controller(idev);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	if (idev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
 		isci_remote_device_not_ready(ihost, idev,
@@ -982,7 +973,7 @@ static void sci_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base
 static void sci_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = sci_remote_device_get_controller(idev);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	isci_remote_device_ready(ihost, idev);
 }
@@ -990,7 +981,7 @@ static void sci_smp_remote_device_ready_idle_substate_enter(struct sci_base_stat
 static void sci_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = sci_remote_device_get_controller(idev);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	BUG_ON(idev->working_request == NULL);
 
diff --git a/drivers/scsi/isci/remote_device.h b/drivers/scsi/isci/remote_device.h
index fa9a0e6..57ccfc3 100644
--- a/drivers/scsi/isci/remote_device.h
+++ b/drivers/scsi/isci/remote_device.h
@@ -305,91 +305,18 @@ static inline bool dev_is_expander(struct domain_device *dev)
 	return dev->dev_type == EDGE_DEV || dev->dev_type == FANOUT_DEV;
 }
 
-/**
- * sci_remote_device_increment_request_count() -
- *
- * This macro incrments the request count for this device
- */
-#define sci_remote_device_increment_request_count(idev) \
-	((idev)->started_request_count++)
-
-/**
- * sci_remote_device_decrement_request_count() -
- *
- * This macro decrements the request count for this device.  This count will
- * never decrment past 0.
- */
-#define sci_remote_device_decrement_request_count(idev) \
-	((idev)->started_request_count > 0 ? \
-	 (idev)->started_request_count-- : 0)
-
-/**
- * sci_remote_device_get_request_count() -
- *
- * This is a helper macro to return the current device request count.
- */
-#define sci_remote_device_get_request_count(idev) \
-	((idev)->started_request_count)
-
-/**
- * sci_remote_device_get_controller() -
- *
- * This macro returns the controller object that contains this device object
- */
-#define sci_remote_device_get_controller(idev) \
-	sci_port_get_controller(sci_remote_device_get_port(idev))
-
-/**
- * sci_remote_device_get_port() -
- *
- * This macro returns the owning port of this device
- */
-#define sci_remote_device_get_port(idev) \
-	((idev)->owning_port)
-
-/**
- * sci_remote_device_get_controller_peg() -
- *
- * This macro returns the controllers protocol engine group
- */
-#define sci_remote_device_get_controller_peg(idev) \
-	(\
-		sci_controller_get_protocol_engine_group(\
-			sci_port_get_controller(\
-				sci_remote_device_get_port(idev) \
-				) \
-			) \
-	)
-
-/**
- * sci_remote_device_get_index() -
- *
- * This macro returns the remote node index for this device object
- */
-#define sci_remote_device_get_index(idev) \
-	((idev)->rnc.remote_node_index)
-
-/**
- * sci_remote_device_build_command_context() -
- *
- * This macro builds a remote device context for the SCU post request operation
- */
-#define sci_remote_device_build_command_context(device, command) \
-	((command) \
-	 | (sci_remote_device_get_controller_peg((device)) << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) \
-	 | ((device)->owning_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) \
-	 | (sci_remote_device_get_index((device)))	\
-	)
-
-/**
- * sci_remote_device_set_working_request() -
- *
- * This macro makes the working request assingment for the remote device
- * object. To clear the working request use this macro with a NULL request
- * object.
- */
-#define sci_remote_device_set_working_request(device, request) \
-	((device)->working_request = (request))
+static inline void sci_remote_device_decrement_request_count(struct isci_remote_device *idev)
+{
+	/* XXX delete this voodoo when converting to the top-level device
+	 * reference count
+	 */
+	if (WARN_ONCE(idev->started_request_count == 0,
+		      "%s: tried to decrement started_request_count past 0!?",
+			__func__))
+		/* pass */;
+	else
+		idev->started_request_count--;
+}
 
 enum sci_status sci_remote_device_frame_handler(
 	struct isci_remote_device *idev,
diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index c2dfd5a..748e833 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -111,7 +111,7 @@ static void sci_remote_node_context_construct_buffer(struct sci_remote_node_cont
 	struct isci_host *ihost;
 	__le64 sas_addr;
 
-	ihost = sci_remote_device_get_controller(idev);
+	ihost = idev->owning_port->owning_controller;
 	rnc = sci_rnc_by_id(ihost, rni);
 
 	memset(rnc, 0, sizeof(union scu_remote_node_context)
diff --git a/drivers/scsi/isci/remote_node_context.h b/drivers/scsi/isci/remote_node_context.h
index b475c5c..41580ad 100644
--- a/drivers/scsi/isci/remote_node_context.h
+++ b/drivers/scsi/isci/remote_node_context.h
@@ -204,9 +204,6 @@ void sci_remote_node_context_construct(struct sci_remote_node_context *rnc,
 bool sci_remote_node_context_is_ready(
 	struct sci_remote_node_context *sci_rnc);
 
-#define sci_remote_node_context_get_remote_node_index(rcn)	\
-	((rnc)->remote_node_index)
-
 enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_context *sci_rnc,
 							   u32 event_code);
 enum sci_status sci_remote_node_context_destruct(struct sci_remote_node_context *sci_rnc,
diff --git a/drivers/scsi/isci/request.c b/drivers/scsi/isci/request.c
index bcb3c08..7c500bb 100644
--- a/drivers/scsi/isci/request.c
+++ b/drivers/scsi/isci/request.c
@@ -211,22 +211,21 @@ static void scu_ssp_reqeust_construct_task_context(
 	struct isci_remote_device *idev;
 	struct isci_port *iport;
 
-	idev = sci_request_get_device(ireq);
-	iport = sci_request_get_port(ireq);
+	idev = ireq->target_device;
+	iport = idev->owning_port;
 
 	/* Fill in the TC with the its required data */
 	task_context->abort = 0;
 	task_context->priority = 0;
 	task_context->initiator_request = 1;
 	task_context->connection_rate = idev->connection_rate;
-	task_context->protocol_engine_index =
-		sci_controller_get_protocol_engine_group(controller);
-	task_context->logical_port_index = sci_port_get_index(iport);
+	task_context->protocol_engine_index = ISCI_PEG;
+	task_context->logical_port_index = iport->physical_port_index;
 	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
 
-	task_context->remote_node_index = sci_remote_device_get_index(idev);
+	task_context->remote_node_index = idev->rnc.remote_node_index;
 	task_context->command_code = 0;
 
 	task_context->link_layer_control = 0;
@@ -242,9 +241,8 @@ static void scu_ssp_reqeust_construct_task_context(
 	task_context->task_phase = 0x01;
 
 	ireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
-			      (sci_controller_get_protocol_engine_group(controller) <<
-			       SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
-			      (sci_port_get_index(iport) <<
+			      (ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
+			      (iport->physical_port_index <<
 			       SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
 			      ISCI_TAG_TCI(ireq->io_tag));
 
@@ -349,23 +347,21 @@ static void scu_sata_reqeust_construct_task_context(
 	struct isci_remote_device *idev;
 	struct isci_port *iport;
 
-	idev = sci_request_get_device(ireq);
-	iport = sci_request_get_port(ireq);
+	idev = ireq->target_device;
+	iport = idev->owning_port;
 
 	/* Fill in the TC with the its required data */
 	task_context->abort = 0;
 	task_context->priority = SCU_TASK_PRIORITY_NORMAL;
 	task_context->initiator_request = 1;
 	task_context->connection_rate = idev->connection_rate;
-	task_context->protocol_engine_index =
-		sci_controller_get_protocol_engine_group(controller);
-	task_context->logical_port_index =
-		sci_port_get_index(iport);
+	task_context->protocol_engine_index = ISCI_PEG;
+	task_context->logical_port_index = iport->physical_port_index;
 	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_STP;
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
 
-	task_context->remote_node_index = sci_remote_device_get_index(idev);
+	task_context->remote_node_index = idev->rnc.remote_node_index;
 	task_context->command_code = 0;
 
 	task_context->link_layer_control = 0;
@@ -385,11 +381,10 @@ static void scu_sata_reqeust_construct_task_context(
 	task_context->type.words[0] = *(u32 *)&ireq->stp.cmd;
 
 	ireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
-				 (sci_controller_get_protocol_engine_group(controller) <<
-				  SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
-				 (sci_port_get_index(iport) <<
-				  SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
-				 ISCI_TAG_TCI(ireq->io_tag));
+			      (ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
+			      (iport->physical_port_index <<
+			       SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
+			      ISCI_TAG_TCI(ireq->io_tag));
 	/*
 	 * Copy the physical address for the command buffer to the SCU Task
 	 * Context. We must offset the command buffer by 4 bytes because the
@@ -716,10 +711,8 @@ sci_io_request_terminate(struct isci_request *ireq)
 
 	switch (state) {
 	case SCI_REQ_CONSTRUCTED:
-		sci_request_set_status(ireq,
-			SCU_TASK_DONE_TASK_ABORT,
-			SCI_FAILURE_IO_TERMINATED);
-
+		ireq->scu_status = SCU_TASK_DONE_TASK_ABORT;
+		ireq->sci_status = SCI_FAILURE_IO_TERMINATED;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		return SCI_SUCCESS;
 	case SCI_REQ_STARTED:
@@ -848,9 +841,8 @@ request_started_state_tc_event(struct isci_request *ireq,
 	 */
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
-		sci_request_set_status(ireq,
-					    SCU_TASK_DONE_GOOD,
-					    SCI_SUCCESS);
+		ireq->scu_status = SCU_TASK_DONE_GOOD;
+		ireq->sci_status = SCI_SUCCESS;
 		break;
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_EARLY_RESP): {
 		/* There are times when the SCU hardware will return an early
@@ -868,13 +860,11 @@ request_started_state_tc_event(struct isci_request *ireq,
 			       word_cnt);
 
 		if (resp->status == 0) {
-			sci_request_set_status(ireq,
-						    SCU_TASK_DONE_GOOD,
-						    SCI_SUCCESS_IO_DONE_EARLY);
+			ireq->scu_status = SCU_TASK_DONE_GOOD;
+			ireq->sci_status = SCI_SUCCESS_IO_DONE_EARLY;
 		} else {
-			sci_request_set_status(ireq,
-						    SCU_TASK_DONE_CHECK_RESPONSE,
-						    SCI_FAILURE_IO_RESPONSE_VALID);
+			ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
+			ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
 		}
 		break;
 	}
@@ -885,9 +875,8 @@ request_started_state_tc_event(struct isci_request *ireq,
 			       &ireq->ssp.rsp,
 			       word_cnt);
 
-		sci_request_set_status(ireq,
-					    SCU_TASK_DONE_CHECK_RESPONSE,
-					    SCI_FAILURE_IO_RESPONSE_VALID);
+		ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
+		ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
 		break;
 	}
 
@@ -900,13 +889,12 @@ request_started_state_tc_event(struct isci_request *ireq,
 		datapres = resp_iu->datapres;
 
 		if (datapres == 1 || datapres == 2) {
-			sci_request_set_status(ireq,
-						    SCU_TASK_DONE_CHECK_RESPONSE,
-						    SCI_FAILURE_IO_RESPONSE_VALID);
-		} else
-			sci_request_set_status(ireq,
-						    SCU_TASK_DONE_GOOD,
-						    SCI_SUCCESS);
+			ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
+			ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
+		} else {
+			ireq->scu_status = SCU_TASK_DONE_GOOD;
+			ireq->sci_status = SCI_SUCCESS;
+		}
 		break;
 	/* only stp device gets suspended. */
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_ACK_NAK_TO):
@@ -921,15 +909,13 @@ request_started_state_tc_event(struct isci_request *ireq,
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_REG_ERR):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SDB_ERR):
 		if (ireq->protocol == SCIC_STP_PROTOCOL) {
-			sci_request_set_status(ireq,
-				SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
-				SCU_COMPLETION_TL_STATUS_SHIFT,
-				SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED);
+			ireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
+					   SCU_COMPLETION_TL_STATUS_SHIFT;
+			ireq->sci_status = SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 		} else {
-			sci_request_set_status(ireq,
-				SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
-				SCU_COMPLETION_TL_STATUS_SHIFT,
-				SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
+			ireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
+					   SCU_COMPLETION_TL_STATUS_SHIFT;
+			ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 		}
 		break;
 
@@ -944,10 +930,9 @@ request_started_state_tc_event(struct isci_request *ireq,
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_STP_RESOURCES_BUSY):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED):
-		sci_request_set_status(ireq,
-					    SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
-					    SCU_COMPLETION_TL_STATUS_SHIFT,
-					    SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED);
+		ireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
+				   SCU_COMPLETION_TL_STATUS_SHIFT;
+		ireq->sci_status = SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 		break;
 
 	/* neither ssp nor stp gets suspended. */
@@ -967,11 +952,9 @@ request_started_state_tc_event(struct isci_request *ireq,
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_IIT_ENTRY_NV):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_RNCNV_OUTBOUND):
 	default:
-		sci_request_set_status(
-			ireq,
-			SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
-			SCU_COMPLETION_TL_STATUS_SHIFT,
-			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
+		ireq->scu_status = SCU_GET_COMPLETION_TL_STATUS(completion_code) >>
+				   SCU_COMPLETION_TL_STATUS_SHIFT;
+		ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 		break;
 	}
 
@@ -991,9 +974,8 @@ request_aborting_state_tc_event(struct isci_request *ireq,
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case (SCU_TASK_DONE_GOOD << SCU_COMPLETION_TL_STATUS_SHIFT):
 	case (SCU_TASK_DONE_TASK_ABORT << SCU_COMPLETION_TL_STATUS_SHIFT):
-		sci_request_set_status(ireq, SCU_TASK_DONE_TASK_ABORT,
-					    SCI_FAILURE_IO_TERMINATED);
-
+		ireq->scu_status = SCU_TASK_DONE_TASK_ABORT;
+		ireq->sci_status = SCI_FAILURE_IO_TERMINATED;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 
@@ -1012,9 +994,8 @@ static enum sci_status ssp_task_request_await_tc_event(struct isci_request *ireq
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
-		sci_request_set_status(ireq, SCU_TASK_DONE_GOOD,
-					    SCI_SUCCESS);
-
+		ireq->scu_status = SCU_TASK_DONE_GOOD;
+		ireq->sci_status = SCI_SUCCESS;
 		sci_change_state(&ireq->sm, SCI_REQ_TASK_WAIT_TC_RESP);
 		break;
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_ACK_NAK_TO):
@@ -1036,10 +1017,8 @@ static enum sci_status ssp_task_request_await_tc_event(struct isci_request *ireq
 		 * If a NAK was received, then it is up to the user to retry
 		 * the request.
 		 */
-		sci_request_set_status(ireq,
-			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
-			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
-
+		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
+		ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	}
@@ -1057,12 +1036,10 @@ smp_request_await_response_tc_event(struct isci_request *ireq,
 		 * unexpected.  but if the TC has success status, we
 		 * complete the IO anyway.
 		 */
-		sci_request_set_status(ireq, SCU_TASK_DONE_GOOD,
-					    SCI_SUCCESS);
-
+		ireq->scu_status = SCU_TASK_DONE_GOOD;
+		ireq->sci_status = SCI_SUCCESS;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
-
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_RESP_TO_ERR):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_UFI_ERR):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SMP_FRM_TYPE_ERR):
@@ -1074,20 +1051,16 @@ smp_request_await_response_tc_event(struct isci_request *ireq,
 		 * these SMP_XXX_XX_ERR status. For these type of error,
 		 * we ask ihost user to retry the request.
 		 */
-		sci_request_set_status(ireq, SCU_TASK_DONE_SMP_RESP_TO_ERR,
-					    SCI_FAILURE_RETRY_REQUIRED);
-
+		ireq->scu_status = SCU_TASK_DONE_SMP_RESP_TO_ERR;
+		ireq->sci_status = SCI_FAILURE_RETRY_REQUIRED;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
-
 	default:
 		/* All other completion status cause the IO to be complete.  If a NAK
 		 * was received, then it is up to the user to retry the request
 		 */
-		sci_request_set_status(ireq,
-					    SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
-					    SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
-
+		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
+		ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	}
@@ -1101,9 +1074,8 @@ smp_request_await_tc_event(struct isci_request *ireq,
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
-		sci_request_set_status(ireq, SCU_TASK_DONE_GOOD,
-					    SCI_SUCCESS);
-
+		ireq->scu_status = SCU_TASK_DONE_GOOD;
+		ireq->sci_status = SCI_SUCCESS;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	default:
@@ -1111,10 +1083,8 @@ smp_request_await_tc_event(struct isci_request *ireq,
 		 * complete.  If a NAK was received, then it is up to
 		 * the user to retry the request.
 		 */
-		sci_request_set_status(ireq,
-					    SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
-					    SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
-
+		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
+		ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	}
@@ -1171,9 +1141,8 @@ stp_request_non_data_await_h2d_tc_event(struct isci_request *ireq,
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
-		sci_request_set_status(ireq, SCU_TASK_DONE_GOOD,
-					    SCI_SUCCESS);
-
+		ireq->scu_status = SCU_TASK_DONE_GOOD;
+		ireq->sci_status = SCI_SUCCESS;
 		sci_change_state(&ireq->sm, SCI_REQ_STP_NON_DATA_WAIT_D2H);
 		break;
 
@@ -1182,10 +1151,8 @@ stp_request_non_data_await_h2d_tc_event(struct isci_request *ireq,
 		 * complete.  If a NAK was received, then it is up to
 		 * the user to retry the request.
 		 */
-		sci_request_set_status(ireq,
-					    SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
-					    SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
-
+		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
+		ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	}
@@ -1363,10 +1330,8 @@ stp_request_pio_await_h2d_completion_tc_event(struct isci_request *ireq,
 
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
-		sci_request_set_status(ireq,
-					    SCU_TASK_DONE_GOOD,
-					    SCI_SUCCESS);
-
+		ireq->scu_status = SCU_TASK_DONE_GOOD;
+		ireq->sci_status = SCI_SUCCESS;
 		sci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);
 		break;
 
@@ -1375,10 +1340,8 @@ stp_request_pio_await_h2d_completion_tc_event(struct isci_request *ireq,
 		 * complete.  If a NAK was received, then it is up to
 		 * the user to retry the request.
 		 */
-		sci_request_set_status(ireq,
-					    SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
-					    SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
-
+		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
+		ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	}
@@ -1426,11 +1389,8 @@ pio_data_out_tx_done_tc_event(struct isci_request *ireq,
 		 * If a NAK was received, then it is up to the user to retry
 		 * the request.
 		 */
-		sci_request_set_status(
-			ireq,
-			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
-			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
-
+		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
+		ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	}
@@ -1438,15 +1398,6 @@ pio_data_out_tx_done_tc_event(struct isci_request *ireq,
 	return status;
 }
 
-static void sci_stp_request_udma_complete_request(
-	struct isci_request *ireq,
-	u32 scu_status,
-	enum sci_status sci_status)
-{
-	sci_request_set_status(ireq, scu_status, sci_status);
-	sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
-}
-
 static enum sci_status sci_stp_request_udma_general_frame_handler(struct isci_request *ireq,
 								       u32 frame_index)
 {
@@ -1512,13 +1463,12 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 
 			if (resp_iu->datapres == 0x01 ||
 			    resp_iu->datapres == 0x02) {
-				sci_request_set_status(ireq,
-							    SCU_TASK_DONE_CHECK_RESPONSE,
-							    SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
-			} else
-				sci_request_set_status(ireq,
-							    SCU_TASK_DONE_GOOD,
-							    SCI_SUCCESS);
+				ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
+				ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
+			} else {
+				ireq->scu_status = SCU_TASK_DONE_GOOD;
+				ireq->sci_status = SCI_SUCCESS;
+			}
 		} else {
 			/* not a response frame, why did it get forwarded? */
 			dev_err(&ihost->pdev->dev,
@@ -1567,9 +1517,8 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 			sci_swab32_cpy(((u8 *) rsp_hdr) + SMP_RESP_HDR_SZ,
 				       smp_resp, word_cnt);
 
-			sci_request_set_status(ireq, SCU_TASK_DONE_GOOD,
-						    SCI_SUCCESS);
-
+			ireq->scu_status = SCU_TASK_DONE_GOOD;
+			ireq->sci_status = SCI_SUCCESS;
 			sci_change_state(&ireq->sm, SCI_REQ_SMP_WAIT_TC_COMP);
 		} else {
 			/*
@@ -1584,10 +1533,8 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 				frame_index,
 				rsp_hdr->frame_type);
 
-			sci_request_set_status(ireq,
-						    SCU_TASK_DONE_SMP_FRM_TYPE_ERR,
-						    SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
-
+			ireq->scu_status = SCU_TASK_DONE_SMP_FRM_TYPE_ERR;
+			ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 			sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		}
 
@@ -1602,16 +1549,14 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 
 	case SCI_REQ_STP_UDMA_WAIT_D2H:
 		/* Use the general frame handler to copy the resposne data */
-		status = sci_stp_request_udma_general_frame_handler(ireq,
-									 frame_index);
+		status = sci_stp_request_udma_general_frame_handler(ireq, frame_index);
 
 		if (status != SCI_SUCCESS)
 			return status;
 
-		sci_stp_request_udma_complete_request(ireq,
-							   SCU_TASK_DONE_CHECK_RESPONSE,
-							   SCI_FAILURE_IO_RESPONSE_VALID);
-
+		ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
+		ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
+		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		return SCI_SUCCESS;
 
 	case SCI_REQ_STP_NON_DATA_WAIT_D2H: {
@@ -1645,8 +1590,8 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 							       frame_buffer);
 
 			/* The command has completed with error */
-			sci_request_set_status(ireq, SCU_TASK_DONE_CHECK_RESPONSE,
-						    SCI_FAILURE_IO_RESPONSE_VALID);
+			ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
+			ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
 			break;
 
 		default:
@@ -1655,8 +1600,8 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 				  "violation occurred\n", __func__, stp_req,
 				  frame_index);
 
-			sci_request_set_status(ireq, SCU_TASK_DONE_UNEXP_FIS,
-						    SCI_FAILURE_PROTOCOL_VIOLATION);
+			ireq->scu_status = SCU_TASK_DONE_UNEXP_FIS;
+			ireq->sci_status = SCI_FAILURE_PROTOCOL_VIOLATION;
 			break;
 		}
 
@@ -1753,10 +1698,8 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 							       frame_header,
 							       frame_buffer);
 
-			sci_request_set_status(ireq,
-						    SCU_TASK_DONE_CHECK_RESPONSE,
-						    SCI_FAILURE_IO_RESPONSE_VALID);
-
+			ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
+			ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
 			sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 			break;
 
@@ -1800,10 +1743,8 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 				frame_index,
 				frame_header->fis_type);
 
-			sci_request_set_status(ireq,
-						    SCU_TASK_DONE_GOOD,
-						    SCI_FAILURE_IO_REQUIRES_SCSI_ABORT);
-
+			ireq->scu_status = SCU_TASK_DONE_GOOD;
+			ireq->sci_status = SCI_FAILURE_IO_REQUIRES_SCSI_ABORT;
 			sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 
 			/* Frame is decoded return it to the controller */
@@ -1833,10 +1774,8 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 			return status;
 
 		if ((stp_req->status & ATA_BUSY) == 0) {
-			sci_request_set_status(ireq,
-						    SCU_TASK_DONE_CHECK_RESPONSE,
-						    SCI_FAILURE_IO_RESPONSE_VALID);
-
+			ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
+			ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
 			sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		} else {
 			sci_change_state(&ireq->sm, SCI_REQ_STP_PIO_WAIT_FRAME);
@@ -1873,9 +1812,8 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 							       frame_buffer);
 
 			/* The command has completed with error */
-			sci_request_set_status(ireq,
-						    SCU_TASK_DONE_CHECK_RESPONSE,
-						    SCI_FAILURE_IO_RESPONSE_VALID);
+			ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
+			ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
 			break;
 
 		default:
@@ -1886,9 +1824,8 @@ sci_io_request_frame_handler(struct isci_request *ireq,
 				 stp_req,
 				 frame_index);
 
-			sci_request_set_status(ireq,
-						    SCU_TASK_DONE_UNEXP_FIS,
-						    SCI_FAILURE_PROTOCOL_VIOLATION);
+			ireq->scu_status = SCU_TASK_DONE_UNEXP_FIS;
+			ireq->sci_status = SCI_FAILURE_PROTOCOL_VIOLATION;
 			break;
 		}
 
@@ -1927,9 +1864,9 @@ static enum sci_status stp_request_udma_await_tc_event(struct isci_request *ireq
 
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
-		sci_stp_request_udma_complete_request(ireq,
-							   SCU_TASK_DONE_GOOD,
-							   SCI_SUCCESS);
+		ireq->scu_status = SCU_TASK_DONE_GOOD;
+		ireq->sci_status = SCI_SUCCESS;
+		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_FIS):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_REG_ERR):
@@ -1941,9 +1878,9 @@ static enum sci_status stp_request_udma_await_tc_event(struct isci_request *ireq
 			sci_remote_device_suspend(ireq->target_device,
 				SCU_EVENT_SPECIFIC(SCU_NORMALIZE_COMPLETION_STATUS(completion_code)));
 
-			sci_stp_request_udma_complete_request(ireq,
-								   SCU_TASK_DONE_CHECK_RESPONSE,
-								   SCI_FAILURE_IO_RESPONSE_VALID);
+			ireq->scu_status = SCU_TASK_DONE_CHECK_RESPONSE;
+			ireq->sci_status = SCI_FAILURE_IO_RESPONSE_VALID;
+			sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		} else {
 			/* If we have an error completion status for the
 			 * TC then we can expect a D2H register FIS from
@@ -1970,9 +1907,9 @@ static enum sci_status stp_request_udma_await_tc_event(struct isci_request *ireq
 	/* Fall through to the default case */
 	default:
 		/* All other completion status cause the IO to be complete. */
-		sci_stp_request_udma_complete_request(ireq,
-					SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
-					SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
+		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
+		ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
+		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	}
 
@@ -1985,9 +1922,8 @@ stp_request_soft_reset_await_h2d_asserted_tc_event(struct isci_request *ireq,
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
-		sci_request_set_status(ireq, SCU_TASK_DONE_GOOD,
-					    SCI_SUCCESS);
-
+		ireq->scu_status = SCU_TASK_DONE_GOOD;
+		ireq->sci_status = SCI_SUCCESS;
 		sci_change_state(&ireq->sm, SCI_REQ_STP_SOFT_RESET_WAIT_H2D_DIAG);
 		break;
 
@@ -1997,10 +1933,8 @@ stp_request_soft_reset_await_h2d_asserted_tc_event(struct isci_request *ireq,
 		 * If a NAK was received, then it is up to the user to retry
 		 * the request.
 		 */
-		sci_request_set_status(ireq,
-					    SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
-					    SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
-
+		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
+		ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	}
@@ -2014,9 +1948,8 @@ stp_request_soft_reset_await_h2d_diagnostic_tc_event(struct isci_request *ireq,
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
-		sci_request_set_status(ireq, SCU_TASK_DONE_GOOD,
-					    SCI_SUCCESS);
-
+		ireq->scu_status = SCU_TASK_DONE_GOOD;
+		ireq->sci_status = SCI_SUCCESS;
 		sci_change_state(&ireq->sm, SCI_REQ_STP_SOFT_RESET_WAIT_D2H);
 		break;
 
@@ -2025,10 +1958,8 @@ stp_request_soft_reset_await_h2d_diagnostic_tc_event(struct isci_request *ireq,
 		 * a NAK was received, then it is up to the user to retry the
 		 * request.
 		 */
-		sci_request_set_status(ireq,
-			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
-			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR);
-
+		ireq->scu_status = SCU_NORMALIZE_COMPLETION_STATUS(completion_code);
+		ireq->sci_status = SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR;
 		sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
 		break;
 	}
@@ -2504,7 +2435,7 @@ static void isci_request_io_request_complete(struct isci_host *ihost,
 		completion_status);
 
 	spin_lock(&request->state_lock);
-	request_status = isci_request_get_state(request);
+	request_status = request->status;
 
 	/* Decode the request status.  Note that if the request has been
 	 * aborted by a task management function, we don't care
@@ -2904,24 +2835,21 @@ static void sci_stp_request_started_non_data_await_h2d_completion_enter(struct s
 {
 	struct isci_request *ireq = container_of(sm, typeof(*ireq), sm);
 
-	sci_remote_device_set_working_request(ireq->target_device,
-						   ireq);
+	ireq->target_device->working_request = ireq;
 }
 
 static void sci_stp_request_started_pio_await_h2d_completion_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_request *ireq = container_of(sm, typeof(*ireq), sm);
 
-	sci_remote_device_set_working_request(ireq->target_device,
-						   ireq);
+	ireq->target_device->working_request = ireq;
 }
 
 static void sci_stp_request_started_soft_reset_await_h2d_asserted_completion_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_request *ireq = container_of(sm, typeof(*ireq), sm);
 
-	sci_remote_device_set_working_request(ireq->target_device,
-						   ireq);
+	ireq->target_device->working_request = ireq;
 }
 
 static void sci_stp_request_started_soft_reset_await_h2d_diagnostic_completion_enter(struct sci_base_state_machine *sm)
@@ -3141,8 +3069,8 @@ sci_io_request_construct_smp(struct device *dev,
 
 	task_context = ireq->tc;
 
-	idev = sci_request_get_device(ireq);
-	iport = sci_request_get_port(ireq);
+	idev = ireq->target_device;
+	iport = idev->owning_port;
 
 	/*
 	 * Fill in the TC with the its required data
@@ -3151,9 +3079,8 @@ sci_io_request_construct_smp(struct device *dev,
 	task_context->priority = 0;
 	task_context->initiator_request = 1;
 	task_context->connection_rate = idev->connection_rate;
-	task_context->protocol_engine_index =
-		sci_controller_get_protocol_engine_group(ihost);
-	task_context->logical_port_index = sci_port_get_index(iport);
+	task_context->protocol_engine_index = ISCI_PEG;
+	task_context->logical_port_index = iport->physical_port_index;
 	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SMP;
 	task_context->abort = 0;
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
@@ -3195,11 +3122,10 @@ sci_io_request_construct_smp(struct device *dev,
 	task_context->task_phase = 0;
 
 	ireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
-				 (sci_controller_get_protocol_engine_group(ihost) <<
-				  SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
-				 (sci_port_get_index(iport) <<
-				  SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
-				 ISCI_TAG_TCI(ireq->io_tag));
+			      (ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
+			       (iport->physical_port_index <<
+				SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
+			      ISCI_TAG_TCI(ireq->io_tag));
 	/*
 	 * Copy the physical address for the command buffer to the SCU Task
 	 * Context command buffer should not contain command header.
diff --git a/drivers/scsi/isci/request.h b/drivers/scsi/isci/request.h
index 08fcf98..5970840 100644
--- a/drivers/scsi/isci/request.h
+++ b/drivers/scsi/isci/request.h
@@ -300,58 +300,6 @@ enum sci_base_request_states {
 	SCI_REQ_FINAL,
 };
 
-/**
- * sci_request_get_controller() -
- *
- * This macro will return the controller for this io request object
- */
-#define sci_request_get_controller(ireq) \
-	((ireq)->owning_controller)
-
-/**
- * sci_request_get_device() -
- *
- * This macro will return the device for this io request object
- */
-#define sci_request_get_device(ireq) \
-	((ireq)->target_device)
-
-/**
- * sci_request_get_port() -
- *
- * This macro will return the port for this io request object
- */
-#define sci_request_get_port(ireq)	\
-	sci_remote_device_get_port(sci_request_get_device(ireq))
-
-/**
- * sci_request_get_post_context() -
- *
- * This macro returns the constructed post context result for the io request.
- */
-#define sci_request_get_post_context(ireq)	\
-	((ireq)->post_context)
-
-/**
- * sci_request_get_task_context() -
- *
- * This is a helper macro to return the os handle for this request object.
- */
-#define sci_request_get_task_context(request) \
-	((request)->task_context_buffer)
-
-/**
- * sci_request_set_status() -
- *
- * This macro will set the scu hardware status and sci request completion
- * status for an io request.
- */
-#define sci_request_set_status(request, scu_status_code, sci_status_code) \
-	{ \
-		(request)->scu_status = (scu_status_code); \
-		(request)->sci_status = (sci_status_code); \
-	}
-
 enum sci_status sci_request_start(struct isci_request *ireq);
 enum sci_status sci_io_request_terminate(struct isci_request *ireq);
 enum sci_status
@@ -382,27 +330,6 @@ sci_io_request_get_dma_addr(struct isci_request *ireq, void *virt_addr)
 }
 
 /**
- * This function gets the status of the request object.
- * @request: This parameter points to the isci_request object
- *
- * status of the object as a isci_request_status enum.
- */
-static inline enum isci_request_status
-isci_request_get_state(struct isci_request *isci_request)
-{
-	BUG_ON(isci_request == NULL);
-
-	/*probably a bad sign...	*/
-	if (isci_request->status == unallocated)
-		dev_warn(&isci_request->isci_host->pdev->dev,
-			 "%s: isci_request->status == unallocated\n",
-			 __func__);
-
-	return isci_request->status;
-}
-
-
-/**
  * isci_request_change_state() - This function sets the status of the request
  *    object.
  * @request: This parameter points to the isci_request object
diff --git a/drivers/scsi/isci/task.c b/drivers/scsi/isci/task.c
index d040aa2..20112cd 100644
--- a/drivers/scsi/isci/task.c
+++ b/drivers/scsi/isci/task.c
@@ -654,7 +654,7 @@ static void isci_terminate_request_core(struct isci_host *ihost,
 			 * needs to be detached and freed here.
 			 */
 			spin_lock_irqsave(&isci_request->state_lock, flags);
-			request_status = isci_request_get_state(isci_request);
+			request_status = isci_request->status;
 
 			if ((isci_request->ttype == io_task) /* TMFs are in their own thread */
 			    && ((request_status == aborted)
-- 
1.6.0.2

