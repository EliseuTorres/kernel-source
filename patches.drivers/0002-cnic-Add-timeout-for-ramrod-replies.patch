From: Michael Chan <mchan@broadcom.com>
Date: Fri, 26 Aug 2011 09:45:40 +0000
Subject: [PATCH 2/4] cnic: Add timeout for ramrod replies.
Git-commit: dcc7e3a6a2a2464cf96dee329f7c58fe8c230d97
Patch-mainline: v3.2-rc1
References: bnc#722436

If the bnx2x device has encountered parity errors, the chip will not DMA
any replies.  Using wait_event_timeout() will allow us to make forward
progress and let bnx2x reset the chip.

Signed-off-by: Michael Chan <mchan@broadcom.com>
Reviewed-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Lee, Chun-Yi <jlee@suse.com>
---
 drivers/net/cnic.c      |   17 ++++++++++-------
 drivers/net/cnic.h      |    2 ++
 drivers/net/cnic_defs.h |    1 +
 3 files changed, 13 insertions(+), 7 deletions(-)

--- a/drivers/net/cnic.c
+++ b/drivers/net/cnic.c
@@ -1875,12 +1875,12 @@ static int cnic_bnx2x_destroy_ramrod(str
 				  hw_cid, NONE_CONNECTION_TYPE, &l5_data);
 
 	if (ret == 0) {
-		wait_event(ctx->waitq, ctx->wait_cond);
+		wait_event_timeout(ctx->waitq, ctx->wait_cond, CNIC_RAMROD_TMO);
 		if (unlikely(test_bit(CTX_FL_CID_ERROR, &ctx->ctx_flags)))
 			return -EBUSY;
 	}
 
-	return ret;
+	return 0;
 }
 
 static int cnic_bnx2x_iscsi_destroy(struct cnic_dev *dev, struct kwqe *kwqe)
@@ -2428,17 +2428,20 @@ static int cnic_bnx2x_fcoe_destroy(struc
 	init_waitqueue_head(&ctx->waitq);
 	ctx->wait_cond = 0;
 
+	memset(&kcqe, 0, sizeof(kcqe));
+	kcqe.completion_status = FCOE_KCQE_COMPLETION_STATUS_ERROR;
 	memset(&l5_data, 0, sizeof(l5_data));
 	ret = cnic_submit_kwqe_16(dev, FCOE_RAMROD_CMD_ID_TERMINATE_CONN, cid,
 				  FCOE_CONNECTION_TYPE, &l5_data);
 	if (ret == 0) {
-		wait_event(ctx->waitq, ctx->wait_cond);
-		set_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags);
-		queue_delayed_work(cnic_wq, &cp->delete_task,
-				   msecs_to_jiffies(2000));
+		wait_event_timeout(ctx->waitq, ctx->wait_cond, CNIC_RAMROD_TMO);
+		if (ctx->wait_cond)
+			kcqe.completion_status = 0;
 	}
 
-	memset(&kcqe, 0, sizeof(kcqe));
+	set_bit(CTX_FL_DELETE_WAIT, &ctx->ctx_flags);
+	queue_delayed_work(cnic_wq, &cp->delete_task, msecs_to_jiffies(2000));
+
 	kcqe.op_code = FCOE_KCQE_OPCODE_DESTROY_CONN;
 	kcqe.fcoe_conn_id = req->conn_id;
 	kcqe.fcoe_conn_context_id = cid;
--- a/drivers/net/cnic.h
+++ b/drivers/net/cnic.h
@@ -474,5 +474,7 @@ struct bnx2x_bd_chain_next {
 	  MAX_STAT_COUNTER_ID_E1))
 #endif
 
+#define CNIC_RAMROD_TMO			(HZ / 4)
+
 #endif
 
--- a/drivers/net/cnic_defs.h
+++ b/drivers/net/cnic_defs.h
@@ -67,6 +67,7 @@
 #define FCOE_KWQE_OPCODE_DESTROY		(10)
 #define FCOE_KWQE_OPCODE_STAT			(11)
 
+#define FCOE_KCQE_COMPLETION_STATUS_ERROR	(0x1)
 #define FCOE_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE	(0x3)
 
 /* KCQ (kernel completion queue) response op codes */

