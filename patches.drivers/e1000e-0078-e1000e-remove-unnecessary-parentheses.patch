From: Bruce Allan <bruce.w.allan@intel.com>
Date: Tue, 31 Jan 2012 07:02:56 +0000
Subject: e1000e: remove unnecessary parentheses
Patch-mainline: v3.4-rc1
Git-commit: 668018d74762741c3fe5a54f0eea1bd65dcabd7e
References: bnc#795174 FATE#313648

Signed-off-by: Bruce Allan <bruce.w.allan@intel.com>
Tested-by: Aaron Brown <aaron.f.brown@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ethernet/intel/e1000e/82571.c   |    2 +-
 drivers/net/ethernet/intel/e1000e/ethtool.c |    4 ++--
 drivers/net/ethernet/intel/e1000e/mac.c     |    6 +++---
 drivers/net/ethernet/intel/e1000e/manage.c  |    2 +-
 drivers/net/ethernet/intel/e1000e/phy.c     |   10 +++++-----
 5 files changed, 12 insertions(+), 12 deletions(-)
--- a/drivers/net/ethernet/intel/e1000e/82571.c
+++ b/drivers/net/ethernet/intel/e1000e/82571.c
@@ -1866,7 +1866,7 @@ static void e1000_power_down_phy_copper_
 	struct e1000_phy_info *phy = &hw->phy;
 	struct e1000_mac_info *mac = &hw->mac;
 
-	if (!(phy->ops.check_reset_block))
+	if (!phy->ops.check_reset_block)
 		return;
 
 	/* If the management interface is not enabled, then power down */
--- a/drivers/net/ethernet/intel/e1000e/ethtool.c
+++ b/drivers/net/ethernet/intel/e1000e/ethtool.c
@@ -1088,7 +1088,7 @@ static int e1000_setup_desc_rings(struct
 	tx_ring->buffer_info = kcalloc(tx_ring->count,
 				       sizeof(struct e1000_buffer),
 				       GFP_KERNEL);
-	if (!(tx_ring->buffer_info)) {
+	if (!tx_ring->buffer_info) {
 		ret_val = 1;
 		goto err_nomem;
 	}
@@ -1150,7 +1150,7 @@ static int e1000_setup_desc_rings(struct
 	rx_ring->buffer_info = kcalloc(rx_ring->count,
 				       sizeof(struct e1000_buffer),
 				       GFP_KERNEL);
-	if (!(rx_ring->buffer_info)) {
+	if (!rx_ring->buffer_info) {
 		ret_val = 5;
 		goto err_nomem;
 	}
--- a/drivers/net/ethernet/intel/e1000e/mac.c
+++ b/drivers/net/ethernet/intel/e1000e/mac.c
@@ -511,8 +511,8 @@ s32 e1000e_check_for_fiber_link(struct e
 	 * was just plugged in. The autoneg_failed flag does this.
 	 */
 	/* (ctrl & E1000_CTRL_SWDPIN1) == 1 == have signal */
-	if ((ctrl & E1000_CTRL_SWDPIN1) && (!(status & E1000_STATUS_LU)) &&
-	    (!(rxcw & E1000_RXCW_C))) {
+	if ((ctrl & E1000_CTRL_SWDPIN1) && !(status & E1000_STATUS_LU) &&
+	    !(rxcw & E1000_RXCW_C)) {
 		if (mac->autoneg_failed == 0) {
 			mac->autoneg_failed = 1;
 			return 0;
@@ -577,7 +577,7 @@ s32 e1000e_check_for_serdes_link(struct
 	 * time to complete.
 	 */
 	/* (ctrl & E1000_CTRL_SWDPIN1) == 1 == have signal */
-	if ((!(status & E1000_STATUS_LU)) && (!(rxcw & E1000_RXCW_C))) {
+	if (!(status & E1000_STATUS_LU) && !(rxcw & E1000_RXCW_C)) {
 		if (mac->autoneg_failed == 0) {
 			mac->autoneg_failed = 1;
 			return 0;
--- a/drivers/net/ethernet/intel/e1000e/manage.c
+++ b/drivers/net/ethernet/intel/e1000e/manage.c
@@ -78,7 +78,7 @@ static s32 e1000_mng_enable_host_if(stru
 	u32 hicr;
 	u8 i;
 
-	if (!(hw->mac.arc_subsystem_valid)) {
+	if (!hw->mac.arc_subsystem_valid) {
 		e_dbg("ARC subsystem not valid.\n");
 		return -E1000_ERR_HOST_INTERFACE_COMMAND;
 	}
--- a/drivers/net/ethernet/intel/e1000e/phy.c
+++ b/drivers/net/ethernet/intel/e1000e/phy.c
@@ -132,7 +132,7 @@ s32 e1000e_get_phy_id(struct e1000_hw *h
 	u16 phy_id;
 	u16 retry_count = 0;
 
-	if (!(phy->ops.read_reg))
+	if (!phy->ops.read_reg)
 		goto out;
 
 	while (retry_count < 2) {
@@ -382,7 +382,7 @@ static s32 __e1000e_read_phy_reg_igp(str
 	s32 ret_val = 0;
 
 	if (!locked) {
-		if (!(hw->phy.ops.acquire))
+		if (!hw->phy.ops.acquire)
 			goto out;
 
 		ret_val = hw->phy.ops.acquire(hw);
@@ -453,7 +453,7 @@ static s32 __e1000e_write_phy_reg_igp(st
 	s32 ret_val = 0;
 
 	if (!locked) {
-		if (!(hw->phy.ops.acquire))
+		if (!hw->phy.ops.acquire)
 			goto out;
 
 		ret_val = hw->phy.ops.acquire(hw);
@@ -526,7 +526,7 @@ static s32 __e1000_read_kmrn_reg(struct
 	s32 ret_val = 0;
 
 	if (!locked) {
-		if (!(hw->phy.ops.acquire))
+		if (!hw->phy.ops.acquire)
 			goto out;
 
 		ret_val = hw->phy.ops.acquire(hw);
@@ -599,7 +599,7 @@ static s32 __e1000_write_kmrn_reg(struct
 	s32 ret_val = 0;
 
 	if (!locked) {
-		if (!(hw->phy.ops.acquire))
+		if (!hw->phy.ops.acquire)
 			goto out;
 
 		ret_val = hw->phy.ops.acquire(hw);
