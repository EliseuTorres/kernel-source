From: Takashi Iwai <tiwai@suse.de>
Subject: Add clickpad button toggle support
Patch-mainline: Unlikely
References: bnc#547370, bnc#582643

Synaptics Clickpad device has a marked point on the upper-left corner.
When use touches this point, the LED should be turned on and the device
should be disabled.

This patch adds this behavior to the existing synaptics driver.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/input/mouse/synaptics.c |   53 ++++++++++++++++++++++++++++++++++++++--
 drivers/input/mouse/synaptics.h |    2 +
 2 files changed, 53 insertions(+), 2 deletions(-)

--- a/drivers/input/mouse/synaptics.c
+++ b/drivers/input/mouse/synaptics.c
@@ -27,6 +27,7 @@
 #include <linux/input.h>
 #include <linux/serio.h>
 #include <linux/libps2.h>
+#include <linux/workqueue.h>
 #include "psmouse.h"
 #include "synaptics.h"
 
@@ -335,6 +336,34 @@
 	((XMAX_NOMINAL - XMIN_NOMINAL) * 3 / 5 + XMIN_NOMINAL)
 #define X_VSCROLL (XMAX_NOMINAL - (XMAX_NOMINAL - XMIN_NOMINAL) / 15)
 
+/* clicpad button toggle point */
+/* touching the toggle point (at the upper-left corner) turns on/off the
+ * clickpad mode.
+ */
+#define CLICKPAD_TOGGLE_X \
+	((XMAX_NOMINAL - XMIN_NOMINAL) * 1 / 10 + XMIN_NOMINAL)
+#define CLICKPAD_TOGGLE_Y \
+	(YMAX_NOMINAL * 7 / 8)
+
+/* FIXME: this is local for keeping the status through reconnection over S3/S4 */
+static int clickpad_disabled;
+
+static void clickpad_set_led(struct psmouse *psmouse, int disable)
+{
+	unsigned char param[1];
+
+	if (psmouse_sliced_command(psmouse, disable ? 0x88 : 0x10))
+		return;
+	param[0] = 0x0a;
+	ps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_SETRATE);
+}
+
+static void clickpad_led_work(struct work_struct *work)
+{
+	struct synaptics_data *priv = container_of(work, struct synaptics_data, led_work);
+	clickpad_set_led(priv->psmouse, clickpad_disabled);
+}
+
 /* additional clickpad area in percent */
 static int clickpad_area = 20;
 module_param(clickpad_area, int, 0644);
@@ -346,7 +375,8 @@
 	/* clickpad mode reports Y range from 0 to YMAX_NOMINAL,
 	 * where the area Y < YMIN_NOMINAL is used as click buttons
 	 */
-	if (hw->y < YMIN_NOMINAL + (YMAX_NOMINAL - YMIN_NOMINAL) * clickpad_area / 100) {
+	if (hw->y < YMIN_NOMINAL + (YMAX_NOMINAL - YMIN_NOMINAL) * clickpad_area / 100 &&
+	   !clickpad_disabled) {
 		/* button area */
 		/* allow position change for the v-scroll area exceptionally */
 		if (hw->x < X_VSCROLL || hw->middle)
@@ -363,13 +393,20 @@
 			else
 				hw->middle = 1;
 		}
-	} else if (hw->middle) {
+	} else if (hw->middle && !clickpad_disabled) {
 		/* dragging */
 		hw->left = priv->prev_hw.left;
 		hw->right = priv->prev_hw.right;
 		hw->middle = priv->prev_hw.middle;
+	} else if (!(priv->prev_hw.left || priv->prev_hw.middle || priv->prev_hw.right) &&
+	    hw->x < CLICKPAD_TOGGLE_X  && hw->y > CLICKPAD_TOGGLE_Y &&
+	    hw->z > 30 && priv->prev_hw.z < 25) {
+		clickpad_disabled ^= 1;
+		schedule_work(&priv->led_work);
 	}
 	priv->prev_hw = *hw;
+	if (clickpad_disabled)
+		hw->z = 0; /* disable position report */
 }
 
 static void synaptics_parse_hw_state(unsigned char buf[], struct synaptics_data *priv, struct synaptics_hw_state *hw)
@@ -644,6 +681,12 @@
 
 static void synaptics_disconnect(struct psmouse *psmouse)
 {
+	struct synaptics_data *priv = psmouse->private;
+
+	if (SYN_CAP_CLICKPAD(priv->ext_cap)) {
+		cancel_work_sync(&priv->led_work);
+		clickpad_set_led(psmouse, 0);
+	}
 	synaptics_reset(psmouse);
 	kfree(psmouse->private);
 	psmouse->private = NULL;
@@ -675,6 +718,9 @@
 		return -1;
 	}
 
+	if (SYN_CAP_CLICKPAD(priv->ext_cap))
+		clickpad_set_led(psmouse, clickpad_disabled);
+
 	return 0;
 }
 
@@ -724,6 +770,7 @@
 	if (!priv)
 		return -1;
 
+	priv->psmouse = psmouse;
 	psmouse_reset(psmouse);
 
 	if (synaptics_query_hardware(psmouse)) {
@@ -747,6 +794,8 @@
 		printk(KERN_INFO "Synaptics: Clickpad mode enabled\n");
 		/* force to enable the middle button */
 		priv->capabilities |= (1 << 18);
+		INIT_WORK(&priv->led_work, clickpad_led_work);
+		clickpad_set_led(psmouse, clickpad_disabled);
 	}
 
 	set_input_params(psmouse->dev, priv);
--- a/drivers/input/mouse/synaptics.h
+++ b/drivers/input/mouse/synaptics.h
@@ -106,6 +106,8 @@
 	unsigned char mode;			/* current mode byte */
 	int scroll;
 	struct synaptics_hw_state prev_hw;
+	struct psmouse *psmouse;
+	struct work_struct led_work;
 };
 
 int synaptics_detect(struct psmouse *psmouse, bool set_properties);
