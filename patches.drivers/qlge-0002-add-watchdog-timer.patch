From: Ron Mercer <ron.mercer@qlogic.com>
Subject: [net-next PATCH 3/3] qlge: Add watchdog timer.
References: bnc#575956
Patch-mainline: Submitted Feb 4 2010 net-next-2.6
Git-commit: 15c052fc7f4a1b3544602be8af77e31bba9261bf
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6.git

Add periodic heartbeat register read to trigger the eeh
recovery process.
We see cases where an eeh error was injected and the slot was
suspended.  An asic access attempt is required to flush the recovery process,
but without interrupts the process can stall.
Adding this periodic register read causes the recovery process to begin.

Signed-off-by: Ron Mercer <ron.mercer@qlogic.com>
Signed-off-by: Brandon Philips <bphilips@suse.de>

---
 drivers/net/qlge/qlge.h      |    1 +
 drivers/net/qlge/qlge_main.c |   26 ++++++++++++++++++++++++++
 2 files changed, 27 insertions(+)

Index: linux-2.6.32-SLE11-SP1/drivers/net/qlge/qlge.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/net/qlge/qlge.h
+++ linux-2.6.32-SLE11-SP1/drivers/net/qlge/qlge.h
@@ -2144,6 +2144,7 @@ struct ql_adapter {
 	struct completion ide_completion;
 	struct nic_operations *nic_ops;
 	u16 device_id;
+	struct timer_list timer;
 	atomic_t lb_count;
 	/* Keep local copy of current mac address. */
 	char current_mac_addr[6];
Index: linux-2.6.32-SLE11-SP1/drivers/net/qlge/qlge_main.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/net/qlge/qlge_main.c
+++ linux-2.6.32-SLE11-SP1/drivers/net/qlge/qlge_main.c
@@ -4554,6 +4554,20 @@ static const struct net_device_ops qlge_
 	.ndo_vlan_rx_kill_vid	= qlge_vlan_rx_kill_vid,
 };
 
+static void ql_timer(unsigned long data)
+{
+	struct ql_adapter *qdev = (struct ql_adapter *)data;
+	u32 var = 0;
+
+	var = ql_read32(qdev, STS);
+	if (pci_channel_offline(qdev->pdev)) {
+		QPRINTK(qdev, IFUP, ERR, "EEH STS = 0x%.08x.\n", var);
+		return;
+	}
+
+	mod_timer(&qdev->timer, jiffies + HZ);
+}
+
 static int __devinit qlge_probe(struct pci_dev *pdev,
 				const struct pci_device_id *pci_entry)
 {
@@ -4605,6 +4619,13 @@ static int __devinit qlge_probe(struct p
 		pci_disable_device(pdev);
 		return err;
 	}
+	/* Start up the timer to trigger EEH if
+	 * the bus goes dead
+	 */
+	init_timer(&qdev->timer);
+	qdev->timer.data = (unsigned long)qdev;
+	qdev->timer.function = ql_timer;
+	mod_timer(&qdev->timer, jiffies + HZ);
 	ql_link_off(qdev);
 	ql_display_dev_info(ndev);
 	atomic_set(&qdev->lb_count, 0);
@@ -4625,6 +4646,8 @@ int ql_clean_lb_rx_ring(struct rx_ring *
 static void __devexit qlge_remove(struct pci_dev *pdev)
 {
 	struct net_device *ndev = pci_get_drvdata(pdev);
+	struct ql_adapter *qdev = netdev_priv(ndev);
+	del_timer_sync(&qdev->timer);
 	unregister_netdev(ndev);
 	ql_release_all(pdev);
 	pci_disable_device(pdev);
@@ -4733,6 +4756,7 @@ static void qlge_io_resume(struct pci_de
 		QPRINTK(qdev, IFUP, ERR,
 			"Device was not running prior to EEH.\n");
 	}
+	mod_timer(&qdev->timer, jiffies + HZ);
 	netif_device_attach(ndev);
 }
 
@@ -4749,6 +4773,7 @@ static int qlge_suspend(struct pci_dev *
 	int err;
 
 	netif_device_detach(ndev);
+	del_timer_sync(&qdev->timer);
 
 	if (netif_running(ndev)) {
 		err = ql_adapter_down(qdev);
@@ -4793,6 +4818,7 @@ static int qlge_resume(struct pci_dev *p
 			return err;
 	}
 
+	mod_timer(&qdev->timer, jiffies + HZ);
 	netif_device_attach(ndev);
 
 	return 0;
