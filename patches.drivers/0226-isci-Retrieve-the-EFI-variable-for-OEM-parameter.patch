From: Dave Jiang <dave.jiang@intel.com>
Date: Wed, 25 May 2011 05:04:35 +0000
Subject: [PATCH 226/273] isci: Retrieve the EFI variable for OEM parameter
Git-commit: bf482c6069b514b7fe57a048ae1b6f11cf3bb10c
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

We can call the EFI get_variable service routine directly to retrieve
the EFI variable that holds the OEM parameters table.

Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/probe_roms.c |   73 ++++++++++++---------------------------
 drivers/scsi/isci/probe_roms.h |    2 +-
 2 files changed, 24 insertions(+), 51 deletions(-)

diff --git a/drivers/scsi/isci/probe_roms.c b/drivers/scsi/isci/probe_roms.c
index 9bc173f..084fdc6 100644
--- a/drivers/scsi/isci/probe_roms.c
+++ b/drivers/scsi/isci/probe_roms.c
@@ -34,14 +34,8 @@
 #include "task.h"
 #include "probe_roms.h"
 
-struct efi_variable {
-	efi_char16_t  VariableName[1024/sizeof(efi_char16_t)];
-	efi_guid_t    VendorGuid;
-	unsigned long DataSize;
-	__u8          Data[1024];
-	efi_status_t  Status;
-	__u32         Attributes;
-} __attribute__((packed));
+static efi_char16_t isci_efivar_name[] =
+			{'R', 's', 't', 'S', 'c', 'u', 'O'};
 
 struct isci_orom *isci_request_oprom(struct pci_dev *pdev)
 {
@@ -169,62 +163,50 @@ struct isci_orom *isci_request_firmware(struct pci_dev *pdev, const struct firmw
 
 static struct efi *get_efi(void)
 {
-	#ifdef CONFIG_EFI
+#ifdef CONFIG_EFI
 	return &efi;
-	#else
+#else
 	return NULL;
-	#endif
+#endif
 }
 
 struct isci_orom *isci_get_efi_var(struct pci_dev *pdev)
 {
-	struct efi_variable *evar;
 	efi_status_t status;
-	struct isci_orom *rom = NULL;
+	struct isci_orom *rom;
 	struct isci_oem_hdr *oem_hdr;
 	u8 *tmp, sum;
 	int j;
-	size_t copy_len;
+	ssize_t data_len;
+	u8 *efi_data;
+	u32 efi_attrib = 0;
 
-	evar = devm_kzalloc(&pdev->dev,
-			    sizeof(struct efi_variable),
-			    GFP_KERNEL);
-	if (!evar) {
+	data_len = 1024;
+	efi_data = devm_kzalloc(&pdev->dev, data_len, GFP_KERNEL);
+	if (!efi_data) {
 		dev_warn(&pdev->dev,
-			 "Unable to allocate memory for EFI var\n");
+			 "Unable to allocate memory for EFI data\n");
 		return NULL;
 	}
 
-	rom = devm_kzalloc(&pdev->dev, sizeof(*rom), GFP_KERNEL);
-	if (!rom) {
-		dev_warn(&pdev->dev,
-			 "Unable to allocate memory for orom\n");
-		return NULL;
-	}
-
-	for (j = 0; j < strlen(ISCI_EFI_VAR_NAME) + 1; j++)
-		evar->VariableName[j] = ISCI_EFI_VAR_NAME[j];
-
-	evar->DataSize = 1024;
-	evar->VendorGuid = ISCI_EFI_VENDOR_GUID;
-	evar->Attributes = ISCI_EFI_ATTRIBUTES;
+	rom = (struct isci_orom *)(efi_data + sizeof(struct isci_oem_hdr));
 
 	if (get_efi())
-		status = get_efi()->get_variable(evar->VariableName,
-						 &evar->VendorGuid,
-						 &evar->Attributes,
-						 &evar->DataSize,
-						 evar->Data);
+		status = get_efi()->get_variable(isci_efivar_name,
+						 &ISCI_EFI_VENDOR_GUID,
+						 &efi_attrib,
+						 &data_len,
+						 efi_data);
 	else
 		status = EFI_NOT_FOUND;
 
 	if (status != EFI_SUCCESS) {
 		dev_warn(&pdev->dev,
-			 "Unable to obtain EFI variable for OEM parms\n");
+			 "Unable to obtain EFI var data for OEM parms\n");
 		return NULL;
 	}
 
-	oem_hdr = (struct isci_oem_hdr *)evar->Data;
+	oem_hdr = (struct isci_oem_hdr *)efi_data;
 
 	if (memcmp(oem_hdr->sig, ISCI_OEM_SIG, ISCI_OEM_SIG_SIZE) != 0) {
 		dev_warn(&pdev->dev,
@@ -233,12 +215,8 @@ struct isci_orom *isci_get_efi_var(struct pci_dev *pdev)
 	}
 
 	/* calculate checksum */
-	tmp = (u8 *)oem_hdr;
-	for (j = 0, sum = 0; j < sizeof(oem_hdr); j++, tmp++)
-		sum += *tmp;
-
-	tmp = (u8 *)rom;
-	for (j = 0; j < sizeof(*rom); j++, tmp++)
+	tmp = (u8 *)efi_data;
+	for (j = 0, sum = 0; j < (sizeof(*oem_hdr) + sizeof(*rom)); j++, tmp++)
 		sum += *tmp;
 
 	if (sum != 0) {
@@ -247,11 +225,6 @@ struct isci_orom *isci_get_efi_var(struct pci_dev *pdev)
 		return NULL;
 	}
 
-	copy_len = min_t(u16, evar->DataSize,
-			 min_t(u16, oem_hdr->len - sizeof(*oem_hdr), sizeof(*rom)));
-
-	memcpy(rom, (char *)evar->Data + sizeof(*oem_hdr), copy_len);
-
 	if (memcmp(rom->hdr.signature,
 		   ISCI_ROM_SIG,
 		   ISCI_ROM_SIG_SIZE) != 0) {
diff --git a/drivers/scsi/isci/probe_roms.h b/drivers/scsi/isci/probe_roms.h
index 7e3e6d7..95c8d91 100644
--- a/drivers/scsi/isci/probe_roms.h
+++ b/drivers/scsi/isci/probe_roms.h
@@ -58,6 +58,7 @@
 #ifdef __KERNEL__
 #include <linux/firmware.h>
 #include <linux/pci.h>
+#include <linux/efi.h>
 #include "isci.h"
 
 #define SCIC_SDS_PARM_NO_SPEED   0
@@ -202,7 +203,6 @@ struct isci_oem_hdr {
 #define ISCI_EFI_VENDOR_GUID	\
 	EFI_GUID(0x193dfefa, 0xa445, 0x4302, 0x99, 0xd8, 0xef, 0x3a, 0xad, \
 			0x1a, 0x04, 0xc6)
-#define ISCI_EFI_ATTRIBUTES	0
 #define ISCI_EFI_VAR_NAME	"RstScuO"
 
 /* Allowed PORT configuration modes APC Automatic PORT configuration mode is
-- 
1.6.0.2

