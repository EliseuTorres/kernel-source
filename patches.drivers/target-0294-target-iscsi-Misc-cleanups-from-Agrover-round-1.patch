From: Andy Grover <agrover@redhat.com>
Date: Tue, 3 Apr 2012 15:51:02 -0700
Subject: [PATCH] target/iscsi: Misc cleanups from Agrover (round 1)
Git-commit: c6037cc546ca10cbdc5b60f0598b4ddcb181fe5d
References: FATE#313550
Patch-Mainline: v3.5

*) Use decoded cmd->immediate_cmd for conditional instead of
   re-examining hdr->opcode
*) Make iscist_dataout_post_crc_passed more legible
*) use max() to reduce code in build_r2ts_for_cmd()
*) Remove CONFIG_SMP and if 0 ifdefs
*) Replace if/goto with a while loop
*) Remove unused conn->tx_immediate_queue and tx_response_queue

Signed-off-by: Andy Grover <agrover@redhat.com>
Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/target/iscsi/iscsi_target.c      |   57 +++++------------------------
 drivers/target/iscsi/iscsi_target_core.h |    2 -
 drivers/target/iscsi/iscsi_target_erl0.c |    9 +++--
 3 files changed, 16 insertions(+), 52 deletions(-)

diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c
index 50cfa1f..3781fc5 100644
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@ -2177,7 +2177,7 @@ static int iscsit_handle_logout_cmd(
 	 * Immediate commands are executed, well, immediately.
 	 * Non-Immediate Logout Commands are executed in CmdSN order.
 	 */
-	if (hdr->opcode & ISCSI_OP_IMMEDIATE) {
+	if (cmd->immediate_cmd) {
 		int ret = iscsit_execute_cmd(cmd, 0);
 
 		if (ret < 0)
@@ -2922,8 +2922,7 @@ int iscsit_build_r2ts_for_cmd(
 	}
 
 	if (conn->sess->sess_ops->DataSequenceInOrder && (type != 2))
-		if (cmd->r2t_offset < cmd->write_data_done)
-			cmd->r2t_offset = cmd->write_data_done;
+		cmd->r2t_offset = max(cmd->r2t_offset, cmd->write_data_done);
 
 	while (cmd->outstanding_r2ts < conn->sess->sess_ops->MaxOutstandingR2T) {
 		if (conn->sess->sess_ops->DataSequenceInOrder) {
@@ -3417,8 +3416,6 @@ static void iscsit_tx_thread_wait_for_tcp(struct iscsi_conn *conn)
 	}
 }
 
-#ifdef CONFIG_SMP
-
 void iscsit_thread_get_cpumask(struct iscsi_conn *conn)
 {
 	struct iscsi_thread_set *ts = conn->thread_set;
@@ -3432,10 +3429,6 @@ void iscsit_thread_get_cpumask(struct iscsi_conn *conn)
 	 * execute upon.
 	 */
 	ord = ts->thread_id % cpumask_weight(cpu_online_mask);
-#if 0
-	pr_debug(">>>>>>>>>>>>>>>>>>>> Generated ord: %d from"
-			" thread_id: %d\n", ord, ts->thread_id);
-#endif
 	for_each_online_cpu(cpu) {
 		if (ord-- == 0) {
 			cpumask_set_cpu(cpu, conn->conn_cpumask);
@@ -3475,23 +3468,9 @@ static inline void iscsit_thread_check_cpumask(
 	 */
 	memset(buf, 0, 128);
 	cpumask_scnprintf(buf, 128, conn->conn_cpumask);
-#if 0
-	pr_debug(">>>>>>>>>>>>>> Calling set_cpus_allowed_ptr():"
-			" %s for %s\n", buf, p->comm);
-#endif
 	set_cpus_allowed_ptr(p, conn->conn_cpumask);
 }
 
-#else
-
-void iscsit_thread_get_cpumask(struct iscsi_conn *conn)
-{
-	return;
-}
-
-#define iscsit_thread_check_cpumask(X, Y, Z) ({})
-#endif /* CONFIG_SMP */
-
 int iscsi_target_tx_thread(void *arg)
 {
 	u8 state;
@@ -3530,9 +3509,7 @@ restart:
 		     signal_pending(current))
 			goto transport_err;
 
-get_immediate:
-		qr = iscsit_get_cmd_from_immediate_queue(conn);
-		if (qr) {
+		while ((qr = iscsit_get_cmd_from_immediate_queue(conn))) {
 			atomic_set(&conn->check_immediate_queue, 0);
 			cmd = qr->cmd;
 			state = qr->state;
@@ -3555,7 +3532,7 @@ get_immediate:
 				spin_unlock_bh(&conn->cmd_lock);
 
 				iscsit_free_cmd(cmd);
-				goto get_immediate;
+				continue;
 			case ISTATE_SEND_NOPIN_WANT_RESPONSE:
 				spin_unlock_bh(&cmd->istate_lock);
 				iscsit_mod_nopin_response_timer(conn);
@@ -3575,13 +3552,10 @@ get_immediate:
 				spin_unlock_bh(&cmd->istate_lock);
 				goto transport_err;
 			}
-			if (ret < 0) {
-				conn->tx_immediate_queue = 0;
+			if (ret < 0)
 				goto transport_err;
-			}
 
 			if (iscsit_send_tx_data(cmd, conn, 1) < 0) {
-				conn->tx_immediate_queue = 0;
 				iscsit_tx_thread_wait_for_tcp(conn);
 				goto transport_err;
 			}
@@ -3610,13 +3584,9 @@ get_immediate:
 				spin_unlock_bh(&cmd->istate_lock);
 				goto transport_err;
 			}
-			goto get_immediate;
-		} else
-			conn->tx_immediate_queue = 0;
+		}
 
-get_response:
-		qr = iscsit_get_cmd_from_response_queue(conn);
-		if (qr) {
+		while ((qr = iscsit_get_cmd_from_response_queue(conn))) {
 			cmd = qr->cmd;
 			state = qr->state;
 			kmem_cache_free(lio_qr_cache, qr);
@@ -3680,21 +3650,17 @@ check_rsp_state:
 				spin_unlock_bh(&cmd->istate_lock);
 				goto transport_err;
 			}
-			if (ret < 0) {
-				conn->tx_response_queue = 0;
+			if (ret < 0)
 				goto transport_err;
-			}
 
 			if (map_sg && !conn->conn_ops->IFMarker) {
 				if (iscsit_fe_sendpage_sg(cmd, conn) < 0) {
-					conn->tx_response_queue = 0;
 					iscsit_tx_thread_wait_for_tcp(conn);
 					iscsit_unmap_iovec(cmd);
 					goto transport_err;
 				}
 			} else {
 				if (iscsit_send_tx_data(cmd, conn, use_misc) < 0) {
-					conn->tx_response_queue = 0;
 					iscsit_tx_thread_wait_for_tcp(conn);
 					iscsit_unmap_iovec(cmd);
 					goto transport_err;
@@ -3770,11 +3736,8 @@ check_rsp_state:
 			spin_unlock_bh(&cmd->istate_lock);
 
 			if (atomic_read(&conn->check_immediate_queue))
-				goto get_immediate;
-
-			goto get_response;
-		} else
-			conn->tx_response_queue = 0;
+				break;
+		}
 	}
 
 transport_err:
diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h
index cf784cc..8a1d18a 100644
--- a/drivers/target/iscsi/iscsi_target_core.h
+++ b/drivers/target/iscsi/iscsi_target_core.h
@@ -500,8 +500,6 @@ struct iscsi_conn {
 	u8			network_transport;
 	enum iscsi_timer_flags_table nopin_timer_flags;
 	enum iscsi_timer_flags_table nopin_response_timer_flags;
-	u8			tx_immediate_queue;
-	u8			tx_response_queue;
 	/* Used to know what thread encountered a transport failure */
 	u8			which_thread;
 	/* connection id assigned by the Initiator */
diff --git a/drivers/target/iscsi/iscsi_target_erl0.c b/drivers/target/iscsi/iscsi_target_erl0.c
index 1ab0560..dd11520 100644
--- a/drivers/target/iscsi/iscsi_target_erl0.c
+++ b/drivers/target/iscsi/iscsi_target_erl0.c
@@ -640,9 +640,12 @@ static int iscsit_dataout_post_crc_passed(
 
 	cmd->write_data_done += payload_length;
 
-	return (cmd->write_data_done == cmd->data_length) ?
-		DATAOUT_SEND_TO_TRANSPORT : (send_r2t) ?
-		DATAOUT_SEND_R2T : DATAOUT_NORMAL;
+	if (cmd->write_data_done == cmd->data_length)
+		return DATAOUT_SEND_TO_TRANSPORT;
+	else if (send_r2t)
+		return DATAOUT_SEND_R2T;
+	else
+		return DATAOUT_NORMAL;
 }
 
 static int iscsit_dataout_post_crc_failed(
-- 
1.7.4.2

