From: Keith Busch <keith.busch@intel.com>
Date: Wed, 18 Mar 2015 13:32:55 -0600
Subject: NVMe: Asynchronous controller probe
Git-commit: nvme-legacy 537d457349d14e70da2ae5886f95b68e48dc0499
Patch-Mainline: not yet
References: bnc#926056

This performs the longest parts of nvme device probe in scheduled work.
This speeds up probe significantly when multiple devices are in use.

Signed-off-by: Keith Busch <keith.busch@intel.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/block/nvme-core.c | 47 ++++++++++++++++++++++++++++++-----------------
 include/linux/nvme.h      |  1 +
 2 files changed, 31 insertions(+), 17 deletions(-)

diff --git a/drivers/block/nvme-core.c b/drivers/block/nvme-core.c
index 3b00d4e..a312d01 100644
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@ -1372,7 +1372,6 @@ static int nvme_suspend_queue(struct nvme_queue *nvmeq)
 static void nvme_clear_queue(struct nvme_queue *nvmeq)
 {
 	spin_lock_irq(&nvmeq->q_lock);
-	nvme_process_cq(nvmeq);
 	nvme_cancel_ios(nvmeq, false);
 	spin_unlock_irq(&nvmeq->q_lock);
 }
@@ -2882,6 +2881,10 @@ static int nvme_dev_open(struct inode *inode, struct file *f)
 	spin_lock(&dev_list_lock);
 	list_for_each_entry(dev, &dev_list, node) {
 		if (dev->instance == instance) {
+			if (!dev->initialized) {
+				ret = -EWOULDBLOCK;
+				break;
+			}
 			if (!kref_get_unless_zero(&dev->kref))
 				break;
 			f->private_data = dev;
@@ -3026,6 +3029,7 @@ static void nvme_reset_failed_dev(struct work_struct *ws)
 	nvme_dev_reset(dev);
 }
 
+static void nvme_async_probe(struct work_struct *work);
 static int nvme_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	int result = -ENOMEM;
@@ -3060,33 +3064,20 @@ static int nvme_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		goto release;
 
 	kref_init(&dev->kref);
-	result = nvme_dev_start(dev);
-	if (result)
-		goto release_pools;
-
 	dev->device = device_create(nvme_class, &pdev->dev,
 				MKDEV(nvme_char_major, dev->instance),
 				dev, "nvme%d", dev->instance);
 	if (IS_ERR(dev->device)) {
 		result = PTR_ERR(dev->device);
-		goto shutdown;
+		goto release_pools;
 	}
 	get_device(dev->device);
 
-	if (dev->online_queues > 1)
-		result = nvme_dev_add(dev);
-	if (result)
-		goto device_del;
-
-	dev->initialized = 1;
+	INIT_WORK(&dev->probe_work, nvme_async_probe);
+	schedule_work(&dev->probe_work);
 	return 0;
 
- device_del:
-	device_destroy(nvme_class, MKDEV(nvme_char_major, dev->instance));
- shutdown:
-	nvme_dev_shutdown(dev);
  release_pools:
-	nvme_free_queues(dev, 0);
 	nvme_release_prp_pools(dev);
  release:
 	nvme_release_instance(dev);
@@ -3100,6 +3091,27 @@ static int nvme_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	return result;
 }
 
+static void nvme_async_probe(struct work_struct *work)
+{
+	struct nvme_dev *dev = container_of(work, struct nvme_dev, probe_work);
+	int result;
+
+	result = nvme_dev_start(dev);
+	if (result)
+		goto reset;
+
+	if (dev->online_queues > 1)
+		result = nvme_dev_add(dev);
+	if (result)
+		goto reset;
+
+	dev->initialized = 1;
+	return;
+ reset:
+	PREPARE_WORK(&dev->reset_work, nvme_reset_failed_dev);
+	queue_work(nvme_workq, &dev->reset_work);
+}
+
 static void nvme_shutdown(struct pci_dev *pdev)
 {
 	struct nvme_dev *dev = pci_get_drvdata(pdev);
@@ -3115,6 +3127,7 @@ static void nvme_remove(struct pci_dev *pdev)
 	spin_unlock(&dev_list_lock);
 
 	pci_set_drvdata(pdev, NULL);
+	flush_work(&dev->probe_work);
 	flush_work(&dev->reset_work);
 	flush_work(&dev->cpu_work);
 	nvme_dev_shutdown(dev);
diff --git a/include/linux/nvme.h b/include/linux/nvme.h
index f8d53381..5e03fe6 100644
--- a/include/linux/nvme.h
+++ b/include/linux/nvme.h
@@ -88,6 +88,7 @@ struct nvme_dev {
 	struct device *device;
 	struct work_struct reset_work;
 	struct work_struct cpu_work;
+	struct work_struct probe_work;
 	char name[12];
 	char serial[20];
 	char model[40];
-- 
1.8.5.2

