From: Hadar Hen Zion <hadarh@mellanox.com>
Date: Wed, 24 Apr 2013 13:58:45 +0000
Subject: mlx4: Match DMFS promiscuous field names to firmware spec
Patch-mainline: v3.10-rc1
Git-commit: f91625398a2e6e03f0155861b630021ceddb42e7
References: bug#919382 FATE#317529

Align the names used by enum mlx4_net_trans_promisc_mode with the
actual firmware specification.  The patch doesn't introduce any
functional change or API change towards the firmware.

Remove MLX4_FS_PROMISC_FUNCTION_PORT which isn't of use.  Add new
enums MLX4_FS_{UC/MC}_SNIFFER as a preparation step for sniffer
support.

Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
Signed-off-by: Roland Dreier <roland@purestorage.com>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ethernet/mellanox/mlx4/en_ethtool.c |    2 +-
 drivers/net/ethernet/mellanox/mlx4/en_netdev.c  |   16 ++++++++--------
 drivers/net/ethernet/mellanox/mlx4/mcg.c        |   21 ++++++++++-----------
 include/linux/mlx4/device.h                     |   11 ++++++-----
 4 files changed, 25 insertions(+), 25 deletions(-)

--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@ -880,7 +880,7 @@ static int mlx4_en_flow_replace(struct n
 		.queue_mode = MLX4_NET_TRANS_Q_FIFO,
 		.exclusive = 0,
 		.allow_loopback = 1,
-		.promisc_mode = MLX4_FS_PROMISC_NONE,
+		.promisc_mode = MLX4_FS_REGULAR,
 	};
 
 	rule.port = priv->port;
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -127,7 +127,7 @@ static void mlx4_en_filter_work(struct w
 		.queue_mode = MLX4_NET_TRANS_Q_LIFO,
 		.exclusive = 1,
 		.allow_loopback = 1,
-		.promisc_mode = MLX4_FS_PROMISC_NONE,
+		.promisc_mode = MLX4_FS_REGULAR,
 		.port = priv->port,
 		.priority = MLX4_DOMAIN_RFS,
 	};
@@ -444,7 +444,7 @@ static int mlx4_en_uc_steer_add(struct m
 			.queue_mode = MLX4_NET_TRANS_Q_FIFO,
 			.exclusive = 0,
 			.allow_loopback = 1,
-			.promisc_mode = MLX4_FS_PROMISC_NONE,
+			.promisc_mode = MLX4_FS_REGULAR,
 			.priority = MLX4_DOMAIN_NIC,
 		};
 
@@ -821,7 +821,7 @@ static void mlx4_en_do_set_multicast(str
 				err = mlx4_flow_steer_promisc_add(mdev->dev,
 								  priv->port,
 								  priv->base_qpn,
-								  MLX4_FS_PROMISC_UPLINK);
+								  MLX4_FS_ALL_DEFAULT);
 				if (err)
 					en_err(priv, "Failed enabling promiscuous mode\n");
 				priv->flags |= MLX4_EN_FLAG_MC_PROMISC;
@@ -885,7 +885,7 @@ static void mlx4_en_do_set_multicast(str
 		case MLX4_STEERING_MODE_DEVICE_MANAGED:
 			err = mlx4_flow_steer_promisc_remove(mdev->dev,
 							     priv->port,
-							     MLX4_FS_PROMISC_UPLINK);
+							     MLX4_FS_ALL_DEFAULT);
 			if (err)
 				en_err(priv, "Failed disabling promiscuous mode\n");
 			priv->flags &= ~MLX4_EN_FLAG_MC_PROMISC;
@@ -937,7 +937,7 @@ static void mlx4_en_do_set_multicast(str
 				err = mlx4_flow_steer_promisc_add(mdev->dev,
 								  priv->port,
 								  priv->base_qpn,
-								  MLX4_FS_PROMISC_ALL_MULTI);
+								  MLX4_FS_MC_DEFAULT);
 				break;
 
 			case MLX4_STEERING_MODE_B0:
@@ -960,7 +960,7 @@ static void mlx4_en_do_set_multicast(str
 			case MLX4_STEERING_MODE_DEVICE_MANAGED:
 				err = mlx4_flow_steer_promisc_remove(mdev->dev,
 								     priv->port,
-								     MLX4_FS_PROMISC_ALL_MULTI);
+								     MLX4_FS_MC_DEFAULT);
 				break;
 
 			case MLX4_STEERING_MODE_B0:
@@ -1475,10 +1475,10 @@ void mlx4_en_stop_port(struct net_device
 				 MLX4_EN_FLAG_MC_PROMISC);
 		mlx4_flow_steer_promisc_remove(mdev->dev,
 					       priv->port,
-					       MLX4_FS_PROMISC_UPLINK);
+					       MLX4_FS_ALL_DEFAULT);
 		mlx4_flow_steer_promisc_remove(mdev->dev,
 					       priv->port,
-					       MLX4_FS_PROMISC_ALL_MULTI);
+					       MLX4_FS_MC_DEFAULT);
 	} else if (priv->flags & MLX4_EN_FLAG_PROMISC) {
 		priv->flags &= ~MLX4_EN_FLAG_PROMISC;
 
--- a/drivers/net/ethernet/mellanox/mlx4/mcg.c
+++ b/drivers/net/ethernet/mellanox/mlx4/mcg.c
@@ -648,10 +648,11 @@ static void trans_rule_ctrl_to_hw(struct
 				  struct mlx4_net_trans_rule_hw_ctrl *hw)
 {
 	static const u8 __promisc_mode[] = {
-		[MLX4_FS_PROMISC_NONE]   = 0x0,
-		[MLX4_FS_PROMISC_UPLINK] = 0x1,
-		[MLX4_FS_PROMISC_FUNCTION_PORT] = 0x2,
-		[MLX4_FS_PROMISC_ALL_MULTI] = 0x3,
+		[MLX4_FS_REGULAR]	= 0x0,
+		[MLX4_FS_ALL_DEFAULT]	= 0x1,
+		[MLX4_FS_MC_DEFAULT]	= 0x3,
+		[MLX4_FS_UC_SNIFFER]	= 0x4,
+		[MLX4_FS_MC_SNIFFER]	= 0x5,
 	};
 
 	u32 dw = 0;
@@ -1135,7 +1136,7 @@ int mlx4_trans_to_dmfs_attach(struct mlx
 		struct mlx4_net_trans_rule rule = {
 			.queue_mode = MLX4_NET_TRANS_Q_FIFO,
 			.exclusive = 0,
-			.promisc_mode = MLX4_FS_PROMISC_NONE,
+			.promisc_mode = MLX4_FS_REGULAR,
 			.priority = MLX4_DOMAIN_NIC,
 		};
 
@@ -1228,11 +1229,10 @@ int mlx4_flow_steer_promisc_add(struct m
 	u64 *regid_p;
 
 	switch (mode) {
-	case MLX4_FS_PROMISC_UPLINK:
-	case MLX4_FS_PROMISC_FUNCTION_PORT:
+	case MLX4_FS_ALL_DEFAULT:
 		regid_p = &dev->regid_promisc_array[port];
 		break;
-	case MLX4_FS_PROMISC_ALL_MULTI:
+	case MLX4_FS_MC_DEFAULT:
 		regid_p = &dev->regid_allmulti_array[port];
 		break;
 	default:
@@ -1259,11 +1259,10 @@ int mlx4_flow_steer_promisc_remove(struc
 	u64 *regid_p;
 
 	switch (mode) {
-	case MLX4_FS_PROMISC_UPLINK:
-	case MLX4_FS_PROMISC_FUNCTION_PORT:
+	case MLX4_FS_ALL_DEFAULT:
 		regid_p = &dev->regid_promisc_array[port];
 		break;
-	case MLX4_FS_PROMISC_ALL_MULTI:
+	case MLX4_FS_MC_DEFAULT:
 		regid_p = &dev->regid_allmulti_array[port];
 		break;
 	default:
--- a/include/linux/mlx4/device.h
+++ b/include/linux/mlx4/device.h
@@ -887,11 +887,12 @@ static inline int map_hw_to_sw_id(u16 he
 }
 
 enum mlx4_net_trans_promisc_mode {
-	MLX4_FS_PROMISC_NONE = 0,
-	MLX4_FS_PROMISC_UPLINK,
-	/* For future use. Not implemented yet */
-	MLX4_FS_PROMISC_FUNCTION_PORT,
-	MLX4_FS_PROMISC_ALL_MULTI,
+	MLX4_FS_REGULAR = 1,
+	MLX4_FS_ALL_DEFAULT,
+	MLX4_FS_MC_DEFAULT,
+	MLX4_FS_UC_SNIFFER,
+	MLX4_FS_MC_SNIFFER,
+
 };
 
 struct mlx4_spec_eth {
