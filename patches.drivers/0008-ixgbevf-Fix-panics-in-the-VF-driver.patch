From: Greg Rose <gregory.v.rose@intel.com>
Date: Fri, 22 Jan 2010 22:47:18 +0000
Subject: [PATCH 8/20] ixgbevf: Fix panics in the VF driver
References: bnc#699085, fate#311956
Patch-mainline: 2.6.34
Git-commit: c0456c231a8b2981128cc29e211b7bad1bd997df

Fix panics in the VF driver that occur when you bring it down after
having already brought the PF down.

Signed-off-by: Greg Rose <gregory.v.rose@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Lee, Chun-Yi <jlee@novell.com>
Acked-by: Michal Marek <mmarek@suse.cz>

---
 drivers/net/ixgbevf/ixgbevf_main.c |   24 ++++++++++++++++++++----
 1 files changed, 20 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ixgbevf/ixgbevf_main.c b/drivers/net/ixgbevf/ixgbevf_main.c
index bd2fd46..0a27fa1 100644
--- a/drivers/net/ixgbevf/ixgbevf_main.c
+++ b/drivers/net/ixgbevf/ixgbevf_main.c
@@ -1693,8 +1693,10 @@ static void ixgbevf_clean_rx_ring(struct ixgbevf_adapter *adapter,
 	unsigned long size;
 	unsigned int i;
 
-	/* Free all the Rx ring sk_buffs */
+	if (!rx_ring->rx_buffer_info)
+		return;
 
+	/* Free all the Rx ring sk_buffs */
 	for (i = 0; i < rx_ring->count; i++) {
 		struct ixgbevf_rx_buffer *rx_buffer_info;
 
@@ -1751,6 +1753,9 @@ static void ixgbevf_clean_tx_ring(struct ixgbevf_adapter *adapter,
 	unsigned long size;
 	unsigned int i;
 
+	if (!tx_ring->tx_buffer_info)
+		return;
+
 	/* Free all the Tx ring sk_buffs */
 
 	for (i = 0; i < tx_ring->count; i++) {
@@ -1843,12 +1848,24 @@ void ixgbevf_down(struct ixgbevf_adapter *adapter)
 
 void ixgbevf_reinit_locked(struct ixgbevf_adapter *adapter)
 {
+	struct ixgbe_hw *hw = &adapter->hw;
+
 	WARN_ON(in_interrupt());
+
 	while (test_and_set_bit(__IXGBEVF_RESETTING, &adapter->state))
 		msleep(1);
 
-	ixgbevf_down(adapter);
-	ixgbevf_up(adapter);
+	/*
+	 * Check if PF is up before re-init.  If not then skip until
+	 * later when the PF is up and ready to service requests from
+	 * the VF via mailbox.  If the VF is up and running then the
+	 * watchdog task will continue to schedule reset tasks until
+	 * the PF is up and running.
+	 */
+	if (!hw->mac.ops.reset_hw(hw)) {
+		ixgbevf_down(adapter);
+		ixgbevf_up(adapter);
+	}
 
 	clear_bit(__IXGBEVF_RESETTING, &adapter->state);
 }
@@ -2423,7 +2440,6 @@ void ixgbevf_free_tx_resources(struct ixgbevf_adapter *adapter,
 {
 	struct pci_dev *pdev = adapter->pdev;
 
-
 	ixgbevf_clean_tx_ring(adapter, tx_ring);
 
 	vfree(tx_ring->tx_buffer_info);
-- 
1.6.0.2

