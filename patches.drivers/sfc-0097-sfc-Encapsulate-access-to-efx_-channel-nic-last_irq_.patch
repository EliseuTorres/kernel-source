From: Ben Hutchings <bhutchings@solarflare.com>
Date: Tue, 28 Feb 2012 23:37:35 +0000
Subject: sfc: Encapsulate access to efx_{channel,nic}::last_irq_cpu in
 self-test
Patch-mainline: v3.4-rc1
Git-commit: eee6f6a9e0c83811de77a137989d4a3289e297cc
References: bnc#786035 FATE#314299

Cleanup in preparation for doing an event test on ifup.

Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ethernet/sfc/nic.c      |    8 ++++++--
 drivers/net/ethernet/sfc/nic.h      |   13 +++++++++++--
 drivers/net/ethernet/sfc/selftest.c |   14 ++++----------
 3 files changed, 21 insertions(+), 14 deletions(-)

--- a/drivers/net/ethernet/sfc/nic.c
+++ b/drivers/net/ethernet/sfc/nic.c
@@ -1340,8 +1340,10 @@ void efx_nic_remove_eventq(struct efx_ch
 }
 
 
-void efx_nic_generate_test_event(struct efx_channel *channel)
+void efx_nic_event_test_start(struct efx_channel *channel)
 {
+	channel->last_irq_cpu = -1;
+	smp_wmb();
 	efx_magic_event(channel, EFX_CHANNEL_MAGIC_TEST(channel));
 }
 
@@ -1390,8 +1392,10 @@ void efx_nic_disable_interrupts(struct e
  * Interrupt must already have been enabled, otherwise nasty things
  * may happen.
  */
-void efx_nic_generate_interrupt(struct efx_nic *efx)
+void efx_nic_irq_test_start(struct efx_nic *efx)
 {
+	efx->last_irq_cpu = -1;
+	smp_wmb();
 	efx_nic_interrupts(efx, true, true);
 }
 
--- a/drivers/net/ethernet/sfc/nic.h
+++ b/drivers/net/ethernet/sfc/nic.h
@@ -301,14 +301,23 @@ extern void falcon_update_stats_xmac(str
 /* Interrupts and test events */
 extern int efx_nic_init_interrupt(struct efx_nic *efx);
 extern void efx_nic_enable_interrupts(struct efx_nic *efx);
-extern void efx_nic_generate_test_event(struct efx_channel *channel);
-extern void efx_nic_generate_interrupt(struct efx_nic *efx);
+extern void efx_nic_event_test_start(struct efx_channel *channel);
+extern void efx_nic_irq_test_start(struct efx_nic *efx);
 extern void efx_nic_disable_interrupts(struct efx_nic *efx);
 extern void efx_nic_fini_interrupt(struct efx_nic *efx);
 extern irqreturn_t efx_nic_fatal_interrupt(struct efx_nic *efx);
 extern irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id);
 extern void falcon_irq_ack_a1(struct efx_nic *efx);
 
+static inline int efx_nic_event_test_irq_cpu(struct efx_channel *channel)
+{
+	return ACCESS_ONCE(channel->last_irq_cpu);
+}
+static inline int efx_nic_irq_test_irq_cpu(struct efx_nic *efx)
+{
+	return ACCESS_ONCE(efx->last_irq_cpu);
+}
+
 /* Global Resources */
 extern int efx_nic_flush_queues(struct efx_nic *efx);
 extern void siena_prepare_flush(struct efx_nic *efx);
--- a/drivers/net/ethernet/sfc/selftest.c
+++ b/drivers/net/ethernet/sfc/selftest.c
@@ -149,11 +149,7 @@ static int efx_test_interrupts(struct ef
 	netif_dbg(efx, drv, efx->net_dev, "testing interrupts\n");
 	tests->interrupt = -1;
 
-	/* Reset interrupt flag */
-	efx->last_irq_cpu = -1;
-	smp_wmb();
-
-	efx_nic_generate_interrupt(efx);
+	efx_nic_irq_test_start(efx);
 	timeout = jiffies + IRQ_TIMEOUT;
 	wait = 1;
 
@@ -161,7 +157,7 @@ static int efx_test_interrupts(struct ef
 	netif_dbg(efx, drv, efx->net_dev, "waiting for test interrupt\n");
 	do {
 		schedule_timeout_uninterruptible(wait);
-		cpu = ACCESS_ONCE(efx->last_irq_cpu);
+		cpu = efx_nic_irq_test_irq_cpu(efx);
 		if (cpu >= 0)
 			goto success;
 		wait *= 2;
@@ -192,9 +188,7 @@ static int efx_test_eventq_irq(struct ef
 		read_ptr[channel->channel] = channel->eventq_read_ptr;
 		set_bit(channel->channel, &dma_pend);
 		set_bit(channel->channel, &int_pend);
-		channel->last_irq_cpu = -1;
-		smp_wmb();
-		efx_nic_generate_test_event(channel);
+		efx_nic_event_test_start(channel);
 	}
 
 	timeout = jiffies + IRQ_TIMEOUT;
@@ -216,7 +210,7 @@ static int efx_test_eventq_irq(struct ef
 			} else {
 				if (efx_nic_event_present(channel))
 					clear_bit(channel->channel, &dma_pend);
-				if (ACCESS_ONCE(channel->last_irq_cpu) >= 0)
+				if (efx_nic_event_test_irq_cpu(channel) >= 0)
 					clear_bit(channel->channel, &int_pend);
 			}
 			napi_enable(&channel->napi_str);
