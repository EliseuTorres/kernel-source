From: Dan Williams <dan.j.williams@intel.com>
Date: Thu, 30 Jun 2011 16:31:37 -0700
Subject: [PATCH 264/273] isci: unify isci_remote_device and scic_sds_remote_device
Git-commit: 78a6f06e0e82125787d7aa308fe28c2c8381540c
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Remove the distinction between these two implementations and unify on
isci_remote_device (local instances named idev).

Reported-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/host.c                |   60 +++---
 drivers/scsi/isci/host.h                |   27 +--
 drivers/scsi/isci/port.c                |    4 +-
 drivers/scsi/isci/port.h                |    6 +-
 drivers/scsi/isci/remote_device.c       |  396 +++++++++++++++----------------
 drivers/scsi/isci/remote_device.h       |  148 ++++--------
 drivers/scsi/isci/remote_node_context.c |   48 ++--
 drivers/scsi/isci/remote_node_context.h |    2 +-
 drivers/scsi/isci/request.c             |   60 +++---
 drivers/scsi/isci/request.h             |    4 +-
 drivers/scsi/isci/task.c                |   47 ++--
 11 files changed, 365 insertions(+), 437 deletions(-)

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 4e11f9e..45d7f71 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -272,7 +272,7 @@ static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic
 {
 	u32 index;
 	struct isci_request *ireq;
-	struct scic_sds_remote_device *device;
+	struct isci_remote_device *idev;
 
 	index = SCU_GET_COMPLETION_INDEX(completion_entry);
 
@@ -289,9 +289,9 @@ static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC:
-		device = scic->device_table[index];
+		idev = scic->device_table[index];
 		dev_warn(scic_to_dev(scic), "%s: %x for device %p\n",
-			 __func__, completion_entry, device);
+			 __func__, completion_entry, idev);
 		/* @todo For a port RNC operation we need to fail the
 		 * device
 		 */
@@ -312,7 +312,7 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct scu_unsolicited_frame_header *frame_header;
 	struct isci_phy *iphy;
-	struct scic_sds_remote_device *device;
+	struct isci_remote_device *idev;
 
 	enum sci_status result = SCI_FAILURE;
 
@@ -348,12 +348,12 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 			result = scic_sds_phy_frame_handler(iphy, frame_index);
 		} else {
 			if (index < scic->remote_node_entries)
-				device = scic->device_table[index];
+				idev = scic->device_table[index];
 			else
-				device = NULL;
+				idev = NULL;
 
-			if (device != NULL)
-				result = scic_sds_remote_device_frame_handler(device, frame_index);
+			if (idev != NULL)
+				result = scic_sds_remote_device_frame_handler(idev, frame_index);
 			else
 				scic_sds_controller_release_frame(scic, frame_index);
 		}
@@ -370,7 +370,7 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 						 u32 completion_entry)
 {
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct scic_sds_remote_device *device;
+	struct isci_remote_device *idev;
 	struct isci_request *ireq;
 	struct isci_phy *iphy;
 	u32 index;
@@ -426,9 +426,9 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 			break;
 
 		case SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT:
-			device = scic->device_table[index];
-			if (device != NULL)
-				scic_sds_remote_device_event_handler(device, completion_entry);
+			idev = scic->device_table[index];
+			if (idev != NULL)
+				scic_sds_remote_device_event_handler(idev, completion_entry);
 			else
 				dev_warn(scic_to_dev(scic),
 					 "%s: SCIC Controller 0x%p received "
@@ -460,10 +460,10 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
 	case SCU_EVENT_TYPE_RNC_OPS_MISC:
 		if (index < scic->remote_node_entries) {
-			device = scic->device_table[index];
+			idev = scic->device_table[index];
 
-			if (device != NULL)
-				scic_sds_remote_device_event_handler(device, completion_entry);
+			if (idev != NULL)
+				scic_sds_remote_device_event_handler(idev, completion_entry);
 		} else
 			dev_err(scic_to_dev(scic),
 				"%s: SCIC Controller 0x%p received event 0x%x "
@@ -2549,13 +2549,13 @@ static bool scic_sds_controller_has_remote_devices_stopping(
  * object that the remote device has stopped.
  */
 void scic_sds_controller_remote_device_stopped(struct scic_sds_controller *scic,
-					       struct scic_sds_remote_device *sci_dev)
+					       struct isci_remote_device *idev)
 {
 	if (scic->sm.current_state_id != SCIC_STOPPING) {
 		dev_dbg(scic_to_dev(scic),
 			"SCIC Controller 0x%p remote device stopped event "
 			"from device 0x%p in unexpected state %d\n",
-			scic, sci_dev,
+			scic, idev,
 			scic->sm.current_state_id);
 		return;
 	}
@@ -2622,18 +2622,18 @@ struct isci_request *scic_request_by_tag(struct scic_sds_controller *scic, u16 i
  */
 enum sci_status scic_sds_controller_allocate_remote_node_context(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u16 *node_id)
 {
 	u16 node_index;
-	u32 remote_node_count = scic_sds_remote_device_node_count(sci_dev);
+	u32 remote_node_count = scic_sds_remote_device_node_count(idev);
 
 	node_index = scic_sds_remote_node_table_allocate_remote_node(
 		&scic->available_remote_nodes, remote_node_count
 		);
 
 	if (node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
-		scic->device_table[node_index] = sci_dev;
+		scic->device_table[node_index] = idev;
 
 		*node_id = node_index;
 
@@ -2654,12 +2654,12 @@ enum sci_status scic_sds_controller_allocate_remote_node_context(
  */
 void scic_sds_controller_free_remote_node_context(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u16 node_id)
 {
-	u32 remote_node_count = scic_sds_remote_device_node_count(sci_dev);
+	u32 remote_node_count = scic_sds_remote_device_node_count(idev);
 
-	if (scic->device_table[node_id] == sci_dev) {
+	if (scic->device_table[node_id] == idev) {
 		scic->device_table[node_id] = NULL;
 
 		scic_sds_remote_node_table_release_remote_node_index(
@@ -2798,7 +2798,7 @@ enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag)
  *    user desires to be utilized for this request.
  */
 enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
-					 struct scic_sds_remote_device *rdev,
+					 struct isci_remote_device *idev,
 					 struct isci_request *ireq)
 {
 	enum sci_status status;
@@ -2808,7 +2808,7 @@ enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_device_start_io(scic, rdev, ireq);
+	status = scic_sds_remote_device_start_io(scic, idev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -2835,7 +2835,7 @@ enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
  */
 enum sci_status scic_controller_terminate_request(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *rdev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq)
 {
 	enum sci_status status;
@@ -2873,7 +2873,7 @@ enum sci_status scic_controller_terminate_request(
  */
 enum sci_status scic_controller_complete_io(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *rdev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq)
 {
 	enum sci_status status;
@@ -2884,7 +2884,7 @@ enum sci_status scic_controller_complete_io(
 		/* XXX: Implement this function */
 		return SCI_FAILURE;
 	case SCIC_READY:
-		status = scic_sds_remote_device_complete_io(scic, rdev, ireq);
+		status = scic_sds_remote_device_complete_io(scic, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -2923,7 +2923,7 @@ enum sci_status scic_controller_continue_io(struct isci_request *ireq)
  */
 enum sci_task_status scic_controller_start_task(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *rdev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq)
 {
 	enum sci_status status;
@@ -2936,7 +2936,7 @@ enum sci_task_status scic_controller_start_task(
 		return SCI_TASK_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_device_start_task(scic, rdev, ireq);
+	status = scic_sds_remote_device_start_task(scic, idev, ireq);
 	switch (status) {
 	case SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS:
 		set_bit(IREQ_ACTIVE, &ireq->flags);
diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index fb8048e..ca2e3b0 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -163,7 +163,7 @@ struct scic_sds_controller {
 	 * objects that need to handle device completion notifications from the
 	 * hardware. The table is RNi based.
 	 */
-	struct scic_sds_remote_device *device_table[SCI_MAX_REMOTE_DEVICES];
+	struct isci_remote_device *device_table[SCI_MAX_REMOTE_DEVICES];
 
 	/**
 	 * This field is the free RNi data structure
@@ -488,12 +488,12 @@ static inline struct isci_host *scic_to_ihost(struct scic_sds_controller *scic)
 #define ISCI_TAG_TCI(tag) ((tag) & (SCI_MAX_IO_REQUESTS-1))
 
 /* expander attached sata devices require 3 rnc slots */
-static inline int scic_sds_remote_device_node_count(struct scic_sds_remote_device *sci_dev)
+static inline int scic_sds_remote_device_node_count(struct isci_remote_device *idev)
 {
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct domain_device *dev = idev->domain_dev;
 
 	if ((dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) &&
-	    !sci_dev->is_direct_attached)
+	    !idev->is_direct_attached)
 		return SCU_STP_REMOTE_NODE_COUNT;
 	return SCU_SSP_REMOTE_NODE_COUNT;
 }
@@ -541,11 +541,8 @@ static inline struct device *sciport_to_dev(struct isci_port *iport)
 	return &iport->isci_host->pdev->dev;
 }
 
-static inline struct device *scirdev_to_dev(struct scic_sds_remote_device *sci_dev)
+static inline struct device *scirdev_to_dev(struct isci_remote_device *idev)
 {
-	struct isci_remote_device *idev =
-			container_of(sci_dev, typeof(*idev), sci);
-
 	if (!idev || !idev->isci_port || !idev->isci_port->isci_host)
 		return NULL;
 
@@ -589,11 +586,11 @@ void scic_sds_controller_copy_sata_response(void *response_buffer,
 					    void *frame_header,
 					    void *frame_buffer);
 enum sci_status scic_sds_controller_allocate_remote_node_context(struct scic_sds_controller *scic,
-								 struct scic_sds_remote_device *sci_dev,
+								 struct isci_remote_device *idev,
 								 u16 *node_id);
 void scic_sds_controller_free_remote_node_context(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u16 node_id);
 union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffer(
 	struct scic_sds_controller *scic,
@@ -622,7 +619,7 @@ void scic_sds_controller_link_down(
 
 void scic_sds_controller_remote_device_stopped(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *sci_dev);
+	struct isci_remote_device *idev);
 
 void scic_sds_controller_copy_task_context(
 	struct scic_sds_controller *scic,
@@ -662,22 +659,22 @@ void scic_controller_disable_interrupts(
 
 enum sci_status scic_controller_start_io(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *remote_device,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_task_status scic_controller_start_task(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *remote_device,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_status scic_controller_terminate_request(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *remote_device,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_status scic_controller_complete_io(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *remote_device,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 void scic_sds_port_configuration_agent_construct(
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 0459188..df37b1b 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1541,7 +1541,7 @@ enum sci_status scic_sds_port_link_down(struct isci_port *iport,
 }
 
 enum sci_status scic_sds_port_start_io(struct isci_port *iport,
-				       struct scic_sds_remote_device *sci_dev,
+				       struct isci_remote_device *idev,
 				       struct isci_request *ireq)
 {
 	enum scic_sds_port_states state;
@@ -1561,7 +1561,7 @@ enum sci_status scic_sds_port_start_io(struct isci_port *iport,
 }
 
 enum sci_status scic_sds_port_complete_io(struct isci_port *iport,
-					  struct scic_sds_remote_device *sci_dev,
+					  struct isci_remote_device *idev,
 					  struct isci_request *ireq)
 {
 	enum scic_sds_port_states state;
diff --git a/drivers/scsi/isci/port.h b/drivers/scsi/isci/port.h
index cdea48e..b9bc89b 100644
--- a/drivers/scsi/isci/port.h
+++ b/drivers/scsi/isci/port.h
@@ -283,15 +283,15 @@ enum sci_status scic_sds_port_link_down(struct isci_port *iport,
 					struct isci_phy *iphy);
 
 struct isci_request;
-struct scic_sds_remote_device;
+struct isci_remote_device;
 enum sci_status scic_sds_port_start_io(
 	struct isci_port *iport,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_status scic_sds_port_complete_io(
 	struct isci_port *iport,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sas_linkrate scic_sds_port_get_max_allowed_speed(
diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 627cf73..3b02340 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -93,7 +93,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 				__func__, idev, ireq);
 
 			scic_controller_terminate_request(&ihost->sci,
-							  &idev->sci,
+							  idev,
 							  ireq);
 		}
 		/* Fall through into the default case... */
@@ -127,15 +127,15 @@ static void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote
  */
 static void rnc_destruct_done(void *_dev)
 {
-	struct scic_sds_remote_device *sci_dev = _dev;
+	struct isci_remote_device *idev = _dev;
 
-	BUG_ON(sci_dev->started_request_count != 0);
-	sci_change_state(&sci_dev->sm, SCI_DEV_STOPPED);
+	BUG_ON(idev->started_request_count != 0);
+	sci_change_state(&idev->sm, SCI_DEV_STOPPED);
 }
 
-static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds_remote_device *sci_dev)
+static enum sci_status scic_sds_remote_device_terminate_requests(struct isci_remote_device *idev)
 {
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	enum sci_status status  = SCI_SUCCESS;
 	u32 i;
@@ -145,10 +145,10 @@ static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds
 		enum sci_status s;
 
 		if (!test_bit(IREQ_ACTIVE, &ireq->flags) ||
-		    ireq->target_device != sci_dev)
+		    ireq->target_device != idev)
 			continue;
 
-		s = scic_controller_terminate_request(scic, sci_dev, ireq);
+		s = scic_controller_terminate_request(scic, idev, ireq);
 		if (s != SCI_SUCCESS)
 			status = s;
 	}
@@ -156,10 +156,10 @@ static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds
 	return status;
 }
 
-enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
+enum sci_status scic_remote_device_stop(struct isci_remote_device *idev,
 					u32 timeout)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
@@ -167,16 +167,16 @@ enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
 	case SCI_DEV_FAILED:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_STOPPED:
 		return SCI_SUCCESS;
 	case SCI_DEV_STARTING:
 		/* device not started so there had better be no requests */
-		BUG_ON(sci_dev->started_request_count != 0);
-		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-						      rnc_destruct_done, sci_dev);
+		BUG_ON(idev->started_request_count != 0);
+		scic_sds_remote_node_context_destruct(&idev->rnc,
+						      rnc_destruct_done, idev);
 		/* Transition to the stopping state and wait for the
 		 * remote node to complete being posted and invalidated.
 		 */
@@ -191,28 +191,28 @@ enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
 	case SCI_SMP_DEV_IDLE:
 	case SCI_SMP_DEV_CMD:
 		sci_change_state(sm, SCI_DEV_STOPPING);
-		if (sci_dev->started_request_count == 0) {
-			scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-							      rnc_destruct_done, sci_dev);
+		if (idev->started_request_count == 0) {
+			scic_sds_remote_node_context_destruct(&idev->rnc,
+							      rnc_destruct_done, idev);
 			return SCI_SUCCESS;
 		} else
-			return scic_sds_remote_device_terminate_requests(sci_dev);
+			return scic_sds_remote_device_terminate_requests(idev);
 		break;
 	case SCI_DEV_STOPPING:
 		/* All requests should have been terminated, but if there is an
 		 * attempt to stop a device already in the stopping state, then
 		 * try again to terminate.
 		 */
-		return scic_sds_remote_device_terminate_requests(sci_dev);
+		return scic_sds_remote_device_terminate_requests(idev);
 	case SCI_DEV_RESETTING:
 		sci_change_state(sm, SCI_DEV_STOPPING);
 		return SCI_SUCCESS;
 	}
 }
 
-enum sci_status scic_remote_device_reset(struct scic_sds_remote_device *sci_dev)
+enum sci_status scic_remote_device_reset(struct isci_remote_device *idev)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
@@ -226,7 +226,7 @@ enum sci_status scic_remote_device_reset(struct scic_sds_remote_device *sci_dev)
 	case SCI_DEV_RESETTING:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
@@ -240,13 +240,13 @@ enum sci_status scic_remote_device_reset(struct scic_sds_remote_device *sci_dev)
 	}
 }
 
-enum sci_status scic_remote_device_reset_complete(struct scic_sds_remote_device *sci_dev)
+enum sci_status scic_remote_device_reset_complete(struct isci_remote_device *idev)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	if (state != SCI_DEV_RESETTING) {
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -255,28 +255,28 @@ enum sci_status scic_remote_device_reset_complete(struct scic_sds_remote_device
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_remote_device_suspend(struct scic_sds_remote_device *sci_dev,
+enum sci_status scic_sds_remote_device_suspend(struct isci_remote_device *idev,
 					       u32 suspend_type)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	if (state != SCI_STP_DEV_CMD) {
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	return scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+	return scic_sds_remote_node_context_suspend(&idev->rnc,
 						    suspend_type, NULL, NULL);
 }
 
-enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_device *sci_dev,
+enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *idev,
 						     u32 frame_index)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 	enum sci_status status;
 
 	switch (state) {
@@ -287,7 +287,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 	case SCI_SMP_DEV_IDLE:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		/* Return the frame back to the controller */
 		scic_sds_controller_release_frame(scic, frame_index);
@@ -313,7 +313,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		sci_swab32_cpy(&hdr, frame_header, word_cnt);
 
 		ireq = scic_request_by_tag(scic, be16_to_cpu(hdr.tag));
-		if (ireq && ireq->target_device == sci_dev) {
+		if (ireq && ireq->target_device == idev) {
 			/* The IO request is now in charge of releasing the frame */
 			status = scic_sds_io_request_frame_handler(ireq, frame_index);
 		} else {
@@ -335,7 +335,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 
 		if (hdr->fis_type == FIS_SETDEVBITS &&
 		    (hdr->status & ATA_ERR)) {
-			sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
+			idev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
 
 			/* TODO Check sactive and complete associated IO if any. */
 			sci_change_state(sm, SCI_STP_DEV_NCQ_ERROR);
@@ -345,8 +345,8 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 			 * Some devices return D2H FIS when an NCQ error is detected.
 			 * Treat this like an SDB error FIS ready reason.
 			 */
-			sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
-			sci_change_state(&sci_dev->sm, SCI_STP_DEV_NCQ_ERROR);
+			idev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
+			sci_change_state(&idev->sm, SCI_STP_DEV_NCQ_ERROR);
 		} else
 			status = SCI_FAILURE;
 
@@ -359,17 +359,17 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		 * in this state.  All unsolicited frames are forwarded to the io request
 		 * object.
 		 */
-		status = scic_sds_io_request_frame_handler(sci_dev->working_request, frame_index);
+		status = scic_sds_io_request_frame_handler(idev->working_request, frame_index);
 		break;
 	}
 
 	return status;
 }
 
-static bool is_remote_device_ready(struct scic_sds_remote_device *sci_dev)
+static bool is_remote_device_ready(struct isci_remote_device *idev)
 {
 
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
@@ -387,10 +387,10 @@ static bool is_remote_device_ready(struct scic_sds_remote_device *sci_dev)
 	}
 }
 
-enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_device *sci_dev,
+enum sci_status scic_sds_remote_device_event_handler(struct isci_remote_device *idev,
 						     u32 event_code)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	enum sci_status status;
 
@@ -398,21 +398,21 @@ enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_devi
 	case SCU_EVENT_TYPE_RNC_OPS_MISC:
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
-		status = scic_sds_remote_node_context_event_handler(&sci_dev->rnc, event_code);
+		status = scic_sds_remote_node_context_event_handler(&idev->rnc, event_code);
 		break;
 	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
 		if (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {
 			status = SCI_SUCCESS;
 
 			/* Suspend the associated RNC */
-			scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+			scic_sds_remote_node_context_suspend(&idev->rnc,
 							      SCI_SOFTWARE_SUSPENSION,
 							      NULL, NULL);
 
-			dev_dbg(scirdev_to_dev(sci_dev),
+			dev_dbg(scirdev_to_dev(idev),
 				"%s: device: %p event code: %x: %s\n",
-				__func__, sci_dev, event_code,
-				is_remote_device_ready(sci_dev)
+				__func__, idev, event_code,
+				is_remote_device_ready(idev)
 				? "I_T_Nexus_Timeout event"
 				: "I_T_Nexus_Timeout event in wrong state");
 
@@ -420,10 +420,10 @@ enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_devi
 		}
 	/* Else, fall through and treat as unhandled... */
 	default:
-		dev_dbg(scirdev_to_dev(sci_dev),
+		dev_dbg(scirdev_to_dev(idev),
 			"%s: device: %p event code: %x: %s\n",
-			__func__, sci_dev, event_code,
-			is_remote_device_ready(sci_dev)
+			__func__, idev, event_code,
+			is_remote_device_ready(idev)
 			? "unexpected event"
 			: "unexpected event in wrong state");
 		status = SCI_FAILURE_INVALID_STATE;
@@ -440,34 +440,34 @@ enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_devi
 		 */
 		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
 		    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)
-			status = scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
+			status = scic_sds_remote_node_context_resume(&idev->rnc, NULL, NULL);
 	}
 
 	return status;
 }
 
-static void scic_sds_remote_device_start_request(struct scic_sds_remote_device *sci_dev,
+static void scic_sds_remote_device_start_request(struct isci_remote_device *idev,
 						 struct isci_request *ireq,
 						 enum sci_status status)
 {
-	struct isci_port *iport = sci_dev->owning_port;
+	struct isci_port *iport = idev->owning_port;
 
 	/* cleanup requests that failed after starting on the port */
 	if (status != SCI_SUCCESS)
-		scic_sds_port_complete_io(iport, sci_dev, ireq);
+		scic_sds_port_complete_io(iport, idev, ireq);
 	else {
-		kref_get(&sci_dev_to_idev(sci_dev)->kref);
-		scic_sds_remote_device_increment_request_count(sci_dev);
+		kref_get(&idev->kref);
+		scic_sds_remote_device_increment_request_count(idev);
 	}
 }
 
 enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic,
-						struct scic_sds_remote_device *sci_dev,
+						struct isci_remote_device *idev,
 						struct isci_request *ireq)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct isci_port *iport = sci_dev->owning_port;
+	struct isci_port *iport = idev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -480,7 +480,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	case SCI_DEV_RESETTING:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
@@ -489,11 +489,11 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		 * successful it will start the request for the port object then
 		 * increment its own request count.
 		 */
-		status = scic_sds_port_start_io(iport, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
+		status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -511,11 +511,11 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		enum scic_sds_remote_device_states new_state;
 		struct sas_task *task = isci_request_access_task(ireq);
 
-		status = scic_sds_port_start_io(iport, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
+		status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -526,7 +526,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		if (task->ata_task.use_ncq)
 			new_state = SCI_STP_DEV_NCQ;
 		else {
-			sci_dev->working_request = ireq;
+			idev->working_request = ireq;
 			new_state = SCI_STP_DEV_CMD;
 		}
 		sci_change_state(sm, new_state);
@@ -536,11 +536,11 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		struct sas_task *task = isci_request_access_task(ireq);
 
 		if (task->ata_task.use_ncq) {
-			status = scic_sds_port_start_io(iport, sci_dev, ireq);
+			status = scic_sds_port_start_io(iport, idev, ireq);
 			if (status != SCI_SUCCESS)
 				return status;
 
-			status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
+			status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
 			if (status != SCI_SUCCESS)
 				break;
 
@@ -552,11 +552,11 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	case SCI_STP_DEV_AWAIT_RESET:
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 	case SCI_SMP_DEV_IDLE:
-		status = scic_sds_port_start_io(iport, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
+		status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -564,8 +564,8 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		if (status != SCI_SUCCESS)
 			break;
 
-		sci_dev->working_request = ireq;
-		sci_change_state(&sci_dev->sm, SCI_SMP_DEV_CMD);
+		idev->working_request = ireq;
+		sci_change_state(&idev->sm, SCI_SMP_DEV_CMD);
 		break;
 	case SCI_STP_DEV_CMD:
 	case SCI_SMP_DEV_CMD:
@@ -575,12 +575,12 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	scic_sds_remote_device_start_request(sci_dev, ireq, status);
+	scic_sds_remote_device_start_request(idev, ireq, status);
 	return status;
 }
 
 static enum sci_status common_complete_io(struct isci_port *iport,
-					  struct scic_sds_remote_device *sci_dev,
+					  struct isci_remote_device *idev,
 					  struct isci_request *ireq)
 {
 	enum sci_status status;
@@ -589,21 +589,21 @@ static enum sci_status common_complete_io(struct isci_port *iport,
 	if (status != SCI_SUCCESS)
 		return status;
 
-	status = scic_sds_port_complete_io(iport, sci_dev, ireq);
+	status = scic_sds_port_complete_io(iport, idev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
-	scic_sds_remote_device_decrement_request_count(sci_dev);
+	scic_sds_remote_device_decrement_request_count(idev);
 	return status;
 }
 
 enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *scic,
-						   struct scic_sds_remote_device *sci_dev,
+						   struct isci_remote_device *idev,
 						   struct isci_request *ireq)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct isci_port *iport = sci_dev->owning_port;
+	struct isci_port *iport = idev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -615,18 +615,18 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 	case SCI_DEV_FAILED:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
 	case SCI_STP_DEV_AWAIT_RESET:
 	case SCI_DEV_RESETTING:
-		status = common_complete_io(iport, sci_dev, ireq);
+		status = common_complete_io(iport, idev, ireq);
 		break;
 	case SCI_STP_DEV_CMD:
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
-		status = common_complete_io(iport, sci_dev, ireq);
+		status = common_complete_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -637,54 +637,54 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 			 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE".
 			 */
 			sci_change_state(sm, SCI_STP_DEV_AWAIT_RESET);
-		} else if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
+		} else if (scic_sds_remote_device_get_request_count(idev) == 0)
 			sci_change_state(sm, SCI_STP_DEV_IDLE);
 		break;
 	case SCI_SMP_DEV_CMD:
-		status = common_complete_io(iport, sci_dev, ireq);
+		status = common_complete_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 		sci_change_state(sm, SCI_SMP_DEV_IDLE);
 		break;
 	case SCI_DEV_STOPPING:
-		status = common_complete_io(iport, sci_dev, ireq);
+		status = common_complete_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
-			scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+		if (scic_sds_remote_device_get_request_count(idev) == 0)
+			scic_sds_remote_node_context_destruct(&idev->rnc,
 							      rnc_destruct_done,
-							      sci_dev);
+							      idev);
 		break;
 	}
 
 	if (status != SCI_SUCCESS)
-		dev_err(scirdev_to_dev(sci_dev),
+		dev_err(scirdev_to_dev(idev),
 			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
 			"could not complete\n", __func__, iport,
-			sci_dev, ireq, status);
+			idev, ireq, status);
 	else
-		isci_put_device(sci_dev_to_idev(sci_dev));
+		isci_put_device(idev);
 
 	return status;
 }
 
 static void scic_sds_remote_device_continue_request(void *dev)
 {
-	struct scic_sds_remote_device *sci_dev = dev;
+	struct isci_remote_device *idev = dev;
 
 	/* we need to check if this request is still valid to continue. */
-	if (sci_dev->working_request)
-		scic_controller_continue_io(sci_dev->working_request);
+	if (idev->working_request)
+		scic_controller_continue_io(idev->working_request);
 }
 
 enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *scic,
-						  struct scic_sds_remote_device *sci_dev,
+						  struct isci_remote_device *idev,
 						  struct isci_request *ireq)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct isci_port *iport = sci_dev->owning_port;
+	struct isci_port *iport = idev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -698,7 +698,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 	case SCI_DEV_RESETTING:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_STP_DEV_IDLE:
@@ -706,11 +706,11 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
 	case SCI_STP_DEV_AWAIT_RESET:
-		status = scic_sds_port_start_io(iport, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_task(&sci_dev->rnc, ireq);
+		status = scic_sds_remote_node_context_start_task(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			goto out;
 
@@ -722,7 +722,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 		 * replace the request that probably resulted in the task
 		 * management request.
 		 */
-		sci_dev->working_request = ireq;
+		idev->working_request = ireq;
 		sci_change_state(sm, SCI_STP_DEV_CMD);
 
 		/* The remote node context must cleanup the TCi to NCQ mapping
@@ -732,32 +732,32 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 		 * the correct action when the remote node context is suspended
 		 * and later resumed.
 		 */
-		scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+		scic_sds_remote_node_context_suspend(&idev->rnc,
 				SCI_SOFTWARE_SUSPENSION, NULL, NULL);
-		scic_sds_remote_node_context_resume(&sci_dev->rnc,
+		scic_sds_remote_node_context_resume(&idev->rnc,
 				scic_sds_remote_device_continue_request,
-						    sci_dev);
+						    idev);
 
 	out:
-		scic_sds_remote_device_start_request(sci_dev, ireq, status);
+		scic_sds_remote_device_start_request(idev, ireq, status);
 		/* We need to let the controller start request handler know that
 		 * it can't post TC yet. We will provide a callback function to
 		 * post TC when RNC gets resumed.
 		 */
 		return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
 	case SCI_DEV_READY:
-		status = scic_sds_port_start_io(iport, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_task(&sci_dev->rnc, ireq);
+		status = scic_sds_remote_node_context_start_task(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
 		status = scic_sds_request_start(ireq);
 		break;
 	}
-	scic_sds_remote_device_start_request(sci_dev, ireq, status);
+	scic_sds_remote_device_start_request(idev, ireq, status);
 
 	return status;
 }
@@ -771,15 +771,15 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
  * request and then requests the controller to post the request. none
  */
 void scic_sds_remote_device_post_request(
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u32 request)
 {
 	u32 context;
 
-	context = scic_sds_remote_device_build_command_context(sci_dev, request);
+	context = scic_sds_remote_device_build_command_context(idev, request);
 
 	scic_sds_controller_post_request(
-		scic_sds_remote_device_get_controller(sci_dev),
+		scic_sds_remote_device_get_controller(idev),
 		context
 		);
 }
@@ -790,34 +790,33 @@ void scic_sds_remote_device_post_request(
  */
 static void remote_device_resume_done(void *_dev)
 {
-	struct scic_sds_remote_device *sci_dev = _dev;
+	struct isci_remote_device *idev = _dev;
 
-	if (is_remote_device_ready(sci_dev))
+	if (is_remote_device_ready(idev))
 		return;
 
 	/* go 'ready' if we are not already in a ready state */
-	sci_change_state(&sci_dev->sm, SCI_DEV_READY);
+	sci_change_state(&idev->sm, SCI_DEV_READY);
 }
 
 static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)
 {
-	struct scic_sds_remote_device *sci_dev = _dev;
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	struct isci_remote_device *idev = _dev;
+	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 
 	/* For NCQ operation we do not issue a isci_remote_device_not_ready().
 	 * As a result, avoid sending the ready notification.
 	 */
-	if (sci_dev->sm.previous_state_id != SCI_STP_DEV_NCQ)
+	if (idev->sm.previous_state_id != SCI_STP_DEV_NCQ)
 		isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
 static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
 	/* Initial state is a transitional state to the stopped state */
-	sci_change_state(&sci_dev->sm, SCI_DEV_STOPPED);
+	sci_change_state(&idev->sm, SCI_DEV_STOPPED);
 }
 
 /**
@@ -833,22 +832,22 @@ static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_mac
  * device isn't valid (e.g. it's already been destoryed, the handle isn't
  * valid, etc.).
  */
-static enum sci_status scic_remote_device_destruct(struct scic_sds_remote_device *sci_dev)
+static enum sci_status scic_remote_device_destruct(struct isci_remote_device *idev)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_controller *scic;
 
 	if (state != SCI_DEV_STOPPED) {
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	scic = sci_dev->owning_port->owning_controller;
-	scic_sds_controller_free_remote_node_context(scic, sci_dev,
-						     sci_dev->rnc.remote_node_index);
-	sci_dev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
+	scic = idev->owning_port->owning_controller;
+	scic_sds_controller_free_remote_node_context(scic, idev,
+						     idev->rnc.remote_node_index);
+	idev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
 	sci_change_state(sm, SCI_DEV_FINAL);
 
 	return SCI_SUCCESS;
@@ -871,34 +870,32 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 	 * io requests in process */
 	BUG_ON(!list_empty(&idev->reqs_in_process));
 
-	scic_remote_device_destruct(&idev->sci);
+	scic_remote_device_destruct(idev);
 	list_del_init(&idev->node);
 	isci_put_device(idev);
 }
 
 static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 	u32 prev_state;
 
 	/* If we are entering from the stopping state let the SCI User know that
 	 * the stop operation has completed.
 	 */
-	prev_state = sci_dev->sm.previous_state_id;
+	prev_state = idev->sm.previous_state_id;
 	if (prev_state == SCI_DEV_STOPPING)
 		isci_remote_device_deconstruct(scic_to_ihost(scic), idev);
 
-	scic_sds_controller_remote_device_stopped(scic, sci_dev);
+	scic_sds_controller_remote_device_stopped(scic, idev);
 }
 
 static void scic_sds_remote_device_starting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
 	isci_remote_device_not_ready(ihost, idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
@@ -906,27 +903,25 @@ static void scic_sds_remote_device_starting_state_enter(struct sci_base_state_ma
 
 static void scic_sds_remote_device_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 	struct domain_device *dev = idev->domain_dev;
 
 	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
-		sci_change_state(&sci_dev->sm, SCI_STP_DEV_IDLE);
+		sci_change_state(&idev->sm, SCI_STP_DEV_IDLE);
 	} else if (dev_is_expander(dev)) {
-		sci_change_state(&sci_dev->sm, SCI_SMP_DEV_IDLE);
+		sci_change_state(&idev->sm, SCI_SMP_DEV_IDLE);
 	} else
 		isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
 static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct domain_device *dev = idev->domain_dev;
 
 	if (dev->dev_type == SAS_END_DEV) {
-		struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
-		struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+		struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 
 		isci_remote_device_not_ready(scic_to_ihost(scic), idev,
 					     SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);
@@ -935,82 +930,81 @@ static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machin
 
 static void scic_sds_remote_device_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
 	scic_sds_remote_node_context_suspend(
-		&sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
+		&idev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
 }
 
 static void scic_sds_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
-	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
+	scic_sds_remote_node_context_resume(&idev->rnc, NULL, NULL);
 }
 
 static void scic_sds_stp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
-	sci_dev->working_request = NULL;
-	if (scic_sds_remote_node_context_is_ready(&sci_dev->rnc)) {
+	idev->working_request = NULL;
+	if (scic_sds_remote_node_context_is_ready(&idev->rnc)) {
 		/*
 		 * Since the RNC is ready, it's alright to finish completion
 		 * processing (e.g. signal the remote device is ready). */
-		scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(sci_dev);
+		scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(idev);
 	} else {
-		scic_sds_remote_node_context_resume(&sci_dev->rnc,
+		scic_sds_remote_node_context_resume(&idev->rnc,
 			scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler,
-			sci_dev);
+			idev);
 	}
 }
 
 static void scic_sds_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
 
-	BUG_ON(sci_dev->working_request == NULL);
+	BUG_ON(idev->working_request == NULL);
 
-	isci_remote_device_not_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev),
+	isci_remote_device_not_ready(scic_to_ihost(scic), idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
 }
 
 static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
 
-	if (sci_dev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
+	if (idev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
 		isci_remote_device_not_ready(scic_to_ihost(scic), idev,
-					     sci_dev->not_ready_reason);
+					     idev->not_ready_reason);
 }
 
 static void scic_sds_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
 
-	isci_remote_device_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev));
+	isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
 static void scic_sds_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
 
-	BUG_ON(sci_dev->working_request == NULL);
+	BUG_ON(idev->working_request == NULL);
 
-	isci_remote_device_not_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev),
+	isci_remote_device_not_ready(scic_to_ihost(scic), idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
 }
 
 static void scic_sds_smp_remote_device_ready_cmd_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
-	sci_dev->working_request = NULL;
+	idev->working_request = NULL;
 }
 
 static const struct sci_base_state scic_sds_remote_device_state_table[] = {
@@ -1065,14 +1059,14 @@ static const struct sci_base_state scic_sds_remote_device_state_table[] = {
  * frees the remote_node_context(s) for the device.
  */
 static void scic_remote_device_construct(struct isci_port *iport,
-				  struct scic_sds_remote_device *sci_dev)
+				  struct isci_remote_device *idev)
 {
-	sci_dev->owning_port = iport;
-	sci_dev->started_request_count = 0;
+	idev->owning_port = iport;
+	idev->started_request_count = 0;
 
-	sci_init_sm(&sci_dev->sm, scic_sds_remote_device_state_table, SCI_DEV_INITIAL);
+	sci_init_sm(&idev->sm, scic_sds_remote_device_state_table, SCI_DEV_INITIAL);
 
-	scic_sds_remote_node_context_construct(&sci_dev->rnc,
+	scic_sds_remote_node_context_construct(&idev->rnc,
 					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
 }
 
@@ -1091,21 +1085,21 @@ static void scic_remote_device_construct(struct isci_port *iport,
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
 static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
-						       struct scic_sds_remote_device *sci_dev)
+						       struct isci_remote_device *idev)
 {
 	enum sci_status status;
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct domain_device *dev = idev->domain_dev;
 
-	scic_remote_device_construct(iport, sci_dev);
+	scic_remote_device_construct(iport, idev);
 
 	/*
 	 * This information is request to determine how many remote node context
 	 * entries will be needed to store the remote node.
 	 */
-	sci_dev->is_direct_attached = true;
+	idev->is_direct_attached = true;
 	status = scic_sds_controller_allocate_remote_node_context(iport->owning_controller,
-								  sci_dev,
-								  &sci_dev->rnc.remote_node_index);
+								  idev,
+								  &idev->rnc.remote_node_index);
 
 	if (status != SCI_SUCCESS)
 		return status;
@@ -1116,10 +1110,10 @@ static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
 	else
 		return SCI_FAILURE_UNSUPPORTED_PROTOCOL;
 
-	sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(iport);
+	idev->connection_rate = scic_sds_port_get_max_allowed_speed(iport);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
-	sci_dev->device_port_width = 1;
+	idev->device_port_width = 1;
 
 	return SCI_SUCCESS;
 }
@@ -1137,16 +1131,16 @@ static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
 static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
-						       struct scic_sds_remote_device *sci_dev)
+						       struct isci_remote_device *idev)
 {
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct domain_device *dev = idev->domain_dev;
 	enum sci_status status;
 
-	scic_remote_device_construct(iport, sci_dev);
+	scic_remote_device_construct(iport, idev);
 
 	status = scic_sds_controller_allocate_remote_node_context(iport->owning_controller,
-								  sci_dev,
-								  &sci_dev->rnc.remote_node_index);
+								  idev,
+								  &idev->rnc.remote_node_index);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -1163,11 +1157,11 @@ static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
 	 * connection the logical link rate is that same as the
 	 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
 	 * one another, so this code works for both situations. */
-	sci_dev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(iport),
+	idev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(iport),
 					 dev->linkrate);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
-	sci_dev->device_port_width = 1;
+	idev->device_port_width = 1;
 
 	return SCI_SUCCESS;
 }
@@ -1185,22 +1179,22 @@ static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
  * SCI_FAILURE_INVALID_PHY This value is returned if the user attempts to start
  * the device when there have been no phys added to it.
  */
-static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *sci_dev,
+static enum sci_status scic_remote_device_start(struct isci_remote_device *idev,
 						u32 timeout)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	enum sci_status status;
 
 	if (state != SCI_DEV_STOPPED) {
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_node_context_resume(&sci_dev->rnc,
+	status = scic_sds_remote_node_context_resume(&idev->rnc,
 						     remote_device_resume_done,
-						     sci_dev);
+						     idev);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -1217,9 +1211,9 @@ static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 	enum sci_status status;
 
 	if (dev->parent && dev_is_expander(dev->parent))
-		status = scic_remote_device_ea_construct(iport, &idev->sci);
+		status = scic_remote_device_ea_construct(iport, idev);
 	else
-		status = scic_remote_device_da_construct(iport, &idev->sci);
+		status = scic_remote_device_da_construct(iport, idev);
 
 	if (status != SCI_SUCCESS) {
 		dev_dbg(&ihost->pdev->dev, "%s: construct failed: %d\n",
@@ -1229,7 +1223,7 @@ static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 	}
 
 	/* start the device. */
-	status = scic_remote_device_start(&idev->sci, ISCI_REMOTE_DEVICE_START_TIMEOUT);
+	status = scic_remote_device_start(idev, ISCI_REMOTE_DEVICE_START_TIMEOUT);
 
 	if (status != SCI_SUCCESS)
 		dev_warn(&ihost->pdev->dev, "remote device start failed: %d\n",
@@ -1330,7 +1324,7 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	set_bit(IDEV_STOP_PENDING, &idev->flags);
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-	status = scic_remote_device_stop(&idev->sci, 50);
+	status = scic_remote_device_stop(idev, 50);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Wait for the stop complete callback. */
diff --git a/drivers/scsi/isci/remote_device.h b/drivers/scsi/isci/remote_device.h
index 578d75b..4579858 100644
--- a/drivers/scsi/isci/remote_device.h
+++ b/drivers/scsi/isci/remote_device.h
@@ -70,65 +70,14 @@ enum scic_remote_device_not_ready_reason_code {
 	SCIC_REMOTE_DEVICE_NOT_READY_REASON_CODE_MAX
 };
 
-struct scic_sds_remote_device {
-	/**
-	 * This field contains the information for the base remote device state
-	 * machine.
-	 */
-	struct sci_base_state_machine sm;
-
-	/**
-	 * This field is the programmed device port width.  This value is
-	 * written to the RCN data structure to tell the SCU how many open
-	 * connections this device can have.
-	 */
-	u32 device_port_width;
-
-	/**
-	 * This field is the programmed connection rate for this remote device.  It is
-	 * used to program the TC with the maximum allowed connection rate.
-	 */
-	enum sas_linkrate connection_rate;
-
-	/**
-	 * This filed is assinged the value of true if the device is directly
-	 * attached to the port.
-	 */
-	bool is_direct_attached;
-
-	/**
-	 * This filed contains a pointer back to the port to which this device
-	 * is assigned.
-	 */
-	struct isci_port *owning_port;
-
-	/**
-	 * This field contains the SCU silicon remote node context specific
-	 * information.
-	 */
-	struct scic_sds_remote_node_context rnc;
-
-	/**
-	 * This field contains the stated request count for the remote device.  The
-	 * device can not reach the SCI_DEV_STOPPED until all
-	 * requests are complete and the rnc_posted value is false.
-	 */
-	u32 started_request_count;
-
-	/**
-	 * This field contains a pointer to the working request object.  It is only
-	 * used only for SATA requests since the unsolicited frames we get from the
-	 * hardware have no Tag value to look up the io request object.
-	 */
-	struct isci_request *working_request;
-
-	/**
-	 * This field contains the reason for the remote device going not_ready.  It is
-	 * assigned in the state handlers and used in the state transition.
-	 */
-	u32 not_ready_reason;
-};
-
+/**
+ * isci_remote_device - isci representation of a sas expander / end point
+ * @device_port_width: hw setting for number of simultaneous connections
+ * @connection_rate: per-taskcontext connection rate for this device
+ * @working_request: SATA requests have no tag we for unaccelerated
+ *                   protocols we need a method to associate unsolicited
+ *                   frames with a pending request
+ */
 struct isci_remote_device {
 	#define IDEV_START_PENDING 0
 	#define IDEV_STOP_PENDING 1
@@ -143,7 +92,16 @@ struct isci_remote_device {
 	struct domain_device *domain_dev;
 	struct list_head node;
 	struct list_head reqs_in_process;
-	struct scic_sds_remote_device sci;
+	struct sci_base_state_machine sm;
+	u32 device_port_width;
+	enum sas_linkrate connection_rate;
+	bool is_direct_attached;
+	struct isci_port *owning_port;
+	struct scic_sds_remote_node_context rnc;
+	/* XXX unify with device reference counting and delete */
+	u32 started_request_count;
+	struct isci_request *working_request;
+	u32 not_ready_reason;
 };
 
 #define ISCI_REMOTE_DEVICE_START_TIMEOUT 5000
@@ -191,7 +149,7 @@ void isci_device_clear_reset_pending(struct isci_host *ihost,
  * successfully stopped.
  */
 enum sci_status scic_remote_device_stop(
-	struct scic_sds_remote_device *remote_device,
+	struct isci_remote_device *idev,
 	u32 timeout);
 
 /**
@@ -207,7 +165,7 @@ enum sci_status scic_remote_device_stop(
  * started.
  */
 enum sci_status scic_remote_device_reset(
-	struct scic_sds_remote_device *remote_device);
+	struct isci_remote_device *idev);
 
 /**
  * scic_remote_device_reset_complete() - This method informs the device object
@@ -220,7 +178,7 @@ enum sci_status scic_remote_device_reset(
  * is resuming operation.
  */
 enum sci_status scic_remote_device_reset_complete(
-	struct scic_sds_remote_device *remote_device);
+	struct isci_remote_device *idev);
 
 #define scic_remote_device_is_atapi(device_handle) false
 
@@ -335,27 +293,15 @@ enum scic_sds_remote_device_states {
 	SCI_DEV_FINAL,
 };
 
-static inline struct scic_sds_remote_device *rnc_to_dev(struct scic_sds_remote_node_context *rnc)
+static inline struct isci_remote_device *rnc_to_dev(struct scic_sds_remote_node_context *rnc)
 {
-	struct scic_sds_remote_device *sci_dev;
+	struct isci_remote_device *idev;
 
-	sci_dev = container_of(rnc, typeof(*sci_dev), rnc);
-
-	return sci_dev;
-}
-
-static inline struct isci_remote_device *sci_dev_to_idev(struct scic_sds_remote_device *sci_dev)
-{
-	struct isci_remote_device *idev = container_of(sci_dev, typeof(*idev), sci);
+	idev = container_of(rnc, typeof(*idev), rnc);
 
 	return idev;
 }
 
-static inline struct domain_device *sci_dev_to_domain(struct scic_sds_remote_device *sci_dev)
-{
-	return sci_dev_to_idev(sci_dev)->domain_dev;
-}
-
 static inline bool dev_is_expander(struct domain_device *dev)
 {
 	return dev->dev_type == EDGE_DEV || dev->dev_type == FANOUT_DEV;
@@ -366,8 +312,8 @@ static inline bool dev_is_expander(struct domain_device *dev)
  *
  * This macro incrments the request count for this device
  */
-#define scic_sds_remote_device_increment_request_count(sci_dev) \
-	((sci_dev)->started_request_count++)
+#define scic_sds_remote_device_increment_request_count(idev) \
+	((idev)->started_request_count++)
 
 /**
  * scic_sds_remote_device_decrement_request_count() -
@@ -375,44 +321,44 @@ static inline bool dev_is_expander(struct domain_device *dev)
  * This macro decrements the request count for this device.  This count will
  * never decrment past 0.
  */
-#define scic_sds_remote_device_decrement_request_count(sci_dev) \
-	((sci_dev)->started_request_count > 0 ? \
-	 (sci_dev)->started_request_count-- : 0)
+#define scic_sds_remote_device_decrement_request_count(idev) \
+	((idev)->started_request_count > 0 ? \
+	 (idev)->started_request_count-- : 0)
 
 /**
  * scic_sds_remote_device_get_request_count() -
  *
  * This is a helper macro to return the current device request count.
  */
-#define scic_sds_remote_device_get_request_count(sci_dev) \
-	((sci_dev)->started_request_count)
+#define scic_sds_remote_device_get_request_count(idev) \
+	((idev)->started_request_count)
 
 /**
  * scic_sds_remote_device_get_controller() -
  *
  * This macro returns the controller object that contains this device object
  */
-#define scic_sds_remote_device_get_controller(sci_dev) \
-	scic_sds_port_get_controller(scic_sds_remote_device_get_port(sci_dev))
+#define scic_sds_remote_device_get_controller(idev) \
+	scic_sds_port_get_controller(scic_sds_remote_device_get_port(idev))
 
 /**
  * scic_sds_remote_device_get_port() -
  *
  * This macro returns the owning port of this device
  */
-#define scic_sds_remote_device_get_port(sci_dev) \
-	((sci_dev)->owning_port)
+#define scic_sds_remote_device_get_port(idev) \
+	((idev)->owning_port)
 
 /**
  * scic_sds_remote_device_get_controller_peg() -
  *
  * This macro returns the controllers protocol engine group
  */
-#define scic_sds_remote_device_get_controller_peg(sci_dev) \
+#define scic_sds_remote_device_get_controller_peg(idev) \
 	(\
 		scic_sds_controller_get_protocol_engine_group(\
 			scic_sds_port_get_controller(\
-				scic_sds_remote_device_get_port(sci_dev) \
+				scic_sds_remote_device_get_port(idev) \
 				) \
 			) \
 	)
@@ -422,8 +368,8 @@ static inline bool dev_is_expander(struct domain_device *dev)
  *
  * This macro returns the remote node index for this device object
  */
-#define scic_sds_remote_device_get_index(sci_dev) \
-	((sci_dev)->rnc.remote_node_index)
+#define scic_sds_remote_device_get_index(idev) \
+	((idev)->rnc.remote_node_index)
 
 /**
  * scic_sds_remote_device_build_command_context() -
@@ -448,36 +394,36 @@ static inline bool dev_is_expander(struct domain_device *dev)
 	((device)->working_request = (request))
 
 enum sci_status scic_sds_remote_device_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u32 frame_index);
 
 enum sci_status scic_sds_remote_device_event_handler(
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u32 event_code);
 
 enum sci_status scic_sds_remote_device_start_io(
 	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_status scic_sds_remote_device_start_task(
 	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_status scic_sds_remote_device_complete_io(
 	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_status scic_sds_remote_device_suspend(
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u32 suspend_type);
 
 void scic_sds_remote_device_post_request(
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u32 request);
 
-#define scic_sds_remote_device_is_atapi(sci_dev) false
+#define scic_sds_remote_device_is_atapi(idev) false
 
 #endif /* !defined(_ISCI_REMOTE_DEVICE_H_) */
diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 1b51fe5..e485744 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -103,22 +103,22 @@ bool scic_sds_remote_node_context_is_ready(
 static void scic_sds_remote_node_context_construct_buffer(
 	struct scic_sds_remote_node_context *sci_rnc)
 {
-	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
+	struct domain_device *dev = idev->domain_dev;
 	int rni = sci_rnc->remote_node_index;
 	union scu_remote_node_context *rnc;
 	struct scic_sds_controller *scic;
 	__le64 sas_addr;
 
-	scic = scic_sds_remote_device_get_controller(sci_dev);
+	scic = scic_sds_remote_device_get_controller(idev);
 	rnc = scic_sds_controller_get_remote_node_context_buffer(scic, rni);
 
 	memset(rnc, 0, sizeof(union scu_remote_node_context)
-		* scic_sds_remote_device_node_count(sci_dev));
+		* scic_sds_remote_device_node_count(idev));
 
 	rnc->ssp.remote_node_index = rni;
-	rnc->ssp.remote_node_port_width = sci_dev->device_port_width;
-	rnc->ssp.logical_port_index = sci_dev->owning_port->physical_port_index;
+	rnc->ssp.remote_node_port_width = idev->device_port_width;
+	rnc->ssp.logical_port_index = idev->owning_port->physical_port_index;
 
 	/* sas address is __be64, context ram format is __le64 */
 	sas_addr = cpu_to_le64(SAS_ADDR(dev->sas_addr));
@@ -148,7 +148,7 @@ static void scic_sds_remote_node_context_construct_buffer(
 	rnc->ssp.initial_arbitration_wait_time = 0;
 
 	/* Open Address Frame Parameters */
-	rnc->ssp.oaf_connection_rate = sci_dev->connection_rate;
+	rnc->ssp.oaf_connection_rate = idev->connection_rate;
 	rnc->ssp.oaf_features = 0;
 	rnc->ssp.oaf_source_zone_group = 0;
 	rnc->ssp.oaf_more_compatibility_features = 0;
@@ -220,26 +220,26 @@ static void scic_sds_remote_node_context_continue_state_transitions(struct scic_
 static void scic_sds_remote_node_context_validate_context_buffer(
 	struct scic_sds_remote_node_context *sci_rnc)
 {
-	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
+	struct domain_device *dev = idev->domain_dev;
 	union scu_remote_node_context *rnc_buffer;
 
 	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
-		scic_sds_remote_device_get_controller(sci_dev),
+		scic_sds_remote_device_get_controller(idev),
 		sci_rnc->remote_node_index
 		);
 
 	rnc_buffer->ssp.is_valid = true;
 
-	if (!sci_dev->is_direct_attached &&
+	if (!idev->is_direct_attached &&
 	    (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP))) {
-		scic_sds_remote_device_post_request(sci_dev,
+		scic_sds_remote_device_post_request(idev,
 						    SCU_CONTEXT_COMMAND_POST_RNC_96);
 	} else {
-		scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_32);
+		scic_sds_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_32);
 
-		if (sci_dev->is_direct_attached) {
-			scic_sds_port_setup_transports(sci_dev->owning_port,
+		if (idev->is_direct_attached) {
+			scic_sds_port_setup_transports(idev->owning_port,
 						       sci_rnc->remote_node_index);
 		}
 	}
@@ -296,11 +296,11 @@ static void scic_sds_remote_node_context_invalidating_state_enter(struct sci_bas
 static void scic_sds_remote_node_context_resuming_state_enter(struct sci_base_state_machine *sm)
 {
 	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
-	struct scic_sds_remote_device *sci_dev;
+	struct isci_remote_device *idev;
 	struct domain_device *dev;
 
-	sci_dev = rnc_to_dev(rnc);
-	dev = sci_dev_to_domain(sci_dev);
+	idev = rnc_to_dev(rnc);
+	dev = idev->domain_dev;
 
 	/*
 	 * For direct attached SATA devices we need to clear the TLCR
@@ -309,11 +309,11 @@ static void scic_sds_remote_node_context_resuming_state_enter(struct sci_base_st
 	 * the STPTLDARNI register with the RNi of the device
 	 */
 	if ((dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) &&
-	    sci_dev->is_direct_attached)
-		scic_sds_port_setup_transports(sci_dev->owning_port,
+	    idev->is_direct_attached)
+		scic_sds_port_setup_transports(idev->owning_port,
 					       rnc->remote_node_index);
 
-	scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
+	scic_sds_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
 }
 
 static void scic_sds_remote_node_context_ready_state_enter(struct sci_base_state_machine *sm)
@@ -564,8 +564,8 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 		sci_rnc->user_cookie   = cb_p;
 		return SCI_SUCCESS;
 	case SCI_RNC_TX_SUSPENDED: {
-		struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
-		struct domain_device *dev = sci_dev_to_domain(sci_dev);
+		struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
+		struct domain_device *dev = idev->domain_dev;
 
 		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
 
@@ -573,7 +573,7 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 		if (dev->dev_type == SAS_END_DEV || dev_is_expander(dev))
 			sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
 		else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
-			if (sci_dev->is_direct_attached) {
+			if (idev->is_direct_attached) {
 				/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
 				sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
 			} else {
diff --git a/drivers/scsi/isci/remote_node_context.h b/drivers/scsi/isci/remote_node_context.h
index 35e6ae6..7a24c7a 100644
--- a/drivers/scsi/isci/remote_node_context.h
+++ b/drivers/scsi/isci/remote_node_context.h
@@ -79,7 +79,7 @@
 #define SCI_SOFTWARE_SUSPENSION  (1)
 
 struct isci_request;
-struct scic_sds_remote_device;
+struct isci_remote_device;
 struct scic_sds_remote_node_context;
 
 typedef void (*scics_sds_remote_node_context_callback)(void *);
diff --git a/drivers/scsi/isci/request.c b/drivers/scsi/isci/request.c
index 2d29abf..90ead66 100644
--- a/drivers/scsi/isci/request.c
+++ b/drivers/scsi/isci/request.c
@@ -209,17 +209,17 @@ static void scu_ssp_reqeust_construct_task_context(
 	struct scu_task_context *task_context)
 {
 	dma_addr_t dma_addr;
-	struct scic_sds_remote_device *target_device;
+	struct isci_remote_device *idev;
 	struct isci_port *iport;
 
-	target_device = scic_sds_request_get_device(ireq);
+	idev = scic_sds_request_get_device(ireq);
 	iport = scic_sds_request_get_port(ireq);
 
 	/* Fill in the TC with the its required data */
 	task_context->abort = 0;
 	task_context->priority = 0;
 	task_context->initiator_request = 1;
-	task_context->connection_rate = target_device->connection_rate;
+	task_context->connection_rate = idev->connection_rate;
 	task_context->protocol_engine_index =
 		scic_sds_controller_get_protocol_engine_group(controller);
 	task_context->logical_port_index = scic_sds_port_get_index(iport);
@@ -227,8 +227,7 @@ static void scu_ssp_reqeust_construct_task_context(
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
 
-	task_context->remote_node_index =
-		scic_sds_remote_device_get_index(ireq->target_device);
+	task_context->remote_node_index = scic_sds_remote_device_get_index(idev);
 	task_context->command_code = 0;
 
 	task_context->link_layer_control = 0;
@@ -348,17 +347,17 @@ static void scu_sata_reqeust_construct_task_context(
 	struct scu_task_context *task_context)
 {
 	dma_addr_t dma_addr;
-	struct scic_sds_remote_device *target_device;
+	struct isci_remote_device *idev;
 	struct isci_port *iport;
 
-	target_device = scic_sds_request_get_device(ireq);
+	idev = scic_sds_request_get_device(ireq);
 	iport = scic_sds_request_get_port(ireq);
 
 	/* Fill in the TC with the its required data */
 	task_context->abort = 0;
 	task_context->priority = SCU_TASK_PRIORITY_NORMAL;
 	task_context->initiator_request = 1;
-	task_context->connection_rate = target_device->connection_rate;
+	task_context->connection_rate = idev->connection_rate;
 	task_context->protocol_engine_index =
 		scic_sds_controller_get_protocol_engine_group(controller);
 	task_context->logical_port_index =
@@ -367,8 +366,7 @@ static void scu_sata_reqeust_construct_task_context(
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
 
-	task_context->remote_node_index =
-		scic_sds_remote_device_get_index(ireq->target_device);
+	task_context->remote_node_index = scic_sds_remote_device_get_index(idev);
 	task_context->command_code = 0;
 
 	task_context->link_layer_control = 0;
@@ -2850,7 +2848,7 @@ static void isci_request_io_request_complete(struct isci_host *isci_host,
 static void scic_sds_request_started_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_request *ireq = container_of(sm, typeof(*ireq), sm);
-	struct domain_device *dev = sci_dev_to_domain(ireq->target_device);
+	struct domain_device *dev = ireq->target_device->domain_dev;
 	struct sas_task *task;
 
 	/* XXX as hch said always creating an internal sas_task for tmf
@@ -2988,12 +2986,12 @@ static const struct sci_base_state scic_sds_request_state_table[] = {
 
 static void
 scic_sds_general_request_construct(struct scic_sds_controller *scic,
-				   struct scic_sds_remote_device *sci_dev,
+				   struct isci_remote_device *idev,
 				   struct isci_request *ireq)
 {
 	sci_init_sm(&ireq->sm, scic_sds_request_state_table, SCI_REQ_INIT);
 
-	ireq->target_device = sci_dev;
+	ireq->target_device = idev;
 	ireq->protocol = SCIC_NO_PROTOCOL;
 	ireq->saved_rx_frame_index = SCU_INVALID_FRAME_INDEX;
 
@@ -3004,16 +3002,16 @@ scic_sds_general_request_construct(struct scic_sds_controller *scic,
 
 static enum sci_status
 scic_io_request_construct(struct scic_sds_controller *scic,
-			  struct scic_sds_remote_device *sci_dev,
+			  struct isci_remote_device *idev,
 			  struct isci_request *ireq)
 {
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct domain_device *dev = idev->domain_dev;
 	enum sci_status status = SCI_SUCCESS;
 
 	/* Build the common part of the request */
-	scic_sds_general_request_construct(scic, sci_dev, ireq);
+	scic_sds_general_request_construct(scic, idev, ireq);
 
-	if (sci_dev->rnc.remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)
+	if (idev->rnc.remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)
 		return SCI_FAILURE_INVALID_REMOTE_DEVICE;
 
 	if (dev->dev_type == SAS_END_DEV)
@@ -3031,14 +3029,14 @@ scic_io_request_construct(struct scic_sds_controller *scic,
 }
 
 enum sci_status scic_task_request_construct(struct scic_sds_controller *scic,
-					    struct scic_sds_remote_device *sci_dev,
+					    struct isci_remote_device *idev,
 					    u16 io_tag, struct isci_request *ireq)
 {
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct domain_device *dev = idev->domain_dev;
 	enum sci_status status = SCI_SUCCESS;
 
 	/* Build the common part of the request */
-	scic_sds_general_request_construct(scic, sci_dev, ireq);
+	scic_sds_general_request_construct(scic, idev, ireq);
 
 	if (dev->dev_type == SAS_END_DEV ||
 	    dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
@@ -3102,7 +3100,7 @@ scic_io_request_construct_smp(struct device *dev,
 			      struct sas_task *task)
 {
 	struct scatterlist *sg = &task->smp_task.smp_req;
-	struct scic_sds_remote_device *sci_dev;
+	struct isci_remote_device *idev;
 	struct scu_task_context *task_context;
 	struct isci_port *iport;
 	struct smp_req *smp_req;
@@ -3147,7 +3145,7 @@ scic_io_request_construct_smp(struct device *dev,
 
 	task_context = ireq->tc;
 
-	sci_dev = scic_sds_request_get_device(ireq);
+	idev = scic_sds_request_get_device(ireq);
 	iport = scic_sds_request_get_port(ireq);
 
 	/*
@@ -3156,7 +3154,7 @@ scic_io_request_construct_smp(struct device *dev,
 	 */
 	task_context->priority = 0;
 	task_context->initiator_request = 1;
-	task_context->connection_rate = sci_dev->connection_rate;
+	task_context->connection_rate = idev->connection_rate;
 	task_context->protocol_engine_index =
 		scic_sds_controller_get_protocol_engine_group(scic);
 	task_context->logical_port_index = scic_sds_port_get_index(iport);
@@ -3166,7 +3164,7 @@ scic_io_request_construct_smp(struct device *dev,
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
 
 	/* 04h */
-	task_context->remote_node_index = sci_dev->rnc.remote_node_index;
+	task_context->remote_node_index = idev->rnc.remote_node_index;
 	task_context->command_code = 0;
 	task_context->task_type = SCU_TASK_TYPE_SMP_REQUEST;
 
@@ -3257,17 +3255,16 @@ static enum sci_status isci_smp_request_build(struct isci_request *ireq)
  */
 static enum sci_status isci_io_request_build(struct isci_host *isci_host,
 					     struct isci_request *request,
-					     struct isci_remote_device *isci_device)
+					     struct isci_remote_device *idev)
 {
 	enum sci_status status = SCI_SUCCESS;
 	struct sas_task *task = isci_request_access_task(request);
-	struct scic_sds_remote_device *sci_device = &isci_device->sci;
 
 	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_device = 0x%p; request = %p, "
+		"%s: idev = 0x%p; request = %p, "
 		"num_scatter = %d\n",
 		__func__,
-		isci_device,
+		idev,
 		request,
 		task->num_scatter);
 
@@ -3290,8 +3287,7 @@ static enum sci_status isci_io_request_build(struct isci_host *isci_host,
 			return SCI_FAILURE_INSUFFICIENT_RESOURCES;
 	}
 
-	status = scic_io_request_construct(&isci_host->sci, sci_device,
-					   request);
+	status = scic_io_request_construct(&isci_host->sci, idev, request);
 
 	if (status != SCI_SUCCESS) {
 		dev_warn(&isci_host->pdev->dev,
@@ -3397,14 +3393,14 @@ int isci_request_execute(struct isci_host *ihost, struct isci_remote_device *ide
 			 * ireq->is_task_management_request is false).
 			 */
 			status = scic_controller_start_task(&ihost->sci,
-							    &idev->sci,
+							    idev,
 							    ireq);
 		} else {
 			status = SCI_FAILURE;
 		}
 	} else {
 		/* send the request, let the core assign the IO TAG.	*/
-		status = scic_controller_start_io(&ihost->sci, &idev->sci,
+		status = scic_controller_start_io(&ihost->sci, idev,
 						  ireq);
 	}
 
diff --git a/drivers/scsi/isci/request.h b/drivers/scsi/isci/request.h
index 68d8a27..ca64ea2 100644
--- a/drivers/scsi/isci/request.h
+++ b/drivers/scsi/isci/request.h
@@ -146,7 +146,7 @@ struct isci_request {
 	struct completion *io_request_completion;
 	struct sci_base_state_machine sm;
 	struct scic_sds_controller *owning_controller;
-	struct scic_sds_remote_device *target_device;
+	struct isci_remote_device *target_device;
 	u16 io_tag;
 	enum sci_request_protocol protocol;
 	u32 scu_status; /* hardware result */
@@ -501,7 +501,7 @@ void isci_terminate_pending_requests(struct isci_host *ihost,
 				     struct isci_remote_device *idev);
 enum sci_status
 scic_task_request_construct(struct scic_sds_controller *scic,
-			    struct scic_sds_remote_device *sci_dev,
+			    struct isci_remote_device *idev,
 			    u16 io_tag,
 			    struct isci_request *ireq);
 enum sci_status
diff --git a/drivers/scsi/isci/task.c b/drivers/scsi/isci/task.c
index 700708c..89b01ee 100644
--- a/drivers/scsi/isci/task.c
+++ b/drivers/scsi/isci/task.c
@@ -257,7 +257,7 @@ static struct isci_request *isci_task_request_build(struct isci_host *ihost,
 		return NULL;
 
 	/* let the core do it's construct. */
-	status = scic_task_request_construct(&ihost->sci, &idev->sci, tag,
+	status = scic_task_request_construct(&ihost->sci, idev, tag,
 					     ireq);
 
 	if (status != SCI_SUCCESS) {
@@ -288,12 +288,11 @@ static struct isci_request *isci_task_request_build(struct isci_host *ihost,
 }
 
 int isci_task_execute_tmf(struct isci_host *ihost,
-			  struct isci_remote_device *isci_device,
+			  struct isci_remote_device *idev,
 			  struct isci_tmf *tmf, unsigned long timeout_ms)
 {
 	DECLARE_COMPLETION_ONSTACK(completion);
 	enum sci_task_status status = SCI_TASK_FAILURE;
-	struct scic_sds_remote_device *sci_device;
 	struct isci_request *ireq;
 	int ret = TMF_RESP_FUNC_FAILED;
 	unsigned long flags;
@@ -310,34 +309,30 @@ int isci_task_execute_tmf(struct isci_host *ihost,
 	/* sanity check, return TMF_RESP_FUNC_FAILED
 	 * if the device is not there and ready.
 	 */
-	if (!isci_device ||
-	    (!test_bit(IDEV_IO_READY, &isci_device->flags) &&
-	     !test_bit(IDEV_IO_NCQERROR, &isci_device->flags))) {
+	if (!idev ||
+	    (!test_bit(IDEV_IO_READY, &idev->flags) &&
+	     !test_bit(IDEV_IO_NCQERROR, &idev->flags))) {
 		dev_dbg(&ihost->pdev->dev,
-			"%s: isci_device = %p not ready (%#lx)\n",
+			"%s: idev = %p not ready (%#lx)\n",
 			__func__,
-			isci_device, isci_device ? isci_device->flags : 0);
+			idev, idev ? idev->flags : 0);
 		goto err_tci;
 	} else
 		dev_dbg(&ihost->pdev->dev,
-			"%s: isci_device = %p\n",
-			__func__, isci_device);
-
-	sci_device = &isci_device->sci;
+			"%s: idev = %p\n",
+			__func__, idev);
 
 	/* Assign the pointer to the TMF's completion kernel wait structure. */
 	tmf->complete = &completion;
 
-	ireq = isci_task_request_build(ihost, isci_device, tag, tmf);
+	ireq = isci_task_request_build(ihost, idev, tag, tmf);
 	if (!ireq)
 		goto err_tci;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	/* start the TMF io. */
-	status = scic_controller_start_task(&ihost->sci,
-					    sci_device,
-					    ireq);
+	status = scic_controller_start_task(&ihost->sci, idev, ireq);
 
 	if (status != SCI_TASK_SUCCESS) {
 		dev_warn(&ihost->pdev->dev,
@@ -355,7 +350,7 @@ int isci_task_execute_tmf(struct isci_host *ihost,
 	isci_request_change_state(ireq, started);
 
 	/* add the request to the remote device request list. */
-	list_add(&ireq->dev_node, &isci_device->reqs_in_process);
+	list_add(&ireq->dev_node, &idev->reqs_in_process);
 
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
@@ -370,7 +365,7 @@ int isci_task_execute_tmf(struct isci_host *ihost,
 			tmf->cb_state_func(isci_tmf_timed_out, tmf, tmf->cb_data);
 
 		scic_controller_terminate_request(&ihost->sci,
-						  &isci_device->sci,
+						  idev,
 						  ireq);
 
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
@@ -520,13 +515,13 @@ static void isci_request_cleanup_completed_loiterer(
  *    from a thread that can wait.  Note that the request is terminated and
  *    completed (back to the host, if started there).
  * @isci_host: This SCU.
- * @isci_device: The target.
+ * @idev: The target.
  * @isci_request: The I/O request to be terminated.
  *
  */
 static void isci_terminate_request_core(
 	struct isci_host *isci_host,
-	struct isci_remote_device *isci_device,
+	struct isci_remote_device *idev,
 	struct isci_request *isci_request)
 {
 	enum sci_status status      = SCI_SUCCESS;
@@ -540,7 +535,7 @@ static void isci_terminate_request_core(
 
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: device = %p; request = %p\n",
-		__func__, isci_device, isci_request);
+		__func__, idev, isci_request);
 
 	spin_lock_irqsave(&isci_host->scic_lock, flags);
 
@@ -564,7 +559,7 @@ static void isci_terminate_request_core(
 		needs_cleanup_handling = true;
 		status = scic_controller_terminate_request(
 			&isci_host->sci,
-			&isci_device->sci,
+			idev,
 			isci_request);
 	}
 	spin_unlock_irqrestore(&isci_host->scic_lock, flags);
@@ -683,7 +678,7 @@ static void isci_terminate_request_core(
 		}
 		if (needs_cleanup_handling)
 			isci_request_cleanup_completed_loiterer(
-				isci_host, isci_device, isci_request, task);
+				isci_host, idev, isci_request, task);
 	}
 }
 
@@ -694,7 +689,7 @@ static void isci_terminate_request_core(
  *    called from a thread that can wait.  Note that the requests are all
  *    terminated and completed (back to the host, if started there).
  * @isci_host: This parameter specifies SCU.
- * @isci_device: This parameter specifies the target.
+ * @idev: This parameter specifies the target.
  *
  */
 void isci_terminate_pending_requests(struct isci_host *ihost,
@@ -1521,7 +1516,7 @@ static int isci_reset_device(struct isci_host *ihost,
 	dev_dbg(&ihost->pdev->dev, "%s: idev %p\n", __func__, idev);
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-	status = scic_remote_device_reset(&idev->sci);
+	status = scic_remote_device_reset(idev);
 	if (status != SCI_SUCCESS) {
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
@@ -1547,7 +1542,7 @@ static int isci_reset_device(struct isci_host *ihost,
 
 	/* Since all pending TCs have been cleaned, resume the RNC. */
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-	status = scic_remote_device_reset_complete(&idev->sci);
+	status = scic_remote_device_reset_complete(idev);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* If this is a device on an expander, bring the phy back up. */
-- 
1.6.0.2

