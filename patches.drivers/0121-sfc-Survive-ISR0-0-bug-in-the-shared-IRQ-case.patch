From gbarzini@solarflare.com  Thu Jun 23 20:54:31 2011
From: Guido Barzini <gbarzini@solarflare.com>
Date: Wed, 3 Feb 2010 09:31:24 +0000
Subject: [PATCH 121/266] sfc: Survive ISR0=0 bug in the shared IRQ case
Patch-mainline: 2.6.39
Git-commit: c91f48d61c5b6fb36a6fc50de923db4db009b0dc
References: bnc#698572, FATE#311724

Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 drivers/net/sfc/nic.c |    9 +++++++++
 1 files changed, 9 insertions(+), 0 deletions(-)

diff --git a/drivers/net/sfc/nic.c b/drivers/net/sfc/nic.c
index db44224..8d9696a 100644
--- a/drivers/net/sfc/nic.c
+++ b/drivers/net/sfc/nic.c
@@ -1384,6 +1384,15 @@ static irqreturn_t efx_legacy_interrupt(int irq, void *dev_id)
 		efx->last_irq_cpu = raw_smp_processor_id();
 		EFX_TRACE(efx, "IRQ %d on CPU %d status " EFX_DWORD_FMT "\n",
 			  irq, raw_smp_processor_id(), EFX_DWORD_VAL(reg));
+	} else if (EFX_WORKAROUND_15783(efx)) {
+		/* We can't return IRQ_HANDLED more than once on seeing ISR0=0
+		 * because this might be a shared interrupt, but we do need to
+		 * check the channel every time and preemptively rearm it if
+		 * it's idle. */
+		efx_for_each_channel(channel, efx) {
+			if (!channel->work_pending)
+				efx_nic_eventq_read_ack(channel);
+		}
 	}
 
 	return result;
-- 
1.7.4.4

