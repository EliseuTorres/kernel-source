From: Yi Zou <yi.zou@intel.com>
Date: Tue, 11 Oct 2011 13:20:55 +0200
Subject: libfc: fix deadlock bug in fc_exch_abort_locked
References: bnc#722414
Patch-Mainline: Not yet

With commit "77a2b73 [SCSI] libfc: fix fc_eh_host_reset", the exch
lock is already held when fc_exch_abort_locked(), but fc_seq_send()
that is called along the path is gonna grab the same exch lock again,
causing dead-lock. Drop the exch lock before fc_seq_send() in
fc_exch_abort_locked() should fix it.

v1:
This is reported by Bhanu with the following kernel log:
https://lists.open-fcoe.org/pipermail/devel/2011-September/011767.html

v2:
No need to hold exch lock for fc_frame_alloc(), so just drop it before the frame
alloc and grab it before returning from fc_exch_abort_locked()

Reported-by: Bhanu Prakash Gollapudi <bprakash@broadcom.com>
Signed-off-by: Yi Zou <yi.zou@intel.com>
Acked-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/libfc/fc_exch.c b/drivers/scsi/libfc/fc_exch.c
index 7c055fd..809f48f 100644
--- a/drivers/scsi/libfc/fc_exch.c
+++ b/drivers/scsi/libfc/fc_exch.c
@@ -617,6 +617,7 @@ static int fc_exch_abort_locked(struct fc_exch *ep,
 	/*
 	 * Send an abort for the sequence that timed out.
 	 */
+	spin_unlock_bh(&ep->ex_lock);
 	fp = fc_frame_alloc(ep->lp, 0);
 	if (fp) {
 		fc_fill_fc_hdr(fp, FC_RCTL_BA_ABTS, ep->did, ep->sid,
@@ -624,6 +625,7 @@ static int fc_exch_abort_locked(struct fc_exch *ep,
 		error = fc_seq_send(ep->lp, sp, fp);
 	} else
 		error = -ENOBUFS;
+	spin_lock_bh(&ep->ex_lock);
 	return error;
 }
 
