From: Ben Hutchings <bhutchings@solarflare.com>
Date: Tue, 27 Aug 2013 23:04:29 +0100
Subject: [PATCH v2 110/244] sfc: Remove unnecessary use of atomic_t
Patch-mainline: v3.12-rc1
Git-commit: 251111d9a1bd9a26e25446d876156bf265858cb5
References: bsc#909618 FATE#317521

We can set, get and compare-and-exchange without using atomic_t.
Change efx_mcdi_iface::state to the enum type we really wanted it to
be.

Suggested-by: David Miller <davem@davemloft.net>
Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
[dchang: fix compile error on IA64, removed #include <asm/cmpxchg.h>]
Acked-by: David Chang <dchang@suse.com>
---
 drivers/net/ethernet/sfc/mcdi.c |   27 +++++++++++----------------
 drivers/net/ethernet/sfc/mcdi.h |    2 +-
 2 files changed, 12 insertions(+), 17 deletions(-)

--- a/drivers/net/ethernet/sfc/mcdi.c
+++ b/drivers/net/ethernet/sfc/mcdi.c
@@ -53,7 +53,7 @@ int efx_mcdi_init(struct efx_nic *efx)
 	mcdi = efx_mcdi(efx);
 	init_waitqueue_head(&mcdi->wq);
 	spin_lock_init(&mcdi->iface_lock);
-	atomic_set(&mcdi->state, MCDI_STATE_QUIESCENT);
+	mcdi->state = MCDI_STATE_QUIESCENT;
 	mcdi->mode = MCDI_MODE_POLL;
 
 	(void) efx_mcdi_poll_reboot(efx);
@@ -65,8 +65,7 @@ int efx_mcdi_init(struct efx_nic *efx)
 
 void efx_mcdi_fini(struct efx_nic *efx)
 {
-	BUG_ON(efx->mcdi &&
-	       atomic_read(&efx->mcdi->iface.state) != MCDI_STATE_QUIESCENT);
+	BUG_ON(efx->mcdi && efx->mcdi->iface.state != MCDI_STATE_QUIESCENT);
 	kfree(efx->mcdi);
 }
 
@@ -78,7 +77,7 @@ static void efx_mcdi_send_request(struct
 	size_t hdr_len;
 	u32 xflags, seqno;
 
-	BUG_ON(atomic_read(&mcdi->state) == MCDI_STATE_QUIESCENT);
+	BUG_ON(mcdi->state == MCDI_STATE_QUIESCENT);
 
 	/* Serialise with efx_mcdi_ev_cpl() and efx_mcdi_ev_death() */
 	spin_lock_bh(&mcdi->iface_lock);
@@ -258,20 +257,17 @@ static void efx_mcdi_acquire(struct efx_
 	/* Wait until the interface becomes QUIESCENT and we win the race
 	 * to mark it RUNNING. */
 	wait_event(mcdi->wq,
-		   atomic_cmpxchg(&mcdi->state,
-				  MCDI_STATE_QUIESCENT,
-				  MCDI_STATE_RUNNING)
-		   == MCDI_STATE_QUIESCENT);
+		   cmpxchg(&mcdi->state,
+			   MCDI_STATE_QUIESCENT, MCDI_STATE_RUNNING) ==
+		   MCDI_STATE_QUIESCENT);
 }
 
 static int efx_mcdi_await_completion(struct efx_nic *efx)
 {
 	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
 
-	if (wait_event_timeout(
-		    mcdi->wq,
-		    atomic_read(&mcdi->state) == MCDI_STATE_COMPLETED,
-		    MCDI_RPC_TIMEOUT) == 0)
+	if (wait_event_timeout(mcdi->wq, mcdi->state == MCDI_STATE_COMPLETED,
+			       MCDI_RPC_TIMEOUT) == 0)
 		return -ETIMEDOUT;
 
 	/* Check if efx_mcdi_set_mode() switched us back to polled completions.
@@ -296,9 +292,8 @@ static bool efx_mcdi_complete(struct efx
 	 * QUIESCENT. [A subsequent invocation would increment seqno, so would
 	 * have failed the seqno check].
 	 */
-	if (atomic_cmpxchg(&mcdi->state,
-			   MCDI_STATE_RUNNING,
-			   MCDI_STATE_COMPLETED) == MCDI_STATE_RUNNING) {
+	if (cmpxchg(&mcdi->state, MCDI_STATE_RUNNING, MCDI_STATE_COMPLETED) ==
+	    MCDI_STATE_RUNNING) {
 		wake_up(&mcdi->wq);
 		return true;
 	}
@@ -308,7 +303,7 @@ static bool efx_mcdi_complete(struct efx
 
 static void efx_mcdi_release(struct efx_mcdi_iface *mcdi)
 {
-	atomic_set(&mcdi->state, MCDI_STATE_QUIESCENT);
+	mcdi->state = MCDI_STATE_QUIESCENT;
 	wake_up(&mcdi->wq);
 }
 
--- a/drivers/net/ethernet/sfc/mcdi.h
+++ b/drivers/net/ethernet/sfc/mcdi.h
@@ -46,7 +46,7 @@ enum efx_mcdi_mode {
  * @resp_data_len: Response data (SDU or error) length
  */
 struct efx_mcdi_iface {
-	atomic_t state;
+	enum efx_mcdi_state state;
 	enum efx_mcdi_mode mode;
 	wait_queue_head_t wq;
 	spinlock_t iface_lock;
