From: Edmund Nadolski <edmund.nadolski@intel.com>
Date: Thu, 2 Jun 2011 00:10:50 +0000
Subject: [PATCH 229/273] isci: additional state machine cleanup
Git-commit: 12ef65444de9d387a383b9991960848bed5bbe74
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Additional state machine cleanups:

 o Remove static functions sci_state_machine_exit_state() and
   sci_state_machine_enter_state()
 o Combines sci_base_state_machine_construct() and
   sci_base_state_machine_start() into a single function,
   sci_init_sm()
 o Remove sci_base_state_machine_stop() which is unused.
 o Kill state_machine.[ch]

Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
[fixed too large to inline functions]
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/Makefile              |    1 -
 drivers/scsi/isci/host.c                |   39 ++++++++-
 drivers/scsi/isci/host.h                |    2 +-
 drivers/scsi/isci/isci.h                |   19 ++++
 drivers/scsi/isci/phy.c                 |    6 +-
 drivers/scsi/isci/phy.h                 |    2 +-
 drivers/scsi/isci/port.c                |    6 +-
 drivers/scsi/isci/remote_device.c       |    6 +-
 drivers/scsi/isci/remote_node_context.c |    8 +--
 drivers/scsi/isci/remote_node_context.h |    2 +-
 drivers/scsi/isci/request.c             |    5 +-
 drivers/scsi/isci/state_machine.c       |  138 -------------------------------
 drivers/scsi/isci/state_machine.h       |  122 ---------------------------
 13 files changed, 62 insertions(+), 294 deletions(-)
 delete mode 100644 drivers/scsi/isci/state_machine.c
 delete mode 100644 drivers/scsi/isci/state_machine.h

diff --git a/drivers/scsi/isci/Makefile b/drivers/scsi/isci/Makefile
index ad58fe3..4244970 100644
--- a/drivers/scsi/isci/Makefile
+++ b/drivers/scsi/isci/Makefile
@@ -2,7 +2,6 @@ obj-$(CONFIG_SCSI_ISCI) += isci.o
 isci-objs := init.o phy.o request.o sata.o \
 	     remote_device.o port.o \
 	     host.o task.o probe_roms.o \
-	     state_machine.o \
 	     remote_node_context.o \
 	     remote_node_table.o \
 	     unsolicited_frame_control.o \
diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 81ee64c..f502882 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -197,6 +197,39 @@
  */
 #define COMPLETION_QUEUE_CYCLE_BIT(x) ((x) & 0x80000000)
 
+/* Init the state machine and call the state entry function (if any) */
+void sci_init_sm(struct sci_base_state_machine *sm,
+		 const struct sci_base_state *state_table, u32 initial_state)
+{
+	sci_state_transition_t handler;
+
+	sm->initial_state_id    = initial_state;
+	sm->previous_state_id   = initial_state;
+	sm->current_state_id    = initial_state;
+	sm->state_table         = state_table;
+
+	handler = sm->state_table[initial_state].enter_state;
+	if (handler)
+		handler(sm);
+}
+
+/* Call the state exit fn, update the current state, call the state entry fn */
+void sci_change_state(struct sci_base_state_machine *sm, u32 next_state)
+{
+	sci_state_transition_t handler;
+
+	handler = sm->state_table[sm->current_state_id].exit_state;
+	if (handler)
+		handler(sm);
+
+	sm->previous_state_id = sm->current_state_id;
+	sm->current_state_id = next_state;
+
+	handler = sm->state_table[sm->current_state_id].enter_state;
+	if (handler)
+		handler(sm);
+}
+
 static bool scic_sds_controller_completion_queue_has_entries(
 	struct scic_sds_controller *scic)
 {
@@ -1807,11 +1840,7 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 	struct isci_host *ihost = scic_to_ihost(scic);
 	u8 i;
 
-	sci_base_state_machine_construct(&scic->sm,
-					 scic_sds_controller_state_table,
-					 SCIC_INITIAL);
-
-	sci_base_state_machine_start(&scic->sm);
+	sci_init_sm(&scic->sm, scic_sds_controller_state_table, SCIC_INITIAL);
 
 	scic->scu_registers = scu_base;
 	scic->smu_registers = smu_base;
diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index be09765..4020cf7 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -58,7 +58,7 @@
 #include "remote_device.h"
 #include "phy.h"
 #include "pool.h"
-#include "state_machine.h"
+#include "isci.h"
 #include "remote_node_table.h"
 #include "registers.h"
 #include "scu_unsolicited_frame.h"
diff --git a/drivers/scsi/isci/isci.h b/drivers/scsi/isci/isci.h
index 2fe5557..80cfb45 100644
--- a/drivers/scsi/isci/isci.h
+++ b/drivers/scsi/isci/isci.h
@@ -57,6 +57,7 @@
 #define __ISCI_H__
 
 #include <linux/interrupt.h>
+#include <linux/types.h>
 
 #define DRV_NAME "isci"
 #define SCI_PCI_BAR_COUNT 2
@@ -584,4 +585,22 @@ static inline void sci_del_timer(struct sci_timer *tmr)
 	del_timer(&tmr->timer);
 }
 
+struct sci_base_state_machine {
+	const struct sci_base_state *state_table;
+	u32 initial_state_id;
+	u32 current_state_id;
+	u32 previous_state_id;
+};
+
+typedef void (*sci_state_transition_t)(struct sci_base_state_machine *sm);
+
+struct sci_base_state {
+	sci_state_transition_t enter_state;	/* Called on state entry */
+	sci_state_transition_t exit_state;	/* Called on state exit */
+};
+
+extern void sci_init_sm(struct sci_base_state_machine *sm,
+			const struct sci_base_state *state_table,
+			u32 initial_state);
+extern void sci_change_state(struct sci_base_state_machine *sm, u32 next_state);
 #endif  /* __ISCI_H__ */
diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 9de21c7..784c9a7 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -1294,11 +1294,7 @@ static const struct sci_base_state scic_sds_phy_state_table[] = {
 void scic_sds_phy_construct(struct scic_sds_phy *sci_phy,
 			    struct scic_sds_port *owning_port, u8 phy_index)
 {
-	sci_base_state_machine_construct(&sci_phy->sm,
-					 scic_sds_phy_state_table,
-					 SCI_PHY_INITIAL);
-
-	sci_base_state_machine_start(&sci_phy->sm);
+	sci_init_sm(&sci_phy->sm, scic_sds_phy_state_table, SCI_PHY_INITIAL);
 
 	/* Copy the rest of the input data to our locals */
 	sci_phy->owning_port = owning_port;
diff --git a/drivers/scsi/isci/phy.h b/drivers/scsi/isci/phy.h
index 9d21d27..97ebee1 100644
--- a/drivers/scsi/isci/phy.h
+++ b/drivers/scsi/isci/phy.h
@@ -57,7 +57,7 @@
 
 #include <scsi/sas.h>
 #include <scsi/libsas.h>
-#include "state_machine.h"
+#include "isci.h"
 #include "sas.h"
 
 /* This is the timeout value for the SATA phy to wait for a SIGNATURE FIS
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 6370b93..74f06f3 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1807,11 +1807,7 @@ static const struct sci_base_state scic_sds_port_state_table[] = {
 void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
 			     struct scic_sds_controller *scic)
 {
-	sci_base_state_machine_construct(&sci_port->sm,
-					 scic_sds_port_state_table,
-					 SCI_PORT_STOPPED);
-
-	sci_base_state_machine_start(&sci_port->sm);
+	sci_init_sm(&sci_port->sm, scic_sds_port_state_table, SCI_PORT_STOPPED);
 
 	sci_port->logical_port_index  = SCIC_SDS_DUMMY_PORT;
 	sci_port->physical_port_index = index;
diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 6c93f20..3b555dc 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1095,11 +1095,7 @@ static void scic_remote_device_construct(struct scic_sds_port *sci_port,
 	sci_dev->owning_port = sci_port;
 	sci_dev->started_request_count = 0;
 
-	sci_base_state_machine_construct(&sci_dev->sm,
-					 scic_sds_remote_device_state_table,
-					 SCI_DEV_INITIAL);
-
-	sci_base_state_machine_start(&sci_dev->sm);
+	sci_init_sm(&sci_dev->sm, scic_sds_remote_device_state_table, SCI_DEV_INITIAL);
 
 	scic_sds_remote_node_context_construct(&sci_dev->rnc,
 					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 24b1d8a..9e8967e 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -54,7 +54,7 @@
  */
 
 #include "host.h"
-#include "state_machine.h"
+#include "isci.h"
 #include "remote_device.h"
 #include "remote_node_context.h"
 #include "scu_event_codes.h"
@@ -373,11 +373,7 @@ void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context
 	rnc->remote_node_index = remote_node_index;
 	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
 
-	sci_base_state_machine_construct(&rnc->sm,
-					 scic_sds_remote_node_context_state_table,
-					 SCI_RNC_INITIAL);
-
-	sci_base_state_machine_start(&rnc->sm);
+	sci_init_sm(&rnc->sm, scic_sds_remote_node_context_state_table, SCI_RNC_INITIAL);
 }
 
 enum sci_status scic_sds_remote_node_context_event_handler(struct scic_sds_remote_node_context *sci_rnc,
diff --git a/drivers/scsi/isci/remote_node_context.h b/drivers/scsi/isci/remote_node_context.h
index e6c7248..67a45b6 100644
--- a/drivers/scsi/isci/remote_node_context.h
+++ b/drivers/scsi/isci/remote_node_context.h
@@ -64,7 +64,7 @@
  *
  */
 
-#include "state_machine.h"
+#include "isci.h"
 
 /**
  *
diff --git a/drivers/scsi/isci/request.c b/drivers/scsi/isci/request.c
index 89f0ab9..8bd1f7d 100644
--- a/drivers/scsi/isci/request.c
+++ b/drivers/scsi/isci/request.c
@@ -3077,10 +3077,7 @@ scic_sds_general_request_construct(struct scic_sds_controller *scic,
 				   u16 io_tag,
 				   struct scic_sds_request *sci_req)
 {
-	sci_base_state_machine_construct(&sci_req->sm,
-					 scic_sds_request_state_table,
-					 SCI_REQ_INIT);
-	sci_base_state_machine_start(&sci_req->sm);
+	sci_init_sm(&sci_req->sm, scic_sds_request_state_table, SCI_REQ_INIT);
 
 	sci_req->io_tag = io_tag;
 	sci_req->owning_controller = scic;
diff --git a/drivers/scsi/isci/state_machine.c b/drivers/scsi/isci/state_machine.c
deleted file mode 100644
index 8cfefb9..0000000
--- a/drivers/scsi/isci/state_machine.c
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- * This file contains all of the functionality common to all state machine
- *    object implementations.
- *
- *
- */
-
-#include "state_machine.h"
-
-static void sci_state_machine_exit_state(struct sci_base_state_machine *sm)
-{
-	u32 state = sm->current_state_id;
-	sci_state_transition_t exit = sm->state_table[state].exit_state;
-
-	if (exit)
-		exit(sm);
-}
-
-static void sci_state_machine_enter_state(struct sci_base_state_machine *sm)
-{
-	u32 state = sm->current_state_id;
-	sci_state_transition_t enter = sm->state_table[state].enter_state;
-
-	if (enter)
-		enter(sm);
-}
-
-/**
- * This method will set the initial state and state table for the state
- *    machine. The caller should follow this request with the initialize
- *    request to cause the state machine to start.
- * @sm: This parameter provides the state machine object to be
- *    constructed.
- * @state_table: This parameter specifies the table of state objects that is
- *    managed by this state machine.
- * @initial_state: This parameter specifies the value of the initial state for
- *    this state machine.
- *
- */
-void sci_base_state_machine_construct(struct sci_base_state_machine *sm,
-				      const struct sci_base_state *state_table,
-				      u32 initial_state)
-{
-	sm->initial_state_id    = initial_state;
-	sm->previous_state_id   = initial_state;
-	sm->current_state_id    = initial_state;
-	sm->state_table         = state_table;
-}
-
-/**
- * This method will cause the state machine to enter the initial state.
- * @sm: This parameter specifies the state machine that is to
- *    be started.
- *
- * sci_base_state_machine_construct() for how to set the initial state none
- */
-void sci_base_state_machine_start(struct sci_base_state_machine *sm)
-{
-	sm->current_state_id = sm->initial_state_id;
-	sci_state_machine_enter_state(sm);
-}
-
-/**
- * This method will cause the state machine to exit it's current state only.
- * @sm: This parameter specifies the state machine that is to
- *    be stopped.
- *
- */
-void sci_base_state_machine_stop(
-	struct sci_base_state_machine *sm)
-{
-	sci_state_machine_exit_state(sm);
-}
-
-void sci_change_state(struct sci_base_state_machine *sm, u32 next_state)
-{
-	sci_state_machine_exit_state(sm);
-
-	sm->previous_state_id = sm->current_state_id;
-	sm->current_state_id = next_state;
-
-	sci_state_machine_enter_state(sm);
-}
diff --git a/drivers/scsi/isci/state_machine.h b/drivers/scsi/isci/state_machine.h
deleted file mode 100644
index 6cb55a0..0000000
--- a/drivers/scsi/isci/state_machine.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SCI_BASE_STATE_MACHINE_H_
-#define _SCI_BASE_STATE_MACHINE_H_
-
-#include <linux/types.h>
-
-struct sci_base_state_machine;
-typedef void (*sci_base_state_handler_t)(void);
-typedef void (*sci_state_transition_t)(struct sci_base_state_machine *sm);
-
-/**
- * struct sci_base_state - The base state object abstracts the fields common to
- *    all state objects defined in SCI.
- *
- *
- */
-struct sci_base_state {
-	/**
-	 * This field is a function pointer that defines the method to be
-	 * invoked when the state is entered.
-	 */
-	sci_state_transition_t enter_state;
-
-	/**
-	 * This field is a function pointer that defines the method to be
-	 * invoked when the state is exited.
-	 */
-	sci_state_transition_t exit_state;
-};
-
-/**
- * struct sci_base_state_machine - This structure defines the fields common to
- *    all state machines.
- *
- *
- */
-struct sci_base_state_machine {
-	/**
-	 * This field points to the start of the state machine's state table.
-	 */
-	const struct sci_base_state *state_table;
-
-	/**
-	 * This field simply indicates the state value for the state machine's
-	 * initial state.
-	 */
-	u32 initial_state_id;
-
-	/**
-	 * This field indicates the current state of the state machine.
-	 */
-	u32 current_state_id;
-
-	/**
-	 * This field indicates the previous state of the state machine.
-	 */
-	u32 previous_state_id;
-
-};
-
-void sci_base_state_machine_construct(struct sci_base_state_machine *sm,
-				      const struct sci_base_state *state_table,
-				      u32 initial_state);
-void sci_base_state_machine_start(struct sci_base_state_machine *sm);
-void sci_base_state_machine_stop(struct sci_base_state_machine *sm);
-void sci_change_state(struct sci_base_state_machine *sm, u32 next_state);
-
-#endif /* _SCI_BASE_STATE_MACHINE_H_ */
-- 
1.6.0.2

