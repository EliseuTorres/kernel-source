From 6ba40693f034f12040eb8561befc8390bf54e9fc Mon Sep 17 00:00:00 2001
From: Shyam Iyer <shyam.iyer.t@gmail.com>
Date: Thu, 14 Jul 2011 15:00:32 +0000
Subject: [PATCH 1/3] Separate handling of irq type flags variable from the irq_flags request_irq variable
Git-commit: 8279171a5fe95902be12f4018907f246d51616d4
Patch-mainline: v3.1-rc1
References: bnc#689230, fate#311451

Commit 5f77898de17ff983ff0e2988b73a6bdf4b6f9f8b does not completely
fix the problem of handling allocations with irqs disabled..  The
below patch on top of it fixes the problem completely.

Based on review by "Ivan Vecera" <ivecera@redhat.com>..
"
Small note, the root of the problem was that non-atomic allocation was requested with IRQs disabled. Your patch description does not contain wwhy were the IRQs disabled.

The function bnad_mbox_irq_alloc incorrectly uses 'flags' var for two different things, 1) to save current CPU flags and 2) for request_irq
call.
First the spin_lock_irqsave disables the IRQs and saves _all_ CPU flags (including one that enables/disables interrupts) to 'flags'. Then the 'flags' is overwritten by 0 or 0x80 (IRQF_SHARED). Finally the spin_unlock_irqrestore should restore saved flags, but these flags are now either 0x00 or 0x80. The interrupt bit value in flags register on x86 arch is 0x100.
This means that the interrupt bit is zero (IRQs disabled) after spin_unlock_irqrestore so the request_irq function is called with disabled interrupts.
"

Signed-off-by: Shyam Iyer <shyam_iyer@dell.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Michal Marek <mmarek@suse.cz>

---
 drivers/net/bna/bnad.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/net/bna/bnad.c b/drivers/net/bna/bnad.c
index 4b1b012..6ec4f63 100644
--- a/drivers/net/bna/bnad.c
+++ b/drivers/net/bna/bnad.c
@@ -1195,7 +1195,7 @@ static int
 bnad_mbox_irq_alloc(struct bnad *bnad)
 {
 	int		err = 0;
-	unsigned long	irq_flags = 0, flags;
+	unsigned long	irq_flags, flags;
 	u32	irq;
 	irq_handler_t	irq_handler;
 
@@ -1203,6 +1203,7 @@ bnad_mbox_irq_alloc(struct bnad *bnad)
 	if (bnad->cfg_flags & BNAD_CF_MSIX) {
 		irq_handler = (irq_handler_t)bnad_msix_mbox_handler;
 		irq = bnad->msix_table[BNAD_MAILBOX_MSIX_INDEX].vector;
+		irq_flags = 0;
 	} else {
 		irq_handler = (irq_handler_t)bnad_isr;
 		irq = bnad->pcidev->irq;
@@ -1210,7 +1211,6 @@ bnad_mbox_irq_alloc(struct bnad *bnad)
 	}
 
 	spin_unlock_irqrestore(&bnad->bna_lock, flags);
-	flags = irq_flags;
 	sprintf(bnad->mbox_irq_name, "%s", BNAD_NAME);
 
 	/*
@@ -1221,7 +1221,7 @@ bnad_mbox_irq_alloc(struct bnad *bnad)
 
 	BNAD_UPDATE_CTR(bnad, mbox_intr_disabled);
 
-	err = request_irq(irq, irq_handler, flags,
+	err = request_irq(irq, irq_handler, irq_flags,
 			  bnad->mbox_irq_name, bnad);
 
 	return err;
-- 
1.7.1

