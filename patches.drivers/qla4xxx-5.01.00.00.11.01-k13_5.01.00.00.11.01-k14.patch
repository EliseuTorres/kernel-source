From: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
Subject: QLA4xxx driver fixes for RC3
References: bnc#585296
Patch-Mainline: Submitted to linux-scsi

This patch addresses following issues:

1.    Fix ACB version 2 support.
        -    Fix is needed to support ACB version 2 correctly.
2.    Fix the freeing of the buffer allocated for DMA
        -    This fix is needed for issue ddb showing connection error. We
             found this issue on Xen kernel.
             This issue is because DDB DMA allocated memory is not freed
             correctly. 
3.    Add support to modify session recovery timeout from application.
4.    Add support to handle SRB_SCSI_PASSTHRU commands send by qisioctl module.
        -    This fix is needed to show LUN information from application.
5.    Initialize “ddb_entry->options” correctly.
        -    This fix is needed to handle IPv6 correctly.

Acked-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/qla4xxx/ql4_def.h b/drivers/scsi/qla4xxx/ql4_def.h
index 1444757..447259d 100644
--- a/drivers/scsi/qla4xxx/ql4_def.h
+++ b/drivers/scsi/qla4xxx/ql4_def.h
@@ -186,8 +186,6 @@ struct srb {
 	uint16_t iocb_cnt;	/* Number of used iocbs */
 	uint16_t cc_stat;
 	uint32_t dma_len;
-	u_long r_start;		/* Time we recieve a cmd from OS */
-	u_long u_start;		/* Time when we handed the cmd to F/W */
 
 	/* Used for extended sense / status continuation */
 	uint8_t *req_sense_ptr;
@@ -225,7 +223,7 @@ struct ddb_entry {
 
 	uint16_t os_target_id;	/* Target ID */
 	uint16_t fw_ddb_index;	/* DDB firmware index */
-	uint8_t options;
+	uint16_t options;
 	uint32_t fw_ddb_device_state; /* F/W Device State  -- see ql4_fw.h */
 
 	uint32_t CmdSn;
@@ -247,13 +245,13 @@ struct ddb_entry {
 	atomic_t relogin_timer;	/* Max Time to wait for relogin to complete */
 	atomic_t relogin_retry_count; /* Num of times relogin has been
 				       * retried */
-
 	uint16_t port;
 	uint32_t tpgt;
 	uint8_t ip_addr[IP_ADDR_LEN];
 	uint8_t iscsi_name[ISCSI_NAME_SIZE];	/* 72 x48 */
 	uint8_t iscsi_alias[0x20];
 	uint8_t isid[6];
+	uint16_t ka_timeout;
 
 	struct in6_addr remote_ipv6_addr;
 	struct in6_addr link_local_ipv6_addr;
diff --git a/drivers/scsi/qla4xxx/ql4_fw.h b/drivers/scsi/qla4xxx/ql4_fw.h
index 868cb0f..88a775c 100644
--- a/drivers/scsi/qla4xxx/ql4_fw.h
+++ b/drivers/scsi/qla4xxx/ql4_fw.h
@@ -281,6 +281,7 @@ union external_hw_config_reg {
 #define MBOX_STS_INTERMEDIATE_COMPLETION	0x1000
 #define MBOX_STS_COMMAND_COMPLETE		0x4000
 #define MBOX_STS_COMMAND_ERROR			0x4005
+#define MBOX_STS_COMMAND_PARAMETER_ERROR	0x4006
 
 #define MBOX_ASYNC_EVENT_STATUS			8
 #define MBOX_ASTS_SYSTEM_ERROR			0x8002
diff --git a/drivers/scsi/qla4xxx/ql4_init.c b/drivers/scsi/qla4xxx/ql4_init.c
index 17994d4..a5f7d2f 100644
--- a/drivers/scsi/qla4xxx/ql4_init.c
+++ b/drivers/scsi/qla4xxx/ql4_init.c
@@ -437,7 +437,7 @@ static struct ddb_entry* qla4xxx_get_ddb_entry(struct scsi_qla_host *ha,
 	if (fw_ddb_entry == NULL) {
 		DEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",
 			      ha->host_no, __func__));
-		return NULL;
+		goto exit_get_ddb_entry_no_free;
 	}
 
 	if (qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,
@@ -447,7 +447,7 @@ static struct ddb_entry* qla4xxx_get_ddb_entry(struct scsi_qla_host *ha,
 		DEBUG2(printk("scsi%ld: %s: failed get_ddb_entry for "
 			      "fw_ddb_index %d\n", ha->host_no, __func__,
 			      fw_ddb_index));
-		return NULL;
+		goto exit_get_ddb_entry;
 	}
 
 	/* Allocate DDB if not already allocated. */
@@ -474,9 +474,11 @@ static struct ddb_entry* qla4xxx_get_ddb_entry(struct scsi_qla_host *ha,
 	}
 
 	/* if not found allocate new ddb */
+exit_get_ddb_entry:
 	dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry), fw_ddb_entry,
 			  fw_ddb_entry_dma);
 
+exit_get_ddb_entry_no_free:
 	return ddb_entry;
 }
 
@@ -504,7 +506,7 @@ static int qla4xxx_update_ddb_entry(struct scsi_qla_host *ha,
 	if (ddb_entry == NULL) {
 		DEBUG2(printk("scsi%ld: %s: ddb_entry is NULL\n", ha->host_no,
 			      __func__));
-		goto exit_update_ddb;
+		goto exit_update_ddb_no_free;
 	}
 
 	/* Make sure the dma buffer is valid */
@@ -515,7 +517,7 @@ static int qla4xxx_update_ddb_entry(struct scsi_qla_host *ha,
 		DEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",
 			      ha->host_no, __func__));
 
-		goto exit_update_ddb;
+		goto exit_update_ddb_no_free;
 	}
 
 	if ((qla4xxx_get_fwddb_entry(ha, fw_ddb_index, fw_ddb_entry,
@@ -532,6 +534,7 @@ static int qla4xxx_update_ddb_entry(struct scsi_qla_host *ha,
 		goto exit_update_ddb;
 	}
 
+	ddb_entry->options = le16_to_cpu(fw_ddb_entry->options);
 	ddb_entry->target_session_id = le16_to_cpu(fw_ddb_entry->tsid);
 	ddb_entry->task_mgmt_timeout =
 		le16_to_cpu(fw_ddb_entry->def_timeout);
@@ -540,6 +543,9 @@ static int qla4xxx_update_ddb_entry(struct scsi_qla_host *ha,
 	ddb_entry->default_relogin_timeout =
 		le16_to_cpu(fw_ddb_entry->def_timeout);
 	ddb_entry->default_time2wait = le16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);
+	ddb_entry->ka_timeout = le16_to_cpu(fw_ddb_entry->ka_timeout);
+	if (ddb_entry->sess)
+		ddb_entry->sess->recovery_tmo = ddb_entry->ka_timeout;
 
 	/* Update index in case it changed */
 	ddb_entry->fw_ddb_index = fw_ddb_index;
@@ -576,11 +582,12 @@ static int qla4xxx_update_ddb_entry(struct scsi_qla_host *ha,
 					le16_to_cpu(fw_ddb_entry->port),
 					fw_ddb_entry->iscsi_name));
 
- exit_update_ddb:
+exit_update_ddb:
 	if (fw_ddb_entry)
 		dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
 				  fw_ddb_entry, fw_ddb_entry_dma);
 
+exit_update_ddb_no_free:
 	return status;
 }
 
@@ -664,7 +671,7 @@ int qla4_is_relogin_allowed(struct scsi_qla_host *ha, uint32_t conn_err)
  **/
 static int qla4xxx_build_ddb_list(struct scsi_qla_host *ha)
 {
-	int status = QLA_SUCCESS;
+	int status = QLA_ERROR;
 	uint32_t fw_ddb_index = 0;
 	uint32_t next_fw_ddb_index = 0;
 	uint32_t ddb_state;
@@ -679,7 +686,7 @@ static int qla4xxx_build_ddb_list(struct scsi_qla_host *ha)
 						&fw_ddb_entry_dma, GFP_KERNEL);
 	if (fw_ddb_entry == NULL) {
 		DEBUG2(dev_info(&ha->pdev->dev, "%s: DMA alloc failed\n", __func__));
-		return QLA_ERROR;
+		goto exit_build_ddb_list_no_free;
 	}
 
 	dev_info(&ha->pdev->dev, "Initializing DDBs ...\n");
@@ -693,7 +700,7 @@ static int qla4xxx_build_ddb_list(struct scsi_qla_host *ha)
 			DEBUG2(printk("scsi%ld: %s: get_ddb_entry, "
 				      "fw_ddb_index %d failed", ha->host_no,
 				      __func__, fw_ddb_index));
-			return QLA_ERROR;
+			goto exit_build_ddb_list;
 		}
 
 		DEBUG2(printk("scsi%ld: %s: Getting DDB[%d] ddbstate=0x%x, "
@@ -720,7 +727,7 @@ static int qla4xxx_build_ddb_list(struct scsi_qla_host *ha)
 						"get_ddb_entry %d failed\n",
 						ha->host_no,
 						__func__, fw_ddb_index));
-					return QLA_ERROR;
+					goto exit_build_ddb_list;
 				}
 			}
 		}
@@ -740,7 +747,7 @@ static int qla4xxx_build_ddb_list(struct scsi_qla_host *ha)
 			DEBUG2(printk("scsi%ld: %s: Unable to allocate memory "
 				      "for device at fw_ddb_index %d\n",
 				      ha->host_no, __func__, fw_ddb_index));
-			return QLA_ERROR;
+			goto exit_build_ddb_list;
 		}
 		/* Fill in the device structure */
 		if (qla4xxx_update_ddb_entry(ha, ddb_entry, fw_ddb_index) ==
@@ -752,7 +759,7 @@ static int qla4xxx_build_ddb_list(struct scsi_qla_host *ha)
 			DEBUG2(printk("scsi%ld: %s: update_ddb_entry failed "
 				      "for fw_ddb_index %d.\n",
 				      ha->host_no, __func__, fw_ddb_index));
-			return QLA_ERROR;
+			goto exit_build_ddb_list;
 		}
 
 next_one:
@@ -761,9 +768,14 @@ next_one:
 		if (next_fw_ddb_index == 0)
 			break;
 	}
-
+	status = QLA_SUCCESS;
 	dev_info(&ha->pdev->dev, "DDB list done..\n");
 
+exit_build_ddb_list:
+	dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry), fw_ddb_entry,
+			  fw_ddb_entry_dma);
+
+exit_build_ddb_list_no_free:
 	return status;
 }
 
@@ -1093,6 +1105,12 @@ static int qla4xxx_start_firmware_from_flash(struct scsi_qla_host *ha)
 		     ha->host_no, __func__));
 
 	spin_lock_irqsave(&ha->hardware_lock, flags);
+	writel(jiffies, &ha->reg->mailbox[7]);
+
+	if (is_qla4022(ha) | is_qla4032(ha))
+		writel(set_rmask(NVR_WRITE_ENABLE),
+		    &ha->reg->u1.isp4022.nvram);
+
 	/*
 	 * Firmware must be informed that the driver supports
 	 * ACB firmware features while starting firmware.
@@ -1100,13 +1118,7 @@ static int qla4xxx_start_firmware_from_flash(struct scsi_qla_host *ha)
 	 * be indicated in the IFCB offset 0x3A (acb_version).
 	 */
 	writel(ACB_SUPPORTED, &ha->reg->mailbox[6]);
-	writel(jiffies, &ha->reg->mailbox[7]);
-	if (is_qla4022(ha) | is_qla4032(ha))
-		writel(set_rmask(NVR_WRITE_ENABLE),
-		       &ha->reg->u1.isp4022.nvram);
-
-        writel(2, &ha->reg->mailbox[6]);
-        readl(&ha->reg->mailbox[6]);
+	readl(&ha->reg->mailbox[6]);
 
 	writel(set_rmask(CSR_BOOT_ENABLE), &ha->reg->ctrl_status);
 	readl(&ha->reg->ctrl_status);
diff --git a/drivers/scsi/qla4xxx/ql4_iocb.c b/drivers/scsi/qla4xxx/ql4_iocb.c
index 4212509..04c2cc7 100644
--- a/drivers/scsi/qla4xxx/ql4_iocb.c
+++ b/drivers/scsi/qla4xxx/ql4_iocb.c
@@ -160,15 +160,22 @@ static void qla4xxx_build_scsi_iocbs(struct srb *srb,
 	cmd = srb->cmd;
 	ha = srb->ha;
 
+	avail_dsds = COMMAND_SEG;
+	cur_dsd = (struct data_seg_a64 *) & (cmd_entry->dataseg[0]);
+
+	if (srb->flags & SRB_SCSI_PASSTHRU) {
+		cur_dsd->base.addrLow = cpu_to_le32(LSDW(srb->dma_handle));
+		cur_dsd->base.addrHigh = cpu_to_le32(MSDW(srb->dma_handle));
+		cur_dsd->count = cpu_to_le32(srb->dma_len);
+		return;
+	}
+
 	if (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {
 		/* No data being transferred */
 		cmd_entry->ttlByteCnt = __constant_cpu_to_le32(0);
 		return;
 	}
 
-	avail_dsds = COMMAND_SEG;
-	cur_dsd = (struct data_seg_a64 *) & (cmd_entry->dataseg[0]);
-
 	scsi_for_each_sg(cmd, sg, tot_dsds, i) {
 		dma_addr_t sle_dma;
 
@@ -255,10 +262,14 @@ int qla4xxx_send_command_to_isp(struct scsi_qla_host *ha, struct srb * srb)
 	}
 
 	/* Calculate the number of request entries needed. */
-	nseg = scsi_dma_map(cmd);
-	if (nseg < 0)
-		goto queuing_error;
-	tot_dsds = nseg;
+	if (srb->flags & SRB_SCSI_PASSTHRU)
+		tot_dsds = 1;
+	else {
+		nseg = scsi_dma_map(cmd);
+		if (nseg < 0)
+			goto queuing_error;
+		tot_dsds = nseg;
+	}
 
 	req_cnt = qla4xxx_calc_request_entries(tot_dsds);
 	if (!qla4xxx_space_in_req_ring(ha, req_cnt))
@@ -337,8 +348,9 @@ int qla4xxx_send_command_to_isp(struct scsi_qla_host *ha, struct srb * srb)
 	return QLA_SUCCESS;
 
 queuing_error:
-	if (tot_dsds)
-		scsi_dma_unmap(cmd);
+	if (!(srb->flags & SRB_SCSI_PASSTHRU))
+		if (tot_dsds)
+			scsi_dma_unmap(cmd);
 
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
diff --git a/drivers/scsi/qla4xxx/ql4_mbx.c b/drivers/scsi/qla4xxx/ql4_mbx.c
index dfccddb..886cfb5 100644
--- a/drivers/scsi/qla4xxx/ql4_mbx.c
+++ b/drivers/scsi/qla4xxx/ql4_mbx.c
@@ -276,7 +276,7 @@ qla4xxx_get_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd, uint32_t *mbox_st
 	if (qla4xxx_mailbox_command(ha, 5, 5, mbox_cmd, mbox_sts)
 		!= QLA_SUCCESS) {
 		if (init_fw_cb_dma == 0 &&
-			mbox_sts[0] == MBOX_STS_COMMAND_ERROR)
+		    mbox_sts[0] == MBOX_STS_COMMAND_PARAMETER_ERROR)
 			return (QLA_SUCCESS);
 
 		DEBUG2(printk("scsi%ld: %s: "
@@ -383,15 +383,28 @@ int qla4xxx_initialize_fw_cb(struct scsi_qla_host * ha)
 	/* Default to Legacy IFCB Size */
 	ha->ifcb_size = LEGACY_IFCB_SIZE;
 
+	if (qla4xxx_get_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], 0) !=
+	    QLA_SUCCESS) {
+		DEBUG2(printk("scsi%ld: %s: get ifcb failed\n",
+			       ha->host_no, __func__));
+		return status;
+	}
+
+	if (mbox_sts[0] == MBOX_STS_COMMAND_PARAMETER_ERROR &&
+	    mbox_sts[4] > LEGACY_IFCB_SIZE) {
+		/* Supports larger ifcb size */
+		ha->ifcb_size = mbox_sts[4] / 2;
+	}
+
 	init_fw_cb = dma_alloc_coherent(&ha->pdev->dev,
-					sizeof(struct addr_ctrl_blk),
+					ha->ifcb_size,
 					&init_fw_cb_dma, GFP_KERNEL);
 	if (init_fw_cb == NULL) {
 		DEBUG2(printk("scsi%ld: %s: Unable to alloc init_cb\n",
-			      ha->host_no, __func__));
-		return 10;
+			       ha->host_no, __func__));
+		goto exit_init_fw_cb_no_free;
 	}
-	memset(init_fw_cb, 0, sizeof(struct addr_ctrl_blk));
+	memset(init_fw_cb, 0, ha->ifcb_size);
 
 	/* Get Initialize Firmware Control Block. */
 	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
@@ -408,12 +421,6 @@ int qla4xxx_initialize_fw_cb(struct scsi_qla_host * ha)
 		goto exit_init_fw_cb;
 	}
 
-	if (mbox_sts[0] == MBOX_STS_COMMAND_ERROR &&
-		mbox_sts[4] > LEGACY_IFCB_SIZE) {
-		/* Supports larger ifcb size */
-		ha->ifcb_size = mbox_sts[4];
-	}
-
 	/* Initialize request and response queues. */
 	qla4xxx_init_rings(ha);
 
@@ -454,6 +461,7 @@ exit_init_fw_cb:
 	dma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),
 				init_fw_cb, init_fw_cb_dma);
 
+exit_init_fw_cb_no_free:
 	return status;
 }
 
@@ -467,6 +475,7 @@ int qla4xxx_get_dhcp_ip_address(struct scsi_qla_host * ha)
 	dma_addr_t init_fw_cb_dma;
 	uint32_t mbox_cmd[MBOX_REG_COUNT];
 	uint32_t mbox_sts[MBOX_REG_COUNT];
+	uint8_t	status = QLA_ERROR;
 
 	init_fw_cb = dma_alloc_coherent(&ha->pdev->dev,
 					sizeof(struct addr_ctrl_blk),
@@ -474,7 +483,7 @@ int qla4xxx_get_dhcp_ip_address(struct scsi_qla_host * ha)
 	if (init_fw_cb == NULL) {
 		printk("scsi%ld: %s: Unable to alloc init_cb\n", ha->host_no,
 		       __func__);
-		return 10;
+		goto exit_get_dhcp_ip_address_no_free;
 	}
 
 	/* Get Initialize Firmware Control Block. */
@@ -483,18 +492,19 @@ int qla4xxx_get_dhcp_ip_address(struct scsi_qla_host * ha)
 		!= QLA_SUCCESS) {
 		DEBUG2(printk("scsi%ld: %s: Failed to get init_fw_ctrl_blk\n",
 			      ha->host_no, __func__));
-		dma_free_coherent(&ha->pdev->dev,
-				  sizeof(struct addr_ctrl_blk),
-				  init_fw_cb, init_fw_cb_dma);
-		return QLA_ERROR;
+		goto exit_get_dhcp_ip_address;
 	}
 
 	/* Save IP Address. */
 	qla4xxx_update_local_ip(ha, init_fw_cb);
+	status = QLA_SUCCESS;
+
+exit_get_dhcp_ip_address:
 	dma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),
 				init_fw_cb, init_fw_cb_dma);
 
-	return QLA_SUCCESS;
+exit_get_dhcp_ip_address_no_free:
+	return status;
 }
 
 /**
@@ -1102,7 +1112,7 @@ int qla4xxx_send_tgts(struct scsi_qla_host *ha, char *ip, uint16_t port)
 		DEBUG2(printk("scsi%ld: %s: Unable to allocate dma buffer.\n",
 			      ha->host_no, __func__));
 		ret_val = QLA_ERROR;
-		goto qla4xxx_send_tgts_exit;
+		goto qla4xxx_send_tgts_exit_no_exit;
 	}
 
 	ret_val = qla4xxx_get_default_ddb(ha, fw_ddb_entry_dma);
@@ -1136,6 +1146,8 @@ int qla4xxx_send_tgts(struct scsi_qla_host *ha, char *ip, uint16_t port)
 qla4xxx_send_tgts_exit:
 	dma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),
 			  fw_ddb_entry, fw_ddb_entry_dma);
+
+qla4xxx_send_tgts_exit_no_exit:
 	return ret_val;
 }
 
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index f7202f9..1b5bf80 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -298,7 +298,7 @@ int qla4xxx_add_sess(struct ddb_entry *ddb_entry)
 {
 	int err;
 
-	ddb_entry->sess->recovery_tmo = ddb_entry->ha->port_down_retry_count;
+	ddb_entry->sess->recovery_tmo = ddb_entry->ka_timeout;
 	err = iscsi_add_session(ddb_entry->sess, ddb_entry->fw_ddb_index);
 	if (err) {
 		DEBUG2(printk(KERN_ERR "Could not add session.\n"));
diff --git a/drivers/scsi/qla4xxx/ql4_version.h b/drivers/scsi/qla4xxx/ql4_version.h
index 263daab..b44d110 100644
--- a/drivers/scsi/qla4xxx/ql4_version.h
+++ b/drivers/scsi/qla4xxx/ql4_version.h
@@ -5,5 +5,5 @@
  * See LICENSE.qla4xxx for copyright and licensing details.
  */
 
-#define QLA4XXX_DRIVER_VERSION	"5.01.00.00.11.01-k13"
+#define QLA4XXX_DRIVER_VERSION	"5.01.00.00.11.01-k14"
 
