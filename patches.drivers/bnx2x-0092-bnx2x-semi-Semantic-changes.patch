From: Yuval Mintz <yuvalmin@broadcom.com>
Date: Sun, 2 Jun 2013 00:06:21 +0000
Subject: [PATCH 092/242] bnx2x: semi-Semantic changes
Patch-mainline: v3.11-rc1

Git-commit: 639d65b85592cf31eca24f33ff00e309ebbf0d2b
References: bsc#908684 FATE#317539


This patch includes a few changes that change the driver's flow without truly
changing anything in its functionality - use usleep_range for short sleeps
instead of msleep and initialize Tx consumer during initialization for better
information during errors.

Signed-off-by: Yuval Mintz <yuvalmin@broadcom.com>
Signed-off-by: Ariel Elior <ariele@broadcom.com>
Signed-off-by: Eilon Greenstein <eilong@broadcom.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Cho, Yu-Chen <acho@suse.com>
---
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c |   14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@ -1954,7 +1954,7 @@ int bnx2x_acquire_hw_lock(struct bnx2x *
 		if (lock_status & resource_bit)
 			return 0;
 
-		msleep(5);
+		usleep_range(5000, 10000);
 	}
 	BNX2X_ERR("Timeout\n");
 	return -EAGAIN;
@@ -3639,7 +3639,7 @@ static int bnx2x_acquire_alr(struct bnx2
 		if (val & MCPR_ACCESS_LOCK_LOCK)
 			break;
 
-		msleep(5);
+		usleep_range(5000, 10000);
 	}
 	if (!(val & MCPR_ACCESS_LOCK_LOCK)) {
 		BNX2X_ERR("Cannot acquire MCP access lock register\n");
@@ -6077,6 +6077,8 @@ static void bnx2x_init_tx_ring_one(struc
 				    BCM_PAGE_SIZE*(i % NUM_TX_RINGS)));
 	}
 
+	*txdata->tx_cons_sb = cpu_to_le16(0);
+
 	SET_FLAG(txdata->tx_db.data.header.header, DOORBELL_HDR_DB_TYPE, 1);
 	txdata->tx_db.data.zero_fill1 = 0;
 	txdata->tx_db.data.prod = 0;
@@ -6328,7 +6330,7 @@ static int bnx2x_int_mem_test(struct bnx
 		if (val == 0x10)
 			break;
 
-		msleep(10);
+		usleep_range(10000, 20000);
 		count--;
 	}
 	if (val != 0x10) {
@@ -6343,7 +6345,7 @@ static int bnx2x_int_mem_test(struct bnx
 		if (val == 1)
 			break;
 
-		msleep(10);
+		usleep_range(10000, 20000);
 		count--;
 	}
 	if (val != 0x1) {
@@ -6384,7 +6386,7 @@ static int bnx2x_int_mem_test(struct bnx
 		if (val == 0xb0)
 			break;
 
-		msleep(10);
+		usleep_range(10000, 20000);
 		count--;
 	}
 	if (val != 0xb0) {
@@ -8499,7 +8501,7 @@ static void bnx2x_reset_func(struct bnx2
 		 * scan to complete
 		 */
 		for (i = 0; i < 200; i++) {
-			msleep(10);
+			usleep_range(10000, 20000);
 			if (!REG_RD(bp, TM_REG_LIN0_SCAN_ON + port*4))
 				break;
 		}
