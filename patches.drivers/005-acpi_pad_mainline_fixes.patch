From: Venkatesh Pallipadi <venki@google.com>
Subject: ACPI: Don't let acpi_pad needlessly mark TSC unstable
References: fate#311793
Patch-Mainline: yes
Git-commit: 0dc698b93f3eecdda43b22232131324eb41e510c


Signed-off-by: Thomas Renninger <trenn@suse.de>

acpi pad driver kind of aggressively marks TSC as unstable at init
time, on mwait capable and non X86_FEATURE_NONSTOP_TSC systems. This is
irrespective of whether pad driver is ever going to be used on the
system or deep C-states are supported/used. This will affect every user
who just happens to compile in (or get a kernel version which
compiles in) acpi pad driver.

Move mark_tsc_unstable() out of init to the actual idle invocation path
of the pad driver.

There is also another bug/missing_feature in the code that it does not
support 'always running apic timer' and switches to broadcast mode
unconditionally. Shaohua, can you take a look at that please.

Signed-off-by: Venkatesh Pallipadi <venki@google.com>
Signed-off-by: Len Brown <len.brown@intel.com>

---
 drivers/acpi/acpi_pad.c |   13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

Index: linux-2.6.32-SLE11-SP2/drivers/acpi/acpi_pad.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/drivers/acpi/acpi_pad.c
+++ linux-2.6.32-SLE11-SP2/drivers/acpi/acpi_pad.c
@@ -37,6 +37,10 @@
 static DEFINE_MUTEX(isolated_cpus_lock);
 
 static unsigned long power_saving_mwait_eax;
+
+static unsigned char tsc_detected_unstable;
+static unsigned char tsc_marked_unstable;
+
 static void power_saving_mwait_init(void)
 {
 	unsigned int eax, ebx, ecx, edx;
@@ -81,8 +85,8 @@ static void power_saving_mwait_init(void
 
 		/*FALL THROUGH*/
 	default:
-		/* TSC could halt in idle, so notify users */
-		mark_tsc_unstable("TSC halts in idle");
+		/* TSC could halt in idle */
+		tsc_detected_unstable = 1;
 	}
 #endif
 }
@@ -165,6 +169,11 @@ static int power_saving_thread(void *dat
 		expire_time = jiffies + HZ * (100 - idle_pct) / 100;
 
 		while (!need_resched()) {
+			if (tsc_detected_unstable && !tsc_marked_unstable) {
+				/* TSC could halt in idle, so notify users */
+				mark_tsc_unstable("TSC halts in idle");
+				tsc_marked_unstable = 1;
+			}
 			local_irq_disable();
 			cpu = smp_processor_id();
 			clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER,
