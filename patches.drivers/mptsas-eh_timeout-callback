From: Kashyap Desai <kashyap.desai@lsi.com>
Subject: mptsas offlines paths after cable pull
References: bnc#603411
Patch-Mainline: Not yet

When cable pull is done by the user, all devices are in
deleting state (not exactly deleted). This is due to a
feature of the LSI firmware (Device missing delay).
See message below:
--
May 10 15:01:58 falcons kernel: [  371.923362] mptbase: ioc0:
LogInfo(0x31170000): Originator={PL}, Code={IO Device Missing Delay Retry},
SubCode(0x0000)
---

In this state the path is still active and commands can
be sent to it. Normally they will be retried and failed
after the delay has exceeded.

The pathchecker commands normally do not have retries.
So once those commands are failed, the path will be
marked as failed from multipathd. Eventually it will try
to clear all pending commands calling blk_abort_request()....

Entering into Error handling thread for device which are
in *deleting* state is causing issue.

We have solve this using 
_transport_template->eh_timed_out callback.

Signed-off-by: Kashyap Desai <kashyap.desai@lsi.com>
Acked-by: Hannes Reinecke <hare@suse.de>

diff -Naurp a/drivers/message/fusion/mptbase.h b/drivers/message/fusion/mptbase.h
--- a/drivers/message/fusion/mptbase.h	2010-05-19 13:38:33.000000000 +0530
+++ b/drivers/message/fusion/mptbase.h	2010-05-19 13:45:47.000000000 +0530
@@ -420,6 +420,8 @@ typedef struct _VirtTarget {
 	u8			 raidVolume;	/* set, if RAID Volume */
 	u8			 type;		/* byte 0 of Inquiry data */
 	u8			 deleted;	/* target in process of being removed */
+	u8			 inDMD;		/* currently in the device 
+						   removal delay timer */
 	int			 num_luns;
 } VirtTarget;
 
diff -Naurp a/drivers/message/fusion/mptsas.c b/drivers/message/fusion/mptsas.c
--- a/drivers/message/fusion/mptsas.c	2010-05-19 13:38:33.000000000 +0530
+++ b/drivers/message/fusion/mptsas.c	2010-05-19 13:46:40.000000000 +0530
@@ -58,6 +58,7 @@
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_transport_sas.h>
+#include <scsi/scsi_transport.h>
 #include <scsi/scsi_dbg.h>
 
 #include "mptbase.h"
@@ -2330,6 +2331,46 @@ mptsas_qcmd(struct scsi_cmnd *SCpnt, voi
 	return mptscsih_qcmd(SCpnt,done);
 }
 
+/**
+ *	mptsas_mptsas_eh_timed_out - resets the scsi_cmnd timeout
+ *		if the device under question is currently in the
+ *		device removal delay. 
+ *	@sc: scsi command that the midlayer is about to time out
+ *
+ **/
+static enum blk_eh_timer_return mptsas_eh_timed_out(struct scsi_cmnd *sc)
+{
+	MPT_SCSI_HOST *hd;
+	MPT_ADAPTER   *ioc;
+	VirtDevice    *vdevice;
+	enum blk_eh_timer_return rc = BLK_EH_NOT_HANDLED;
+
+	if ((hd = shost_priv(sc->device->host)) == NULL) {
+		printk(KERN_ERR MYNAM ": %s: Can't locate host! (sc=%p)\n",
+		    __func__, sc );
+		goto done;
+	}
+
+	ioc = hd->ioc;
+	if (ioc->bus_type != SAS) {
+		printk(KERN_ERR MYNAM ": %s: Wrong bus type (sc=%p)\n",
+		    __func__, sc );
+		goto done;
+	}
+
+	vdevice = sc->device->hostdata;
+	if (vdevice && vdevice->vtarget && vdevice->vtarget->inDMD) {
+		dtmprintk(ioc, printk(MYIOC_s_WARN_FMT ": %s: target removed "
+		    "or in device removal delay (sc=%p)\n",
+		    ioc->name, __func__, sc ));
+		rc = BLK_EH_RESET_TIMER;
+		goto done;
+	}
+
+done:
+	return rc;
+}
+
 
 static struct scsi_host_template mptsas_driver_template = {
 	.module				= THIS_MODULE,
@@ -3498,6 +3539,7 @@ static int mptsas_probe_one_phy(struct d
 	struct sas_phy *phy;
 	struct sas_port *port;
 	int error = 0;
+	VirtTarget *vtarget;
 
 	if (!dev) {
 		error = -ENODEV;
@@ -3717,6 +3759,16 @@ static int mptsas_probe_one_phy(struct d
 			    rphy_to_expander_device(rphy));
 	}
 
+	/* If the device exists,verify it wasn't previously flagged
+	as a missing device.  If so, clear it */
+	vtarget = mptsas_find_vtarget(ioc,
+	    phy_info->attached.channel,
+	    phy_info->attached.id);
+	if (vtarget && vtarget->inDMD) {
+		printk(KERN_INFO "Device returned, unsetting inDMD\n");
+		vtarget->inDMD = 0;
+	}
+
  out:
 	return error;
 }
@@ -5778,6 +5830,7 @@ mptsas_init(void)
 	    sas_attach_transport(&mptsas_transport_functions);
 	if (!mptsas_transport_template)
 		return -ENODEV;
+	mptsas_transport_template->eh_timed_out = mptsas_eh_timed_out;
 
 	mptsasDoneCtx = mpt_register(mptscsih_io_done, MPTSAS_DRIVER);
 	mptsasTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSAS_DRIVER);
diff -Naurp a/drivers/message/fusion/mptscsih.c b/drivers/message/fusion/mptscsih.c
--- a/drivers/message/fusion/mptscsih.c	2010-05-19 13:38:33.000000000 +0530
+++ b/drivers/message/fusion/mptscsih.c	2010-05-19 13:45:47.000000000 +0530
@@ -740,7 +740,18 @@ mptscsih_io_done(MPT_ADAPTER *ioc, MPT_F
 				if (ioc_status & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {
 					if ((log_info & SAS_LOGINFO_MASK)
 					    == SAS_LOGINFO_NEXUS_LOSS) {
-						sc->result = (DID_BUS_BUSY << 16);
+						VirtDevice *vdevice = sc->device->hostdata;
+
+						/* flag the device as being in device
+						removal delay so we can notify the midlayer
+						to hold off on timeout eh */
+						if (vdevice && vdevice->vtarget && 
+						    vdevice->vtarget->raidVolume)
+							printk(KERN_INFO "Skipping Raid Volume for inDMD\n" );
+						else if (vdevice && vdevice->vtarget)
+							vdevice->vtarget->inDMD = 1;
+
+						sc->result = (DID_TRANSPORT_DISRUPTED << 16);
 						break;
 					}
 				}
