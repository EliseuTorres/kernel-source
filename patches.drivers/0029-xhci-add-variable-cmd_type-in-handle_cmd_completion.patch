From 10dd14a52f5983534aaf2b503dc051f1e35601f4 Mon Sep 17 00:00:00 2001
From: Xenia Ragiadakou <burzalodowa@gmail.com>
Date: Mon, 9 Sep 2013 13:29:58 +0300
Subject: [PATCH 29/50] xhci: add variable 'cmd_type' in
 handle_cmd_completion()
Git-Commit: b54fc46dce0c45ce42a012f733ab2abf4b9be5fe
Patch-Mainline: v3.13
References: bnc#920620

This patch adds a new variable 'cmd_type' to hold the command type so that
switch cases can be simplified by removing TRB_TYPE() macro improving
code readability.

Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Signed-off-by: Oliver Neukum <oneukum@suse.de>
Conflicts:
	drivers/usb/host/xhci-ring.c
---
 drivers/usb/host/xhci-ring.c | 27 ++++++++++++++-------------
 1 file changed, 14 insertions(+), 13 deletions(-)

diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index cdce2c2..0b68f84 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -1440,6 +1440,7 @@ static void handle_cmd_completion(struct xhci_hcd *xhci,
 	unsigned int ep_state;
 	u32 cmd_comp_code;
 	union xhci_trb *cmd_trb;
+	u32 cmd_type;
 
 	cmd_dma = le64_to_cpu(event->cmd_trb);
 	cmd_trb = xhci->cmd_ring->dequeue;
@@ -1476,15 +1477,15 @@ static void handle_cmd_completion(struct xhci_hcd *xhci,
 			return;
 	}
 
-	switch (le32_to_cpu(cmd_trb->generic.field[3])
-		& TRB_TYPE_BITMASK) {
-	case TRB_TYPE(TRB_ENABLE_SLOT):
+	cmd_type = TRB_FIELD_TO_TYPE(le32_to_cpu(cmd_trb->generic.field[3]));
+	switch (cmd_type) {
+	case TRB_ENABLE_SLOT:
 		xhci_handle_cmd_enable_slot(xhci, slot_id, cmd_comp_code);
 		break;
-	case TRB_TYPE(TRB_DISABLE_SLOT):
+	case TRB_DISABLE_SLOT:
 		xhci_handle_cmd_disable_slot(xhci, slot_id);
 		break;
-	case TRB_TYPE(TRB_CONFIG_EP):
+	case TRB_CONFIG_EP:
 		virt_dev = xhci->devs[slot_id];
 		if (handle_cmd_in_cmd_wait_list(xhci, virt_dev, event))
 			break;
@@ -1532,29 +1533,29 @@ bandwidth_change:
 			cmd_comp_code;
 		complete(&xhci->devs[slot_id]->cmd_completion);
 		break;
-	case TRB_TYPE(TRB_EVAL_CONTEXT):
+	case TRB_EVAL_CONTEXT:
 		xhci_handle_cmd_eval_ctx(xhci, slot_id, event, cmd_comp_code);
 		break;
-	case TRB_TYPE(TRB_ADDR_DEV):
+	case TRB_ADDR_DEV:
 		xhci_handle_cmd_addr_dev(xhci, slot_id, cmd_comp_code);
 		break;
-	case TRB_TYPE(TRB_STOP_RING):
+	case TRB_STOP_RING:
 		handle_stopped_endpoint(xhci, cmd_trb, event);
 		break;
-	case TRB_TYPE(TRB_SET_DEQ):
+	case TRB_SET_DEQ:
 		handle_set_deq_completion(xhci, event, cmd_trb);
 		break;
-	case TRB_TYPE(TRB_CMD_NOOP):
+	case TRB_CMD_NOOP:
 		break;
-	case TRB_TYPE(TRB_RESET_EP):
+	case TRB_RESET_EP:
 		handle_reset_ep_completion(xhci, event, cmd_trb);
 		break;
-	case TRB_TYPE(TRB_RESET_DEV):
+	case TRB_RESET_DEV:
 		WARN_ON(slot_id != TRB_TO_SLOT_ID(
 				le32_to_cpu(cmd_trb->generic.field[3])));
 		xhci_handle_cmd_reset_dev(xhci, slot_id, event);
 		break;
-	case TRB_TYPE(TRB_NEC_GET_FW):
+	case TRB_NEC_GET_FW:
 		if (!(xhci->quirks & XHCI_NEC_HOST)) {
 			xhci->error_bitmask |= 1 << 6;
 			break;
-- 
1.8.4.5

