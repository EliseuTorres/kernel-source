From: David Woodhouse <David.Woodhouse@intel.com>
Date: Tue, 1 Apr 2014 14:58:36 +0100
Subject: iommu/vt-d: Fix error handling in ANDD processing
Git-commit: 7713ec066ae8adc49dd8daa02a73e6b60af6ee5f
Patch-mainline: v3.15-rc2
References: bnc#870687 bnc#879482 fate#317112

If we failed to find an ACPI device to correspond to an ANDD record, we
would fail to increment our pointer and would just process the same record
over and over again, with predictable results.

Turn it from a while() loop into a for() loop to let the 'continue' in
the error paths work correctly.

Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
Acked-by: Joerg Roedel <jroedel@suse.de>
---
 drivers/iommu/dmar.c | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c
index 142650e..f445c10 100644
--- a/drivers/iommu/dmar.c
+++ b/drivers/iommu/dmar.c
@@ -662,10 +662,9 @@ static int __init dmar_acpi_dev_scope_init(void)
 	if (dmar_tbl == NULL)
 		return -ENODEV;
 
-	andd = (void *)dmar_tbl + sizeof(struct acpi_table_dmar);
-
-	while (((unsigned long)andd) <
-	       ((unsigned long)dmar_tbl) + dmar_tbl->length) {
+	for (andd = (void *)dmar_tbl + sizeof(struct acpi_table_dmar);
+	     ((unsigned long)andd) < ((unsigned long)dmar_tbl) + dmar_tbl->length;
+	     andd = ((void *)andd) + andd->header.length) {
 		if (andd->header.type == ACPI_DMAR_TYPE_ANDD) {
 			acpi_handle h;
 			struct acpi_device *adev;
@@ -685,7 +684,6 @@ static int __init dmar_acpi_dev_scope_init(void)
 			}
 			dmar_acpi_insert_dev_scope(andd->device_number, adev);
 		}
-		andd = ((void *)andd) + andd->header.length;
 	}
 	return 0;
 }

