From 382225e62bdb8059b7f915b133426425516dd300 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Tue, 22 Feb 2011 10:21:18 +0100
Subject: [PATCH] ALSA: usb-audio: fix oops due to cleanup race when disconnecting
Git-commit: 382225e62bdb8059b7f915b133426425516dd300
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound-2.6.git
Patch-mainline: Submitted
References: bnc#674735

When a USB audio device is disconnected, snd_usb_audio_disconnect()
kills all audio URBs.  At the same time, the application, after being
notified of the disconnection, might close the device, in which case
ALSA calls the .hw_free callback, which should free the URBs too.

Commit de1b8b93a0ba "[ALSA] Fix hang-up at disconnection of usb-audio"
prevented snd_usb_hw_free() from freeing the URBs to avoid a hang that
resulted from this race, but this introduced another race because the
URB callbacks could now be executed after snd_usb_hw_free() has
returned, and try to access already freed data.

Fix the first race by introducing a mutex to serialize the disconnect
callback and all PCM callbacks that manage URBs (hw_free and hw_params).

[Rewritten for older SUSE kernels not to break kABI -- tiwai]

Reported-and-tested-by: Pierre-Louis Bossart <pierre-louis.bossart@intel.com>
Cc: <stable@kernel.org>
[cl: also serialize hw_params callback]
Signed-off-by: Clemens Ladisch <clemens@ladisch.de>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/usb/usbaudio.c |    4 ++++
 1 file changed, 4 insertions(+)

--- a/sound/usb/usbaudio.c
+++ b/sound/usb/usbaudio.c
@@ -1482,12 +1482,14 @@
 	}
 
 	if (changed) {
+		mutex_lock(&register_mutex);
 		/* format changed */
 		release_substream_urbs(subs, 0);
 		/* influenced: period_bytes, channels, rate, format, */
 		ret = init_substream_urbs(subs, params_period_bytes(hw_params),
 					  params_rate(hw_params),
 					  snd_pcm_format_physical_width(params_format(hw_params)) * params_channels(hw_params));
+		mutex_unlock(&register_mutex);
 	}
 
 	return ret;
@@ -1505,8 +1507,10 @@
 	subs->cur_audiofmt = NULL;
 	subs->cur_rate = 0;
 	subs->period_bytes = 0;
+	mutex_lock(&register_mutex);
 	if (!subs->stream->chip->shutdown)
 		release_substream_urbs(subs, 0);
+	mutex_unlock(&register_mutex);
 	return snd_pcm_free_vmalloc_buffer(substream);
 }
 
