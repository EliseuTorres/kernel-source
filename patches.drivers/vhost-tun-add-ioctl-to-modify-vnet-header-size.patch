From: Michael S. Tsirkin <mst@redhat.com>
Subject: [PATCH] tun: add ioctl to modify vnet header size
References: FATE#311977
Git-commit: d9d52b5178af586d679c1052fb161ee05ea2e83f
Patch-mainline: v2.6.34

virtio added mergeable buffers mode where 2 bytes of extra info is put
after vnet header but before actual data (tun does not need this data).
In hindsight, it would have been better to add the new info *before* the
packet: as it is, users need a lot of tricky code to skip the extra 2
bytes in the middle of the iovec, and in fact applications seem to get
it wrong, and only work with specific iovec layout.  The fact we might
need to split iovec also means we might in theory overflow iovec max
size.

This patch adds a simpler way for applications to handle this,
and future proofs the interface against further extensions,
by making the size of the virtio net header configurable
from userspace. As a result, tun driver will simply
skip the extra 2 bytes on both input and output.

Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
Acked-by: David S. Miller <davem@davemloft.net>
Acked-by: Bruce Rogers <brogers@suse.com>
---
 drivers/net/tun.c      |   30 ++++++++++++++++++++++++++----
 include/linux/if_tun.h |    3 +++
 2 files changed, 29 insertions(+), 4 deletions(-)

Index: b/drivers/net/tun.c
===================================================================
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -108,6 +108,7 @@ struct tun_struct {
 
 	struct tap_filter       txflt;
 	struct socket		socket;
+	int			vnet_hdr_sz;
 
 #ifdef TUN_DEBUG
 	int debug;
@@ -554,7 +555,7 @@ static __inline__ ssize_t tun_get_user(s
 	}
 
 	if (tun->flags & TUN_VNET_HDR) {
-		if ((len -= sizeof(gso)) > count)
+		if ((len -= tun->vnet_hdr_sz) > count)
 			return -EINVAL;
 
 		if (memcpy_fromiovecend((void *)&gso, iv, offset, sizeof(gso)))
@@ -566,7 +567,7 @@ static __inline__ ssize_t tun_get_user(s
 
 		if (gso.hdr_len > len)
 			return -EINVAL;
-		offset += sizeof(gso);
+		offset += tun->vnet_hdr_sz;
 	}
 
 	if ((tun->flags & TUN_TYPE_MASK) == TUN_TAP_DEV) {
@@ -709,7 +710,7 @@ static __inline__ ssize_t tun_put_user(s
 
 	if (tun->flags & TUN_VNET_HDR) {
 		struct virtio_net_hdr gso = { 0 }; /* no info leak */
-		if ((len -= sizeof(gso)) < 0)
+		if ((len -= tun->vnet_hdr_sz) < 0)
 			return -EINVAL;
 
 		if (skb_is_gso(skb)) {
@@ -740,7 +741,7 @@ static __inline__ ssize_t tun_put_user(s
 		if (unlikely(memcpy_toiovecend(iv, (void *)&gso, total,
 					       sizeof(gso))))
 			return -EFAULT;
-		total += sizeof(gso);
+		total += tun->vnet_hdr_sz;
 	}
 
 	len = min_t(int, skb->len, len);
@@ -1024,6 +1025,7 @@ static int tun_set_iff(struct net *net,
 		tun->dev = dev;
 		tun->flags = flags;
 		tun->txflt.count = 0;
+		tun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);
 
 		err = -ENOMEM;
 		sk = sk_alloc(net, AF_UNSPEC, GFP_KERNEL, &tun_proto);
@@ -1165,6 +1167,7 @@ static long tun_chr_ioctl(struct file *f
 	void __user* argp = (void __user*)arg;
 	struct ifreq ifr;
 	int sndbuf;
+	int vnet_hdr_sz;
 	int ret;
 
 	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)
@@ -1310,6 +1313,25 @@ static long tun_chr_ioctl(struct file *f
 		tun->socket.sk->sk_sndbuf = sndbuf;
 		break;
 
+	case TUNGETVNETHDRSZ:
+		vnet_hdr_sz = tun->vnet_hdr_sz;
+		if (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))
+			ret = -EFAULT;
+		break;
+
+	case TUNSETVNETHDRSZ:
+		if (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {
+			ret = -EFAULT;
+			break;
+		}
+		if (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {
+			ret = -EINVAL;
+			break;
+		}
+
+		tun->vnet_hdr_sz = vnet_hdr_sz;
+		break;
+
 	default:
 		ret = -EINVAL;
 		break;
Index: b/include/linux/if_tun.h
===================================================================
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -48,6 +48,9 @@
 #define TUNGETIFF      _IOR('T', 210, unsigned int)
 #define TUNGETSNDBUF   _IOR('T', 211, int)
 #define TUNSETSNDBUF   _IOW('T', 212, int)
+#define TUNGETVNETHDRSZ _IOR('T', 215, int)
+#define TUNSETVNETHDRSZ _IOW('T', 216, int)
+
 
 /* TUNSETIFF ifr flags */
 #define IFF_TUN		0x0001
