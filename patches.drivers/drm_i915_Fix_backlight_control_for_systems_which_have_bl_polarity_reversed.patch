From: Egbert Eich <eich@suse.de>
Subject: DRM/i915: Fix backlight control for systems which have bl polarity reversed.
References: bnc #766156
Patch-Mainline: NotYet
Git-commit: 801c5457301a4df598d898dcda46f2f56ec45778


Signed-off-by: Egbert Eich <eich@suse.de>

Backlight control is done by a pwm signal. The value of the backlight
control registers determine the duty cycle. Polarity can either be reversed
in software by programming (max_level - level) instead of level to
program the 'off-duty' period into the backlight control registers or
by setting the polarity bit appropriately.

Most systems seem to set the polarity bit - still there are some which
reverse polarity by programming the off-duty period.
We have thought about a method of detecting how the hardware is programmed
but this can only be done under the assumption that the backlight is
set to a specific value (for example full brightness) when the driver
initialized. This assumption however may not always be true. Thus we
add a per system backlight blacklist which flags those systems which
need to set the off-duty cycle.

Signed-off-by: Egbert Eich <eich@suse.de>

---
 drivers/gpu/drm/i915/i915_drv.h    |    1 +
 drivers/gpu/drm/i915/intel_panel.c |   25 +++++++++++++++++++++++++
 2 files changed, 26 insertions(+)

Index: b/drivers/gpu/drm/i915/i915_drv.h
===================================================================
--- a.orig/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -359,6 +359,7 @@ typedef struct drm_i915_private {
 	/* LVDS info */
 	int backlight_level;  /* restore backlight to this value */
 	bool backlight_enabled;
+	bool backlight_polarity_reversed;
 	struct drm_display_mode *lfp_lvds_vbt_mode; /* if any */
 	struct drm_display_mode *sdvo_lvds_vbt_mode; /* if any */
 
Index: b/drivers/gpu/drm/i915/intel_panel.c
===================================================================
--- a.orig/drivers/gpu/drm/i915/intel_panel.c
+++ b/drivers/gpu/drm/i915/intel_panel.c
@@ -28,6 +28,7 @@
  *      Chris Wilson <chris@chris-wilson.co.uk>
  */
 
+#include <linux/dmi.h>
 #include "intel_drv.h"
 
 #define PCI_LBPC 0xf4 /* legacy/combination backlight modes */
@@ -212,6 +213,8 @@ u32 intel_panel_get_backlight(struct drm
 	}
 
 	DRM_DEBUG_DRIVER("get backlight PWM = %d\n", val);
+	if (dev_priv->backlight_polarity_reversed)
+		val = intel_panel_get_max_backlight(dev) - val;
 	return val;
 }
 
@@ -229,6 +232,9 @@ static void intel_panel_actually_set_bac
 
 	DRM_DEBUG_DRIVER("set backlight PWM = %d\n", level);
 
+	if (dev_priv->backlight_polarity_reversed)
+		level = intel_panel_get_max_backlight(dev) - level;
+
 	if (HAS_PCH_SPLIT(dev))
 		return intel_pch_panel_set_backlight(dev, level);
 
@@ -276,12 +282,33 @@ void intel_panel_enable_backlight(struct
 	intel_panel_actually_set_backlight(dev, dev_priv->backlight_level);
 }
 
+static int intel_backlight_reversed_callback(const struct dmi_system_id *id)
+{
+	DRM_INFO("Backlight polarity reversed on %s\n", id->ident);
+	return 1;
+}
+
+static const struct dmi_system_id intel_backlight_reversed_list[] = {
+	{
+		.callback = intel_backlight_reversed_callback,
+		.ident = "",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "NCR Corporation"),
+			DMI_MATCH(DMI_PRODUCT_NAME, ""),
+		},
+	},
+
+	{ }     /* terminating entry */
+};
+
 static void intel_panel_init_backlight(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 
 	dev_priv->backlight_level = intel_panel_get_backlight(dev);
 	dev_priv->backlight_enabled = dev_priv->backlight_level != 0;
+	dev_priv->backlight_polarity_reversed =
+		(dmi_check_system(intel_backlight_reversed_list) != 0);
 }
 
 enum drm_connector_status
