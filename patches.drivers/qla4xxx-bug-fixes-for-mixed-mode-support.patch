From: Nilesh Javali <nilesh.javali@qlogic.com>
Date: Mon, 21 Nov 2011 10:26:08 +0100
Subject: qla4xxx: bug fixes for mixed mode support
References: bnc#731029
Patch-Mainline: Not yet

This patch has the following bug fixes for mixed mode support:

- Increment the next_idx when qla4xxx_get_fwddb_entry returns QLA_ERROR
- Correct ipaddress match check

Signed-off-by: Nilesh Javali <nilesh.javali@qlogic.com>
Acked-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/qla4xxx/ql4_def.h b/drivers/scsi/qla4xxx/ql4_def.h
index 961a265..e422bb0 100644
--- a/drivers/scsi/qla4xxx/ql4_def.h
+++ b/drivers/scsi/qla4xxx/ql4_def.h
@@ -224,12 +224,12 @@ struct srb {
  * Asynchronous Event Queue structure
  */
 struct aen {
-        uint32_t mbox_sts[MBOX_AEN_REG_COUNT];
+	uint32_t mbox_sts[MBOX_AEN_REG_COUNT];
 };
 
 struct ql4_aen_log {
-        int count;
-        struct aen entry[MAX_AEN_ENTRIES];
+	int count;
+	struct aen entry[MAX_AEN_ENTRIES];
 };
 
 /*
@@ -669,7 +669,7 @@ struct scsi_qla_host {
 	uint16_t pri_ddb_idx;
 	uint16_t sec_ddb_idx;
 	struct completion disable_acb_comp;
-	int	is_reset;
+	int is_reset;
 };
 
 struct ql4_task_data {
diff --git a/drivers/scsi/qla4xxx/ql4_init.c b/drivers/scsi/qla4xxx/ql4_init.c
index 657c18a..ef43ca0 100644
--- a/drivers/scsi/qla4xxx/ql4_init.c
+++ b/drivers/scsi/qla4xxx/ql4_init.c
@@ -572,8 +572,8 @@ static int qla4xxx_start_firmware_from_flash(struct scsi_qla_host *ha)
 		writel(set_rmask(NVR_WRITE_ENABLE),
 		       &ha->reg->u1.isp4022.nvram);
 
-        writel(2, &ha->reg->mailbox[6]);
-        readl(&ha->reg->mailbox[6]);
+	writel(2, &ha->reg->mailbox[6]);
+	readl(&ha->reg->mailbox[6]);
 
 	writel(set_rmask(CSR_BOOT_ENABLE), &ha->reg->ctrl_status);
 	readl(&ha->reg->ctrl_status);
@@ -787,8 +787,10 @@ void qla4xxx_free_ddb_index(struct scsi_qla_host *ha)
 		ret = qla4xxx_get_fwddb_entry(ha, idx, NULL, 0, NULL,
 					      &next_idx, &state, &conn_err,
 						NULL, NULL);
-		if (ret == QLA_ERROR)
+		if (ret == QLA_ERROR) {
+			next_idx++;
 			continue;
+		}
 		if (state == DDB_DS_NO_CONNECTION_ACTIVE ||
 		    state == DDB_DS_SESSION_FAILED) {
 			DEBUG2(ql4_printk(KERN_INFO, ha,
diff --git a/drivers/scsi/qla4xxx/ql4_isr.c b/drivers/scsi/qla4xxx/ql4_isr.c
index 827e930..04b1806 100644
--- a/drivers/scsi/qla4xxx/ql4_isr.c
+++ b/drivers/scsi/qla4xxx/ql4_isr.c
@@ -17,8 +17,8 @@
  * @srb: Pointer to srb structure.
  **/
 static void qla4xxx_copy_sense(struct scsi_qla_host *ha,
-                               struct status_entry *sts_entry,
-                               struct srb *srb)
+			       struct status_entry *sts_entry,
+			       struct srb *srb)
 {
 	struct scsi_cmnd *cmd = srb->cmd;
 	uint16_t sense_len;
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index bd4d1e4..bc6ca5f 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -8,6 +8,7 @@
 #include <linux/slab.h>
 #include <linux/blkdev.h>
 #include <linux/iscsi_boot_sysfs.h>
+#include <linux/inet.h>
 
 #include <scsi/scsi_tcq.h>
 #include <scsi/scsicam.h>
@@ -72,7 +71,7 @@ static int ql4xsess_recovery_tmo = QL4_SESS_RECOVERY_TMO;
 module_param(ql4xsess_recovery_tmo, int, S_IRUGO);
 MODULE_PARM_DESC(ql4xsess_recovery_tmo,
 		"Target Session Recovery Timeout.\n"
-		" Default: 30 sec.");
+		" Default: 120 sec.");
 
 static int qla4xxx_wait_for_hba_online(struct scsi_qla_host *ha);
 /*
@@ -801,7 +800,7 @@ static void qla4xxx_set_ipv4(struct scsi_qla_host *ha,
 			qla4xxx_destroy_ipv4_iface(ha);
 		}
 		break;
-	case ISCSI_NET_PARAM_VLAN_ID:
+	case ISCSI_NET_PARAM_VLAN_TAG:
 		if (iface_param->len != sizeof(init_fw_cb->ipv4_vlan_tag))
 			break;
 		init_fw_cb->ipv4_vlan_tag =
@@ -1023,10 +1022,44 @@ exit_get_ddb_index:
 	return ret;
 }
 
+static int qla4xxx_match_ipaddress(struct scsi_qla_host *ha,
+				   struct ddb_entry *ddb_entry,
+				   char *existing_ipaddr,
+				   char *user_ipaddr)
+{
+	uint8_t dst_ipaddr[IPv6_ADDR_LEN];
+	char formatted_ipaddr[DDB_IPADDR_LEN];
+	int status = QLA_SUCCESS, ret = 0;
+
+	if (ddb_entry->fw_ddb_entry.options & DDB_OPT_IPV6_DEVICE) {
+		ret = in6_pton(user_ipaddr, strlen(user_ipaddr), dst_ipaddr,
+			       '\0', NULL);
+		if (ret == 0) {
+			status = QLA_ERROR;
+			goto out_match;
+		}
+		ret = sprintf(formatted_ipaddr, "%pI6", dst_ipaddr);
+	} else {
+		ret = in4_pton(user_ipaddr, strlen(user_ipaddr), dst_ipaddr,
+			       '\0', NULL);
+		if (ret == 0) {
+			status = QLA_ERROR;
+			goto out_match;
+		}
+		ret = sprintf(formatted_ipaddr, "%pI4", dst_ipaddr);
+	}
+
+	if (strcmp(existing_ipaddr, formatted_ipaddr))
+		status = QLA_ERROR;
+
+out_match:
+	return status;
+}
+
 static int qla4xxx_match_fwdb_session(struct scsi_qla_host *ha,
 				      struct iscsi_cls_conn *cls_conn)
 {
-	int idx = 0, max_ddbs;
+	int idx = 0, max_ddbs, rval;
 	struct iscsi_cls_session *cls_sess = iscsi_conn_to_session(cls_conn);
 	struct iscsi_session *sess, *existing_sess;
 	struct iscsi_conn *conn, *existing_conn;
@@ -1076,8 +1109,11 @@ static int qla4xxx_match_fwdb_session(struct scsi_qla_host *ha,
 
 		if (strcmp(existing_sess->targetname, sess->targetname))
 			continue;
-		if (strcmp(existing_conn->persistent_address,
-			   conn->persistent_address))
+
+		rval = qla4xxx_match_ipaddress(ha, ddb_entry,
+					existing_conn->persistent_address,
+					conn->persistent_address);
+		if (rval == QLA_ERROR)
 			continue;
 		if (existing_conn->persistent_port != conn->persistent_port)
 			continue;
diff --git a/drivers/scsi/qla4xxx/ql4_version.h b/drivers/scsi/qla4xxx/ql4_version.h
index 80cf103..1ecdac4 100644
--- a/drivers/scsi/qla4xxx/ql4_version.h
+++ b/drivers/scsi/qla4xxx/ql4_version.h
@@ -5,4 +5,4 @@
  * See LICENSE.qla4xxx for copyright and licensing details.
  */
 
-#define QLA4XXX_DRIVER_VERSION	"5.02.00.00.11.2-k0"
+#define QLA4XXX_DRIVER_VERSION	"5.02.00.00.11.2-k1"
