From: Jayamohan Kallickal <jayamohan.kallickal@emulex.com>
Subject: [PATCH 4/5] be2iscsi: Fix processing CQE before connection resources
 are freed
Patch-mainline: v3.18-rc1
Git-commit: b7ab35b13379e709a2a1c3f1b3a59e5db62ce4e3
Reference: bnc#869278

 Driver should process the completion queue entries before a connection
 resources are freed. While running mixed traffic due to latency, driver
 processes the CQE after the connection resources are freed. This fix
 processes all the completion queue before the connection resources are
 freed.

Signed-off-by: John Soni Jose <sony.john-n@emulex.com>
Signed-off-by: Jayamohan Kallickal <jayamohan.kallickal@emulex.com>
Acked-by: Lee Duncan <lduncan@suse.com>
---
 drivers/scsi/be2iscsi/be_iscsi.c | 29 +++++++++++++++++++++++++++++
 drivers/scsi/be2iscsi/be_main.c  | 15 ++++++++++++++-
 drivers/scsi/be2iscsi/be_main.h  |  2 ++
 3 files changed, 45 insertions(+), 1 deletion(-)

diff -aurp linux-3.12-SLE12.orig/drivers/scsi/be2iscsi/be_iscsi.c linux-3.12-SLE12/drivers/scsi/be2iscsi/be_iscsi.c
--- a/drivers/scsi/be2iscsi/be_iscsi.c
+++ b/drivers/scsi/be2iscsi/be_iscsi.c
@@ -1266,6 +1266,31 @@ int beiscsi_ep_poll(struct iscsi_endpoin
 }
 
 /**
+ * beiscsi_flush_cq()- Flush the CQ created.
+ * @phba: ptr device priv structure.
+ *
+ * Before the connection resource are freed flush
+ * all the CQ enteries
+ **/
+static void beiscsi_flush_cq(struct beiscsi_hba *phba)
+{
+	uint16_t i;
+	struct be_eq_obj *pbe_eq;
+	struct hwi_controller *phwi_ctrlr;
+	struct hwi_context_memory *phwi_context;
+
+	phwi_ctrlr = phba->phwi_ctrlr;
+	phwi_context = phwi_ctrlr->phwi_ctxt;
+
+	for (i = 0; i < phba->num_cpus; i++) {
+		pbe_eq = &phwi_context->be_eq[i];
+		blk_iopoll_disable(&pbe_eq->iopoll);
+		beiscsi_process_cq(pbe_eq);
+		blk_iopoll_enable(&pbe_eq->iopoll);
+	}
+}
+
+/**
  * beiscsi_close_conn - Upload the  connection
  * @ep: The iscsi endpoint
  * @flag: The type of connection closure
@@ -1286,6 +1311,10 @@ static int beiscsi_close_conn(struct  be
 	}
 
 	ret = beiscsi_mccq_compl(phba, tag, NULL, NULL);
+
+	/* Flush the CQ entries */
+	beiscsi_flush_cq(phba);
+
 	return ret;
 }
 
diff -aurp linux-3.12-SLE12.orig/drivers/scsi/be2iscsi/be_main.c linux-3.12-SLE12/drivers/scsi/be2iscsi/be_main.c
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -2088,7 +2088,7 @@ static void  beiscsi_process_mcc_isr(str
  * return
  *     Number of Completion Entries processed.
  **/
-static unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq)
+unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq)
 {
 	struct be_queue_info *cq;
 	struct sol_cqe *sol;
@@ -2130,6 +2130,18 @@ static unsigned int beiscsi_process_cq(s
 
 		cri_index = BE_GET_CRI_FROM_CID(cid);
 		ep = phba->ep_array[cri_index];
+
+		if (ep == NULL) {
+			/* connection has already been freed
+			 * just move on to next one
+			 */
+			beiscsi_log(phba, KERN_WARNING,
+				    BEISCSI_LOG_INIT,
+				    "BM_%d : proc cqe of disconn ep: cid %d\n",
+				    cid);
+			goto proc_next_cqe;
+		}
+
 		beiscsi_ep = ep->dd_data;
 		beiscsi_conn = beiscsi_ep->conn;
 
@@ -2239,6 +2251,7 @@ static unsigned int beiscsi_process_cq(s
 			break;
 		}
 
+proc_next_cqe:
 		AMAP_SET_BITS(struct amap_sol_cqe, valid, sol, 0);
 		queue_tail_inc(cq);
 		sol = queue_tail_node(cq);
diff -aurp linux-3.12-SLE12.orig/drivers/scsi/be2iscsi/be_main.h linux-3.12-SLE12/drivers/scsi/be2iscsi/be_main.h
--- a/drivers/scsi/be2iscsi/be_main.h
+++ b/drivers/scsi/be2iscsi/be_main.h
@@ -822,6 +822,8 @@ void beiscsi_process_all_cqs(struct work
 void beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn,
 				     struct iscsi_task *task);
 
+unsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq);
+
 static inline bool beiscsi_error(struct beiscsi_hba *phba)
 {
 	return phba->ue_detected || phba->fw_timeout;
