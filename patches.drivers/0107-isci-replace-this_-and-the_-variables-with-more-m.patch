From: Dave Jiang <dave.jiang@intel.com>
Date: Thu, 21 Apr 2011 05:34:49 +0000
Subject: [PATCH 107/273] isci: replace this_* and the_* variables with more meaningful names
Git-commit: e2023b8735956bb78f167d0fdc575364e69b02c4
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Removed any instances of the_* and this_* to variable names that are more
meaningful and tell us what they actually are.

Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/core/sci_pool.h                  |   60 ++--
 drivers/scsi/isci/core/scic_sds_controller.c       |  395 ++++++++++----------
 drivers/scsi/isci/core/scic_sds_controller.h       |   18 +-
 drivers/scsi/isci/core/scic_sds_phy.c              |  396 ++++++++++----------
 drivers/scsi/isci/core/scic_sds_port.c             |  294 ++++++++--------
 drivers/scsi/isci/core/scic_sds_port.h             |   58 ++--
 drivers/scsi/isci/core/scic_sds_remote_device.c    |  186 +++++-----
 drivers/scsi/isci/core/scic_sds_remote_device.h    |  102 +++---
 .../scsi/isci/core/scic_sds_remote_node_context.c  |  374 +++++++++---------
 .../scsi/isci/core/scic_sds_remote_node_context.h  |   16 +-
 drivers/scsi/isci/core/scic_sds_request.c          |  196 +++++-----
 drivers/scsi/isci/core/scic_sds_request.h          |   40 +-
 .../scsi/isci/core/scic_sds_smp_remote_device.c    |   16 +-
 drivers/scsi/isci/core/scic_sds_smp_request.c      |  116 +++---
 drivers/scsi/isci/core/scic_sds_smp_request.h      |    3 +-
 drivers/scsi/isci/core/scic_sds_ssp_request.c      |   30 +-
 .../scsi/isci/core/scic_sds_stp_packet_request.c   |  194 +++++-----
 .../scsi/isci/core/scic_sds_stp_packet_request.h   |   10 +-
 .../scsi/isci/core/scic_sds_stp_remote_device.c    |   76 ++--
 drivers/scsi/isci/core/scic_sds_stp_request.c      |  370 +++++++++---------
 drivers/scsi/isci/core/scic_sds_stp_request.h      |    8 +-
 21 files changed, 1481 insertions(+), 1477 deletions(-)

diff --git a/drivers/scsi/isci/core/sci_pool.h b/drivers/scsi/isci/core/sci_pool.h
index c0d2ea3..016ec83 100644
--- a/drivers/scsi/isci/core/sci_pool.h
+++ b/drivers/scsi/isci/core/sci_pool.h
@@ -73,8 +73,8 @@
  *
  * Private operation for the pool
  */
-#define SCI_POOL_INCREMENT(this_pool, index) \
-	(((index) + 1) == (this_pool).size ? 0 : (index) + 1)
+#define SCI_POOL_INCREMENT(pool, index) \
+	(((index) + 1) == (pool).size ? 0 : (index) + 1)
 
 /**
  * SCI_POOL_CREATE() -
@@ -98,8 +98,8 @@
  * This macro evaluates the pool and returns true if the pool is empty. If the
  * pool is empty the user should not perform any get operation on the pool.
  */
-#define sci_pool_empty(this_pool) \
-	((this_pool).get == (this_pool).put)
+#define sci_pool_empty(pool) \
+	((pool).get == (pool).put)
 
 /**
  * sci_pool_full() -
@@ -107,8 +107,8 @@
  * This macro evaluates the pool and returns true if the pool is full.  If the
  * pool is full the user should not perform any put operation.
  */
-#define sci_pool_full(this_pool) \
-	(SCI_POOL_INCREMENT(this_pool, (this_pool).put) == (this_pool).get)
+#define sci_pool_full(pool) \
+	(SCI_POOL_INCREMENT(pool, (pool).put) == (pool).get)
 
 /**
  * sci_pool_size() -
@@ -118,25 +118,25 @@
  * pointers can be written simultaneously by different users.  As a result,
  * this macro subtracts 1 from the internal size
  */
-#define sci_pool_size(this_pool) \
-	((this_pool).size - 1)
+#define sci_pool_size(pool) \
+	((pool).size - 1)
 
 /**
  * sci_pool_count() -
  *
  * This macro indicates the number of elements currently contained in the pool.
  */
-#define sci_pool_count(this_pool) \
+#define sci_pool_count(pool) \
 	(\
-		sci_pool_empty((this_pool)) \
+		sci_pool_empty((pool)) \
 		? 0 \
 		: (\
-			sci_pool_full((this_pool)) \
-			? sci_pool_size((this_pool)) \
+			sci_pool_full((pool)) \
+			? sci_pool_size((pool)) \
 			: (\
-				(this_pool).get > (this_pool).put \
-				? ((this_pool).size - (this_pool).get + (this_pool).put) \
-				: ((this_pool).put - (this_pool).get) \
+				(pool).get > (pool).put \
+				? ((pool).size - (pool).get + (pool).put) \
+				: ((pool).put - (pool).get) \
 				) \
 			) \
 	)
@@ -146,11 +146,11 @@
  *
  * This macro initializes the pool to an empty condition.
  */
-#define sci_pool_initialize(this_pool) \
+#define sci_pool_initialize(pool) \
 	{ \
-		(this_pool).size = (sizeof((this_pool).array) / sizeof((this_pool).array[0])); \
-		(this_pool).get = 0; \
-		(this_pool).put = 0; \
+		(pool).size = (sizeof((pool).array) / sizeof((pool).array[0])); \
+		(pool).get = 0; \
+		(pool).put = 0; \
 	}
 
 /**
@@ -159,10 +159,10 @@
  * This macro will get the next free element from the pool. This should only be
  * called if the pool is not empty.
  */
-#define sci_pool_get(this_pool, my_value) \
+#define sci_pool_get(pool, my_value) \
 	{ \
-		(my_value) = (this_pool).array[(this_pool).get]; \
-		(this_pool).get = SCI_POOL_INCREMENT((this_pool), (this_pool).get); \
+		(my_value) = (pool).array[(pool).get]; \
+		(pool).get = SCI_POOL_INCREMENT((pool), (pool).get); \
 	}
 
 /**
@@ -171,10 +171,10 @@
  * This macro will put the value into the pool. This should only be called if
  * the pool is not full.
  */
-#define sci_pool_put(this_pool, the_value) \
+#define sci_pool_put(pool, value) \
 	{ \
-		(this_pool).array[(this_pool).put] = (the_value); \
-		(this_pool).put = SCI_POOL_INCREMENT((this_pool), (this_pool).put); \
+		(pool).array[(pool).put] = (value); \
+		(pool).put = SCI_POOL_INCREMENT((pool), (pool).put); \
 	}
 
 /**
@@ -183,16 +183,16 @@
  * This macro will search the pool and remove any elements in the pool matching
  * the supplied value. This method can only be utilized on pools
  */
-#define sci_pool_erase(this_pool, type, the_value) \
+#define sci_pool_erase(pool, type, value) \
 	{ \
 		type tmp_value;	\
 		u32 index; \
-		u32 element_count = sci_pool_count((this_pool)); \
+		u32 element_count = sci_pool_count((pool)); \
  \
 		for (index = 0; index < element_count; index++) {	\
-			sci_pool_get((this_pool), tmp_value); \
-			if (tmp_value != (the_value)) \
-				sci_pool_put((this_pool), tmp_value); \
+			sci_pool_get((pool), tmp_value); \
+			if (tmp_value != (value)) \
+				sci_pool_put((pool), tmp_value); \
 		} \
 	}
 
diff --git a/drivers/scsi/isci/core/scic_sds_controller.c b/drivers/scsi/isci/core/scic_sds_controller.c
index 9bb78a2..63f4cd1 100644
--- a/drivers/scsi/isci/core/scic_sds_controller.c
+++ b/drivers/scsi/isci/core/scic_sds_controller.c
@@ -290,7 +290,7 @@ int scic_controller_mem_init(struct scic_sds_controller *scic)
 
 /**
  * This method initializes the task context data for the controller.
- * @this_controller:
+ * @scic:
  *
  */
 static void
@@ -321,22 +321,22 @@ scic_sds_controller_assign_task_entries(struct scic_sds_controller *controller)
  *
  */
 static void scic_sds_controller_initialize_completion_queue(
-	struct scic_sds_controller *this_controller)
+	struct scic_sds_controller *scic)
 {
 	u32 index;
 	u32 completion_queue_control_value;
 	u32 completion_queue_get_value;
 	u32 completion_queue_put_value;
 
-	this_controller->completion_queue_get = 0;
+	scic->completion_queue_get = 0;
 
 	completion_queue_control_value = (
-		SMU_CQC_QUEUE_LIMIT_SET(this_controller->completion_queue_entries - 1)
-		| SMU_CQC_EVENT_LIMIT_SET(this_controller->completion_event_entries - 1)
+		SMU_CQC_QUEUE_LIMIT_SET(scic->completion_queue_entries - 1)
+		| SMU_CQC_EVENT_LIMIT_SET(scic->completion_event_entries - 1)
 		);
 
 	writel(completion_queue_control_value,
-		&this_controller->smu_registers->completion_queue_control);
+	       &scic->smu_registers->completion_queue_control);
 
 
 	/* Set the completion queue get pointer and enable the queue */
@@ -348,7 +348,7 @@ static void scic_sds_controller_initialize_completion_queue(
 		);
 
 	writel(completion_queue_get_value,
-		&this_controller->smu_registers->completion_queue_get);
+	       &scic->smu_registers->completion_queue_get);
 
 	/* Set the completion queue put pointer */
 	completion_queue_put_value = (
@@ -357,16 +357,15 @@ static void scic_sds_controller_initialize_completion_queue(
 		);
 
 	writel(completion_queue_put_value,
-		&this_controller->smu_registers->completion_queue_put);
-
+	       &scic->smu_registers->completion_queue_put);
 
 	/* Initialize the cycle bit of the completion queue entries */
-	for (index = 0; index < this_controller->completion_queue_entries; index++) {
+	for (index = 0; index < scic->completion_queue_entries; index++) {
 		/*
 		 * If get.cycle_bit != completion_queue.cycle_bit
 		 * its not a valid completion queue entry
 		 * so at system start all entries are invalid */
-		this_controller->completion_queue[index] = 0x80000000;
+		scic->completion_queue[index] = 0x80000000;
 	}
 }
 
@@ -376,7 +375,7 @@ static void scic_sds_controller_initialize_completion_queue(
  *
  */
 static void scic_sds_controller_initialize_unsolicited_frame_queue(
-	struct scic_sds_controller *this_controller)
+	struct scic_sds_controller *scic)
 {
 	u32 frame_queue_control_value;
 	u32 frame_queue_get_value;
@@ -384,10 +383,11 @@ static void scic_sds_controller_initialize_unsolicited_frame_queue(
 
 	/* Write the queue size */
 	frame_queue_control_value =
-		SCU_UFQC_GEN_VAL(QUEUE_SIZE, this_controller->uf_control.address_table.count);
+		SCU_UFQC_GEN_VAL(QUEUE_SIZE,
+				 scic->uf_control.address_table.count);
 
 	writel(frame_queue_control_value,
-		&this_controller->scu_registers->sdma.unsolicited_frame_queue_control);
+	       &scic->scu_registers->sdma.unsolicited_frame_queue_control);
 
 	/* Setup the get pointer for the unsolicited frame queue */
 	frame_queue_get_value = (
@@ -396,11 +396,11 @@ static void scic_sds_controller_initialize_unsolicited_frame_queue(
 		);
 
 	writel(frame_queue_get_value,
-		&this_controller->scu_registers->sdma.unsolicited_frame_get_pointer);
+	       &scic->scu_registers->sdma.unsolicited_frame_get_pointer);
 	/* Setup the put pointer for the unsolicited frame queue */
 	frame_queue_put_value = SCU_UFQPP_GEN_VAL(POINTER, 0);
 	writel(frame_queue_put_value,
-		&this_controller->scu_registers->sdma.unsolicited_frame_put_pointer);
+	       &scic->scu_registers->sdma.unsolicited_frame_put_pointer);
 }
 
 /**
@@ -409,16 +409,17 @@ static void scic_sds_controller_initialize_unsolicited_frame_queue(
  *
  */
 static void scic_sds_controller_enable_port_task_scheduler(
-	struct scic_sds_controller *this_controller)
+	struct scic_sds_controller *scic)
 {
 	u32 port_task_scheduler_value;
 
 	port_task_scheduler_value =
-		readl(&this_controller->scu_registers->peg0.ptsg.control);
+		readl(&scic->scu_registers->peg0.ptsg.control);
 	port_task_scheduler_value |=
-		(SCU_PTSGCR_GEN_BIT(ETM_ENABLE) | SCU_PTSGCR_GEN_BIT(PTSG_ENABLE));
+		(SCU_PTSGCR_GEN_BIT(ETM_ENABLE) |
+		 SCU_PTSGCR_GEN_BIT(PTSG_ENABLE));
 	writel(port_task_scheduler_value,
-		&this_controller->scu_registers->peg0.ptsg.control);
+	       &scic->scu_registers->peg0.ptsg.control);
 }
 
 /**
@@ -564,7 +565,7 @@ static void scic_sds_controller_afe_initialization(struct scic_sds_controller *s
  * This method will attempt to transition into the ready state for the
  *    controller and indicate that the controller start operation has completed
  *    if all criteria are met.
- * @this_controller: This parameter indicates the controller object for which
+ * @scic: This parameter indicates the controller object for which
  *    to transition to ready.
  * @status: This parameter indicates the status value to be pass into the call
  *    to scic_cb_controller_start_complete().
@@ -858,30 +859,30 @@ static void scic_sds_controller_power_control_timer_restart(struct scic_sds_cont
 static void scic_sds_controller_power_control_timer_handler(
 	void *controller)
 {
-	struct scic_sds_controller *this_controller;
+	struct scic_sds_controller *scic;
 
-	this_controller = (struct scic_sds_controller *)controller;
+	scic = (struct scic_sds_controller *)controller;
 
-	this_controller->power_control.phys_granted_power = 0;
+	scic->power_control.phys_granted_power = 0;
 
-	if (this_controller->power_control.phys_waiting == 0) {
-		this_controller->power_control.timer_started = false;
+	if (scic->power_control.phys_waiting == 0) {
+		scic->power_control.timer_started = false;
 	} else {
-		struct scic_sds_phy *the_phy = NULL;
+		struct scic_sds_phy *sci_phy = NULL;
 		u8 i;
 
 		for (i = 0;
 		     (i < SCI_MAX_PHYS)
-		     && (this_controller->power_control.phys_waiting != 0);
+		     && (scic->power_control.phys_waiting != 0);
 		     i++) {
-			if (this_controller->power_control.requesters[i] != NULL) {
-				if (this_controller->power_control.phys_granted_power <
-				    this_controller->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
-					the_phy = this_controller->power_control.requesters[i];
-					this_controller->power_control.requesters[i] = NULL;
-					this_controller->power_control.phys_waiting--;
-					this_controller->power_control.phys_granted_power++;
-					scic_sds_phy_consume_power_handler(the_phy);
+			if (scic->power_control.requesters[i] != NULL) {
+				if (scic->power_control.phys_granted_power <
+				    scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
+					sci_phy = scic->power_control.requesters[i];
+					scic->power_control.requesters[i] = NULL;
+					scic->power_control.phys_waiting--;
+					scic->power_control.phys_granted_power++;
+					scic_sds_phy_consume_power_handler(sci_phy);
 				} else {
 					break;
 				}
@@ -892,56 +893,56 @@ static void scic_sds_controller_power_control_timer_handler(
 		 * It doesn't matter if the power list is empty, we need to start the
 		 * timer in case another phy becomes ready.
 		 */
-		scic_sds_controller_power_control_timer_start(this_controller);
+		scic_sds_controller_power_control_timer_start(scic);
 	}
 }
 
 /**
  * This method inserts the phy in the stagger spinup control queue.
- * @this_controller:
+ * @scic:
  *
  *
  */
 void scic_sds_controller_power_control_queue_insert(
-	struct scic_sds_controller *this_controller,
-	struct scic_sds_phy *the_phy)
+	struct scic_sds_controller *scic,
+	struct scic_sds_phy *sci_phy)
 {
-	BUG_ON(the_phy == NULL);
+	BUG_ON(sci_phy == NULL);
 
-	if (this_controller->power_control.phys_granted_power <
-	    this_controller->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
-		this_controller->power_control.phys_granted_power++;
-		scic_sds_phy_consume_power_handler(the_phy);
+	if (scic->power_control.phys_granted_power <
+	    scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
+		scic->power_control.phys_granted_power++;
+		scic_sds_phy_consume_power_handler(sci_phy);
 
 		/*
 		 * stop and start the power_control timer. When the timer fires, the
 		 * no_of_phys_granted_power will be set to 0
 		 */
-		scic_sds_controller_power_control_timer_restart(this_controller);
+		scic_sds_controller_power_control_timer_restart(scic);
 	} else {
 		/* Add the phy in the waiting list */
-		this_controller->power_control.requesters[the_phy->phy_index] = the_phy;
-		this_controller->power_control.phys_waiting++;
+		scic->power_control.requesters[sci_phy->phy_index] = sci_phy;
+		scic->power_control.phys_waiting++;
 	}
 }
 
 /**
  * This method removes the phy from the stagger spinup control queue.
- * @this_controller:
+ * @scic:
  *
  *
  */
 void scic_sds_controller_power_control_queue_remove(
-	struct scic_sds_controller *this_controller,
-	struct scic_sds_phy *the_phy)
+	struct scic_sds_controller *scic,
+	struct scic_sds_phy *sci_phy)
 {
-	BUG_ON(the_phy == NULL);
+	BUG_ON(sci_phy == NULL);
 
-	if (this_controller->power_control.requesters[the_phy->phy_index] != NULL) {
-		this_controller->power_control.phys_waiting--;
+	if (scic->power_control.requesters[sci_phy->phy_index] != NULL) {
+		scic->power_control.phys_waiting--;
 	}
 
-	this_controller->power_control.requesters[the_phy->phy_index] = NULL;
+	scic->power_control.requesters[sci_phy->phy_index] = NULL;
 }
 
 /*
@@ -952,23 +953,20 @@ void scic_sds_controller_power_control_queue_remove(
 /**
  * This method returns a true value if the completion queue has entries that
  *    can be processed
- * @this_controller:
+ * @scic:
  *
  * bool true if the completion queue has entries to process false if the
  * completion queue has no entries to process
  */
 static bool scic_sds_controller_completion_queue_has_entries(
-	struct scic_sds_controller *this_controller)
+	struct scic_sds_controller *scic)
 {
-	u32 get_value = this_controller->completion_queue_get;
+	u32 get_value = scic->completion_queue_get;
 	u32 get_index = get_value & SMU_COMPLETION_QUEUE_GET_POINTER_MASK;
 
-	if (
-		NORMALIZE_GET_POINTER_CYCLE_BIT(get_value)
-		== COMPLETION_QUEUE_CYCLE_BIT(this_controller->completion_queue[get_index])
-		) {
+	if (NORMALIZE_GET_POINTER_CYCLE_BIT(get_value) ==
+	    COMPLETION_QUEUE_CYCLE_BIT(scic->completion_queue[get_index]))
 		return true;
-	}
 
 	return false;
 }
@@ -976,19 +974,19 @@ static bool scic_sds_controller_completion_queue_has_entries(
 /**
  * This method processes a task completion notification.  This is called from
  *    within the controller completion handler.
- * @this_controller:
+ * @scic:
  * @completion_entry:
  *
  */
 static void scic_sds_controller_task_completion(
-	struct scic_sds_controller *this_controller,
+	struct scic_sds_controller *scic,
 	u32 completion_entry)
 {
 	u32 index;
 	struct scic_sds_request *io_request;
 
 	index = SCU_GET_COMPLETION_INDEX(completion_entry);
-	io_request = this_controller->io_request_table[index];
+	io_request = scic->io_request_table[index];
 
 	/* Make sure that we really want to process this IO request */
 	if (
@@ -996,7 +994,7 @@ static void scic_sds_controller_task_completion(
 		&& (io_request->io_tag != SCI_CONTROLLER_INVALID_IO_TAG)
 		&& (
 			scic_sds_io_tag_get_sequence(io_request->io_tag)
-			== this_controller->io_request_sequence[index]
+			== scic->io_request_sequence[index]
 			)
 		) {
 		/* Yep this is a valid io request pass it along to the io request handler */
@@ -1007,12 +1005,12 @@ static void scic_sds_controller_task_completion(
 /**
  * This method processes an SDMA completion event.  This is called from within
  *    the controller completion handler.
- * @this_controller:
+ * @scic:
  * @completion_entry:
  *
  */
 static void scic_sds_controller_sdma_completion(
-	struct scic_sds_controller *this_controller,
+	struct scic_sds_controller *scic,
 	u32 completion_entry)
 {
 	u32 index;
@@ -1024,8 +1022,8 @@ static void scic_sds_controller_sdma_completion(
 	switch (scu_get_command_request_type(completion_entry)) {
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC:
-		io_request = this_controller->io_request_table[index];
-		dev_warn(scic_to_dev(this_controller),
+		io_request = scic->io_request_table[index];
+		dev_warn(scic_to_dev(scic),
 			 "%s: SCIC SDS Completion type SDMA %x for io request "
 			 "%p\n",
 			 __func__,
@@ -1039,8 +1037,8 @@ static void scic_sds_controller_sdma_completion(
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC:
-		device = this_controller->device_table[index];
-		dev_warn(scic_to_dev(this_controller),
+		device = scic->device_table[index];
+		dev_warn(scic_to_dev(scic),
 			 "%s: SCIC SDS Completion type SDMA %x for remote "
 			 "device %p\n",
 			 __func__,
@@ -1052,7 +1050,7 @@ static void scic_sds_controller_sdma_completion(
 		break;
 
 	default:
-		dev_warn(scic_to_dev(this_controller),
+		dev_warn(scic_to_dev(scic),
 			 "%s: SCIC SDS Completion unknown SDMA completion "
 			 "type %x\n",
 			 __func__,
@@ -1064,14 +1062,14 @@ static void scic_sds_controller_sdma_completion(
 
 /**
  *
- * @this_controller:
+ * @scic:
  * @completion_entry:
  *
  * This method processes an unsolicited frame message.  This is called from
  * within the controller completion handler. none
  */
 static void scic_sds_controller_unsolicited_frame(
-	struct scic_sds_controller *this_controller,
+	struct scic_sds_controller *scic,
 	u32 completion_entry)
 {
 	u32 index;
@@ -1086,8 +1084,8 @@ static void scic_sds_controller_unsolicited_frame(
 	frame_index = SCU_GET_FRAME_INDEX(completion_entry);
 
 	frame_header
-		= this_controller->uf_control.buffers.array[frame_index].header;
-	this_controller->uf_control.buffers.array[frame_index].state
+		= scic->uf_control.buffers.array[frame_index].header;
+	scic->uf_control.buffers.array[frame_index].state
 		= UNSOLICITED_FRAME_IN_USE;
 
 	if (SCU_GET_FRAME_ERROR(completion_entry)) {
@@ -1095,13 +1093,13 @@ static void scic_sds_controller_unsolicited_frame(
 		 * / @todo If the IAF frame or SIGNATURE FIS frame has an error will
 		 * /       this cause a problem? We expect the phy initialization will
 		 * /       fail if there is an error in the frame. */
-		scic_sds_controller_release_frame(this_controller, frame_index);
+		scic_sds_controller_release_frame(scic, frame_index);
 		return;
 	}
 
 	if (frame_header->is_address_frame) {
 		index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
-		phy = &this_controller->phy_table[index];
+		phy = &scic->phy_table[index];
 		if (phy != NULL) {
 			result = scic_sds_phy_frame_handler(phy, frame_index);
 		}
@@ -1115,18 +1113,18 @@ static void scic_sds_controller_unsolicited_frame(
 			 * device that has not yet been created.  In either case forwared
 			 * the frame to the PE and let it take care of the frame data. */
 			index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
-			phy = &this_controller->phy_table[index];
+			phy = &scic->phy_table[index];
 			result = scic_sds_phy_frame_handler(phy, frame_index);
 		} else {
-			if (index < this_controller->remote_node_entries)
-				device = this_controller->device_table[index];
+			if (index < scic->remote_node_entries)
+				device = scic->device_table[index];
 			else
 				device = NULL;
 
 			if (device != NULL)
 				result = scic_sds_remote_device_frame_handler(device, frame_index);
 			else
-				scic_sds_controller_release_frame(this_controller, frame_index);
+				scic_sds_controller_release_frame(scic, frame_index);
 		}
 	}
 
@@ -1140,12 +1138,12 @@ static void scic_sds_controller_unsolicited_frame(
 /**
  * This method processes an event completion entry.  This is called from within
  *    the controller completion handler.
- * @this_controller:
+ * @scic:
  * @completion_entry:
  *
  */
 static void scic_sds_controller_event_completion(
-	struct scic_sds_controller *this_controller,
+	struct scic_sds_controller *scic,
 	u32 completion_entry)
 {
 	u32 index;
@@ -1158,11 +1156,11 @@ static void scic_sds_controller_event_completion(
 	switch (scu_get_event_type(completion_entry)) {
 	case SCU_EVENT_TYPE_SMU_COMMAND_ERROR:
 		/* / @todo The driver did something wrong and we need to fix the condtion. */
-		dev_err(scic_to_dev(this_controller),
+		dev_err(scic_to_dev(scic),
 			"%s: SCIC Controller 0x%p received SMU command error "
 			"0x%x\n",
 			__func__,
-			this_controller,
+			scic,
 			completion_entry);
 		break;
 
@@ -1172,16 +1170,16 @@ static void scic_sds_controller_event_completion(
 		/*
 		 * / @todo This is a hardware failure and its likely that we want to
 		 * /       reset the controller. */
-		dev_err(scic_to_dev(this_controller),
+		dev_err(scic_to_dev(scic),
 			"%s: SCIC Controller 0x%p received fatal controller "
 			"event  0x%x\n",
 			__func__,
-			this_controller,
+			scic,
 			completion_entry);
 		break;
 
 	case SCU_EVENT_TYPE_TRANSPORT_ERROR:
-		io_request = this_controller->io_request_table[index];
+		io_request = scic->io_request_table[index];
 		scic_sds_io_request_event_handler(io_request, completion_entry);
 		break;
 
@@ -1189,31 +1187,31 @@ static void scic_sds_controller_event_completion(
 		switch (scu_get_event_specifier(completion_entry)) {
 		case SCU_EVENT_SPECIFIC_SMP_RESPONSE_NO_PE:
 		case SCU_EVENT_SPECIFIC_TASK_TIMEOUT:
-			io_request = this_controller->io_request_table[index];
+			io_request = scic->io_request_table[index];
 			if (io_request != NULL)
 				scic_sds_io_request_event_handler(io_request, completion_entry);
 			else
-				dev_warn(scic_to_dev(this_controller),
+				dev_warn(scic_to_dev(scic),
 					 "%s: SCIC Controller 0x%p received "
 					 "event 0x%x for io request object "
 					 "that doesnt exist.\n",
 					 __func__,
-					 this_controller,
+					 scic,
 					 completion_entry);
 
 			break;
 
 		case SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT:
-			device = this_controller->device_table[index];
+			device = scic->device_table[index];
 			if (device != NULL)
 				scic_sds_remote_device_event_handler(device, completion_entry);
 			else
-				dev_warn(scic_to_dev(this_controller),
+				dev_warn(scic_to_dev(scic),
 					 "%s: SCIC Controller 0x%p received "
 					 "event 0x%x for remote device object "
 					 "that doesnt exist.\n",
 					 __func__,
-					 this_controller,
+					 scic,
 					 completion_entry);
 
 			break;
@@ -1230,32 +1228,32 @@ static void scic_sds_controller_event_completion(
 	 * we get the event notification.  This is a type 4 event. */
 	case SCU_EVENT_TYPE_OSSP_EVENT:
 		index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
-		phy = &this_controller->phy_table[index];
+		phy = &scic->phy_table[index];
 		scic_sds_phy_event_handler(phy, completion_entry);
 		break;
 
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
 	case SCU_EVENT_TYPE_RNC_OPS_MISC:
-		if (index < this_controller->remote_node_entries) {
-			device = this_controller->device_table[index];
+		if (index < scic->remote_node_entries) {
+			device = scic->device_table[index];
 
 			if (device != NULL)
 				scic_sds_remote_device_event_handler(device, completion_entry);
 		} else
-			dev_err(scic_to_dev(this_controller),
+			dev_err(scic_to_dev(scic),
 				"%s: SCIC Controller 0x%p received event 0x%x "
 				"for remote device object 0x%0x that doesnt "
 				"exist.\n",
 				__func__,
-				this_controller,
+				scic,
 				completion_entry,
 				index);
 
 		break;
 
 	default:
-		dev_warn(scic_to_dev(this_controller),
+		dev_warn(scic_to_dev(scic),
 			 "%s: SCIC Controller received unknown event code %x\n",
 			 __func__,
 			 completion_entry);
@@ -1265,11 +1263,11 @@ static void scic_sds_controller_event_completion(
 
 /**
  * This method is a private routine for processing the completion queue entries.
- * @this_controller:
+ * @scic:
  *
  */
 static void scic_sds_controller_process_completions(
-	struct scic_sds_controller *this_controller)
+	struct scic_sds_controller *scic)
 {
 	u32 completion_count = 0;
 	u32 completion_entry;
@@ -1278,60 +1276,60 @@ static void scic_sds_controller_process_completions(
 	u32 event_index;
 	u32 event_cycle;
 
-	dev_dbg(scic_to_dev(this_controller),
+	dev_dbg(scic_to_dev(scic),
 		"%s: completion queue begining get:0x%08x\n",
 		__func__,
-		this_controller->completion_queue_get);
+		scic->completion_queue_get);
 
 	/* Get the component parts of the completion queue */
-	get_index = NORMALIZE_GET_POINTER(this_controller->completion_queue_get);
-	get_cycle = SMU_CQGR_CYCLE_BIT & this_controller->completion_queue_get;
+	get_index = NORMALIZE_GET_POINTER(scic->completion_queue_get);
+	get_cycle = SMU_CQGR_CYCLE_BIT & scic->completion_queue_get;
 
-	event_index = NORMALIZE_EVENT_POINTER(this_controller->completion_queue_get);
-	event_cycle = SMU_CQGR_EVENT_CYCLE_BIT & this_controller->completion_queue_get;
+	event_index = NORMALIZE_EVENT_POINTER(scic->completion_queue_get);
+	event_cycle = SMU_CQGR_EVENT_CYCLE_BIT & scic->completion_queue_get;
 
 	while (
 		NORMALIZE_GET_POINTER_CYCLE_BIT(get_cycle)
-		== COMPLETION_QUEUE_CYCLE_BIT(this_controller->completion_queue[get_index])
+		== COMPLETION_QUEUE_CYCLE_BIT(scic->completion_queue[get_index])
 		) {
 		completion_count++;
 
-		completion_entry = this_controller->completion_queue[get_index];
-		INCREMENT_COMPLETION_QUEUE_GET(this_controller, get_index, get_cycle);
+		completion_entry = scic->completion_queue[get_index];
+		INCREMENT_COMPLETION_QUEUE_GET(scic, get_index, get_cycle);
 
-		dev_dbg(scic_to_dev(this_controller),
+		dev_dbg(scic_to_dev(scic),
 			"%s: completion queue entry:0x%08x\n",
 			__func__,
 			completion_entry);
 
 		switch (SCU_GET_COMPLETION_TYPE(completion_entry)) {
 		case SCU_COMPLETION_TYPE_TASK:
-			scic_sds_controller_task_completion(this_controller, completion_entry);
+			scic_sds_controller_task_completion(scic, completion_entry);
 			break;
 
 		case SCU_COMPLETION_TYPE_SDMA:
-			scic_sds_controller_sdma_completion(this_controller, completion_entry);
+			scic_sds_controller_sdma_completion(scic, completion_entry);
 			break;
 
 		case SCU_COMPLETION_TYPE_UFI:
-			scic_sds_controller_unsolicited_frame(this_controller, completion_entry);
+			scic_sds_controller_unsolicited_frame(scic, completion_entry);
 			break;
 
 		case SCU_COMPLETION_TYPE_EVENT:
-			INCREMENT_EVENT_QUEUE_GET(this_controller, event_index, event_cycle);
-			scic_sds_controller_event_completion(this_controller, completion_entry);
+			INCREMENT_EVENT_QUEUE_GET(scic, event_index, event_cycle);
+			scic_sds_controller_event_completion(scic, completion_entry);
 			break;
 
 		case SCU_COMPLETION_TYPE_NOTIFY:
 			/*
 			 * Presently we do the same thing with a notify event that we do with the
 			 * other event codes. */
-			INCREMENT_EVENT_QUEUE_GET(this_controller, event_index, event_cycle);
-			scic_sds_controller_event_completion(this_controller, completion_entry);
+			INCREMENT_EVENT_QUEUE_GET(scic, event_index, event_cycle);
+			scic_sds_controller_event_completion(scic, completion_entry);
 			break;
 
 		default:
-			dev_warn(scic_to_dev(this_controller),
+			dev_warn(scic_to_dev(scic),
 				 "%s: SCIC Controller received unknown "
 				 "completion type %x\n",
 				 __func__,
@@ -1342,21 +1340,23 @@ static void scic_sds_controller_process_completions(
 
 	/* Update the get register if we completed one or more entries */
 	if (completion_count > 0) {
-		this_controller->completion_queue_get =
-			SMU_CQGR_GEN_BIT(ENABLE)
-			| SMU_CQGR_GEN_BIT(EVENT_ENABLE)
-			| event_cycle | SMU_CQGR_GEN_VAL(EVENT_POINTER, event_index)
-			| get_cycle   | SMU_CQGR_GEN_VAL(POINTER, get_index);
+		scic->completion_queue_get =
+			SMU_CQGR_GEN_BIT(ENABLE) |
+			SMU_CQGR_GEN_BIT(EVENT_ENABLE) |
+			event_cycle |
+			SMU_CQGR_GEN_VAL(EVENT_POINTER, event_index) |
+			get_cycle |
+			SMU_CQGR_GEN_VAL(POINTER, get_index);
 
-		writel(this_controller->completion_queue_get,
-			&this_controller->smu_registers->completion_queue_get);
+		writel(scic->completion_queue_get,
+		       &scic->smu_registers->completion_queue_get);
 
 	}
 
-	dev_dbg(scic_to_dev(this_controller),
+	dev_dbg(scic_to_dev(scic),
 		"%s: completion queue ending get:0x%08x\n",
 		__func__,
-		this_controller->completion_queue_get);
+		scic->completion_queue_get);
 
 }
 
@@ -1540,29 +1540,29 @@ void scic_sds_controller_remote_device_stopped(struct scic_sds_controller *scic,
 /**
  * This method will write to the SCU PCP register the request value. The method
  *    is used to suspend/resume ports, devices, and phys.
- * @this_controller:
+ * @scic:
  *
  *
  */
 void scic_sds_controller_post_request(
-	struct scic_sds_controller *this_controller,
+	struct scic_sds_controller *scic,
 	u32 request)
 {
-	dev_dbg(scic_to_dev(this_controller),
+	dev_dbg(scic_to_dev(scic),
 		"%s: SCIC Controller 0x%p post request 0x%08x\n",
 		__func__,
-		this_controller,
+		scic,
 		request);
 
-	writel(request, &this_controller->smu_registers->post_context_port);
+	writel(request, &scic->smu_registers->post_context_port);
 }
 
 /**
  * This method will copy the soft copy of the task context into the physical
  *    memory accessible by the controller.
- * @this_controller: This parameter specifies the controller for which to copy
+ * @scic: This parameter specifies the controller for which to copy
  *    the task context.
- * @this_request: This parameter specifies the request for which the task
+ * @sci_req: This parameter specifies the request for which the task
  *    context is being copied.
  *
  * After this call is made the SCIC_SDS_IO_REQUEST object will always point to
@@ -1571,43 +1571,40 @@ void scic_sds_controller_post_request(
  * memory). none
  */
 void scic_sds_controller_copy_task_context(
-	struct scic_sds_controller *this_controller,
-	struct scic_sds_request *this_request)
+	struct scic_sds_controller *scic,
+	struct scic_sds_request *sci_req)
 {
 	struct scu_task_context *task_context_buffer;
 
 	task_context_buffer = scic_sds_controller_get_task_context_buffer(
-		this_controller, this_request->io_tag
-		);
+		scic, sci_req->io_tag);
 
-	memcpy(
-		task_context_buffer,
-		this_request->task_context_buffer,
-		SCI_FIELD_OFFSET(struct scu_task_context, sgl_snapshot_ac)
-		);
+	memcpy(task_context_buffer,
+	       sci_req->task_context_buffer,
+	       SCI_FIELD_OFFSET(struct scu_task_context, sgl_snapshot_ac));
 
 	/*
 	 * Now that the soft copy of the TC has been copied into the TC
 	 * table accessible by the silicon.  Thus, any further changes to
 	 * the TC (e.g. TC termination) occur in the appropriate location. */
-	this_request->task_context_buffer = task_context_buffer;
+	sci_req->task_context_buffer = task_context_buffer;
 }
 
 /**
  * This method returns the task context buffer for the given io tag.
- * @this_controller:
+ * @scic:
  * @io_tag:
  *
  * struct scu_task_context*
  */
 struct scu_task_context *scic_sds_controller_get_task_context_buffer(
-	struct scic_sds_controller *this_controller,
+	struct scic_sds_controller *scic,
 	u16 io_tag
 	) {
 	u16 task_index = scic_sds_io_tag_get_index(io_tag);
 
-	if (task_index < this_controller->task_context_entries) {
-		return &this_controller->task_context_table[task_index];
+	if (task_index < scic->task_context_entries) {
+		return &scic->task_context_table[task_index];
 	}
 
 	return NULL;
@@ -1615,7 +1612,7 @@ struct scu_task_context *scic_sds_controller_get_task_context_buffer(
 
 /**
  * This method returnst the sequence value from the io tag value
- * @this_controller:
+ * @scic:
  * @io_tag:
  *
  * u16
@@ -1623,13 +1620,13 @@ struct scu_task_context *scic_sds_controller_get_task_context_buffer(
 
 /**
  * This method returns the IO request associated with the tag value
- * @this_controller:
+ * @scic:
  * @io_tag:
  *
  * SCIC_SDS_IO_REQUEST_T* NULL if there is no valid IO request at the tag value
  */
 struct scic_sds_request *scic_sds_controller_get_io_request_from_tag(
-	struct scic_sds_controller *this_controller,
+	struct scic_sds_controller *scic,
 	u16 io_tag
 	) {
 	u16 task_index;
@@ -1637,12 +1634,12 @@ struct scic_sds_request *scic_sds_controller_get_io_request_from_tag(
 
 	task_index = scic_sds_io_tag_get_index(io_tag);
 
-	if (task_index  < this_controller->task_context_entries) {
-		if (this_controller->io_request_table[task_index] != NULL) {
+	if (task_index  < scic->task_context_entries) {
+		if (scic->io_request_table[task_index] != NULL) {
 			task_sequence = scic_sds_io_tag_get_sequence(io_tag);
 
-			if (task_sequence == this_controller->io_request_sequence[task_index]) {
-				return this_controller->io_request_table[task_index];
+			if (task_sequence == scic->io_request_sequence[task_index]) {
+				return scic->io_request_table[task_index];
 			}
 		}
 	}
@@ -1654,9 +1651,9 @@ struct scic_sds_request *scic_sds_controller_get_io_request_from_tag(
  * This method allocates remote node index and the reserves the remote node
  *    context space for use. This method can fail if there are no more remote
  *    node index available.
- * @this_controller: This is the controller object which contains the set of
+ * @scic: This is the controller object which contains the set of
  *    free remote node ids
- * @the_devce: This is the device object which is requesting the a remote node
+ * @sci_dev: This is the device object which is requesting the a remote node
  *    id
  * @node_id: This is the remote node id that is assinged to the device if one
  *    is available
@@ -1665,19 +1662,19 @@ struct scic_sds_request *scic_sds_controller_get_io_request_from_tag(
  * node index available.
  */
 enum sci_status scic_sds_controller_allocate_remote_node_context(
-	struct scic_sds_controller *this_controller,
-	struct scic_sds_remote_device *the_device,
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *sci_dev,
 	u16 *node_id)
 {
 	u16 node_index;
-	u32 remote_node_count = scic_sds_remote_device_node_count(the_device);
+	u32 remote_node_count = scic_sds_remote_device_node_count(sci_dev);
 
 	node_index = scic_sds_remote_node_table_allocate_remote_node(
-		&this_controller->available_remote_nodes, remote_node_count
+		&scic->available_remote_nodes, remote_node_count
 		);
 
 	if (node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
-		this_controller->device_table[node_index] = the_device;
+		scic->device_table[node_index] = sci_dev;
 
 		*node_id = node_index;
 
@@ -1691,23 +1688,23 @@ enum sci_status scic_sds_controller_allocate_remote_node_context(
  * This method frees the remote node index back to the available pool.  Once
  *    this is done the remote node context buffer is no longer valid and can
  *    not be used.
- * @this_controller:
- * @the_device:
+ * @scic:
+ * @sci_dev:
  * @node_id:
  *
  */
 void scic_sds_controller_free_remote_node_context(
-	struct scic_sds_controller *this_controller,
-	struct scic_sds_remote_device *the_device,
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *sci_dev,
 	u16 node_id)
 {
-	u32 remote_node_count = scic_sds_remote_device_node_count(the_device);
+	u32 remote_node_count = scic_sds_remote_device_node_count(sci_dev);
 
-	if (this_controller->device_table[node_id] == the_device) {
-		this_controller->device_table[node_id] = NULL;
+	if (scic->device_table[node_id] == sci_dev) {
+		scic->device_table[node_id] = NULL;
 
 		scic_sds_remote_node_table_release_remote_node_index(
-			&this_controller->available_remote_nodes, remote_node_count, node_id
+			&scic->available_remote_nodes, remote_node_count, node_id
 			);
 	}
 }
@@ -1715,20 +1712,20 @@ void scic_sds_controller_free_remote_node_context(
 /**
  * This method returns the union scu_remote_node_context for the specified remote
  *    node id.
- * @this_controller:
+ * @scic:
  * @node_id:
  *
  * union scu_remote_node_context*
  */
 union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffer(
-	struct scic_sds_controller *this_controller,
+	struct scic_sds_controller *scic,
 	u16 node_id
 	) {
 	if (
-		(node_id < this_controller->remote_node_entries)
-		&& (this_controller->device_table[node_id] != NULL)
+		(node_id < scic->remote_node_entries)
+		&& (scic->device_table[node_id] != NULL)
 		) {
-		return &this_controller->remote_node_context_table[node_id];
+		return &scic->remote_node_context_table[node_id];
 	}
 
 	return NULL;
@@ -1767,18 +1764,18 @@ void scic_sds_controller_copy_sata_response(
  *    re-use by the hardware.  The data contained in the frame header and frame
  *    buffer is no longer valid. The UF queue get pointer is only updated if UF
  *    control indicates this is appropriate.
- * @this_controller:
+ * @scic:
  * @frame_index:
  *
  */
 void scic_sds_controller_release_frame(
-	struct scic_sds_controller *this_controller,
+	struct scic_sds_controller *scic,
 	u32 frame_index)
 {
 	if (scic_sds_unsolicited_frame_control_release_frame(
-		    &this_controller->uf_control, frame_index) == true)
-		writel(this_controller->uf_control.get,
-			&this_controller->scu_registers->sdma.unsolicited_frame_get_pointer);
+		    &scic->uf_control, frame_index) == true)
+		writel(scic->uf_control.get,
+			&scic->scu_registers->sdma.unsolicited_frame_get_pointer);
 }
 
 /**
@@ -2888,11 +2885,11 @@ enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 static void scic_sds_controller_initial_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_controller *this_controller;
+	struct scic_sds_controller *scic;
 
-	this_controller = (struct scic_sds_controller *)object;
+	scic = (struct scic_sds_controller *)object;
 
-	sci_base_state_machine_change_state(&this_controller->state_machine,
+	sci_base_state_machine_change_state(&scic->state_machine,
 			SCI_BASE_CONTROLLER_STATE_RESET);
 }
 
@@ -2925,13 +2922,13 @@ static inline void scic_sds_controller_starting_state_exit(
 static void scic_sds_controller_ready_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_controller *this_controller;
+	struct scic_sds_controller *scic;
 
-	this_controller = (struct scic_sds_controller *)object;
+	scic = (struct scic_sds_controller *)object;
 
 	/* set the default interrupt coalescence number and timeout value. */
 	scic_controller_set_interrupt_coalescence(
-		this_controller, 0x10, 250);
+		scic, 0x10, 250);
 }
 
 /**
@@ -2945,12 +2942,12 @@ static void scic_sds_controller_ready_state_enter(
 static void scic_sds_controller_ready_state_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_controller *this_controller;
+	struct scic_sds_controller *scic;
 
-	this_controller = (struct scic_sds_controller *)object;
+	scic = (struct scic_sds_controller *)object;
 
 	/* disable interrupt coalescence. */
-	scic_controller_set_interrupt_coalescence(this_controller, 0, 0);
+	scic_controller_set_interrupt_coalescence(scic, 0, 0);
 }
 
 /**
@@ -2966,14 +2963,14 @@ static void scic_sds_controller_ready_state_exit(
 static void scic_sds_controller_stopping_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_controller *this_controller;
+	struct scic_sds_controller *scic;
 
-	this_controller = (struct scic_sds_controller *)object;
+	scic = (struct scic_sds_controller *)object;
 
 	/* Stop all of the components for this controller */
-	scic_sds_controller_stop_phys(this_controller);
-	scic_sds_controller_stop_ports(this_controller);
-	scic_sds_controller_stop_devices(this_controller);
+	scic_sds_controller_stop_phys(scic);
+	scic_sds_controller_stop_ports(scic);
+	scic_sds_controller_stop_devices(scic);
 }
 
 /**
diff --git a/drivers/scsi/isci/core/scic_sds_controller.h b/drivers/scsi/isci/core/scic_sds_controller.h
index 9a646e5..4bb9a43 100644
--- a/drivers/scsi/isci/core/scic_sds_controller.h
+++ b/drivers/scsi/isci/core/scic_sds_controller.h
@@ -542,12 +542,12 @@ void scic_sds_controller_copy_sata_response(
 
 enum sci_status scic_sds_controller_allocate_remote_node_context(
 	struct scic_sds_controller *this_controller,
-	struct scic_sds_remote_device *the_device,
+	struct scic_sds_remote_device *sci_dev,
 	u16 *node_id);
 
 void scic_sds_controller_free_remote_node_context(
 	struct scic_sds_controller *this_controller,
-	struct scic_sds_remote_device *the_device,
+	struct scic_sds_remote_device *sci_dev,
 	u16 node_id);
 
 union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffer(
@@ -565,25 +565,25 @@ struct scu_task_context *scic_sds_controller_get_task_context_buffer(
 
 void scic_sds_controller_power_control_queue_insert(
 	struct scic_sds_controller *this_controller,
-	struct scic_sds_phy *the_phy);
+	struct scic_sds_phy *sci_phy);
 
 void scic_sds_controller_power_control_queue_remove(
 	struct scic_sds_controller *this_controller,
-	struct scic_sds_phy *the_phy);
+	struct scic_sds_phy *sci_phy);
 
 void scic_sds_controller_link_up(
 	struct scic_sds_controller *this_controller,
-	struct scic_sds_port *the_port,
-	struct scic_sds_phy *the_phy);
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
 
 void scic_sds_controller_link_down(
 	struct scic_sds_controller *this_controller,
-	struct scic_sds_port *the_port,
-	struct scic_sds_phy *the_phy);
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
 
 void scic_sds_controller_remote_device_stopped(
 	struct scic_sds_controller *this_controller,
-	struct scic_sds_remote_device *the_device);
+	struct scic_sds_remote_device *sci_dev);
 
 void scic_sds_controller_copy_task_context(
 	struct scic_sds_controller *this_controller,
diff --git a/drivers/scsi/isci/core/scic_sds_phy.c b/drivers/scsi/isci/core/scic_sds_phy.c
index 40176f0..34bd3b2 100644
--- a/drivers/scsi/isci/core/scic_sds_phy.c
+++ b/drivers/scsi/isci/core/scic_sds_phy.c
@@ -84,26 +84,29 @@ enum sas_linkrate sci_phy_linkrate(struct scic_sds_phy *sci_phy)
 
 /**
  * This method will initialize the phy transport layer registers
- * @this_phy:
+ * @sci_phy:
  * @transport_layer_registers
  *
  * enum sci_status
  */
 static enum sci_status scic_sds_phy_transport_layer_initialization(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	struct scu_transport_layer_registers __iomem *transport_layer_registers)
 {
 	u32 tl_control;
 
-	this_phy->transport_layer_registers = transport_layer_registers;
+	sci_phy->transport_layer_registers = transport_layer_registers;
 
 	writel(SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX,
-		&this_phy->transport_layer_registers->stp_rni);
+		&sci_phy->transport_layer_registers->stp_rni);
 
-	/* Hardware team recommends that we enable the STP prefetch for all transports */
-	tl_control = readl(&this_phy->transport_layer_registers->control);
+	/*
+	 * Hardware team recommends that we enable the STP prefetch for all
+	 * transports
+	 */
+	tl_control = readl(&sci_phy->transport_layer_registers->control);
 	tl_control |= SCU_TLCR_GEN_BIT(STP_WRITE_DATA_PREFETCH);
-	writel(tl_control, &this_phy->transport_layer_registers->control);
+	writel(tl_control, &sci_phy->transport_layer_registers->control);
 
 	return SCI_SUCCESS;
 }
@@ -284,7 +287,7 @@ static void scic_sds_phy_sata_timeout(void *phy)
  * This method returns the port currently containing this phy. If the phy is
  *    currently contained by the dummy port, then the phy is considered to not
  *    be part of a port.
- * @this_phy: This parameter specifies the phy for which to retrieve the
+ * @sci_phy: This parameter specifies the phy for which to retrieve the
  *    containing port.
  *
  * This method returns a handle to a port that contains the supplied phy.
@@ -293,30 +296,30 @@ static void scic_sds_phy_sata_timeout(void *phy)
  * values indicate a handle/pointer to the port containing the phy.
  */
 struct scic_sds_port *scic_sds_phy_get_port(
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_phy *sci_phy)
 {
-	if (scic_sds_port_get_index(this_phy->owning_port) == SCIC_SDS_DUMMY_PORT)
+	if (scic_sds_port_get_index(sci_phy->owning_port) == SCIC_SDS_DUMMY_PORT)
 		return NULL;
 
-	return this_phy->owning_port;
+	return sci_phy->owning_port;
 }
 
 /**
  * This method will assign a port to the phy object.
- * @out]: this_phy This parameter specifies the phy for which to assign a port
+ * @out]: sci_phy This parameter specifies the phy for which to assign a port
  *    object.
  *
  *
  */
 void scic_sds_phy_set_port(
-	struct scic_sds_phy *this_phy,
-	struct scic_sds_port *the_port)
+	struct scic_sds_phy *sci_phy,
+	struct scic_sds_port *sci_port)
 {
-	this_phy->owning_port = the_port;
+	sci_phy->owning_port = sci_port;
 
-	if (this_phy->bcn_received_while_port_unassigned) {
-		this_phy->bcn_received_while_port_unassigned = false;
-		scic_sds_port_broadcast_change_received(this_phy->owning_port, this_phy);
+	if (sci_phy->bcn_received_while_port_unassigned) {
+		sci_phy->bcn_received_while_port_unassigned = false;
+		scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
 	}
 }
 
@@ -362,123 +365,125 @@ enum sci_status scic_sds_phy_initialize(
 /**
  * This method assigns the direct attached device ID for this phy.
  *
- * @this_phy The phy for which the direct attached device id is to
+ * @sci_phy The phy for which the direct attached device id is to
  *       be assigned.
  * @device_id The direct attached device ID to assign to the phy.
  *       This will either be the RNi for the device or an invalid RNi if there
  *       is no current device assigned to the phy.
  */
 void scic_sds_phy_setup_transport(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	u32 device_id)
 {
 	u32 tl_control;
 
-	writel(device_id, &this_phy->transport_layer_registers->stp_rni);
+	writel(device_id, &sci_phy->transport_layer_registers->stp_rni);
 
 	/*
 	 * The read should guarantee that the first write gets posted
 	 * before the next write
 	 */
-	tl_control = readl(&this_phy->transport_layer_registers->control);
+	tl_control = readl(&sci_phy->transport_layer_registers->control);
 	tl_control |= SCU_TLCR_GEN_BIT(CLEAR_TCI_NCQ_MAPPING_TABLE);
-	writel(tl_control, &this_phy->transport_layer_registers->control);
+	writel(tl_control, &sci_phy->transport_layer_registers->control);
 }
 
 /**
  *
- * @this_phy: The phy object to be suspended.
+ * @sci_phy: The phy object to be suspended.
  *
  * This function will perform the register reads/writes to suspend the SCU
  * hardware protocol engine. none
  */
 static void scic_sds_phy_suspend(
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_phy *sci_phy)
 {
 	u32 scu_sas_pcfg_value;
 
 	scu_sas_pcfg_value =
-		readl(&this_phy->link_layer_registers->phy_configuration);
+		readl(&sci_phy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);
 	writel(scu_sas_pcfg_value,
-		&this_phy->link_layer_registers->phy_configuration);
+		&sci_phy->link_layer_registers->phy_configuration);
 
-	scic_sds_phy_setup_transport(this_phy, SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
+	scic_sds_phy_setup_transport(
+			sci_phy,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
 }
 
 /**
  *
- * @this_phy: The phy object to resume.
+ * @sci_phy: The phy object to resume.
  *
  * This function will perform the register reads/writes required to resume the
  * SCU hardware protocol engine. none
  */
 void scic_sds_phy_resume(
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_phy *sci_phy)
 {
 	u32 scu_sas_pcfg_value;
 
 	scu_sas_pcfg_value =
-		readl(&this_phy->link_layer_registers->phy_configuration);
+		readl(&sci_phy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);
 	writel(scu_sas_pcfg_value,
-		&this_phy->link_layer_registers->phy_configuration);
+		&sci_phy->link_layer_registers->phy_configuration);
 }
 
 /**
  * This method returns the local sas address assigned to this phy.
- * @this_phy: This parameter specifies the phy for which to retrieve the local
+ * @sci_phy: This parameter specifies the phy for which to retrieve the local
  *    SAS address.
  * @sas_address: This parameter specifies the location into which to copy the
  *    local SAS address.
  *
  */
 void scic_sds_phy_get_sas_address(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	struct sci_sas_address *sas_address)
 {
-	sas_address->high = readl(&this_phy->link_layer_registers->source_sas_address_high);
-	sas_address->low = readl(&this_phy->link_layer_registers->source_sas_address_low);
+	sas_address->high = readl(&sci_phy->link_layer_registers->source_sas_address_high);
+	sas_address->low = readl(&sci_phy->link_layer_registers->source_sas_address_low);
 }
 
 /**
  * This method returns the remote end-point (i.e. attached) sas address
  *    assigned to this phy.
- * @this_phy: This parameter specifies the phy for which to retrieve the remote
+ * @sci_phy: This parameter specifies the phy for which to retrieve the remote
  *    end-point SAS address.
  * @sas_address: This parameter specifies the location into which to copy the
  *    remote end-point SAS address.
  *
  */
 void scic_sds_phy_get_attached_sas_address(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	struct sci_sas_address *sas_address)
 {
 	sas_address->high
-		= this_phy->phy_type.sas.identify_address_frame_buffer.sas_address.high;
+		= sci_phy->phy_type.sas.identify_address_frame_buffer.sas_address.high;
 	sas_address->low
-		= this_phy->phy_type.sas.identify_address_frame_buffer.sas_address.low;
+		= sci_phy->phy_type.sas.identify_address_frame_buffer.sas_address.low;
 }
 
 /**
  * This method returns the supported protocols assigned to this phy
- * @this_phy:
+ * @sci_phy:
  *
  *
  */
 void scic_sds_phy_get_protocols(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	struct sci_sas_identify_address_frame_protocols *protocols)
 {
 	protocols->u.all =
-		(u16)(readl(&this_phy->
+		(u16)(readl(&sci_phy->
 			link_layer_registers->transmit_identification) &
 				0x0000FFFF);
 }
 
 /**
  *
- * @this_phy: The parameter is the phy object for which the attached phy
+ * @sci_phy: The parameter is the phy object for which the attached phy
  *    protcols are to be returned.
  *
  * This method returns the supported protocols for the attached phy.  If this
@@ -488,15 +493,15 @@ void scic_sds_phy_get_protocols(
  * value.
  */
 void scic_sds_phy_get_attached_phy_protocols(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	struct sci_sas_identify_address_frame_protocols *protocols)
 {
 	protocols->u.all = 0;
 
-	if (this_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+	if (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
 		protocols->u.all =
-			this_phy->phy_type.sas.identify_address_frame_buffer.protocols.u.all;
-	} else if (this_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
+			sci_phy->phy_type.sas.identify_address_frame_buffer.protocols.u.all;
+	} else if (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
 		protocols->u.bits.stp_target = 1;
 	}
 }
@@ -533,54 +538,54 @@ enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy)
 /**
  * This method will attempt to reset the phy.  This request is only valid when
  *    the phy is in an ready state
- * @this_phy:
+ * @sci_phy:
  *
  * enum sci_status
  */
 enum sci_status scic_sds_phy_reset(
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_phy *sci_phy)
 {
-	return this_phy->state_handlers->reset_handler(this_phy);
+	return sci_phy->state_handlers->reset_handler(sci_phy);
 }
 
 /**
  * This method will process the event code received.
- * @this_phy:
+ * @sci_phy:
  * @event_code:
  *
  * enum sci_status
  */
 enum sci_status scic_sds_phy_event_handler(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	u32 event_code)
 {
-	return this_phy->state_handlers->event_handler(this_phy, event_code);
+	return sci_phy->state_handlers->event_handler(sci_phy, event_code);
 }
 
 /**
  * This method will process the frame index received.
- * @this_phy:
+ * @sci_phy:
  * @frame_index:
  *
  * enum sci_status
  */
 enum sci_status scic_sds_phy_frame_handler(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	u32 frame_index)
 {
-	return this_phy->state_handlers->frame_handler(this_phy, frame_index);
+	return sci_phy->state_handlers->frame_handler(sci_phy, frame_index);
 }
 
 /**
  * This method will give the phy permission to consume power
- * @this_phy:
+ * @sci_phy:
  *
  * enum sci_status
  */
 enum sci_status scic_sds_phy_consume_power_handler(
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_phy *sci_phy)
 {
-	return this_phy->state_handlers->consume_power_handler(this_phy);
+	return sci_phy->state_handlers->consume_power_handler(sci_phy);
 }
 
 /*
@@ -638,7 +643,7 @@ enum sci_status scic_sata_phy_get_properties(
 
 /**
  *
- * @this_phy: The phy object that received SAS PHY DETECTED.
+ * @sci_phy: The phy object that received SAS PHY DETECTED.
  *
  * This method continues the link training for the phy as if it were a SAS PHY
  * instead of a SATA PHY. This is done because the completion queue had a SAS
@@ -646,41 +651,41 @@ enum sci_status scic_sata_phy_get_properties(
  * none
  */
 static void scic_sds_phy_start_sas_link_training(
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_phy *sci_phy)
 {
 	u32 phy_control;
 
 	phy_control =
-		readl(&this_phy->link_layer_registers->phy_configuration);
+		readl(&sci_phy->link_layer_registers->phy_configuration);
 	phy_control |= SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD);
 	writel(phy_control,
-		&this_phy->link_layer_registers->phy_configuration);
+		&sci_phy->link_layer_registers->phy_configuration);
 
 	sci_base_state_machine_change_state(
-		&this_phy->starting_substate_machine,
+		&sci_phy->starting_substate_machine,
 		SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN
 		);
 
-	this_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SAS;
+	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SAS;
 }
 
 /**
  *
- * @this_phy: The phy object that received a SATA SPINUP HOLD event
+ * @sci_phy: The phy object that received a SATA SPINUP HOLD event
  *
  * This method continues the link training for the phy as if it were a SATA PHY
  * instead of a SAS PHY.  This is done because the completion queue had a SATA
  * SPINUP HOLD event when the state machine was expecting a SAS PHY event. none
  */
 static void scic_sds_phy_start_sata_link_training(
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_phy *sci_phy)
 {
 	sci_base_state_machine_change_state(
-		&this_phy->starting_substate_machine,
+		&sci_phy->starting_substate_machine,
 		SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER
 		);
 
-	this_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
+	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
 }
 
 /**
@@ -748,24 +753,24 @@ static enum sci_status scic_sds_phy_starting_substate_general_stop_handler(
  * SCI_FAILURE on any unexpected event notifation
  */
 static enum sci_status scic_sds_phy_starting_substate_await_ossp_event_handler(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	u32 event_code)
 {
 	u32 result = SCI_SUCCESS;
 
 	switch (scu_get_event_code(event_code)) {
 	case SCU_EVENT_SAS_PHY_DETECTED:
-		scic_sds_phy_start_sas_link_training(this_phy);
-		this_phy->is_in_link_training = true;
+		scic_sds_phy_start_sas_link_training(sci_phy);
+		sci_phy->is_in_link_training = true;
 		break;
 
 	case SCU_EVENT_SATA_SPINUP_HOLD:
-		scic_sds_phy_start_sata_link_training(this_phy);
-		this_phy->is_in_link_training = true;
+		scic_sds_phy_start_sata_link_training(sci_phy);
+		sci_phy->is_in_link_training = true;
 		break;
 
 	default:
-		dev_dbg(sciphy_to_dev(this_phy),
+		dev_dbg(sciphy_to_dev(sci_phy),
 			"%s: PHY starting substate machine received "
 			"unexpected event_code %x\n",
 			__func__,
@@ -793,7 +798,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_ossp_event_handler(
  * event notification SCI_FAILURE on any unexpected event notifation
  */
 static enum sci_status scic_sds_phy_starting_substate_await_sas_phy_speed_event_handler(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	u32 event_code)
 {
 	u32 result = SCI_SUCCESS;
@@ -808,38 +813,41 @@ static enum sci_status scic_sds_phy_starting_substate_await_sas_phy_speed_event_
 	case SCU_EVENT_SAS_15:
 	case SCU_EVENT_SAS_15_SSC:
 		scic_sds_phy_complete_link_training(
-			this_phy, SAS_LINK_RATE_1_5_GBPS, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF
-			);
+			sci_phy,
+			SAS_LINK_RATE_1_5_GBPS,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
 		break;
 
 	case SCU_EVENT_SAS_30:
 	case SCU_EVENT_SAS_30_SSC:
 		scic_sds_phy_complete_link_training(
-			this_phy, SAS_LINK_RATE_3_0_GBPS, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF
-			);
+			sci_phy,
+			SAS_LINK_RATE_3_0_GBPS,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
 		break;
 
 	case SCU_EVENT_SAS_60:
 	case SCU_EVENT_SAS_60_SSC:
 		scic_sds_phy_complete_link_training(
-			this_phy, SAS_LINK_RATE_6_0_GBPS, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF
-			);
+			sci_phy,
+			SAS_LINK_RATE_6_0_GBPS,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
 		break;
 
 	case SCU_EVENT_SATA_SPINUP_HOLD:
 		/*
 		 * We were doing SAS PHY link training and received a SATA PHY event
 		 * continue OOB/SN as if this were a SATA PHY */
-		scic_sds_phy_start_sata_link_training(this_phy);
+		scic_sds_phy_start_sata_link_training(sci_phy);
 		break;
 
 	case SCU_EVENT_LINK_FAILURE:
 		/* Link failure change state back to the starting state */
-		scic_sds_phy_restart_starting_state(this_phy);
+		scic_sds_phy_restart_starting_state(sci_phy);
 		break;
 
 	default:
-		dev_warn(sciphy_to_dev(this_phy),
+		dev_warn(sciphy_to_dev(sci_phy),
 			 "%s: PHY starting substate machine received "
 			 "unexpected event_code %x\n",
 			 __func__,
@@ -867,7 +875,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_sas_phy_speed_event_
  * unexpected event notifation
  */
 static enum sci_status scic_sds_phy_starting_substate_await_iaf_uf_event_handler(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	u32 event_code)
 {
 	u32 result = SCI_SUCCESS;
@@ -875,25 +883,25 @@ static enum sci_status scic_sds_phy_starting_substate_await_iaf_uf_event_handler
 	switch (scu_get_event_code(event_code)) {
 	case SCU_EVENT_SAS_PHY_DETECTED:
 		/* Backup the state machine */
-		scic_sds_phy_start_sas_link_training(this_phy);
+		scic_sds_phy_start_sas_link_training(sci_phy);
 		break;
 
 	case SCU_EVENT_SATA_SPINUP_HOLD:
 		/*
 		 * We were doing SAS PHY link training and received a SATA PHY event
 		 * continue OOB/SN as if this were a SATA PHY */
-		scic_sds_phy_start_sata_link_training(this_phy);
+		scic_sds_phy_start_sata_link_training(sci_phy);
 		break;
 
 	case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
 	case SCU_EVENT_LINK_FAILURE:
 	case SCU_EVENT_HARD_RESET_RECEIVED:
 		/* Start the oob/sn state machine over again */
-		scic_sds_phy_restart_starting_state(this_phy);
+		scic_sds_phy_restart_starting_state(sci_phy);
 		break;
 
 	default:
-		dev_warn(sciphy_to_dev(this_phy),
+		dev_warn(sciphy_to_dev(sci_phy),
 			 "%s: PHY starting substate machine received "
 			 "unexpected event_code %x\n",
 			 __func__,
@@ -919,7 +927,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_iaf_uf_event_handler
  * notifation
  */
 static enum sci_status scic_sds_phy_starting_substate_await_sas_power_event_handler(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	u32 event_code)
 {
 	u32 result = SCI_SUCCESS;
@@ -927,11 +935,11 @@ static enum sci_status scic_sds_phy_starting_substate_await_sas_power_event_hand
 	switch (scu_get_event_code(event_code)) {
 	case SCU_EVENT_LINK_FAILURE:
 		/* Link failure change state back to the starting state */
-		scic_sds_phy_restart_starting_state(this_phy);
+		scic_sds_phy_restart_starting_state(sci_phy);
 		break;
 
 	default:
-		dev_warn(sciphy_to_dev(this_phy),
+		dev_warn(sciphy_to_dev(sci_phy),
 			"%s: PHY starting substate machine received unexpected "
 			"event_code %x\n",
 			__func__,
@@ -957,7 +965,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_sas_power_event_hand
  * on a link failure event SCI_FAILURE on any unexpected event notifation
  */
 static enum sci_status scic_sds_phy_starting_substate_await_sata_power_event_handler(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	u32 event_code)
 {
 	u32 result = SCI_SUCCESS;
@@ -965,7 +973,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_sata_power_event_han
 	switch (scu_get_event_code(event_code)) {
 	case SCU_EVENT_LINK_FAILURE:
 		/* Link failure change state back to the starting state */
-		scic_sds_phy_restart_starting_state(this_phy);
+		scic_sds_phy_restart_starting_state(sci_phy);
 		break;
 
 	case SCU_EVENT_SATA_SPINUP_HOLD:
@@ -976,11 +984,11 @@ static enum sci_status scic_sds_phy_starting_substate_await_sata_power_event_han
 		/*
 		 * There has been a change in the phy type before OOB/SN for the
 		 * SATA finished start down the SAS link traning path. */
-		scic_sds_phy_start_sas_link_training(this_phy);
+		scic_sds_phy_start_sas_link_training(sci_phy);
 		break;
 
 	default:
-		dev_warn(sciphy_to_dev(this_phy),
+		dev_warn(sciphy_to_dev(sci_phy),
 			 "%s: PHY starting substate machine received "
 			 "unexpected event_code %x\n",
 			 __func__,
@@ -1066,7 +1074,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_sata_phy_event_handl
  * valid event notification SCI_FAILURE on any unexpected event notifation
  */
 static enum sci_status scic_sds_phy_starting_substate_await_sata_speed_event_handler(
-	struct scic_sds_phy *this_phy,
+	struct scic_sds_phy *sci_phy,
 	u32 event_code)
 {
 	u32 result = SCI_SUCCESS;
@@ -1081,44 +1089,41 @@ static enum sci_status scic_sds_phy_starting_substate_await_sata_speed_event_han
 	case SCU_EVENT_SATA_15:
 	case SCU_EVENT_SATA_15_SSC:
 		scic_sds_phy_complete_link_training(
-			this_phy,
+			sci_phy,
 			SAS_LINK_RATE_1_5_GBPS,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF
-			);
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
 		break;
 
 	case SCU_EVENT_SATA_30:
 	case SCU_EVENT_SATA_30_SSC:
 		scic_sds_phy_complete_link_training(
-			this_phy,
+			sci_phy,
 			SAS_LINK_RATE_3_0_GBPS,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF
-			);
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
 		break;
 
 	case SCU_EVENT_SATA_60:
 	case SCU_EVENT_SATA_60_SSC:
 		scic_sds_phy_complete_link_training(
-			this_phy,
+			sci_phy,
 			SAS_LINK_RATE_6_0_GBPS,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF
-			);
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
 		break;
 
 	case SCU_EVENT_LINK_FAILURE:
 		/* Link failure change state back to the starting state */
-		scic_sds_phy_restart_starting_state(this_phy);
+		scic_sds_phy_restart_starting_state(sci_phy);
 		break;
 
 	case SCU_EVENT_SAS_PHY_DETECTED:
 		/*
 		 * There has been a change in the phy type before OOB/SN for the
 		 * SATA finished start down the SAS link traning path. */
-		scic_sds_phy_start_sas_link_training(this_phy);
+		scic_sds_phy_start_sas_link_training(sci_phy);
 		break;
 
 	default:
-		dev_warn(sciphy_to_dev(this_phy),
+		dev_warn(sciphy_to_dev(sci_phy),
 			 "%s: PHY starting substate machine received "
 			 "unexpected event_code %x\n",
 			 __func__,
@@ -1583,12 +1588,12 @@ static void scic_sds_phy_starting_initial_substate_enter(struct sci_base_object
 static void scic_sds_phy_starting_await_ossp_en_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
 	scic_sds_phy_set_starting_substate_handlers(
-		this_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN
 		);
 }
 
@@ -1603,12 +1608,12 @@ static void scic_sds_phy_starting_await_ossp_en_substate_enter(
 static void scic_sds_phy_starting_await_sas_speed_en_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
 	scic_sds_phy_set_starting_substate_handlers(
-		this_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN
 		);
 }
 
@@ -1623,12 +1628,12 @@ static void scic_sds_phy_starting_await_sas_speed_en_substate_enter(
 static void scic_sds_phy_starting_await_iaf_uf_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
 	scic_sds_phy_set_starting_substate_handlers(
-		this_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF
 		);
 }
 
@@ -1644,17 +1649,17 @@ static void scic_sds_phy_starting_await_iaf_uf_substate_enter(
 static void scic_sds_phy_starting_await_sas_power_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
 	scic_sds_phy_set_starting_substate_handlers(
-		this_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER
 		);
 
 	scic_sds_controller_power_control_queue_insert(
-		scic_sds_phy_get_controller(this_phy),
-		this_phy
+		scic_sds_phy_get_controller(sci_phy),
+		sci_phy
 		);
 }
 
@@ -1669,12 +1674,12 @@ static void scic_sds_phy_starting_await_sas_power_substate_enter(
 static void scic_sds_phy_starting_await_sas_power_substate_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
 	scic_sds_controller_power_control_queue_remove(
-		scic_sds_phy_get_controller(this_phy), this_phy
+		scic_sds_phy_get_controller(sci_phy), sci_phy
 		);
 }
 
@@ -1690,17 +1695,17 @@ static void scic_sds_phy_starting_await_sas_power_substate_exit(
 static void scic_sds_phy_starting_await_sata_power_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
 	scic_sds_phy_set_starting_substate_handlers(
-		this_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER
 		);
 
 	scic_sds_controller_power_control_queue_insert(
-		scic_sds_phy_get_controller(this_phy),
-		this_phy
+		scic_sds_phy_get_controller(sci_phy),
+		sci_phy
 		);
 }
 
@@ -1715,13 +1720,13 @@ static void scic_sds_phy_starting_await_sata_power_substate_enter(
 static void scic_sds_phy_starting_await_sata_power_substate_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
 	scic_sds_controller_power_control_queue_remove(
-		scic_sds_phy_get_controller(this_phy),
-		this_phy
+		scic_sds_phy_get_controller(sci_phy),
+		sci_phy
 		);
 }
 
@@ -2115,33 +2120,32 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 
 /**
  *
- * @this_phy: This is the struct scic_sds_phy object to stop.
+ * @sci_phy: This is the struct scic_sds_phy object to stop.
  *
  * This method will stop the struct scic_sds_phy object. This does not reset the
  * protocol engine it just suspends it and places it in a state where it will
  * not cause the end device to power up. none
  */
 static void scu_link_layer_stop_protocol_engine(
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_phy *sci_phy)
 {
 	u32 scu_sas_pcfg_value;
 	u32 enable_spinup_value;
 
 	/* Suspend the protocol engine and place it in a sata spinup hold state */
 	scu_sas_pcfg_value =
-		readl(&this_phy->link_layer_registers->phy_configuration);
-	scu_sas_pcfg_value |= (
-		SCU_SAS_PCFG_GEN_BIT(OOB_RESET)
-		| SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE)
-		| SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD)
-		);
+		readl(&sci_phy->link_layer_registers->phy_configuration);
+	scu_sas_pcfg_value |=
+		(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
+		 SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE) |
+		 SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD));
 	writel(scu_sas_pcfg_value,
-		&this_phy->link_layer_registers->phy_configuration);
+	       &sci_phy->link_layer_registers->phy_configuration);
 
 	/* Disable the notify enable spinup primitives */
-	enable_spinup_value = readl(&this_phy->link_layer_registers->notify_enable_spinup_control);
+	enable_spinup_value = readl(&sci_phy->link_layer_registers->notify_enable_spinup_control);
 	enable_spinup_value &= ~SCU_ENSPINUP_GEN_BIT(ENABLE);
-	writel(enable_spinup_value, &this_phy->link_layer_registers->notify_enable_spinup_control);
+	writel(enable_spinup_value, &sci_phy->link_layer_registers->notify_enable_spinup_control);
 }
 
 /**
@@ -2150,17 +2154,18 @@ static void scu_link_layer_stop_protocol_engine(
  * This method will start the OOB/SN state machine for this struct scic_sds_phy object.
  */
 static void scu_link_layer_start_oob(
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_phy *sci_phy)
 {
 	u32 scu_sas_pcfg_value;
 
 	scu_sas_pcfg_value =
-		readl(&this_phy->link_layer_registers->phy_configuration);
+		readl(&sci_phy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
 	scu_sas_pcfg_value &=
-		~(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) | SCU_SAS_PCFG_GEN_BIT(HARD_RESET));
+		~(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
+		SCU_SAS_PCFG_GEN_BIT(HARD_RESET));
 	writel(scu_sas_pcfg_value,
-		&this_phy->link_layer_registers->phy_configuration);
+	       &sci_phy->link_layer_registers->phy_configuration);
 }
 
 /**
@@ -2172,7 +2177,7 @@ static void scu_link_layer_start_oob(
  * hard reset bit set.
  */
 static void scu_link_layer_tx_hard_reset(
-	struct scic_sds_phy *this_phy)
+	struct scic_sds_phy *sci_phy)
 {
 	u32 phy_configuration_value;
 
@@ -2180,17 +2185,18 @@ static void scu_link_layer_tx_hard_reset(
 	 * SAS Phys must wait for the HARD_RESET_TX event notification to transition
 	 * to the starting state. */
 	phy_configuration_value =
-		readl(&this_phy->link_layer_registers->phy_configuration);
+		readl(&sci_phy->link_layer_registers->phy_configuration);
 	phy_configuration_value |=
-		(SCU_SAS_PCFG_GEN_BIT(HARD_RESET) | SCU_SAS_PCFG_GEN_BIT(OOB_RESET));
+		(SCU_SAS_PCFG_GEN_BIT(HARD_RESET) |
+		 SCU_SAS_PCFG_GEN_BIT(OOB_RESET));
 	writel(phy_configuration_value,
-		&this_phy->link_layer_registers->phy_configuration);
+	       &sci_phy->link_layer_registers->phy_configuration);
 
 	/* Now take the OOB state machine out of reset */
 	phy_configuration_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
 	phy_configuration_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
 	writel(phy_configuration_value,
-		&this_phy->link_layer_registers->phy_configuration);
+	       &sci_phy->link_layer_registers->phy_configuration);
 }
 
 /*
@@ -2209,11 +2215,11 @@ static void scu_link_layer_tx_hard_reset(
 static void scic_sds_phy_initial_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
-	scic_sds_phy_set_base_state_handlers(this_phy, SCI_BASE_PHY_STATE_INITIAL);
+	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_INITIAL);
 }
 
 /**
@@ -2273,28 +2279,28 @@ static void scic_sds_phy_stopped_state_enter(struct sci_base_object *object)
 static void scic_sds_phy_starting_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
-	scic_sds_phy_set_base_state_handlers(this_phy, SCI_BASE_PHY_STATE_STARTING);
+	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_STARTING);
 
-	scu_link_layer_stop_protocol_engine(this_phy);
-	scu_link_layer_start_oob(this_phy);
+	scu_link_layer_stop_protocol_engine(sci_phy);
+	scu_link_layer_start_oob(sci_phy);
 
 	/* We don't know what kind of phy we are going to be just yet */
-	this_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
-	this_phy->bcn_received_while_port_unassigned = false;
+	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
+	sci_phy->bcn_received_while_port_unassigned = false;
 
 	/* Change over to the starting substate machine to continue */
-	sci_base_state_machine_start(&this_phy->starting_substate_machine);
+	sci_base_state_machine_start(&sci_phy->starting_substate_machine);
 
-	if (this_phy->state_machine.previous_state_id
+	if (sci_phy->state_machine.previous_state_id
 	    == SCI_BASE_PHY_STATE_READY) {
 		scic_sds_controller_link_down(
-			scic_sds_phy_get_controller(this_phy),
-			scic_sds_phy_get_port(this_phy),
-			this_phy
+			scic_sds_phy_get_controller(sci_phy),
+			scic_sds_phy_get_port(sci_phy),
+			sci_phy
 			);
 	}
 }
@@ -2312,16 +2318,16 @@ static void scic_sds_phy_starting_state_enter(
 static void scic_sds_phy_ready_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
-	scic_sds_phy_set_base_state_handlers(this_phy, SCI_BASE_PHY_STATE_READY);
+	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_READY);
 
 	scic_sds_controller_link_up(
-		scic_sds_phy_get_controller(this_phy),
-		scic_sds_phy_get_port(this_phy),
-		this_phy
+		scic_sds_phy_get_controller(sci_phy),
+		scic_sds_phy_get_port(sci_phy),
+		sci_phy
 		);
 }
 
@@ -2336,11 +2342,11 @@ static void scic_sds_phy_ready_state_enter(
 static void scic_sds_phy_ready_state_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
-	scic_sds_phy_suspend(this_phy);
+	scic_sds_phy_suspend(sci_phy);
 }
 
 /**
@@ -2354,26 +2360,28 @@ static void scic_sds_phy_ready_state_exit(
 static void scic_sds_phy_resetting_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
-	scic_sds_phy_set_base_state_handlers(this_phy, SCI_BASE_PHY_STATE_RESETTING);
+	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_RESETTING);
 
 	/*
 	 * The phy is being reset, therefore deactivate it from the port.
 	 * In the resetting state we don't notify the user regarding
 	 * link up and link down notifications. */
-	scic_sds_port_deactivate_phy(this_phy->owning_port, this_phy, false);
+	scic_sds_port_deactivate_phy(sci_phy->owning_port, sci_phy, false);
 
-	if (this_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
-		scu_link_layer_tx_hard_reset(this_phy);
+	if (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+		scu_link_layer_tx_hard_reset(sci_phy);
 	} else {
 		/*
-		 * The SCU does not need to have a discrete reset state so just go back to
-		 * the starting state. */
-		sci_base_state_machine_change_state(&this_phy->state_machine,
-						    SCI_BASE_PHY_STATE_STARTING);
+		 * The SCU does not need to have a discrete reset state so
+		 * just go back to the starting state.
+		 */
+		sci_base_state_machine_change_state(
+				&sci_phy->state_machine,
+				SCI_BASE_PHY_STATE_STARTING);
 	}
 }
 
@@ -2388,11 +2396,11 @@ static void scic_sds_phy_resetting_state_enter(
 static void scic_sds_phy_final_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_phy *this_phy;
+	struct scic_sds_phy *sci_phy;
 
-	this_phy = (struct scic_sds_phy *)object;
+	sci_phy = (struct scic_sds_phy *)object;
 
-	scic_sds_phy_set_base_state_handlers(this_phy, SCI_BASE_PHY_STATE_FINAL);
+	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_FINAL);
 
 	/* Nothing to do here */
 }
diff --git a/drivers/scsi/isci/core/scic_sds_port.c b/drivers/scsi/isci/core/scic_sds_port.c
index 40c1297..a8d7e51 100644
--- a/drivers/scsi/isci/core/scic_sds_port.c
+++ b/drivers/scsi/isci/core/scic_sds_port.c
@@ -75,7 +75,7 @@
 
 /**
  *
- * @this_port: This is the port object to which the phy is being assigned.
+ * @sci_port: This is the port object to which the phy is being assigned.
  * @phy_index: This is the phy index that is being assigned to the port.
  *
  * This method will return a true value if the specified phy can be assigned to
@@ -90,30 +90,30 @@
  * port
  */
 bool scic_sds_port_is_valid_phy_assignment(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	u32 phy_index)
 {
 	/* Initialize to invalid value. */
 	u32 existing_phy_index = SCI_MAX_PHYS;
 	u32 index;
 
-	if ((this_port->physical_port_index == 1) && (phy_index != 1)) {
+	if ((sci_port->physical_port_index == 1) && (phy_index != 1)) {
 		return false;
 	}
 
-	if (this_port->physical_port_index == 3 && phy_index != 3) {
+	if (sci_port->physical_port_index == 3 && phy_index != 3) {
 		return false;
 	}
 
 	if (
-		(this_port->physical_port_index == 2)
+		(sci_port->physical_port_index == 2)
 		&& ((phy_index == 0) || (phy_index == 1))
 		) {
 		return false;
 	}
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if ((this_port->phy_table[index] != NULL)
+		if ((sci_port->phy_table[index] != NULL)
 		    && (index != phy_index)) {
 			existing_phy_index = index;
 		}
@@ -124,9 +124,9 @@ bool scic_sds_port_is_valid_phy_assignment(
 	 * operating at the same maximum link rate. */
 	if (
 		(existing_phy_index < SCI_MAX_PHYS)
-		&& (this_port->owning_controller->user_parameters.sds1.phys[
+		&& (sci_port->owning_controller->user_parameters.sds1.phys[
 			    phy_index].max_speed_generation !=
-		    this_port->owning_controller->user_parameters.sds1.phys[
+		    sci_port->owning_controller->user_parameters.sds1.phys[
 			    existing_phy_index].max_speed_generation)
 		)
 		return false;
@@ -137,13 +137,13 @@ bool scic_sds_port_is_valid_phy_assignment(
 /**
  * This method requests a list (mask) of the phys contained in the supplied SAS
  *    port.
- * @this_port: a handle corresponding to the SAS port for which to return the
+ * @sci_port: a handle corresponding to the SAS port for which to return the
  *    phy mask.
  *
  * Return a bit mask indicating which phys are a part of this port. Each bit
  * corresponds to a phy identifier (e.g. bit 0 = phy id 0).
  */
-static u32 scic_sds_port_get_phys(struct scic_sds_port *this_port)
+static u32 scic_sds_port_get_phys(struct scic_sds_port *sci_port)
 {
 	u32 index;
 	u32 mask;
@@ -151,7 +151,7 @@ static u32 scic_sds_port_get_phys(struct scic_sds_port *this_port)
 	mask = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (this_port->phy_table[index] != NULL) {
+		if (sci_port->phy_table[index] != NULL) {
 			mask |= (1 << index);
 		}
 	}
@@ -161,7 +161,7 @@ static u32 scic_sds_port_get_phys(struct scic_sds_port *this_port)
 
 /**
  *
- * @this_port: This is the port object for which to determine if the phy mask
+ * @sci_port: This is the port object for which to determine if the phy mask
  *    can be supported.
  *
  * This method will return a true value if the port's phy mask can be supported
@@ -172,25 +172,25 @@ static u32 scic_sds_port_get_phys(struct scic_sds_port *this_port)
  * port false if this is not a valid phy assignment for the port
  */
 static bool scic_sds_port_is_phy_mask_valid(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	u32 phy_mask)
 {
-	if (this_port->physical_port_index == 0) {
+	if (sci_port->physical_port_index == 0) {
 		if (((phy_mask & 0x0F) == 0x0F)
 		    || ((phy_mask & 0x03) == 0x03)
 		    || ((phy_mask & 0x01) == 0x01)
 		    || (phy_mask == 0))
 			return true;
-	} else if (this_port->physical_port_index == 1) {
+	} else if (sci_port->physical_port_index == 1) {
 		if (((phy_mask & 0x02) == 0x02)
 		    || (phy_mask == 0))
 			return true;
-	} else if (this_port->physical_port_index == 2) {
+	} else if (sci_port->physical_port_index == 2) {
 		if (((phy_mask & 0x0C) == 0x0C)
 		    || ((phy_mask & 0x04) == 0x04)
 		    || (phy_mask == 0))
 			return true;
-	} else if (this_port->physical_port_index == 3) {
+	} else if (sci_port->physical_port_index == 3) {
 		if (((phy_mask & 0x08) == 0x08)
 		    || (phy_mask == 0))
 			return true;
@@ -201,7 +201,7 @@ static bool scic_sds_port_is_phy_mask_valid(
 
 /**
  *
- * @this_port: This parameter specifies the port from which to return a
+ * @sci_port: This parameter specifies the port from which to return a
  *    connected phy.
  *
  * This method retrieves a currently active (i.e. connected) phy contained in
@@ -212,7 +212,7 @@ static bool scic_sds_port_is_phy_mask_valid(
  * object that is active in the port.
  */
 static struct scic_sds_phy *scic_sds_port_get_a_connected_phy(
-	struct scic_sds_port *this_port
+	struct scic_sds_port *sci_port
 	) {
 	u32 index;
 	struct scic_sds_phy *phy;
@@ -221,10 +221,10 @@ static struct scic_sds_phy *scic_sds_port_get_a_connected_phy(
 		/*
 		 * Ensure that the phy is both part of the port and currently
 		 * connected to the remote end-point. */
-		phy = this_port->phy_table[index];
+		phy = sci_port->phy_table[index];
 		if (
 			(phy != NULL)
-			&& scic_sds_port_active_phy(this_port, phy)
+			&& scic_sds_port_active_phy(sci_port, phy)
 			) {
 			return phy;
 		}
@@ -304,50 +304,50 @@ static enum sci_status scic_sds_port_clear_phy(
 
 /**
  * scic_sds_port_add_phy() -
- * @this_port: This parameter specifies the port in which the phy will be added.
- * @the_phy: This parameter is the phy which is to be added to the port.
+ * @sci_port: This parameter specifies the port in which the phy will be added.
+ * @sci_phy: This parameter is the phy which is to be added to the port.
  *
  * This method will add a PHY to the selected port. This method returns an
  * enum sci_status. SCI_SUCCESS the phy has been added to the port. Any other status
  * is failre to add the phy to the port.
  */
 enum sci_status scic_sds_port_add_phy(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
 {
-	return this_port->state_handlers->add_phy_handler(
-		       this_port, the_phy);
+	return sci_port->state_handlers->add_phy_handler(
+		       sci_port, sci_phy);
 }
 
 
 /**
  * scic_sds_port_remove_phy() -
- * @this_port: This parameter specifies the port in which the phy will be added.
- * @the_phy: This parameter is the phy which is to be added to the port.
+ * @sci_port: This parameter specifies the port in which the phy will be added.
+ * @sci_phy: This parameter is the phy which is to be added to the port.
  *
  * This method will remove the PHY from the selected PORT. This method returns
  * an enum sci_status. SCI_SUCCESS the phy has been removed from the port. Any other
  * status is failre to add the phy to the port.
  */
 enum sci_status scic_sds_port_remove_phy(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
 {
-	return this_port->state_handlers->remove_phy_handler(
-		       this_port, the_phy);
+	return sci_port->state_handlers->remove_phy_handler(
+		       sci_port, sci_phy);
 }
 
 /**
  * This method requests the SAS address for the supplied SAS port from the SCI
  *    implementation.
- * @this_port: a handle corresponding to the SAS port for which to return the
+ * @sci_port: a handle corresponding to the SAS port for which to return the
  *    SAS address.
  * @sas_address: This parameter specifies a pointer to a SAS address structure
  *    into which the core will copy the SAS address for the port.
  *
  */
 void scic_sds_port_get_sas_address(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	struct sci_sas_address *sas_address)
 {
 	u32 index;
@@ -356,15 +356,15 @@ void scic_sds_port_get_sas_address(
 	sas_address->low  = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (this_port->phy_table[index] != NULL) {
-			scic_sds_phy_get_sas_address(this_port->phy_table[index], sas_address);
+		if (sci_port->phy_table[index] != NULL) {
+			scic_sds_phy_get_sas_address(sci_port->phy_table[index], sas_address);
 		}
 	}
 }
 
 /**
  * This method will indicate which protocols are supported by this port.
- * @this_port: a handle corresponding to the SAS port for which to return the
+ * @sci_port: a handle corresponding to the SAS port for which to return the
  *    supported protocols.
  * @protocols: This parameter specifies a pointer to an IAF protocol field
  *    structure into which the core will copy the protocol values for the port.
@@ -373,7 +373,7 @@ void scic_sds_port_get_sas_address(
  *
  */
 static void scic_sds_port_get_protocols(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	struct sci_sas_identify_address_frame_protocols *protocols)
 {
 	u8 index;
@@ -381,8 +381,8 @@ static void scic_sds_port_get_protocols(
 	protocols->u.all = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (this_port->phy_table[index] != NULL) {
-			scic_sds_phy_get_protocols(this_port->phy_table[index], protocols);
+		if (sci_port->phy_table[index] != NULL) {
+			scic_sds_phy_get_protocols(sci_port->phy_table[index], protocols);
 		}
 	}
 }
@@ -390,7 +390,7 @@ static void scic_sds_port_get_protocols(
 /**
  * This method requests the SAS address for the device directly attached to
  *    this SAS port.
- * @this_port: a handle corresponding to the SAS port for which to return the
+ * @sci_port: a handle corresponding to the SAS port for which to return the
  *    SAS address.
  * @sas_address: This parameter specifies a pointer to a SAS address structure
  *    into which the core will copy the SAS address for the device directly
@@ -398,7 +398,7 @@ static void scic_sds_port_get_protocols(
  *
  */
 void scic_sds_port_get_attached_sas_address(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	struct sci_sas_address *sas_address)
 {
 	struct sci_sas_identify_address_frame_protocols protocols;
@@ -407,7 +407,7 @@ void scic_sds_port_get_attached_sas_address(
 	/*
 	 * Ensure that the phy is both part of the port and currently
 	 * connected to the remote end-point. */
-	phy = scic_sds_port_get_a_connected_phy(this_port);
+	phy = scic_sds_port_get_a_connected_phy(sci_port);
 	if (phy != NULL) {
 		scic_sds_phy_get_attached_phy_protocols(phy, &protocols);
 
@@ -426,7 +426,7 @@ void scic_sds_port_get_attached_sas_address(
 /**
  * This method will indicate which protocols are supported by this remote
  *    device.
- * @this_port: a handle corresponding to the SAS port for which to return the
+ * @sci_port: a handle corresponding to the SAS port for which to return the
  *    supported protocols.
  * @protocols: This parameter specifies a pointer to an IAF protocol field
  *    structure into which the core will copy the protocol values for the port.
@@ -435,7 +435,7 @@ void scic_sds_port_get_attached_sas_address(
  *
  */
 void scic_sds_port_get_attached_protocols(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	struct sci_sas_identify_address_frame_protocols *protocols)
 {
 	struct scic_sds_phy *phy;
@@ -443,7 +443,7 @@ void scic_sds_port_get_attached_protocols(
 	/*
 	 * Ensure that the phy is both part of the port and currently
 	 * connected to the remote end-point. */
-	phy = scic_sds_port_get_a_connected_phy(this_port);
+	phy = scic_sds_port_get_a_connected_phy(sci_port);
 	if (phy != NULL)
 		scic_sds_phy_get_attached_phy_protocols(phy, protocols);
 	else
@@ -548,7 +548,7 @@ static void scic_sds_port_destroy_dummy_resources(struct scic_sds_port *sci_port
  * This method performs initialization of the supplied port. Initialization
  *    includes: - state machine initialization - member variable initialization
  *    - configuring the phy_mask
- * @this_port:
+ * @sci_port:
  * @transport_layer_registers:
  * @port_task_scheduler_registers:
  * @port_configuration_regsiter:
@@ -557,14 +557,14 @@ static void scic_sds_port_destroy_dummy_resources(struct scic_sds_port *sci_port
  * if the phy being added to the port
  */
 enum sci_status scic_sds_port_initialize(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	void __iomem *port_task_scheduler_registers,
 	void __iomem *port_configuration_regsiter,
 	void __iomem *viit_registers)
 {
-	this_port->port_task_scheduler_registers  = port_task_scheduler_registers;
-	this_port->port_pe_configuration_register = port_configuration_regsiter;
-	this_port->viit_registers                 = viit_registers;
+	sci_port->port_task_scheduler_registers  = port_task_scheduler_registers;
+	sci_port->port_pe_configuration_register = port_configuration_regsiter;
+	sci_port->viit_registers                 = viit_registers;
 
 	return SCI_SUCCESS;
 }
@@ -622,27 +622,27 @@ enum sci_status scic_port_hard_reset(
 /**
  * This method assigns the direct attached device ID for this port.
  *
- * @param[in] this_port The port for which the direct attached device id is to
+ * @param[in] sci_port The port for which the direct attached device id is to
  *       be assigned.
  * @param[in] device_id The direct attached device ID to assign to the port.
  *       This will be the RNi for the device
  */
 void scic_sds_port_setup_transports(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	u32 device_id)
 {
 	u8 index;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (this_port->active_phy_mask & (1 << index))
-			scic_sds_phy_setup_transport(this_port->phy_table[index], device_id);
+		if (sci_port->active_phy_mask & (1 << index))
+			scic_sds_phy_setup_transport(sci_port->phy_table[index], device_id);
 	}
 }
 
 /**
  *
- * @this_port: This is the port on which the phy should be enabled.
- * @the_phy: This is the specific phy which to enable.
+ * @sci_port: This is the port on which the phy should be enabled.
+ * @sci_phy: This is the specific phy which to enable.
  * @do_notify_user: This parameter specifies whether to inform the user (via
  *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
  *
@@ -696,8 +696,8 @@ void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
 
 /**
  *
- * @this_port: This is the port on which the phy should be disabled.
- * @the_phy: This is the specific phy which to disabled.
+ * @sci_port: This is the port on which the phy should be disabled.
+ * @sci_phy: This is the specific phy which to disabled.
  *
  * This function will disable the phy and report that the phy is not valid for
  * this port object. None
@@ -766,18 +766,18 @@ static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port
  * This method returns false if the port only has a single phy object assigned.
  *     If there are no phys or more than one phy then the method will return
  *    true.
- * @this_port: The port for which the wide port condition is to be checked.
+ * @sci_port: The port for which the wide port condition is to be checked.
  *
  * bool true Is returned if this is a wide ported port. false Is returned if
  * this is a narrow port.
  */
-static bool scic_sds_port_is_wide(struct scic_sds_port *this_port)
+static bool scic_sds_port_is_wide(struct scic_sds_port *sci_port)
 {
 	u32 index;
 	u32 phy_count = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (this_port->phy_table[index] != NULL) {
+		if (sci_port->phy_table[index] != NULL) {
 			phy_count++;
 		}
 	}
@@ -790,8 +790,8 @@ static bool scic_sds_port_is_wide(struct scic_sds_port *this_port)
  *    port wants the PHY to continue on to the link up state then the port
  *    layer must return true.  If the port object returns false the phy object
  *    must halt its attempt to go link up.
- * @this_port: The port associated with the phy object.
- * @the_phy: The phy object that is trying to go link up.
+ * @sci_port: The port associated with the phy object.
+ * @sci_phy: The phy object that is trying to go link up.
  *
  * true if the phy object can continue to the link up condition. true Is
  * returned if this phy can continue to the ready state. false Is returned if
@@ -800,19 +800,19 @@ static bool scic_sds_port_is_wide(struct scic_sds_port *this_port)
  * devices this could become an invalid port configuration.
  */
 bool scic_sds_port_link_detected(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
 {
 	struct sci_sas_identify_address_frame_protocols protocols;
 
-	scic_sds_phy_get_attached_phy_protocols(the_phy, &protocols);
+	scic_sds_phy_get_attached_phy_protocols(sci_phy, &protocols);
 
 	if (
-		(this_port->logical_port_index != SCIC_SDS_DUMMY_PORT)
+		(sci_port->logical_port_index != SCIC_SDS_DUMMY_PORT)
 		&& (protocols.u.bits.stp_target)
-		&& scic_sds_port_is_wide(this_port)
+		&& scic_sds_port_is_wide(sci_port)
 		) {
-		scic_sds_port_invalid_link_up(this_port, the_phy);
+		scic_sds_port_invalid_link_up(sci_port, sci_phy);
 
 		return false;
 	}
@@ -823,65 +823,65 @@ bool scic_sds_port_link_detected(
 /**
  * This method is the entry point for the phy to inform the port that it is now
  *    in a ready state
- * @this_port:
+ * @sci_port:
  *
  *
  */
 void scic_sds_port_link_up(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
 {
-	the_phy->is_in_link_training = false;
+	sci_phy->is_in_link_training = false;
 
-	this_port->state_handlers->link_up_handler(this_port, the_phy);
+	sci_port->state_handlers->link_up_handler(sci_port, sci_phy);
 }
 
 /**
  * This method is the entry point for the phy to inform the port that it is no
  *    longer in a ready state
- * @this_port:
+ * @sci_port:
  *
  *
  */
 void scic_sds_port_link_down(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
 {
-	this_port->state_handlers->link_down_handler(this_port, the_phy);
+	sci_port->state_handlers->link_down_handler(sci_port, sci_phy);
 }
 
 /**
  * This method is called to start an IO request on this port.
- * @this_port:
- * @the_device:
- * @the_io_request:
+ * @sci_port:
+ * @sci_dev:
+ * @sci_req:
  *
  * enum sci_status
  */
 enum sci_status scic_sds_port_start_io(
-	struct scic_sds_port *this_port,
-	struct scic_sds_remote_device *the_device,
-	struct scic_sds_request *the_io_request)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req)
 {
-	return this_port->state_handlers->start_io_handler(
-		       this_port, the_device, the_io_request);
+	return sci_port->state_handlers->start_io_handler(
+		       sci_port, sci_dev, sci_req);
 }
 
 /**
  * This method is called to complete an IO request to the port.
- * @this_port:
- * @the_device:
- * @the_io_request:
+ * @sci_port:
+ * @sci_dev:
+ * @sci_req:
  *
  * enum sci_status
  */
 enum sci_status scic_sds_port_complete_io(
-	struct scic_sds_port *this_port,
-	struct scic_sds_remote_device *the_device,
-	struct scic_sds_request *the_io_request)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req)
 {
-	return this_port->state_handlers->complete_io_handler(
-		       this_port, the_device, the_io_request);
+	return sci_port->state_handlers->complete_io_handler(
+		       sci_port, sci_dev, sci_req);
 }
 
 /**
@@ -945,40 +945,40 @@ static void scic_sds_port_timeout_handler(void *port)
  *
  *
  */
-static void scic_sds_port_update_viit_entry(struct scic_sds_port *this_port)
+static void scic_sds_port_update_viit_entry(struct scic_sds_port *sci_port)
 {
 	struct sci_sas_address sas_address;
 
-	scic_sds_port_get_sas_address(this_port, &sas_address);
+	scic_sds_port_get_sas_address(sci_port, &sas_address);
 
 	writel(sas_address.high,
-		&this_port->viit_registers->initiator_sas_address_hi);
+		&sci_port->viit_registers->initiator_sas_address_hi);
 	writel(sas_address.low,
-		&this_port->viit_registers->initiator_sas_address_lo);
+		&sci_port->viit_registers->initiator_sas_address_lo);
 
 	/* This value get cleared just in case its not already cleared */
-	writel(0, &this_port->viit_registers->reserved);
+	writel(0, &sci_port->viit_registers->reserved);
 
 	/* We are required to update the status register last */
 	writel(SCU_VIIT_ENTRY_ID_VIIT |
 	       SCU_VIIT_IPPT_INITIATOR |
-	       ((1 << this_port->physical_port_index) << SCU_VIIT_ENTRY_LPVIE_SHIFT) |
+	       ((1 << sci_port->physical_port_index) << SCU_VIIT_ENTRY_LPVIE_SHIFT) |
 	       SCU_VIIT_STATUS_ALL_VALID,
-	       &this_port->viit_registers->status);
+	       &sci_port->viit_registers->status);
 }
 
 /**
  * This method returns the maximum allowed speed for data transfers on this
  *    port.  This maximum allowed speed evaluates to the maximum speed of the
  *    slowest phy in the port.
- * @this_port: This parameter specifies the port for which to retrieve the
+ * @sci_port: This parameter specifies the port for which to retrieve the
  *    maximum allowed speed.
  *
  * This method returns the maximum negotiated speed of the slowest phy in the
  * port.
  */
 enum sas_linkrate scic_sds_port_get_max_allowed_speed(
-	struct scic_sds_port *this_port)
+	struct scic_sds_port *sci_port)
 {
 	u16 index;
 	enum sas_linkrate max_allowed_speed = SAS_LINK_RATE_6_0_GBPS;
@@ -988,10 +988,10 @@ enum sas_linkrate scic_sds_port_get_max_allowed_speed(
 	 * Loop through all of the phys in this port and find the phy with the
 	 * lowest maximum link rate. */
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		phy = this_port->phy_table[index];
+		phy = sci_port->phy_table[index];
 		if (
 			(phy != NULL)
-			&& (scic_sds_port_active_phy(this_port, phy) == true)
+			&& (scic_sds_port_active_phy(sci_port, phy) == true)
 			&& (phy->max_negotiated_speed < max_allowed_speed)
 			)
 			max_allowed_speed = phy->max_negotiated_speed;
@@ -1003,8 +1003,8 @@ enum sas_linkrate scic_sds_port_get_max_allowed_speed(
 
 /**
  * This method passes the event to core user.
- * @this_port: The port that a BCN happens.
- * @this_phy: The phy that receives BCN.
+ * @sci_port: The port that a BCN happens.
+ * @sci_phy: The phy that receives BCN.
  *
  */
 void scic_sds_port_broadcast_change_received(
@@ -1022,7 +1022,7 @@ void scic_sds_port_broadcast_change_received(
 /**
  * This API methhod enables the broadcast change notification from underneath
  *    hardware.
- * @this_port: The port that a BCN had been disabled from.
+ * @sci_port: The port that a BCN had been disabled from.
  *
  */
 void scic_port_enable_broadcast_change_notification(
@@ -1134,25 +1134,25 @@ static enum sci_status scic_sds_port_ready_substate_remove_phy_handler(
 
 /**
  *
- * @this_port: This is the struct scic_sds_port object that which has a phy that has
+ * @sci_port: This is the struct scic_sds_port object that which has a phy that has
  *    gone link up.
- * @the_phy: This is the struct scic_sds_phy object that has gone link up.
+ * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
  *
  * This method is the ready waiting substate link up handler for the
  * struct scic_sds_port object.  This methos will report the link up condition for
  * this port and will transition to the ready operational substate. none
  */
 static void scic_sds_port_ready_waiting_substate_link_up_handler(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
 {
 	/*
 	 * Since this is the first phy going link up for the port we can just enable
 	 * it and continue. */
-	scic_sds_port_activate_phy(this_port, the_phy, true);
+	scic_sds_port_activate_phy(sci_port, sci_phy, true);
 
 	sci_base_state_machine_change_state(
-		&this_port->ready_substate_machine,
+		&sci_port->ready_substate_machine,
 		SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
 		);
 }
@@ -1224,19 +1224,19 @@ sci_status scic_sds_port_ready_operational_substate_reset_handler(
 
 /**
  * scic_sds_port_ready_operational_substate_link_up_handler() -
- * @this_port: This is the struct scic_sds_port object that which has a phy that has
+ * @sci_port: This is the struct scic_sds_port object that which has a phy that has
  *    gone link up.
- * @the_phy: This is the struct scic_sds_phy object that has gone link up.
+ * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
  *
  * This method is the ready operational substate link up handler for the
  * struct scic_sds_port object. This function notifies the SCI User that the phy has
  * gone link up. none
  */
 static void scic_sds_port_ready_operational_substate_link_up_handler(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy)
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
 {
-	scic_sds_port_general_link_up_handler(this_port, the_phy, true);
+	scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
 }
 
 /**
@@ -1534,7 +1534,7 @@ scic_sds_port_ready_substate_handler_table[SCIC_SDS_PORT_READY_MAX_SUBSTATES] =
 
 /**
  *
- * @this_port: This is the struct scic_sds_port object to suspend.
+ * @sci_port: This is the struct scic_sds_port object to suspend.
  *
  * This method will susped the port task scheduler for this port object. none
  */
@@ -1602,7 +1602,7 @@ static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
 
 /**
  *
- * @this_port: This is the struct scic_sds_port object to resume.
+ * @sci_port: This is the struct scic_sds_port object to resume.
  *
  * This method will resume the port task scheduler for this port object. none
  */
@@ -1633,20 +1633,20 @@ scic_sds_port_resume_port_task_scheduler(struct scic_sds_port *port)
 static void scic_sds_port_ready_substate_waiting_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port = (struct scic_sds_port *)object;
+	struct scic_sds_port *sci_port = (struct scic_sds_port *)object;
 
 	scic_sds_port_set_ready_state_handlers(
-		this_port, SCIC_SDS_PORT_READY_SUBSTATE_WAITING
+		sci_port, SCIC_SDS_PORT_READY_SUBSTATE_WAITING
 		);
 
-	scic_sds_port_suspend_port_task_scheduler(this_port);
+	scic_sds_port_suspend_port_task_scheduler(sci_port);
 
-	this_port->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
+	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
 
-	if (this_port->active_phy_mask != 0) {
+	if (sci_port->active_phy_mask != 0) {
 		/* At least one of the phys on the port is ready */
 		sci_base_state_machine_change_state(
-			&this_port->ready_substate_machine,
+			&sci_port->ready_substate_machine,
 			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
 			);
 	}
@@ -1766,9 +1766,9 @@ static void scic_sds_port_ready_substate_configuring_enter(
 static void scic_sds_port_ready_substate_configuring_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port = (struct scic_sds_port *)object;
+	struct scic_sds_port *sci_port = (struct scic_sds_port *)object;
 
-	scic_sds_port_suspend_port_task_scheduler(this_port);
+	scic_sds_port_suspend_port_task_scheduler(sci_port);
 }
 
 /* --------------------------------------------------------------------------- */
@@ -2160,7 +2160,7 @@ scic_sds_port_state_handler_table[SCI_BASE_PORT_MAX_STATES] =
 
 /**
  *
- * @this_port: This is the port object which to suspend.
+ * @sci_port: This is the port object which to suspend.
  *
  * This method will enable the SCU Port Task Scheduler for this port object but
  * will leave the port task scheduler in a suspended state. none
@@ -2177,7 +2177,7 @@ scic_sds_port_enable_port_task_scheduler(struct scic_sds_port *port)
 
 /**
  *
- * @this_port: This is the port object which to resume.
+ * @sci_port: This is the port object which to resume.
  *
  * This method will disable the SCU port task scheduler for this port object.
  * none
@@ -2263,23 +2263,23 @@ static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci
 static void scic_sds_port_stopped_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port;
+	struct scic_sds_port *sci_port;
 
-	this_port = (struct scic_sds_port *)object;
+	sci_port = (struct scic_sds_port *)object;
 
 	scic_sds_port_set_base_state_handlers(
-		this_port, SCI_BASE_PORT_STATE_STOPPED
+		sci_port, SCI_BASE_PORT_STATE_STOPPED
 		);
 
 	if (
 		SCI_BASE_PORT_STATE_STOPPING
-		== this_port->state_machine.previous_state_id
+		== sci_port->state_machine.previous_state_id
 		) {
 		/*
 		 * If we enter this state becasuse of a request to stop
 		 * the port then we want to disable the hardwares port
 		 * task scheduler. */
-		scic_sds_port_disable_port_task_scheduler(this_port);
+		scic_sds_port_disable_port_task_scheduler(sci_port);
 	}
 }
 
@@ -2294,12 +2294,12 @@ static void scic_sds_port_stopped_state_enter(
 static void scic_sds_port_stopped_state_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port;
+	struct scic_sds_port *sci_port;
 
-	this_port = (struct scic_sds_port *)object;
+	sci_port = (struct scic_sds_port *)object;
 
 	/* Enable and suspend the port task scheduler */
-	scic_sds_port_enable_port_task_scheduler(this_port);
+	scic_sds_port_enable_port_task_scheduler(sci_port);
 }
 
 /**
@@ -2360,12 +2360,12 @@ static void scic_sds_port_ready_state_exit(struct sci_base_object *object)
 static void scic_sds_port_resetting_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port;
+	struct scic_sds_port *sci_port;
 
-	this_port = (struct scic_sds_port *)object;
+	sci_port = (struct scic_sds_port *)object;
 
 	scic_sds_port_set_base_state_handlers(
-		this_port, SCI_BASE_PORT_STATE_RESETTING
+		sci_port, SCI_BASE_PORT_STATE_RESETTING
 		);
 }
 
@@ -2397,12 +2397,12 @@ static inline void scic_sds_port_resetting_state_exit(
 static void scic_sds_port_stopping_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_port *this_port;
+	struct scic_sds_port *sci_port;
 
-	this_port = (struct scic_sds_port *)object;
+	sci_port = (struct scic_sds_port *)object;
 
 	scic_sds_port_set_base_state_handlers(
-		this_port, SCI_BASE_PORT_STATE_STOPPING
+		sci_port, SCI_BASE_PORT_STATE_STOPPING
 		);
 }
 
diff --git a/drivers/scsi/isci/core/scic_sds_port.h b/drivers/scsi/isci/core/scic_sds_port.h
index c7741e8..964e388 100644
--- a/drivers/scsi/isci/core/scic_sds_port.h
+++ b/drivers/scsi/isci/core/scic_sds_port.h
@@ -378,77 +378,77 @@ static inline void scic_sds_port_decrement_request_count(struct scic_sds_port *s
 	(((port)->active_phy_mask & (1 << (phy)->phy_index)) != 0)
 
 void scic_sds_port_construct(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	u8 port_index,
-	struct scic_sds_controller *owning_controller);
+	struct scic_sds_controller *scic);
 
 enum sci_status scic_sds_port_initialize(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	void __iomem *port_task_scheduler_registers,
 	void __iomem *port_configuration_regsiter,
 	void __iomem *viit_registers);
 
 enum sci_status scic_sds_port_add_phy(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy);
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
 
 enum sci_status scic_sds_port_remove_phy(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *the_phy);
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
 
 void scic_sds_port_setup_transports(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	u32 device_id);
 
 
 void scic_sds_port_deactivate_phy(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *phy,
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy,
 	bool do_notify_user);
 
 bool scic_sds_port_link_detected(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *phy);
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
 
 void scic_sds_port_link_up(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *phy);
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
 
 void scic_sds_port_link_down(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *phy);
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
 
 enum sci_status scic_sds_port_start_io(
-	struct scic_sds_port *this_port,
-	struct scic_sds_remote_device *the_device,
-	struct scic_sds_request *the_io_request);
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req);
 
 enum sci_status scic_sds_port_complete_io(
-	struct scic_sds_port *this_port,
-	struct scic_sds_remote_device *the_device,
-	struct scic_sds_request *the_io_request);
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req);
 
 enum sas_linkrate scic_sds_port_get_max_allowed_speed(
-	struct scic_sds_port *this_port);
+	struct scic_sds_port *sci_port);
 
 void scic_sds_port_broadcast_change_received(
-	struct scic_sds_port *this_port,
-	struct scic_sds_phy *this_phy);
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
 
 bool scic_sds_port_is_valid_phy_assignment(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	u32 phy_index);
 
 void scic_sds_port_get_sas_address(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	struct sci_sas_address *sas_address);
 
 void scic_sds_port_get_attached_sas_address(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	struct sci_sas_address *sas_address);
 
 void scic_sds_port_get_attached_protocols(
-	struct scic_sds_port *this_port,
+	struct scic_sds_port *sci_port,
 	struct sci_sas_identify_address_frame_protocols *protocols);
 
 #endif /* _SCIC_SDS_PORT_H_ */
diff --git a/drivers/scsi/isci/core/scic_sds_remote_device.c b/drivers/scsi/isci/core/scic_sds_remote_device.c
index 0976fae..fa7828d 100644
--- a/drivers/scsi/isci/core/scic_sds_remote_device.c
+++ b/drivers/scsi/isci/core/scic_sds_remote_device.c
@@ -149,17 +149,17 @@ enum sci_status scic_remote_device_da_construct(
 
 
 static void scic_sds_remote_device_get_info_from_smp_discover_response(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	struct smp_response_discover *discover_response)
 {
-	/* decode discover_response to set sas_address to this_device. */
-	this_device->device_address.high =
+	/* decode discover_response to set sas_address to sci_dev. */
+	sci_dev->device_address.high =
 		discover_response->attached_sas_address.high;
 
-	this_device->device_address.low =
+	sci_dev->device_address.low =
 		discover_response->attached_sas_address.low;
 
-	this_device->target_protocols.u.all = discover_response->protocols.u.all;
+	sci_dev->target_protocols.u.all = discover_response->protocols.u.all;
 }
 
 
@@ -168,15 +168,15 @@ enum sci_status scic_remote_device_ea_construct(
 	struct smp_response_discover *discover_response)
 {
 	enum sci_status status;
-	struct scic_sds_controller *the_controller;
+	struct scic_sds_controller *scic;
 
-	the_controller = scic_sds_port_get_controller(sci_dev->owning_port);
+	scic = scic_sds_port_get_controller(sci_dev->owning_port);
 
 	scic_sds_remote_device_get_info_from_smp_discover_response(
 		sci_dev, discover_response);
 
 	status = scic_sds_controller_allocate_remote_node_context(
-		the_controller, sci_dev, &sci_dev->rnc->remote_node_index);
+		scic, sci_dev, &sci_dev->rnc->remote_node_index);
 
 	if (status == SCI_SUCCESS) {
 		if (sci_dev->target_protocols.u.bits.attached_ssp_target) {
@@ -294,32 +294,32 @@ bool scic_remote_device_is_atapi(struct scic_sds_remote_device *sci_dev)
 
 /**
  *
- * @this_device: The remote device for which the suspend is being requested.
+ * @sci_dev: The remote device for which the suspend is being requested.
  *
  * This method invokes the remote device suspend state handler. enum sci_status
  */
 enum sci_status scic_sds_remote_device_suspend(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 suspend_type)
 {
-	return this_device->state_handlers->suspend_handler(this_device, suspend_type);
+	return sci_dev->state_handlers->suspend_handler(sci_dev, suspend_type);
 }
 
 /**
  *
- * @this_device: The remote device for which the resume is being requested.
+ * @sci_dev: The remote device for which the resume is being requested.
  *
  * This method invokes the remote device resume state handler. enum sci_status
  */
 enum sci_status scic_sds_remote_device_resume(
-	struct scic_sds_remote_device *this_device)
+	struct scic_sds_remote_device *sci_dev)
 {
-	return this_device->state_handlers->resume_handler(this_device);
+	return sci_dev->state_handlers->resume_handler(sci_dev);
 }
 
 /**
  *
- * @this_device: The remote device for which the event handling is being
+ * @sci_dev: The remote device for which the event handling is being
  *    requested.
  * @frame_index: This is the frame index that is being processed.
  *
@@ -327,31 +327,31 @@ enum sci_status scic_sds_remote_device_resume(
  * enum sci_status
  */
 enum sci_status scic_sds_remote_device_frame_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index)
 {
-	return this_device->state_handlers->frame_handler(this_device, frame_index);
+	return sci_dev->state_handlers->frame_handler(sci_dev, frame_index);
 }
 
 /**
  *
- * @this_device: The remote device for which the event handling is being
+ * @sci_dev: The remote device for which the event handling is being
  *    requested.
  * @event_code: This is the event code that is to be processed.
  *
  * This method invokes the remote device event handler. enum sci_status
  */
 enum sci_status scic_sds_remote_device_event_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 event_code)
 {
-	return this_device->state_handlers->event_handler(this_device, event_code);
+	return sci_dev->state_handlers->event_handler(sci_dev, event_code);
 }
 
 /**
  *
  * @controller: The controller that is starting the io request.
- * @this_device: The remote device for which the start io handling is being
+ * @sci_dev: The remote device for which the start io handling is being
  *    requested.
  * @io_request: The io request that is being started.
  *
@@ -359,17 +359,17 @@ enum sci_status scic_sds_remote_device_event_handler(
  */
 enum sci_status scic_sds_remote_device_start_io(
 	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *io_request)
 {
-	return this_device->state_handlers->start_io_handler(
-		       this_device, io_request);
+	return sci_dev->state_handlers->start_io_handler(
+		       sci_dev, io_request);
 }
 
 /**
  *
  * @controller: The controller that is completing the io request.
- * @this_device: The remote device for which the complete io handling is being
+ * @sci_dev: The remote device for which the complete io handling is being
  *    requested.
  * @io_request: The io request that is being completed.
  *
@@ -377,17 +377,17 @@ enum sci_status scic_sds_remote_device_start_io(
  */
 enum sci_status scic_sds_remote_device_complete_io(
 	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *io_request)
 {
-	return this_device->state_handlers->complete_io_handler(
-		       this_device, io_request);
+	return sci_dev->state_handlers->complete_io_handler(
+		       sci_dev, io_request);
 }
 
 /**
  *
  * @controller: The controller that is starting the task request.
- * @this_device: The remote device for which the start task handling is being
+ * @sci_dev: The remote device for which the start task handling is being
  *    requested.
  * @io_request: The task request that is being started.
  *
@@ -395,17 +395,17 @@ enum sci_status scic_sds_remote_device_complete_io(
  */
 enum sci_status scic_sds_remote_device_start_task(
 	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *io_request)
 {
-	return this_device->state_handlers->start_task_handler(
-		       this_device, io_request);
+	return sci_dev->state_handlers->start_task_handler(
+		       sci_dev, io_request);
 }
 
 /**
  *
  * @controller: The controller that is completing the task request.
- * @this_device: The remote device for which the complete task handling is
+ * @sci_dev: The remote device for which the complete task handling is
  *    being requested.
  * @io_request: The task request that is being completed.
  *
@@ -414,22 +414,22 @@ enum sci_status scic_sds_remote_device_start_task(
 
 /**
  *
- * @this_device:
+ * @sci_dev:
  * @request:
  *
  * This method takes the request and bulids an appropriate SCU context for the
  * request and then requests the controller to post the request. none
  */
 void scic_sds_remote_device_post_request(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 request)
 {
 	u32 context;
 
-	context = scic_sds_remote_device_build_command_context(this_device, request);
+	context = scic_sds_remote_device_build_command_context(sci_dev, request);
 
 	scic_sds_controller_post_request(
-		scic_sds_remote_device_get_controller(this_device),
+		scic_sds_remote_device_get_controller(sci_dev),
 		context
 		);
 }
@@ -437,22 +437,22 @@ void scic_sds_remote_device_post_request(
 #if !defined(DISABLE_ATAPI)
 /**
  *
- * @this_device: The device to be checked.
+ * @sci_dev: The device to be checked.
  *
  * This method check the signature fis of a stp device to decide whether a
  * device is atapi or not. true if a device is atapi device. False if a device
  * is not atapi.
  */
 bool scic_sds_remote_device_is_atapi(
-	struct scic_sds_remote_device *this_device)
+	struct scic_sds_remote_device *sci_dev)
 {
-	if (!this_device->target_protocols.u.bits.attached_stp_target)
+	if (!sci_dev->target_protocols.u.bits.attached_stp_target)
 		return false;
-	else if (this_device->is_direct_attached) {
+	else if (sci_dev->is_direct_attached) {
 		struct scic_sds_phy *phy;
 		struct scic_sata_phy_properties properties;
 		struct sata_fis_reg_d2h *signature_fis;
-		phy = scic_sds_port_get_a_connected_phy(this_device->owning_port);
+		phy = scic_sds_port_get_a_connected_phy(sci_dev->owning_port);
 		scic_sata_phy_get_properties(phy, &properties);
 
 		/* decode the signature fis. */
@@ -506,16 +506,16 @@ static void scic_sds_cb_remote_device_rnc_destruct_complete(
 static void scic_sds_remote_device_resume_complete_handler(
 	void *user_parameter)
 {
-	struct scic_sds_remote_device *this_device;
+	struct scic_sds_remote_device *sci_dev;
 
-	this_device = (struct scic_sds_remote_device *)user_parameter;
+	sci_dev = (struct scic_sds_remote_device *)user_parameter;
 
 	if (
-		sci_base_state_machine_get_state(&this_device->state_machine)
+		sci_base_state_machine_get_state(&sci_dev->state_machine)
 		!= SCI_BASE_REMOTE_DEVICE_STATE_READY
 		) {
 		sci_base_state_machine_change_state(
-			&this_device->state_machine,
+			&sci_dev->state_machine,
 			SCI_BASE_REMOTE_DEVICE_STATE_READY
 			);
 	}
@@ -532,16 +532,16 @@ static void scic_sds_remote_device_resume_complete_handler(
  * requests and task requests of all types. none
  */
 void scic_sds_remote_device_start_request(
-	struct scic_sds_remote_device *this_device,
-	struct scic_sds_request *the_request,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req,
 	enum sci_status status)
 {
 	/* We still have a fault in starting the io complete it on the port */
 	if (status == SCI_SUCCESS)
-		scic_sds_remote_device_increment_request_count(this_device);
+		scic_sds_remote_device_increment_request_count(sci_dev);
 	else{
-		this_device->owning_port->state_handlers->complete_io_handler(
-			this_device->owning_port, this_device, the_request
+		sci_dev->owning_port->state_handlers->complete_io_handler(
+			sci_dev->owning_port, sci_dev, sci_req
 			);
 	}
 }
@@ -576,7 +576,7 @@ void scic_sds_remote_device_continue_request(void *dev)
 /**
  * This method will terminate all of the IO requests in the controllers IO
  *    request table that were targeted for this device.
- * @this_device: This parameter specifies the remote device for which to
+ * @sci_dev: This parameter specifies the remote device for which to
  *    attempt to terminate all requests.
  *
  * This method returns an indication as to whether all requests were
@@ -584,24 +584,24 @@ void scic_sds_remote_device_continue_request(void *dev)
  * this method will return the failure.
  */
 static enum sci_status scic_sds_remote_device_terminate_requests(
-	struct scic_sds_remote_device *this_device)
+	struct scic_sds_remote_device *sci_dev)
 {
 	enum sci_status status           = SCI_SUCCESS;
 	enum sci_status terminate_status = SCI_SUCCESS;
-	struct scic_sds_request *the_request;
+	struct scic_sds_request *sci_req;
 	u32 index;
-	u32 request_count    = this_device->started_request_count;
+	u32 request_count    = sci_dev->started_request_count;
 
 	for (index = 0;
 	     (index < SCI_MAX_IO_REQUESTS) && (request_count > 0);
 	     index++) {
-		the_request = this_device->owning_port->owning_controller->io_request_table[index];
+		sci_req = sci_dev->owning_port->owning_controller->io_request_table[index];
 
-		if ((the_request != NULL) && (the_request->target_device == this_device)) {
+		if ((sci_req != NULL) && (sci_req->target_device == sci_dev)) {
 			terminate_status = scic_controller_terminate_request(
-				this_device->owning_port->owning_controller,
-				this_device,
-				the_request
+				sci_dev->owning_port->owning_controller,
+				sci_dev,
+				sci_req
 				);
 
 			if (terminate_status != SCI_SUCCESS)
@@ -684,7 +684,7 @@ enum sci_status scic_sds_remote_device_default_resume_handler(
  * returns a failure. enum sci_status SCI_FAILURE_INVALID_STATE
  */
 static enum sci_status  scic_sds_remote_device_core_event_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 event_code,
 	bool is_ready_state)
 {
@@ -694,7 +694,7 @@ static enum sci_status  scic_sds_remote_device_core_event_handler(
 	case SCU_EVENT_TYPE_RNC_OPS_MISC:
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
-		status = scic_sds_remote_node_context_event_handler(this_device->rnc, event_code);
+		status = scic_sds_remote_node_context_event_handler(sci_dev->rnc, event_code);
 		break;
 	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
 
@@ -702,13 +702,13 @@ static enum sci_status  scic_sds_remote_device_core_event_handler(
 			status = SCI_SUCCESS;
 
 			/* Suspend the associated RNC */
-			scic_sds_remote_node_context_suspend(this_device->rnc,
+			scic_sds_remote_node_context_suspend(sci_dev->rnc,
 							      SCI_SOFTWARE_SUSPENSION,
 							      NULL, NULL);
 
-			dev_dbg(scirdev_to_dev(this_device),
+			dev_dbg(scirdev_to_dev(sci_dev),
 				"%s: device: %p event code: %x: %s\n",
-				__func__, this_device, event_code,
+				__func__, sci_dev, event_code,
 				(is_ready_state)
 				? "I_T_Nexus_Timeout event"
 				: "I_T_Nexus_Timeout event in wrong state");
@@ -718,9 +718,9 @@ static enum sci_status  scic_sds_remote_device_core_event_handler(
 	/* Else, fall through and treat as unhandled... */
 
 	default:
-		dev_dbg(scirdev_to_dev(this_device),
+		dev_dbg(scirdev_to_dev(sci_dev),
 			"%s: device: %p event code: %x: %s\n",
-			__func__, this_device, event_code,
+			__func__, sci_dev, event_code,
 			(is_ready_state)
 			? "unexpected event"
 			: "unexpected event in wrong state");
@@ -742,10 +742,10 @@ static enum sci_status  scic_sds_remote_device_core_event_handler(
  * returns a failure. enum sci_status SCI_FAILURE_INVALID_STATE
  */
 static enum sci_status  scic_sds_remote_device_default_event_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 event_code)
 {
-	return scic_sds_remote_device_core_event_handler(this_device,
+	return scic_sds_remote_device_core_event_handler(sci_dev,
 							  event_code,
 							  false);
 }
@@ -762,20 +762,20 @@ static enum sci_status  scic_sds_remote_device_default_event_handler(
  * SCI_FAILURE_INVALID_STATE
  */
 enum sci_status scic_sds_remote_device_default_frame_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index)
 {
-	dev_warn(scirdev_to_dev(this_device),
+	dev_warn(scirdev_to_dev(sci_dev),
 		 "%s: SCIC Remote Device requested to handle frame %x "
 		 "while in wrong state %d\n",
 		 __func__,
 		 frame_index,
 		 sci_base_state_machine_get_state(
-			 &this_device->state_machine));
+			 &sci_dev->state_machine));
 
 	/* Return the frame back to the controller */
 	scic_sds_controller_release_frame(
-		scic_sds_remote_device_get_controller(this_device), frame_index
+		scic_sds_remote_device_get_controller(sci_dev), frame_index
 		);
 
 	return SCI_FAILURE_INVALID_STATE;
@@ -815,7 +815,7 @@ enum sci_status scic_sds_remote_device_default_continue_request_handler(
  * unsolicited frame to that object. enum sci_status SCI_FAILURE_INVALID_STATE
  */
 enum sci_status scic_sds_remote_device_general_frame_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index)
 {
 	enum sci_status result;
@@ -823,22 +823,22 @@ enum sci_status scic_sds_remote_device_general_frame_handler(
 	struct scic_sds_request *io_request;
 
 	result = scic_sds_unsolicited_frame_control_get_header(
-		&(scic_sds_remote_device_get_controller(this_device)->uf_control),
+		&(scic_sds_remote_device_get_controller(sci_dev)->uf_control),
 		frame_index,
 		(void **)&frame_header
 		);
 
 	if (SCI_SUCCESS == result) {
 		io_request = scic_sds_controller_get_io_request_from_tag(
-			scic_sds_remote_device_get_controller(this_device), frame_header->tag);
+			scic_sds_remote_device_get_controller(sci_dev), frame_header->tag);
 
 		if ((io_request == NULL)
-		    || (io_request->target_device != this_device)) {
+		    || (io_request->target_device != sci_dev)) {
 			/*
 			 * We could not map this tag to a valid IO request
 			 * Just toss the frame and continue */
 			scic_sds_controller_release_frame(
-				scic_sds_remote_device_get_controller(this_device), frame_index
+				scic_sds_remote_device_get_controller(sci_dev), frame_index
 				);
 		} else {
 			/* The IO request is now in charge of releasing the frame */
@@ -852,17 +852,17 @@ enum sci_status scic_sds_remote_device_general_frame_handler(
 
 /**
  *
- * @[in]: this_device This is the device object that is receiving the event.
+ * @[in]: sci_dev This is the device object that is receiving the event.
  * @[in]: event_code The event code to process.
  *
  * This is a common method for handling events reported to the remote device
  * from the controller object. enum sci_status
  */
 enum sci_status scic_sds_remote_device_general_event_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 event_code)
 {
-	return scic_sds_remote_device_core_event_handler(this_device,
+	return scic_sds_remote_device_core_event_handler(sci_dev,
 							  event_code,
 							  true);
 }
@@ -1093,7 +1093,7 @@ static enum sci_status scic_sds_remote_device_ready_state_complete_request_handl
 
 /**
  *
- * @this_device: The struct scic_sds_remote_device which is cast into a
+ * @sci_dev: The struct scic_sds_remote_device which is cast into a
  *    struct scic_sds_remote_device.
  *
  * This method will stop a struct scic_sds_remote_device that is already in the
@@ -1536,10 +1536,10 @@ static void scic_sds_remote_device_ready_state_exit(
 static void scic_sds_remote_device_stopping_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 
 	SET_STATE_HANDLER(
-		this_device,
+		sci_dev,
 		scic_sds_remote_device_state_handler_table,
 		SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
 		);
@@ -1556,10 +1556,10 @@ static void scic_sds_remote_device_stopping_state_enter(
 static void scic_sds_remote_device_failed_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 
 	SET_STATE_HANDLER(
-		this_device,
+		sci_dev,
 		scic_sds_remote_device_state_handler_table,
 		SCI_BASE_REMOTE_DEVICE_STATE_FAILED
 		);
@@ -1576,16 +1576,16 @@ static void scic_sds_remote_device_failed_state_enter(
 static void scic_sds_remote_device_resetting_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 
 	SET_STATE_HANDLER(
-		this_device,
+		sci_dev,
 		scic_sds_remote_device_state_handler_table,
 		SCI_BASE_REMOTE_DEVICE_STATE_RESETTING
 		);
 
 	scic_sds_remote_node_context_suspend(
-		this_device->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
+		sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
 }
 
 /**
@@ -1599,9 +1599,9 @@ static void scic_sds_remote_device_resetting_state_enter(
 static void scic_sds_remote_device_resetting_state_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 
-	scic_sds_remote_node_context_resume(this_device->rnc, NULL, NULL);
+	scic_sds_remote_node_context_resume(sci_dev->rnc, NULL, NULL);
 }
 
 /**
@@ -1615,10 +1615,10 @@ static void scic_sds_remote_device_resetting_state_exit(
 static void scic_sds_remote_device_final_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_remote_device *this_device = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 
 	SET_STATE_HANDLER(
-		this_device,
+		sci_dev,
 		scic_sds_remote_device_state_handler_table,
 		SCI_BASE_REMOTE_DEVICE_STATE_FINAL
 		);
diff --git a/drivers/scsi/isci/core/scic_sds_remote_device.h b/drivers/scsi/isci/core/scic_sds_remote_device.h
index ebb0ac8..5d3df92 100644
--- a/drivers/scsi/isci/core/scic_sds_remote_device.h
+++ b/drivers/scsi/isci/core/scic_sds_remote_device.h
@@ -350,25 +350,25 @@ typedef enum sci_status (*scic_sds_remote_device_high_priority_request_complete_
 	enum sci_io_status);
 
 typedef enum sci_status (*scic_sds_remote_device_handler_t)(
-	struct scic_sds_remote_device *this_device);
+	struct scic_sds_remote_device *sci_dev);
 
 typedef enum sci_status (*scic_sds_remote_device_suspend_handler_t)(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 suspend_type);
 
 typedef enum sci_status (*scic_sds_remote_device_resume_handler_t)(
-	struct scic_sds_remote_device *this_device);
+	struct scic_sds_remote_device *sci_dev);
 
 typedef enum sci_status (*scic_sds_remote_device_frame_handler_t)(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index);
 
 typedef enum sci_status (*scic_sds_remote_device_event_handler_t)(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 event_code);
 
 typedef void (*scic_sds_remote_device_ready_not_ready_handler_t)(
-	struct scic_sds_remote_device *this_device);
+	struct scic_sds_remote_device *sci_dev);
 
 /**
  * struct scic_sds_remote_device_state_handler - This structure conains the
@@ -461,8 +461,8 @@ extern const struct sci_base_state scic_sds_smp_remote_device_ready_substate_tab
  *
  * This macro incrments the request count for this device
  */
-#define scic_sds_remote_device_increment_request_count(this_device) \
-	((this_device)->started_request_count++)
+#define scic_sds_remote_device_increment_request_count(sci_dev) \
+	((sci_dev)->started_request_count++)
 
 /**
  * scic_sds_remote_device_decrement_request_count() -
@@ -470,33 +470,33 @@ extern const struct sci_base_state scic_sds_smp_remote_device_ready_substate_tab
  * This macro decrements the request count for this device.  This count will
  * never decrment past 0.
  */
-#define scic_sds_remote_device_decrement_request_count(this_device) \
-	((this_device)->started_request_count > 0 ? \
-	 (this_device)->started_request_count-- : 0)
+#define scic_sds_remote_device_decrement_request_count(sci_dev) \
+	((sci_dev)->started_request_count > 0 ? \
+	 (sci_dev)->started_request_count-- : 0)
 
 /**
  * scic_sds_remote_device_get_request_count() -
  *
  * This is a helper macro to return the current device request count.
  */
-#define scic_sds_remote_device_get_request_count(this_device) \
-	((this_device)->started_request_count)
+#define scic_sds_remote_device_get_request_count(sci_dev) \
+	((sci_dev)->started_request_count)
 
 /**
  * scic_sds_remote_device_get_port() -
  *
  * This macro returns the owning port of this remote device obejct.
  */
-#define scic_sds_remote_device_get_port(this_device) \
-	((this_device)->owning_port)
+#define scic_sds_remote_device_get_port(sci_dev) \
+	((sci_dev)->owning_port)
 
 /**
  * scic_sds_remote_device_get_controller() -
  *
  * This macro returns the controller object that contains this device object
  */
-#define scic_sds_remote_device_get_controller(this_device) \
-	scic_sds_port_get_controller(scic_sds_remote_device_get_port(this_device))
+#define scic_sds_remote_device_get_controller(sci_dev) \
+	scic_sds_port_get_controller(scic_sds_remote_device_get_port(sci_dev))
 
 /**
  * scic_sds_remote_device_set_state_handlers() -
@@ -504,26 +504,26 @@ extern const struct sci_base_state scic_sds_smp_remote_device_ready_substate_tab
  * This macro sets the remote device state handlers pointer and is set on entry
  * to each device state.
  */
-#define scic_sds_remote_device_set_state_handlers(this_device, handlers) \
-	((this_device)->state_handlers = (handlers))
+#define scic_sds_remote_device_set_state_handlers(sci_dev, handlers) \
+	((sci_dev)->state_handlers = (handlers))
 
 /**
  * scic_sds_remote_device_get_port() -
  *
  * This macro returns the owning port of this device
  */
-#define scic_sds_remote_device_get_port(this_device) \
-	((this_device)->owning_port)
+#define scic_sds_remote_device_get_port(sci_dev) \
+	((sci_dev)->owning_port)
 
 /**
  * scic_sds_remote_device_get_sequence() -
  *
  * This macro returns the remote device sequence value
  */
-#define scic_sds_remote_device_get_sequence(this_device) \
+#define scic_sds_remote_device_get_sequence(sci_dev) \
 	(\
-		scic_sds_remote_device_get_controller(this_device)-> \
-		remote_device_sequence[(this_device)->rnc->remote_node_index] \
+		scic_sds_remote_device_get_controller(sci_dev)-> \
+		remote_device_sequence[(sci_dev)->rnc->remote_node_index] \
 	)
 
 /**
@@ -531,11 +531,11 @@ extern const struct sci_base_state scic_sds_smp_remote_device_ready_substate_tab
  *
  * This macro returns the controllers protocol engine group
  */
-#define scic_sds_remote_device_get_controller_peg(this_device) \
+#define scic_sds_remote_device_get_controller_peg(sci_dev) \
 	(\
 		scic_sds_controller_get_protocol_engine_group(\
 			scic_sds_port_get_controller(\
-				scic_sds_remote_device_get_port(this_device) \
+				scic_sds_remote_device_get_port(sci_dev) \
 				) \
 			) \
 	)
@@ -545,16 +545,16 @@ extern const struct sci_base_state scic_sds_smp_remote_device_ready_substate_tab
  *
  * This macro returns the port index for the devices owning port
  */
-#define scic_sds_remote_device_get_port_index(this_device) \
-	(scic_sds_port_get_index(scic_sds_remote_device_get_port(this_device)))
+#define scic_sds_remote_device_get_port_index(sci_dev) \
+	(scic_sds_port_get_index(scic_sds_remote_device_get_port(sci_dev)))
 
 /**
  * scic_sds_remote_device_get_index() -
  *
  * This macro returns the remote node index for this device object
  */
-#define scic_sds_remote_device_get_index(this_device) \
-	((this_device)->rnc->remote_node_index)
+#define scic_sds_remote_device_get_index(sci_dev) \
+	((sci_dev)->rnc->remote_node_index)
 
 /**
  * scic_sds_remote_device_build_command_context() -
@@ -579,61 +579,61 @@ extern const struct sci_base_state scic_sds_smp_remote_device_ready_substate_tab
 	((device)->working_request = (request))
 
 enum sci_status scic_sds_remote_device_frame_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index);
 
 enum sci_status scic_sds_remote_device_event_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 event_code);
 
 enum sci_status scic_sds_remote_device_start_io(
 	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *io_request);
 
 enum sci_status scic_sds_remote_device_complete_io(
 	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *io_request);
 
 enum sci_status scic_sds_remote_device_resume(
-	struct scic_sds_remote_device *this_device);
+	struct scic_sds_remote_device *sci_dev);
 
 enum sci_status scic_sds_remote_device_suspend(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 suspend_type);
 
 enum sci_status scic_sds_remote_device_start_task(
 	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *io_request);
 
 void scic_sds_remote_device_post_request(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 request);
 
 #if !defined(DISABLE_ATAPI)
 bool scic_sds_remote_device_is_atapi(
-	struct scic_sds_remote_device *this_device);
+	struct scic_sds_remote_device *sci_dev);
 #else /* !defined(DISABLE_ATAPI) */
-#define scic_sds_remote_device_is_atapi(this_device) false
+#define scic_sds_remote_device_is_atapi(sci_dev) false
 #endif /* !defined(DISABLE_ATAPI) */
 
 void scic_sds_remote_device_start_request(
-	struct scic_sds_remote_device *this_device,
-	struct scic_sds_request *the_request,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req,
 	enum sci_status status);
 
 void scic_sds_remote_device_continue_request(void *sci_dev);
 
 enum sci_status scic_sds_remote_device_default_start_handler(
-	struct scic_sds_remote_device *this_device);
+	struct scic_sds_remote_device *sci_dev);
 
 enum sci_status scic_sds_remote_device_default_fail_handler(
-	struct scic_sds_remote_device *this_device);
+	struct scic_sds_remote_device *sci_dev);
 
 enum sci_status scic_sds_remote_device_default_destruct_handler(
-	struct scic_sds_remote_device *this_device);
+	struct scic_sds_remote_device *sci_dev);
 
 enum sci_status scic_sds_remote_device_default_reset_handler(
 	struct scic_sds_remote_device *device);
@@ -654,15 +654,15 @@ enum sci_status scic_sds_remote_device_default_continue_request_handler(
 	struct scic_sds_request *request);
 
 enum sci_status scic_sds_remote_device_default_suspend_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 suspend_type);
 
 enum sci_status scic_sds_remote_device_default_resume_handler(
-	struct scic_sds_remote_device *this_device);
+	struct scic_sds_remote_device *sci_dev);
 
 
 enum sci_status scic_sds_remote_device_default_frame_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index);
 
 enum sci_status scic_sds_remote_device_ready_state_stop_handler(
@@ -672,14 +672,14 @@ enum sci_status scic_sds_remote_device_ready_state_reset_handler(
 	struct scic_sds_remote_device *device);
 
 enum sci_status scic_sds_remote_device_general_frame_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index);
 
 enum sci_status scic_sds_remote_device_general_event_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 event_code);
 
 enum sci_status scic_sds_ssp_remote_device_ready_suspended_substate_resume_handler(
-	struct scic_sds_remote_device *this_device);
+	struct scic_sds_remote_device *sci_dev);
 
 #endif /* _SCIC_SDS_REMOTE_DEVICE_H_ */
diff --git a/drivers/scsi/isci/core/scic_sds_remote_node_context.c b/drivers/scsi/isci/core/scic_sds_remote_node_context.c
index 81e4ab3..e329296 100644
--- a/drivers/scsi/isci/core/scic_sds_remote_node_context.c
+++ b/drivers/scsi/isci/core/scic_sds_remote_node_context.c
@@ -67,7 +67,7 @@
 
 /**
  *
- * @this_rnc: The RNC for which the is posted request is being made.
+ * @sci_rnc: The RNC for which the is posted request is being made.
  *
  * This method will return true if the RNC is not in the initial state.  In all
  * other states the RNC is considered active and this will return true. The
@@ -79,16 +79,16 @@
 
 /**
  *
- * @this_rnc: The state of the remote node context object to check.
+ * @sci_rnc: The state of the remote node context object to check.
  *
  * This method will return true if the remote node context is in a READY state
  * otherwise it will return false bool true if the remote node context is in
  * the ready state. false if the remote node context is not in the ready state.
  */
 bool scic_sds_remote_node_context_is_ready(
-	struct scic_sds_remote_node_context *this_rnc)
+	struct scic_sds_remote_node_context *sci_rnc)
 {
-	u32 current_state = sci_base_state_machine_get_state(&this_rnc->state_machine);
+	u32 current_state = sci_base_state_machine_get_state(&sci_rnc->state_machine);
 
 	if (current_state == SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE) {
 		return true;
@@ -99,36 +99,36 @@ bool scic_sds_remote_node_context_is_ready(
 
 /**
  *
- * @this_device: The remote device to use to construct the RNC buffer.
+ * @sci_dev: The remote device to use to construct the RNC buffer.
  * @rnc: The buffer into which the remote device data will be copied.
  *
  * This method will construct the RNC buffer for this remote device object. none
  */
 static void scic_sds_remote_node_context_construct_buffer(
-	struct scic_sds_remote_node_context *this_rnc)
+	struct scic_sds_remote_node_context *sci_rnc)
 {
 	union scu_remote_node_context *rnc;
-	struct scic_sds_controller *the_controller;
+	struct scic_sds_controller *scic;
 
-	the_controller = scic_sds_remote_device_get_controller(this_rnc->device);
+	scic = scic_sds_remote_device_get_controller(sci_rnc->device);
 
 	rnc = scic_sds_controller_get_remote_node_context_buffer(
-		the_controller, this_rnc->remote_node_index);
+		scic, sci_rnc->remote_node_index);
 
 	memset(
 		rnc,
 		0x00,
 		sizeof(union scu_remote_node_context)
-		* scic_sds_remote_device_node_count(this_rnc->device)
+		* scic_sds_remote_device_node_count(sci_rnc->device)
 		);
 
-	rnc->ssp.remote_node_index = this_rnc->remote_node_index;
-	rnc->ssp.remote_node_port_width = this_rnc->device->device_port_width;
+	rnc->ssp.remote_node_index = sci_rnc->remote_node_index;
+	rnc->ssp.remote_node_port_width = sci_rnc->device->device_port_width;
 	rnc->ssp.logical_port_index =
-		scic_sds_remote_device_get_port_index(this_rnc->device);
+		scic_sds_remote_device_get_port_index(sci_rnc->device);
 
-	rnc->ssp.remote_sas_address_hi = SCIC_SWAP_DWORD(this_rnc->device->device_address.high);
-	rnc->ssp.remote_sas_address_lo = SCIC_SWAP_DWORD(this_rnc->device->device_address.low);
+	rnc->ssp.remote_sas_address_hi = SCIC_SWAP_DWORD(sci_rnc->device->device_address.high);
+	rnc->ssp.remote_sas_address_lo = SCIC_SWAP_DWORD(sci_rnc->device->device_address.low);
 
 	rnc->ssp.nexus_loss_timer_enable = true;
 	rnc->ssp.check_bit               = false;
@@ -140,24 +140,24 @@ static void scic_sds_remote_node_context_construct_buffer(
 
 
 	if (
-		this_rnc->device->target_protocols.u.bits.attached_sata_device
-		|| this_rnc->device->target_protocols.u.bits.attached_stp_target
+		sci_rnc->device->target_protocols.u.bits.attached_sata_device
+		|| sci_rnc->device->target_protocols.u.bits.attached_stp_target
 		) {
 		rnc->ssp.connection_occupancy_timeout =
-			the_controller->user_parameters.sds1.stp_max_occupancy_timeout;
+			scic->user_parameters.sds1.stp_max_occupancy_timeout;
 		rnc->ssp.connection_inactivity_timeout =
-			the_controller->user_parameters.sds1.stp_inactivity_timeout;
+			scic->user_parameters.sds1.stp_inactivity_timeout;
 	} else {
 		rnc->ssp.connection_occupancy_timeout  =
-			the_controller->user_parameters.sds1.ssp_max_occupancy_timeout;
+			scic->user_parameters.sds1.ssp_max_occupancy_timeout;
 		rnc->ssp.connection_inactivity_timeout =
-			the_controller->user_parameters.sds1.ssp_inactivity_timeout;
+			scic->user_parameters.sds1.ssp_inactivity_timeout;
 	}
 
 	rnc->ssp.initial_arbitration_wait_time = 0;
 
 	/* Open Address Frame Parameters */
-	rnc->ssp.oaf_connection_rate = this_rnc->device->connection_rate;
+	rnc->ssp.oaf_connection_rate = sci_rnc->device->connection_rate;
 	rnc->ssp.oaf_features = 0;
 	rnc->ssp.oaf_source_zone_group = 0;
 	rnc->ssp.oaf_more_compatibility_features = 0;
@@ -165,8 +165,8 @@ static void scic_sds_remote_node_context_construct_buffer(
 
 /**
  *
- * @this_rnc:
- * @the_callback:
+ * @sci_rnc:
+ * @callback:
  * @callback_parameter:
  *
  * This method will setup the remote node context object so it will transition
@@ -174,52 +174,52 @@ static void scic_sds_remote_node_context_construct_buffer(
  * transition to its final state then this function does nothing. none
  */
 static void scic_sds_remote_node_context_setup_to_resume(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
-	if (this_rnc->destination_state != SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
-		this_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY;
-		this_rnc->user_callback     = the_callback;
-		this_rnc->user_cookie       = callback_parameter;
+	if (sci_rnc->destination_state != SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
+		sci_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY;
+		sci_rnc->user_callback     = callback;
+		sci_rnc->user_cookie       = callback_parameter;
 	}
 }
 
 /**
  *
- * @this_rnc:
- * @the_callback:
+ * @sci_rnc:
+ * @callback:
  * @callback_parameter:
  *
  * This method will setup the remote node context object so it will transistion
  * to its final state. none
  */
 static void scic_sds_remote_node_context_setup_to_destory(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
-	this_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL;
-	this_rnc->user_callback     = the_callback;
-	this_rnc->user_cookie       = callback_parameter;
+	sci_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL;
+	sci_rnc->user_callback     = callback;
+	sci_rnc->user_cookie       = callback_parameter;
 }
 
 /**
  *
- * @this_rnc:
- * @the_callback:
+ * @sci_rnc:
+ * @callback:
  *
  * This method will continue to resume a remote node context.  This is used in
  * the states where a resume is requested while a resume is in progress.
  */
 static enum sci_status scic_sds_remote_node_context_continue_to_resume_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
-	if (this_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY) {
-		this_rnc->user_callback = the_callback;
-		this_rnc->user_cookie   = callback_parameter;
+	if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY) {
+		sci_rnc->user_callback = callback;
+		sci_rnc->user_cookie   = callback_parameter;
 
 		return SCI_SUCCESS;
 	}
@@ -230,16 +230,16 @@ static enum sci_status scic_sds_remote_node_context_continue_to_resume_handler(
 /* --------------------------------------------------------------------------- */
 
 static enum sci_status scic_sds_remote_node_context_default_destruct_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
-	dev_warn(scirdev_to_dev(this_rnc->device),
+	dev_warn(scirdev_to_dev(sci_rnc->device),
 		 "%s: SCIC Remote Node Context 0x%p requested to stop while "
 		 "in unexpected state %d\n",
 		 __func__,
-		 this_rnc,
-		 sci_base_state_machine_get_state(&this_rnc->state_machine));
+		 sci_rnc,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
 
 	/*
 	 * We have decided that the destruct request on the remote node context can not fail
@@ -248,101 +248,101 @@ static enum sci_status scic_sds_remote_node_context_default_destruct_handler(
 }
 
 static enum sci_status scic_sds_remote_node_context_default_suspend_handler(
-	struct scic_sds_remote_node_context *this_rnc,
+	struct scic_sds_remote_node_context *sci_rnc,
 	u32 suspend_type,
-	scics_sds_remote_node_context_callback the_callback,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
-	dev_warn(scirdev_to_dev(this_rnc->device),
+	dev_warn(scirdev_to_dev(sci_rnc->device),
 		 "%s: SCIC Remote Node Context 0x%p requested to suspend "
 		 "while in wrong state %d\n",
 		 __func__,
-		 this_rnc,
-		 sci_base_state_machine_get_state(&this_rnc->state_machine));
+		 sci_rnc,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
 
 	return SCI_FAILURE_INVALID_STATE;
 }
 
 static enum sci_status scic_sds_remote_node_context_default_resume_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
-	dev_warn(scirdev_to_dev(this_rnc->device),
+	dev_warn(scirdev_to_dev(sci_rnc->device),
 		 "%s: SCIC Remote Node Context 0x%p requested to resume "
 		 "while in wrong state %d\n",
 		 __func__,
-		 this_rnc,
-		 sci_base_state_machine_get_state(&this_rnc->state_machine));
+		 sci_rnc,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
 
 	return SCI_FAILURE_INVALID_STATE;
 }
 
 static enum sci_status scic_sds_remote_node_context_default_start_io_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	struct scic_sds_request *the_request)
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
 {
-	dev_warn(scirdev_to_dev(this_rnc->device),
+	dev_warn(scirdev_to_dev(sci_rnc->device),
 		 "%s: SCIC Remote Node Context 0x%p requested to start io "
 		 "0x%p while in wrong state %d\n",
 		 __func__,
-		 this_rnc,
-		 the_request,
-		 sci_base_state_machine_get_state(&this_rnc->state_machine));
+		 sci_rnc,
+		 sci_req,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
 
 	return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 }
 
 static enum sci_status scic_sds_remote_node_context_default_start_task_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	struct scic_sds_request *the_request)
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
 {
-	dev_warn(scirdev_to_dev(this_rnc->device),
+	dev_warn(scirdev_to_dev(sci_rnc->device),
 		 "%s: SCIC Remote Node Context 0x%p requested to start "
 		 "task 0x%p while in wrong state %d\n",
 		 __func__,
-		 this_rnc,
-		 the_request,
-		 sci_base_state_machine_get_state(&this_rnc->state_machine));
+		 sci_rnc,
+		 sci_req,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
 
 	return SCI_FAILURE;
 }
 
 static enum sci_status scic_sds_remote_node_context_default_event_handler(
-	struct scic_sds_remote_node_context *this_rnc,
+	struct scic_sds_remote_node_context *sci_rnc,
 	u32 event_code)
 {
-	dev_warn(scirdev_to_dev(this_rnc->device),
+	dev_warn(scirdev_to_dev(sci_rnc->device),
 		 "%s: SCIC Remote Node Context 0x%p requested to process "
 		 "event 0x%x while in wrong state %d\n",
 		 __func__,
-		 this_rnc,
+		 sci_rnc,
 		 event_code,
-		 sci_base_state_machine_get_state(&this_rnc->state_machine));
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
 
 	return SCI_FAILURE_INVALID_STATE;
 }
 
 /**
  *
- * @this_rnc: The rnc for which the task request is targeted.
- * @the_request: The request which is going to be started.
+ * @sci_rnc: The rnc for which the task request is targeted.
+ * @sci_req: The request which is going to be started.
  *
  * This method determines if the task request can be started by the SCU
  * hardware. When the RNC is in the ready state any task can be started.
  * enum sci_status SCI_SUCCESS
  */
 static enum sci_status scic_sds_remote_node_context_success_start_task_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	struct scic_sds_request *the_request)
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
 {
 	return SCI_SUCCESS;
 }
 
 /**
  *
- * @this_rnc:
- * @the_callback:
+ * @sci_rnc:
+ * @callback:
  * @callback_parameter:
  *
  * This method handles destruct calls from the various state handlers.  The
@@ -351,16 +351,16 @@ static enum sci_status scic_sds_remote_node_context_success_start_task_handler(
  * callback. enum sci_status
  */
 static enum sci_status scic_sds_remote_node_context_general_destruct_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
 	scic_sds_remote_node_context_setup_to_destory(
-		this_rnc, the_callback, callback_parameter
+		sci_rnc, callback, callback_parameter
 		);
 
 	sci_base_state_machine_change_state(
-		&this_rnc->state_machine,
+		&sci_rnc->state_machine,
 		SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
 		);
 
@@ -370,19 +370,19 @@ static enum sci_status scic_sds_remote_node_context_general_destruct_handler(
 /* --------------------------------------------------------------------------- */
 
 static enum sci_status scic_sds_remote_node_context_initial_state_resume_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
-	if (this_rnc->remote_node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
+	if (sci_rnc->remote_node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
 		scic_sds_remote_node_context_setup_to_resume(
-			this_rnc, the_callback, callback_parameter
+			sci_rnc, callback, callback_parameter
 			);
 
-		scic_sds_remote_node_context_construct_buffer(this_rnc);
+		scic_sds_remote_node_context_construct_buffer(sci_rnc);
 
 		sci_base_state_machine_change_state(
-			&this_rnc->state_machine,
+			&sci_rnc->state_machine,
 			SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
 			);
 
@@ -395,7 +395,7 @@ static enum sci_status scic_sds_remote_node_context_initial_state_resume_handler
 /* --------------------------------------------------------------------------- */
 
 static enum sci_status scic_sds_remote_node_context_posting_state_event_handler(
-	struct scic_sds_remote_node_context *this_rnc,
+	struct scic_sds_remote_node_context *sci_rnc,
 	u32 event_code)
 {
 	enum sci_status status;
@@ -405,19 +405,19 @@ static enum sci_status scic_sds_remote_node_context_posting_state_event_handler(
 		status = SCI_SUCCESS;
 
 		sci_base_state_machine_change_state(
-			&this_rnc->state_machine,
+			&sci_rnc->state_machine,
 			SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
 			);
 		break;
 
 	default:
 		status = SCI_FAILURE;
-		dev_warn(scirdev_to_dev(this_rnc->device),
+		dev_warn(scirdev_to_dev(sci_rnc->device),
 			 "%s: SCIC Remote Node Context 0x%p requested to "
 			 "process unexpected event 0x%x while in posting "
 			 "state\n",
 			 __func__,
-			 this_rnc,
+			 sci_rnc,
 			 event_code);
 		break;
 	}
@@ -428,19 +428,19 @@ static enum sci_status scic_sds_remote_node_context_posting_state_event_handler(
 /* --------------------------------------------------------------------------- */
 
 static enum sci_status scic_sds_remote_node_context_invalidating_state_destruct_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
 	scic_sds_remote_node_context_setup_to_destory(
-		this_rnc, the_callback, callback_parameter
+		sci_rnc, callback, callback_parameter
 		);
 
 	return SCI_SUCCESS;
 }
 
 static enum sci_status scic_sds_remote_node_context_invalidating_state_event_handler(
-	struct scic_sds_remote_node_context *this_rnc,
+	struct scic_sds_remote_node_context *sci_rnc,
 	u32 event_code)
 {
 	enum sci_status status;
@@ -448,14 +448,14 @@ static enum sci_status scic_sds_remote_node_context_invalidating_state_event_han
 	if (scu_get_event_code(event_code) == SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE) {
 		status = SCI_SUCCESS;
 
-		if (this_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
+		if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
 			sci_base_state_machine_change_state(
-				&this_rnc->state_machine,
+				&sci_rnc->state_machine,
 				SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
 				);
 		} else {
 			sci_base_state_machine_change_state(
-				&this_rnc->state_machine,
+				&sci_rnc->state_machine,
 				SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
 				);
 		}
@@ -466,25 +466,25 @@ static enum sci_status scic_sds_remote_node_context_invalidating_state_event_han
 			/*
 			 * We really dont care if the hardware is going to suspend
 			 * the device since it's being invalidated anyway */
-			dev_dbg(scirdev_to_dev(this_rnc->device),
+			dev_dbg(scirdev_to_dev(sci_rnc->device),
 				"%s: SCIC Remote Node Context 0x%p was "
 				"suspeneded by hardware while being "
 				"invalidated.\n",
 				__func__,
-				this_rnc);
+				sci_rnc);
 			status = SCI_SUCCESS;
 			break;
 
 		default:
-			dev_warn(scirdev_to_dev(this_rnc->device),
+			dev_warn(scirdev_to_dev(sci_rnc->device),
 				 "%s: SCIC Remote Node Context 0x%p "
 				 "requested to process event 0x%x while "
 				 "in state %d.\n",
 				 __func__,
-				 this_rnc,
+				 sci_rnc,
 				 event_code,
 				 sci_base_state_machine_get_state(
-					 &this_rnc->state_machine));
+					 &sci_rnc->state_machine));
 			status = SCI_FAILURE;
 			break;
 		}
@@ -497,7 +497,7 @@ static enum sci_status scic_sds_remote_node_context_invalidating_state_event_han
 
 
 static enum sci_status scic_sds_remote_node_context_resuming_state_event_handler(
-	struct scic_sds_remote_node_context *this_rnc,
+	struct scic_sds_remote_node_context *sci_rnc,
 	u32 event_code)
 {
 	enum sci_status status;
@@ -506,7 +506,7 @@ static enum sci_status scic_sds_remote_node_context_resuming_state_event_handler
 		status = SCI_SUCCESS;
 
 		sci_base_state_machine_change_state(
-			&this_rnc->state_machine,
+			&sci_rnc->state_machine,
 			SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
 			);
 	} else {
@@ -516,23 +516,23 @@ static enum sci_status scic_sds_remote_node_context_resuming_state_event_handler
 			/*
 			 * We really dont care if the hardware is going to suspend
 			 * the device since it's being resumed anyway */
-			dev_dbg(scirdev_to_dev(this_rnc->device),
+			dev_dbg(scirdev_to_dev(sci_rnc->device),
 				"%s: SCIC Remote Node Context 0x%p was "
 				"suspeneded by hardware while being resumed.\n",
 				__func__,
-				this_rnc);
+				sci_rnc);
 			status = SCI_SUCCESS;
 			break;
 
 		default:
-			dev_warn(scirdev_to_dev(this_rnc->device),
+			dev_warn(scirdev_to_dev(sci_rnc->device),
 				 "%s: SCIC Remote Node Context 0x%p requested "
 				 "to process event 0x%x while in state %d.\n",
 				 __func__,
-				 this_rnc,
+				 sci_rnc,
 				 event_code,
 				 sci_base_state_machine_get_state(
-					 &this_rnc->state_machine));
+					 &sci_rnc->state_machine));
 			status = SCI_FAILURE;
 			break;
 		}
@@ -545,32 +545,32 @@ static enum sci_status scic_sds_remote_node_context_resuming_state_event_handler
 
 /**
  *
- * @this_rnc: The remote node context object being suspended.
- * @the_callback: The callback when the suspension is complete.
+ * @sci_rnc: The remote node context object being suspended.
+ * @callback: The callback when the suspension is complete.
  * @callback_parameter: The parameter that is to be passed into the callback.
  *
  * This method will handle the suspend requests from the ready state.
  * SCI_SUCCESS
  */
 static enum sci_status scic_sds_remote_node_context_ready_state_suspend_handler(
-	struct scic_sds_remote_node_context *this_rnc,
+	struct scic_sds_remote_node_context *sci_rnc,
 	u32 suspend_type,
-	scics_sds_remote_node_context_callback the_callback,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
-	this_rnc->user_callback   = the_callback;
-	this_rnc->user_cookie     = callback_parameter;
-	this_rnc->suspension_code = suspend_type;
+	sci_rnc->user_callback   = callback;
+	sci_rnc->user_cookie     = callback_parameter;
+	sci_rnc->suspension_code = suspend_type;
 
 	if (suspend_type == SCI_SOFTWARE_SUSPENSION) {
 		scic_sds_remote_device_post_request(
-			this_rnc->device,
+			sci_rnc->device,
 			SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX
 			);
 	}
 
 	sci_base_state_machine_change_state(
-		&this_rnc->state_machine,
+		&sci_rnc->state_machine,
 		SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE
 		);
 
@@ -579,23 +579,23 @@ static enum sci_status scic_sds_remote_node_context_ready_state_suspend_handler(
 
 /**
  *
- * @this_rnc: The rnc for which the io request is targeted.
- * @the_request: The request which is going to be started.
+ * @sci_rnc: The rnc for which the io request is targeted.
+ * @sci_req: The request which is going to be started.
  *
  * This method determines if the io request can be started by the SCU hardware.
  * When the RNC is in the ready state any io request can be started. enum sci_status
  * SCI_SUCCESS
  */
 static enum sci_status scic_sds_remote_node_context_ready_state_start_io_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	struct scic_sds_request *the_request)
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
 {
 	return SCI_SUCCESS;
 }
 
 
 static enum sci_status scic_sds_remote_node_context_ready_state_event_handler(
-	struct scic_sds_remote_node_context *this_rnc,
+	struct scic_sds_remote_node_context *sci_rnc,
 	u32 event_code)
 {
 	enum sci_status status;
@@ -603,33 +603,33 @@ static enum sci_status scic_sds_remote_node_context_ready_state_event_handler(
 	switch (scu_get_event_type(event_code)) {
 	case SCU_EVENT_TL_RNC_SUSPEND_TX:
 		sci_base_state_machine_change_state(
-			&this_rnc->state_machine,
+			&sci_rnc->state_machine,
 			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
 			);
 
-		this_rnc->suspension_code = scu_get_event_specifier(event_code);
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
 		status = SCI_SUCCESS;
 		break;
 
 	case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
 		sci_base_state_machine_change_state(
-			&this_rnc->state_machine,
+			&sci_rnc->state_machine,
 			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
 			);
 
-		this_rnc->suspension_code = scu_get_event_specifier(event_code);
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
 		status = SCI_SUCCESS;
 		break;
 
 	default:
-		dev_warn(scirdev_to_dev(this_rnc->device),
+		dev_warn(scirdev_to_dev(sci_rnc->device),
 			"%s: SCIC Remote Node Context 0x%p requested to "
 			"process event 0x%x while in state %d.\n",
 			__func__,
-			this_rnc,
+			sci_rnc,
 			event_code,
 			sci_base_state_machine_get_state(
-				&this_rnc->state_machine));
+				&sci_rnc->state_machine));
 
 		status = SCI_FAILURE;
 		break;
@@ -641,41 +641,41 @@ static enum sci_status scic_sds_remote_node_context_ready_state_event_handler(
 /* --------------------------------------------------------------------------- */
 
 static enum sci_status scic_sds_remote_node_context_tx_suspended_state_resume_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
 	enum sci_status status;
 	struct smp_discover_response_protocols protocols;
 
 	scic_sds_remote_node_context_setup_to_resume(
-		this_rnc, the_callback, callback_parameter
+		sci_rnc, callback, callback_parameter
 		);
 
 	/* TODO: consider adding a resume action of NONE, INVALIDATE, WRITE_TLCR */
 
-	scic_remote_device_get_protocols(this_rnc->device, &protocols);
+	scic_remote_device_get_protocols(sci_rnc->device, &protocols);
 
 	if (
 		(protocols.u.bits.attached_ssp_target == 1)
 		|| (protocols.u.bits.attached_smp_target == 1)
 		) {
 		sci_base_state_machine_change_state(
-			&this_rnc->state_machine,
+			&sci_rnc->state_machine,
 			SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
 			);
 
 		status = SCI_SUCCESS;
 	} else if (protocols.u.bits.attached_stp_target == 1) {
-		if (this_rnc->device->is_direct_attached) {
+		if (sci_rnc->device->is_direct_attached) {
 			/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
 			sci_base_state_machine_change_state(
-				&this_rnc->state_machine,
+				&sci_rnc->state_machine,
 				SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
 				);
 		} else {
 			sci_base_state_machine_change_state(
-				&this_rnc->state_machine,
+				&sci_rnc->state_machine,
 				SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
 				);
 		}
@@ -690,8 +690,8 @@ static enum sci_status scic_sds_remote_node_context_tx_suspended_state_resume_ha
 
 /**
  *
- * @this_rnc: The remote node context which is to receive the task request.
- * @the_request: The task request to be transmitted to to the remote target
+ * @sci_rnc: The remote node context which is to receive the task request.
+ * @sci_req: The task request to be transmitted to to the remote target
  *    device.
  *
  * This method will report a success or failure attempt to start a new task
@@ -700,10 +700,10 @@ static enum sci_status scic_sds_remote_node_context_tx_suspended_state_resume_ha
  * enum sci_status SCI_SUCCESS
  */
 static enum sci_status scic_sds_remote_node_context_suspended_start_task_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	struct scic_sds_request *the_request)
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
 {
-	scic_sds_remote_node_context_resume(this_rnc, NULL, NULL);
+	scic_sds_remote_node_context_resume(sci_rnc, NULL, NULL);
 
 	return SCI_SUCCESS;
 }
@@ -711,16 +711,16 @@ static enum sci_status scic_sds_remote_node_context_suspended_start_task_handler
 /* --------------------------------------------------------------------------- */
 
 static enum sci_status scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
 	scic_sds_remote_node_context_setup_to_resume(
-		this_rnc, the_callback, callback_parameter
+		sci_rnc, callback, callback_parameter
 		);
 
 	sci_base_state_machine_change_state(
-		&this_rnc->state_machine,
+		&sci_rnc->state_machine,
 		SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
 		);
 
@@ -735,12 +735,12 @@ static enum sci_status scic_sds_remote_node_context_tx_rx_suspended_state_resume
  *
  */
 static enum sci_status scic_sds_remote_node_context_await_suspension_state_resume_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
 	scic_sds_remote_node_context_setup_to_resume(
-		this_rnc, the_callback, callback_parameter
+		sci_rnc, callback, callback_parameter
 		);
 
 	return SCI_SUCCESS;
@@ -748,8 +748,8 @@ static enum sci_status scic_sds_remote_node_context_await_suspension_state_resum
 
 /**
  *
- * @this_rnc: The remote node context which is to receive the task request.
- * @the_request: The task request to be transmitted to to the remote target
+ * @sci_rnc: The remote node context which is to receive the task request.
+ * @sci_req: The task request to be transmitted to to the remote target
  *    device.
  *
  * This method will report a success or failure attempt to start a new task
@@ -758,14 +758,14 @@ static enum sci_status scic_sds_remote_node_context_await_suspension_state_resum
  * enum sci_status SCI_SUCCESS
  */
 static enum sci_status scic_sds_remote_node_context_await_suspension_state_start_task_handler(
-	struct scic_sds_remote_node_context *this_rnc,
-	struct scic_sds_request *the_request)
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
 {
 	return SCI_SUCCESS;
 }
 
 static enum sci_status scic_sds_remote_node_context_await_suspension_state_event_handler(
-	struct scic_sds_remote_node_context *this_rnc,
+	struct scic_sds_remote_node_context *sci_rnc,
 	u32 event_code)
 {
 	enum sci_status status;
@@ -773,33 +773,33 @@ static enum sci_status scic_sds_remote_node_context_await_suspension_state_event
 	switch (scu_get_event_type(event_code)) {
 	case SCU_EVENT_TL_RNC_SUSPEND_TX:
 		sci_base_state_machine_change_state(
-			&this_rnc->state_machine,
+			&sci_rnc->state_machine,
 			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
 			);
 
-		this_rnc->suspension_code = scu_get_event_specifier(event_code);
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
 		status = SCI_SUCCESS;
 		break;
 
 	case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
 		sci_base_state_machine_change_state(
-			&this_rnc->state_machine,
+			&sci_rnc->state_machine,
 			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
 			);
 
-		this_rnc->suspension_code = scu_get_event_specifier(event_code);
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
 		status = SCI_SUCCESS;
 		break;
 
 	default:
-		dev_warn(scirdev_to_dev(this_rnc->device),
+		dev_warn(scirdev_to_dev(sci_rnc->device),
 			 "%s: SCIC Remote Node Context 0x%p requested to "
 			 "process event 0x%x while in state %d.\n",
 			 __func__,
-			 this_rnc,
+			 sci_rnc,
 			 event_code,
 			 sci_base_state_machine_get_state(
-				 &this_rnc->state_machine));
+				 &sci_rnc->state_machine));
 
 		status = SCI_FAILURE;
 		break;
@@ -929,41 +929,41 @@ static void scic_sds_remote_node_context_continue_state_transitions(
 
 /**
  *
- * @this_rnc: The remote node context object that is to be validated.
+ * @sci_rnc: The remote node context object that is to be validated.
  *
  * This method will mark the rnc buffer as being valid and post the request to
  * the hardware. none
  */
 static void scic_sds_remote_node_context_validate_context_buffer(
-	struct scic_sds_remote_node_context *this_rnc)
+	struct scic_sds_remote_node_context *sci_rnc)
 {
 	union scu_remote_node_context *rnc_buffer;
 
 	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
-		scic_sds_remote_device_get_controller(this_rnc->device),
-		this_rnc->remote_node_index
+		scic_sds_remote_device_get_controller(sci_rnc->device),
+		sci_rnc->remote_node_index
 		);
 
 	rnc_buffer->ssp.is_valid = true;
 
 	if (
-		!this_rnc->device->is_direct_attached
-		&& this_rnc->device->target_protocols.u.bits.attached_stp_target
+		!sci_rnc->device->is_direct_attached
+		&& sci_rnc->device->target_protocols.u.bits.attached_stp_target
 		) {
 		scic_sds_remote_device_post_request(
-			this_rnc->device,
+			sci_rnc->device,
 			SCU_CONTEXT_COMMAND_POST_RNC_96
 			);
 	} else {
 		scic_sds_remote_device_post_request(
-			this_rnc->device,
+			sci_rnc->device,
 			SCU_CONTEXT_COMMAND_POST_RNC_32
 			);
 
-		if (this_rnc->device->is_direct_attached) {
+		if (sci_rnc->device->is_direct_attached) {
 			scic_sds_port_setup_transports(
-				this_rnc->device->owning_port,
-				this_rnc->remote_node_index
+				sci_rnc->device->owning_port,
+				sci_rnc->remote_node_index
 				);
 		}
 	}
@@ -971,24 +971,24 @@ static void scic_sds_remote_node_context_validate_context_buffer(
 
 /**
  *
- * @this_rnc: The remote node context object that is to be invalidated.
+ * @sci_rnc: The remote node context object that is to be invalidated.
  *
  * This method will update the RNC buffer and post the invalidate request. none
  */
 static void scic_sds_remote_node_context_invalidate_context_buffer(
-	struct scic_sds_remote_node_context *this_rnc)
+	struct scic_sds_remote_node_context *sci_rnc)
 {
 	union scu_remote_node_context *rnc_buffer;
 
 	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
-		scic_sds_remote_device_get_controller(this_rnc->device),
-		this_rnc->remote_node_index
+		scic_sds_remote_device_get_controller(sci_rnc->device),
+		sci_rnc->remote_node_index
 		);
 
 	rnc_buffer->ssp.is_valid = false;
 
 	scic_sds_remote_device_post_request(
-		this_rnc->device,
+		sci_rnc->device,
 		SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE
 		);
 }
@@ -1037,17 +1037,17 @@ static void scic_sds_remote_node_context_initial_state_enter(
 static void scic_sds_remote_node_context_posting_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_remote_node_context *this_rnc;
+	struct scic_sds_remote_node_context *sci_rnc;
 
-	this_rnc = (struct scic_sds_remote_node_context *)object;
+	sci_rnc = (struct scic_sds_remote_node_context *)object;
 
 	SET_STATE_HANDLER(
-		this_rnc,
+		sci_rnc,
 		scic_sds_remote_node_context_state_handler_table,
 		SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
 		);
 
-	scic_sds_remote_node_context_validate_context_buffer(this_rnc);
+	scic_sds_remote_node_context_validate_context_buffer(sci_rnc);
 }
 
 /**
diff --git a/drivers/scsi/isci/core/scic_sds_remote_node_context.h b/drivers/scsi/isci/core/scic_sds_remote_node_context.h
index e21abe2..a103f15 100644
--- a/drivers/scsi/isci/core/scic_sds_remote_node_context.h
+++ b/drivers/scsi/isci/core/scic_sds_remote_node_context.h
@@ -86,25 +86,25 @@ struct scic_sds_remote_node_context;
 typedef void (*scics_sds_remote_node_context_callback)(void *);
 
 typedef enum sci_status (*scic_sds_remote_node_context_operation)(
-	struct scic_sds_remote_node_context *this_rnc,
-	scics_sds_remote_node_context_callback the_callback,
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter
 	);
 
 typedef enum sci_status (*scic_sds_remote_node_context_suspend_operation)(
-	struct scic_sds_remote_node_context *this_rnc,
+	struct scic_sds_remote_node_context *sci_rnc,
 	u32 suspension_type,
-	scics_sds_remote_node_context_callback the_callback,
+	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter
 	);
 
 typedef enum sci_status (*scic_sds_remote_node_context_io_request)(
-	struct scic_sds_remote_node_context *this_rnc,
-	struct scic_sds_request *the_request
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req
 	);
 
 typedef enum sci_status (*scic_sds_remote_node_context_event_handler)(
-	struct scic_sds_remote_node_context *this_rnc,
+	struct scic_sds_remote_node_context *sci_rnc,
 	u32 event_code
 	);
 
@@ -286,7 +286,7 @@ void scic_sds_remote_node_context_construct(
 
 
 bool scic_sds_remote_node_context_is_ready(
-	struct scic_sds_remote_node_context *this_rnc);
+	struct scic_sds_remote_node_context *sci_rnc);
 
 #define scic_sds_remote_node_context_get_remote_node_index(rcn)	\
 	((rnc)->remote_node_index)
diff --git a/drivers/scsi/isci/core/scic_sds_request.c b/drivers/scsi/isci/core/scic_sds_request.c
index a6ee155..8a608f0 100644
--- a/drivers/scsi/isci/core/scic_sds_request.c
+++ b/drivers/scsi/isci/core/scic_sds_request.c
@@ -226,7 +226,7 @@ static u32 scic_sds_ssp_request_get_object_size(void)
 
 /**
  * This method returns the sgl element pair for the specificed sgl_pair index.
- * @this_request: This parameter specifies the IO request for which to retrieve
+ * @sci_req: This parameter specifies the IO request for which to retrieve
  *    the Scatter-Gather List element pair.
  * @sgl_pair_index: This parameter specifies the index into the SGL element
  *    pair to be retrieved.
@@ -234,12 +234,12 @@ static u32 scic_sds_ssp_request_get_object_size(void)
  * This method returns a pointer to an struct scu_sgl_element_pair.
  */
 static struct scu_sgl_element_pair *scic_sds_request_get_sgl_element_pair(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 sgl_pair_index
 	) {
 	struct scu_task_context *task_context;
 
-	task_context = (struct scu_task_context *)this_request->task_context_buffer;
+	task_context = (struct scu_task_context *)sci_req->task_context_buffer;
 
 	if (sgl_pair_index == 0) {
 		return &task_context->sgl_pair_ab;
@@ -247,12 +247,12 @@ static struct scu_sgl_element_pair *scic_sds_request_get_sgl_element_pair(
 		return &task_context->sgl_pair_cd;
 	}
 
-	return &this_request->sgl_element_pair_buffer[sgl_pair_index - 2];
+	return &sci_req->sgl_element_pair_buffer[sgl_pair_index - 2];
 }
 
 /**
  * This function will build the SGL list for an IO request.
- * @this_request: This parameter specifies the IO request for which to build
+ * @sci_req: This parameter specifies the IO request for which to build
  *    the Scatter-Gather List.
  *
  */
@@ -325,36 +325,36 @@ void scic_sds_request_build_sgl(struct scic_sds_request *sds_request)
 
 /**
  * This method build the remainder of the IO request object.
- * @this_request: This parameter specifies the request object being constructed.
+ * @sci_req: This parameter specifies the request object being constructed.
  *
  * The scic_sds_general_request_construct() must be called before this call is
  * valid. none
  */
 static void scic_sds_ssp_io_request_assign_buffers(
-	struct scic_sds_request *this_request)
+	struct scic_sds_request *sci_req)
 {
-	this_request->command_buffer =
-		scic_sds_ssp_request_get_command_buffer(this_request);
-	this_request->response_buffer =
-		scic_sds_ssp_request_get_response_buffer(this_request);
-	this_request->sgl_element_pair_buffer =
-		scic_sds_ssp_request_get_sgl_element_buffer(this_request);
-	this_request->sgl_element_pair_buffer =
-		PTR_ALIGN(this_request->sgl_element_pair_buffer,
+	sci_req->command_buffer =
+		scic_sds_ssp_request_get_command_buffer(sci_req);
+	sci_req->response_buffer =
+		scic_sds_ssp_request_get_response_buffer(sci_req);
+	sci_req->sgl_element_pair_buffer =
+		scic_sds_ssp_request_get_sgl_element_buffer(sci_req);
+	sci_req->sgl_element_pair_buffer =
+		PTR_ALIGN(sci_req->sgl_element_pair_buffer,
 			  sizeof(struct scu_sgl_element_pair));
 
-	if (this_request->was_tag_assigned_by_user == false) {
-		this_request->task_context_buffer =
-			scic_sds_ssp_request_get_task_context_buffer(this_request);
-		this_request->task_context_buffer =
-			PTR_ALIGN(this_request->task_context_buffer,
+	if (sci_req->was_tag_assigned_by_user == false) {
+		sci_req->task_context_buffer =
+			scic_sds_ssp_request_get_task_context_buffer(sci_req);
+		sci_req->task_context_buffer =
+			PTR_ALIGN(sci_req->task_context_buffer,
 				  SMP_CACHE_BYTES);
 	}
 }
 
 /**
  * This method constructs the SSP Command IU data for this io request object.
- * @this_request: This parameter specifies the request object for which the SSP
+ * @sci_req: This parameter specifies the request object for which the SSP
  *    command information unit is being built.
  *
  */
@@ -401,7 +401,7 @@ static void scic_sds_io_request_build_ssp_command_iu(
 
 /**
  * This method constructs the SSP Task IU data for this io request object.
- * @this_request:
+ * @sci_req:
  *
  */
 static void scic_sds_task_request_build_ssp_task_iu(
@@ -430,7 +430,7 @@ static void scic_sds_task_request_build_ssp_task_iu(
 
 /**
  * This method is will fill in the SCU Task Context for any type of SSP request.
- * @this_request:
+ * @sci_req:
  * @task_context:
  *
  */
@@ -474,7 +474,7 @@ static void scu_ssp_reqeust_construct_task_context(
 
 	task_context->address_modifier = 0;
 
-	/* task_context->type.ssp.tag = this_request->io_tag; */
+	/* task_context->type.ssp.tag = sci_req->io_tag; */
 	task_context->task_phase = 0x01;
 
 	if (sds_request->was_tag_assigned_by_user) {
@@ -530,7 +530,7 @@ static void scu_ssp_reqeust_construct_task_context(
 
 /**
  * This method is will fill in the SCU Task Context for a SSP IO request.
- * @this_request:
+ * @sci_req:
  *
  */
 static void scu_ssp_io_request_construct_task_context(
@@ -568,24 +568,24 @@ static void scu_ssp_io_request_construct_task_context(
 /**
  * This method will fill in the remainder of the io request object for SSP Task
  *    requests.
- * @this_request:
+ * @sci_req:
  *
  */
 static void scic_sds_ssp_task_request_assign_buffers(
-	struct scic_sds_request *this_request)
+	struct scic_sds_request *sci_req)
 {
 	/* Assign all of the buffer pointers */
-	this_request->command_buffer =
-		scic_sds_ssp_task_request_get_command_buffer(this_request);
-	this_request->response_buffer =
-		scic_sds_ssp_task_request_get_response_buffer(this_request);
-	this_request->sgl_element_pair_buffer = NULL;
-
-	if (this_request->was_tag_assigned_by_user == false) {
-		this_request->task_context_buffer =
-			scic_sds_ssp_task_request_get_task_context_buffer(this_request);
-		this_request->task_context_buffer =
-			PTR_ALIGN(this_request->task_context_buffer, SMP_CACHE_BYTES);
+	sci_req->command_buffer =
+		scic_sds_ssp_task_request_get_command_buffer(sci_req);
+	sci_req->response_buffer =
+		scic_sds_ssp_task_request_get_response_buffer(sci_req);
+	sci_req->sgl_element_pair_buffer = NULL;
+
+	if (sci_req->was_tag_assigned_by_user == false) {
+		sci_req->task_context_buffer =
+			scic_sds_ssp_task_request_get_task_context_buffer(sci_req);
+		sci_req->task_context_buffer =
+			PTR_ALIGN(sci_req->task_context_buffer, SMP_CACHE_BYTES);
 	}
 }
 
@@ -598,18 +598,18 @@ static void scic_sds_ssp_task_request_assign_buffers(
  *    (i.e. non-raw frame) is being utilized to perform task management. -#
  *    control_frame == 1.  This ensures that the proper endianess is set so
  *    that the bytes are transmitted in the right order for a task frame.
- * @this_request: This parameter specifies the task request object being
+ * @sci_req: This parameter specifies the task request object being
  *    constructed.
  *
  */
 static void scu_ssp_task_request_construct_task_context(
-	struct scic_sds_request *this_request)
+	struct scic_sds_request *sci_req)
 {
 	struct scu_task_context *task_context;
 
-	task_context = scic_sds_request_get_task_context(this_request);
+	task_context = scic_sds_request_get_task_context(sci_req);
 
-	scu_ssp_reqeust_construct_task_context(this_request, task_context);
+	scu_ssp_reqeust_construct_task_context(sci_req, task_context);
 
 	task_context->control_frame                = 1;
 	task_context->priority                     = SCU_TASK_PRIORITY_HIGH;
@@ -623,7 +623,7 @@ static void scu_ssp_task_request_construct_task_context(
 /**
  * This method constructs the SSP Command IU data for this ssp passthrough
  *    comand request object.
- * @this_request: This parameter specifies the request object for which the SSP
+ * @sci_req: This parameter specifies the request object for which the SSP
  *    command information unit is being built.
  *
  * enum sci_status, returns invalid parameter is cdb > 16
@@ -632,7 +632,7 @@ static void scu_ssp_task_request_construct_task_context(
 
 /**
  * This method constructs the SATA request object.
- * @this_request:
+ * @sci_req:
  * @sat_protocol:
  * @transfer_length:
  * @data_direction:
@@ -964,7 +964,7 @@ scic_sds_io_request_tc_completion(struct scic_sds_request *request, u32 completi
 
 /**
  *
- * @this_request: The SCIC_SDS_IO_REQUEST_T object for which the start
+ * @sci_req: The SCIC_SDS_IO_REQUEST_T object for which the start
  *    operation is to be executed.
  * @frame_index: The frame index returned by the hardware for the reqeust
  *    object.
@@ -992,7 +992,7 @@ enum sci_status scic_sds_io_request_frame_handler(
 
 /**
  *
- * @this_request: The SCIC_SDS_IO_REQUEST_T object for which the task start
+ * @sci_req: The SCIC_SDS_IO_REQUEST_T object for which the task start
  *    operation is to be executed.
  *
  * This method invokes the core state task complete handler for the
@@ -1007,7 +1007,7 @@ enum sci_status scic_sds_io_request_frame_handler(
 /**
  * This method copies response data for requests returning response data
  *    instead of sense data.
- * @this_request: This parameter specifies the request object for which to copy
+ * @sci_req: This parameter specifies the request object for which to copy
  *    the response data.
  *
  */
@@ -1161,14 +1161,14 @@ enum sci_status scic_sds_request_started_state_abort_handler(
  *    TC (task context) completions for normal IO request (i.e. Task/Abort
  *    Completions of type 0).  This method will update the
  *    SCIC_SDS_IO_REQUEST_T::status field.
- * @this_request: This parameter specifies the request for which a completion
+ * @sci_req: This parameter specifies the request for which a completion
  *    occurred.
  * @completion_code: This parameter specifies the completion code received from
  *    the SCU.
  *
  */
 enum sci_status scic_sds_request_started_state_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	u8 data_present;
@@ -1181,7 +1181,7 @@ enum sci_status scic_sds_request_started_state_tc_completion_handler(
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 		break;
 
@@ -1194,20 +1194,20 @@ enum sci_status scic_sds_request_started_state_tc_completion_handler(
 		 * response stats to see if this is truly a failed request or a good
 		 * request that just got completed early. */
 		struct sci_ssp_response_iu *response = (struct sci_ssp_response_iu *)
-						  this_request->response_buffer;
+						  sci_req->response_buffer;
 		scic_word_copy_with_swap(
-			this_request->response_buffer,
-			this_request->response_buffer,
+			sci_req->response_buffer,
+			sci_req->response_buffer,
 			sizeof(struct sci_ssp_response_iu) / sizeof(u32)
 			);
 
 		if (response->status == 0) {
 			scic_sds_request_set_status(
-				this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS_IO_DONE_EARLY
+				sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS_IO_DONE_EARLY
 				);
 		} else {
 			scic_sds_request_set_status(
-				this_request,
+				sci_req,
 				SCU_TASK_DONE_CHECK_RESPONSE,
 				SCI_FAILURE_IO_RESPONSE_VALID
 				);
@@ -1217,13 +1217,13 @@ enum sci_status scic_sds_request_started_state_tc_completion_handler(
 
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_CHECK_RESPONSE):
 		scic_word_copy_with_swap(
-			this_request->response_buffer,
-			this_request->response_buffer,
+			sci_req->response_buffer,
+			sci_req->response_buffer,
 			sizeof(struct sci_ssp_response_iu) / sizeof(u32)
 			);
 
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_TASK_DONE_CHECK_RESPONSE,
 			SCI_FAILURE_IO_RESPONSE_VALID
 			);
@@ -1234,19 +1234,19 @@ enum sci_status scic_sds_request_started_state_tc_completion_handler(
 		 * / @todo With TASK_DONE_RESP_LEN_ERR is the response frame guaranteed
 		 * /       to be received before this completion status is posted? */
 		response_buffer =
-			(struct sci_ssp_response_iu *)this_request->response_buffer;
+			(struct sci_ssp_response_iu *)sci_req->response_buffer;
 		data_present =
 			response_buffer->data_present & SCI_SSP_RESPONSE_IU_DATA_PRESENT_MASK;
 
 		if ((data_present == 0x01) || (data_present == 0x02)) {
 			scic_sds_request_set_status(
-				this_request,
+				sci_req,
 				SCU_TASK_DONE_CHECK_RESPONSE,
 				SCI_FAILURE_IO_RESPONSE_VALID
 				);
 		} else {
 			scic_sds_request_set_status(
-				this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+				sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 				);
 		}
 		break;
@@ -1263,15 +1263,15 @@ enum sci_status scic_sds_request_started_state_tc_completion_handler(
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_UNEXP_SDBFIS):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_REG_ERR):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_SDB_ERR):
-		if (this_request->protocol == SCIC_STP_PROTOCOL) {
+		if (sci_req->protocol == SCIC_STP_PROTOCOL) {
 			scic_sds_request_set_status(
-				this_request,
+				sci_req,
 				SCU_GET_COMPLETION_TL_STATUS(completion_code) >> SCU_COMPLETION_TL_STATUS_SHIFT,
 				SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED
 				);
 		} else {
 			scic_sds_request_set_status(
-				this_request,
+				sci_req,
 				SCU_GET_COMPLETION_TL_STATUS(completion_code) >> SCU_COMPLETION_TL_STATUS_SHIFT,
 				SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 				);
@@ -1290,7 +1290,7 @@ enum sci_status scic_sds_request_started_state_tc_completion_handler(
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_OPEN_REJECT_CONNECTION_RATE_NOT_SUPPORTED):
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_GET_COMPLETION_TL_STATUS(completion_code) >> SCU_COMPLETION_TL_STATUS_SHIFT,
 			SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED
 			);
@@ -1314,7 +1314,7 @@ enum sci_status scic_sds_request_started_state_tc_completion_handler(
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_RNCNV_OUTBOUND):
 	default:
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_GET_COMPLETION_TL_STATUS(completion_code) >> SCU_COMPLETION_TL_STATUS_SHIFT,
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
@@ -1326,7 +1326,7 @@ enum sci_status scic_sds_request_started_state_tc_completion_handler(
 	 */
 
 	/* In all cases we will treat this as the completion of the IO request. */
-	sci_base_state_machine_change_state(&this_request->state_machine,
+	sci_base_state_machine_change_state(&sci_req->state_machine,
 		SCI_BASE_REQUEST_STATE_COMPLETED);
 	return SCI_SUCCESS;
 }
@@ -1340,7 +1340,7 @@ enum sci_status scic_sds_request_started_state_tc_completion_handler(
  * logged. enum sci_status SCI_SUCCESS SCI_FAILURE_INVALID_PARAMETER_VALUE
  */
 static enum sci_status scic_sds_request_started_state_frame_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 frame_index)
 {
 	enum sci_status status;
@@ -1348,7 +1348,7 @@ static enum sci_status scic_sds_request_started_state_frame_handler(
 
 	/* / @todo If this is a response frame we must record that we received it */
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(scic_sds_request_get_controller(this_request)->uf_control),
+		&(scic_sds_request_get_controller(sci_req)->uf_control),
 		frame_index,
 		(void **)&frame_header
 		);
@@ -1357,37 +1357,37 @@ static enum sci_status scic_sds_request_started_state_frame_handler(
 		struct sci_ssp_response_iu *response_buffer;
 
 		status = scic_sds_unsolicited_frame_control_get_buffer(
-			&(scic_sds_request_get_controller(this_request)->uf_control),
+			&(scic_sds_request_get_controller(sci_req)->uf_control),
 			frame_index,
 			(void **)&response_buffer
 			);
 
 		scic_word_copy_with_swap(
-			this_request->response_buffer,
+			sci_req->response_buffer,
 			(u32 *)response_buffer,
 			sizeof(struct sci_ssp_response_iu)
 			);
 
-		response_buffer = (struct sci_ssp_response_iu *)this_request->response_buffer;
+		response_buffer = (struct sci_ssp_response_iu *)sci_req->response_buffer;
 
 		if ((response_buffer->data_present == 0x01) ||
 		    (response_buffer->data_present == 0x02)) {
 			scic_sds_request_set_status(
-				this_request,
+				sci_req,
 				SCU_TASK_DONE_CHECK_RESPONSE,
 				SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 				);
 		} else
 			scic_sds_request_set_status(
-				this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+				sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 				);
 	} else
 		/* This was not a response frame why did it get forwarded? */
-		dev_err(scic_to_dev(this_request->owning_controller),
+		dev_err(scic_to_dev(sci_req->owning_controller),
 			"%s: SCIC IO Request 0x%p received unexpected "
 			"frame %d type 0x%02x\n",
 			__func__,
-			this_request,
+			sci_req,
 			frame_index,
 			frame_header->frame_type);
 
@@ -1395,7 +1395,7 @@ static enum sci_status scic_sds_request_started_state_frame_handler(
 	 * In any case we are done with this frame buffer return it to the
 	 * controller */
 	scic_sds_controller_release_frame(
-		this_request->owning_controller, frame_index
+		sci_req->owning_controller, frame_index
 		);
 
 	return SCI_SUCCESS;
@@ -1460,17 +1460,17 @@ static enum sci_status scic_sds_request_aborting_state_abort_handler(
  * transitions to the completed state. enum sci_status SCI_SUCCESS
  */
 static enum sci_status scic_sds_request_aborting_state_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case (SCU_TASK_DONE_GOOD << SCU_COMPLETION_TL_STATUS_SHIFT):
 	case (SCU_TASK_DONE_TASK_ABORT << SCU_COMPLETION_TL_STATUS_SHIFT):
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_TASK_ABORT, SCI_FAILURE_IO_TERMINATED
+			sci_req, SCU_TASK_DONE_TASK_ABORT, SCI_FAILURE_IO_TERMINATED
 			);
 
-		sci_base_state_machine_change_state(&this_request->state_machine,
+		sci_base_state_machine_change_state(&sci_req->state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED);
 		break;
 
@@ -1491,13 +1491,13 @@ static enum sci_status scic_sds_request_aborting_state_tc_completion_handler(
  * completion. enum sci_status SCI_SUCCESS
  */
 static enum sci_status scic_sds_request_aborting_state_frame_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 frame_index)
 {
 	/* TODO: Is it even possible to get an unsolicited frame in the aborting state? */
 
 	scic_sds_controller_release_frame(
-		this_request->owning_controller, frame_index);
+		sci_req->owning_controller, frame_index);
 
 	return SCI_SUCCESS;
 }
@@ -1539,10 +1539,10 @@ static const struct scic_sds_io_request_state_handler scic_sds_request_state_han
 static void scic_sds_request_initial_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_request_state_handler_table,
 		SCI_BASE_REQUEST_STATE_INITIAL
 		);
@@ -1559,10 +1559,10 @@ static void scic_sds_request_initial_state_enter(
 static void scic_sds_request_constructed_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_request_state_handler_table,
 		SCI_BASE_REQUEST_STATE_CONSTRUCTED
 		);
@@ -1580,10 +1580,10 @@ static void scic_sds_request_constructed_state_enter(
 static void scic_sds_request_started_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_request_state_handler_table,
 		SCI_BASE_REQUEST_STATE_STARTED
 		);
@@ -1591,8 +1591,8 @@ static void scic_sds_request_started_state_enter(
 	/*
 	 * Most of the request state machines have a started substate machine so
 	 * start its execution on the entry to the started state. */
-	if (this_request->has_started_substate_machine == true)
-		sci_base_state_machine_start(&this_request->started_substate_machine);
+	if (sci_req->has_started_substate_machine == true)
+		sci_base_state_machine_start(&sci_req->started_substate_machine);
 }
 
 /**
@@ -1608,10 +1608,10 @@ static void scic_sds_request_started_state_enter(
 static void scic_sds_request_started_state_exit(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
-	if (this_request->has_started_substate_machine == true)
-		sci_base_state_machine_stop(&this_request->started_substate_machine);
+	if (sci_req->has_started_substate_machine == true)
+		sci_base_state_machine_stop(&sci_req->started_substate_machine);
 }
 
 /**
@@ -1660,13 +1660,13 @@ static void scic_sds_request_completed_state_enter(
 static void scic_sds_request_aborting_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	/* Setting the abort bit in the Task Context is required by the silicon. */
-	this_request->task_context_buffer->abort = 1;
+	sci_req->task_context_buffer->abort = 1;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_request_state_handler_table,
 		SCI_BASE_REQUEST_STATE_ABORTING
 		);
@@ -1684,10 +1684,10 @@ static void scic_sds_request_aborting_state_enter(
 static void scic_sds_request_final_state_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_request_state_handler_table,
 		SCI_BASE_REQUEST_STATE_FINAL
 		);
diff --git a/drivers/scsi/isci/core/scic_sds_request.h b/drivers/scsi/isci/core/scic_sds_request.h
index 423567a..0bb1da8 100644
--- a/drivers/scsi/isci/core/scic_sds_request.h
+++ b/drivers/scsi/isci/core/scic_sds_request.h
@@ -336,32 +336,32 @@ extern const struct sci_base_state scic_sds_io_request_started_task_mgmt_substat
  *
  * This macro will return the controller for this io request object
  */
-#define scic_sds_request_get_controller(this_request) \
-	((this_request)->owning_controller)
+#define scic_sds_request_get_controller(sci_req) \
+	((sci_req)->owning_controller)
 
 /**
  * scic_sds_request_get_device() -
  *
  * This macro will return the device for this io request object
  */
-#define scic_sds_request_get_device(this_request) \
-	((this_request)->target_device)
+#define scic_sds_request_get_device(sci_req) \
+	((sci_req)->target_device)
 
 /**
  * scic_sds_request_get_port() -
  *
  * This macro will return the port for this io request object
  */
-#define scic_sds_request_get_port(this_request)	\
-	scic_sds_remote_device_get_port(scic_sds_request_get_device(this_request))
+#define scic_sds_request_get_port(sci_req)	\
+	scic_sds_remote_device_get_port(scic_sds_request_get_device(sci_req))
 
 /**
  * scic_sds_request_get_post_context() -
  *
  * This macro returns the constructed post context result for the io request.
  */
-#define scic_sds_request_get_post_context(this_request)	\
-	((this_request)->post_context)
+#define scic_sds_request_get_post_context(sci_req)	\
+	((sci_req)->post_context)
 
 /**
  * scic_sds_request_get_task_context() -
@@ -433,41 +433,41 @@ scic_sds_io_request_tc_completion(struct scic_sds_request *request, u32 completi
  * ***************************************************************************** */
 
 void scic_sds_request_build_sgl(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 
 
 
 void scic_sds_stp_request_assign_buffers(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 
 void scic_sds_smp_request_assign_buffers(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 
 /* --------------------------------------------------------------------------- */
 
 enum sci_status scic_sds_request_start(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 
 enum sci_status scic_sds_io_request_terminate(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 
 enum sci_status scic_sds_io_request_complete(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 
 void scic_sds_io_request_copy_response(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 
 enum sci_status scic_sds_io_request_event_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 event_code);
 
 enum sci_status scic_sds_io_request_frame_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 frame_index);
 
 
 enum sci_status scic_sds_task_request_terminate(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 
 /*
  * *****************************************************************************
@@ -475,10 +475,10 @@ enum sci_status scic_sds_task_request_terminate(
  * ***************************************************************************** */
 
 enum sci_status scic_sds_request_started_state_abort_handler(
-	struct scic_sds_request *request);
+	struct scic_sds_request *sci_req);
 
 enum sci_status scic_sds_request_started_state_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code);
 
 #endif /* _SCIC_SDS_IO_REQUEST_H_ */
diff --git a/drivers/scsi/isci/core/scic_sds_smp_remote_device.c b/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
index 88c3595..471cb7d 100644
--- a/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
+++ b/drivers/scsi/isci/core/scic_sds_smp_remote_device.c
@@ -142,15 +142,15 @@ scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler(
 	struct scic_sds_request *request)
 {
 	enum sci_status status;
-	struct scic_sds_request *the_request;
+	struct scic_sds_request *sci_req;
 
-	the_request = (struct scic_sds_request *)request;
+	sci_req = (struct scic_sds_request *)request;
 
-	status = scic_sds_io_request_complete(the_request);
+	status = scic_sds_io_request_complete(sci_req);
 
 	if (status == SCI_SUCCESS) {
 		status = scic_sds_port_complete_io(
-			device->owning_port, device, the_request);
+			device->owning_port, device, sci_req);
 
 		if (status == SCI_SUCCESS) {
 			scic_sds_remote_device_decrement_request_count(device);
@@ -165,7 +165,7 @@ scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler(
 				"failed with status %d.\n",
 				__func__,
 				device,
-				the_request,
+				sci_req,
 				device->owning_port,
 				status);
 	}
@@ -175,13 +175,13 @@ scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler(
 
 /**
  * This is frame handler for smp device ready cmd substate.
- * @this_device: This is the device object that is receiving the frame.
+ * @sci_dev: This is the device object that is receiving the frame.
  * @frame_index: The index for the frame received.
  *
  * enum sci_status
  */
 static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index)
 {
 	enum sci_status status;
@@ -191,7 +191,7 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 	 * / in this state.  All unsolicited frames are forwarded to the io request
 	 * / object. */
 	status = scic_sds_io_request_frame_handler(
-		this_device->working_request,
+		sci_dev->working_request,
 		frame_index
 		);
 
diff --git a/drivers/scsi/isci/core/scic_sds_smp_request.c b/drivers/scsi/isci/core/scic_sds_smp_request.c
index 70bc8d2..f53f21b 100644
--- a/drivers/scsi/isci/core/scic_sds_smp_request.c
+++ b/drivers/scsi/isci/core/scic_sds_smp_request.c
@@ -67,7 +67,7 @@
 #include "scu_task_context.h"
 
 static void scu_smp_request_construct_task_context(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	struct smp_request *smp_request);
 
 /**
@@ -118,27 +118,27 @@ u32 scic_sds_smp_request_get_object_size(void)
 
 /**
  * This method build the remainder of the IO request object.
- * @this_request: This parameter specifies the request object being constructed.
+ * @sci_req: This parameter specifies the request object being constructed.
  *
  * The scic_sds_general_request_construct() must be called before this call is
  * valid. none
  */
 
 void scic_sds_smp_request_assign_buffers(
-	struct scic_sds_request *this_request)
+	struct scic_sds_request *sci_req)
 {
 	/* Assign all of the buffer pointers */
-	this_request->command_buffer =
-		scic_sds_smp_request_get_command_buffer(this_request);
-	this_request->response_buffer =
-		scic_sds_smp_request_get_response_buffer(this_request);
-	this_request->sgl_element_pair_buffer = NULL;
-
-	if (this_request->was_tag_assigned_by_user == false) {
-		this_request->task_context_buffer =
-			scic_sds_smp_request_get_task_context_buffer(this_request);
-		this_request->task_context_buffer =
-			PTR_ALIGN(this_request->task_context_buffer, SMP_CACHE_BYTES);
+	sci_req->command_buffer =
+		scic_sds_smp_request_get_command_buffer(sci_req);
+	sci_req->response_buffer =
+		scic_sds_smp_request_get_response_buffer(sci_req);
+	sci_req->sgl_element_pair_buffer = NULL;
+
+	if (sci_req->was_tag_assigned_by_user == false) {
+		sci_req->task_context_buffer =
+			scic_sds_smp_request_get_task_context_buffer(sci_req);
+		sci_req->task_context_buffer =
+			PTR_ALIGN(sci_req->task_context_buffer, SMP_CACHE_BYTES);
 	}
 
 }
@@ -163,7 +163,7 @@ void scic_sds_smp_request_assign_buffers(
  *    (i.e. non-raw frame) is being utilized to perform task management. -#
  *    control_frame == 1.  This ensures that the proper endianess is set so
  *    that the bytes are transmitted in the right order for a smp request frame.
- * @this_request: This parameter specifies the smp request object being
+ * @sci_req: This parameter specifies the smp request object being
  *    constructed.
  *
  */
@@ -295,7 +295,7 @@ static void scu_smp_request_construct_task_context(
  *    for a response frame.  It will copy the response data, release the
  *    unsolicited frame, and transition the request to the
  *    SCI_BASE_REQUEST_STATE_COMPLETED state.
- * @this_request: This parameter specifies the request for which the
+ * @sci_req: This parameter specifies the request for which the
  *    unsolicited frame was received.
  * @frame_index: This parameter indicates the unsolicited frame index that
  *    should contain the response.
@@ -305,16 +305,16 @@ static void scu_smp_request_construct_task_context(
  * indicates successful processing of the TC response.
  */
 static enum sci_status scic_sds_smp_request_await_response_frame_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 frame_index)
 {
 	enum sci_status status;
 	void *frame_header;
-	struct smp_response_header *this_frame_header;
-	u8 *user_smp_buffer = this_request->response_buffer;
+	struct smp_response_header *rsp_hdr;
+	u8 *user_smp_buffer = sci_req->response_buffer;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(scic_sds_request_get_controller(this_request)->uf_control),
+		&(scic_sds_request_get_controller(sci_req)->uf_control),
 		frame_index,
 		&frame_header
 		);
@@ -325,13 +325,13 @@ static enum sci_status scic_sds_smp_request_await_response_frame_handler(
 		frame_header,
 		sizeof(struct smp_response_header) / sizeof(u32)
 		);
-	this_frame_header = (struct smp_response_header *)user_smp_buffer;
+	rsp_hdr = (struct smp_response_header *)user_smp_buffer;
 
-	if (this_frame_header->smp_frame_type == SMP_FRAME_TYPE_RESPONSE) {
+	if (rsp_hdr->smp_frame_type == SMP_FRAME_TYPE_RESPONSE) {
 		void *smp_response_buffer;
 
 		status = scic_sds_unsolicited_frame_control_get_buffer(
-			&(scic_sds_request_get_controller(this_request)->uf_control),
+			&(scic_sds_request_get_controller(sci_req)->uf_control),
 			frame_index,
 			&smp_response_buffer
 			);
@@ -341,23 +341,23 @@ static enum sci_status scic_sds_smp_request_await_response_frame_handler(
 			smp_response_buffer,
 			sizeof(union smp_response_body) / sizeof(u32)
 			);
-		if (this_frame_header->function == SMP_FUNCTION_DISCOVER) {
-			struct smp_response *this_smp_response;
+		if (rsp_hdr->function == SMP_FUNCTION_DISCOVER) {
+			struct smp_response *smp_resp;
 
-			this_smp_response = (struct smp_response *)user_smp_buffer;
+			smp_resp = (struct smp_response *)user_smp_buffer;
 
 			/*
 			 * Some expanders only report an attached SATA device, and
 			 * not an STP target.  Since the core depends on the STP
 			 * target attribute to correctly build I/O, set the bit now
 			 * if necessary. */
-			if (this_smp_response->response.discover.protocols.u.bits.attached_sata_device
-			    && !this_smp_response->response.discover.protocols.u.bits.attached_stp_target) {
-				this_smp_response->response.discover.protocols.u.bits.attached_stp_target = 1;
+			if (smp_resp->response.discover.protocols.u.bits.attached_sata_device
+			    && !smp_resp->response.discover.protocols.u.bits.attached_stp_target) {
+				smp_resp->response.discover.protocols.u.bits.attached_stp_target = 1;
 
-				dev_dbg(scic_to_dev(this_request->owning_controller),
+				dev_dbg(scic_to_dev(sci_req->owning_controller),
 					"%s: scic_sds_smp_request_await_response_frame_handler(0x%p) Found SATA dev, setting STP bit.\n",
-					__func__, this_request);
+					__func__, sci_req);
 			}
 		}
 
@@ -367,40 +367,40 @@ static enum sci_status scic_sds_smp_request_await_response_frame_handler(
 
 		/*
 		 * copy the smp response to framework smp request's response buffer.
-		 * scic_sds_smp_request_copy_response(this_request); */
+		 * scic_sds_smp_request_copy_response(sci_req); */
 
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->started_substate_machine,
+			&sci_req->started_substate_machine,
 			SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_TC_COMPLETION
 			);
 	} else {
 		/* This was not a response frame why did it get forwarded? */
-		dev_err(scic_to_dev(this_request->owning_controller),
+		dev_err(scic_to_dev(sci_req->owning_controller),
 			"%s: SCIC SMP Request 0x%p received unexpected frame "
 			"%d type 0x%02x\n",
 			__func__,
-			this_request,
+			sci_req,
 			frame_index,
-			this_frame_header->smp_frame_type);
+			rsp_hdr->smp_frame_type);
 
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_TASK_DONE_SMP_FRM_TYPE_ERR,
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->state_machine,
+			&sci_req->state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED
 			);
 	}
 
 	scic_sds_controller_release_frame(
-		this_request->owning_controller, frame_index
+		sci_req->owning_controller, frame_index
 		);
 
 	return SCI_SUCCESS;
@@ -411,7 +411,7 @@ static enum sci_status scic_sds_smp_request_await_response_frame_handler(
  * This method processes an abnormal TC completion while the SMP request is
  *    waiting for a response frame.  It decides what happened to the IO based
  *    on TC completion status.
- * @this_request: This parameter specifies the request for which the TC
+ * @sci_req: This parameter specifies the request for which the TC
  *    completion was received.
  * @completion_code: This parameter indicates the completion status information
  *    for the TC.
@@ -420,7 +420,7 @@ static enum sci_status scic_sds_smp_request_await_response_frame_handler(
  * this method always returns success.
  */
 static enum sci_status scic_sds_smp_request_await_response_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
@@ -429,11 +429,11 @@ static enum sci_status scic_sds_smp_request_await_response_tc_completion_handler
 		 * In the AWAIT RESPONSE state, any TC completion is unexpected.
 		 * but if the TC has success status, we complete the IO anyway. */
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->state_machine,
+			&sci_req->state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED);
 		break;
 
@@ -447,11 +447,11 @@ static enum sci_status scic_sds_smp_request_await_response_tc_completion_handler
 		 * break the connection and set TC completion with one of these SMP_XXX_XX_ERR
 		 * status. For these type of error, we ask scic user to retry the request. */
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_SMP_RESP_TO_ERR, SCI_FAILURE_RETRY_REQUIRED
+			sci_req, SCU_TASK_DONE_SMP_RESP_TO_ERR, SCI_FAILURE_RETRY_REQUIRED
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->state_machine,
+			&sci_req->state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED);
 		break;
 
@@ -460,13 +460,13 @@ static enum sci_status scic_sds_smp_request_await_response_tc_completion_handler
 		 * All other completion status cause the IO to be complete.  If a NAK
 		 * was received, then it is up to the user to retry the request. */
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->state_machine,
+			&sci_req->state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED);
 		break;
 	}
@@ -480,7 +480,7 @@ static enum sci_status scic_sds_smp_request_await_response_tc_completion_handler
  *    determine if the SMP request was sent successfully. If the SMP request
  *    was sent successfully, then the state for the SMP request transits to
  *    waiting for a response frame.
- * @this_request: This parameter specifies the request for which the TC
+ * @sci_req: This parameter specifies the request for which the TC
  *    completion was received.
  * @completion_code: This parameter indicates the completion status information
  *    for the TC.
@@ -489,17 +489,17 @@ static enum sci_status scic_sds_smp_request_await_response_tc_completion_handler
  * this method always returns success.
  */
 static enum sci_status scic_sds_smp_request_await_tc_completion_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->state_machine,
+			&sci_req->state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED);
 		break;
 
@@ -508,13 +508,13 @@ static enum sci_status scic_sds_smp_request_await_tc_completion_tc_completion_ha
 		 * All other completion status cause the IO to be complete.  If a NAK
 		 * was received, then it is up to the user to retry the request. */
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->state_machine,
+			&sci_req->state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED);
 		break;
 	}
@@ -547,10 +547,10 @@ static const struct scic_sds_io_request_state_handler scic_sds_smp_request_start
 static void scic_sds_smp_request_started_await_response_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_smp_request_started_substate_handler_table,
 		SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_RESPONSE
 		);
@@ -568,10 +568,10 @@ static void scic_sds_smp_request_started_await_response_substate_enter(
 static void scic_sds_smp_request_started_await_tc_completion_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_smp_request_started_substate_handler_table,
 		SCIC_SDS_SMP_REQUEST_STARTED_SUBSTATE_AWAIT_TC_COMPLETION
 		);
diff --git a/drivers/scsi/isci/core/scic_sds_smp_request.h b/drivers/scsi/isci/core/scic_sds_smp_request.h
index bcad282..8f34ffe 100644
--- a/drivers/scsi/isci/core/scic_sds_smp_request.h
+++ b/drivers/scsi/isci/core/scic_sds_smp_request.h
@@ -62,8 +62,7 @@
 u32 scic_sds_smp_request_get_object_size(void);
 
 
-void scic_sds_smp_request_copy_response(
-	struct scic_sds_request *this_request);
+void scic_sds_smp_request_copy_response(struct scic_sds_request *sci_req);
 
 #endif /* _SCIC_SDS_SMP_REQUEST_T_ */
 
diff --git a/drivers/scsi/isci/core/scic_sds_ssp_request.c b/drivers/scsi/isci/core/scic_sds_ssp_request.c
index 4d3a21b..0367668 100644
--- a/drivers/scsi/isci/core/scic_sds_ssp_request.c
+++ b/drivers/scsi/isci/core/scic_sds_ssp_request.c
@@ -67,7 +67,7 @@
  *    determine if the RAW task management frame was sent successfully. If the
  *    raw frame was sent successfully, then the state for the task request
  *    transitions to waiting for a response frame.
- * @this_request: This parameter specifies the request for which the TC
+ * @sci_req: This parameter specifies the request for which the TC
  *    completion was received.
  * @completion_code: This parameter indicates the completion status information
  *    for the TC.
@@ -76,17 +76,17 @@
  * this method always returns success.
  */
 static enum sci_status scic_sds_ssp_task_request_await_tc_completion_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->started_substate_machine,
+			&sci_req->started_substate_machine,
 			SCIC_SDS_IO_REQUEST_STARTED_TASK_MGMT_SUBSTATE_AWAIT_TC_RESPONSE
 			);
 		break;
@@ -97,15 +97,15 @@ static enum sci_status scic_sds_ssp_task_request_await_tc_completion_tc_completi
 		 * timeout if the task IU wasn't received successfully.
 		 * There is a potential for receiving multiple task responses if we
 		 * decide to send the task IU again. */
-		dev_warn(scic_to_dev(this_request->owning_controller),
+		dev_warn(scic_to_dev(sci_req->owning_controller),
 			 "%s: TaskRequest:0x%p CompletionCode:%x - "
 			 "ACK/NAK timeout\n",
 			 __func__,
-			 this_request,
+			 sci_req,
 			 completion_code);
 
 		sci_base_state_machine_change_state(
-			&this_request->started_substate_machine,
+			&sci_req->started_substate_machine,
 			SCIC_SDS_IO_REQUEST_STARTED_TASK_MGMT_SUBSTATE_AWAIT_TC_RESPONSE
 			);
 		break;
@@ -115,12 +115,12 @@ static enum sci_status scic_sds_ssp_task_request_await_tc_completion_tc_completi
 		 * All other completion status cause the IO to be complete.  If a NAK
 		 * was received, then it is up to the user to retry the request. */
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
 
-		sci_base_state_machine_change_state(&this_request->state_machine,
+		sci_base_state_machine_change_state(&sci_req->state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED);
 		break;
 	}
@@ -132,7 +132,7 @@ static enum sci_status scic_sds_ssp_task_request_await_tc_completion_tc_completi
  * This method is responsible for processing a terminate/abort request for this
  *    TC while the request is waiting for the task management response
  *    unsolicited frame.
- * @this_request: This parameter specifies the request for which the
+ * @sci_req: This parameter specifies the request for which the
  *    termination was requested.
  *
  * This method returns an indication as to whether the abort request was
@@ -155,7 +155,7 @@ static enum sci_status scic_sds_ssp_task_request_await_tc_response_abort_handler
  *    waiting for a response frame.  It will copy the response data, release
  *    the unsolicited frame, and transition the request to the
  *    SCI_BASE_REQUEST_STATE_COMPLETED state.
- * @this_request: This parameter specifies the request for which the
+ * @sci_req: This parameter specifies the request for which the
  *    unsolicited frame was received.
  * @frame_index: This parameter indicates the unsolicited frame index that
  *    should contain the response.
@@ -202,10 +202,10 @@ static const struct scic_sds_io_request_state_handler scic_sds_ssp_task_request_
 static void scic_sds_io_request_started_task_mgmt_await_tc_completion_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_ssp_task_request_started_substate_handler_table,
 		SCIC_SDS_IO_REQUEST_STARTED_TASK_MGMT_SUBSTATE_AWAIT_TC_COMPLETION
 		);
@@ -223,10 +223,10 @@ static void scic_sds_io_request_started_task_mgmt_await_tc_completion_substate_e
 static void scic_sds_io_request_started_task_mgmt_await_task_response_substate_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_ssp_task_request_started_substate_handler_table,
 		SCIC_SDS_IO_REQUEST_STARTED_TASK_MGMT_SUBSTATE_AWAIT_TC_RESPONSE
 		);
diff --git a/drivers/scsi/isci/core/scic_sds_stp_packet_request.c b/drivers/scsi/isci/core/scic_sds_stp_packet_request.c
index 25c68ce..e4d2bf5 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_packet_request.c
+++ b/drivers/scsi/isci/core/scic_sds_stp_packet_request.c
@@ -75,16 +75,16 @@
 /**
  * This method will fill in the SCU Task Context for a PACKET fis. And
  *    construct the request STARTED sub-state machine for Packet Protocol IO.
- * @this_request: This parameter specifies the stp packet request object being
+ * @sci_req: This parameter specifies the stp packet request object being
  *    constructed.
  *
  */
 enum sci_status scic_sds_stp_packet_request_construct(
-	struct scic_sds_request *this_request)
+	struct scic_sds_request *sci_req)
 {
 	struct sata_fis_reg_h2d *h2d_fis =
 		scic_stp_io_request_get_h2d_reg_address(
-			this_request
+			sci_req
 			);
 
 	/*
@@ -92,17 +92,17 @@ enum sci_status scic_sds_stp_packet_request_construct(
 	 * need to make change to Packet Fis features field. */
 	h2d_fis->features = h2d_fis->features | ATA_PACKET_FEATURE_DMA;
 
-	scic_sds_stp_non_ncq_request_construct(this_request);
+	scic_sds_stp_non_ncq_request_construct(sci_req);
 
 	/* Build the Packet Fis task context structure */
 	scu_stp_raw_request_construct_task_context(
-		(struct scic_sds_stp_request *)this_request,
-		this_request->task_context_buffer
+		(struct scic_sds_stp_request *)sci_req,
+		sci_req->task_context_buffer
 		);
 
 	sci_base_state_machine_construct(
-		&this_request->started_substate_machine,
-		&this_request->parent.parent,
+		&sci_req->started_substate_machine,
+		&sci_req->parent.parent,
 		scic_sds_stp_packet_request_started_substate_table,
 		SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
 		);
@@ -119,24 +119,24 @@ enum sci_status scic_sds_stp_packet_request_construct(
  *    utilized to perform task management. -# control_frame == 1.  This ensures
  *    that the proper endianess is set so that the bytes are transmitted in the
  *    right order for a smp request frame.
- * @this_request: This parameter specifies the smp request object being
+ * @sci_req: This parameter specifies the smp request object being
  *    constructed.
  * @task_context: The task_context to be reconstruct for packet request command
  *    phase.
  *
  */
 void scu_stp_packet_request_command_phase_construct_task_context(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	struct scu_task_context *task_context)
 {
 	void *atapi_cdb;
 	u32 atapi_cdb_length;
-	struct scic_sds_stp_request *stp_request = (struct scic_sds_stp_request *)this_request;
+	struct scic_sds_stp_request *stp_request = (struct scic_sds_stp_request *)sci_req;
 
 	/*
 	 * reference: SSTL 1.13.4.2
 	 * task_type, sata_direction */
-	if (scic_cb_io_request_get_data_direction(this_request->user_request)
+	if (scic_cb_io_request_get_data_direction(sci_req->user_request)
 	     == SCI_IO_REQUEST_DATA_OUT) {
 		task_context->task_type = SCU_TASK_TYPE_PACKET_DMA_OUT;
 		task_context->sata_direction = 0;
@@ -152,15 +152,15 @@ void scu_stp_packet_request_command_phase_construct_task_context(
 	/*
 	 * Copy in the command IU with CDB so that the commandIU address doesn't
 	 * change. */
-	memset(this_request->command_buffer, 0, sizeof(struct sata_fis_reg_h2d));
+	memset(sci_req->command_buffer, 0, sizeof(struct sata_fis_reg_h2d));
 
 	atapi_cdb =
-		scic_cb_stp_packet_io_request_get_cdb_address(this_request->user_request);
+		scic_cb_stp_packet_io_request_get_cdb_address(sci_req->user_request);
 
 	atapi_cdb_length =
-		scic_cb_stp_packet_io_request_get_cdb_length(this_request->user_request);
+		scic_cb_stp_packet_io_request_get_cdb_length(sci_req->user_request);
 
-	memcpy(((u8 *)this_request->command_buffer + sizeof(u32)), atapi_cdb, atapi_cdb_length);
+	memcpy(((u8 *)sci_req->command_buffer + sizeof(u32)), atapi_cdb, atapi_cdb_length);
 
 	atapi_cdb_length =
 		max(atapi_cdb_length, stp_request->type.packet.device_preferred_cdb_length);
@@ -175,18 +175,18 @@ void scu_stp_packet_request_command_phase_construct_task_context(
 	/* retry counter */
 	task_context->stp_retry_count = 0;
 
-	if (scic_cb_request_is_initial_construction(this_request->user_request)) {
+	if (scic_cb_request_is_initial_construction(sci_req->user_request)) {
 		/* data transfer size. */
 		task_context->transfer_length_bytes =
-			scic_cb_io_request_get_transfer_length(this_request->user_request);
+			scic_cb_io_request_get_transfer_length(sci_req->user_request);
 
 		/* setup sgl */
-		scic_sds_request_build_sgl(this_request);
+		scic_sds_request_build_sgl(sci_req);
 	} else {
 		/* data transfer size, need to be 4 bytes aligned. */
 		task_context->transfer_length_bytes = (SCSI_FIXED_SENSE_DATA_BASE_LENGTH + 2);
 
-		scic_sds_stp_packet_internal_request_sense_build_sgl(this_request);
+		scic_sds_stp_packet_internal_request_sense_build_sgl(sci_req);
 	}
 }
 
@@ -194,24 +194,24 @@ void scu_stp_packet_request_command_phase_construct_task_context(
  * This method will fill in the SCU Task Context for a DATA fis containing CDB
  *    in Raw Frame type. The TC for previous Packet fis was already there, we
  *    only need to change the H2D fis content.
- * @this_request: This parameter specifies the smp request object being
+ * @sci_req: This parameter specifies the smp request object being
  *    constructed.
  * @task_context: The task_context to be reconstruct for packet request command
  *    phase.
  *
  */
 void scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	struct scu_task_context *task_context)
 {
 	void *atapi_cdb =
-		scic_cb_stp_packet_io_request_get_cdb_address(this_request->user_request);
+		scic_cb_stp_packet_io_request_get_cdb_address(sci_req->user_request);
 
 	u32 atapi_cdb_length =
-		scic_cb_stp_packet_io_request_get_cdb_length(this_request->user_request);
+		scic_cb_stp_packet_io_request_get_cdb_length(sci_req->user_request);
 
-	memset(this_request->command_buffer, 0, sizeof(struct sata_fis_reg_h2d));
-	memcpy(((u8 *)this_request->command_buffer + sizeof(u32)), atapi_cdb, atapi_cdb_length);
+	memset(sci_req->command_buffer, 0, sizeof(struct sata_fis_reg_h2d));
+	memcpy(((u8 *)sci_req->command_buffer + sizeof(u32)), atapi_cdb, atapi_cdb_length);
 
 	memset(&(task_context->type.stp), 0, sizeof(struct stp_task_context));
 	task_context->type.stp.fis_type = SATA_FIS_TYPE_DATA;
@@ -227,12 +227,12 @@ void scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context(
  * *@brief This methods decode the D2H status FIS and retrieve the sense data,
  *          then pass the sense data to user request.
  *
- ***@param[in] this_request The request receive D2H status FIS.
+ ***@param[in] sci_req The request receive D2H status FIS.
  ***@param[in] status_fis The D2H status fis to be processed.
  *
  */
 enum sci_status scic_sds_stp_packet_request_process_status_fis(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	struct sata_fis_reg_d2h *status_fis)
 {
 	enum sci_status status = SCI_SUCCESS;
@@ -249,7 +249,7 @@ enum sci_status scic_sds_stp_packet_request_process_status_fis(
  *          command using this request response buffer, only one sge is
  *          needed.
  *
- ***@param[in] this_request The request receive request sense data.
+ ***@param[in] sci_req The request receive request sense data.
  *
  */
 void scic_sds_stp_packet_internal_request_sense_build_sgl(
@@ -284,7 +284,7 @@ void scic_sds_stp_packet_internal_request_sense_build_sgl(
  *    determine if the Packet FIS was sent successfully. If the Packet FIS was
  *    sent successfully, then the state for the Packet request transits to
  *    waiting for a PIO SETUP frame.
- * @this_request: This parameter specifies the request for which the TC
+ * @sci_req: This parameter specifies the request for which the TC
  *    completion was received.
  * @completion_code: This parameter indicates the completion status information
  *    for the TC.
@@ -293,7 +293,7 @@ void scic_sds_stp_packet_internal_request_sense_build_sgl(
  * this method always returns success.
  */
 enum sci_status scic_sds_stp_packet_request_packet_phase_await_tc_completion_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	enum sci_status status = SCI_SUCCESS;
@@ -301,11 +301,11 @@ enum sci_status scic_sds_stp_packet_request_packet_phase_await_tc_completion_tc_
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->started_substate_machine,
+			&sci_req->started_substate_machine,
 			SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_PIO_SETUP_SUBSTATE
 			);
 		break;
@@ -315,13 +315,13 @@ enum sci_status scic_sds_stp_packet_request_packet_phase_await_tc_completion_tc_
 		 * All other completion status cause the IO to be complete.  If a NAK
 		 * was received, then it is up to the user to retry the request. */
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->parent.state_machine,
+			&sci_req->parent.state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED
 			);
 		break;
@@ -336,7 +336,7 @@ enum sci_status scic_sds_stp_packet_request_packet_phase_await_tc_completion_tc_
  *    waiting for a PIO SETUP FIS.  It will release the unsolicited frame, and
  *    transition the request to the COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
  *    state.
- * @this_request: This parameter specifies the request for which the
+ * @sci_req: This parameter specifies the request for which the
  *    unsolicited frame was received.
  * @frame_index: This parameter indicates the unsolicited frame index that
  *    should contain the response.
@@ -352,12 +352,12 @@ enum sci_status scic_sds_stp_packet_request_packet_phase_await_pio_setup_frame_h
 	enum sci_status status;
 	struct sata_fis_header *frame_header;
 	u32 *frame_buffer;
-	struct scic_sds_stp_request *this_request;
+	struct scic_sds_stp_request *sci_req;
 
-	this_request = (struct scic_sds_stp_request *)request;
+	sci_req = (struct scic_sds_stp_request *)request;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(this_request->parent.owning_controller->uf_control),
+		&(sci_req->parent.owning_controller->uf_control),
 		frame_index,
 		(void **)&frame_header
 		);
@@ -369,7 +369,7 @@ enum sci_status scic_sds_stp_packet_request_packet_phase_await_pio_setup_frame_h
 		 * Get from the frame buffer the PIO Setup Data, although we don't need
 		 * any info from this pio setup fis. */
 		scic_sds_unsolicited_frame_control_get_buffer(
-			&(this_request->parent.owning_controller->uf_control),
+			&(sci_req->parent.owning_controller->uf_control),
 			frame_index,
 			(void **)&frame_buffer
 			);
@@ -378,23 +378,23 @@ enum sci_status scic_sds_stp_packet_request_packet_phase_await_pio_setup_frame_h
 		 * Get the data from the PIO Setup
 		 * The SCU Hardware returns first word in the frame_header and the rest
 		 * of the data is in the frame buffer so we need to back up one dword */
-		this_request->type.packet.device_preferred_cdb_length =
+		sci_req->type.packet.device_preferred_cdb_length =
 			(u16)((struct sata_fis_pio_setup *)(&frame_buffer[-1]))->transfter_count;
 
 		/* Frame has been decoded return it to the controller */
 		scic_sds_controller_release_frame(
-			this_request->parent.owning_controller, frame_index
+			sci_req->parent.owning_controller, frame_index
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->parent.started_substate_machine,
+			&sci_req->parent.started_substate_machine,
 			SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
 			);
 	} else
 		dev_err(scic_to_dev(request->owning_controller),
 			"%s: SCIC IO Request 0x%p could not get frame header "
 			"for frame index %d, status %x\n",
-			__func__, this_request, frame_index, status);
+			__func__, sci_req, frame_index, status);
 
 	return status;
 }
@@ -406,7 +406,7 @@ enum sci_status scic_sds_stp_packet_request_packet_phase_await_pio_setup_frame_h
  *    successfully, then the state for the packet request transits to COMPLETE
  *    state. If not successfuly, the request transits to
  *    COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE.
- * @this_request: This parameter specifies the request for which the TC
+ * @sci_req: This parameter specifies the request for which the TC
  *    completion was received.
  * @completion_code: This parameter indicates the completion status information
  *    for the TC.
@@ -415,64 +415,64 @@ enum sci_status scic_sds_stp_packet_request_packet_phase_await_pio_setup_frame_h
  * this method always returns success.
  */
 enum sci_status scic_sds_stp_packet_request_command_phase_await_tc_completion_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	enum sci_status status = SCI_SUCCESS;
 	u8 sat_packet_protocol =
-		scic_cb_request_get_sat_protocol(this_request->user_request);
+		scic_cb_request_get_sat_protocol(sci_req->user_request);
 
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case (SCU_TASK_DONE_GOOD << SCU_COMPLETION_TL_STATUS_SHIFT):
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		if (sat_packet_protocol == SAT_PROTOCOL_PACKET_DMA_DATA_IN
 		     || sat_packet_protocol == SAT_PROTOCOL_PACKET_DMA_DATA_OUT
 		     )
 			sci_base_state_machine_change_state(
-				&this_request->parent.state_machine,
+				&sci_req->parent.state_machine,
 				SCI_BASE_REQUEST_STATE_COMPLETED
 				);
 		else
 			sci_base_state_machine_change_state(
-				&this_request->started_substate_machine,
+				&sci_req->started_substate_machine,
 				SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
 				);
 		break;
 
 	case (SCU_TASK_DONE_UNEXP_FIS << SCU_COMPLETION_TL_STATUS_SHIFT):
-		if (scic_io_request_get_number_of_bytes_transferred(this_request) <
-		    scic_cb_io_request_get_transfer_length(this_request->user_request)) {
+		if (scic_io_request_get_number_of_bytes_transferred(sci_req) <
+		    scic_cb_io_request_get_transfer_length(sci_req->user_request)) {
 			scic_sds_request_set_status(
-				this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS_IO_DONE_EARLY
+				sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS_IO_DONE_EARLY
 				);
 
 			sci_base_state_machine_change_state(
-				&this_request->parent.state_machine,
+				&sci_req->parent.state_machine,
 				SCI_BASE_REQUEST_STATE_COMPLETED
 				);
 
-			status = this_request->sci_status;
+			status = sci_req->sci_status;
 		}
 		break;
 
 	case (SCU_TASK_DONE_EXCESS_DATA << SCU_COMPLETION_TL_STATUS_SHIFT):
 		/* In this case, there is no UF coming after. compelte the IO now. */
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->parent.state_machine,
+			&sci_req->parent.state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED
 			);
 
 		break;
 
 	default:
-		if (this_request->sci_status != SCI_SUCCESS) {  /* The io status was set already. This means an UF for the status
+		if (sci_req->sci_status != SCI_SUCCESS) {  /* The io status was set already. This means an UF for the status
 								 * fis was received already.
 								 */
 
@@ -480,28 +480,28 @@ enum sci_status scic_sds_stp_packet_request_command_phase_await_tc_completion_tc
 			 * A device suspension event is expected, we need to have the device
 			 * coming out of suspension, then complete the IO. */
 			sci_base_state_machine_change_state(
-				&this_request->started_substate_machine,
+				&sci_req->started_substate_machine,
 				SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE
 				);
 
 			/* change the device state to ATAPI_ERROR. */
 			sci_base_state_machine_change_state(
-				&this_request->target_device->ready_substate_machine,
+				&sci_req->target_device->ready_substate_machine,
 				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR
 				);
 
-			status = this_request->sci_status;
+			status = sci_req->sci_status;
 		} else {  /* If receiving any non-sucess TC status, no UF received yet, then an UF for
 			   * the status fis is coming after.
 			   */
 			scic_sds_request_set_status(
-				this_request,
+				sci_req,
 				SCU_TASK_DONE_CHECK_RESPONSE,
 				SCI_FAILURE_IO_RESPONSE_VALID
 				);
 
 			sci_base_state_machine_change_state(
-				&this_request->started_substate_machine,
+				&sci_req->started_substate_machine,
 				SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
 				);
 		}
@@ -514,7 +514,7 @@ enum sci_status scic_sds_stp_packet_request_command_phase_await_tc_completion_tc
 
 /**
  * This method processes an unsolicited frame.
- * @this_request: This parameter specifies the request for which the
+ * @sci_req: This parameter specifies the request for which the
  *    unsolicited frame was received.
  * @frame_index: This parameter indicates the unsolicited frame index that
  *    should contain the response.
@@ -530,12 +530,12 @@ enum sci_status scic_sds_stp_packet_request_command_phase_common_frame_handler(
 	enum sci_status status;
 	struct sata_fis_header *frame_header;
 	u32 *frame_buffer;
-	struct scic_sds_stp_request *this_request;
+	struct scic_sds_stp_request *sci_req;
 
-	this_request = (struct scic_sds_stp_request *)request;
+	sci_req = (struct scic_sds_stp_request *)request;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(this_request->parent.owning_controller->uf_control),
+		&(sci_req->parent.owning_controller->uf_control),
 		frame_index,
 		(void **)&frame_header
 		);
@@ -547,18 +547,18 @@ enum sci_status scic_sds_stp_packet_request_command_phase_common_frame_handler(
 		 * Get from the frame buffer the PIO Setup Data, although we don't need
 		 * any info from this pio setup fis. */
 		scic_sds_unsolicited_frame_control_get_buffer(
-			&(this_request->parent.owning_controller->uf_control),
+			&(sci_req->parent.owning_controller->uf_control),
 			frame_index,
 			(void **)&frame_buffer
 			);
 
 		scic_sds_controller_copy_sata_response(
-			&this_request->d2h_reg_fis, (u32 *)frame_header, frame_buffer
+			&sci_req->d2h_reg_fis, (u32 *)frame_header, frame_buffer
 			);
 
 		/* Frame has been decoded return it to the controller */
 		scic_sds_controller_release_frame(
-			this_request->parent.owning_controller, frame_index
+			sci_req->parent.owning_controller, frame_index
 			);
 	}
 
@@ -568,7 +568,7 @@ enum sci_status scic_sds_stp_packet_request_command_phase_common_frame_handler(
 /**
  * This method processes an unsolicited frame while the packet request is
  *    expecting TC completion. It will process the FIS and construct sense data.
- * @this_request: This parameter specifies the request for which the
+ * @sci_req: This parameter specifies the request for which the
  *    unsolicited frame was received.
  * @frame_index: This parameter indicates the unsolicited frame index that
  *    should contain the response.
@@ -581,7 +581,7 @@ enum sci_status scic_sds_stp_packet_request_command_phase_await_tc_completion_fr
 	struct scic_sds_request *request,
 	u32 frame_index)
 {
-	struct scic_sds_stp_request *this_request = (struct scic_sds_stp_request *)request;
+	struct scic_sds_stp_request *sci_req = (struct scic_sds_stp_request *)request;
 
 	enum sci_status status =
 		scic_sds_stp_packet_request_command_phase_common_frame_handler(
@@ -590,17 +590,17 @@ enum sci_status scic_sds_stp_packet_request_command_phase_await_tc_completion_fr
 	if (status == SCI_SUCCESS) {
 		/* The command has completed with error status from target device. */
 		status = scic_sds_stp_packet_request_process_status_fis(
-			request, &this_request->d2h_reg_fis);
+			request, &sci_req->d2h_reg_fis);
 
 		if (status != SCI_SUCCESS) {
 			scic_sds_request_set_status(
-				&this_request->parent,
+				&sci_req->parent,
 				SCU_TASK_DONE_CHECK_RESPONSE,
 				status
 				);
 		} else
 			scic_sds_request_set_status(
-				&this_request->parent, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+				&sci_req->parent, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 				);
 	}
 
@@ -611,7 +611,7 @@ enum sci_status scic_sds_stp_packet_request_command_phase_await_tc_completion_fr
 /**
  * This method processes an unsolicited frame while the packet request is
  *    expecting TC completion. It will process the FIS and construct sense data.
- * @this_request: This parameter specifies the request for which the
+ * @sci_req: This parameter specifies the request for which the
  *    unsolicited frame was received.
  * @frame_index: This parameter indicates the unsolicited frame index that
  *    should contain the response.
@@ -628,12 +628,12 @@ enum sci_status scic_sds_stp_packet_request_command_phase_await_d2h_fis_frame_ha
 		scic_sds_stp_packet_request_command_phase_common_frame_handler(
 			request, frame_index);
 
-	struct scic_sds_stp_request *this_request = (struct scic_sds_stp_request *)request;
+	struct scic_sds_stp_request *sci_req = (struct scic_sds_stp_request *)request;
 
 	if (status == SCI_SUCCESS) {
 		/* The command has completed with error status from target device. */
 		status = scic_sds_stp_packet_request_process_status_fis(
-			request, &this_request->d2h_reg_fis);
+			request, &sci_req->d2h_reg_fis);
 
 		if (status != SCI_SUCCESS) {
 			scic_sds_request_set_status(
@@ -696,26 +696,26 @@ const struct scic_sds_io_request_state_handler scic_sds_stp_packet_request_start
 void scic_sds_stp_packet_request_started_packet_phase_await_tc_completion_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_packet_request_started_substate_handler_table,
 		SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
 		);
 
 	scic_sds_remote_device_set_working_request(
-		this_request->target_device, this_request
+		sci_req->target_device, sci_req
 		);
 }
 
 void scic_sds_stp_packet_request_started_packet_phase_await_pio_setup_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_packet_request_started_substate_handler_table,
 		SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_PIO_SETUP_SUBSTATE
 		);
@@ -724,9 +724,9 @@ void scic_sds_stp_packet_request_started_packet_phase_await_pio_setup_enter(
 void scic_sds_stp_packet_request_started_command_phase_await_tc_completion_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 	u8 sat_packet_protocol =
-		scic_cb_request_get_sat_protocol(this_request->user_request);
+		scic_cb_request_get_sat_protocol(sci_req->user_request);
 
 	struct scu_task_context *task_context;
 	enum sci_status status;
@@ -735,25 +735,25 @@ void scic_sds_stp_packet_request_started_command_phase_await_tc_completion_enter
 	 * Recycle the TC and reconstruct it for sending out data fis containing
 	 * CDB. */
 	task_context = scic_sds_controller_get_task_context_buffer(
-		this_request->owning_controller, this_request->io_tag);
+		sci_req->owning_controller, sci_req->io_tag);
 
 	if (sat_packet_protocol == SAT_PROTOCOL_PACKET_NON_DATA)
 		scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context(
-			this_request, task_context);
+			sci_req, task_context);
 	else
 		scu_stp_packet_request_command_phase_construct_task_context(
-			this_request, task_context);
+			sci_req, task_context);
 
 	/* send the new TC out. */
-	status = this_request->owning_controller->state_handlers->parent.continue_io_handler(
-		&this_request->owning_controller->parent,
-		&this_request->target_device->parent,
-		&this_request->parent
+	status = sci_req->owning_controller->state_handlers->parent.continue_io_handler(
+		&sci_req->owning_controller->parent,
+		&sci_req->target_device->parent,
+		&sci_req->parent
 		);
 
 	if (status == SCI_SUCCESS)
 		SET_STATE_HANDLER(
-			this_request,
+			sci_req,
 			scic_sds_stp_packet_request_started_substate_handler_table,
 			SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
 			);
@@ -762,10 +762,10 @@ void scic_sds_stp_packet_request_started_command_phase_await_tc_completion_enter
 void scic_sds_stp_packet_request_started_command_phase_await_d2h_fis_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_packet_request_started_substate_handler_table,
 		SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
 		);
@@ -774,10 +774,10 @@ void scic_sds_stp_packet_request_started_command_phase_await_d2h_fis_enter(
 void scic_sds_stp_packet_request_started_completion_delay_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_packet_request_started_substate_handler_table,
 		SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE
 		);
diff --git a/drivers/scsi/isci/core/scic_sds_stp_packet_request.h b/drivers/scsi/isci/core/scic_sds_stp_packet_request.h
index eebfff3..f6ff5a6 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_packet_request.h
+++ b/drivers/scsi/isci/core/scic_sds_stp_packet_request.h
@@ -113,14 +113,14 @@ extern const struct scic_sds_io_request_state_handler scic_sds_stp_packet_reques
 
 #if !defined(DISABLE_ATAPI)
 enum sci_status scic_sds_stp_packet_request_construct(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 #else  /* !defined(DISABLE_ATAPI) */
 #define scic_sds_stp_packet_request_construct(request) SCI_FAILURE
 #endif /* !defined(DISABLE_ATAPI) */
 
 #if !defined(DISABLE_ATAPI)
 void scu_stp_packet_request_command_phase_construct_task_context(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	struct scu_task_context *task_context);
 #else  /* !defined(DISABLE_ATAPI) */
 #define scu_stp_packet_request_command_phase_construct_task_context(reqeust, tc)
@@ -128,7 +128,7 @@ void scu_stp_packet_request_command_phase_construct_task_context(
 
 #if !defined(DISABLE_ATAPI)
 void scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	struct scu_task_context *task_context);
 #else  /* !defined(DISABLE_ATAPI) */
 #define scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context(reqeust, tc)
@@ -136,7 +136,7 @@ void scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context(
 
 #if !defined(DISABLE_ATAPI)
 enum sci_status scic_sds_stp_packet_request_process_status_fis(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	struct sata_fis_reg_d2h *status_fis);
 #else  /* !defined(DISABLE_ATAPI) */
 #define scic_sds_stp_packet_request_process_status_fis(reqeust, fis) SCI_FAILURE
@@ -144,7 +144,7 @@ enum sci_status scic_sds_stp_packet_request_process_status_fis(
 
 #if !defined(DISABLE_ATAPI)
 void scic_sds_stp_packet_internal_request_sense_build_sgl(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 #else  /* !defined(DISABLE_ATAPI) */
 #define scic_sds_stp_packet_internal_request_sense_build_sgl(request)
 #endif /* !defined(DISABLE_ATAPI) */
diff --git a/drivers/scsi/isci/core/scic_sds_stp_remote_device.c b/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
index a5b1fe3..b15357b 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
+++ b/drivers/scsi/isci/core/scic_sds_stp_remote_device.c
@@ -252,18 +252,18 @@ out:
  * resume the RNC right away. enum sci_status
  */
 static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_event_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 event_code)
 {
 	enum sci_status status;
 
-	status = scic_sds_remote_device_general_event_handler(this_device, event_code);
+	status = scic_sds_remote_device_general_event_handler(sci_dev, event_code);
 
 	if (status == SCI_SUCCESS) {
 		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX
 		    || scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {
 			status = scic_sds_remote_node_context_resume(
-				this_device->rnc, NULL, NULL);
+				sci_dev->rnc, NULL, NULL);
 		}
 	}
 
@@ -312,21 +312,21 @@ static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_start_io_ha
 /**
  * This method will handle events received while the STP device is in the ready
  *    command substate.
- * @this_device: This is the device object that is receiving the event.
+ * @sci_dev: This is the device object that is receiving the event.
  * @event_code: The event code to process.
  *
  * enum sci_status
  */
 
 static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index)
 {
 	enum sci_status status;
 	struct sata_fis_header *frame_header;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(scic_sds_remote_device_get_controller(this_device)->uf_control),
+		&(scic_sds_remote_device_get_controller(sci_dev)->uf_control),
 		frame_index,
 		(void **)&frame_header
 		);
@@ -334,7 +334,7 @@ static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handl
 	if (status == SCI_SUCCESS) {
 		if (frame_header->fis_type == SATA_FIS_TYPE_SETDEVBITS &&
 		    (frame_header->status & ATA_STATUS_REG_ERROR_BIT)) {
-			this_device->not_ready_reason =
+			sci_dev->not_ready_reason =
 				SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
 
 			/*
@@ -343,7 +343,7 @@ static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handl
 			 */
 
 			sci_base_state_machine_change_state(
-				&this_device->ready_substate_machine,
+				&sci_dev->ready_substate_machine,
 				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR
 				);
 		} else if (frame_header->fis_type == SATA_FIS_TYPE_REGD2H &&
@@ -353,11 +353,11 @@ static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handl
 			 * Some devices return D2H FIS when an NCQ error is detected.
 			 * Treat this like an SDB error FIS ready reason.
 			 */
-			this_device->not_ready_reason =
+			sci_dev->not_ready_reason =
 				SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
 
 			sci_base_state_machine_change_state(
-				&this_device->ready_substate_machine,
+				&sci_dev->ready_substate_machine,
 				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR
 				);
 		} else {
@@ -365,7 +365,7 @@ static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handl
 		}
 
 		scic_sds_controller_release_frame(
-			scic_sds_remote_device_get_controller(this_device), frame_index
+			scic_sds_remote_device_get_controller(sci_dev), frame_index
 			);
 	}
 
@@ -393,20 +393,20 @@ static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_start_io_ha
 }
 
 static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 suspend_type)
 {
 	enum sci_status status;
 
 	status = scic_sds_remote_node_context_suspend(
-		this_device->rnc, suspend_type, NULL, NULL
+		sci_dev->rnc, suspend_type, NULL, NULL
 		);
 
 	return status;
 }
 
 static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_frame_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index)
 {
 	enum sci_status status;
@@ -416,7 +416,7 @@ static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_frame_handl
 	 * / in this state.  All unsolicited frames are forwarded to the io request
 	 * / object. */
 	status = scic_sds_io_request_frame_handler(
-		this_device->working_request,
+		sci_dev->working_request,
 		frame_index
 		);
 
@@ -461,14 +461,14 @@ static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_com
 	struct scic_sds_remote_device *device,
 	struct scic_sds_request *request)
 {
-	struct scic_sds_request *the_request = (struct scic_sds_request *)request;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)request;
 	enum sci_status status;
 
-	status = scic_sds_io_request_complete(the_request);
+	status = scic_sds_io_request_complete(sci_req);
 
 	if (status == SCI_SUCCESS) {
 		status = scic_sds_port_complete_io(
-			device->owning_port, device, the_request
+			device->owning_port, device, sci_req
 			);
 
 		if (status == SCI_SUCCESS)
@@ -482,7 +482,7 @@ static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_com
 			__func__,
 			device->owning_port,
 			device,
-			the_request,
+			sci_req,
 			status);
 
 	return status;
@@ -505,20 +505,20 @@ static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_com
  * this device. enum sci_status
  */
 enum sci_status scic_sds_stp_remote_device_ready_atapi_error_substate_event_handler(
-	struct scic_sds_remote_device *this_device,
+	struct scic_sds_remote_device *sci_dev,
 	u32 event_code)
 {
 	enum sci_status status;
 
-	status = scic_sds_remote_device_general_event_handler(this_device, event_code);
+	status = scic_sds_remote_device_general_event_handler(sci_dev, event_code);
 
 	if (status == SCI_SUCCESS) {
 		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX
 		    || scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {
 			status = scic_sds_remote_node_context_resume(
-				this_device->rnc,
-				this_device->working_request->state_handlers->parent.complete_handler,
-				(void *)this_device->working_request
+				sci_dev->rnc,
+				sci_dev->working_request->state_handlers->parent.complete_handler,
+				(void *)sci_dev->working_request
 				);
 		}
 	}
@@ -673,30 +673,30 @@ scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *use
 static void scic_sds_stp_remote_device_ready_idle_substate_enter(
 	struct sci_base_object *device)
 {
-	struct scic_sds_remote_device *this_device;
+	struct scic_sds_remote_device *sci_dev;
 
-	this_device = (struct scic_sds_remote_device *)device;
+	sci_dev = (struct scic_sds_remote_device *)device;
 
 	SET_STATE_HANDLER(
-		this_device,
+		sci_dev,
 		scic_sds_stp_remote_device_ready_substate_handler_table,
 		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE
 		);
 
-	this_device->working_request = NULL;
+	sci_dev->working_request = NULL;
 
-	if (scic_sds_remote_node_context_is_ready(this_device->rnc)) {
+	if (scic_sds_remote_node_context_is_ready(sci_dev->rnc)) {
 		/*
 		 * Since the RNC is ready, it's alright to finish completion
 		 * processing (e.g. signal the remote device is ready). */
 		scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(
-			this_device
+			sci_dev
 			);
 	} else {
 		scic_sds_remote_node_context_resume(
-			this_device->rnc,
+			sci_dev->rnc,
 			scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler,
-			this_device
+			sci_dev
 			);
 	}
 }
@@ -759,12 +759,12 @@ static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(struct sci
 static void scic_sds_stp_remote_device_ready_await_reset_substate_enter(
 	struct sci_base_object *device)
 {
-	struct scic_sds_remote_device *this_device;
+	struct scic_sds_remote_device *sci_dev;
 
-	this_device = (struct scic_sds_remote_device *)device;
+	sci_dev = (struct scic_sds_remote_device *)device;
 
 	SET_STATE_HANDLER(
-		this_device,
+		sci_dev,
 		scic_sds_stp_remote_device_ready_substate_handler_table,
 		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET
 		);
@@ -785,12 +785,12 @@ static void scic_sds_stp_remote_device_ready_await_reset_substate_enter(
 void scic_sds_stp_remote_device_ready_atapi_error_substate_enter(
 	struct sci_base_object *device)
 {
-	struct scic_sds_remote_device *this_device;
+	struct scic_sds_remote_device *sci_dev;
 
-	this_device = (struct scic_sds_remote_device *)device;
+	sci_dev = (struct scic_sds_remote_device *)device;
 
 	SET_STATE_HANDLER(
-		this_device,
+		sci_dev,
 		scic_sds_stp_remote_device_ready_substate_handler_table,
 		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR
 		);
diff --git a/drivers/scsi/isci/core/scic_sds_stp_request.c b/drivers/scsi/isci/core/scic_sds_stp_request.c
index e4ca4e4..ab01f8d 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_request.c
+++ b/drivers/scsi/isci/core/scic_sds_stp_request.c
@@ -156,7 +156,7 @@ void scic_sds_stp_request_assign_buffers(struct scic_sds_request *sci_req)
 /**
  * This method is will fill in the SCU Task Context for any type of SATA
  *    request.  This is called from the various SATA constructors.
- * @this_request: The general IO request object which is to be used in
+ * @sci_req: The general IO request object which is to be used in
  *    constructing the SCU task context.
  * @task_context: The buffer pointer for the SCU task context which is being
  *    constructed.
@@ -262,15 +262,15 @@ static void scu_sata_reqeust_construct_task_context(
 
 /**
  *
- * @this_request:
+ * @sci_req:
  *
  * This method will perform any general sata request construction. What part of
  * SATA IO request construction is general? none
  */
 static void scic_sds_stp_non_ncq_request_construct(
-	struct scic_sds_request *this_request)
+	struct scic_sds_request *sci_req)
 {
-	this_request->has_started_substate_machine = true;
+	sci_req->has_started_substate_machine = true;
 }
 
 /**
@@ -338,7 +338,7 @@ enum sci_status scic_sds_stp_ncq_request_construct(struct scic_sds_request *sci_
 
 /**
  * scu_stp_raw_request_construct_task_context -
- * @this_request: This parameter specifies the STP request object for which to
+ * @sci_req: This parameter specifies the STP request object for which to
  *    construct a RAW command frame task context.
  * @task_context: This parameter specifies the SCU specific task context buffer
  *    to construct.
@@ -347,10 +347,10 @@ enum sci_status scic_sds_stp_ncq_request_construct(struct scic_sds_request *sci_
  * utilizing the raw frame method. none
  */
 static void scu_stp_raw_request_construct_task_context(
-	struct scic_sds_stp_request *this_request,
+	struct scic_sds_stp_request *sci_req,
 	struct scu_task_context *task_context)
 {
-	scu_sata_reqeust_construct_task_context(&this_request->parent, task_context);
+	scu_sata_reqeust_construct_task_context(&sci_req->parent, task_context);
 
 	task_context->control_frame         = 0;
 	task_context->priority              = SCU_TASK_PRIORITY_NORMAL;
@@ -386,7 +386,7 @@ void *scic_stp_io_request_get_d2h_reg_address(
 
 /**
  *
- * @this_request:
+ * @sci_req:
  *
  * Get the next SGL element from the request. - Check on which SGL element pair
  * we are working - if working on SLG pair element A - advance to element B -
@@ -430,7 +430,7 @@ static struct scu_sgl_element *scic_sds_stp_request_pio_get_next_sgl(struct scic
 
 /**
  *
- * @this_request:
+ * @sci_req:
  * @completion_code:
  *
  * This method processes a TC completion.  The expected TC completion is for
@@ -439,17 +439,17 @@ static struct scu_sgl_element *scic_sds_stp_request_pio_get_next_sgl(struct scic
  * SCI_SUCCESS This value is always returned.
  */
 static enum sci_status scic_sds_stp_request_non_data_await_h2d_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->started_substate_machine,
+			&sci_req->started_substate_machine,
 			SCIC_SDS_STP_REQUEST_STARTED_NON_DATA_AWAIT_D2H_SUBSTATE
 			);
 		break;
@@ -459,13 +459,13 @@ static enum sci_status scic_sds_stp_request_non_data_await_h2d_tc_completion_han
 		 * All other completion status cause the IO to be complete.  If a NAK
 		 * was received, then it is up to the user to retry the request. */
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->state_machine, SCI_BASE_REQUEST_STATE_COMPLETED);
+			&sci_req->state_machine, SCI_BASE_REQUEST_STATE_COMPLETED);
 		break;
 	}
 
@@ -491,10 +491,10 @@ static enum sci_status scic_sds_stp_request_non_data_await_d2h_frame_handler(
 	enum sci_status status;
 	struct sata_fis_header *frame_header;
 	u32 *frame_buffer;
-	struct scic_sds_stp_request *this_request = (struct scic_sds_stp_request *)request;
+	struct scic_sds_stp_request *sci_req = (struct scic_sds_stp_request *)request;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&this_request->parent.owning_controller->uf_control,
+		&sci_req->parent.owning_controller->uf_control,
 		frame_index,
 		(void **)&frame_header
 		);
@@ -503,18 +503,18 @@ static enum sci_status scic_sds_stp_request_non_data_await_d2h_frame_handler(
 		switch (frame_header->fis_type) {
 		case SATA_FIS_TYPE_REGD2H:
 			scic_sds_unsolicited_frame_control_get_buffer(
-				&this_request->parent.owning_controller->uf_control,
+				&sci_req->parent.owning_controller->uf_control,
 				frame_index,
 				(void **)&frame_buffer
 				);
 
 			scic_sds_controller_copy_sata_response(
-				&this_request->d2h_reg_fis, (u32 *)frame_header, frame_buffer
+				&sci_req->d2h_reg_fis, (u32 *)frame_header, frame_buffer
 				);
 
 			/* The command has completed with error */
 			scic_sds_request_set_status(
-				&this_request->parent,
+				&sci_req->parent,
 				SCU_TASK_DONE_CHECK_RESPONSE,
 				SCI_FAILURE_IO_RESPONSE_VALID
 				);
@@ -524,10 +524,10 @@ static enum sci_status scic_sds_stp_request_non_data_await_d2h_frame_handler(
 			dev_warn(scic_to_dev(request->owning_controller),
 				 "%s: IO Request:0x%p Frame Id:%d protocol "
 				 "violation occurred\n",
-				 __func__, this_request, frame_index);
+				 __func__, sci_req, frame_index);
 
 			scic_sds_request_set_status(
-				&this_request->parent,
+				&sci_req->parent,
 				SCU_TASK_DONE_UNEXP_FIS,
 				SCI_FAILURE_PROTOCOL_VIOLATION
 				);
@@ -535,18 +535,18 @@ static enum sci_status scic_sds_stp_request_non_data_await_d2h_frame_handler(
 		}
 
 		sci_base_state_machine_change_state(
-			&this_request->parent.state_machine,
+			&sci_req->parent.state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED
 			);
 
 		/* Frame has been decoded return it to the controller */
 		scic_sds_controller_release_frame(
-			this_request->parent.owning_controller, frame_index);
+			sci_req->parent.owning_controller, frame_index);
 	} else
 		dev_err(scic_to_dev(request->owning_controller),
 			"%s: SCIC IO Request 0x%p could not get frame header "
 			"for frame index %d, status %x\n",
-			__func__, this_request, frame_index, status);
+			__func__, sci_req, frame_index, status);
 
 	return status;
 }
@@ -567,26 +567,26 @@ static const struct scic_sds_io_request_state_handler scic_sds_stp_request_start
 static void scic_sds_stp_request_started_non_data_await_h2d_completion_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_request_started_non_data_substate_handler_table,
 		SCIC_SDS_STP_REQUEST_STARTED_NON_DATA_AWAIT_H2D_COMPLETION_SUBSTATE
 		);
 
 	scic_sds_remote_device_set_working_request(
-		this_request->target_device, this_request
+		sci_req->target_device, sci_req
 		);
 }
 
 static void scic_sds_stp_request_started_non_data_await_d2h_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_request_started_non_data_substate_handler_table,
 		SCIC_SDS_STP_REQUEST_STARTED_NON_DATA_AWAIT_D2H_SUBSTATE
 		);
@@ -624,7 +624,7 @@ enum sci_status scic_sds_stp_non_data_request_construct(struct scic_sds_request
 
 /**
  *
- * @this_request:
+ * @sci_req:
  * @length:
  *
  * This function will transmit DATA_FIS from (current sgl + offset) for input
@@ -633,24 +633,24 @@ enum sci_status scic_sds_stp_non_data_request_construct(struct scic_sds_request
  */
 
 static enum sci_status scic_sds_stp_request_pio_data_out_trasmit_data_frame(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 length)
 {
-	struct scic_sds_stp_request *this_sds_stp_request = (struct scic_sds_stp_request *)this_request;
+	struct scic_sds_stp_request *stp_req = (struct scic_sds_stp_request *)sci_req;
 	struct scu_sgl_element *current_sgl;
 
 	/*
 	 * Recycle the TC and reconstruct it for sending out DATA FIS containing
 	 * for the data from current_sgl+offset for the input length */
 	struct scu_task_context *task_context = scic_sds_controller_get_task_context_buffer(
-		this_request->owning_controller,
-		this_request->io_tag
+		sci_req->owning_controller,
+		sci_req->io_tag
 		);
 
-	if (this_sds_stp_request->type.pio.request_current.sgl_set == SCU_SGL_ELEMENT_PAIR_A)
-		current_sgl = &(this_sds_stp_request->type.pio.request_current.sgl_pair->A);
+	if (stp_req->type.pio.request_current.sgl_set == SCU_SGL_ELEMENT_PAIR_A)
+		current_sgl = &(stp_req->type.pio.request_current.sgl_pair->A);
 	else
-		current_sgl = &(this_sds_stp_request->type.pio.request_current.sgl_pair->B);
+		current_sgl = &(stp_req->type.pio.request_current.sgl_pair->B);
 
 	/* update the TC */
 	task_context->command_iu_upper = current_sgl->address_upper;
@@ -659,17 +659,17 @@ static enum sci_status scic_sds_stp_request_pio_data_out_trasmit_data_frame(
 	task_context->type.stp.fis_type = SATA_FIS_TYPE_DATA;
 
 	/* send the new TC out. */
-	return scic_controller_continue_io(this_request);
+	return scic_controller_continue_io(sci_req);
 }
 
 /**
  *
- * @this_request:
+ * @sci_req:
  *
  * enum sci_status
  */
 static enum sci_status scic_sds_stp_request_pio_data_out_transmit_data(
-	struct scic_sds_request *this_sds_request)
+	struct scic_sds_request *sci_req)
 {
 
 	struct scu_sgl_element *current_sgl;
@@ -677,45 +677,45 @@ static enum sci_status scic_sds_stp_request_pio_data_out_transmit_data(
 	u32 remaining_bytes_in_current_sgl = 0;
 	enum sci_status status = SCI_SUCCESS;
 
-	struct scic_sds_stp_request *this_sds_stp_request = (struct scic_sds_stp_request *)this_sds_request;
+	struct scic_sds_stp_request *stp_req = (struct scic_sds_stp_request *)sci_req;
 
-	sgl_offset = this_sds_stp_request->type.pio.request_current.sgl_offset;
+	sgl_offset = stp_req->type.pio.request_current.sgl_offset;
 
-	if (this_sds_stp_request->type.pio.request_current.sgl_set == SCU_SGL_ELEMENT_PAIR_A) {
-		current_sgl = &(this_sds_stp_request->type.pio.request_current.sgl_pair->A);
-		remaining_bytes_in_current_sgl = this_sds_stp_request->type.pio.request_current.sgl_pair->A.length - sgl_offset;
+	if (stp_req->type.pio.request_current.sgl_set == SCU_SGL_ELEMENT_PAIR_A) {
+		current_sgl = &(stp_req->type.pio.request_current.sgl_pair->A);
+		remaining_bytes_in_current_sgl = stp_req->type.pio.request_current.sgl_pair->A.length - sgl_offset;
 	} else {
-		current_sgl = &(this_sds_stp_request->type.pio.request_current.sgl_pair->B);
-		remaining_bytes_in_current_sgl = this_sds_stp_request->type.pio.request_current.sgl_pair->B.length - sgl_offset;
+		current_sgl = &(stp_req->type.pio.request_current.sgl_pair->B);
+		remaining_bytes_in_current_sgl = stp_req->type.pio.request_current.sgl_pair->B.length - sgl_offset;
 	}
 
 
-	if (this_sds_stp_request->type.pio.pio_transfer_bytes > 0) {
-		if (this_sds_stp_request->type.pio.pio_transfer_bytes >= remaining_bytes_in_current_sgl) {
+	if (stp_req->type.pio.pio_transfer_bytes > 0) {
+		if (stp_req->type.pio.pio_transfer_bytes >= remaining_bytes_in_current_sgl) {
 			/* recycle the TC and send the H2D Data FIS from (current sgl + sgl_offset) and length = remaining_bytes_in_current_sgl */
-			status = scic_sds_stp_request_pio_data_out_trasmit_data_frame(this_sds_request, remaining_bytes_in_current_sgl);
+			status = scic_sds_stp_request_pio_data_out_trasmit_data_frame(sci_req, remaining_bytes_in_current_sgl);
 			if (status == SCI_SUCCESS) {
-				this_sds_stp_request->type.pio.pio_transfer_bytes -= remaining_bytes_in_current_sgl;
+				stp_req->type.pio.pio_transfer_bytes -= remaining_bytes_in_current_sgl;
 
 				/* update the current sgl, sgl_offset and save for future */
-				current_sgl = scic_sds_stp_request_pio_get_next_sgl(this_sds_stp_request);
+				current_sgl = scic_sds_stp_request_pio_get_next_sgl(stp_req);
 				sgl_offset = 0;
 			}
-		} else if (this_sds_stp_request->type.pio.pio_transfer_bytes < remaining_bytes_in_current_sgl) {
+		} else if (stp_req->type.pio.pio_transfer_bytes < remaining_bytes_in_current_sgl) {
 			/* recycle the TC and send the H2D Data FIS from (current sgl + sgl_offset) and length = type.pio.pio_transfer_bytes */
-			scic_sds_stp_request_pio_data_out_trasmit_data_frame(this_sds_request, this_sds_stp_request->type.pio.pio_transfer_bytes);
+			scic_sds_stp_request_pio_data_out_trasmit_data_frame(sci_req, stp_req->type.pio.pio_transfer_bytes);
 
 			if (status == SCI_SUCCESS) {
 				/* Sgl offset will be adjusted and saved for future */
-				sgl_offset += this_sds_stp_request->type.pio.pio_transfer_bytes;
-				current_sgl->address_lower += this_sds_stp_request->type.pio.pio_transfer_bytes;
-				this_sds_stp_request->type.pio.pio_transfer_bytes = 0;
+				sgl_offset += stp_req->type.pio.pio_transfer_bytes;
+				current_sgl->address_lower += stp_req->type.pio.pio_transfer_bytes;
+				stp_req->type.pio.pio_transfer_bytes = 0;
 			}
 		}
 	}
 
 	if (status == SCI_SUCCESS) {
-		this_sds_stp_request->type.pio.request_current.sgl_offset = sgl_offset;
+		stp_req->type.pio.request_current.sgl_offset = sgl_offset;
 	}
 
 	return status;
@@ -772,13 +772,13 @@ scic_sds_stp_request_pio_data_in_copy_data_buffer(struct scic_sds_stp_request *s
 
 /**
  *
- * @this_request: The PIO DATA IN request that is to receive the data.
+ * @sci_req: The PIO DATA IN request that is to receive the data.
  * @data_buffer: The buffer to copy from.
  *
  * Copy the data buffer to the io request data region. enum sci_status
  */
 static enum sci_status scic_sds_stp_request_pio_data_in_copy_data(
-	struct scic_sds_stp_request *this_request,
+	struct scic_sds_stp_request *sci_req,
 	u8 *data_buffer)
 {
 	enum sci_status status;
@@ -786,19 +786,19 @@ static enum sci_status scic_sds_stp_request_pio_data_in_copy_data(
 	/*
 	 * If there is less than 1K remaining in the transfer request
 	 * copy just the data for the transfer */
-	if (this_request->type.pio.pio_transfer_bytes < SCU_MAX_FRAME_BUFFER_SIZE) {
+	if (sci_req->type.pio.pio_transfer_bytes < SCU_MAX_FRAME_BUFFER_SIZE) {
 		status = scic_sds_stp_request_pio_data_in_copy_data_buffer(
-			this_request, data_buffer, this_request->type.pio.pio_transfer_bytes);
+			sci_req, data_buffer, sci_req->type.pio.pio_transfer_bytes);
 
 		if (status == SCI_SUCCESS)
-			this_request->type.pio.pio_transfer_bytes = 0;
+			sci_req->type.pio.pio_transfer_bytes = 0;
 	} else {
 		/* We are transfering the whole frame so copy */
 		status = scic_sds_stp_request_pio_data_in_copy_data_buffer(
-			this_request, data_buffer, SCU_MAX_FRAME_BUFFER_SIZE);
+			sci_req, data_buffer, SCU_MAX_FRAME_BUFFER_SIZE);
 
 		if (status == SCI_SUCCESS)
-			this_request->type.pio.pio_transfer_bytes -= SCU_MAX_FRAME_BUFFER_SIZE;
+			sci_req->type.pio.pio_transfer_bytes -= SCU_MAX_FRAME_BUFFER_SIZE;
 	}
 
 	return status;
@@ -806,13 +806,13 @@ static enum sci_status scic_sds_stp_request_pio_data_in_copy_data(
 
 /**
  *
- * @this_request:
+ * @sci_req:
  * @completion_code:
  *
  * enum sci_status
  */
 static enum sci_status scic_sds_stp_request_pio_await_h2d_completion_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	enum sci_status status = SCI_SUCCESS;
@@ -820,11 +820,11 @@ static enum sci_status scic_sds_stp_request_pio_await_h2d_completion_tc_completi
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->started_substate_machine,
+			&sci_req->started_substate_machine,
 			SCIC_SDS_STP_REQUEST_STARTED_PIO_AWAIT_FRAME_SUBSTATE
 			);
 		break;
@@ -834,13 +834,13 @@ static enum sci_status scic_sds_stp_request_pio_await_h2d_completion_tc_completi
 		 * All other completion status cause the IO to be complete.  If a NAK
 		 * was received, then it is up to the user to retry the request. */
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->state_machine,
+			&sci_req->state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED
 			);
 		break;
@@ -851,7 +851,7 @@ static enum sci_status scic_sds_stp_request_pio_await_h2d_completion_tc_completi
 
 /**
  *
- * @this_request:
+ * @sci_req:
  * @frame_index:
  *
  * enum sci_status
@@ -863,12 +863,12 @@ static enum sci_status scic_sds_stp_request_pio_await_frame_frame_handler(
 	enum sci_status status;
 	struct sata_fis_header *frame_header;
 	u32 *frame_buffer;
-	struct scic_sds_stp_request *this_request;
+	struct scic_sds_stp_request *sci_req;
 
-	this_request = (struct scic_sds_stp_request *)request;
+	sci_req = (struct scic_sds_stp_request *)request;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(this_request->parent.owning_controller->uf_control),
+		&(sci_req->parent.owning_controller->uf_control),
 		frame_index,
 		(void **)&frame_header
 		);
@@ -878,7 +878,7 @@ static enum sci_status scic_sds_stp_request_pio_await_frame_frame_handler(
 		case SATA_FIS_TYPE_PIO_SETUP:
 			/* Get from the frame buffer the PIO Setup Data */
 			scic_sds_unsolicited_frame_control_get_buffer(
-				&(this_request->parent.owning_controller->uf_control),
+				&(sci_req->parent.owning_controller->uf_control),
 				frame_index,
 				(void **)&frame_buffer
 				);
@@ -887,30 +887,30 @@ static enum sci_status scic_sds_stp_request_pio_await_frame_frame_handler(
 			 * Get the data from the PIO Setup
 			 * The SCU Hardware returns first word in the frame_header and the rest
 			 * of the data is in the frame buffer so we need to back up one dword */
-			this_request->type.pio.pio_transfer_bytes =
+			sci_req->type.pio.pio_transfer_bytes =
 				(u16)((struct sata_fis_pio_setup *)(&frame_buffer[-1]))->transfter_count;
-			this_request->type.pio.ending_status =
+			sci_req->type.pio.ending_status =
 				(u8)((struct sata_fis_pio_setup *)(&frame_buffer[-1]))->ending_status;
 
 			scic_sds_controller_copy_sata_response(
-				&this_request->d2h_reg_fis, (u32 *)frame_header, frame_buffer
+				&sci_req->d2h_reg_fis, (u32 *)frame_header, frame_buffer
 				);
 
-			this_request->d2h_reg_fis.status =
-				this_request->type.pio.ending_status;
+			sci_req->d2h_reg_fis.status =
+				sci_req->type.pio.ending_status;
 
 			/* The next state is dependent on whether the request was PIO Data-in or Data out */
-			if (this_request->type.pio.sat_protocol == SAT_PROTOCOL_PIO_DATA_IN) {
+			if (sci_req->type.pio.sat_protocol == SAT_PROTOCOL_PIO_DATA_IN) {
 				sci_base_state_machine_change_state(
-					&this_request->parent.started_substate_machine,
+					&sci_req->parent.started_substate_machine,
 					SCIC_SDS_STP_REQUEST_STARTED_PIO_DATA_IN_AWAIT_DATA_SUBSTATE
 					);
-			} else if (this_request->type.pio.sat_protocol == SAT_PROTOCOL_PIO_DATA_OUT) {
+			} else if (sci_req->type.pio.sat_protocol == SAT_PROTOCOL_PIO_DATA_OUT) {
 				/* Transmit data */
 				status = scic_sds_stp_request_pio_data_out_transmit_data(request);
 				if (status == SCI_SUCCESS) {
 					sci_base_state_machine_change_state(
-						&this_request->parent.started_substate_machine,
+						&sci_req->parent.started_substate_machine,
 						SCIC_SDS_STP_REQUEST_STARTED_PIO_DATA_OUT_TRANSMIT_DATA_SUBSTATE
 						);
 				}
@@ -919,7 +919,7 @@ static enum sci_status scic_sds_stp_request_pio_await_frame_frame_handler(
 
 		case SATA_FIS_TYPE_SETDEVBITS:
 			sci_base_state_machine_change_state(
-				&this_request->parent.started_substate_machine,
+				&sci_req->parent.started_substate_machine,
 				SCIC_SDS_STP_REQUEST_STARTED_PIO_AWAIT_FRAME_SUBSTATE
 				);
 			break;
@@ -927,22 +927,22 @@ static enum sci_status scic_sds_stp_request_pio_await_frame_frame_handler(
 		case SATA_FIS_TYPE_REGD2H:
 			if ((frame_header->status & ATA_STATUS_REG_BSY_BIT) == 0) {
 				scic_sds_unsolicited_frame_control_get_buffer(
-					&(this_request->parent.owning_controller->uf_control),
+					&(sci_req->parent.owning_controller->uf_control),
 					frame_index,
 					(void **)&frame_buffer
 					);
 
 				scic_sds_controller_copy_sata_response(
-					&this_request->d2h_reg_fis, (u32 *)frame_header, frame_buffer);
+					&sci_req->d2h_reg_fis, (u32 *)frame_header, frame_buffer);
 
 				scic_sds_request_set_status(
-					&this_request->parent,
+					&sci_req->parent,
 					SCU_TASK_DONE_CHECK_RESPONSE,
 					SCI_FAILURE_IO_RESPONSE_VALID
 					);
 
 				sci_base_state_machine_change_state(
-					&this_request->parent.state_machine,
+					&sci_req->parent.state_machine,
 					SCI_BASE_REQUEST_STATE_COMPLETED
 					);
 			} else {
@@ -954,7 +954,7 @@ static enum sci_status scic_sds_stp_request_pio_await_frame_frame_handler(
 					"D2H Register FIS with BSY status "
 					"0x%x\n",
 					__func__,
-					this_request,
+					sci_req,
 					frame_header->status);
 			}
 			break;
@@ -965,21 +965,21 @@ static enum sci_status scic_sds_stp_request_pio_await_frame_frame_handler(
 
 		/* Frame is decoded return it to the controller */
 		scic_sds_controller_release_frame(
-			this_request->parent.owning_controller,
+			sci_req->parent.owning_controller,
 			frame_index
 			);
 	} else
 		dev_err(scic_to_dev(request->owning_controller),
 			"%s: SCIC IO Request 0x%p could not get frame header "
 			"for frame index %d, status %x\n",
-			__func__, this_request, frame_index, status);
+			__func__, sci_req, frame_index, status);
 
 	return status;
 }
 
 /**
  *
- * @this_request:
+ * @sci_req:
  * @frame_index:
  *
  * enum sci_status
@@ -991,33 +991,33 @@ static enum sci_status scic_sds_stp_request_pio_data_in_await_data_frame_handler
 	enum sci_status status;
 	struct sata_fis_header *frame_header;
 	struct sata_fis_data *frame_buffer;
-	struct scic_sds_stp_request *this_request;
+	struct scic_sds_stp_request *sci_req;
 
-	this_request = (struct scic_sds_stp_request *)request;
+	sci_req = (struct scic_sds_stp_request *)request;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(this_request->parent.owning_controller->uf_control),
+		&(sci_req->parent.owning_controller->uf_control),
 		frame_index,
 		(void **)&frame_header
 		);
 
 	if (status == SCI_SUCCESS) {
 		if (frame_header->fis_type == SATA_FIS_TYPE_DATA) {
-			if (this_request->type.pio.request_current.sgl_pair == NULL) {
-				this_request->parent.saved_rx_frame_index = frame_index;
-				this_request->type.pio.pio_transfer_bytes = 0;
+			if (sci_req->type.pio.request_current.sgl_pair == NULL) {
+				sci_req->parent.saved_rx_frame_index = frame_index;
+				sci_req->type.pio.pio_transfer_bytes = 0;
 			} else {
 				status = scic_sds_unsolicited_frame_control_get_buffer(
-					&(this_request->parent.owning_controller->uf_control),
+					&(sci_req->parent.owning_controller->uf_control),
 					frame_index,
 					(void **)&frame_buffer
 					);
 
-				status = scic_sds_stp_request_pio_data_in_copy_data(this_request, (u8 *)frame_buffer);
+				status = scic_sds_stp_request_pio_data_in_copy_data(sci_req, (u8 *)frame_buffer);
 
 				/* Frame is decoded return it to the controller */
 				scic_sds_controller_release_frame(
-					this_request->parent.owning_controller,
+					sci_req->parent.owning_controller,
 					frame_index
 					);
 			}
@@ -1027,17 +1027,17 @@ static enum sci_status scic_sds_stp_request_pio_data_in_await_data_frame_handler
 			 * for this data transfer */
 			if (
 				(status == SCI_SUCCESS)
-				&& (this_request->type.pio.pio_transfer_bytes == 0)
+				&& (sci_req->type.pio.pio_transfer_bytes == 0)
 				) {
-				if ((this_request->type.pio.ending_status & ATA_STATUS_REG_BSY_BIT) == 0) {
+				if ((sci_req->type.pio.ending_status & ATA_STATUS_REG_BSY_BIT) == 0) {
 					scic_sds_request_set_status(
-						&this_request->parent,
+						&sci_req->parent,
 						SCU_TASK_DONE_CHECK_RESPONSE,
 						SCI_FAILURE_IO_RESPONSE_VALID
 						);
 
 					sci_base_state_machine_change_state(
-						&this_request->parent.state_machine,
+						&sci_req->parent.state_machine,
 						SCI_BASE_REQUEST_STATE_COMPLETED
 						);
 				} else {
@@ -1053,24 +1053,24 @@ static enum sci_status scic_sds_stp_request_pio_data_in_await_data_frame_handler
 				"with fis type 0x%02x when expecting a data "
 				"fis.\n",
 				__func__,
-				this_request,
+				sci_req,
 				frame_index,
 				frame_header->fis_type);
 
 			scic_sds_request_set_status(
-				&this_request->parent,
+				&sci_req->parent,
 				SCU_TASK_DONE_GOOD,
 				SCI_FAILURE_IO_REQUIRES_SCSI_ABORT
 				);
 
 			sci_base_state_machine_change_state(
-				&this_request->parent.state_machine,
+				&sci_req->parent.state_machine,
 				SCI_BASE_REQUEST_STATE_COMPLETED
 				);
 
 			/* Frame is decoded return it to the controller */
 			scic_sds_controller_release_frame(
-				this_request->parent.owning_controller,
+				sci_req->parent.owning_controller,
 				frame_index
 				);
 		}
@@ -1078,7 +1078,7 @@ static enum sci_status scic_sds_stp_request_pio_data_in_await_data_frame_handler
 		dev_err(scic_to_dev(request->owning_controller),
 			"%s: SCIC IO Request 0x%p could not get frame header "
 			"for frame index %d, status %x\n",
-			__func__, this_request, frame_index, status);
+			__func__, sci_req, frame_index, status);
 
 	return status;
 }
@@ -1086,31 +1086,31 @@ static enum sci_status scic_sds_stp_request_pio_data_in_await_data_frame_handler
 
 /**
  *
- * @this_request:
+ * @sci_req:
  * @completion_code:
  *
  * enum sci_status
  */
 static enum sci_status scic_sds_stp_request_pio_data_out_await_data_transmit_completion_tc_completion_handler(
 
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	enum sci_status status                     = SCI_SUCCESS;
 	bool all_frames_transferred     = false;
 
-	struct scic_sds_stp_request *this_scic_sds_stp_request = (struct scic_sds_stp_request *)this_request;
+	struct scic_sds_stp_request *stp_req = (struct scic_sds_stp_request *)sci_req;
 
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
 		/* Transmit data */
-		if (this_scic_sds_stp_request->type.pio.pio_transfer_bytes != 0) {
-			status = scic_sds_stp_request_pio_data_out_transmit_data(this_request);
+		if (stp_req->type.pio.pio_transfer_bytes != 0) {
+			status = scic_sds_stp_request_pio_data_out_transmit_data(sci_req);
 			if (status == SCI_SUCCESS) {
-				if (this_scic_sds_stp_request->type.pio.pio_transfer_bytes == 0)
+				if (stp_req->type.pio.pio_transfer_bytes == 0)
 					all_frames_transferred = true;
 			}
-		} else if (this_scic_sds_stp_request->type.pio.pio_transfer_bytes == 0) {
+		} else if (stp_req->type.pio.pio_transfer_bytes == 0) {
 			/*
 			 * this will happen if the all data is written at the
 			 * first time after the pio setup fis is received
@@ -1124,7 +1124,7 @@ static enum sci_status scic_sds_stp_request_pio_data_out_await_data_transmit_com
 			 * Change the state to SCIC_SDS_STP_REQUEST_STARTED_PIO_DATA_IN_AWAIT_FRAME_SUBSTATE
 			 * and wait for PIO_SETUP fis / or D2H REg fis. */
 			sci_base_state_machine_change_state(
-				&this_request->started_substate_machine,
+				&sci_req->started_substate_machine,
 				SCIC_SDS_STP_REQUEST_STARTED_PIO_AWAIT_FRAME_SUBSTATE
 				);
 		}
@@ -1135,13 +1135,13 @@ static enum sci_status scic_sds_stp_request_pio_data_out_await_data_transmit_com
 		 * All other completion status cause the IO to be complete.  If a NAK
 		 * was received, then it is up to the user to retry the request. */
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->state_machine,
+			&sci_req->state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED
 			);
 		break;
@@ -1217,25 +1217,25 @@ static const struct scic_sds_io_request_state_handler scic_sds_stp_request_start
 static void scic_sds_stp_request_started_pio_await_h2d_completion_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_request_started_pio_substate_handler_table,
 		SCIC_SDS_STP_REQUEST_STARTED_PIO_AWAIT_H2D_COMPLETION_SUBSTATE
 		);
 
 	scic_sds_remote_device_set_working_request(
-		this_request->target_device, this_request);
+		sci_req->target_device, sci_req);
 }
 
 static void scic_sds_stp_request_started_pio_await_frame_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_request_started_pio_substate_handler_table,
 		SCIC_SDS_STP_REQUEST_STARTED_PIO_AWAIT_FRAME_SUBSTATE
 		);
@@ -1244,10 +1244,10 @@ static void scic_sds_stp_request_started_pio_await_frame_enter(
 static void scic_sds_stp_request_started_pio_data_in_await_data_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_request_started_pio_substate_handler_table,
 		SCIC_SDS_STP_REQUEST_STARTED_PIO_DATA_IN_AWAIT_DATA_SUBSTATE
 		);
@@ -1256,10 +1256,10 @@ static void scic_sds_stp_request_started_pio_data_in_await_data_enter(
 static void scic_sds_stp_request_started_pio_data_out_transmit_data_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_request_started_pio_substate_handler_table,
 		SCIC_SDS_STP_REQUEST_STARTED_PIO_DATA_OUT_TRANSMIT_DATA_SUBSTATE
 		);
@@ -1333,13 +1333,13 @@ static void scic_sds_stp_request_udma_complete_request(
 
 /**
  *
- * @this_request:
+ * @sci_req:
  * @frame_index:
  *
  * enum sci_status
  */
 static enum sci_status scic_sds_stp_request_udma_general_frame_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 frame_index)
 {
 	enum sci_status status;
@@ -1347,7 +1347,7 @@ static enum sci_status scic_sds_stp_request_udma_general_frame_handler(
 	u32 *frame_buffer;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&this_request->owning_controller->uf_control,
+		&sci_req->owning_controller->uf_control,
 		frame_index,
 		(void **)&frame_header
 		);
@@ -1357,20 +1357,20 @@ static enum sci_status scic_sds_stp_request_udma_general_frame_handler(
 		&& (frame_header->fis_type == SATA_FIS_TYPE_REGD2H)
 		) {
 		scic_sds_unsolicited_frame_control_get_buffer(
-			&this_request->owning_controller->uf_control,
+			&sci_req->owning_controller->uf_control,
 			frame_index,
 			(void **)&frame_buffer
 			);
 
 		scic_sds_controller_copy_sata_response(
-			&((struct scic_sds_stp_request *)this_request)->d2h_reg_fis,
+			&((struct scic_sds_stp_request *)sci_req)->d2h_reg_fis,
 			(u32 *)frame_header,
 			frame_buffer
 			);
 	}
 
 	scic_sds_controller_release_frame(
-		this_request->owning_controller, frame_index);
+		sci_req->owning_controller, frame_index);
 
 	return status;
 }
@@ -1378,7 +1378,7 @@ static enum sci_status scic_sds_stp_request_udma_general_frame_handler(
 /**
  * This method process TC completions while in the state where we are waiting
  *    for TC completions.
- * @this_request:
+ * @sci_req:
  * @completion_code:
  *
  * enum sci_status
@@ -1388,12 +1388,12 @@ static enum sci_status scic_sds_stp_request_udma_await_tc_completion_tc_completi
 	u32 completion_code)
 {
 	enum sci_status status = SCI_SUCCESS;
-	struct scic_sds_stp_request *this_request = (struct scic_sds_stp_request *)request;
+	struct scic_sds_stp_request *sci_req = (struct scic_sds_stp_request *)request;
 
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
 		scic_sds_stp_request_udma_complete_request(
-			&this_request->parent, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			&sci_req->parent, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 		break;
 
@@ -1402,14 +1402,14 @@ static enum sci_status scic_sds_stp_request_udma_await_tc_completion_tc_completi
 		/*
 		 * We must check ther response buffer to see if the D2H Register FIS was
 		 * received before we got the TC completion. */
-		if (this_request->d2h_reg_fis.fis_type == SATA_FIS_TYPE_REGD2H) {
+		if (sci_req->d2h_reg_fis.fis_type == SATA_FIS_TYPE_REGD2H) {
 			scic_sds_remote_device_suspend(
-				this_request->parent.target_device,
+				sci_req->parent.target_device,
 				SCU_EVENT_SPECIFIC(SCU_NORMALIZE_COMPLETION_STATUS(completion_code))
 				);
 
 			scic_sds_stp_request_udma_complete_request(
-				&this_request->parent,
+				&sci_req->parent,
 				SCU_TASK_DONE_CHECK_RESPONSE,
 				SCI_FAILURE_IO_RESPONSE_VALID
 				);
@@ -1418,7 +1418,7 @@ static enum sci_status scic_sds_stp_request_udma_await_tc_completion_tc_completi
 			 * If we have an error completion status for the TC then we can expect a
 			 * D2H register FIS from the device so we must change state to wait for it */
 			sci_base_state_machine_change_state(
-				&this_request->parent.started_substate_machine,
+				&sci_req->parent.started_substate_machine,
 				SCIC_SDS_STP_REQUEST_STARTED_UDMA_AWAIT_D2H_REG_FIS_SUBSTATE
 				);
 		}
@@ -1434,14 +1434,14 @@ static enum sci_status scic_sds_stp_request_udma_await_tc_completion_tc_completi
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_CMD_LL_R_ERR):
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_CRC_ERR):
 		scic_sds_remote_device_suspend(
-			this_request->parent.target_device,
+			sci_req->parent.target_device,
 			SCU_EVENT_SPECIFIC(SCU_NORMALIZE_COMPLETION_STATUS(completion_code))
 			);
 	/* Fall through to the default case */
 	default:
 		/* All other completion status cause the IO to be complete. */
 		scic_sds_stp_request_udma_complete_request(
-			&this_request->parent,
+			&sci_req->parent,
 			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
@@ -1452,17 +1452,17 @@ static enum sci_status scic_sds_stp_request_udma_await_tc_completion_tc_completi
 }
 
 static enum sci_status scic_sds_stp_request_udma_await_d2h_reg_fis_frame_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 frame_index)
 {
 	enum sci_status status;
 
 	/* Use the general frame handler to copy the resposne data */
-	status = scic_sds_stp_request_udma_general_frame_handler(this_request, frame_index);
+	status = scic_sds_stp_request_udma_general_frame_handler(sci_req, frame_index);
 
 	if (status == SCI_SUCCESS) {
 		scic_sds_stp_request_udma_complete_request(
-			this_request,
+			sci_req,
 			SCU_TASK_DONE_CHECK_RESPONSE,
 			SCI_FAILURE_IO_RESPONSE_VALID
 			);
@@ -1488,10 +1488,10 @@ static const struct scic_sds_io_request_state_handler scic_sds_stp_request_start
 static void scic_sds_stp_request_started_udma_await_tc_completion_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_request_started_udma_substate_handler_table,
 		SCIC_SDS_STP_REQUEST_STARTED_UDMA_AWAIT_TC_COMPLETION_SUBSTATE
 		);
@@ -1507,10 +1507,10 @@ static void scic_sds_stp_request_started_udma_await_tc_completion_enter(
 static void scic_sds_stp_request_started_udma_await_d2h_reg_fis_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_request_started_udma_substate_handler_table,
 		SCIC_SDS_STP_REQUEST_STARTED_UDMA_AWAIT_D2H_REG_FIS_SUBSTATE
 		);
@@ -1548,7 +1548,7 @@ enum sci_status scic_sds_stp_udma_request_construct(struct scic_sds_request *sci
 
 /**
  *
- * @this_request:
+ * @sci_req:
  * @completion_code:
  *
  * This method processes a TC completion.  The expected TC completion is for
@@ -1557,17 +1557,17 @@ enum sci_status scic_sds_stp_udma_request_construct(struct scic_sds_request *sci
  * SCI_SUCCESS This value is always returned.
  */
 static enum sci_status scic_sds_stp_request_soft_reset_await_h2d_asserted_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->started_substate_machine,
+			&sci_req->started_substate_machine,
 			SCIC_SDS_STP_REQUEST_STARTED_SOFT_RESET_AWAIT_H2D_DIAGNOSTIC_COMPLETION_SUBSTATE
 			);
 		break;
@@ -1577,13 +1577,13 @@ static enum sci_status scic_sds_stp_request_soft_reset_await_h2d_asserted_tc_com
 		 * All other completion status cause the IO to be complete.  If a NAK
 		 * was received, then it is up to the user to retry the request. */
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->state_machine, SCI_BASE_REQUEST_STATE_COMPLETED);
+			&sci_req->state_machine, SCI_BASE_REQUEST_STATE_COMPLETED);
 		break;
 	}
 
@@ -1592,7 +1592,7 @@ static enum sci_status scic_sds_stp_request_soft_reset_await_h2d_asserted_tc_com
 
 /**
  *
- * @this_request:
+ * @sci_req:
  * @completion_code:
  *
  * This method processes a TC completion.  The expected TC completion is for
@@ -1601,17 +1601,17 @@ static enum sci_status scic_sds_stp_request_soft_reset_await_h2d_asserted_tc_com
  * SCI_SUCCESS This value is always returned.
  */
 static enum sci_status scic_sds_stp_request_soft_reset_await_h2d_diagnostic_tc_completion_handler(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 completion_code)
 {
 	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
 	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
 		scic_sds_request_set_status(
-			this_request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
+			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
 			);
 
 		sci_base_state_machine_change_state(
-			&this_request->started_substate_machine,
+			&sci_req->started_substate_machine,
 			SCIC_SDS_STP_REQUEST_STARTED_SOFT_RESET_AWAIT_D2H_RESPONSE_FRAME_SUBSTATE
 			);
 		break;
@@ -1621,12 +1621,12 @@ static enum sci_status scic_sds_stp_request_soft_reset_await_h2d_diagnostic_tc_c
 		 * All other completion status cause the IO to be complete.  If a NAK
 		 * was received, then it is up to the user to retry the request. */
 		scic_sds_request_set_status(
-			this_request,
+			sci_req,
 			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
 			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
 			);
 
-		sci_base_state_machine_change_state(&this_request->state_machine,
+		sci_base_state_machine_change_state(&sci_req->state_machine,
 				SCI_BASE_REQUEST_STATE_COMPLETED);
 		break;
 	}
@@ -1653,10 +1653,10 @@ static enum sci_status scic_sds_stp_request_soft_reset_await_d2h_frame_handler(
 	enum sci_status status;
 	struct sata_fis_header *frame_header;
 	u32 *frame_buffer;
-	struct scic_sds_stp_request *this_request = (struct scic_sds_stp_request *)request;
+	struct scic_sds_stp_request *sci_req = (struct scic_sds_stp_request *)request;
 
 	status = scic_sds_unsolicited_frame_control_get_header(
-		&(this_request->parent.owning_controller->uf_control),
+		&(sci_req->parent.owning_controller->uf_control),
 		frame_index,
 		(void **)&frame_header
 		);
@@ -1665,18 +1665,18 @@ static enum sci_status scic_sds_stp_request_soft_reset_await_d2h_frame_handler(
 		switch (frame_header->fis_type) {
 		case SATA_FIS_TYPE_REGD2H:
 			scic_sds_unsolicited_frame_control_get_buffer(
-				&(this_request->parent.owning_controller->uf_control),
+				&(sci_req->parent.owning_controller->uf_control),
 				frame_index,
 				(void **)&frame_buffer
 				);
 
 			scic_sds_controller_copy_sata_response(
-				&this_request->d2h_reg_fis, (u32 *)frame_header, frame_buffer
+				&sci_req->d2h_reg_fis, (u32 *)frame_header, frame_buffer
 				);
 
 			/* The command has completed with error */
 			scic_sds_request_set_status(
-				&this_request->parent,
+				&sci_req->parent,
 				SCU_TASK_DONE_CHECK_RESPONSE,
 				SCI_FAILURE_IO_RESPONSE_VALID
 				);
@@ -1687,11 +1687,11 @@ static enum sci_status scic_sds_stp_request_soft_reset_await_d2h_frame_handler(
 				 "%s: IO Request:0x%p Frame Id:%d protocol "
 				 "violation occurred\n",
 				 __func__,
-				 this_request,
+				 sci_req,
 				 frame_index);
 
 			scic_sds_request_set_status(
-				&this_request->parent,
+				&sci_req->parent,
 				SCU_TASK_DONE_UNEXP_FIS,
 				SCI_FAILURE_PROTOCOL_VIOLATION
 				);
@@ -1699,18 +1699,18 @@ static enum sci_status scic_sds_stp_request_soft_reset_await_d2h_frame_handler(
 		}
 
 		sci_base_state_machine_change_state(
-			&this_request->parent.state_machine,
+			&sci_req->parent.state_machine,
 			SCI_BASE_REQUEST_STATE_COMPLETED);
 
 		/* Frame has been decoded return it to the controller */
 		scic_sds_controller_release_frame(
-			this_request->parent.owning_controller, frame_index
+			sci_req->parent.owning_controller, frame_index
 			);
 	} else
 		dev_err(scic_to_dev(request->owning_controller),
 			"%s: SCIC IO Request 0x%p could not get frame header "
 			"for frame index %d, status %x\n",
-			__func__, this_request, frame_index, status);
+			__func__, sci_req, frame_index, status);
 
 	return status;
 }
@@ -1735,40 +1735,40 @@ static const struct scic_sds_io_request_state_handler scic_sds_stp_request_start
 static void scic_sds_stp_request_started_soft_reset_await_h2d_asserted_completion_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_request_started_soft_reset_substate_handler_table,
 		SCIC_SDS_STP_REQUEST_STARTED_SOFT_RESET_AWAIT_H2D_ASSERTED_COMPLETION_SUBSTATE
 		);
 
 	scic_sds_remote_device_set_working_request(
-		this_request->target_device, this_request
+		sci_req->target_device, sci_req
 		);
 }
 
 static void scic_sds_stp_request_started_soft_reset_await_h2d_diagnostic_completion_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 	struct scu_task_context *task_context;
 	struct sata_fis_reg_h2d *h2d_fis;
 	enum sci_status status;
 
 	/* Clear the SRST bit */
-	h2d_fis = scic_stp_io_request_get_h2d_reg_address(this_request);
+	h2d_fis = scic_stp_io_request_get_h2d_reg_address(sci_req);
 	h2d_fis->control = 0;
 
 	/* Clear the TC control bit */
 	task_context = scic_sds_controller_get_task_context_buffer(
-		this_request->owning_controller, this_request->io_tag);
+		sci_req->owning_controller, sci_req->io_tag);
 	task_context->control_frame = 0;
 
-	status = scic_controller_continue_io(this_request);
+	status = scic_controller_continue_io(sci_req);
 	if (status == SCI_SUCCESS) {
 		SET_STATE_HANDLER(
-			this_request,
+			sci_req,
 			scic_sds_stp_request_started_soft_reset_substate_handler_table,
 			SCIC_SDS_STP_REQUEST_STARTED_SOFT_RESET_AWAIT_H2D_DIAGNOSTIC_COMPLETION_SUBSTATE
 			);
@@ -1778,10 +1778,10 @@ static void scic_sds_stp_request_started_soft_reset_await_h2d_diagnostic_complet
 static void scic_sds_stp_request_started_soft_reset_await_d2h_response_enter(
 	struct sci_base_object *object)
 {
-	struct scic_sds_request *this_request = (struct scic_sds_request *)object;
+	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
 
 	SET_STATE_HANDLER(
-		this_request,
+		sci_req,
 		scic_sds_stp_request_started_soft_reset_substate_handler_table,
 		SCIC_SDS_STP_REQUEST_STARTED_SOFT_RESET_AWAIT_D2H_RESPONSE_FRAME_SUBSTATE
 		);
diff --git a/drivers/scsi/isci/core/scic_sds_stp_request.h b/drivers/scsi/isci/core/scic_sds_stp_request.h
index a6c02d3..6724c1d 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_request.h
+++ b/drivers/scsi/isci/core/scic_sds_stp_request.h
@@ -177,18 +177,18 @@ enum sci_status scic_sds_stp_pio_request_construct(
 	bool copy_rx_frame);
 
 enum sci_status scic_sds_stp_udma_request_construct(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 transfer_length,
 	enum dma_data_direction dir);
 
 enum sci_status scic_sds_stp_non_data_request_construct(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 
 enum sci_status scic_sds_stp_soft_reset_request_construct(
-	struct scic_sds_request *this_request);
+	struct scic_sds_request *sci_req);
 
 enum sci_status scic_sds_stp_ncq_request_construct(
-	struct scic_sds_request *this_request,
+	struct scic_sds_request *sci_req,
 	u32 transfer_length,
 	enum dma_data_direction dir);
 
-- 
1.6.0.2

