From: Mauro Carvalho Chehab <mchehab@redhat.com>
Subject: i7core_edac: Adds write unlock to MC registers
References: fate#311968
Git-commit: e9bd2e73793bf0f7fcd8f94b532bb8f5c5b44171
Patch-mainline: v2.6.35-rc2


Signed-off-by: Thomas Renninger <trenn@suse.de>

The public Intel Xeon 5500 volume 2 datasheet describes, on page 53,
session 2.6.7 a register that can lock/unlock Memory Controller the
configuration register, called MC_CFG_CONTROL.

Adds support for it in the hope that software error injection would
work. With my tests with Xeon 35xx, there's still something missing.
With a program that does sequencial bit writes at dev 0.0, sometimes, it
produces error injection, after unblocking the MC_CFG_CONTROL (and,
sometimes, it just locks my testing machine).

I'll try later to discover by trial and error what's the register that
solves this issue on Xeon 35xx.

Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

---
 drivers/edac/i7core_edac.c |   30 +++++++++++++++++++++++++++---
 include/linux/pci_ids.h    |    1 +
 2 files changed, 28 insertions(+), 3 deletions(-)

Index: linux-2.6.32-SLE11-SP1/drivers/edac/i7core_edac.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/edac/i7core_edac.c
+++ linux-2.6.32-SLE11-SP1/drivers/edac/i7core_edac.c
@@ -34,7 +34,7 @@
 #include "edac_core.h"
 
 /* To use the new pci_[read/write]_config_qword instead of two dword */
-#define USE_QWORD 1
+#define USE_QWORD 0
 
 /* trenn: Temporary function which gets removed with later patches.
    Code may be broken for some patches, but at least compiles for bisecting */
@@ -68,6 +68,10 @@ static inline int pci_read_config_qword(
  * i7core Memory Controller Registers
  */
 
+	/* OFFSETS for Device 0 Function 0 */
+
+#define MC_CFG_CONTROL	0x90
+
 	/* OFFSETS for Device 3 Function 0 */
 
 #define MC_CONTROL	0x48
@@ -196,6 +200,7 @@ struct pci_id_descr {
 };
 
 struct i7core_pvt {
+	struct pci_dev		*pci_noncore;
 	struct pci_dev		*pci_mcr[MAX_MCR_FUNC + 1];
 	struct pci_dev		*pci_ch[NUM_CHANS][MAX_CHAN_FUNC + 1];
 	struct i7core_info	info;
@@ -232,6 +237,9 @@ struct pci_id_descr pci_devs[] = {
 	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS)  }, /* if RDIMM is supported */
 	{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_I7_MC_TEST) },
 
+		/* Generic Non-core registers */
+	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NOCORE)  },
+
 		/* Channel 0 */
 	{ PCI_DESCR(4, 0, PCI_DEVICE_ID_INTEL_I7_MC_CH0_CTRL) },
 	{ PCI_DESCR(4, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH0_ADDR) },
@@ -892,6 +900,16 @@ static ssize_t i7core_inject_enable_stor
 	else
 		mask |= (pvt->inject.col & 0x3fffL);
 
+	/* Unlock writes to registers */
+	pci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, 0x2);
+	msleep(100);
+
+	/* Zeroes error count registers */
+	pci_write_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV1, 0);
+	pci_write_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV0, 0);
+	pvt->ce_count_available = 0;
+
+
 #if USE_QWORD
 	pci_write_config_qword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, mask);
@@ -939,12 +957,15 @@ static ssize_t i7core_inject_enable_stor
 	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, injectmask);
 
+#if 0
+	/* lock writes to registers */
+	pci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, 0);
+#endif
 	debugf0("Error inject addr match 0x%016llx, ecc 0x%08x,"
 		" inject 0x%08x\n",
 		mask, pvt->inject.eccmask, injectmask);
 
 
-
 	return count;
 }
 
@@ -1134,12 +1155,15 @@ static int mci_bind_devs(struct mem_ctl_
 			if (unlikely(func > MAX_CHAN_FUNC))
 				goto error;
 			pvt->pci_ch[slot - 4][func] = pdev;
-		} else
+		} else if (!slot && !func)
+			pvt->pci_noncore = pdev;
+		else
 			goto error;
 
 		debugf0("Associated fn %d.%d, dev = %p\n",
 			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn), pdev);
 	}
+
 	return 0;
 
 error:
Index: linux-2.6.32-SLE11-SP1/include/linux/pci_ids.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/pci_ids.h
+++ linux-2.6.32-SLE11-SP1/include/linux/pci_ids.h
@@ -2555,6 +2555,7 @@
 #define PCI_DEVICE_ID_INTEL_I7_MC_CH2_ADDR  0x2c31
 #define PCI_DEVICE_ID_INTEL_I7_MC_CH2_RANK  0x2c32
 #define PCI_DEVICE_ID_INTEL_I7_MC_CH2_TC    0x2c33
+#define PCI_DEVICE_ID_INTEL_I7_NOCORE	0x2c41
 #define PCI_DEVICE_ID_INTEL_82855PM_HB	0x3340
 #define PCI_DEVICE_ID_INTEL_IOAT_TBG4	0x3429
 #define PCI_DEVICE_ID_INTEL_IOAT_TBG5	0x342a
