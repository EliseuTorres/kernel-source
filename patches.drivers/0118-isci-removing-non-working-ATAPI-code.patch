From: Dave Jiang <dave.jiang@intel.com>
Date: Tue, 26 Apr 2011 12:31:37 -0700
Subject: [PATCH 118/273] isci: removing non-working ATAPI code
Git-commit: 3d6e428c0cd8d234bab0ac93aff9ccffacc8bc7e
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Removing not used / bit-rotten ATAPI code. This needs to go back
and debugged at a later date.

Signed-off-by: Dave Jiang <dave.jiang@intel.com>
[reflow against devel, delete dead sati headers]
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/Makefile                         |    4 -
 drivers/scsi/isci/core/sati_device.h               |  156 ----
 drivers/scsi/isci/core/sati_translator_sequence.h  |  304 --------
 drivers/scsi/isci/core/sati_types.h                |  145 ----
 drivers/scsi/isci/core/scic_sds_request.c          |   14 -
 .../scsi/isci/core/scic_sds_stp_packet_request.c   |  805 --------------------
 .../scsi/isci/core/scic_sds_stp_packet_request.h   |   39 -
 drivers/scsi/isci/remote_device.c                  |   60 --
 drivers/scsi/isci/remote_device.h                  |   38 -
 drivers/scsi/isci/stp_remote_device.c              |   94 ---
 10 files changed, 0 insertions(+), 1659 deletions(-)
 delete mode 100644 drivers/scsi/isci/core/sati_device.h
 delete mode 100644 drivers/scsi/isci/core/sati_translator_sequence.h
 delete mode 100644 drivers/scsi/isci/core/sati_types.h
 delete mode 100644 drivers/scsi/isci/core/scic_sds_stp_packet_request.c

diff --git a/drivers/scsi/isci/Makefile b/drivers/scsi/isci/Makefile
index ccc8c53..fc50ba3 100644
--- a/drivers/scsi/isci/Makefile
+++ b/drivers/scsi/isci/Makefile
@@ -2,9 +2,6 @@
 #generation of silicon
 EXTRA_CFLAGS += -DSCIC_SDS_4_ENABLED
 
-#temporary until atapi support ready
-EXTRA_CFLAGS += -DDISABLE_ATAPI
-
 EXTRA_CFLAGS += -Idrivers/scsi/isci/core/ -Idrivers/scsi/isci/
 obj-$(CONFIG_SCSI_ISCI) += isci.o
 isci-objs := init.o phy.o request.o sata.o \
@@ -17,7 +14,6 @@ isci-objs := init.o phy.o request.o sata.o \
 	     core/scic_sds_controller.o  \
 	     core/scic_sds_request.o \
 	     core/scic_sds_stp_request.o \
-	     core/scic_sds_stp_packet_request.o \
 	     core/scic_sds_port.o \
 	     core/scic_sds_port_configuration_agent.o \
 	     core/scic_sds_phy.o \
diff --git a/drivers/scsi/isci/core/sati_device.h b/drivers/scsi/isci/core/sati_device.h
deleted file mode 100644
index 4d1cfde..0000000
--- a/drivers/scsi/isci/core/sati_device.h
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SATI_DEVICE_H_
-#define _SATI_DEVICE_H_
-
-/**
- * This file contains all of the defintions for the SATI remote device object.
- *    Some translations require information to be remembered on a per device
- *    basis.  This information is stored in the object defined in this file.
- *
- *
- */
-
-#include "sati_types.h"
-#include "intel_ata.h"
-
-/**
- * enum _SATI_DEVICE_STATE - This enumeration depicts the various states
- *    possible for the a translation remote device object.
- *
- *
- */
-enum sati_device_state {
-	SATI_DEVICE_STATE_OPERATIONAL,
-	SATI_DEVICE_STATE_STOPPED,
-	SATI_DEVICE_STATE_STANDBY,
-	SATI_DEVICE_STATE_IDLE,
-	SATI_DEVICE_STATE_DEVICE_FAULT_OCCURRED,
-	SATI_DEVICE_STATE_FORMAT_UNIT_IN_PROGRESS,
-	SATI_DEVICE_STATE_SELF_TEST_IN_PROGRESS,
-	SATI_DEVICE_STATE_SEQUENCE_INCOMPLETE,
-	SATI_DEVICE_STATE_UNIT_ATTENTION_CONDITION
-
-};
-
-/**
- *
- *
- * SATI_DEVICE_CAPABILITIES These constants define the various capabilities
- * that a remote device may support for which there is an impact on translation.
- */
-#define SATI_DEVICE_CAP_UDMA_ENABLE          0x00000001
-#define SATI_DEVICE_CAP_NCQ_REQUESTED_ENABLE 0x00000002
-#define SATI_DEVICE_CAP_NCQ_SUPPORTED_ENABLE 0x00000004
-#define SATI_DEVICE_CAP_48BIT_ENABLE         0x00000008
-#define SATI_DEVICE_CAP_DMA_FUA_ENABLE       0x00000010
-#define SATI_DEVICE_CAP_SMART_SUPPORT        0x00000020
-#define SATI_DEVICE_CAP_REMOVABLE_MEDIA      0x00000040
-#define SATI_DEVICE_CAP_SMART_ENABLE         0x00000080
-#define SATI_DEVICE_CAP_WRITE_UNCORRECTABLE_ENABLE           0x00000100
-#define SATI_DEVICE_CAP_MULTIPLE_SECTORS_PER_PHYSCIAL_SECTOR 0x00000200
-#define SATI_DEVICE_CAP_SMART_SELF_TEST_SUPPORT              0x00000400
-
-
-/**
- * struct sati_device - The SATI_DEVICE structure define the state of the
- *    remote device with respect to translation.
- *
- *
- */
-struct sati_device {
-	/**
-	 * This field simply dictates the state of the SATI device.
-	 */
-	enum sati_device_state state;
-
-	/**
-	 * This field indicates features supported by the remote device that
-	 * impact translation execution.
-	 */
-	u16 capabilities;
-
-	/**
-	 * This field indicates the depth of the native command queue supported
-	 * by the device.
-	 */
-	u8 ncq_depth;
-
-	/**
-	 * This field stores the additional sense code for a unit attention
-	 * condition.
-	 */
-	u8 unit_attention_asc;
-
-	/**
-	 * This field indicates the additional sense code qualifier for a unit
-	 * attention condition.
-	 */
-	u8 unit_attention_ascq;
-
-};
-
-void sati_device_construct(
-	struct sati_device *device,
-	bool is_ncq_enabled,
-	u8 max_ncq_depth);
-
-void sati_device_update_capabilities(
-	struct sati_device *device,
-	struct ata_identify_device_data *identify);
-
-#endif /* _SATI_TRANSLATOR_SEQUENCE_H_ */
-
diff --git a/drivers/scsi/isci/core/sati_translator_sequence.h b/drivers/scsi/isci/core/sati_translator_sequence.h
deleted file mode 100644
index 915724c..0000000
--- a/drivers/scsi/isci/core/sati_translator_sequence.h
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SATI_TRANSLATOR_SEQUENCE_H_
-#define _SATI_TRANSLATOR_SEQUENCE_H_
-
-/**
- * This file contains all of the defintions for the SATI translator sequence.
- *    A translator sequence is simply a defintion for the various sequences of
- *    commands that occur in this translator.
- *
- *
- */
-
-#include "sati_device.h"
-
-/**
- * enum _sati_translator_sequence_type - This enumeration defines the possible
- *    sequence types for the translator.
- *
- *
- */
-enum sati_translator_sequence_type {
-	/* SCSI Primary Command (SPC) sequences. */
-	SATI_SEQUENCE_REPORT_LUNS,
-	SATI_SEQUENCE_TEST_UNIT_READY,
-	SATI_SEQUENCE_INQUIRY_STANDARD,
-	SATI_SEQUENCE_INQUIRY_SUPPORTED_PAGES,
-	SATI_SEQUENCE_INQUIRY_SERIAL_NUMBER,
-	SATI_SEQUENCE_INQUIRY_DEVICE_ID,
-	SATI_SEQUENCE_INQUIRY_BLOCK_DEVICE,
-	SATI_SEQUENCE_MODE_SENSE_6_CACHING,
-	SATI_SEQUENCE_MODE_SENSE_6_INFORMATIONAL_EXCP_CONTROL,
-	SATI_SEQUENCE_MODE_SENSE_6_READ_WRITE_ERROR,
-	SATI_SEQUENCE_MODE_SENSE_6_DISCONNECT_RECONNECT,
-	SATI_SEQUENCE_MODE_SENSE_6_CONTROL,
-	SATI_SEQUENCE_MODE_SENSE_6_ALL_PAGES,
-	SATI_SEQUENCE_MODE_SENSE_10_CACHING,
-	SATI_SEQUENCE_MODE_SENSE_10_INFORMATIONAL_EXCP_CONTROL,
-	SATI_SEQUENCE_MODE_SENSE_10_READ_WRITE_ERROR,
-	SATI_SEQUENCE_MODE_SENSE_10_DISCONNECT_RECONNECT,
-	SATI_SEQUENCE_MODE_SENSE_10_CONTROL,
-	SATI_SEQUENCE_MODE_SENSE_10_ALL_PAGES,
-	SATI_SEQUENCE_MODE_SELECT_MODE_PAGE_CACHING,
-	SATI_SEQUENCE_MODE_SELECT_MODE_POWER_CONDITION,
-	SATI_SEQUENCE_MODE_SELECT_MODE_INFORMATION_EXCEPT_CONTROL,
-
-	/* Log Sense Sequences */
-	SATI_SEQUENCE_LOG_SENSE_SELF_TEST_LOG_PAGE,
-	SATI_SEQUENCE_LOG_SENSE_EXTENDED_SELF_TEST_LOG_PAGE,
-	SATI_SEQUENCE_LOG_SENSE_SUPPORTED_LOG_PAGE,
-	SATI_SEQUENCE_LOG_SENSE_INFO_EXCEPTION_LOG_PAGE,
-
-	/* SCSI Block Command (SBC) sequences. */
-
-	SATI_SEQUENCE_READ_6,
-	SATI_SEQUENCE_READ_10,
-	SATI_SEQUENCE_READ_12,
-	SATI_SEQUENCE_READ_16,
-
-	SATI_SEQUENCE_READ_CAPACITY_10,
-	SATI_SEQUENCE_READ_CAPACITY_16,
-
-	SATI_SEQUENCE_SYNCHRONIZE_CACHE,
-
-	SATI_SEQUENCE_VERIFY_10,
-	SATI_SEQUENCE_VERIFY_12,
-	SATI_SEQUENCE_VERIFY_16,
-
-	SATI_SEQUENCE_WRITE_6,
-	SATI_SEQUENCE_WRITE_10,
-	SATI_SEQUENCE_WRITE_12,
-	SATI_SEQUENCE_WRITE_16,
-
-	SATI_SEQUENCE_START_STOP_UNIT,
-
-	SATI_SEQUENCE_REASSIGN_BLOCKS,
-
-	/* SCSI Task Requests sequences */
-
-	SATI_SEQUENCE_LUN_RESET,
-
-	SATI_SEQUENCE_REQUEST_SENSE_SMART_RETURN_STATUS,
-	SATI_SEQUENCE_REQUEST_SENSE_CHECK_POWER_MODE,
-
-	SATI_SEQUENCE_WRITE_LONG
-
-};
-
-#define SATI_SEQUENCE_TYPE_READ_MIN SATI_SEQUENCE_READ_6
-#define SATI_SEQUENCE_TYPE_READ_MAX SATI_SEQUENCE_READ_16
-
-/**
- *
- *
- * SATI_SEQUENCE_STATES These constants depict the various state values
- * associated with a translation sequence.
- */
-#define SATI_SEQUENCE_STATE_INITIAL        0
-#define SATI_SEQUENCE_STATE_TRANSLATE_DATA 1
-#define SATI_SEQUENCE_STATE_AWAIT_RESPONSE 2
-#define SATI_SEQUENCE_STATE_FINAL          3
-#define SATI_SEQUENCE_STATE_INCOMPLETE     4
-
-/**
- *
- *
- * SATI_DATA_DIRECTIONS These constants depict the various types of data
- * directions for a translation sequence.  Data can flow in/out (read/write) or
- * no data at all.
- */
-#define SATI_DATA_DIRECTION_NONE 0
-#define SATI_DATA_DIRECTION_IN   1
-#define SATI_DATA_DIRECTION_OUT  2
-
-/**
- * struct SATI_MODE_SELECT_PROCESSING_STATE - This structure contains all of
- *    the current processing states for processing mode select 6 and 10
- *    commands' parameter fields.
- *
- *
- */
-struct sati_mode_select_processing_state {
-	u8 *mode_pages;
-	u32 mode_page_offset;
-	u32 mode_pages_size;
-	u32 size_of_data_processed;
-	u32 total_ata_command_sent;
-	u32 ata_command_sent_for_cmp; /* cmp: current mode page */
-	bool current_mode_page_processed;
-};
-
-
-enum sati_reassign_blocks_ata_command_status {
-	SATI_REASSIGN_BLOCKS_READY_TO_SEND,
-	SATI_REASSIGN_BLOCKS_COMMAND_FAIL,
-	SATI_REASSIGN_BLOCKS_COMMAND_SUCCESS,
-};
-
-/**
- * struct sati_reassign_blocks_processing_state - This structure contains all
- *    of the current processing states for processing reassign block command's
- *    parameter fields.
- *
- *
- */
-struct sati_reassign_blocks_processing_state {
-	u32 lba_offset;
-	u32 block_lists_size;
-	u8 lba_size;
-	u32 size_of_data_processed;
-	u32 ata_command_sent_for_current_lba;
-	bool current_lba_processed;
-	enum  sati_reassign_blocks_ata_command_status ata_command_status;
-
-};
-
-#define SATI_ATAPI_REQUEST_SENSE_CDB_LENGTH 12
-
-/**
- * struct sati_atapi_data - The SATI_ATAPI_DATA structure is for sati atapi IO
- *    specific data.
- *
- *
- */
-struct sati_atapi_data {
-	u8 request_sense_cdb[SATI_ATAPI_REQUEST_SENSE_CDB_LENGTH];
-};
-
-/**
- * struct sati_translator_sequence - This structure contains all of the
- *    translation information associated with a particular request.
- *
- *
- */
-struct sati_translator_sequence {
-	/**
-	 * This field contains the sequence type determined by the SATI.
-	 */
-	u8 type;
-
-	/**
-	 * This field indicates the current state for the sequence.
-	 */
-	u8 state;
-
-	/**
-	 * This field indicates the data direction (none, read, or write) for
-	 * the translated request.
-	 */
-	u8 data_direction;
-
-	/**
-	 * This field contains the SATA/ATA protocol to be utilized during
-	 * the IO transfer.
-	 */
-	u8 protocol;
-
-	/**
-	 * This field is utilized for sequences requiring data translation.
-	 * It specifies the amount of data requested by the caller from the
-	 * operation.  It's necessary, because at times the user requests less
-	 * data than is available.  Thus, we need to avoid overrunning the
-	 * buffer.
-	 */
-	u32 allocation_length;
-
-	/**
-	 * This field specifies the amount of data that will actually be
-	 * transfered across the wire for this ATA request.
-	 */
-	u32 ata_transfer_length;
-
-	/**
-	 * This field specifies the amount of data bytes that have been
-	 * set in a translation sequence. It will be incremented every time
-	 * a data byte has been set by a sati translation.
-	 */
-	u16 number_data_bytes_set;
-
-	/**
-	 * This field indicates whether or not the sense response has been set
-	 * by the translation sequence.
-	 */
-	bool is_sense_response_set;
-
-	/**
-	 * This field specifies the remote device context for which this
-	 * translator sequence is destined.
-	 */
-	struct sati_device *device;
-
-	/**
-	 * This field is utilized to provide the translator with memory space
-	 * required for translations that utilize multiple requests.
-	 */
-	union {
-		u32 translated_command;
-		u32 move_sector_count;
-		u32 scratch;
-		struct sati_reassign_blocks_processing_state
-			reassign_blocks_process_state;
-		struct sati_mode_select_processing_state process_state;
-		struct sati_atapi_data sati_atapi_data;
-	} command_specific_data;
-
-};
-
-
-
-#endif /* _SATI_TRANSLATOR_SEQUENCE_H_ */
-
diff --git a/drivers/scsi/isci/core/sati_types.h b/drivers/scsi/isci/core/sati_types.h
deleted file mode 100644
index b6159e0..0000000
--- a/drivers/scsi/isci/core/sati_types.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _SATI_TYPES_H_
-#define _SATI_TYPES_H_
-
-/**
- * This file contains various type definitions to be utilized with SCSI to ATA
- *    Translation Implementation.
- *
- *
- */
-
-/**
- * enum _SATI_STATUS - This enumeration defines the possible return values from
- *    the SATI translation methods.
- *
- *
- */
-enum sati_status {
-	/**
-	 * This indicates that the translation was supported and occurred
-	 * without error.
-	 */
-	SATI_SUCCESS,
-
-	/**
-	 * This indicates that the translation was supported, occurred without
-	 * error, and no additional translation is necessary.  This is done in
-	 * conditions where the SCSI command doesn't require any interaction with
-	 * the remote device.
-	 */
-	SATI_COMPLETE,
-
-	/**
-	 * This indicated everything SATI_COMPLETE does in addition to the response data
-	 * not using all the memory allocated by the OS.
-	 */
-	SATI_COMPLETE_IO_DONE_EARLY,
-
-	/**
-	 * This indicates that translator sequence has finished some specific
-	 * command in the sequence, but additional commands are necessary.
-	 */
-	SATI_SEQUENCE_INCOMPLETE,
-
-	/**
-	 * This indicates a general failure has occurred for which no further
-	 * specification information is available.
-	 */
-	SATI_FAILURE,
-
-	/**
-	 * This indicates that the result of the IO request indicates a
-	 * failure.  The caller should reference the corresponding response
-	 * data for further details.
-	 */
-	SATI_FAILURE_CHECK_RESPONSE_DATA,
-
-	/**
-	 * This status indicates that the supplied sequence type doesn't map
-	 * to an existing definition.
-	 */
-	SATI_FAILURE_INVALID_SEQUENCE_TYPE,
-
-	/**
-	 * This status indicates that the supplied sequence state doesn't match
-	 * the operation being requested by the user.
-	 */
-	SATI_FAILURE_INVALID_STATE
-
-};
-
-#if (!defined(DISABLE_SATI_MODE_SENSE)	    \
-	|| !defined(DISABLE_SATI_MODE_SELECT)	  \
-	|| !defined(DISABLE_SATI_REQUEST_SENSE)) \
-
-#if !defined(ENABLE_SATI_MODE_PAGES)
-/**
- *
- *
- * This macro enables the common mode page data structures and code. Currently,
- * MODE SENSE, MODE SELECT, and REQUEST SENSE all make reference to this common
- * code.  As a result, enable the common mode page code if any of these 3 are
- * being translated.
- */
-#define ENABLE_SATI_MODE_PAGES
-#endif  /* !defined(ENABLE_SATI_MODE_PAGES) */
-
-#endif  /* MODE_SENSE/SELECT/REQUEST_SENSE */
-
-#endif  /* _SATI_TYPES_H_ */
-
diff --git a/drivers/scsi/isci/core/scic_sds_request.c b/drivers/scsi/isci/core/scic_sds_request.c
index a66e7b2..395080d 100644
--- a/drivers/scsi/isci/core/scic_sds_request.c
+++ b/drivers/scsi/isci/core/scic_sds_request.c
@@ -73,10 +73,6 @@
 #include "scu_constants.h"
 #include "scu_task_context.h"
 
-#if !defined(DISABLE_ATAPI)
-#include "scic_sds_stp_packet_request.h"
-#endif
-
 /*
  * ****************************************************************************
  * * SCIC SDS IO REQUEST CONSTANTS
@@ -670,16 +666,6 @@ static enum sci_status scic_io_request_construct_sata(struct scic_sds_request *s
 		status = scic_sds_stp_ncq_request_construct(sci_req, len, dir);
 		break;
 
-#if !defined(DISABLE_ATAPI)
-	case SAT_PROTOCOL_PACKET_NON_DATA:
-	case SAT_PROTOCOL_PACKET_DMA_DATA_IN:
-	case SAT_PROTOCOL_PACKET_DMA_DATA_OUT:
-	case SAT_PROTOCOL_PACKET_PIO_DATA_IN:
-	case SAT_PROTOCOL_PACKET_PIO_DATA_OUT:
-		status = scic_sds_stp_packet_request_construct(sci_req);
-		break;
-#endif
-
 	case SAT_PROTOCOL_DMA_QUEUED:
 	case SAT_PROTOCOL_DMA:
 	case SAT_PROTOCOL_DEVICE_DIAGNOSTIC:
diff --git a/drivers/scsi/isci/core/scic_sds_stp_packet_request.c b/drivers/scsi/isci/core/scic_sds_stp_packet_request.c
deleted file mode 100644
index 1cb77bb..0000000
--- a/drivers/scsi/isci/core/scic_sds_stp_packet_request.c
+++ /dev/null
@@ -1,805 +0,0 @@
-/*
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * BSD LICENSE
- *
- * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *   * Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- *   * Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in
- *     the documentation and/or other materials provided with the
- *     distribution.
- *   * Neither the name of Intel Corporation nor the names of its
- *     contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#if !defined(DISABLE_ATAPI)
-
-#include "intel_ata.h"
-#include "intel_sas.h"
-#include "intel_sata.h"
-#include "intel_sat.h"
-#include "sati_translator_sequence.h"
-#include "sci_base_state.h"
-#include "scic_controller.h"
-#include "scic_sds_controller.h"
-#include "remote_device.h"
-#include "scic_sds_request.h"
-#include "scic_sds_stp_packet_request.h"
-#include "scic_user_callback.h"
-#include "sci_util.h"
-#include "scu_completion_codes.h"
-#include "scu_task_context.h"
-
-
-/**
- * This method will fill in the SCU Task Context for a PACKET fis. And
- *    construct the request STARTED sub-state machine for Packet Protocol IO.
- * @sci_req: This parameter specifies the stp packet request object being
- *    constructed.
- *
- */
-enum sci_status scic_sds_stp_packet_request_construct(
-	struct scic_sds_request *sci_req)
-{
-	struct sata_fis_reg_h2d *h2d_fis =
-		scic_stp_io_request_get_h2d_reg_address(
-			sci_req
-			);
-
-	/*
-	 * Work around, we currently only support PACKET DMA protocol, so we
-	 * need to make change to Packet Fis features field. */
-	h2d_fis->features = h2d_fis->features | ATA_PACKET_FEATURE_DMA;
-
-	scic_sds_stp_non_ncq_request_construct(sci_req);
-
-	/* Build the Packet Fis task context structure */
-	scu_stp_raw_request_construct_task_context(
-		(struct scic_sds_stp_request *)sci_req,
-		sci_req->task_context_buffer
-		);
-
-	sci_base_state_machine_construct(
-		&sci_req->started_substate_machine,
-		&sci_req->parent.parent,
-		scic_sds_stp_packet_request_started_substate_table,
-		SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
-		);
-
-	return SCI_SUCCESS;
-}
-
-
-/**
- * This method will fill in the SCU Task Context for a Packet request command
- *    phase in PACKET DMA DATA (IN/OUT) type. The following important settings
- *    are utilized: -# task_type == SCU_TASK_TYPE_PACKET_DMA.  This simply
- *    indicates that a normal request type (i.e. non-raw frame) is being
- *    utilized to perform task management. -# control_frame == 1.  This ensures
- *    that the proper endianess is set so that the bytes are transmitted in the
- *    right order for a smp request frame.
- * @sci_req: This parameter specifies the smp request object being
- *    constructed.
- * @task_context: The task_context to be reconstruct for packet request command
- *    phase.
- *
- */
-void scu_stp_packet_request_command_phase_construct_task_context(
-	struct scic_sds_request *sci_req,
-	struct scu_task_context *task_context)
-{
-	void *atapi_cdb;
-	u32 atapi_cdb_length;
-	struct scic_sds_stp_request *stp_request = (struct scic_sds_stp_request *)sci_req;
-
-	/*
-	 * reference: SSTL 1.13.4.2
-	 * task_type, sata_direction */
-	if (scic_cb_io_request_get_data_direction(sci_req->user_request)
-	     == SCI_IO_REQUEST_DATA_OUT) {
-		task_context->task_type = SCU_TASK_TYPE_PACKET_DMA_OUT;
-		task_context->sata_direction = 0;
-	} else {  /* todo: for NO_DATA command, we need to send out raw frame. */
-		task_context->task_type = SCU_TASK_TYPE_PACKET_DMA_IN;
-		task_context->sata_direction = 1;
-	}
-
-	/* sata header */
-	memset(&(task_context->type.stp), 0, sizeof(struct stp_task_context));
-	task_context->type.stp.fis_type = SATA_FIS_TYPE_DATA;
-
-	/*
-	 * Copy in the command IU with CDB so that the commandIU address doesn't
-	 * change. */
-	memset(sci_req->command_buffer, 0, sizeof(struct sata_fis_reg_h2d));
-
-	atapi_cdb =
-		scic_cb_stp_packet_io_request_get_cdb_address(sci_req->user_request);
-
-	atapi_cdb_length =
-		scic_cb_stp_packet_io_request_get_cdb_length(sci_req->user_request);
-
-	memcpy(((u8 *)sci_req->command_buffer + sizeof(u32)), atapi_cdb, atapi_cdb_length);
-
-	atapi_cdb_length =
-		max(atapi_cdb_length, stp_request->type.packet.device_preferred_cdb_length);
-
-	task_context->ssp_command_iu_length =
-		((atapi_cdb_length % 4) == 0) ?
-		(atapi_cdb_length / 4) : ((atapi_cdb_length / 4) + 1);
-
-	/* task phase is set to TX_CMD */
-	task_context->task_phase = 0x1;
-
-	/* retry counter */
-	task_context->stp_retry_count = 0;
-
-	if (scic_cb_request_is_initial_construction(sci_req->user_request)) {
-		/* data transfer size. */
-		task_context->transfer_length_bytes =
-			scic_cb_io_request_get_transfer_length(sci_req->user_request);
-
-		/* setup sgl */
-		scic_sds_request_build_sgl(sci_req);
-	} else {
-		/* data transfer size, need to be 4 bytes aligned. */
-		task_context->transfer_length_bytes = (SCSI_FIXED_SENSE_DATA_BASE_LENGTH + 2);
-
-		scic_sds_stp_packet_internal_request_sense_build_sgl(sci_req);
-	}
-}
-
-/**
- * This method will fill in the SCU Task Context for a DATA fis containing CDB
- *    in Raw Frame type. The TC for previous Packet fis was already there, we
- *    only need to change the H2D fis content.
- * @sci_req: This parameter specifies the smp request object being
- *    constructed.
- * @task_context: The task_context to be reconstruct for packet request command
- *    phase.
- *
- */
-void scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context(
-	struct scic_sds_request *sci_req,
-	struct scu_task_context *task_context)
-{
-	void *atapi_cdb =
-		scic_cb_stp_packet_io_request_get_cdb_address(sci_req->user_request);
-
-	u32 atapi_cdb_length =
-		scic_cb_stp_packet_io_request_get_cdb_length(sci_req->user_request);
-
-	memset(sci_req->command_buffer, 0, sizeof(struct sata_fis_reg_h2d));
-	memcpy(((u8 *)sci_req->command_buffer + sizeof(u32)), atapi_cdb, atapi_cdb_length);
-
-	memset(&(task_context->type.stp), 0, sizeof(struct stp_task_context));
-	task_context->type.stp.fis_type = SATA_FIS_TYPE_DATA;
-
-	/*
-	 * Note the data send out has to be 4 bytes aligned. Or else out hardware will
-	 * patch non-zero bytes and cause the target device unhappy. */
-	task_context->transfer_length_bytes = 12;
-}
-
-
-/*
- * *@brief This methods decode the D2H status FIS and retrieve the sense data,
- *          then pass the sense data to user request.
- *
- ***@param[in] sci_req The request receive D2H status FIS.
- ***@param[in] status_fis The D2H status fis to be processed.
- *
- */
-enum sci_status scic_sds_stp_packet_request_process_status_fis(
-	struct scic_sds_request *sci_req,
-	struct sata_fis_reg_d2h *status_fis)
-{
-	enum sci_status status = SCI_SUCCESS;
-
-	/* TODO: Process the error status fis, retrieve sense data. */
-	if (status_fis->status & ATA_STATUS_REG_ERROR_BIT)
-		status = SCI_FAILURE_IO_RESPONSE_VALID;
-
-	return status;
-}
-
-/*
- * *@brief This methods builds sgl for internal REQUEST SENSE stp packet
- *          command using this request response buffer, only one sge is
- *          needed.
- *
- ***@param[in] sci_req The request receive request sense data.
- *
- */
-void scic_sds_stp_packet_internal_request_sense_build_sgl(
-	struct scic_sds_request *sds_request)
-{
-	void *sge;
-	struct scu_sgl_element_pair *scu_sgl_list   = NULL;
-	struct scu_task_context *task_context;
-	dma_addr_t dma_addr;
-
-	struct sci_ssp_response_iu *rsp_iu =
-		(struct sci_ssp_response_iu *)sds_request->response_buffer;
-
-	sge =  (void *)&rsp_iu->data[0];
-
-	task_context =
-		(struct scu_task_context *)sds_request->task_context_buffer;
-	scu_sgl_list = &task_context->sgl_pair_ab;
-
-	dma_addr = scic_io_request_get_dma_addr(sds_request, sge);
-
-	scu_sgl_list->A.address_upper = upper_32_bits(dma_addr);
-	scu_sgl_list->A.address_lower = lower_32_bits(dma_addr);
-	scu_sgl_list->A.length = task_context->transfer_length_bytes;
-	scu_sgl_list->A.address_modifier = 0;
-
-	SCU_SGL_ZERO(scu_sgl_list->B);
-}
-
-/**
- * This method processes the completions transport layer (TL) status to
- *    determine if the Packet FIS was sent successfully. If the Packet FIS was
- *    sent successfully, then the state for the Packet request transits to
- *    waiting for a PIO SETUP frame.
- * @sci_req: This parameter specifies the request for which the TC
- *    completion was received.
- * @completion_code: This parameter indicates the completion status information
- *    for the TC.
- *
- * Indicate if the tc completion handler was successful. SCI_SUCCESS currently
- * this method always returns success.
- */
-enum sci_status scic_sds_stp_packet_request_packet_phase_await_tc_completion_tc_completion_handler(
-	struct scic_sds_request *sci_req,
-	u32 completion_code)
-{
-	enum sci_status status = SCI_SUCCESS;
-
-	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
-	case SCU_MAKE_COMPLETION_STATUS(SCU_TASK_DONE_GOOD):
-		scic_sds_request_set_status(
-			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
-			);
-
-		sci_base_state_machine_change_state(
-			&sci_req->started_substate_machine,
-			SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_PIO_SETUP_SUBSTATE
-			);
-		break;
-
-	default:
-		/*
-		 * All other completion status cause the IO to be complete.  If a NAK
-		 * was received, then it is up to the user to retry the request. */
-		scic_sds_request_set_status(
-			sci_req,
-			SCU_NORMALIZE_COMPLETION_STATUS(completion_code),
-			SCI_FAILURE_CONTROLLER_SPECIFIC_IO_ERR
-			);
-
-		sci_base_state_machine_change_state(
-			&sci_req->parent.state_machine,
-			SCI_BASE_REQUEST_STATE_COMPLETED
-			);
-		break;
-	}
-
-	return status;
-}
-
-
-/**
- * This method processes an unsolicited frame while the Packet request is
- *    waiting for a PIO SETUP FIS.  It will release the unsolicited frame, and
- *    transition the request to the COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
- *    state.
- * @sci_req: This parameter specifies the request for which the
- *    unsolicited frame was received.
- * @frame_index: This parameter indicates the unsolicited frame index that
- *    should contain the response.
- *
- * This method returns an indication of whether the pio setup frame was handled
- * successfully or not. SCI_SUCCESS Currently this value is always returned and
- * indicates successful processing of the TC response.
- */
-enum sci_status scic_sds_stp_packet_request_packet_phase_await_pio_setup_frame_handler(
-	struct scic_sds_request *request,
-	u32 frame_index)
-{
-	enum sci_status status;
-	struct sata_fis_header *frame_header;
-	u32 *frame_buffer;
-	struct scic_sds_stp_request *sci_req;
-
-	sci_req = (struct scic_sds_stp_request *)request;
-
-	status = scic_sds_unsolicited_frame_control_get_header(
-		&(sci_req->parent.owning_controller->uf_control),
-		frame_index,
-		(void **)&frame_header
-		);
-
-	if (status == SCI_SUCCESS) {
-		BUG_ON(frame_header->fis_type != SATA_FIS_TYPE_PIO_SETUP);
-
-		/*
-		 * Get from the frame buffer the PIO Setup Data, although we don't need
-		 * any info from this pio setup fis. */
-		scic_sds_unsolicited_frame_control_get_buffer(
-			&(sci_req->parent.owning_controller->uf_control),
-			frame_index,
-			(void **)&frame_buffer
-			);
-
-		/*
-		 * Get the data from the PIO Setup
-		 * The SCU Hardware returns first word in the frame_header and the rest
-		 * of the data is in the frame buffer so we need to back up one dword */
-		sci_req->type.packet.device_preferred_cdb_length =
-			(u16)((struct sata_fis_pio_setup *)(&frame_buffer[-1]))->transfter_count;
-
-		/* Frame has been decoded return it to the controller */
-		scic_sds_controller_release_frame(
-			sci_req->parent.owning_controller, frame_index
-			);
-
-		sci_base_state_machine_change_state(
-			&sci_req->parent.started_substate_machine,
-			SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
-			);
-	} else
-		dev_err(scic_to_dev(request->owning_controller),
-			"%s: SCIC IO Request 0x%p could not get frame header "
-			"for frame index %d, status %x\n",
-			__func__, sci_req, frame_index, status);
-
-	return status;
-}
-
-
-/**
- * This method processes the completions transport layer (TL) status to
- *    determine if the PACKET command data FIS was sent successfully. If
- *    successfully, then the state for the packet request transits to COMPLETE
- *    state. If not successfuly, the request transits to
- *    COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE.
- * @sci_req: This parameter specifies the request for which the TC
- *    completion was received.
- * @completion_code: This parameter indicates the completion status information
- *    for the TC.
- *
- * Indicate if the tc completion handler was successful. SCI_SUCCESS currently
- * this method always returns success.
- */
-enum sci_status scic_sds_stp_packet_request_command_phase_await_tc_completion_tc_completion_handler(
-	struct scic_sds_request *sci_req,
-	u32 completion_code)
-{
-	enum sci_status status = SCI_SUCCESS;
-	u8 sat_packet_protocol =
-		scic_cb_request_get_sat_protocol(sci_req->user_request);
-
-	switch (SCU_GET_COMPLETION_TL_STATUS(completion_code)) {
-	case (SCU_TASK_DONE_GOOD << SCU_COMPLETION_TL_STATUS_SHIFT):
-		scic_sds_request_set_status(
-			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
-			);
-
-		if (sat_packet_protocol == SAT_PROTOCOL_PACKET_DMA_DATA_IN
-		     || sat_packet_protocol == SAT_PROTOCOL_PACKET_DMA_DATA_OUT
-		     )
-			sci_base_state_machine_change_state(
-				&sci_req->parent.state_machine,
-				SCI_BASE_REQUEST_STATE_COMPLETED
-				);
-		else
-			sci_base_state_machine_change_state(
-				&sci_req->started_substate_machine,
-				SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
-				);
-		break;
-
-	case (SCU_TASK_DONE_UNEXP_FIS << SCU_COMPLETION_TL_STATUS_SHIFT):
-		if (scic_io_request_get_number_of_bytes_transferred(sci_req) <
-		    scic_cb_io_request_get_transfer_length(sci_req->user_request)) {
-			scic_sds_request_set_status(
-				sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS_IO_DONE_EARLY
-				);
-
-			sci_base_state_machine_change_state(
-				&sci_req->parent.state_machine,
-				SCI_BASE_REQUEST_STATE_COMPLETED
-				);
-
-			status = sci_req->sci_status;
-		}
-		break;
-
-	case (SCU_TASK_DONE_EXCESS_DATA << SCU_COMPLETION_TL_STATUS_SHIFT):
-		/* In this case, there is no UF coming after. compelte the IO now. */
-		scic_sds_request_set_status(
-			sci_req, SCU_TASK_DONE_GOOD, SCI_SUCCESS
-			);
-
-		sci_base_state_machine_change_state(
-			&sci_req->parent.state_machine,
-			SCI_BASE_REQUEST_STATE_COMPLETED
-			);
-
-		break;
-
-	default:
-		if (sci_req->sci_status != SCI_SUCCESS) {  /* The io status was set already. This means an UF for the status
-								 * fis was received already.
-								 */
-
-			/*
-			 * A device suspension event is expected, we need to have the device
-			 * coming out of suspension, then complete the IO. */
-			sci_base_state_machine_change_state(
-				&sci_req->started_substate_machine,
-				SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE
-				);
-
-			/* change the device state to ATAPI_ERROR. */
-			sci_base_state_machine_change_state(
-				&sci_req->target_device->ready_substate_machine,
-				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR
-				);
-
-			status = sci_req->sci_status;
-		} else {  /* If receiving any non-sucess TC status, no UF received yet, then an UF for
-			   * the status fis is coming after.
-			   */
-			scic_sds_request_set_status(
-				sci_req,
-				SCU_TASK_DONE_CHECK_RESPONSE,
-				SCI_FAILURE_IO_RESPONSE_VALID
-				);
-
-			sci_base_state_machine_change_state(
-				&sci_req->started_substate_machine,
-				SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
-				);
-		}
-		break;
-	}
-
-	return status;
-}
-
-
-/**
- * This method processes an unsolicited frame.
- * @sci_req: This parameter specifies the request for which the
- *    unsolicited frame was received.
- * @frame_index: This parameter indicates the unsolicited frame index that
- *    should contain the response.
- *
- * This method returns an indication of whether the UF frame was handled
- * successfully or not. SCI_SUCCESS Currently this value is always returned and
- * indicates successful processing of the TC response.
- */
-enum sci_status scic_sds_stp_packet_request_command_phase_common_frame_handler(
-	struct scic_sds_request *request,
-	u32 frame_index)
-{
-	enum sci_status status;
-	struct sata_fis_header *frame_header;
-	u32 *frame_buffer;
-	struct scic_sds_stp_request *sci_req;
-
-	sci_req = (struct scic_sds_stp_request *)request;
-
-	status = scic_sds_unsolicited_frame_control_get_header(
-		&(sci_req->parent.owning_controller->uf_control),
-		frame_index,
-		(void **)&frame_header
-		);
-
-	if (status == SCI_SUCCESS) {
-		BUG_ON(frame_header->fis_type != SATA_FIS_TYPE_REGD2H);
-
-		/*
-		 * Get from the frame buffer the PIO Setup Data, although we don't need
-		 * any info from this pio setup fis. */
-		scic_sds_unsolicited_frame_control_get_buffer(
-			&(sci_req->parent.owning_controller->uf_control),
-			frame_index,
-			(void **)&frame_buffer
-			);
-
-		scic_sds_controller_copy_sata_response(
-			&sci_req->d2h_reg_fis, (u32 *)frame_header, frame_buffer
-			);
-
-		/* Frame has been decoded return it to the controller */
-		scic_sds_controller_release_frame(
-			sci_req->parent.owning_controller, frame_index
-			);
-	}
-
-	return status;
-}
-
-/**
- * This method processes an unsolicited frame while the packet request is
- *    expecting TC completion. It will process the FIS and construct sense data.
- * @sci_req: This parameter specifies the request for which the
- *    unsolicited frame was received.
- * @frame_index: This parameter indicates the unsolicited frame index that
- *    should contain the response.
- *
- * This method returns an indication of whether the UF frame was handled
- * successfully or not. SCI_SUCCESS Currently this value is always returned and
- * indicates successful processing of the TC response.
- */
-enum sci_status scic_sds_stp_packet_request_command_phase_await_tc_completion_frame_handler(
-	struct scic_sds_request *request,
-	u32 frame_index)
-{
-	struct scic_sds_stp_request *sci_req = (struct scic_sds_stp_request *)request;
-
-	enum sci_status status =
-		scic_sds_stp_packet_request_command_phase_common_frame_handler(
-			request, frame_index);
-
-	if (status == SCI_SUCCESS) {
-		/* The command has completed with error status from target device. */
-		status = scic_sds_stp_packet_request_process_status_fis(
-			request, &sci_req->d2h_reg_fis);
-
-		if (status != SCI_SUCCESS) {
-			scic_sds_request_set_status(
-				&sci_req->parent,
-				SCU_TASK_DONE_CHECK_RESPONSE,
-				status
-				);
-		} else
-			scic_sds_request_set_status(
-				&sci_req->parent, SCU_TASK_DONE_GOOD, SCI_SUCCESS
-				);
-	}
-
-	return status;
-}
-
-
-/**
- * This method processes an unsolicited frame while the packet request is
- *    expecting TC completion. It will process the FIS and construct sense data.
- * @sci_req: This parameter specifies the request for which the
- *    unsolicited frame was received.
- * @frame_index: This parameter indicates the unsolicited frame index that
- *    should contain the response.
- *
- * This method returns an indication of whether the UF frame was handled
- * successfully or not. SCI_SUCCESS Currently this value is always returned and
- * indicates successful processing of the TC response.
- */
-enum sci_status scic_sds_stp_packet_request_command_phase_await_d2h_fis_frame_handler(
-	struct scic_sds_request *request,
-	u32 frame_index)
-{
-	enum sci_status status =
-		scic_sds_stp_packet_request_command_phase_common_frame_handler(
-			request, frame_index);
-
-	struct scic_sds_stp_request *sci_req = (struct scic_sds_stp_request *)request;
-
-	if (status == SCI_SUCCESS) {
-		/* The command has completed with error status from target device. */
-		status = scic_sds_stp_packet_request_process_status_fis(
-			request, &sci_req->d2h_reg_fis);
-
-		if (status != SCI_SUCCESS) {
-			scic_sds_request_set_status(
-				request,
-				SCU_TASK_DONE_CHECK_RESPONSE,
-				status
-				);
-		} else
-			scic_sds_request_set_status(
-				request, SCU_TASK_DONE_GOOD, SCI_SUCCESS
-				);
-
-		/*
-		 * Always complete the NON_DATA command right away, no need to delay completion
-		 * even an error status fis came from target device. */
-		sci_base_state_machine_change_state(
-			&request->parent.state_machine,
-			SCI_BASE_REQUEST_STATE_COMPLETED
-			);
-	}
-
-	return status;
-}
-
-enum sci_status scic_sds_stp_packet_request_started_completion_delay_complete_handler(
-	struct scic_sds_request *request)
-{
-	sci_base_state_machine_change_state(&request->parent.state_machine,
-		SCI_BASE_REQUEST_STATE_COMPLETED);
-
-	return request->sci_status;
-}
-
-/* --------------------------------------------------------------------------- */
-
-const struct scic_sds_io_request_state_handler scic_sds_stp_packet_request_started_substate_handler_table[] = {
-	[SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_TC_COMPLETION_SUBSTATE] = {
-		.parent.abort_handler    = scic_sds_request_started_state_abort_handler,
-		.tc_completion_handler   = scic_sds_stp_packet_request_packet_phase_await_tc_completion_tc_completion_handler,
-	},
-	[SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_PIO_SETUP_SUBSTATE] = {
-		.parent.abort_handler    = scic_sds_request_started_state_abort_handler,
-		.frame_handler           = scic_sds_stp_packet_request_packet_phase_await_pio_setup_frame_handler
-	},
-	[SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE] = {
-		.parent.abort_handler    = scic_sds_request_started_state_abort_handler,
-		.tc_completion_handler   = scic_sds_stp_packet_request_command_phase_await_tc_completion_tc_completion_handler,
-		.frame_handler           = scic_sds_stp_packet_request_command_phase_await_tc_completion_frame_handler
-	},
-	[SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE] = {
-		.parent.abort_handler    = scic_sds_request_started_state_abort_handler,
-		.frame_handler           = scic_sds_stp_packet_request_command_phase_await_d2h_fis_frame_handler
-	},
-	[SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE] = {
-		.parent.abort_handler    = scic_sds_request_started_state_abort_handler,
-		.parent.complete_handler = scic_sds_stp_packet_request_started_completion_delay_complete_handler,
-	},
-};
-
-void scic_sds_stp_packet_request_started_packet_phase_await_tc_completion_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
-
-	SET_STATE_HANDLER(
-		sci_req,
-		scic_sds_stp_packet_request_started_substate_handler_table,
-		SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
-		);
-
-	scic_sds_remote_device_set_working_request(
-		sci_req->target_device, sci_req
-		);
-}
-
-void scic_sds_stp_packet_request_started_packet_phase_await_pio_setup_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
-
-	SET_STATE_HANDLER(
-		sci_req,
-		scic_sds_stp_packet_request_started_substate_handler_table,
-		SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_PIO_SETUP_SUBSTATE
-		);
-}
-
-void scic_sds_stp_packet_request_started_command_phase_await_tc_completion_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
-	u8 sat_packet_protocol =
-		scic_cb_request_get_sat_protocol(sci_req->user_request);
-
-	struct scu_task_context *task_context;
-	enum sci_status status;
-
-	/*
-	 * Recycle the TC and reconstruct it for sending out data fis containing
-	 * CDB. */
-	task_context = scic_sds_controller_get_task_context_buffer(
-		sci_req->owning_controller, sci_req->io_tag);
-
-	if (sat_packet_protocol == SAT_PROTOCOL_PACKET_NON_DATA)
-		scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context(
-			sci_req, task_context);
-	else
-		scu_stp_packet_request_command_phase_construct_task_context(
-			sci_req, task_context);
-
-	/* send the new TC out. */
-	status = sci_req->owning_controller->state_handlers->parent.continue_io_handler(
-		&sci_req->owning_controller->parent,
-		&sci_req->target_device->parent,
-		&sci_req->parent
-		);
-
-	if (status == SCI_SUCCESS)
-		SET_STATE_HANDLER(
-			sci_req,
-			scic_sds_stp_packet_request_started_substate_handler_table,
-			SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE
-			);
-}
-
-void scic_sds_stp_packet_request_started_command_phase_await_d2h_fis_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
-
-	SET_STATE_HANDLER(
-		sci_req,
-		scic_sds_stp_packet_request_started_substate_handler_table,
-		SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE
-		);
-}
-
-void scic_sds_stp_packet_request_started_completion_delay_enter(
-	struct sci_base_object *object)
-{
-	struct scic_sds_request *sci_req = (struct scic_sds_request *)object;
-
-	SET_STATE_HANDLER(
-		sci_req,
-		scic_sds_stp_packet_request_started_substate_handler_table,
-		SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE
-		);
-}
-
-
-/* --------------------------------------------------------------------------- */
-const struct sci_base_state scic_sds_stp_packet_request_started_substate_table[] = {
-	[SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_TC_COMPLETION_SUBSTATE] = {
-		.enter_state = scic_sds_stp_packet_request_started_packet_phase_await_tc_completion_enter,
-	},
-	[SCIC_SDS_STP_PACKET_REQUEST_STARTED_PACKET_PHASE_AWAIT_PIO_SETUP_SUBSTATE] = {
-		.enter_state = scic_sds_stp_packet_request_started_packet_phase_await_pio_setup_enter,
-	},
-	[SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_TC_COMPLETION_SUBSTATE] = {
-		.enter_state = scic_sds_stp_packet_request_started_command_phase_await_tc_completion_enter,
-	},
-	[SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMMAND_PHASE_AWAIT_D2H_FIS_SUBSTATE] = {
-		.enter_state = scic_sds_stp_packet_request_started_command_phase_await_d2h_fis_enter,
-	},
-	[SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE] = {
-		.enter_state scic_sds_stp_packet_request_started_completion_delay_enter,
-	}
-};
-
-#endif /* !defined(DISABLE_ATAPI) */
diff --git a/drivers/scsi/isci/core/scic_sds_stp_packet_request.h b/drivers/scsi/isci/core/scic_sds_stp_packet_request.h
index f6ff5a6..5d45ef6 100644
--- a/drivers/scsi/isci/core/scic_sds_stp_packet_request.h
+++ b/drivers/scsi/isci/core/scic_sds_stp_packet_request.h
@@ -104,50 +104,11 @@ enum _scic_sds_stp_packet_request_started_substates {
 	SCIC_SDS_STP_PACKET_REQUEST_STARTED_COMPLETION_DELAY_SUBSTATE,
 };
 
-
-
-#if !defined(DISABLE_ATAPI)
-extern const struct sci_base_state scic_sds_stp_packet_request_started_substate_table[];
-extern const struct scic_sds_io_request_state_handler scic_sds_stp_packet_request_started_substate_handler_table[];
-#endif /* !defined(DISABLE_ATAPI) */
-
-#if !defined(DISABLE_ATAPI)
-enum sci_status scic_sds_stp_packet_request_construct(
-	struct scic_sds_request *sci_req);
-#else  /* !defined(DISABLE_ATAPI) */
 #define scic_sds_stp_packet_request_construct(request) SCI_FAILURE
-#endif /* !defined(DISABLE_ATAPI) */
-
-#if !defined(DISABLE_ATAPI)
-void scu_stp_packet_request_command_phase_construct_task_context(
-	struct scic_sds_request *sci_req,
-	struct scu_task_context *task_context);
-#else  /* !defined(DISABLE_ATAPI) */
 #define scu_stp_packet_request_command_phase_construct_task_context(reqeust, tc)
-#endif /* !defined(DISABLE_ATAPI) */
-
-#if !defined(DISABLE_ATAPI)
-void scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context(
-	struct scic_sds_request *sci_req,
-	struct scu_task_context *task_context);
-#else  /* !defined(DISABLE_ATAPI) */
 #define scu_stp_packet_request_command_phase_reconstruct_raw_frame_task_context(reqeust, tc)
-#endif /* !defined(DISABLE_ATAPI) */
-
-#if !defined(DISABLE_ATAPI)
-enum sci_status scic_sds_stp_packet_request_process_status_fis(
-	struct scic_sds_request *sci_req,
-	struct sata_fis_reg_d2h *status_fis);
-#else  /* !defined(DISABLE_ATAPI) */
 #define scic_sds_stp_packet_request_process_status_fis(reqeust, fis) SCI_FAILURE
-#endif /* !defined(DISABLE_ATAPI) */
-
-#if !defined(DISABLE_ATAPI)
-void scic_sds_stp_packet_internal_request_sense_build_sgl(
-	struct scic_sds_request *sci_req);
-#else  /* !defined(DISABLE_ATAPI) */
 #define scic_sds_stp_packet_internal_request_sense_build_sgl(request)
-#endif /* !defined(DISABLE_ATAPI) */
 
 #endif /* _SCIC_SDS_STP_PACKET_REQUEST_H_ */
 
diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 1e9e222..6d5ab72 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -99,15 +99,6 @@ enum sas_linkrate scic_remote_device_get_connection_rate(
 	return sci_dev->connection_rate;
 }
 
-
-#if !defined(DISABLE_ATAPI)
-bool scic_remote_device_is_atapi(struct scic_sds_remote_device *sci_dev)
-{
-	return sci_dev->is_atapi;
-}
-#endif
-
-
 /**
  *
  *
@@ -217,16 +208,6 @@ enum sci_status scic_sds_remote_device_start_task(
 
 /**
  *
- * @controller: The controller that is completing the task request.
- * @sci_dev: The remote device for which the complete task handling is
- *    being requested.
- * @io_request: The task request that is being completed.
- *
- * This method invokes the remote device complete task handler. enum sci_status
- */
-
-/**
- *
  * @sci_dev:
  * @request:
  *
@@ -247,47 +228,6 @@ void scic_sds_remote_device_post_request(
 		);
 }
 
-#if !defined(DISABLE_ATAPI)
-/**
- *
- * @sci_dev: The device to be checked.
- *
- * This method check the signature fis of a stp device to decide whether a
- * device is atapi or not. true if a device is atapi device. False if a device
- * is not atapi.
- */
-bool scic_sds_remote_device_is_atapi(
-	struct scic_sds_remote_device *sci_dev)
-{
-	if (!sci_dev->target_protocols.u.bits.attached_stp_target)
-		return false;
-	else if (sci_dev->is_direct_attached) {
-		struct scic_sds_phy *phy;
-		struct scic_sata_phy_properties properties;
-		struct sata_fis_reg_d2h *signature_fis;
-		phy = scic_sds_port_get_a_connected_phy(sci_dev->owning_port);
-		scic_sata_phy_get_properties(phy, &properties);
-
-		/* decode the signature fis. */
-		signature_fis = &(properties.signature_fis);
-
-		if ((signature_fis->sector_count  == 0x01)
-		    && (signature_fis->lba_low       == 0x01)
-		    && (signature_fis->lba_mid       == 0x14)
-		    && (signature_fis->lba_high      == 0xEB)
-		    && ((signature_fis->device & 0x5F) == 0x00)
-		    ) {
-			/* An ATA device supporting the PACKET command set. */
-			return true;
-		} else
-			return false;
-	} else {
-		/* Expander supported ATAPI device is not currently supported. */
-		return false;
-	}
-}
-#endif
-
 /**
  *
  * @user_parameter: This is cast to a remote device object.
diff --git a/drivers/scsi/isci/remote_device.h b/drivers/scsi/isci/remote_device.h
index 5b82b9f..5cceb6c 100644
--- a/drivers/scsi/isci/remote_device.h
+++ b/drivers/scsi/isci/remote_device.h
@@ -105,14 +105,6 @@ struct scic_sds_remote_device {
 	 */
 	bool is_direct_attached;
 
-#if !defined(DISABLE_ATAPI)
-	/**
-	 * This filed is assinged the value of true if the device is an ATAPI
-	 * device.
-	 */
-	bool is_atapi;
-#endif
-
 	/**
 	 * This filed contains a pointer back to the port to which this device
 	 * is assigned.
@@ -254,22 +246,7 @@ enum sci_status scic_remote_device_reset_complete(
 enum sas_linkrate scic_remote_device_get_connection_rate(
 	struct scic_sds_remote_device *remote_device);
 
-#if !defined(DISABLE_ATAPI)
-/**
- * scic_remote_device_is_atapi() -
- * @this_device: The device whose type is to be decided.
- *
- * This method first decide whether a device is a stp target, then decode the
- * signature fis of a DA STP device to tell whether it is a standard end disk
- * or an ATAPI device. bool Indicate a device is ATAPI device or not.
- */
-bool scic_remote_device_is_atapi(
-	struct scic_sds_remote_device *device_handle);
-#else /* !defined(DISABLE_ATAPI) */
 #define scic_remote_device_is_atapi(device_handle) false
-#endif /* !defined(DISABLE_ATAPI) */
-
-
 
 /**
  * enum scic_sds_remote_device_states - This enumeration depicts all the states
@@ -405,16 +382,6 @@ enum scic_sds_stp_remote_device_ready_substates {
 	 */
 	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR,
 
-#if !defined(DISABLE_ATAPI)
-	/**
-	 * This is the ATAPI error state for the STP ATAPI remote device.  This state is
-	 * entered when ATAPI device sends error status FIS without data while the device
-	 * object is in CMD state. A suspension event is expected in this state. The device
-	 * object will resume right away.
-	 */
-	SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR,
-#endif
-
 	/**
 	 * This is the READY substate indicates the device is waiting for the RESET task
 	 * coming to be recovered from certain hardware specific error.
@@ -727,12 +694,7 @@ void scic_sds_remote_device_post_request(
 	struct scic_sds_remote_device *sci_dev,
 	u32 request);
 
-#if !defined(DISABLE_ATAPI)
-bool scic_sds_remote_device_is_atapi(
-	struct scic_sds_remote_device *sci_dev);
-#else /* !defined(DISABLE_ATAPI) */
 #define scic_sds_remote_device_is_atapi(sci_dev) false
-#endif /* !defined(DISABLE_ATAPI) */
 
 void scic_sds_remote_device_start_request(
 	struct scic_sds_remote_device *sci_dev,
diff --git a/drivers/scsi/isci/stp_remote_device.c b/drivers/scsi/isci/stp_remote_device.c
index b81f21f..0fbfe52 100644
--- a/drivers/scsi/isci/stp_remote_device.c
+++ b/drivers/scsi/isci/stp_remote_device.c
@@ -483,47 +483,6 @@ static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_com
 	return status;
 }
 
-#if !defined(DISABLE_ATAPI)
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY ATAPI ERROR SUBSTATE HANDLERS
- * ***************************************************************************** */
-
-/**
- *
- * @[in]: device The device received event.
- * @[in]: event_code The event code.
- *
- * This method will handle the event for a ATAPI device that is in the ATAPI
- * ERROR state. We pick up suspension events to handle specifically to this
- * state. We resume the RNC right away. We then complete the outstanding IO to
- * this device. enum sci_status
- */
-enum sci_status scic_sds_stp_remote_device_ready_atapi_error_substate_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	status = scic_sds_remote_device_general_event_handler(sci_dev, event_code);
-
-	if (status == SCI_SUCCESS) {
-		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX
-		    || scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {
-			status = scic_sds_remote_node_context_resume(
-				sci_dev->rnc,
-				sci_dev->working_request->state_handlers->parent.complete_handler,
-				(void *)sci_dev->working_request
-				);
-		}
-	}
-
-	return status;
-}
-#endif /* !defined(DISABLE_ATAPI) */
-
-/* --------------------------------------------------------------------------- */
-
 static const struct scic_sds_remote_device_state_handler scic_sds_stp_remote_device_ready_substate_handler_table[] = {
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
 		.start_handler		= scic_sds_remote_device_default_start_handler,
@@ -593,25 +552,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_stp_remote_dev
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
-#if !defined(DISABLE_ATAPI)
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
-		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
-		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
-		.event_handler			= scic_sds_stp_remote_device_ready_atapi_error_substate_event_handler,
-		.frame_handler			= scic_sds_remote_device_general_frame_handler
-	},
-#endif
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
 		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
@@ -764,35 +704,6 @@ static void scic_sds_stp_remote_device_ready_await_reset_substate_enter(
 		);
 }
 
-#if !defined(DISABLE_ATAPI)
-/*
- * *****************************************************************************
- * *  STP REMOTE DEVICE READY ATAPI ERROR SUBSTATE
- * ***************************************************************************** */
-
-/**
- * The enter routine to READY ATAPI ERROR substate.
- * @device: This is the SCI base object which is cast into a
- *    struct scic_sds_remote_device object.
- *
- */
-void scic_sds_stp_remote_device_ready_atapi_error_substate_enter(
-	struct sci_base_object *device)
-{
-	struct scic_sds_remote_device *sci_dev;
-
-	sci_dev = (struct scic_sds_remote_device *)device;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_stp_remote_device_ready_substate_handler_table,
-		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR
-		);
-}
-#endif /* !defined(DISABLE_ATAPI) */
-
-/* --------------------------------------------------------------------------- */
-
 const struct sci_base_state scic_sds_stp_remote_device_ready_substate_table[] = {
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
 		.enter_state = scic_sds_stp_remote_device_ready_idle_substate_enter,
@@ -806,11 +717,6 @@ const struct sci_base_state scic_sds_stp_remote_device_ready_substate_table[] =
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
 		.enter_state = scic_sds_stp_remote_device_ready_ncq_error_substate_enter,
 	},
-#if !defined(DISABLE_ATAPI)
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_ATAPI_ERROR] = {
-		.enter_state = scic_sds_stp_remote_device_ready_atapi_error_substate_enter,
-	},
-#endif
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
 		.enter_state = scic_sds_stp_remote_device_ready_await_reset_substate_enter,
 	},
-- 
1.6.0.2

