From: Jitendra Kalsaria <jitendra.kalsaria@qlogic.com>
Date: Fri, 15 Oct 2010 23:06:00 -0700
Subject: [PATCH 10/14] qlge: Fix a deadlock when the interface is going down.
Git-commit: c5dadddb8c9d310bc263f671f19fe3ba90b329fe
Patch-mainline: v2.6.37-rc1

	Currently qlge can deadlock when the interface is going
	down, and the mpi_port_cfg_work() is executing on another
	processor. It happens because unregister_netdev() holds
	the rtnl lock, and the mpi_port_cfg_work() also request
	this lock.

	Since unregister_netdev() may wait mpi_port_cfg_work(), who
	also request the holding lock, it can cause an deadlock.

Signed-off-by: Jitendra Kalsaria <jitendra.kalsaria@qlogic.com>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 drivers/net/qlge/qlge_main.c |   24 ++++++++++++------------
 1 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/drivers/net/qlge/qlge_main.c b/drivers/net/qlge/qlge_main.c
index 5e05b85..16624b6 100644
--- a/drivers/net/qlge/qlge_main.c
+++ b/drivers/net/qlge/qlge_main.c
@@ -3862,12 +3862,8 @@ int ql_wol(struct ql_adapter *qdev)
 	return status;
 }
 
-static int ql_adapter_down(struct ql_adapter *qdev)
+static void ql_cancel_all_work_sync(struct ql_adapter *qdev)
 {
-	int i, status = 0;
-
-	ql_link_off(qdev);
-
 	/* Don't kill the reset worker thread if we
 	 * are in the process of recovery.
 	 */
@@ -3878,6 +3874,15 @@ static int ql_adapter_down(struct ql_adapter *qdev)
 	cancel_delayed_work_sync(&qdev->mpi_idc_work);
 	cancel_delayed_work_sync(&qdev->mpi_core_to_log);
 	cancel_delayed_work_sync(&qdev->mpi_port_cfg_work);
+}
+
+static int ql_adapter_down(struct ql_adapter *qdev)
+{
+	int i, status = 0;
+
+	ql_link_off(qdev);
+
+	ql_cancel_all_work_sync(qdev);
 
 	for (i = 0; i < qdev->rss_ring_count; i++)
 		napi_disable(&qdev->rx_ring[i].napi);
@@ -4700,6 +4705,7 @@ static void __devexit qlge_remove(struct pci_dev *pdev)
 	struct net_device *ndev = pci_get_drvdata(pdev);
 	struct ql_adapter *qdev = netdev_priv(ndev);
 	del_timer_sync(&qdev->timer);
+	ql_cancel_all_work_sync(qdev);
 	unregister_netdev(ndev);
 	ql_release_all(pdev);
 	pci_disable_device(pdev);
@@ -4719,13 +4725,7 @@ static void ql_eeh_close(struct net_device *ndev)
 	/* Disabling the timer */
 	del_timer_sync(&qdev->timer);
 
-	if (test_bit(QL_ADAPTER_UP, &qdev->flags))
-		cancel_delayed_work_sync(&qdev->asic_reset_work);
-	cancel_delayed_work_sync(&qdev->mpi_reset_work);
-	cancel_delayed_work_sync(&qdev->mpi_work);
-	cancel_delayed_work_sync(&qdev->mpi_idc_work);
-	cancel_delayed_work_sync(&qdev->mpi_core_to_log);
-	cancel_delayed_work_sync(&qdev->mpi_port_cfg_work);
+	ql_cancel_all_work_sync(qdev);
 
 	for (i = 0; i < qdev->rss_ring_count; i++)
 		netif_napi_del(&qdev->rx_ring[i].napi);
-- 
1.7.6.rc0.12.g2c6b5

