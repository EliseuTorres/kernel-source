From: Mauro Carvalho Chehab <mchehab@redhat.com>
Subject: i7core_edac: Be sure that the edac pci handler will be properly released
References: fate#311968
Patch-Mainline: yes
Git-commit: 939747bd680eb09bb98792b17a5bfd2f525afe9d


Signed-off-by: Thomas Renninger <trenn@suse.de>

With multi-sockets, more than one edac pci handler is enabled. Be sure to
un-register all instances.

Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

---
 drivers/edac/edac_core.h   |    1 +
 drivers/edac/edac_mc.c     |    6 ++++--
 drivers/edac/i7core_edac.c |   38 +++++++++++++++++++++++---------------
 3 files changed, 28 insertions(+), 17 deletions(-)

Index: linux-2.6.32-SLE11-SP1/drivers/edac/edac_core.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/edac/edac_core.h
+++ linux-2.6.32-SLE11-SP1/drivers/edac/edac_core.h
@@ -810,6 +810,7 @@ extern struct mem_ctl_info *edac_mc_allo
 extern int edac_mc_add_mc(struct mem_ctl_info *mci);
 extern void edac_mc_free(struct mem_ctl_info *mci);
 extern struct mem_ctl_info *edac_mc_find(int idx);
+extern struct mem_ctl_info *find_mci_by_dev(struct device *dev);
 extern struct mem_ctl_info *edac_mc_del_mc(struct device *dev);
 extern int edac_mc_find_csrow_by_page(struct mem_ctl_info *mci,
 				      unsigned long page);
Index: linux-2.6.32-SLE11-SP1/drivers/edac/edac_mc.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/edac/edac_mc.c
+++ linux-2.6.32-SLE11-SP1/drivers/edac/edac_mc.c
@@ -239,13 +239,14 @@ void edac_mc_free(struct mem_ctl_info *m
 EXPORT_SYMBOL_GPL(edac_mc_free);
 
 
-/*
+/**
  * find_mci_by_dev
  *
  *	scan list of controllers looking for the one that manages
  *	the 'dev' device
+ * @dev: pointer to a struct device related with the MCI
  */
-static struct mem_ctl_info *find_mci_by_dev(struct device *dev)
+struct mem_ctl_info *find_mci_by_dev(struct device *dev)
 {
 	struct mem_ctl_info *mci;
 	struct list_head *item;
@@ -261,6 +262,7 @@ static struct mem_ctl_info *find_mci_by_
 
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(find_mci_by_dev);
 
 /*
  * handler for EDAC to check if NMI type handler has asserted interrupt
Index: linux-2.6.32-SLE11-SP1/drivers/edac/i7core_edac.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/edac/i7core_edac.c
+++ linux-2.6.32-SLE11-SP1/drivers/edac/i7core_edac.c
@@ -262,6 +262,9 @@ struct i7core_pvt {
 
 	/* Count indicator to show errors not got */
 	unsigned		mce_overrun;
+
+	/* Struct to control EDAC polling */
+	struct edac_pci_ctl_info *i7core_pci;
 };
 
 /* Static vars */
@@ -379,8 +382,6 @@ static const struct pci_device_id i7core
 	{0,}			/* 0 terminated list. */
 };
 
-static struct edac_pci_ctl_info *i7core_pci;
-
 /****************************************************************************
 			Anciliary status routines
  ****************************************************************************/
@@ -1907,9 +1908,9 @@ static int i7core_register_mci(struct i7
 	}
 
 	/* allocating generic PCI control info */
-	i7core_pci = edac_pci_create_generic_ctl(&i7core_dev->pdev[0]->dev,
+	pvt->i7core_pci = edac_pci_create_generic_ctl(&i7core_dev->pdev[0]->dev,
 						 EDAC_MOD_STR);
-	if (unlikely(!i7core_pci)) {
+	if (unlikely(!pvt->i7core_pci)) {
 		printk(KERN_WARNING
 			"%s(): Unable to create PCI control\n",
 			__func__);
@@ -2009,12 +2010,10 @@ static void __devexit i7core_remove(stru
 {
 	struct mem_ctl_info *mci;
 	struct i7core_dev *i7core_dev, *tmp;
+	struct i7core_pvt *pvt;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
 
-	if (i7core_pci)
-		edac_pci_release_generic_ctl(i7core_pci);
-
 	/*
 	 * we have a trouble here: pdev value for removal will be wrong, since
 	 * it will point to the X58 register used to detect that the machine
@@ -2025,19 +2024,28 @@ static void __devexit i7core_remove(stru
 
 	mutex_lock(&i7core_edac_lock);
 	list_for_each_entry_safe(i7core_dev, tmp, &i7core_edac_list, list) {
-		mci = edac_mc_del_mc(&i7core_dev->pdev[0]->dev);
-		if (mci) {
-			struct i7core_pvt *pvt = mci->pvt_info;
-
+		mci = find_mci_by_dev(&i7core_dev->pdev[0]->dev);
+		if (unlikely(!mci || !mci->pvt_info)) {
+			i7core_printk(KERN_ERR,
+				      "Couldn't find mci hanler\n");
+		} else {
+			pvt = mci->pvt_info;
 			i7core_dev = pvt->i7core_dev;
+
+			if (likely(pvt->i7core_pci))
+				edac_pci_release_generic_ctl(pvt->i7core_pci);
+			else
+				i7core_printk(KERN_ERR,
+					      "Couldn't find mem_ctl_info for socket %d\n",
+					      i7core_dev->socket);
+			pvt->i7core_pci = NULL;
+
+			edac_mc_del_mc(&i7core_dev->pdev[0]->dev);
+
 			edac_mce_unregister(&pvt->edac_mce);
 			kfree(mci->ctl_name);
 			edac_mc_free(mci);
 			i7core_put_devices(i7core_dev);
-		} else {
-			i7core_printk(KERN_ERR,
-				      "Couldn't find mci for socket %d\n",
-				      i7core_dev->socket);
 		}
 	}
 	probed--;
