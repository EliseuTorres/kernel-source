From 84a9a8cd9d0aa93c17e5815ab8a9cc4c0a765c63 Mon Sep 17 00:00:00 2001
From: Gwendal Grignou <gwendal@google.com>
Date: Fri, 18 Jan 2013 10:56:43 -0800
Subject: [libata] Set proper SK when CK_COND is set.
Patch-mainline: v3.9-rc1
Git-commit: 84a9a8cd9d0aa93c17e5815ab8a9cc4c0a765c63
References: bnc#833588

When the user application sends a ATA_12 or ATA_16 PASSTHROUGH
scsi command, put the task file register in the sense data with the
proper Sense Key. Instead of NO SENSE, set RECOVERED, as
specified in [SAT2]12.2.5 Table 92.

Tested:
Using udev ata_id to generate a passthrough command, IDENTIFY:
before:
 sd 0:0:0:0: [sda] CDB: ATA command pass through(12)/Blank: \
a1 08 2e 00 01 00 00 00 00 ec 00 00
 sd 0:0:0:0: [sda] Sense Key : No Sense [current] [descriptor]
 Descriptor sense data with sense descriptors (in hex):
         72 00 00 00 00 00 00 0e 09 0c 00 00 00 00 00 3f
         00 18 00 a6 e0 50

after
 sd 0:0:0:0: [sda] CDB: ATA command pass through(12)/Blank: \
a1 08 2e 00 01 00 00 00 00 ec 00 00
 sd 0:0:0:0: [sda]  Sense Key : Recovered Error [current] [descriptor]
 Descriptor sense data with sense descriptors (in hex):
        72 01 00 1d 00 00 00 0e 09 0c 00 00 00 01 00 00
        00 00 00 00 00 50

Signed-off-by: Gwendal Grignou <gwendal@google.com>
Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
Acked-by: Lee Duncan <lduncan@suse.com>
---
 drivers/ata/libata-scsi.c | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c
index 1ff0185..318b413 100644
--- a/drivers/ata/libata-scsi.c
+++ b/drivers/ata/libata-scsi.c
@@ -933,7 +933,11 @@ static void ata_to_sense_error(unsigned id, u8 drv_stat, u8 drv_err, u8 *sk,
  *	block specified for the ATA pass through commands.  Regardless
  *	of whether the command errored or not, return a sense
  *	block. Copy all controller registers into the sense
- *	block. Clear sense key, ASC & ASCQ if there is no error.
+ *	block. If there was no error, we get the request from an ATA
+ *	passthrough command, so we use the following sense data:
+ *	sk = RECOVERED ERROR
+ *	asc,ascq = ATA PASS-THROUGH INFORMATION AVAILABLE
+ *      
  *
  *	LOCKING:
  *	None.
@@ -959,6 +963,10 @@ static void ata_gen_passthru_sense(struct ata_queued_cmd *qc)
 		ata_to_sense_error(qc->ap->print_id, tf->command, tf->feature,
 				   &sb[1], &sb[2], &sb[3], verbose);
 		sb[1] &= 0x0f;
+	} else {
+		sb[1] = RECOVERED_ERROR;
+		sb[2] = 0;
+		sb[3] = 0x1D;
 	}
 
 	/*
@@ -1733,10 +1741,12 @@ static void ata_scsi_qc_complete(struct ata_queued_cmd *qc)
 
 	/* For ATA pass thru (SAT) commands, generate a sense block if
 	 * user mandated it or if there's an error.  Note that if we
-	 * generate because the user forced us to, a check condition
-	 * is generated and the ATA register values are returned
+	 * generate because the user forced us to [CK_COND =1], a check
+	 * condition is generated and the ATA register values are returned
 	 * whether the command completed successfully or not. If there
-	 * was no error, SK, ASC and ASCQ will all be zero.
+	 * was no error, we use the following sense data:
+	 * sk = RECOVERED ERROR
+	 * asc,ascq = ATA PASS-THROUGH INFORMATION AVAILABLE
 	 */
 	if (((cdb[0] == ATA_16) || (cdb[0] == ATA_12)) &&
 	    ((cdb[2] & 0x20) || need_sense)) {

