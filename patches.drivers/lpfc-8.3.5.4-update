From: James Smart <james.smart@emulex.com>
Subject: Patch to update Emulex LPFC driver to 8.3.5.4
References: bnc#577203
Patch-mainline: 2.6.33

In general this patch:
- Removes the DH-CHAP functionality
- Provides fixes and complete implementation of the BSG/SGIO management
infrastructure

Note that all the LPFC codebase in this latest patch, 8.3.5->8.3.5.4, is
included in the upstream LPFC driver 8.3.8 which was posted upstream on
1/26/10.

This is a detailed listing of the changes included in this patch:

* Changed version number to 8.3.5.4
* Remove DH-CHAP support
* Fix bug with BSG issue mbox not handling a busy mailbox status
* Submit abort WQE to same work queue as the command WQE
* Add missing functionality LPFC_BSG_VENDOR_GET_MGMT_REV
* Add missing functionality LPFC_BSG_VENDOR_MBOX
* Add timeout handler for EVT jobs
* Add missing functionality LPFC_BSG_VENDOR_DIAG_MODE, 
  LPFC_BSG_VENDOR_DIAG_TEST
* Fix bug with mgmt response resetting cmdiocbq
* Add missing functionality LPFC_BSG_VENDOR_SEND_MGMT_RESP
* Modify FC_BSG_RPT_ELS to operate asynchronously
* Fix bug with kzmalloc being called with ct_ev_lock held
* LPSe12002-ML1-E EmulexSecure changes for IOCB command define values
* Modify LPFC_BSG_VENDOR_SET_CT_EVENT adding driver private data
* Modify FC_BSG_RPT_CT to operate asynchronously and handle a timeout condition
* Update code infrastructure to add support for missing SGIO functionality
* Do not check class specific parameters for FLOGI (CR 97788)

Acked-by: Hannes Reinecke <hare@suse.de>

--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2009 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -45,8 +45,6 @@
 #include "lpfc_compat.h"
 #include "lpfc_crtn.h"
 #include "lpfc_vport.h"
-#include "lpfc_auth_access.h"
-#include "lpfc_security.h"
 
 #define LPFC_DEF_DEVLOSS_TMO 30
 #define LPFC_MIN_DEVLOSS_TMO 1
@@ -641,7 +639,7 @@ lpfc_do_offline(struct lpfc_hba *phba, u
  * -EIO reset not configured or error posting the event
  * zero for success
  **/
-int
+static int
 lpfc_selective_reset(struct lpfc_hba *phba)
 {
 	struct completion online_compl;
@@ -1199,152 +1197,6 @@ lpfc_poll_store(struct device *dev, stru
 	return strlen(buf);
 }
 
-static ssize_t
-lpfc_auth_state_show(struct device *dev, struct device_attribute *attr,
-		    char *buf)
-{
-	struct Scsi_Host  *shost = class_to_shost(dev);
-	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
-	switch (vport->auth.auth_state) {
-	case LPFC_AUTH_UNKNOWN:
-		if (vport->auth.auth_msg_state == LPFC_AUTH_NEGOTIATE ||
-		    vport->auth.auth_msg_state == LPFC_DHCHAP_CHALLENGE ||
-		    vport->auth.auth_msg_state == LPFC_DHCHAP_REPLY ||
-		    vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS_REPLY)
-			return snprintf(buf, PAGE_SIZE, "Authenticating\n");
-		else
-			return snprintf(buf, PAGE_SIZE, "Not Authenticated\n");
-	case LPFC_AUTH_FAIL:
-		return snprintf(buf, PAGE_SIZE, "Failed\n");
-	case LPFC_AUTH_FAIL_ELS_TMO:
-		return snprintf(buf, PAGE_SIZE, "Failed - ELS Timeout\n");
-	case LPFC_AUTH_FAIL_TRANS_TMO:
-		return snprintf(buf, PAGE_SIZE, "Failed - "
-				"Transaction Timeout\n");
-	case LPFC_AUTH_FAIL_LS_RJT_GEN:
-		return snprintf(buf, PAGE_SIZE, "Failed - LS_RJT\n");
-	case LPFC_AUTH_FAIL_LS_RJT_BUSY:
-		return snprintf(buf, PAGE_SIZE, "Failed - LS_RJT Busy\n");
-	case LPFC_AUTH_FAIL_AUTH_RJT:
-		return snprintf(buf, PAGE_SIZE, "Failed - AUTH RJT\n");
-	case LPFC_AUTH_SUCCESS:
-		if (vport->auth.auth_msg_state == LPFC_AUTH_NEGOTIATE ||
-		    vport->auth.auth_msg_state == LPFC_DHCHAP_CHALLENGE ||
-		    vport->auth.auth_msg_state == LPFC_DHCHAP_REPLY ||
-		    vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS_REPLY)
-			return snprintf(buf, PAGE_SIZE, "Authenticating\n");
-		else if (vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS)
-			return snprintf(buf, PAGE_SIZE, "Authenticated\n");
-	}
-	return snprintf(buf, PAGE_SIZE, "Unknown\n");
-}
-
-static ssize_t
-lpfc_auth_dir_show(struct device *dev, struct device_attribute *attr,
-		   char *buf)
-{
-	struct Scsi_Host  *shost = class_to_shost(dev);
-	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
-	if (!vport->cfg_enable_auth ||
-	    vport->auth.auth_state != LPFC_AUTH_SUCCESS)
-		return snprintf(buf, PAGE_SIZE, "Unknown\n");
-	if (vport->auth.direction == AUTH_DIRECTION_LOCAL)
-		return snprintf(buf, PAGE_SIZE, "Local Authenticated\n");
-	else if (vport->auth.direction == AUTH_DIRECTION_REMOTE)
-		return snprintf(buf, PAGE_SIZE, "Remote Authenticated\n");
-	else if (vport->auth.direction == AUTH_DIRECTION_BIDI)
-		return snprintf(buf, PAGE_SIZE, "Bidi Authentication\n");
-	return snprintf(buf, PAGE_SIZE, "Unknown\n");
-}
-
-static ssize_t
-lpfc_auth_protocol_show(struct device *dev, struct device_attribute *attr,
-			char *buf)
-{
-	struct Scsi_Host  *shost = class_to_shost(dev);
-	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
-	if (vport->cfg_enable_auth &&
-	    vport->auth.auth_state == LPFC_AUTH_SUCCESS)
-		return snprintf(buf, PAGE_SIZE, "1 (DH-CHAP)\n");
-	else
-		return snprintf(buf, PAGE_SIZE, "Unknown\n");
-}
-
-static ssize_t
-lpfc_auth_dhgroup_show(struct device *dev, struct device_attribute *attr,
-		       char *buf)
-{
-	struct Scsi_Host  *shost = class_to_shost(dev);
-	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
-	if (!vport->cfg_enable_auth ||
-	    vport->auth.auth_state != LPFC_AUTH_SUCCESS)
-		return snprintf(buf, PAGE_SIZE, "Unknown\n");
-	switch (vport->auth.group_id) {
-	case DH_GROUP_NULL:
-		return snprintf(buf, PAGE_SIZE, "0 (NULL)\n");
-	case DH_GROUP_1024:
-		return snprintf(buf, PAGE_SIZE, "1 (1024)\n");
-	case DH_GROUP_1280:
-		return snprintf(buf, PAGE_SIZE, "2 (1280)\n");
-	case DH_GROUP_1536:
-		return snprintf(buf, PAGE_SIZE, "3 (1536)\n");
-	case DH_GROUP_2048:
-		return snprintf(buf, PAGE_SIZE, "4 (2048)\n");
-	}
-	return snprintf(buf, PAGE_SIZE, "%d (Unrecognized)\n",
-			vport->auth.group_id);
-}
-
-static ssize_t
-lpfc_auth_hash_show(struct device *dev, struct device_attribute *attr,
-		    char *buf)
-{
-	struct Scsi_Host  *shost = class_to_shost(dev);
-	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
-	if (!vport->cfg_enable_auth ||
-	    vport->auth.auth_state != LPFC_AUTH_SUCCESS)
-		return snprintf(buf, PAGE_SIZE, "Unknown\n");
-	switch (vport->auth.hash_id) {
-	case FC_SP_HASH_MD5:
-		return snprintf(buf, PAGE_SIZE, "5 (MD5)\n");
-	case FC_SP_HASH_SHA1:
-		return snprintf(buf, PAGE_SIZE, "6 (SHA1)\n");
-	}
-	return snprintf(buf, PAGE_SIZE, "%d (Unrecognized)\n",
-			vport->auth.hash_id);
-}
-static ssize_t
-lpfc_auth_last_show(struct device *dev, struct device_attribute *attr,
-		    char *buf)
-{
-	struct Scsi_Host  *shost = class_to_shost(dev);
-	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
-	struct timeval last_time;
-	if (!vport->cfg_enable_auth || vport->auth.last_auth == 0)
-		return snprintf(buf, PAGE_SIZE, "%d\n", -1);
-	jiffies_to_timeval((jiffies - vport->auth.last_auth), &last_time);
-	return snprintf(buf, PAGE_SIZE, "%ld\n", last_time.tv_sec);
-}
-
-static ssize_t
-lpfc_auth_next_show(struct device *dev, struct device_attribute *attr,
-		    char *buf)
-{
-	struct Scsi_Host  *shost = class_to_shost(dev);
-	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
-	unsigned long next_jiff;
-	struct timeval next_time;
-	if (!vport->cfg_enable_auth ||
-	    vport->auth.last_auth == 0 ||
-	    vport->auth.reauth_interval == 0)
-		return snprintf(buf, PAGE_SIZE, "%d\n", -1);
-	/* calculate the amount of time left until next auth */
-	next_jiff = (msecs_to_jiffies(vport->auth.reauth_interval * 60000) +
-		     vport->auth.last_auth) - jiffies;
-	jiffies_to_timeval(next_jiff, &next_time);
-	return snprintf(buf, PAGE_SIZE, "%ld\n", next_time.tv_sec);
-}
-
 /**
  * lpfc_param_show - Return a cfg attribute value in decimal
  *
@@ -1782,38 +1634,7 @@ static DEVICE_ATTR(max_xri, S_IRUGO, lpf
 static DEVICE_ATTR(used_xri, S_IRUGO, lpfc_used_xri_show, NULL);
 static DEVICE_ATTR(npiv_info, S_IRUGO, lpfc_npiv_info_show, NULL);
 static DEVICE_ATTR(lpfc_temp_sensor, S_IRUGO, lpfc_temp_sensor_show, NULL);
-static DEVICE_ATTR(auth_state, S_IRUGO, lpfc_auth_state_show, NULL);
-static DEVICE_ATTR(auth_dir, S_IRUGO, lpfc_auth_dir_show, NULL);
-static DEVICE_ATTR(auth_protocol, S_IRUGO, lpfc_auth_protocol_show, NULL);
-static DEVICE_ATTR(auth_dhgroup, S_IRUGO, lpfc_auth_dhgroup_show, NULL);
-static DEVICE_ATTR(auth_hash, S_IRUGO, lpfc_auth_hash_show, NULL);
-static DEVICE_ATTR(auth_last, S_IRUGO, lpfc_auth_last_show, NULL);
-static DEVICE_ATTR(auth_next, S_IRUGO, lpfc_auth_next_show, NULL);
-
-static int
-lpfc_parse_wwn(const char *ns, uint8_t *nm)
-{
-	unsigned int i, j;
-	memset(nm, 0, 8);
-
-	/* Validate and store the new name */
-	for (i = 0, j = 0; i < 16; i++) {
-		if ((*ns >= 'a') && (*ns <= 'f'))
-			j = ((j << 4) | ((*ns++ - 'a') + 10));
-		else if ((*ns >= 'A') && (*ns <= 'F'))
-			j = ((j << 4) | ((*ns++ - 'A') + 10));
-		else if ((*ns >= '0') && (*ns <= '9'))
-			j = ((j << 4) | (*ns++ - '0'));
-		else
-			return -EINVAL;
-		if (i % 2) {
-			nm[i/2] = j & 0xff;
-			j = 0;
-		}
-	}
 
-	return 0;
-}
 
 static char *lpfc_soft_wwn_key = "C99G71SL8032A";
 
@@ -2209,88 +2030,6 @@ lpfc_vport_param_store(nodev_tmo)
 
 static DEVICE_ATTR(lpfc_nodev_tmo, S_IRUGO | S_IWUSR,
 		   lpfc_nodev_tmo_show, lpfc_nodev_tmo_store);
-static ssize_t
-lpfc_authenticate(struct device *dev, struct device_attribute *attr,
-		  const char *buf, size_t count)
-{
-	struct Scsi_Host *shost = class_to_shost(dev);
-	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
-	struct lpfc_hba   *phba = vport->phba;
-	struct lpfc_nodelist *ndlp;
-	int status;
-	struct lpfc_name wwpn;
-
-	if (lpfc_parse_wwn(buf, wwpn.u.wwn))
-		return -EINVAL;
-
-	if (vport->port_state == LPFC_VPORT_FAILED) {
-		lpfc_issue_lip(shost);
-		return strlen(buf);
-	}
-	if ((vport->fc_flag & FC_OFFLINE_MODE) ||
-	    (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO) ||
-	    (!vport->cfg_enable_auth))
-		return -EPERM;
-
-	/* If vport already in the middle of authentication do not restart */
-	if ((vport->auth.auth_msg_state == LPFC_AUTH_NEGOTIATE) ||
-	    (vport->auth.auth_msg_state == LPFC_DHCHAP_CHALLENGE) ||
-	    (vport->auth.auth_msg_state == LPFC_DHCHAP_REPLY))
-		return -EAGAIN;
-
-	if (wwn_to_u64(wwpn.u.wwn) == AUTH_FABRIC_WWN)
-		ndlp = lpfc_findnode_did(vport, Fabric_DID);
-	else
-		ndlp = lpfc_findnode_wwnn(vport, &wwpn);
-	if (!ndlp || !NLP_CHK_NODE_ACT(ndlp))
-		return -EPERM;
-	status = lpfc_start_node_authentication(ndlp);
-	if (status)
-		return status;
-	return strlen(buf);
-}
-static DEVICE_ATTR(lpfc_authenticate, S_IRUGO | S_IWUSR, NULL,
-		   lpfc_authenticate);
-
-static ssize_t
-lpfc_update_auth_config(struct device *dev, struct device_attribute *attr,
-			const char *buf, size_t count)
-{
-	struct Scsi_Host *shost = class_to_shost(dev);
-	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
-	struct lpfc_hba   *phba = vport->phba;
-	struct lpfc_nodelist *ndlp;
-	struct lpfc_name wwpn;
-	int status;
-
-	if (lpfc_parse_wwn(buf, wwpn.u.wwn))
-		return -EINVAL;
-
-	if ((vport->fc_flag & FC_OFFLINE_MODE) ||
-	    (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO) ||
-	    (!vport->cfg_enable_auth))
-		return -EPERM;
-
-	/* If vport already in the middle of authentication do not restart */
-	if ((vport->auth.auth_msg_state == LPFC_AUTH_NEGOTIATE) ||
-	    (vport->auth.auth_msg_state == LPFC_DHCHAP_CHALLENGE) ||
-	    (vport->auth.auth_msg_state == LPFC_DHCHAP_REPLY))
-		return -EAGAIN;
-
-	if (wwn_to_u64(wwpn.u.wwn) == AUTH_FABRIC_WWN)
-		status = lpfc_get_auth_config(vport, NULL);
-	else {
-		ndlp = lpfc_findnode_wwnn(vport, &wwpn);
-		if (!ndlp || !NLP_CHK_NODE_ACT(ndlp))
-			return -EPERM;
-		status = lpfc_get_auth_config(vport, ndlp);
-	}
-	if (status)
-		return -EPERM;
-	return strlen(buf);
-}
-static DEVICE_ATTR(lpfc_update_auth_config, S_IRUGO | S_IWUSR,
-		   NULL, lpfc_update_auth_config);
 
 /*
 # lpfc_devloss_tmo: If set, it will hold all I/O errors on devices that
@@ -3384,48 +3123,6 @@ LPFC_ATTR_R(use_msi, 0, 0, 2, "Use Messa
 	    "MSI-X (2), if possible");
 
 /*
-# lpfc_enable_auth: controls FC Authentication.
-#       0 = Authentication OFF
-#       1 = Authentication ON
-# Value range [0,1]. Default value is 0.
-*/
-static int lpfc_enable_auth;
-module_param(lpfc_enable_auth, int, 0);
-MODULE_PARM_DESC(lpfc_enable_auth, "Enable FC Authentication");
-lpfc_vport_param_show(enable_auth);
-lpfc_vport_param_init(enable_auth, 0, 0, 1);
-static int
-lpfc_enable_auth_set(struct lpfc_vport *vport, int val)
-{
-	if (val == vport->cfg_enable_auth)
-		return 0;
-	if (val == 0) {
-		spin_lock_irq(&fc_security_user_lock);
-		list_del(&vport->sc_users);
-		spin_unlock_irq(&fc_security_user_lock);
-		vport->cfg_enable_auth = val;
-		lpfc_fc_queue_security_work(vport,
-					    &vport->sc_offline_work);
-		return 0;
-	} else if (val == 1) {
-		spin_lock_irq(&fc_security_user_lock);
-		list_add_tail(&vport->sc_users, &fc_security_user_list);
-		spin_unlock_irq(&fc_security_user_lock);
-		vport->cfg_enable_auth = val;
-		lpfc_fc_queue_security_work(vport,
-					    &vport->sc_online_work);
-		return 0;
-	}
-	lpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,
-			 "0560 lpfc_enable_auth attribute cannot be set to %d, "
-			 "allowed range is [0, 1]\n", val);
-	return -EINVAL;
-}
-lpfc_vport_param_store(enable_auth);
-static DEVICE_ATTR(lpfc_enable_auth, S_IRUGO | S_IWUSR,
-		   lpfc_enable_auth_show, lpfc_enable_auth_store);
-
-/*
 # lpfc_fcp_imax: Set the maximum number of fast-path FCP interrupts per second
 #
 # Value range is [636,651042]. Default value is 10000.
@@ -3566,16 +3263,6 @@ struct device_attribute *lpfc_hba_attrs[
 	&dev_attr_lpfc_poll,
 	&dev_attr_lpfc_poll_tmo,
 	&dev_attr_lpfc_use_msi,
-	&dev_attr_lpfc_enable_auth,
-	&dev_attr_lpfc_authenticate,
-	&dev_attr_lpfc_update_auth_config,
-	&dev_attr_auth_state,
-	&dev_attr_auth_dir,
-	&dev_attr_auth_protocol,
-	&dev_attr_auth_dhgroup,
-	&dev_attr_auth_hash,
-	&dev_attr_auth_last,
-	&dev_attr_auth_next,
 	&dev_attr_lpfc_fcp_imax,
 	&dev_attr_lpfc_fcp_wq_count,
 	&dev_attr_lpfc_fcp_eq_count,
@@ -3613,13 +3300,6 @@ struct device_attribute *lpfc_vport_attr
 	&dev_attr_nport_evt_cnt,
 	&dev_attr_npiv_info,
 	&dev_attr_lpfc_enable_da_id,
-	&dev_attr_auth_state,
-	&dev_attr_auth_dir,
-	&dev_attr_auth_protocol,
-	&dev_attr_auth_dhgroup,
-	&dev_attr_auth_hash,
-	&dev_attr_auth_last,
-	&dev_attr_auth_next,
 	&dev_attr_lpfc_max_scsicmpl_time,
 	&dev_attr_lpfc_stat_data_ctrl,
 	&dev_attr_lpfc_static_vport,
@@ -4801,9 +4481,5 @@ lpfc_get_vport_cfgparam(struct lpfc_vpor
 	lpfc_max_luns_init(vport, lpfc_max_luns);
 	lpfc_scan_down_init(vport, lpfc_scan_down);
 	lpfc_enable_da_id_init(vport, lpfc_enable_da_id);
-	if (vport->phba->sli_rev != LPFC_SLI_REV4)
-		lpfc_enable_auth_init(vport, lpfc_enable_auth);
-	else
-		lpfc_enable_auth_init(vport, 0);
 	return;
 }
--- a/drivers/scsi/lpfc/lpfc_auth_access.c
+++ b/drivers/scsi/lpfc/lpfc_auth_access.c
@@ -1,602 +0,0 @@
-/*******************************************************************
- * This file is part of the Emulex Linux Device Driver for         *
- * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2006-2008 Emulex.  All rights reserved.           *
- * EMULEX and SLI are trademarks of Emulex.                        *
- * www.emulex.com                                                  *
- *                                                                 *
- * This program is free software; you can redistribute it and/or   *
- * modify it under the terms of version 2 of the GNU General       *
- * Public License as published by the Free Software Foundation.    *
- * This program is distributed in the hope that it will be useful. *
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
- * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
- * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
- * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
- * more details, a copy of which can be found in the file COPYING  *
- * included with this package.                                     *
- *******************************************************************/
-#include <linux/blkdev.h>
-#include <linux/pci.h>
-#include <linux/kthread.h>
-#include <linux/interrupt.h>
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/sched.h>	/* workqueue stuff, HZ */
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_host.h>
-#include <scsi/scsi_transport.h>
-#include <scsi/scsi_transport_fc.h>
-#include <scsi/scsi_cmnd.h>
-#include <linux/time.h>
-#include <linux/jiffies.h>
-#include <linux/security.h>
-#include <net/sock.h>
-#include <net/netlink.h>
-
-#include <scsi/scsi.h>
-
-#include "lpfc_hw4.h"
-#include "lpfc_hw.h"
-#include "lpfc_sli.h"
-#include "lpfc_sli4.h"
-#include "lpfc_nl.h"
-#include "lpfc_disc.h"
-#include "lpfc_scsi.h"
-#include "lpfc.h"
-#include "lpfc_logmsg.h"
-#include "lpfc_crtn.h"
-#include "lpfc_vport.h"
-#include "lpfc_auth_access.h"
-
-/* fc security */
-struct workqueue_struct *security_work_q;
-struct list_head fc_security_user_list;
-int fc_service_state = FC_SC_SERVICESTATE_UNKNOWN;
-static int fc_service_pid;
-DEFINE_SPINLOCK(fc_security_user_lock);
-
-static inline struct lpfc_vport *
-lpfc_fc_find_vport(unsigned long host_no)
-{
-	struct lpfc_vport *vport;
-	struct Scsi_Host *shost;
-
-	list_for_each_entry(vport, &fc_security_user_list, sc_users) {
-		shost = lpfc_shost_from_vport(vport);
-		if (shost && (shost->host_no == host_no))
-			return vport;
-	}
-
-	return NULL;
-}
-
-
-/**
- * lpfc_fc_sc_add_timer
- *
- *
- **/
-
-void
-lpfc_fc_sc_add_timer(struct fc_security_request *req, int timeout,
-		    void (*complete)(struct fc_security_request *))
-{
-
-	init_timer(&req->timer);
-
-
-	req->timer.data = (unsigned long)req;
-	req->timer.expires = jiffies + timeout;
-	req->timer.function = (void (*)(unsigned long)) complete;
-
-	add_timer(&req->timer);
-}
-/**
- * lpfc_fc_sc_req_times_out
- *
- *
- **/
-
-void
-lpfc_fc_sc_req_times_out(struct fc_security_request *req)
-{
-
-	unsigned long flags;
-	int found = 0;
-	struct fc_security_request *fc_sc_req;
-	struct lpfc_vport *vport = req->vport;
-	struct Scsi_Host *shost = lpfc_shost_from_vport(vport);
-
-	if (!req)
-		return;
-
-	spin_lock_irqsave(shost->host_lock, flags);
-
-	/* To avoid a completion race check to see if request is on the list */
-
-	list_for_each_entry(fc_sc_req, &vport->sc_response_wait_queue, rlist)
-		if (fc_sc_req == req) {
-			found = 1;
-			break;
-		}
-
-	if (!found) {
-		spin_unlock_irqrestore(shost->host_lock, flags);
-		return;
-		}
-
-	list_del(&fc_sc_req->rlist);
-
-	spin_unlock_irqrestore(shost->host_lock, flags);
-
-	lpfc_printf_vlog(vport, KERN_WARNING, LOG_SECURITY,
-			 "1019 Request tranid %d timed out\n",
-			 fc_sc_req->tran_id);
-
-	switch (fc_sc_req->req_type) {
-
-	case FC_NL_SC_GET_CONFIG_REQ:
-		lpfc_security_config(shost, -ETIMEDOUT,
-			fc_sc_req->data);
-		break;
-
-	case FC_NL_SC_DHCHAP_MAKE_CHALLENGE_REQ:
-		lpfc_dhchap_make_challenge(shost, -ETIMEDOUT,
-			fc_sc_req->data, 0);
-		break;
-
-	case FC_NL_SC_DHCHAP_MAKE_RESPONSE_REQ:
-		lpfc_dhchap_make_response(shost, -ETIMEDOUT,
-			fc_sc_req->data, 0);
-		break;
-
-	case FC_NL_SC_DHCHAP_AUTHENTICATE_REQ:
-		lpfc_dhchap_authenticate(shost, -ETIMEDOUT, fc_sc_req->data, 0);
-		break;
-	}
-
-	kfree(fc_sc_req);
-
-}
-
-
-static inline struct fc_security_request *
-lpfc_fc_find_sc_request(u32 tran_id, u32 type, struct lpfc_vport *vport)
-{
-	struct fc_security_request *fc_sc_req;
-
-	list_for_each_entry(fc_sc_req, &vport->sc_response_wait_queue, rlist)
-		if (fc_sc_req->tran_id == tran_id &&
-			fc_sc_req->req_type == type)
-			return fc_sc_req;
-	return NULL;
-}
-
-
-
-/**
- * lpfc_fc_sc_request
- *
- *
- **/
-
-int
-lpfc_fc_sc_request(struct lpfc_vport *vport,
-	      u32 msg_type,
-	      struct fc_auth_req *auth_req,
-	      u32 auth_req_len, /* includes length of struct fc_auth_req */
-	      struct fc_auth_rsp *auth_rsp,
-	      u32 auth_rsp_len)	/* includes length of struct fc_auth_rsp */
-{
-	struct Scsi_Host *shost = lpfc_shost_from_vport(vport);
-	struct fc_security_request *fc_sc_req;
-	struct fc_nl_sc_message *fc_nl_sc_msg;
-	unsigned long flags;
-	u32 len;
-	u32 seq = ++vport->sc_tran_id;
-
-	if (fc_service_state != FC_SC_SERVICESTATE_ONLINE)
-		return -EINVAL;
-
-	if (vport->port_state == FC_PORTSTATE_DELETED)
-		return -EINVAL;
-
-	fc_sc_req = kzalloc(sizeof(struct fc_security_request), GFP_KERNEL);
-	if (!fc_sc_req)
-		return -ENOMEM;
-
-	fc_sc_req->req_type = msg_type;
-	fc_sc_req->data = auth_rsp;
-	fc_sc_req->data_len = auth_rsp_len;
-	fc_sc_req->vport = vport;
-	fc_sc_req->tran_id = seq;
-
-	len = sizeof(struct fc_nl_sc_message) + auth_req_len;
-	fc_nl_sc_msg = kzalloc(len, GFP_KERNEL);
-	if (!fc_nl_sc_msg) {
-		kfree(fc_sc_req);
-		return -ENOMEM;
-	}
-	fc_nl_sc_msg->msgtype = msg_type;
-	fc_nl_sc_msg->data_len = auth_req_len;
-	memcpy(fc_nl_sc_msg->data, auth_req, auth_req_len);
-	fc_nl_sc_msg->tran_id = seq;
-
-	lpfc_fc_sc_add_timer(fc_sc_req, FC_SC_REQ_TIMEOUT,
-			     lpfc_fc_sc_req_times_out);
-
-	spin_lock_irqsave(shost->host_lock, flags);
-	list_add_tail(&fc_sc_req->rlist, &vport->sc_response_wait_queue);
-	spin_unlock_irqrestore(shost->host_lock, flags);
-	scsi_nl_send_vendor_msg(fc_service_pid, shost->host_no,
-				(SCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_EMULEX),
-				(char *) fc_nl_sc_msg, len);
-	kfree(fc_nl_sc_msg);
-	return 0;
-}
-
-/**
- * lpfc_fc_security_get_config
- *
- *
- **/
-
-int
-lpfc_fc_security_get_config(struct Scsi_Host *shost,
-			struct fc_auth_req *auth_req,
-			u32 auth_req_len,
-			struct fc_auth_rsp *auth_rsp,
-			u32 auth_rsp_len)
-{
-
-	return lpfc_fc_sc_request((struct lpfc_vport *) shost->hostdata,
-				  FC_NL_SC_GET_CONFIG_REQ, auth_req,
-				  auth_req_len, auth_rsp, auth_rsp_len);
-
-}
-EXPORT_SYMBOL(lpfc_fc_security_get_config);
-
-/**
- * lpfc_fc_security_dhchap_make_challenge
- *
- *
- **/
-
-int
-lpfc_fc_security_dhchap_make_challenge(struct Scsi_Host *shost,
-				  struct fc_auth_req *auth_req,
-				  u32 auth_req_len,
-				  struct fc_auth_rsp *auth_rsp,
-				  u32 auth_rsp_len)
-{
-
-	return lpfc_fc_sc_request((struct lpfc_vport *) shost->hostdata,
-				  FC_NL_SC_DHCHAP_MAKE_CHALLENGE_REQ,
-				  auth_req, auth_req_len,
-				  auth_rsp, auth_rsp_len);
-
-}
-EXPORT_SYMBOL(lpfc_fc_security_dhchap_make_challenge);
-
-/**
- * lpfc_fc_security_dhchap_make_response
- *
- *
- **/
-
-int
-lpfc_fc_security_dhchap_make_response(struct Scsi_Host *shost,
-			struct fc_auth_req *auth_req,
-			u32 auth_req_len,
-			struct fc_auth_rsp *auth_rsp,
-			u32 auth_rsp_len)
-{
-
-	return lpfc_fc_sc_request((struct lpfc_vport *) shost->hostdata,
-				  FC_NL_SC_DHCHAP_MAKE_RESPONSE_REQ,
-				  auth_req, auth_req_len,
-				  auth_rsp, auth_rsp_len);
-
-}
-EXPORT_SYMBOL(lpfc_fc_security_dhchap_make_response);
-
-
-/**
- * lpfc_fc_security_dhchap_authenticate
- *
- *
- **/
-
-int
-lpfc_fc_security_dhchap_authenticate(struct Scsi_Host *shost,
-			struct fc_auth_req *auth_req,
-			u32 auth_req_len,
-			struct fc_auth_rsp *auth_rsp,
-			u32 auth_rsp_len)
-{
-
-	return lpfc_fc_sc_request((struct lpfc_vport *) shost->hostdata,
-				  FC_NL_SC_DHCHAP_AUTHENTICATE_REQ,
-				  auth_req, auth_req_len,
-				  auth_rsp, auth_rsp_len);
-
-}
-EXPORT_SYMBOL(lpfc_fc_security_dhchap_authenticate);
-
-/**
- * lpfc_fc_queue_security_work - Queue work to the fc_host security workqueue.
- * @shost:	Pointer to Scsi_Host bound to fc_host.
- * @work:	Work to queue for execution.
- *
- * Return value:
- *	1 - work queued for execution
- *	0 - work is already queued
- *	-EINVAL - work queue doesn't exist
- **/
-int
-lpfc_fc_queue_security_work(struct lpfc_vport *vport, struct work_struct *work)
-{
-	if (unlikely(!security_work_q)) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-			"1021 ERROR: attempted to queue security work, "
-			"when no workqueue created.\n");
-		dump_stack();
-
-		return -EINVAL;
-	}
-
-	return queue_work(security_work_q, work);
-
-}
-
-
-
- /**
- * lpfc_fc_sc_schedule_notify_all
- *
- *
- **/
-
-void
-lpfc_fc_sc_schedule_notify_all(int message)
-{
-	struct lpfc_vport *vport;
-	unsigned long flags;
-
-	spin_lock_irqsave(&fc_security_user_lock, flags);
-	list_for_each_entry(vport, &fc_security_user_list, sc_users) {
-		switch (message) {
-		case FC_NL_SC_REG:
-			lpfc_fc_queue_security_work(vport,
-						    &vport->sc_online_work);
-			break;
-		case FC_NL_SC_DEREG:
-			lpfc_fc_queue_security_work(vport,
-						    &vport->sc_offline_work);
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&fc_security_user_lock, flags);
-}
-
-
-
-/**
- * lpfc_fc_sc_security_online
- *
- *
- **/
-
-void
-lpfc_fc_sc_security_online(struct work_struct *work)
-{
-	struct lpfc_vport *vport = container_of(work, struct lpfc_vport,
-						sc_online_work);
-	lpfc_security_service_online(lpfc_shost_from_vport(vport));
-	return;
-}
-
-/**
- * lpfc_fc_sc_security_offline
- *
- *
- **/
-void
-lpfc_fc_sc_security_offline(struct work_struct *work)
-{
-	struct lpfc_vport *vport = container_of(work, struct lpfc_vport,
-						sc_offline_work);
-	lpfc_security_service_offline(lpfc_shost_from_vport(vport));
-	return;
-}
-
-
-/**
- * lpfc_fc_sc_process_msg
- *
- *
- **/
-static void
-lpfc_fc_sc_process_msg(struct work_struct *work)
-{
-	struct fc_sc_msg_work_q_wrapper *wqw =
-		container_of(work, struct fc_sc_msg_work_q_wrapper, work);
-
-	switch (wqw->msgtype) {
-
-	case FC_NL_SC_GET_CONFIG_RSP:
-		lpfc_security_config(lpfc_shost_from_vport(wqw->fc_sc_req->
-				vport), wqw->status,
-				wqw->fc_sc_req->data);
-		break;
-
-	case FC_NL_SC_DHCHAP_MAKE_CHALLENGE_RSP:
-		lpfc_dhchap_make_challenge(lpfc_shost_from_vport(wqw->
-					fc_sc_req->vport), wqw->status,
-					wqw->fc_sc_req->data, wqw->data_len);
-		break;
-
-	case FC_NL_SC_DHCHAP_MAKE_RESPONSE_RSP:
-		lpfc_dhchap_make_response(lpfc_shost_from_vport(wqw->
-					fc_sc_req->vport), wqw->status,
-					wqw->fc_sc_req->data, wqw->data_len);
-		break;
-
-	case FC_NL_SC_DHCHAP_AUTHENTICATE_RSP:
-		lpfc_dhchap_authenticate(lpfc_shost_from_vport(wqw->fc_sc_req->
-					vport),
-					wqw->status,
-					wqw->fc_sc_req->data, wqw->data_len);
-		break;
-	}
-
-	kfree(wqw->fc_sc_req);
-	kfree(wqw);
-
-	return;
-}
-
-
-/**
- * lpfc_fc_sc_schedule_msg
- *
- *
- **/
-
-int
-lpfc_fc_sc_schedule_msg(struct Scsi_Host *shost,
-			struct fc_nl_sc_message *fc_nl_sc_msg, int rcvlen)
-{
-	struct fc_security_request *fc_sc_req;
-	u32 req_type;
-	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
-	int err = 0;
-	struct fc_sc_msg_work_q_wrapper *wqw;
-	unsigned long flags;
-
-	if (vport->port_state == FC_PORTSTATE_DELETED) {
-		printk(KERN_WARNING
-		"%s: Host being deleted.\n", __func__);
-		return -EBADR;
-	}
-
-	wqw = kzalloc(sizeof(struct fc_sc_msg_work_q_wrapper), GFP_KERNEL);
-
-	if (!wqw)
-		return -ENOMEM;
-
-	switch (fc_nl_sc_msg->msgtype) {
-	case FC_NL_SC_GET_CONFIG_RSP:
-		req_type = FC_NL_SC_GET_CONFIG_REQ;
-		break;
-
-	case FC_NL_SC_DHCHAP_MAKE_CHALLENGE_RSP:
-		req_type = FC_NL_SC_DHCHAP_MAKE_CHALLENGE_REQ;
-		break;
-
-	case FC_NL_SC_DHCHAP_MAKE_RESPONSE_RSP:
-		req_type = FC_NL_SC_DHCHAP_MAKE_RESPONSE_REQ;
-		break;
-
-	case FC_NL_SC_DHCHAP_AUTHENTICATE_RSP:
-		req_type = FC_NL_SC_DHCHAP_AUTHENTICATE_REQ;
-		break;
-
-	default:
-		kfree(wqw);
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(shost->host_lock, flags);
-
-	fc_sc_req = lpfc_fc_find_sc_request(fc_nl_sc_msg->tran_id,
-				req_type, vport);
-
-	if (!fc_sc_req) {
-		spin_unlock_irqrestore(shost->host_lock, flags);
-		lpfc_printf_vlog(vport, KERN_WARNING, LOG_SECURITY,
-				 "1022 Security request does not exist.\n");
-		kfree(wqw);
-		return -EBADR;
-	}
-
-	list_del(&fc_sc_req->rlist);
-
-	spin_unlock_irqrestore(shost->host_lock, flags);
-
-	del_singleshot_timer_sync(&fc_sc_req->timer);
-
-	wqw->status = 0;
-	wqw->fc_sc_req = fc_sc_req;
-	wqw->data_len = rcvlen;
-	wqw->msgtype = fc_nl_sc_msg->msgtype;
-
-	if (!fc_sc_req->data ||
-		(fc_sc_req->data_len < fc_nl_sc_msg->data_len)) {
-		wqw->status = -ENOBUFS;
-		wqw->data_len = 0;
-		lpfc_printf_vlog(vport, KERN_WARNING, LOG_SECURITY,
-				 "1023 Warning - data may have been truncated. "
-				 "data:%p reqdl:%x mesdl:%x\n",
-				 fc_sc_req->data,
-				 fc_sc_req->data_len, fc_nl_sc_msg->data_len);
-	} else {
-		memcpy(fc_sc_req->data, fc_nl_sc_msg->data,
-			fc_nl_sc_msg->data_len);
-	}
-
-	INIT_WORK(&wqw->work, lpfc_fc_sc_process_msg);
-	lpfc_fc_queue_security_work(vport, &wqw->work);
-
-	return err;
-}
-
-int
-lpfc_rcv_nl_msg(struct Scsi_Host *shost, void *payload,
-		uint32_t len, uint32_t pid)
-{
-	struct fc_nl_sc_message *msg = (struct fc_nl_sc_message *)payload;
-	int err = 0;
-printk("%s %d - msgtype:%x\n", __func__, __LINE__, msg->msgtype);
-	switch (msg->msgtype) {
-	case FC_NL_SC_REG:
-		fc_service_pid = pid;
-		fc_service_state = FC_SC_SERVICESTATE_ONLINE;
-		lpfc_fc_sc_schedule_notify_all(FC_NL_SC_REG);
-		break;
-	case FC_NL_SC_DEREG:
-		fc_service_pid = pid;
-		fc_service_state = FC_SC_SERVICESTATE_OFFLINE;
-		lpfc_fc_sc_schedule_notify_all(FC_NL_SC_DEREG);
-		break;
-	case FC_NL_SC_GET_CONFIG_RSP:
-	case FC_NL_SC_DHCHAP_MAKE_CHALLENGE_RSP:
-	case FC_NL_SC_DHCHAP_MAKE_RESPONSE_RSP:
-	case FC_NL_SC_DHCHAP_AUTHENTICATE_RSP:
-		err = lpfc_fc_sc_schedule_msg(shost, msg, len);
-		break;
-	default:
-		printk(KERN_WARNING "%s: unknown msg type 0x%x len %d\n",
-		       __func__, msg->msgtype, len);
-		break;
-	}
-	return err;
-}
-
-void
-lpfc_rcv_nl_event(struct notifier_block *this,
-		  unsigned long event,
-		  void *ptr)
-{
-	struct netlink_notify *n = ptr;
-
-	if ((event == NETLINK_URELEASE) &&
-	    (n->protocol == NETLINK_SCSITRANSPORT) && (n->pid)) {
-		printk(KERN_WARNING "Warning - Security Service Offline\n");
-		fc_service_state = FC_SC_SERVICESTATE_OFFLINE;
-		lpfc_fc_sc_schedule_notify_all(FC_NL_SC_DEREG);
-	}
-}
--- a/drivers/scsi/lpfc/lpfc_auth_access.h
+++ b/drivers/scsi/lpfc/lpfc_auth_access.h
@@ -1,225 +0,0 @@
-/*******************************************************************
- * This file is part of the Emulex Linux Device Driver for         *
- * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2006-2008 Emulex.  All rights reserved.           *
- * EMULEX and SLI are trademarks of Emulex.                        *
- * www.emulex.com                                                  *
- *                                                                 *
- * This program is free software; you can redistribute it and/or   *
- * modify it under the terms of version 2 of the GNU General       *
- * Public License as published by the Free Software Foundation.    *
- * This program is distributed in the hope that it will be useful. *
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
- * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
- * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
- * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
- * more details, a copy of which can be found in the file COPYING  *
- * included with this package.                                     *
- *******************************************************************/
-
-#define FC_SC_REQ_TIMEOUT (60*HZ)
-
-enum fc_sc_service_state {
-	FC_SC_SERVICESTATE_UNKNOWN,
-	FC_SC_SERVICESTATE_ONLINE,
-	FC_SC_SERVICESTATE_OFFLINE,
-	FC_SC_SERVICESTATE_ERROR,
-};
-
-struct fc_security_request {
-	struct list_head rlist;
-	int pid;
-	u32 tran_id;
-	u32 req_type;
-	struct timer_list timer;
-	struct lpfc_vport *vport;
-	u32 data_len;
-	void *data;
-};
-
-struct fc_sc_msg_work_q_wrapper {
-	struct work_struct work;
-	struct fc_security_request *fc_sc_req;
-	u32 data_len;
-	int status;
-	u32 msgtype;
-};
-struct fc_sc_notify_work_q_wrapper {
-	struct work_struct work;
-	struct Scsi_Host *shost;
-	int msg;
-};
-
-#define FC_DHCHAP	1
-#define FC_FCAP		2
-#define FC_FCPAP	3
-#define FC_KERBEROS	4
-
-#define FC_AUTHMODE_UNKNOWN	0
-#define FC_AUTHMODE_NONE	1
-#define FC_AUTHMODE_ACTIVE	2
-#define FC_AUTHMODE_PASSIVE	3
-
-#define FC_SP_HASH_MD5  0x5
-#define FC_SP_HASH_SHA1 0x6
-
-#define DH_GROUP_NULL	0x00
-#define DH_GROUP_1024	0x01
-#define DH_GROUP_1280	0x02
-#define DH_GROUP_1536	0x03
-#define DH_GROUP_2048	0x04
-
-#define MAX_AUTH_REQ_SIZE 1024
-#define MAX_AUTH_RSP_SIZE 1024
-
-#define AUTH_FABRIC_WWN	0xFFFFFFFFFFFFFFFFLL
-
-struct fc_auth_req {
-	uint64_t local_wwpn;
-	uint64_t remote_wwpn;
-	union {
-		struct dhchap_challenge_req {
-			uint32_t transaction_id;
-			uint32_t dh_group_id;
-			uint32_t hash_id;
-		} dhchap_challenge;
-		struct dhchap_reply_req {
-			uint32_t transaction_id;
-			uint32_t dh_group_id;
-			uint32_t hash_id;
-			uint32_t bidirectional;
-			uint32_t received_challenge_len;
-			uint32_t received_public_key_len;
-			uint8_t  data[0];
-		} dhchap_reply;
-		struct dhchap_success_req {
-			uint32_t transaction_id;
-			uint32_t dh_group_id;
-			uint32_t hash_id;
-			uint32_t our_challenge_len;
-			uint32_t received_response_len;
-			uint32_t received_public_key_len;
-			uint32_t received_challenge_len;
-			uint8_t  data[0];
-		} dhchap_success;
-	} u;
-} __attribute__ ((packed));
-
-struct fc_auth_rsp {
-	uint64_t local_wwpn;
-	uint64_t remote_wwpn;
-	union {
-		struct authinfo {
-			uint8_t  auth_mode;
-			uint16_t auth_timeout;
-			uint8_t  bidirectional;
-			uint8_t  type_priority[4];
-			uint16_t type_len;
-			uint8_t  hash_priority[4];
-			uint16_t hash_len;
-			uint8_t  dh_group_priority[8];
-			uint16_t dh_group_len;
-			uint32_t reauth_interval;
-		} dhchap_security_config;
-		struct dhchap_challenge_rsp {
-			uint32_t transaction_id;
-			uint32_t our_challenge_len;
-			uint32_t our_public_key_len;
-			uint8_t  data[0];
-		} dhchap_challenge;
-		struct dhchap_reply_rsp {
-			uint32_t transaction_id;
-			uint32_t our_challenge_rsp_len;
-			uint32_t our_public_key_len;
-			uint32_t our_challenge_len;
-			uint8_t  data[0];
-		} dhchap_reply;
-		struct dhchap_success_rsp {
-			uint32_t transaction_id;
-			uint32_t authenticated;
-			uint32_t response_len;
-			uint8_t  data[0];
-		} dhchap_success;
-	} u;
-} __attribute__ ((packed));
-
-int
-lpfc_fc_security_get_config(struct Scsi_Host *shost,
-			struct fc_auth_req *auth_req,
-			u32 req_len,
-			struct fc_auth_rsp *auth_rsp,
-			u32 rsp_len);
-int
-lpfc_fc_security_dhchap_make_challenge(struct Scsi_Host *shost,
-			struct fc_auth_req *auth_req,
-			u32 req_len,
-			struct fc_auth_rsp *auth_rsp,
-			u32 rsp_len);
-int
-lpfc_fc_security_dhchap_make_response(struct Scsi_Host *shost,
-			struct fc_auth_req *auth_req,
-			u32 req_len,
-			struct fc_auth_rsp *auth_rsp,
-			u32 rsp_len);
-int
-lpfc_fc_security_dhchap_authenticate(struct Scsi_Host *shost,
-			struct fc_auth_req *auth_req,
-			u32 req_len,
-			struct fc_auth_rsp *auth_rsp,
-			u32 rsp_len);
-
-int lpfc_fc_queue_security_work(struct lpfc_vport *,
-		struct work_struct *);
-
-/*
- * FC Transport Message Types
- */
-	/* user -> kernel */
-#define FC_NL_EVENTS_REG			0x0001
-#define FC_NL_EVENTS_DEREG			0x0002
-#define FC_NL_SC_REG				0x0003
-#define FC_NL_SC_DEREG				0x0004
-#define FC_NL_SC_GET_CONFIG_RSP			0x0005
-#define FC_NL_SC_SET_CONFIG_RSP			0x0006
-#define FC_NL_SC_DHCHAP_MAKE_CHALLENGE_RSP	0x0007
-#define FC_NL_SC_DHCHAP_MAKE_RESPONSE_RSP	0x0008
-#define FC_NL_SC_DHCHAP_AUTHENTICATE_RSP	0x0009
-	/* kernel -> user */
-/* #define FC_NL_ASYNC_EVENT			0x0100 */
-#define FC_NL_SC_GET_CONFIG_REQ			0x0020
-#define FC_NL_SC_SET_CONFIG_REQ			0x0030
-#define FC_NL_SC_DHCHAP_MAKE_CHALLENGE_REQ	0x0040
-#define FC_NL_SC_DHCHAP_MAKE_RESPONSE_REQ	0x0050
-#define FC_NL_SC_DHCHAP_AUTHENTICATE_REQ	0x0060
-
-/*
- * Message Structures :
- */
-
-/* macro to round up message lengths to 8byte boundary */
-#define FC_NL_MSGALIGN(len)		(((len) + 7) & ~7)
-
-#define FC_NETLINK_API_VERSION		1
-
-/* Single Netlink Message type to send all FC Transport messages */
-#define FC_TRANSPORT_MSG		(NLMSG_MIN_TYPE + 1)
-
-/* SCSI_TRANSPORT_MSG event message header */
-/*
-struct scsi_nl_hdr {
-	uint8_t version;
-	uint8_t transport;
-	uint16_t magic;
-	uint16_t msgtype;
-	uint16_t msglen;
-} __attribute__((aligned(sizeof(uint64_t))));
-*/
-struct fc_nl_sc_message {
-	uint16_t msgtype;
-	uint16_t rsvd;
-	uint32_t tran_id;
-	uint32_t data_len;
-	uint8_t data[0];
-} __attribute__((aligned(sizeof(uint64_t))));
-
--- a/drivers/scsi/lpfc/lpfc_auth.c
+++ b/drivers/scsi/lpfc/lpfc_auth.c
@@ -1,833 +0,0 @@
-/*******************************************************************
- * This file is part of the Emulex Linux Device Driver for         *
- * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2006-2008 Emulex.  All rights reserved.           *
- * EMULEX and SLI are trademarks of Emulex.                        *
- * www.emulex.com                                                  *
- *                                                                 *
- * This program is free software; you can redistribute it and/or   *
- * modify it under the terms of version 2 of the GNU General       *
- * Public License as published by the Free Software Foundation.    *
- * This program is distributed in the hope that it will be useful. *
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
- * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
- * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
- * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
- * more details, a copy of which can be found in the file COPYING  *
- * included with this package.                                     *
- *******************************************************************/
-/* See Fibre Channel protocol T11 FC-SP for details */
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_tcq.h>
-#include <scsi/scsi_transport_fc.h>
-
-#include "lpfc_hw4.h"
-#include "lpfc_hw.h"
-#include "lpfc_sli.h"
-#include "lpfc_sli4.h"
-#include "lpfc_nl.h"
-#include "lpfc_disc.h"
-#include "lpfc.h"
-#include "lpfc_crtn.h"
-#include "lpfc_logmsg.h"
-#include "lpfc_auth_access.h"
-#include "lpfc_auth.h"
-
-void
-lpfc_start_authentication(struct lpfc_vport *vport,
-		       struct lpfc_nodelist *ndlp)
-{
-	uint32_t nego_payload_len;
-	uint8_t *nego_payload;
-
-	nego_payload = kmalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
-	if (!nego_payload)
-		return;
-	vport->auth.trans_id++;
-	vport->auth.auth_msg_state = LPFC_AUTH_NEGOTIATE;
-	nego_payload_len = lpfc_build_auth_neg(vport, nego_payload);
-	lpfc_issue_els_auth(vport, ndlp, AUTH_NEGOTIATE,
-			    nego_payload, nego_payload_len);
-	kfree(nego_payload);
-}
-
-void
-lpfc_dhchap_make_challenge(struct Scsi_Host *shost, int status,
-			void *rsp, uint32_t rsp_len)
-{
-	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
-	struct lpfc_nodelist *ndlp;
-	uint32_t chal_payload_len;
-	uint8_t *chal_payload;
-	struct fc_auth_rsp *auth_rsp = rsp;
-
-	ndlp = lpfc_findnode_did(vport, Fabric_DID);
-	if (!ndlp || !NLP_CHK_NODE_ACT(ndlp)) {
-		kfree(rsp);
-		return;
-	}
-
-	lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
-			 "1003 Send dhchap challenge local_wwpn "
-			 "%llX remote_wwpn %llX \n",
-			 (unsigned long long)auth_rsp->local_wwpn,
-			 (unsigned long long)auth_rsp->remote_wwpn);
-
-	chal_payload = kmalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
-	if (!chal_payload) {
-		kfree(rsp);
-		return;
-	}
-	vport->auth.auth_msg_state = LPFC_DHCHAP_CHALLENGE;
-	chal_payload_len = lpfc_build_dhchap_challenge(vport,
-				chal_payload, rsp);
-	lpfc_issue_els_auth(vport, ndlp, DHCHAP_CHALLENGE,
-			    chal_payload, chal_payload_len);
-	kfree(chal_payload);
-	kfree(rsp);
-}
-
-
-void
-lpfc_dhchap_make_response(struct Scsi_Host *shost, int status,
-			void *rsp, uint32_t rsp_len)
-{
-	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
-	struct lpfc_nodelist *ndlp;
-	uint32_t reply_payload_len;
-	uint8_t *reply_payload;
-	struct fc_auth_rsp *auth_rsp = rsp;
-
-	ndlp = lpfc_findnode_did(vport, Fabric_DID);
-	if (!ndlp || !NLP_CHK_NODE_ACT(ndlp)) {
-		kfree(rsp);
-		return;
-	}
-
-	lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
-			 "1004 Send dhchap reply local_wwpn "
-			 "%llX remote_wwpn %llX \n",
-			 (unsigned long long)auth_rsp->local_wwpn,
-			 (unsigned long long)auth_rsp->remote_wwpn);
-
-	reply_payload = kmalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
-	if (!reply_payload) {
-		kfree(rsp);
-		return;
-	}
-
-	vport->auth.auth_msg_state = LPFC_DHCHAP_REPLY;
-	reply_payload_len = lpfc_build_dhchap_reply(vport, reply_payload, rsp);
-	lpfc_issue_els_auth(vport, ndlp, DHCHAP_REPLY,
-			    reply_payload, reply_payload_len);
-	kfree(reply_payload);
-	kfree(rsp);
-
-}
-
-
-void
-lpfc_dhchap_authenticate(struct Scsi_Host *shost,
-			int status, void *rsp,
-			uint32_t rsp_len)
-{
-	struct fc_auth_rsp *auth_rsp = (struct fc_auth_rsp *)rsp;
-	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
-	struct lpfc_nodelist *ndlp;
-
-	ndlp = lpfc_findnode_did(vport, Fabric_DID);
-	if (!ndlp || !NLP_CHK_NODE_ACT(ndlp)) {
-		kfree(rsp);
-		return;
-	}
-	if (status != 0) {
-		lpfc_issue_els_auth_reject(vport, ndlp,
-			AUTH_ERR, AUTHENTICATION_FAILED);
-		kfree(rsp);
-		return;
-	}
-
-	if (auth_rsp->u.dhchap_success.authenticated) {
-		uint32_t suc_payload_len;
-		uint8_t *suc_payload;
-
-		suc_payload = kmalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
-		if (!suc_payload) {
-			lpfc_issue_els_auth_reject(vport, ndlp,
-				AUTH_ERR, AUTHENTICATION_FAILED);
-			kfree(rsp);
-			return;
-		}
-		suc_payload_len = lpfc_build_dhchap_success(vport,
-				suc_payload, rsp);
-		if (suc_payload_len == sizeof(uint32_t)) {
-			/* Auth is complete after sending this SUCCESS */
-			vport->auth.auth_msg_state = LPFC_DHCHAP_SUCCESS;
-		} else {
-			/* Need to wait for SUCCESS from Auth Initiator */
-			vport->auth.auth_msg_state = LPFC_DHCHAP_SUCCESS_REPLY;
-		}
-		lpfc_issue_els_auth(vport, ndlp, DHCHAP_SUCCESS,
-				    suc_payload, suc_payload_len);
-		kfree(suc_payload);
-		vport->auth.direction |= AUTH_DIRECTION_LOCAL;
-	} else {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1005 AUTHENTICATION_FAILURE Nport:x%x\n",
-				 ndlp->nlp_DID);
-		lpfc_issue_els_auth_reject(vport, ndlp,
-					   AUTH_ERR, AUTHENTICATION_FAILED);
-		if (vport->auth.auth_state == LPFC_AUTH_SUCCESS)
-			lpfc_port_auth_failed(ndlp, LPFC_AUTH_FAIL_AUTH_RJT);
-	}
-
-	kfree(rsp);
-}
-
-int
-lpfc_unpack_auth_negotiate(struct lpfc_vport *vport, uint8_t *message,
-			   uint8_t *reason, uint8_t *explanation)
-{
-	uint32_t prot_len;
-	uint32_t param_len;
-	int i, j = 0;
-
-	/* Following is the format of the message. Name Format.
-	 * uint16_t  nameTag;
-	 * uint16_t  nameLength;
-	 * uint8_t   name[8];
-	 * AUTH_Negotiate Message
-	 * uint32_t  NumberOfAuthProtocals
-	 * uint32_t  AuthProtParameter#1Len
-	 * uint32_t  AuthProtID#1  (DH-CHAP = 0x1)
-	 * AUTH_Negotiate DH-CHAP
-	 * uint16_t  DH-CHAPParameterTag (HashList = 0x1)
-	 * uint16_t  DH-CHAPParameterWordCount (number of uint32_t entries)
-	 * uint8_t   DH-CHAPParameter[]; (uint32_t entries)
-	 * uint16_t  DH-CHAPParameterTag (DHglDList = 0x2)
-	 * uint16_t  DH-CHAPParameterWordCount (number of uint32_t entries)
-	 * uint8_t   DH-CHAPParameter[]; (uint32_t entries)
-	 * DHCHAP_Challenge Message
-	 * uint32_t  hashIdentifier;
-	 * uint32_t  dhgroupIdentifier;
-	 * uint32_t  challengevalueLen;
-	 * uint8_t   challengeValue[];
-	 * uint32_t  dhvalueLen;
-	 * uint8_t   dhvalue[];
-	 */
-
-	/* Name Tag */
-	if (be16_to_cpu(*(uint16_t *)message) != NAME_TAG) {
-		*reason = AUTH_ERR;
-		*explanation = BAD_PAYLOAD;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1006 Bad Name tag in auth message 0x%x\n",
-				 be16_to_cpu(*(uint16_t *)message));
-		return 1;
-	}
-	message += sizeof(uint16_t);
-
-	/* Name Length */
-	if (be16_to_cpu(*(uint16_t *)message) != NAME_LEN) {
-		*reason = AUTH_ERR;
-		*explanation = BAD_PAYLOAD;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1007 Bad Name length in auth message 0x%x\n",
-				 be16_to_cpu(*(uint16_t *)message));
-		return 1;
-	}
-	message += sizeof(uint16_t);
-
-	/* Skip over Remote Port Name */
-	message += NAME_LEN;
-
-	 /* Number of Auth Protocols must be 1 DH-CHAP */
-	if (be32_to_cpu(*(uint32_t *)message) != 1) {
-		*reason = AUTH_ERR;
-		*explanation = BAD_PAYLOAD;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1008 Bad Number of Protocols 0x%x\n",
-				 be32_to_cpu(*(uint32_t *)message));
-		return 1;
-	}
-	message += sizeof(uint32_t);
-
-	/* Protocol Parameter Length */
-	prot_len = be32_to_cpu(*(uint32_t *)message);
-	message += sizeof(uint32_t);
-
-	/* Protocol Parameter type */
-	if (be32_to_cpu(*(uint32_t *)message) != FC_DHCHAP) {
-		*reason = AUTH_ERR;
-		*explanation = BAD_PAYLOAD;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1009 Bad param type 0x%x\n",
-				 be32_to_cpu(*(uint32_t *)message));
-		return 1;
-	}
-	message += sizeof(uint32_t);
-
-	/* Parameter #1 Tag */
-	if (be16_to_cpu(*(uint16_t *)message) != HASH_LIST_TAG) {
-		*reason = AUTH_ERR;
-		*explanation = BAD_PAYLOAD;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1010 Bad Tag 1 0x%x\n",
-				 be16_to_cpu(*(uint16_t *)message));
-		return 1;
-	}
-	message += sizeof(uint16_t);
-
-	/* Parameter #1 Length */
-	param_len =  be16_to_cpu(*(uint16_t *)message);
-	message += sizeof(uint16_t);
-
-	/* Choose a hash function */
-	for (i = 0; i < vport->auth.hash_len; i++) {
-		for (j = 0; j < param_len; j++) {
-			if (vport->auth.hash_priority[i] ==
-			    be32_to_cpu(((uint32_t *)message)[j]))
-				break;
-		}
-		if (j != param_len)
-			break;
-	}
-	if (i == vport->auth.hash_len && j == param_len) {
-		*reason = AUTH_ERR;
-		*explanation = BAD_PAYLOAD;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1011 Auth_neg no hash function chosen.\n");
-		return 1;
-	}
-	vport->auth.hash_id = vport->auth.hash_priority[i];
-	message += sizeof(uint32_t) * param_len;
-
-	/* Parameter #2 Tag */
-	if (be16_to_cpu(*(uint16_t *)message) != DHGID_LIST_TAG) {
-		*reason = AUTH_ERR;
-		*explanation = BAD_PAYLOAD;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1012 Auth_negotiate Bad Tag 2 0x%x\n",
-				 be16_to_cpu(*(uint16_t *)message));
-		return 1;
-	}
-	message += sizeof(uint16_t);
-
-	/* Parameter #2 Length */
-	param_len =  be16_to_cpu(*(uint16_t *)message);
-	message += sizeof(uint16_t);
-
-	/* Choose a DH Group */
-	for (i = 0; i < vport->auth.dh_group_len; i++) {
-		for (j = 0; j < param_len; j++) {
-			if (vport->auth.dh_group_priority[i] ==
-			    be32_to_cpu(((uint32_t *)message)[j]))
-				break;
-		}
-		if (j != param_len)
-			break;
-	}
-	if (i == vport->auth.dh_group_len && j == param_len) {
-		*reason = AUTH_ERR;
-		*explanation = BAD_PAYLOAD;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1013 Auth_negotiate  no DH_group found. \n");
-		return 1;
-	}
-	vport->auth.group_id = vport->auth.dh_group_priority[i];
-	message += sizeof(uint32_t) * param_len;
-
-	return 0;
-}
-
-int
-lpfc_unpack_dhchap_challenge(struct lpfc_vport *vport, uint8_t *message,
-			     uint8_t *reason, uint8_t *explanation)
-{
-	int i;
-
-	/* Following is the format of the message DHCHAP_Challenge.
-	 * uint16_t  nameTag;
-	 * uint16_t  nameLength;
-	 * uint8_t   name[8];
-	 * uint32_t  hashIdentifier;
-	 * uint32_t  dhgroupIdentifier;
-	 * uint32_t  challengevalueLen;
-	 * uint8_t   challengeValue[];
-	 * uint32_t  dhvalueLen;
-	 * uint8_t   dhvalue[];
-	 */
-
-	/* Name Tag */
-	if (be16_to_cpu(*(uint16_t *)message) != NAME_TAG) {
-		*reason = AUTH_ERR;
-		*explanation = BAD_PAYLOAD;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1014 dhchap challenge bad name tag 0x%x. \n",
-				 be16_to_cpu(*(uint16_t *)message));
-		return 1;
-	}
-	message += sizeof(uint16_t);
-
-	/* Name Length */
-	if (be16_to_cpu(*(uint16_t *)message) != NAME_LEN) {
-		*reason = AUTH_ERR;
-		*explanation = BAD_PAYLOAD;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1015 dhchap challenge bad name length "
-				 "0x%x.\n", be16_to_cpu(*(uint16_t *)message));
-		return 1;
-	}
-	message += sizeof(uint16_t);
-
-	/* Remote Port Name */
-	message += NAME_LEN;
-
-	/* Hash ID */
-	vport->auth.hash_id = be32_to_cpu(*(uint32_t *)message);  /* Hash id */
-	for (i = 0; i < vport->auth.hash_len; i++) {
-		if (vport->auth.hash_id == vport->auth.hash_priority[i])
-			break;
-	}
-	if (i == vport->auth.hash_len) {
-		*reason = LOGIC_ERR;
-		*explanation = BAD_ALGORITHM;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1016 dhchap challenge Hash ID not Supported "
-				 "0x%x. \n", vport->auth.hash_id);
-		return 1;
-	}
-	message += sizeof(uint32_t);
-
-	vport->auth.group_id =
-		be32_to_cpu(*(uint32_t *)message);  /* DH group id */
-	for (i = 0; i < vport->auth.dh_group_len; i++) {
-		if (vport->auth.group_id == vport->auth.dh_group_priority[i])
-			break;
-	}
-	if (i == vport->auth.dh_group_len) {
-		*reason = LOGIC_ERR;
-		*explanation = BAD_DHGROUP;
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1017 dhchap challenge could not find DH "
-				 "Group. \n");
-		return 1;
-	}
-	message += sizeof(uint32_t);
-
-	vport->auth.challenge_len =
-		be32_to_cpu(*(uint32_t *)message);  /* Challenge Len */
-	message += sizeof(uint32_t);
-
-	/* copy challenge to vport */
-	if (vport->auth.challenge != NULL)
-		kfree(vport->auth.challenge);
-	vport->auth.challenge = kmalloc(vport->auth.challenge_len, GFP_KERNEL);
-	if (!vport->auth.challenge) {
-		*reason = AUTH_ERR;
-		return 1;
-	}
-	memcpy(vport->auth.challenge, message, vport->auth.challenge_len);
-	message += vport->auth.challenge_len;
-
-	vport->auth.dh_pub_key_len =
-		be32_to_cpu(*(uint32_t *)message);  /* DH Value Len */
-	message += sizeof(uint32_t);
-
-	if (vport->auth.dh_pub_key_len != 0) {
-		if (vport->auth.group_id == DH_GROUP_NULL) {
-			*reason = LOGIC_ERR;
-			*explanation = BAD_DHGROUP;
-			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-					 "1018 dhchap challenge No Public key "
-					 "for non-NULL DH Group.\n");
-			return 1;
-		}
-
-		/* Copy to the vport to save for authentication */
-		if (vport->auth.dh_pub_key != NULL)
-			kfree(vport->auth.dh_pub_key);
-		vport->auth.dh_pub_key = kmalloc(vport->auth.dh_pub_key_len,
-				GFP_KERNEL);
-		if (!vport->auth.dh_pub_key) {
-			*reason = AUTH_ERR;
-			return 1;
-		}
-		memcpy(vport->auth.dh_pub_key, message,
-			vport->auth.dh_pub_key_len);
-	}
-	return 0;
-}
-
-int
-lpfc_unpack_dhchap_reply(struct lpfc_vport *vport, uint8_t *message,
-			 struct fc_auth_req *fc_req)
-{
-	uint32_t rsp_len;
-	uint32_t dh_len;
-	uint32_t challenge_len;
-
-	/* Following is the format of the message DHCHAP_Reply.
-	 * uint32_t	Response Value Length;
-	 * uint8_t	Response Value[];
-	 * uint32_t	DH Value Length;
-	 * uint8_t	DH Value[];
-	 * uint32_t	Challenge Value Length;
-	 * uint8_t	Challenge Value[];
-	 */
-
-	rsp_len = be32_to_cpu(*(uint32_t *)message);   /* Response Len */
-	message += sizeof(uint32_t);
-	memcpy(fc_req->u.dhchap_success.data + vport->auth.challenge_len,
-	       message, rsp_len);
-	fc_req->u.dhchap_success.received_response_len = rsp_len;
-	message += rsp_len;
-
-	dh_len = be32_to_cpu(*(uint32_t *)message);   /* DH Len */
-	message += sizeof(uint32_t);
-	memcpy(fc_req->u.dhchap_success.data + vport->auth.challenge_len +
-	       rsp_len, message, dh_len);
-	fc_req->u.dhchap_success.received_public_key_len = dh_len;
-	message += dh_len;
-
-	challenge_len = be32_to_cpu(*(uint32_t *)message);   /* Challenge Len */
-	message += sizeof(uint32_t);
-	memcpy(fc_req->u.dhchap_success.data + vport->auth.challenge_len
-	       + rsp_len + dh_len, message, challenge_len);
-	fc_req->u.dhchap_success.received_challenge_len = challenge_len;
-	message += challenge_len;
-
-	return rsp_len + dh_len + challenge_len;
-}
-
-int
-lpfc_unpack_dhchap_success(struct lpfc_vport *vport, uint8_t *message,
-			   struct fc_auth_req *fc_req)
-{
-	uint32_t rsp_len = 0;
-
-	/* DHCHAP_Success.
-	 * uint32_t  responseValueLen;
-	 * uint8_t   response[];
-	 */
-
-	rsp_len = be32_to_cpu(*(uint32_t *)message);   /* Response Len */
-	message += sizeof(uint32_t);
-	memcpy(fc_req->u.dhchap_success.data + vport->auth.challenge_len,
-	       message, rsp_len);
-	fc_req->u.dhchap_success.received_response_len = rsp_len;
-
-	memcpy(fc_req->u.dhchap_success.data +
-		vport->auth.challenge_len + rsp_len,
-		vport->auth.dh_pub_key, vport->auth.dh_pub_key_len);
-
-	fc_req->u.dhchap_success.received_public_key_len =
-		vport->auth.dh_pub_key_len;
-
-	fc_req->u.dhchap_success.received_challenge_len = 0;
-
-	return vport->auth.challenge_len + rsp_len + vport->auth.dh_pub_key_len;
-}
-
-int
-lpfc_build_auth_neg(struct lpfc_vport *vport, uint8_t *message)
-{
-	uint8_t *message_start = message;
-	uint8_t *params_start;
-	uint32_t *params_len;
-	uint32_t len;
-	int i;
-
-	/* Because some of the fields are not static in length
-	 * and number we will pack on the fly.This will be expanded
-	 * in the future to optionally offer DHCHAP or FCAP or both.
-	 * The packing is done in Big Endian byte order DHCHAP_Reply.
-	 *
-	 * uint16_t nameTag;
-	 * uint16_t nameLength;
-	 * uint8_t  name[8];
-	 * uint32_t available;		For now we will only offer one
-					protocol ( DHCHAP ) for authentication.
-	 * uint32_t potocolParamsLenId#1;
-	 * uint32_t protocolId#1;	1 : DHCHAP. The protocol list is
-	 *					in order of preference.
-	 * uint16_t parameter#1Tag	1 : HashList
-	 * uint16_t parameter#1Len	2 : Count of how many parameter values
-	 *                                  follow in order of preference.
-	 * uint16_t parameter#1value#1	5 : MD5 Hash Function
-	 * uint16_t parameter#1value#2	6 : SHA-1 Hash Function
-	 * uint16_t parameter#2Tag		2 : DHglDList
-	 * uint16_t parameter#2Len		1 : Only One is supported now
-	 * uint16_t parameter#2value#1	0 : NULL DH-CHAP Algorithm
-	 * uint16_t parameter#2value#2 ...
-	 * uint32_t protocolParamsLenId#2;
-	 * uint32_t protocolId#2;         2 = FCAP
-	 * uint16_t parameter#1Tag
-	 * uint16_t parameter#1Len
-	 * uint16_t parameter#1value#1
-	 * uint16_t parameter#1value#2 ...
-	 * uint16_t parameter#2Tag
-	 * uint16_t parameter#2Len
-	 * uint16_t parameter#2value#1
-	 * uint16_t parameter#2value#2 ...
-	 */
-
-
-	/* Name Tag */
-	*((uint16_t *)message) = cpu_to_be16(NAME_TAG);
-	message += sizeof(uint16_t);
-
-	/* Name Len */
-	*((uint16_t *)message) = cpu_to_be16(NAME_LEN);
-	message += sizeof(uint16_t);
-
-	memcpy(message, vport->fc_portname.u.wwn, sizeof(uint64_t));
-
-	message += sizeof(uint64_t);
-
-	/* Protocols Available */
-	*((uint32_t *)message) = cpu_to_be32(PROTS_NUM);
-	message += sizeof(uint32_t);
-
-	/* First Protocol Params Len */
-	params_len = (uint32_t *)message;
-	message += sizeof(uint32_t);
-
-	/* Start of first Param */
-	params_start = message;
-
-	 /* Protocol Id */
-	*((uint32_t *)message) = cpu_to_be32(FC_DHCHAP);
-	message += sizeof(uint32_t);
-
-	/* Hash List Tag */
-	*((uint16_t *)message) = cpu_to_be16(HASH_LIST_TAG);
-	message += sizeof(uint16_t);
-
-	/* Hash Value Len */
-	*((uint16_t *)message) = cpu_to_be16(vport->auth.hash_len);
-	message += sizeof(uint16_t);
-
-	/* Hash Value each 4 byte words */
-	for (i = 0; i < vport->auth.hash_len; i++) {
-		*((uint32_t *)message) =
-			cpu_to_be32(vport->auth.hash_priority[i]);
-		message += sizeof(uint32_t);
-	}
-
-	/* DHgIDList Tag */
-	*((uint16_t *)message) = cpu_to_be16(DHGID_LIST_TAG);
-	message += sizeof(uint16_t);
-
-	/* DHgIDListValue Len */
-	*((uint16_t *)message) = cpu_to_be16(vport->auth.dh_group_len);
-
-	message += sizeof(uint16_t);
-
-	/* DHgIDList each 4 byte words */
-
-	for (i = 0; i < vport->auth.dh_group_len; i++) {
-		*((uint32_t *)message) =
-			cpu_to_be32(vport->auth.dh_group_priority[i]);
-		message += sizeof(uint32_t);
-	}
-
-	*params_len = cpu_to_be32(message - params_start);
-
-	len = (uint32_t)(message - message_start);
-
-	return len;
-}
-
-int
-lpfc_build_dhchap_challenge(struct lpfc_vport *vport, uint8_t *message,
-			    struct fc_auth_rsp *fc_rsp)
-{
-	uint8_t *message_start = message;
-
-	/* Because some of the fields are not static in length and number
-	 * we will pack on the fly. The packing is done in Big Endian byte
-	 * order DHCHAP_Challenge.
-	 *
-	 * uint16_t  nameTag;
-	 * uint16_t  nameLength;
-	 * uint8_t   name[8];
-	 * uint32_t  Hash_Identifier;
-	 * uint32_t  DH_Group_Identifier;
-	 * uint32_t  Challenge_Value_Length;
-	 * uint8_t   Challenge_Value[];
-	 * uint32_t  DH_Value_Length;
-	 * uint8_t   DH_Value[];
-	 */
-
-	/* Name Tag */
-	*((uint16_t *)message) = cpu_to_be16(NAME_TAG);
-	message += sizeof(uint16_t);
-
-	/* Name Len */
-	*((uint16_t *)message) = cpu_to_be16(NAME_LEN);
-	message += sizeof(uint16_t);
-
-	memcpy(message, vport->fc_portname.u.wwn, NAME_LEN);
-	message += NAME_LEN;
-
-	/* Hash Value each 4 byte words */
-	*((uint32_t *)message) = cpu_to_be32(vport->auth.hash_id);
-	message += sizeof(uint32_t);
-
-	/* DH group id each 4 byte words */
-	*((uint32_t *)message) = cpu_to_be32(vport->auth.group_id);
-	message += sizeof(uint32_t);
-
-	/* Challenge Length */
-	*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.
-		dhchap_challenge.our_challenge_len);
-	message += sizeof(uint32_t);
-
-	/* copy challenge to vport to save */
-	kfree(vport->auth.challenge);
-	vport->auth.challenge_len = fc_rsp->u.
-		dhchap_challenge.our_challenge_len;
-	vport->auth.challenge = kmalloc(vport->auth.challenge_len, GFP_KERNEL);
-
-	if (!vport->auth.challenge)
-		return 0;
-
-	memcpy(vport->auth.challenge, fc_rsp->u.dhchap_challenge.data,
-	       fc_rsp->u.dhchap_challenge.our_challenge_len);
-
-	/* Challenge */
-	memcpy(message, fc_rsp->u.dhchap_challenge.data,
-	       fc_rsp->u.dhchap_challenge.our_challenge_len);
-	message += fc_rsp->u.dhchap_challenge.our_challenge_len;
-
-	/* Public Key length */
-	*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.
-		dhchap_challenge.our_public_key_len);
-	message += sizeof(uint32_t);
-
-	/* Public Key */
-	memcpy(message, fc_rsp->u.dhchap_challenge.data +
-	       fc_rsp->u.dhchap_challenge.our_challenge_len,
-	       fc_rsp->u.dhchap_challenge.our_public_key_len);
-	message += fc_rsp->u.dhchap_challenge.our_public_key_len;
-
-	return (uint32_t)(message - message_start);
-
-}
-
-int
-lpfc_build_dhchap_reply(struct lpfc_vport *vport, uint8_t *message,
-				struct fc_auth_rsp *fc_rsp)
-
-{
-	uint8_t *message_start = message;
-
-	/*
-	 * Because some of the fields are not static in length and
-	 * number we will pack on the fly. The packing is done in
-	 * Big Endian byte order DHCHAP_Reply.
-	 *
-	 * uint32_t  ResonseLength;
-	 * uint8_t   ResponseValue[];
-	 * uint32_t  DHLength;
-	 * uint8_t   DHValue[];          Our Public key
-	 * uint32_t  ChallengeLength;    Used for bi-directional authentication
-	 * uint8_t   ChallengeValue[];
-	 *
-	 * The combined key ( g^x mod p )^y mod p is used as the last
-	 * hash of the password.
-	 *
-	 * g is the base 2 or 5.
-	 * y is our private key.
-	 * ( g^y mod p ) is our public key which we send.
-	 * ( g^x mod p ) is their public key which we received.
-	 */
-	/* Response Value Length */
-	*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.dhchap_reply.
-		our_challenge_rsp_len);
-
-	message += sizeof(uint32_t);
-	/* Response Value */
-	memcpy(message, fc_rsp->u.dhchap_reply.data,
-		fc_rsp->u.dhchap_reply.our_challenge_rsp_len);
-
-	message += fc_rsp->u.dhchap_reply.our_challenge_rsp_len;
-	/* DH Value Length */
-	*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.dhchap_reply.
-			our_public_key_len);
-
-	message += sizeof(uint32_t);
-	/* DH Value */
-	memcpy(message, fc_rsp->u.dhchap_reply.data +
-				fc_rsp->u.dhchap_reply.our_challenge_rsp_len,
-				fc_rsp->u.dhchap_reply.our_public_key_len);
-
-	message += fc_rsp->u.dhchap_reply.our_public_key_len;
-
-	if (vport->auth.bidirectional) {
-
-		/* copy to vport to save */
-		kfree(vport->auth.challenge);
-		vport->auth.challenge_len = fc_rsp->u.dhchap_reply.
-			our_challenge_len;
-		vport->auth.challenge = kmalloc(vport->auth.challenge_len,
-			GFP_KERNEL);
-		if (!vport->auth.challenge)
-			return 0;
-
-		memcpy(vport->auth.challenge, fc_rsp->u.dhchap_reply.data +
-		       fc_rsp->u.dhchap_reply.our_challenge_rsp_len +
-		       fc_rsp->u.dhchap_reply.our_public_key_len,
-		       fc_rsp->u.dhchap_reply.our_challenge_len);
-		/* Challenge Value Length */
-		*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.
-			dhchap_reply.our_challenge_len);
-		message += sizeof(uint32_t);
-		/* Challenge Value */
-		memcpy(message, fc_rsp->u.dhchap_reply.data +
-			fc_rsp->u.dhchap_reply.our_challenge_rsp_len +
-			fc_rsp->u.dhchap_reply.our_public_key_len,
-			fc_rsp->u.dhchap_reply.our_challenge_len);
-
-		message += fc_rsp->u.dhchap_reply.our_challenge_len;
-
-	} else {
-		*((uint32_t *)message) = 0;      /* Challenge Len for No
-						bidirectional authentication */
-		message += sizeof(uint32_t); /* Challenge Value Not Present */
-	}
-
-	return (uint32_t)(message - message_start);
-
-}
-
-int
-lpfc_build_dhchap_success(struct lpfc_vport *vport, uint8_t *message,
-			  struct fc_auth_rsp *fc_rsp)
-{
-	uint8_t *message_start = message;
-
-	/*
-	 * Because some of the fields are not static in length and number
-	 * we will pack on the fly. The packing is done in Big Endian byte
-	 * order DHCHAP_Success.
-	 * uint32_t  responseValueLen;
-	 * uint8_t   response[];.
-	 */
-
-	*((uint32_t *)message) = cpu_to_be32(fc_rsp->u.
-			dhchap_success.response_len);
-	message += sizeof(uint32_t);
-
-	memcpy(message, fc_rsp->u.dhchap_success.data,
-	       fc_rsp->u.dhchap_success.response_len);
-	message += fc_rsp->u.dhchap_success.response_len;
-
-	return (uint32_t)(message - message_start);
-}
-
--- a/drivers/scsi/lpfc/lpfc_auth.h
+++ b/drivers/scsi/lpfc/lpfc_auth.h
@@ -1,92 +0,0 @@
-/*******************************************************************
- * This file is part of the Emulex Linux Device Driver for         *
- * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2006-2007 Emulex.  All rights reserved.           *
- * EMULEX and SLI are trademarks of Emulex.                        *
- * www.emulex.com                                                  *
- *                                                                 *
- * This program is free software; you can redistribute it and/or   *
- * modify it under the terms of version 2 of the GNU General       *
- * Public License as published by the Free Software Foundation.    *
- * This program is distributed in the hope that it will be useful. *
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
- * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
- * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
- * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
- * more details, a copy of which can be found in the file COPYING  *
- * included with this package.                                     *
- *******************************************************************/
-
-#define N_DH_GROUP            4
-#define ELS_CMD_AUTH_BYTE     0x90
-
-#define AUTH_REJECT           0xA
-#define AUTH_NEGOTIATE        0xB
-#define AUTH_DONE             0xC
-
-#define DHCHAP_CHALLENGE 0x10
-#define DHCHAP_REPLY     0x11
-#define DHCHAP_SUCCESS   0x12
-
-#define FCAP_REQUEST	0x13
-#define FCAP_ACK        0x14
-#define FCAP_CONFIRM    0x15
-
-#define PROTS_NUM	0x01
-
-#define NAME_TAG	0x01
-#define NAME_LEN	0x08
-
-#define HASH_LIST_TAG   0x01
-
-#define DHGID_LIST_TAG  0x02
-
-#define HBA_SECURITY       0x20
-
-#define AUTH_ERR                 0x1
-#define LOGIC_ERR                0x2
-
-#define BAD_DHGROUP              0x2
-#define BAD_ALGORITHM            0x3
-#define AUTHENTICATION_FAILED    0x5
-#define BAD_PAYLOAD              0x6
-#define BAD_PROTOCOL             0x7
-#define RESTART		         0x8
-
-#define AUTH_VERSION	0x1
-
-#define MAX_AUTH_MESSAGE_SIZE 1024
-
-struct lpfc_auth_reject {
-   uint8_t reason;
-   uint8_t explanation;
-   uint8_t reserved[2];
-}  __attribute__ ((packed));
-
-struct lpfc_auth_message {		/* Structure is in Big Endian format */
-	uint8_t command_code;
-	uint8_t flags;
-	uint8_t message_code;
-	uint8_t protocol_ver;
-	uint32_t message_len;
-	uint32_t trans_id;
-	uint8_t data[0];
-}  __attribute__ ((packed));
-
-int lpfc_build_auth_neg(struct lpfc_vport *vport, uint8_t *message);
-int lpfc_build_dhchap_challenge(struct lpfc_vport *vport, uint8_t *message,
-				struct fc_auth_rsp *fc_rsp);
-int lpfc_build_dhchap_reply(struct lpfc_vport *vport, uint8_t *message,
-			    struct fc_auth_rsp *fc_rsp);
-int lpfc_build_dhchap_success(struct lpfc_vport *vport, uint8_t *message,
-			      struct fc_auth_rsp *fc_rsp);
-
-int lpfc_unpack_auth_negotiate(struct lpfc_vport *vport, uint8_t *message,
-				 uint8_t *reason, uint8_t *explanation);
-int lpfc_unpack_dhchap_challenge(struct lpfc_vport *vport, uint8_t *message,
-				 uint8_t *reason, uint8_t *explanation);
-int lpfc_unpack_dhchap_reply(struct lpfc_vport *vport, uint8_t *message,
-			     struct fc_auth_req *fc_req);
-int lpfc_unpack_dhchap_success(struct lpfc_vport *vport, uint8_t *message,
-			       struct fc_auth_req *fc_req);
--- a/drivers/scsi/lpfc/lpfc_bsg.c
+++ b/drivers/scsi/lpfc/lpfc_bsg.c
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2009 Emulex.  All rights reserved.                *
+ * Copyright (C) 2009-2010 Emulex.  All rights reserved.                *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -33,6 +33,7 @@
 #include "lpfc_sli.h"
 #include "lpfc_sli4.h"
 #include "lpfc_nl.h"
+#include "lpfc_bsg.h"
 #include "lpfc_disc.h"
 #include "lpfc_scsi.h"
 #include "lpfc.h"
@@ -41,14 +42,183 @@
 #include "lpfc_vport.h"
 #include "lpfc_version.h"
 
+struct lpfc_bsg_event {
+	struct list_head node;
+	struct kref kref;
+	wait_queue_head_t wq;
+
+	/* Event type and waiter identifiers */
+	uint32_t type_mask;
+	uint32_t req_id;
+	uint32_t reg_id;
+
+	/* next two flags are here for the auto-delete logic */
+	unsigned long wait_time_stamp;
+	int waiting;
+
+	/* seen and not seen events */
+	struct list_head events_to_get;
+	struct list_head events_to_see;
+
+	/* job waiting for this event to finish */
+	struct fc_bsg_job *set_job;
+};
+
+struct lpfc_bsg_iocb {
+	struct lpfc_iocbq *cmdiocbq;
+	struct lpfc_iocbq *rspiocbq;
+	struct lpfc_dmabuf *bmp;
+	struct lpfc_nodelist *ndlp;
+
+	/* job waiting for this iocb to finish */
+	struct fc_bsg_job *set_job;
+};
+
+struct lpfc_bsg_mbox {
+	LPFC_MBOXQ_t *pmboxq;
+	MAILBOX_t *mb;
+
+	/* job waiting for this mbox command to finish */
+	struct fc_bsg_job *set_job;
+};
+
+#define TYPE_EVT 	1
+#define TYPE_IOCB	2
+#define TYPE_MBOX	3
+struct bsg_job_data {
+	uint32_t type;
+	union {
+		struct lpfc_bsg_event *evt;
+		struct lpfc_bsg_iocb iocb;
+		struct lpfc_bsg_mbox mbox;
+	} context_un;
+};
+
+struct event_data {
+	struct list_head node;
+	uint32_t type;
+	uint32_t immed_dat;
+	void *data;
+	uint32_t len;
+};
+
+#define BUF_SZ_4K 4096
+#define SLI_CT_ELX_LOOPBACK 0x10
+
+enum ELX_LOOPBACK_CMD {
+	ELX_LOOPBACK_XRI_SETUP,
+	ELX_LOOPBACK_DATA,
+};
+
+#define ELX_LOOPBACK_HEADER_SZ \
+	(size_t)(&((struct lpfc_sli_ct_request *)NULL)->un)
+
+struct lpfc_dmabufext {
+	struct lpfc_dmabuf dma;
+	uint32_t size;
+	uint32_t flag;
+};
+
+/**
+ * lpfc_bsg_send_mgmt_cmd_cmp - lpfc_bsg_send_mgmt_cmd's completion handler
+ * @phba: Pointer to HBA context object.
+ * @cmdiocbq: Pointer to command iocb.
+ * @rspiocbq: Pointer to response iocb.
+ *
+ * This function is the completion handler for iocbs issued using
+ * lpfc_bsg_send_mgmt_cmd function. This function is called by the
+ * ring event handler function without any lock held. This function
+ * can be called from both worker thread context and interrupt
+ * context. This function also can be called from another thread which
+ * cleans up the SLI layer objects.
+ * This function copies the contents of the response iocb to the
+ * response iocb memory object provided by the caller of
+ * lpfc_sli_issue_iocb_wait and then wakes up the thread which
+ * sleeps for the iocb completion.
+ **/
+static void
+lpfc_bsg_send_mgmt_cmd_cmp(struct lpfc_hba *phba,
+			struct lpfc_iocbq *cmdiocbq,
+			struct lpfc_iocbq *rspiocbq)
+{
+	unsigned long iflags;
+	struct bsg_job_data *dd_data;
+	struct fc_bsg_job *job;
+	IOCB_t *rsp;
+	struct lpfc_dmabuf *bmp;
+	struct lpfc_nodelist *ndlp;
+	struct lpfc_bsg_iocb *iocb;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
+	dd_data = cmdiocbq->context1;
+	if (!dd_data) {
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+		return;
+	}
+
+	iocb = &dd_data->context_un.iocb;
+	job = iocb->set_job;
+	job->dd_data = NULL; /* so timeout handler does not reply */
+
+	spin_lock_irqsave(&phba->hbalock, iflags);
+	cmdiocbq->iocb_flag |= LPFC_IO_WAKE;
+	if (cmdiocbq->context2 && rspiocbq)
+		memcpy(&((struct lpfc_iocbq *)cmdiocbq->context2)->iocb,
+		       &rspiocbq->iocb, sizeof(IOCB_t));
+	spin_unlock_irqrestore(&phba->hbalock, iflags);
+
+	bmp = iocb->bmp;
+	rspiocbq = iocb->rspiocbq;
+	rsp = &rspiocbq->iocb;
+	ndlp = iocb->ndlp;
+
+	pci_unmap_sg(phba->pcidev, job->request_payload.sg_list,
+		     job->request_payload.sg_cnt, DMA_TO_DEVICE);
+	pci_unmap_sg(phba->pcidev, job->reply_payload.sg_list,
+		     job->reply_payload.sg_cnt, DMA_FROM_DEVICE);
+
+	if (rsp->ulpStatus) {
+		if (rsp->ulpStatus == IOSTAT_LOCAL_REJECT) {
+			switch (rsp->un.ulpWord[4] & 0xff) {
+			case IOERR_SEQUENCE_TIMEOUT:
+				rc = -ETIMEDOUT;
+				break;
+			case IOERR_INVALID_RPI:
+				rc = -EFAULT;
+				break;
+			default:
+				rc = -EACCES;
+				break;
+			}
+		} else
+			rc = -EACCES;
+	} else
+		job->reply->reply_payload_rcv_len =
+			rsp->un.genreq64.bdl.bdeSize;
+
+	lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+	lpfc_sli_release_iocbq(phba, rspiocbq);
+	lpfc_sli_release_iocbq(phba, cmdiocbq);
+	lpfc_nlp_put(ndlp);
+	kfree(bmp);
+	kfree(dd_data);
+	/* make error code available to userspace */
+	job->reply->result = rc;
+	/* complete the job back to userspace */
+	job->job_done(job);
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+	return;
+}
+
 /**
- * lpfc_bsg_rport_ct - send a CT command from a bsg request
+ * lpfc_bsg_send_mgmt_cmd - send a CT command from a bsg request
  * @job: fc_bsg_job to handle
- */
+ **/
 static int
-lpfc_bsg_rport_ct(struct fc_bsg_job *job)
+lpfc_bsg_send_mgmt_cmd(struct fc_bsg_job *job)
 {
-	struct Scsi_Host *shost = job->shost;
 	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
 	struct lpfc_hba *phba = vport->phba;
 	struct lpfc_rport_data *rdata = job->rport->dd_data;
@@ -65,57 +235,60 @@ lpfc_bsg_rport_ct(struct fc_bsg_job *job
 	struct scatterlist *sgel = NULL;
 	int numbde;
 	dma_addr_t busaddr;
+	struct bsg_job_data *dd_data;
+	uint32_t creg_val;
 	int rc = 0;
 
 	/* in case no data is transferred */
 	job->reply->reply_payload_rcv_len = 0;
 
+	/* allocate our bsg tracking structure */
+	dd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);
+	if (!dd_data) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2733 Failed allocation of dd_data\n");
+		rc = -ENOMEM;
+		goto no_dd_data;
+	}
+
 	if (!lpfc_nlp_get(ndlp)) {
-		job->reply->result = -ENODEV;
-		return 0;
+		rc = -ENODEV;
+		goto no_ndlp;
+	}
+
+	bmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);
+	if (!bmp) {
+		rc = -ENOMEM;
+		goto free_ndlp;
 	}
 
 	if (ndlp->nlp_flag & NLP_ELS_SND_MASK) {
 		rc = -ENODEV;
-		goto free_ndlp_exit;
+		goto free_bmp;
 	}
 
-	spin_lock_irq(shost->host_lock);
 	cmdiocbq = lpfc_sli_get_iocbq(phba);
 	if (!cmdiocbq) {
 		rc = -ENOMEM;
-		spin_unlock_irq(shost->host_lock);
-		goto free_ndlp_exit;
+		goto free_bmp;
 	}
-	cmd = &cmdiocbq->iocb;
 
+	cmd = &cmdiocbq->iocb;
 	rspiocbq = lpfc_sli_get_iocbq(phba);
 	if (!rspiocbq) {
 		rc = -ENOMEM;
 		goto free_cmdiocbq;
 	}
-	spin_unlock_irq(shost->host_lock);
 
 	rsp = &rspiocbq->iocb;
-
-	bmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);
-	if (!bmp) {
-		rc = -ENOMEM;
-		spin_lock_irq(shost->host_lock);
-		goto free_rspiocbq;
-	}
-
-	spin_lock_irq(shost->host_lock);
 	bmp->virt = lpfc_mbuf_alloc(phba, 0, &bmp->phys);
 	if (!bmp->virt) {
 		rc = -ENOMEM;
-		goto free_bmp;
+		goto free_rspiocbq;
 	}
-	spin_unlock_irq(shost->host_lock);
 
 	INIT_LIST_HEAD(&bmp->list);
 	bpl = (struct ulp_bde64 *) bmp->virt;
-
 	request_nseg = pci_map_sg(phba->pcidev, job->request_payload.sg_list,
 				  job->request_payload.sg_cnt, DMA_TO_DEVICE);
 	for_each_sg(job->request_payload.sg_list, sgel, request_nseg, numbde) {
@@ -157,78 +330,152 @@ lpfc_bsg_rport_ct(struct fc_bsg_job *job
 	cmd->ulpContext = ndlp->nlp_rpi;
 	cmd->ulpOwner = OWN_CHIP;
 	cmdiocbq->vport = phba->pport;
-	cmdiocbq->context1 = NULL;
-	cmdiocbq->context2 = NULL;
+	cmdiocbq->context3 = bmp;
 	cmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;
-
 	timeout = phba->fc_ratov * 2;
-	job->dd_data = cmdiocbq;
+	cmd->ulpTimeout = timeout;
 
-	rc = lpfc_sli_issue_iocb_wait(phba, LPFC_ELS_RING, cmdiocbq, rspiocbq,
-					timeout + LPFC_DRVR_TIMEOUT);
+	cmdiocbq->iocb_cmpl = lpfc_bsg_send_mgmt_cmd_cmp;
+	cmdiocbq->context1 = dd_data;
+	cmdiocbq->context2 = rspiocbq;
+	dd_data->type = TYPE_IOCB;
+	dd_data->context_un.iocb.cmdiocbq = cmdiocbq;
+	dd_data->context_un.iocb.rspiocbq = rspiocbq;
+	dd_data->context_un.iocb.set_job = job;
+	dd_data->context_un.iocb.bmp = bmp;
+	dd_data->context_un.iocb.ndlp = ndlp;
+
+	if (phba->cfg_poll & DISABLE_FCP_RING_INT) {
+		creg_val = readl(phba->HCregaddr);
+		creg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);
+		writel(creg_val, phba->HCregaddr);
+		readl(phba->HCregaddr); /* flush */
+	}
+
+	rc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq, 0);
+
+	if (rc == IOCB_SUCCESS)
+		return 0; /* done for now */
+
+	/* iocb failed so cleanup */
+	pci_unmap_sg(phba->pcidev, job->request_payload.sg_list,
+		     job->request_payload.sg_cnt, DMA_TO_DEVICE);
+	pci_unmap_sg(phba->pcidev, job->reply_payload.sg_list,
+		     job->reply_payload.sg_cnt, DMA_FROM_DEVICE);
 
-	if (rc != IOCB_TIMEDOUT) {
-		pci_unmap_sg(phba->pcidev, job->request_payload.sg_list,
-			     job->request_payload.sg_cnt, DMA_TO_DEVICE);
-		pci_unmap_sg(phba->pcidev, job->reply_payload.sg_list,
-			     job->reply_payload.sg_cnt, DMA_FROM_DEVICE);
-	}
+	lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
 
-	if (rc == IOCB_TIMEDOUT) {
-		lpfc_sli_release_iocbq(phba, rspiocbq);
-		rc = -EACCES;
-		goto free_ndlp_exit;
-	}
+free_rspiocbq:
+	lpfc_sli_release_iocbq(phba, rspiocbq);
+free_cmdiocbq:
+	lpfc_sli_release_iocbq(phba, cmdiocbq);
+free_bmp:
+	kfree(bmp);
+free_ndlp:
+	lpfc_nlp_put(ndlp);
+no_ndlp:
+	kfree(dd_data);
+no_dd_data:
+	/* make error code available to userspace */
+	job->reply->result = rc;
+	job->dd_data = NULL;
+	return rc;
+}
 
-	if (rc != IOCB_SUCCESS) {
-		rc = -EACCES;
-		goto free_outdmp;
-	}
+/**
+ * lpfc_bsg_rport_els_cmp - lpfc_bsg_rport_els's completion handler
+ * @phba: Pointer to HBA context object.
+ * @cmdiocbq: Pointer to command iocb.
+ * @rspiocbq: Pointer to response iocb.
+ *
+ * This function is the completion handler for iocbs issued using
+ * lpfc_bsg_rport_els_cmp function. This function is called by the
+ * ring event handler function without any lock held. This function
+ * can be called from both worker thread context and interrupt
+ * context. This function also can be called from other thread which
+ * cleans up the SLI layer objects.
+ * This function copies the contents of the response iocb to the
+ * response iocb memory object provided by the caller of
+ * lpfc_sli_issue_iocb_wait and then wakes up the thread which
+ * sleeps for the iocb completion.
+ **/
+static void
+lpfc_bsg_rport_els_cmp(struct lpfc_hba *phba,
+			struct lpfc_iocbq *cmdiocbq,
+			struct lpfc_iocbq *rspiocbq)
+{
+	struct bsg_job_data *dd_data;
+	struct fc_bsg_job *job;
+	IOCB_t *rsp;
+	struct lpfc_nodelist *ndlp;
+	struct lpfc_dmabuf *pbuflist = NULL;
+	struct fc_bsg_ctels_reply *els_reply;
+	uint8_t *rjt_data;
+	unsigned long flags;
+	int rc = 0;
 
-	if (rsp->ulpStatus) {
-		if (rsp->ulpStatus == IOSTAT_LOCAL_REJECT) {
-			switch (rsp->un.ulpWord[4] & 0xff) {
-			case IOERR_SEQUENCE_TIMEOUT:
-				rc = -ETIMEDOUT;
-				break;
-			case IOERR_INVALID_RPI:
-				rc = -EFAULT;
-				break;
-			default:
-				rc = -EACCES;
-				break;
-			}
-			goto free_outdmp;
-		}
-	} else
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
+	dd_data = cmdiocbq->context1;
+	/* normal completion and timeout crossed paths, already done */
+	if (!dd_data) {
+		spin_unlock_irqrestore(&phba->hbalock, flags);
+		return;
+	}
+
+	cmdiocbq->iocb_flag |= LPFC_IO_WAKE;
+	if (cmdiocbq->context2 && rspiocbq)
+		memcpy(&((struct lpfc_iocbq *)cmdiocbq->context2)->iocb,
+		       &rspiocbq->iocb, sizeof(IOCB_t));
+
+	job = dd_data->context_un.iocb.set_job;
+	cmdiocbq = dd_data->context_un.iocb.cmdiocbq;
+	rspiocbq = dd_data->context_un.iocb.rspiocbq;
+	rsp = &rspiocbq->iocb;
+	ndlp = dd_data->context_un.iocb.ndlp;
+
+	pci_unmap_sg(phba->pcidev, job->request_payload.sg_list,
+		     job->request_payload.sg_cnt, DMA_TO_DEVICE);
+	pci_unmap_sg(phba->pcidev, job->reply_payload.sg_list,
+		     job->reply_payload.sg_cnt, DMA_FROM_DEVICE);
+
+	if (job->reply->result == -EAGAIN)
+		rc = -EAGAIN;
+	else if (rsp->ulpStatus == IOSTAT_SUCCESS)
 		job->reply->reply_payload_rcv_len =
-			rsp->un.genreq64.bdl.bdeSize;
+			rsp->un.elsreq64.bdl.bdeSize;
+	else if (rsp->ulpStatus == IOSTAT_LS_RJT) {
+		job->reply->reply_payload_rcv_len =
+			sizeof(struct fc_bsg_ctels_reply);
+		/* LS_RJT data returned in word 4 */
+		rjt_data = (uint8_t *)&rsp->un.ulpWord[4];
+		els_reply = &job->reply->reply_data.ctels_reply;
+		els_reply->status = FC_CTELS_STATUS_REJECT;
+		els_reply->rjt_data.action = rjt_data[3];
+		els_reply->rjt_data.reason_code = rjt_data[2];
+		els_reply->rjt_data.reason_explanation = rjt_data[1];
+		els_reply->rjt_data.vendor_unique = rjt_data[0];
+	} else
+		rc = -EIO;
 
-free_outdmp:
-	spin_lock_irq(shost->host_lock);
-	lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
-free_bmp:
-	kfree(bmp);
-free_rspiocbq:
+	pbuflist = (struct lpfc_dmabuf *) cmdiocbq->context3;
+	lpfc_mbuf_free(phba, pbuflist->virt, pbuflist->phys);
 	lpfc_sli_release_iocbq(phba, rspiocbq);
-free_cmdiocbq:
 	lpfc_sli_release_iocbq(phba, cmdiocbq);
-	spin_unlock_irq(shost->host_lock);
-free_ndlp_exit:
 	lpfc_nlp_put(ndlp);
-
+	kfree(dd_data);
 	/* make error code available to userspace */
 	job->reply->result = rc;
+	job->dd_data = NULL;
 	/* complete the job back to userspace */
 	job->job_done(job);
-
-	return 0;
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+	return;
 }
 
 /**
  * lpfc_bsg_rport_els - send an ELS command from a bsg request
  * @job: fc_bsg_job to handle
- */
+ **/
 static int
 lpfc_bsg_rport_els(struct fc_bsg_job *job)
 {
@@ -236,7 +483,6 @@ lpfc_bsg_rport_els(struct fc_bsg_job *jo
 	struct lpfc_hba *phba = vport->phba;
 	struct lpfc_rport_data *rdata = job->rport->dd_data;
 	struct lpfc_nodelist *ndlp = rdata->pnode;
-
 	uint32_t elscmd;
 	uint32_t cmdsize;
 	uint32_t rspsize;
@@ -248,20 +494,30 @@ lpfc_bsg_rport_els(struct fc_bsg_job *jo
 	struct lpfc_dmabuf *prsp;
 	struct lpfc_dmabuf *pbuflist = NULL;
 	struct ulp_bde64 *bpl;
-	int iocb_status;
 	int request_nseg;
 	int reply_nseg;
 	struct scatterlist *sgel = NULL;
 	int numbde;
 	dma_addr_t busaddr;
+	struct bsg_job_data *dd_data;
+	uint32_t creg_val;
 	int rc = 0;
 
 	/* in case no data is transferred */
 	job->reply->reply_payload_rcv_len = 0;
 
+	/* allocate our bsg tracking structure */
+	dd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);
+	if (!dd_data) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2735 Failed allocation of dd_data\n");
+		rc = -ENOMEM;
+		goto no_dd_data;
+	}
+
 	if (!lpfc_nlp_get(ndlp)) {
 		rc = -ENODEV;
-		goto out;
+		goto free_dd_data;
 	}
 
 	elscmd = job->request->rqst_data.r_els.els_code;
@@ -271,24 +527,24 @@ lpfc_bsg_rport_els(struct fc_bsg_job *jo
 	if (!rspiocbq) {
 		lpfc_nlp_put(ndlp);
 		rc = -ENOMEM;
-		goto out;
+		goto free_dd_data;
 	}
 
 	rsp = &rspiocbq->iocb;
 	rpi = ndlp->nlp_rpi;
 
-	cmdiocbq = lpfc_prep_els_iocb(phba->pport, 1, cmdsize, 0, ndlp,
+	cmdiocbq = lpfc_prep_els_iocb(vport, 1, cmdsize, 0, ndlp,
 				      ndlp->nlp_DID, elscmd);
-
 	if (!cmdiocbq) {
-		lpfc_sli_release_iocbq(phba, rspiocbq);
-		return -EIO;
+		rc = -EIO;
+		goto free_rspiocbq;
 	}
 
-	job->dd_data = cmdiocbq;
+	/* prep els iocb set context1 to the ndlp, context2 to the command
+	 * dmabuf, context3 holds the data dmabuf
+	 */
 	pcmd = (struct lpfc_dmabuf *) cmdiocbq->context2;
 	prsp = (struct lpfc_dmabuf *) pcmd->list.next;
-
 	lpfc_mbuf_free(phba, pcmd->virt, pcmd->phys);
 	kfree(pcmd);
 	lpfc_mbuf_free(phba, prsp->virt, prsp->phys);
@@ -300,7 +556,6 @@ lpfc_bsg_rport_els(struct fc_bsg_job *jo
 
 	request_nseg = pci_map_sg(phba->pcidev, job->request_payload.sg_list,
 				  job->request_payload.sg_cnt, DMA_TO_DEVICE);
-
 	for_each_sg(job->request_payload.sg_list, sgel, request_nseg, numbde) {
 		busaddr = sg_dma_address(sgel);
 		bpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;
@@ -322,7 +577,6 @@ lpfc_bsg_rport_els(struct fc_bsg_job *jo
 		bpl->addrHigh = cpu_to_le32(putPaddrHigh(busaddr));
 		bpl++;
 	}
-
 	cmdiocbq->iocb.un.elsreq64.bdl.bdeSize =
 		(request_nseg + reply_nseg) * sizeof(struct ulp_bde64);
 	cmdiocbq->iocb.ulpContext = rpi;
@@ -330,102 +584,62 @@ lpfc_bsg_rport_els(struct fc_bsg_job *jo
 	cmdiocbq->context1 = NULL;
 	cmdiocbq->context2 = NULL;
 
-	iocb_status = lpfc_sli_issue_iocb_wait(phba, LPFC_ELS_RING, cmdiocbq,
-					rspiocbq, (phba->fc_ratov * 2)
-					       + LPFC_DRVR_TIMEOUT);
-
-	/* release the new ndlp once the iocb completes */
-	lpfc_nlp_put(ndlp);
-	if (iocb_status != IOCB_TIMEDOUT) {
-		pci_unmap_sg(phba->pcidev, job->request_payload.sg_list,
-			     job->request_payload.sg_cnt, DMA_TO_DEVICE);
-		pci_unmap_sg(phba->pcidev, job->reply_payload.sg_list,
-			     job->reply_payload.sg_cnt, DMA_FROM_DEVICE);
+	cmdiocbq->iocb_cmpl = lpfc_bsg_rport_els_cmp;
+	cmdiocbq->context1 = dd_data;
+	cmdiocbq->context2 = rspiocbq;
+	dd_data->type = TYPE_IOCB;
+	dd_data->context_un.iocb.cmdiocbq = cmdiocbq;
+	dd_data->context_un.iocb.rspiocbq = rspiocbq;
+	dd_data->context_un.iocb.set_job = job;
+	dd_data->context_un.iocb.bmp = NULL;;
+	dd_data->context_un.iocb.ndlp = ndlp;
+
+	if (phba->cfg_poll & DISABLE_FCP_RING_INT) {
+		creg_val = readl(phba->HCregaddr);
+		creg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);
+		writel(creg_val, phba->HCregaddr);
+		readl(phba->HCregaddr); /* flush */
 	}
+	rc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq, 0);
+	lpfc_nlp_put(ndlp);
+	if (rc == IOCB_SUCCESS)
+		return 0; /* done for now */
 
-	if (iocb_status == IOCB_SUCCESS) {
-		if (rsp->ulpStatus == IOSTAT_SUCCESS) {
-			job->reply->reply_payload_rcv_len =
-				rsp->un.elsreq64.bdl.bdeSize;
-			rc = 0;
-		} else if (rsp->ulpStatus == IOSTAT_LS_RJT) {
-			struct fc_bsg_ctels_reply *els_reply;
-			/* LS_RJT data returned in word 4 */
-			uint8_t *rjt_data = (uint8_t *)&rsp->un.ulpWord[4];
+	pci_unmap_sg(phba->pcidev, job->request_payload.sg_list,
+		     job->request_payload.sg_cnt, DMA_TO_DEVICE);
+	pci_unmap_sg(phba->pcidev, job->reply_payload.sg_list,
+		     job->reply_payload.sg_cnt, DMA_FROM_DEVICE);
 
-			els_reply = &job->reply->reply_data.ctels_reply;
-			job->reply->result = 0;
-			els_reply->status = FC_CTELS_STATUS_REJECT;
-			els_reply->rjt_data.action = rjt_data[0];
-			els_reply->rjt_data.reason_code = rjt_data[1];
-			els_reply->rjt_data.reason_explanation = rjt_data[2];
-			els_reply->rjt_data.vendor_unique = rjt_data[3];
-		} else
-			rc = -EIO;
-	} else
-		rc = -EIO;
+	lpfc_mbuf_free(phba, pbuflist->virt, pbuflist->phys);
 
-	if (iocb_status != IOCB_TIMEDOUT)
-		lpfc_els_free_iocb(phba, cmdiocbq);
+	lpfc_sli_release_iocbq(phba, cmdiocbq);
 
+free_rspiocbq:
 	lpfc_sli_release_iocbq(phba, rspiocbq);
 
-out:
+free_dd_data:
+	kfree(dd_data);
+
+no_dd_data:
 	/* make error code available to userspace */
 	job->reply->result = rc;
-	/* complete the job back to userspace */
-	job->job_done(job);
-
-	return 0;
-}
-
-struct lpfc_ct_event {
-	struct list_head node;
-	int ref;
-	wait_queue_head_t wq;
-
-	/* Event type and waiter identifiers */
-	uint32_t type_mask;
-	uint32_t req_id;
-	uint32_t reg_id;
-
-	/* next two flags are here for the auto-delete logic */
-	unsigned long wait_time_stamp;
-	int waiting;
-
-	/* seen and not seen events */
-	struct list_head events_to_get;
-	struct list_head events_to_see;
-};
-
-struct event_data {
-	struct list_head node;
-	uint32_t type;
-	uint32_t immed_dat;
-	void *data;
-	uint32_t len;
-};
-
-static struct lpfc_ct_event *
-lpfc_ct_event_new(int ev_reg_id, uint32_t ev_req_id)
-{
-	struct lpfc_ct_event *evt = kzalloc(sizeof(*evt), GFP_KERNEL);
-	if (!evt)
-		return NULL;
-
-	INIT_LIST_HEAD(&evt->events_to_get);
-	INIT_LIST_HEAD(&evt->events_to_see);
-	evt->req_id = ev_req_id;
-	evt->reg_id = ev_reg_id;
-	evt->wait_time_stamp = jiffies;
-	init_waitqueue_head(&evt->wq);
-
-	return evt;
+	job->dd_data = NULL;
+	return rc;
 }
 
+/**
+ * lpfc_bsg_event_free - frees an allocated event structure
+ * @kref: Pointer to a kref.
+ *
+ * Called from kref_put. Back cast the kref into an event structure address.
+ * Free any events to get, delete associated nodes, free any events to see,
+ * free any data then free the event itself.
+ **/
 static void
-lpfc_ct_event_free(struct lpfc_ct_event *evt)
+lpfc_bsg_event_free(struct kref *kref)
 {
+	struct lpfc_bsg_event *evt = container_of(kref, struct lpfc_bsg_event,
+						  kref);
 	struct event_data *ed;
 
 	list_del(&evt->node);
@@ -447,25 +661,82 @@ lpfc_ct_event_free(struct lpfc_ct_event 
 	kfree(evt);
 }
 
+/**
+ * lpfc_bsg_event_ref - increments the kref for an event
+ * @evt: Pointer to an event structure.
+ **/
 static inline void
-lpfc_ct_event_ref(struct lpfc_ct_event *evt)
+lpfc_bsg_event_ref(struct lpfc_bsg_event *evt)
 {
-	evt->ref++;
+	kref_get(&evt->kref);
 }
 
+/**
+ * lpfc_bsg_event_unref - Uses kref_put to free an event structure
+ * @evt: Pointer to an event structure.
+ **/
 static inline void
-lpfc_ct_event_unref(struct lpfc_ct_event *evt)
+lpfc_bsg_event_unref(struct lpfc_bsg_event *evt)
 {
-	if (--evt->ref < 0)
-		lpfc_ct_event_free(evt);
+	kref_put(&evt->kref, lpfc_bsg_event_free);
 }
 
-#define SLI_CT_ELX_LOOPBACK 0x10
+/**
+ * lpfc_bsg_event_new - allocate and initialize a event structure
+ * @ev_mask: Mask of events.
+ * @ev_reg_id: Event reg id.
+ * @ev_req_id: Event request id.
+ **/
+static struct lpfc_bsg_event *
+lpfc_bsg_event_new(uint32_t ev_mask, int ev_reg_id, uint32_t ev_req_id)
+{
+	struct lpfc_bsg_event *evt = kzalloc(sizeof(*evt), GFP_KERNEL);
 
-enum ELX_LOOPBACK_CMD {
-	ELX_LOOPBACK_XRI_SETUP,
-	ELX_LOOPBACK_DATA,
-};
+	if (!evt)
+		return NULL;
+
+	INIT_LIST_HEAD(&evt->events_to_get);
+	INIT_LIST_HEAD(&evt->events_to_see);
+	evt->type_mask = ev_mask;
+	evt->req_id = ev_req_id;
+	evt->reg_id = ev_reg_id;
+	evt->wait_time_stamp = jiffies;
+	init_waitqueue_head(&evt->wq);
+	kref_init(&evt->kref);
+	return evt;
+}
+
+/**
+ * diag_cmd_data_free - Frees an lpfc dma buffer extension
+ * @phba: Pointer to HBA context object.
+ * @mlist: Pointer to an lpfc dma buffer extension.
+ **/
+static int
+diag_cmd_data_free(struct lpfc_hba *phba, struct lpfc_dmabufext *mlist)
+{
+	struct lpfc_dmabufext *mlast;
+	struct pci_dev *pcidev;
+	struct list_head head, *curr, *next;
+
+	if ((!mlist) || (!lpfc_is_link_up(phba) &&
+		(phba->link_flag & LS_LOOPBACK_MODE))) {
+		return 0;
+	}
+
+	pcidev = phba->pcidev;
+	list_add_tail(&head, &mlist->dma.list);
+
+	list_for_each_safe(curr, next, &head) {
+		mlast = list_entry(curr, struct lpfc_dmabufext , dma.list);
+		if (mlast->dma.virt)
+			dma_free_coherent(&pcidev->dev,
+					  mlast->size,
+					  mlast->dma.virt,
+					  mlast->dma.phys);
+		kfree(mlast);
+	}
+	return 0;
+}
 
 /**
  * lpfc_bsg_ct_unsol_event - process an unsolicited CT command
@@ -474,9 +745,9 @@ enum ELX_LOOPBACK_CMD {
  * @piocbq:
  *
  * This function is called when an unsolicited CT command is received.  It
- * forwards the event to any processes registerd to receive CT events.
- */
-void
+ * forwards the event to any processes registered to receive CT events.
+ **/
+int
 lpfc_bsg_ct_unsol_event(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,
 			struct lpfc_iocbq *piocbq)
 {
@@ -484,7 +755,7 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba 
 	uint32_t cmd;
 	uint32_t len;
 	struct lpfc_dmabuf *dmabuf = NULL;
-	struct lpfc_ct_event *evt;
+	struct lpfc_bsg_event *evt;
 	struct event_data *evt_dat = NULL;
 	struct lpfc_iocbq *iocbq;
 	size_t offset = 0;
@@ -496,6 +767,9 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba 
 	struct lpfc_dmabuf *bdeBuf2 = piocbq->context3;
 	struct lpfc_hbq_entry *hbqe;
 	struct lpfc_sli_ct_request *ct_req;
+	struct fc_bsg_job *job = NULL;
+	unsigned long flags;
+	int size = 0;
 
 	INIT_LIST_HEAD(&head);
 	list_add_tail(&head, &piocbq->list);
@@ -504,6 +778,10 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba 
 	    piocbq->iocb.un.cont64[0].tus.f.bdeSize == 0)
 		goto error_ct_unsol_exit;
 
+	if (phba->link_state == LPFC_HBA_ERROR ||
+		(!(phba->sli.sli_flag & LPFC_SLI_ACTIVE)))
+		goto error_ct_unsol_exit;
+
 	if (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED)
 		dmabuf = bdeBuf1;
 	else {
@@ -511,7 +789,8 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba 
 				    piocbq->iocb.un.cont64[0].addrLow);
 		dmabuf = lpfc_sli_ringpostbuf_get(phba, pring, dma_addr);
 	}
-
+	if (dmabuf == NULL)
+		goto error_ct_unsol_exit;
 	ct_req = (struct lpfc_sli_ct_request *)dmabuf->virt;
 	evt_req_id = ct_req->FsType;
 	cmd = ct_req->CommandResponse.bits.CmdRsp;
@@ -519,24 +798,24 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba 
 	if (!(phba->sli3_options & LPFC_SLI3_HBQ_ENABLED))
 		lpfc_sli_ringpostbuf_put(phba, pring, dmabuf);
 
-	mutex_lock(&phba->ct_event_mutex);
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
 	list_for_each_entry(evt, &phba->ct_ev_waiters, node) {
-		if (evt->req_id != evt_req_id)
+		if (!(evt->type_mask & FC_REG_CT_EVENT) ||
+			evt->req_id != evt_req_id)
 			continue;
 
-		lpfc_ct_event_ref(evt);
-
+		lpfc_bsg_event_ref(evt);
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
 		evt_dat = kzalloc(sizeof(*evt_dat), GFP_KERNEL);
-		if (!evt_dat) {
-			lpfc_ct_event_unref(evt);
+		if (evt_dat == NULL) {
+			spin_lock_irqsave(&phba->ct_ev_lock, flags);
+			lpfc_bsg_event_unref(evt);
 			lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
 					"2614 Memory allocation failed for "
 					"CT event\n");
 			break;
 		}
 
-		mutex_unlock(&phba->ct_event_mutex);
-
 		if (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {
 			/* take accumulated byte count from the last iocbq */
 			iocbq = list_entry(head.prev, typeof(*iocbq), list);
@@ -550,25 +829,25 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba 
 		}
 
 		evt_dat->data = kzalloc(evt_dat->len, GFP_KERNEL);
-		if (!evt_dat->data) {
+		if (evt_dat->data == NULL) {
 			lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
 					"2615 Memory allocation failed for "
 					"CT event data, size %d\n",
 					evt_dat->len);
 			kfree(evt_dat);
-			mutex_lock(&phba->ct_event_mutex);
-			lpfc_ct_event_unref(evt);
-			mutex_unlock(&phba->ct_event_mutex);
+			spin_lock_irqsave(&phba->ct_ev_lock, flags);
+			lpfc_bsg_event_unref(evt);
+			spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
 			goto error_ct_unsol_exit;
 		}
 
 		list_for_each_entry(iocbq, &head, list) {
+			size = 0;
 			if (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {
 				bdeBuf1 = iocbq->context2;
 				bdeBuf2 = iocbq->context3;
 			}
 			for (i = 0; i < iocbq->iocb.ulpBdeCount; i++) {
-				int size = 0;
 				if (phba->sli3_options &
 				    LPFC_SLI3_HBQ_ENABLED) {
 					if (i == 0) {
@@ -601,9 +880,11 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba 
 						iocbq);
 					kfree(evt_dat->data);
 					kfree(evt_dat);
-					mutex_lock(&phba->ct_event_mutex);
-					lpfc_ct_event_unref(evt);
-					mutex_unlock(&phba->ct_event_mutex);
+					spin_lock_irqsave(&phba->ct_ev_lock,
+						flags);
+					lpfc_bsg_event_unref(evt);
+					spin_unlock_irqrestore(
+						&phba->ct_ev_lock, flags);
 					goto error_ct_unsol_exit;
 				}
 				memcpy((char *)(evt_dat->data) + offset,
@@ -616,15 +897,24 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba 
 								 dmabuf);
 				} else {
 					switch (cmd) {
+					case ELX_LOOPBACK_DATA:
+						diag_cmd_data_free(phba,
+						(struct lpfc_dmabufext *)
+							dmabuf);
+						break;
 					case ELX_LOOPBACK_XRI_SETUP:
-						if (!(phba->sli3_options &
-						      LPFC_SLI3_HBQ_ENABLED))
+						if ((phba->sli_rev ==
+							LPFC_SLI_REV2) ||
+							(phba->sli3_options &
+							LPFC_SLI3_HBQ_ENABLED
+							)) {
+							lpfc_in_buf_free(phba,
+									dmabuf);
+						} else {
 							lpfc_post_buffer(phba,
 									 pring,
 									 1);
-						else
-							lpfc_in_buf_free(phba,
-									dmabuf);
+						}
 						break;
 					default:
 						if (!(phba->sli3_options &
@@ -638,7 +928,7 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba 
 			}
 		}
 
-		mutex_lock(&phba->ct_event_mutex);
+		spin_lock_irqsave(&phba->ct_ev_lock, flags);
 		if (phba->sli_rev == LPFC_SLI_REV4) {
 			evt_dat->immed_dat = phba->ctx_idx;
 			phba->ctx_idx = (phba->ctx_idx + 1) % 64;
@@ -651,122 +941,144 @@ lpfc_bsg_ct_unsol_event(struct lpfc_hba 
 
 		evt_dat->type = FC_REG_CT_EVENT;
 		list_add(&evt_dat->node, &evt->events_to_see);
-		wake_up_interruptible(&evt->wq);
-		lpfc_ct_event_unref(evt);
-		if (evt_req_id == SLI_CT_ELX_LOOPBACK)
+		if (evt_req_id == SLI_CT_ELX_LOOPBACK) {
+			wake_up_interruptible(&evt->wq);
+			lpfc_bsg_event_unref(evt);
 			break;
+		}
+
+		list_move(evt->events_to_see.prev, &evt->events_to_get);
+		lpfc_bsg_event_unref(evt);
+
+		job = evt->set_job;
+		evt->set_job = NULL;
+		if (job) {
+			job->reply->reply_payload_rcv_len = size;
+			/* make error code available to userspace */
+			job->reply->result = 0;
+			job->dd_data = NULL;
+			/* complete the job back to userspace */
+			spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+			job->job_done(job);
+			spin_lock_irqsave(&phba->ct_ev_lock, flags);
+		}
 	}
-	mutex_unlock(&phba->ct_event_mutex);
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
 
 error_ct_unsol_exit:
 	if (!list_empty(&head))
 		list_del(&head);
-
-	return;
+	if (evt_req_id == SLI_CT_ELX_LOOPBACK)
+		return 0;
+	return 1;
 }
 
 /**
- * lpfc_bsg_set_event - process a SET_EVENT bsg vendor command
+ * lpfc_bsg_hba_set_event - process a SET_EVENT bsg vendor command
  * @job: SET_EVENT fc_bsg_job
- */
+ **/
 static int
-lpfc_bsg_set_event(struct fc_bsg_job *job)
+lpfc_bsg_hba_set_event(struct fc_bsg_job *job)
 {
 	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
 	struct lpfc_hba *phba = vport->phba;
 	struct set_ct_event *event_req;
-	struct lpfc_ct_event *evt;
+	struct lpfc_bsg_event *evt;
 	int rc = 0;
+	struct bsg_job_data *dd_data = NULL;
+	uint32_t ev_mask;
+	unsigned long flags;
 
 	if (job->request_len <
 	    sizeof(struct fc_bsg_request) + sizeof(struct set_ct_event)) {
 		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
 				"2612 Received SET_CT_EVENT below minimum "
 				"size\n");
-		return -EINVAL;
+		rc = -EINVAL;
+		goto job_error;
+	}
+
+	dd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);
+	if (dd_data == NULL) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2734 Failed allocation of dd_data\n");
+		rc = -ENOMEM;
+		goto job_error;
 	}
 
 	event_req = (struct set_ct_event *)
 		job->request->rqst_data.h_vendor.vendor_cmd;
-
-	mutex_lock(&phba->ct_event_mutex);
+	ev_mask = ((uint32_t)(unsigned long)event_req->type_mask &
+				FC_REG_EVENT_MASK);
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
 	list_for_each_entry(evt, &phba->ct_ev_waiters, node) {
 		if (evt->reg_id == event_req->ev_reg_id) {
-			lpfc_ct_event_ref(evt);
+			lpfc_bsg_event_ref(evt);
 			evt->wait_time_stamp = jiffies;
 			break;
 		}
 	}
-	mutex_unlock(&phba->ct_event_mutex);
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
 
 	if (&evt->node == &phba->ct_ev_waiters) {
 		/* no event waiting struct yet - first call */
-		evt = lpfc_ct_event_new(event_req->ev_reg_id,
+		evt = lpfc_bsg_event_new(ev_mask, event_req->ev_reg_id,
 					event_req->ev_req_id);
 		if (!evt) {
 			lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
 					"2617 Failed allocation of event "
 					"waiter\n");
-			return -ENOMEM;
+			rc = -ENOMEM;
+			goto job_error;
 		}
 
-		mutex_lock(&phba->ct_event_mutex);
+		spin_lock_irqsave(&phba->ct_ev_lock, flags);
 		list_add(&evt->node, &phba->ct_ev_waiters);
-		lpfc_ct_event_ref(evt);
-		mutex_unlock(&phba->ct_event_mutex);
+		lpfc_bsg_event_ref(evt);
+		evt->wait_time_stamp = jiffies;
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
 	}
 
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
 	evt->waiting = 1;
-	if (wait_event_interruptible(evt->wq,
-				     !list_empty(&evt->events_to_see))) {
-		mutex_lock(&phba->ct_event_mutex);
-		lpfc_ct_event_unref(evt); /* release ref */
-		lpfc_ct_event_unref(evt); /* delete */
-		mutex_unlock(&phba->ct_event_mutex);
-		rc = -EINTR;
-		goto set_event_out;
-	}
-
-	evt->wait_time_stamp = jiffies;
-	evt->waiting = 0;
-
-	mutex_lock(&phba->ct_event_mutex);
-	list_move(evt->events_to_see.prev, &evt->events_to_get);
-	lpfc_ct_event_unref(evt); /* release ref */
-	mutex_unlock(&phba->ct_event_mutex);
-
-set_event_out:
-	/* set_event carries no reply payload */
-	job->reply->reply_payload_rcv_len = 0;
-	/* make error code available to userspace */
-	job->reply->result = rc;
-	/* complete the job back to userspace */
-	job->job_done(job);
+	dd_data->type = TYPE_EVT;
+	dd_data->context_un.evt = evt;
+	evt->set_job = job; /* for unsolicited command */
+	job->dd_data = dd_data; /* for fc transport timeout callback*/
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+	return 0; /* call job done later */
+
+job_error:
+	if (dd_data != NULL)
+		kfree(dd_data);
 
-	return 0;
+	job->dd_data = NULL;
+	return rc;
 }
 
 /**
- * lpfc_bsg_get_event - process a GET_EVENT bsg vendor command
+ * lpfc_bsg_hba_get_event - process a GET_EVENT bsg vendor command
  * @job: GET_EVENT fc_bsg_job
- */
+ **/
 static int
-lpfc_bsg_get_event(struct fc_bsg_job *job)
+lpfc_bsg_hba_get_event(struct fc_bsg_job *job)
 {
 	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
 	struct lpfc_hba *phba = vport->phba;
 	struct get_ct_event *event_req;
 	struct get_ct_event_reply *event_reply;
-	struct lpfc_ct_event *evt;
+	struct lpfc_bsg_event *evt;
 	struct event_data *evt_dat = NULL;
-	int rc = 0;
+	unsigned long flags;
+	uint32_t rc = 0;
 
 	if (job->request_len <
 	    sizeof(struct fc_bsg_request) + sizeof(struct get_ct_event)) {
 		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
 				"2613 Received GET_CT_EVENT request below "
 				"minimum size\n");
-		return -EINVAL;
+		rc = -EINVAL;
+		goto job_error;
 	}
 
 	event_req = (struct get_ct_event *)
@@ -774,13 +1086,12 @@ lpfc_bsg_get_event(struct fc_bsg_job *jo
 
 	event_reply = (struct get_ct_event_reply *)
 		job->reply->reply_data.vendor_reply.vendor_rsp;
-
-	mutex_lock(&phba->ct_event_mutex);
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
 	list_for_each_entry(evt, &phba->ct_ev_waiters, node) {
 		if (evt->reg_id == event_req->ev_reg_id) {
 			if (list_empty(&evt->events_to_get))
 				break;
-			lpfc_ct_event_ref(evt);
+			lpfc_bsg_event_ref(evt);
 			evt->wait_time_stamp = jiffies;
 			evt_dat = list_entry(evt->events_to_get.prev,
 					     struct event_data, node);
@@ -788,118 +1099,1689 @@ lpfc_bsg_get_event(struct fc_bsg_job *jo
 			break;
 		}
 	}
-	mutex_unlock(&phba->ct_event_mutex);
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
 
-	if (!evt_dat) {
+	/* The app may continue to ask for event data until it gets
+	 * an error indicating that there isn't anymore
+	 */
+	if (evt_dat == NULL) {
 		job->reply->reply_payload_rcv_len = 0;
 		rc = -ENOENT;
-		goto error_get_event_exit;
+		goto job_error;
 	}
 
-	if (evt_dat->len > job->reply_payload.payload_len) {
-		evt_dat->len = job->reply_payload.payload_len;
-			lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
-					"2618 Truncated event data at %d "
-					"bytes\n",
-					job->reply_payload.payload_len);
+	if (evt_dat->len > job->request_payload.payload_len) {
+		evt_dat->len = job->request_payload.payload_len;
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2618 Truncated event data at %d "
+				"bytes\n",
+				job->request_payload.payload_len);
 	}
 
+	event_reply->type = evt_dat->type;
 	event_reply->immed_data = evt_dat->immed_dat;
-
 	if (evt_dat->len > 0)
 		job->reply->reply_payload_rcv_len =
-			sg_copy_from_buffer(job->reply_payload.sg_list,
-					    job->reply_payload.sg_cnt,
+			sg_copy_from_buffer(job->request_payload.sg_list,
+					    job->request_payload.sg_cnt,
 					    evt_dat->data, evt_dat->len);
 	else
 		job->reply->reply_payload_rcv_len = 0;
-	rc = 0;
 
-	if (evt_dat)
+	if (evt_dat) {
 		kfree(evt_dat->data);
-	kfree(evt_dat);
-	mutex_lock(&phba->ct_event_mutex);
-	lpfc_ct_event_unref(evt);
-	mutex_unlock(&phba->ct_event_mutex);
+		kfree(evt_dat);
+	}
+
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
+	lpfc_bsg_event_unref(evt);
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+	job->dd_data = NULL;
+	job->reply->result = 0;
+	job->job_done(job);
+	return 0;
+
+job_error:
+	job->dd_data = NULL;
+	job->reply->result = rc;
+	return rc;
+}
+
+/**
+ * lpfc_issue_ct_rsp_cmp - lpfc_issue_ct_rsp's completion handler
+ * @phba: Pointer to HBA context object.
+ * @cmdiocbq: Pointer to command iocb.
+ * @rspiocbq: Pointer to response iocb.
+ *
+ * This function is the completion handler for iocbs issued using
+ * lpfc_issue_ct_rsp_cmp function. This function is called by the
+ * ring event handler function without any lock held. This function
+ * can be called from both worker thread context and interrupt
+ * context. This function also can be called from other thread which
+ * cleans up the SLI layer objects.
+ * This function copy the contents of the response iocb to the
+ * response iocb memory object provided by the caller of
+ * lpfc_sli_issue_iocb_wait and then wakes up the thread which
+ * sleeps for the iocb completion.
+ **/
+static void
+lpfc_issue_ct_rsp_cmp(struct lpfc_hba *phba,
+			struct lpfc_iocbq *cmdiocbq,
+			struct lpfc_iocbq *rspiocbq)
+{
+	struct bsg_job_data *dd_data;
+	struct fc_bsg_job *job;
+	IOCB_t *rsp;
+	struct lpfc_dmabuf *bmp;
+	struct lpfc_nodelist *ndlp;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
+	dd_data = cmdiocbq->context1;
+	/* normal completion and timeout crossed paths, already done */
+	if (!dd_data) {
+		spin_unlock_irqrestore(&phba->hbalock, flags);
+		return;
+	}
+
+	job = dd_data->context_un.iocb.set_job;
+	bmp = dd_data->context_un.iocb.bmp;
+	rsp = &rspiocbq->iocb;
+	ndlp = dd_data->context_un.iocb.ndlp;
+
+	pci_unmap_sg(phba->pcidev, job->request_payload.sg_list,
+		     job->request_payload.sg_cnt, DMA_TO_DEVICE);
+
+	if (rsp->ulpStatus) {
+		if (rsp->ulpStatus == IOSTAT_LOCAL_REJECT) {
+			switch (rsp->un.ulpWord[4] & 0xff) {
+			case IOERR_SEQUENCE_TIMEOUT:
+				rc = -ETIMEDOUT;
+				break;
+			case IOERR_INVALID_RPI:
+				rc = -EFAULT;
+				break;
+			default:
+				rc = -EACCES;
+				break;
+			}
+		} else
+			rc = -EACCES;
+	} else
+		job->reply->reply_payload_rcv_len =
+			rsp->un.genreq64.bdl.bdeSize;
 
-error_get_event_exit:
+	lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+	lpfc_sli_release_iocbq(phba, cmdiocbq);
+	lpfc_nlp_put(ndlp);
+	kfree(bmp);
+	kfree(dd_data);
 	/* make error code available to userspace */
 	job->reply->result = rc;
+	job->dd_data = NULL;
 	/* complete the job back to userspace */
 	job->job_done(job);
-
-	return rc;
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+	return;
 }
 
 /**
- * lpfc_bsg_hst_vendor - process a vendor-specific fc_bsg_job
- * @job: fc_bsg_job to handle
- */
+ * lpfc_issue_ct_rsp - issue a ct response
+ * @phba: Pointer to HBA context object.
+ * @job: Pointer to the job object.
+ * @tag: tag index value into the ports context exchange array.
+ * @bmp: Pointer to a dma buffer descriptor.
+ * @num_entry: Number of enties in the bde.
+ **/
 static int
-lpfc_bsg_hst_vendor(struct fc_bsg_job *job)
+lpfc_issue_ct_rsp(struct lpfc_hba *phba, struct fc_bsg_job *job, uint32_t tag,
+		  struct lpfc_dmabuf *bmp, int num_entry)
 {
-	int command = job->request->rqst_data.h_vendor.vendor_cmd[0];
+	IOCB_t *icmd;
+	struct lpfc_iocbq *ctiocb = NULL;
+	int rc = 0;
+	struct lpfc_nodelist *ndlp = NULL;
+	struct bsg_job_data *dd_data;
+	uint32_t creg_val;
+
+	/* allocate our bsg tracking structure */
+	dd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);
+	if (!dd_data) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2736 Failed allocation of dd_data\n");
+		rc = -ENOMEM;
+		goto no_dd_data;
+	}
 
-	switch (command) {
-	case LPFC_BSG_VENDOR_SET_CT_EVENT:
-		return lpfc_bsg_set_event(job);
-		break;
+	/* Allocate buffer for  command iocb */
+	ctiocb = lpfc_sli_get_iocbq(phba);
+	if (!ctiocb) {
+		rc = ENOMEM;
+		goto no_ctiocb;
+	}
+
+	icmd = &ctiocb->iocb;
+	icmd->un.xseq64.bdl.ulpIoTag32 = 0;
+	icmd->un.xseq64.bdl.addrHigh = putPaddrHigh(bmp->phys);
+	icmd->un.xseq64.bdl.addrLow = putPaddrLow(bmp->phys);
+	icmd->un.xseq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;
+	icmd->un.xseq64.bdl.bdeSize = (num_entry * sizeof(struct ulp_bde64));
+	icmd->un.xseq64.w5.hcsw.Fctl = (LS | LA);
+	icmd->un.xseq64.w5.hcsw.Dfctl = 0;
+	icmd->un.xseq64.w5.hcsw.Rctl = FC_RCTL_DD_SOL_CTL;
+	icmd->un.xseq64.w5.hcsw.Type = FC_TYPE_CT;
+
+	/* Fill in rest of iocb */
+	icmd->ulpCommand = CMD_XMIT_SEQUENCE64_CX;
+	icmd->ulpBdeCount = 1;
+	icmd->ulpLe = 1;
+	icmd->ulpClass = CLASS3;
+	if (phba->sli_rev == LPFC_SLI_REV4) {
+		/* Do not issue unsol response if oxid not marked as valid */
+		if (!(phba->ct_ctx[tag].flags & UNSOL_VALID)) {
+			rc = IOCB_ERROR;
+			goto issue_ct_rsp_exit;
+		}
+		icmd->ulpContext = phba->ct_ctx[tag].oxid;
+		ndlp = lpfc_findnode_did(phba->pport, phba->ct_ctx[tag].SID);
+		if (!ndlp) {
+			lpfc_printf_log(phba, KERN_WARNING, LOG_ELS,
+				 "2721 ndlp null for oxid %x SID %x\n",
+					icmd->ulpContext,
+					phba->ct_ctx[tag].SID);
+			rc = IOCB_ERROR;
+			goto issue_ct_rsp_exit;
+		}
+		icmd->un.ulpWord[3] = ndlp->nlp_rpi;
+		/* The exchange is done, mark the entry as invalid */
+		phba->ct_ctx[tag].flags &= ~UNSOL_VALID;
+	} else
+		icmd->ulpContext = (ushort) tag;
 
-	case LPFC_BSG_VENDOR_GET_CT_EVENT:
-		return lpfc_bsg_get_event(job);
-		break;
+	icmd->ulpTimeout = phba->fc_ratov * 2;
 
-	default:
-		return -EINVAL;
-	}
+	/* Xmit CT response on exchange <xid> */
+	lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
+			"2722 Xmit CT response on exchange x%x Data: x%x x%x\n",
+			icmd->ulpContext, icmd->ulpIoTag, phba->link_state);
+
+	ctiocb->iocb_cmpl = NULL;
+	ctiocb->iocb_flag |= LPFC_IO_LIBDFC;
+	ctiocb->vport = phba->pport;
+	ctiocb->context3 = bmp;
+
+	ctiocb->iocb_cmpl = lpfc_issue_ct_rsp_cmp;
+	ctiocb->context1 = dd_data;
+	ctiocb->context2 = NULL;
+	dd_data->type = TYPE_IOCB;
+	dd_data->context_un.iocb.cmdiocbq = ctiocb;
+	dd_data->context_un.iocb.rspiocbq = NULL;
+	dd_data->context_un.iocb.set_job = job;
+	dd_data->context_un.iocb.bmp = bmp;
+	dd_data->context_un.iocb.ndlp = ndlp;
+
+	if (phba->cfg_poll & DISABLE_FCP_RING_INT) {
+		creg_val = readl(phba->HCregaddr);
+		creg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);
+		writel(creg_val, phba->HCregaddr);
+		readl(phba->HCregaddr); /* flush */
+	}
+
+	rc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, ctiocb, 0);
+
+	if (rc == IOCB_SUCCESS)
+		return 0; /* done for now */
+
+issue_ct_rsp_exit:
+	lpfc_sli_release_iocbq(phba, ctiocb);
+no_ctiocb:
+	kfree(dd_data);
+no_dd_data:
+	return rc;
 }
 
 /**
- * lpfc_bsg_request - handle a bsg request from the FC transport
- * @job: fc_bsg_job to handle
- */
-int
-lpfc_bsg_request(struct fc_bsg_job *job)
+ * lpfc_bsg_send_mgmt_rsp - process a SEND_MGMT_RESP bsg vendor command
+ * @job: SEND_MGMT_RESP fc_bsg_job
+ **/
+static int
+lpfc_bsg_send_mgmt_rsp(struct fc_bsg_job *job)
 {
-	uint32_t msgcode;
-	int rc = -EINVAL;
+	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
+	struct lpfc_hba *phba = vport->phba;
+	struct send_mgmt_resp *mgmt_resp = (struct send_mgmt_resp *)
+		job->request->rqst_data.h_vendor.vendor_cmd;
+	struct ulp_bde64 *bpl;
+	struct lpfc_dmabuf *bmp = NULL;
+	struct scatterlist *sgel = NULL;
+	int request_nseg;
+	int numbde;
+	dma_addr_t busaddr;
+	uint32_t tag = mgmt_resp->tag;
+	unsigned long reqbfrcnt =
+			(unsigned long)job->request_payload.payload_len;
+	int rc = 0;
 
-	msgcode = job->request->msgcode;
+	/* in case no data is transferred */
+	job->reply->reply_payload_rcv_len = 0;
 
-	switch (msgcode) {
-	case FC_BSG_HST_VENDOR:
-		rc = lpfc_bsg_hst_vendor(job);
-		break;
-	case FC_BSG_RPT_ELS:
-		rc = lpfc_bsg_rport_els(job);
-		break;
-	case FC_BSG_RPT_CT:
-		rc = lpfc_bsg_rport_ct(job);
-		break;
-	default:
-		break;
+	if (!reqbfrcnt || (reqbfrcnt > (80 * BUF_SZ_4K))) {
+		rc = -ERANGE;
+		goto send_mgmt_rsp_exit;
+	}
+
+	bmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);
+	if (!bmp) {
+		rc = -ENOMEM;
+		goto send_mgmt_rsp_exit;
+	}
+
+	bmp->virt = lpfc_mbuf_alloc(phba, 0, &bmp->phys);
+	if (!bmp->virt) {
+		rc = -ENOMEM;
+		goto send_mgmt_rsp_free_bmp;
+	}
+
+	INIT_LIST_HEAD(&bmp->list);
+	bpl = (struct ulp_bde64 *) bmp->virt;
+	request_nseg = pci_map_sg(phba->pcidev, job->request_payload.sg_list,
+				  job->request_payload.sg_cnt, DMA_TO_DEVICE);
+	for_each_sg(job->request_payload.sg_list, sgel, request_nseg, numbde) {
+		busaddr = sg_dma_address(sgel);
+		bpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;
+		bpl->tus.f.bdeSize = sg_dma_len(sgel);
+		bpl->tus.w = cpu_to_le32(bpl->tus.w);
+		bpl->addrLow = cpu_to_le32(putPaddrLow(busaddr));
+		bpl->addrHigh = cpu_to_le32(putPaddrHigh(busaddr));
+		bpl++;
 	}
 
+	rc = lpfc_issue_ct_rsp(phba, job, tag, bmp, request_nseg);
+
+	if (rc == IOCB_SUCCESS)
+		return 0; /* done for now */
+
+	/* TBD need to handle a timeout */
+	pci_unmap_sg(phba->pcidev, job->request_payload.sg_list,
+			  job->request_payload.sg_cnt, DMA_TO_DEVICE);
+	rc = -EACCES;
+	lpfc_mbuf_free(phba, bmp->virt, bmp->phys);
+
+send_mgmt_rsp_free_bmp:
+	kfree(bmp);
+send_mgmt_rsp_exit:
+	/* make error code available to userspace */
+	job->reply->result = rc;
+	job->dd_data = NULL;
 	return rc;
 }
 
 /**
- * lpfc_bsg_timeout - handle timeout of a bsg request from the FC transport
- * @job: fc_bsg_job that has timed out
+ * lpfc_bsg_diag_mode - process a LPFC_BSG_VENDOR_DIAG_MODE bsg vendor command
+ * @job: LPFC_BSG_VENDOR_DIAG_MODE
  *
- * This function just aborts the job's IOCB.  The aborted IOCB will return to
- * the waiting function which will handle passing the error back to userspace
+ * This function is responsible for placing a port into diagnostic loopback
+ * mode in order to perform a diagnostic loopback test.
+ * All new scsi requests are blocked, a small delay is used to allow the
+ * scsi requests to complete then the link is brought down. If the link is
+ * is placed in loopback mode then scsi requests are again allowed
+ * so the scsi mid-layer doesn't give up on the port.
+ * All of this is done in-line.
  */
-int
-lpfc_bsg_timeout(struct fc_bsg_job *job)
+static int
+lpfc_bsg_diag_mode(struct fc_bsg_job *job)
 {
+	struct Scsi_Host *shost = job->shost;
 	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
 	struct lpfc_hba *phba = vport->phba;
-	struct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)job->dd_data;
-	struct lpfc_sli_ring *pring = &phba->sli.ring[LPFC_ELS_RING];
+	struct diag_mode_set *loopback_mode;
+	struct lpfc_sli *psli = &phba->sli;
+	struct lpfc_sli_ring *pring = &psli->ring[LPFC_FCP_RING];
+	uint32_t link_flags;
+	uint32_t timeout;
+	struct lpfc_vport **vports;
+	LPFC_MBOXQ_t *pmboxq;
+	int mbxstatus;
+	int i = 0;
+	int rc = 0;
 
-	if (cmdiocb)
-		lpfc_sli_issue_abort_iotag(phba, pring, cmdiocb);
+	/* no data to return just the return code */
+	job->reply->reply_payload_rcv_len = 0;
+
+	if (job->request_len <
+	    sizeof(struct fc_bsg_request) + sizeof(struct diag_mode_set)) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2738 Received DIAG MODE request below minimum "
+				"size\n");
+		rc = -EINVAL;
+		goto job_error;
+	}
+
+	loopback_mode = (struct diag_mode_set *)
+		job->request->rqst_data.h_vendor.vendor_cmd;
+	link_flags = loopback_mode->type;
+	timeout = loopback_mode->timeout;
+
+	if ((phba->link_state == LPFC_HBA_ERROR) ||
+	    (psli->sli_flag & LPFC_BLOCK_MGMT_IO) ||
+	    (!(psli->sli_flag & LPFC_SLI_ACTIVE))) {
+		rc = -EACCES;
+		goto job_error;
+	}
+
+	pmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
+	if (!pmboxq) {
+		rc = -ENOMEM;
+		goto job_error;
+	}
+
+	vports = lpfc_create_vport_work_array(phba);
+	if (vports) {
+		for (i = 0; i <= phba->max_vpi && vports[i] != NULL; i++) {
+			shost = lpfc_shost_from_vport(vports[i]);
+			scsi_block_requests(shost);
+		}
+
+		lpfc_destroy_vport_work_array(phba, vports);
+	} else {
+		shost = lpfc_shost_from_vport(phba->pport);
+		scsi_block_requests(shost);
+	}
+
+	while (pring->txcmplq_cnt) {
+		if (i++ > 500)	/* wait up to 5 seconds */
+			break;
+
+		msleep(10);
+	}
+
+	memset((void *)pmboxq, 0, sizeof(LPFC_MBOXQ_t));
+	pmboxq->u.mb.mbxCommand = MBX_DOWN_LINK;
+	pmboxq->u.mb.mbxOwner = OWN_HOST;
+
+	mbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq, LPFC_MBOX_TMO);
+
+	if ((mbxstatus == MBX_SUCCESS) && (pmboxq->u.mb.mbxStatus == 0)) {
+		/* wait for link down before proceeding */
+		i = 0;
+		while (phba->link_state != LPFC_LINK_DOWN) {
+			if (i++ > timeout) {
+				rc = -ETIMEDOUT;
+				goto loopback_mode_exit;
+			}
+
+			msleep(10);
+		}
+
+		memset((void *)pmboxq, 0, sizeof(LPFC_MBOXQ_t));
+		if (link_flags == INTERNAL_LOOP_BACK)
+			pmboxq->u.mb.un.varInitLnk.link_flags = FLAGS_LOCAL_LB;
+		else
+			pmboxq->u.mb.un.varInitLnk.link_flags =
+				FLAGS_TOPOLOGY_MODE_LOOP;
+
+		pmboxq->u.mb.mbxCommand = MBX_INIT_LINK;
+		pmboxq->u.mb.mbxOwner = OWN_HOST;
+
+		mbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq,
+						     LPFC_MBOX_TMO);
+
+		if ((mbxstatus != MBX_SUCCESS) || (pmboxq->u.mb.mbxStatus))
+			rc = -ENODEV;
+		else {
+			phba->link_flag |= LS_LOOPBACK_MODE;
+			/* wait for the link attention interrupt */
+			msleep(100);
+
+			i = 0;
+			while (phba->link_state != LPFC_HBA_READY) {
+				if (i++ > timeout) {
+					rc = -ETIMEDOUT;
+					break;
+				}
+
+				msleep(10);
+			}
+		}
+
+	} else
+		rc = -ENODEV;
+
+loopback_mode_exit:
+	vports = lpfc_create_vport_work_array(phba);
+	if (vports) {
+		for (i = 0; i <= phba->max_vpi && vports[i] != NULL; i++) {
+			shost = lpfc_shost_from_vport(vports[i]);
+			scsi_unblock_requests(shost);
+		}
+		lpfc_destroy_vport_work_array(phba, vports);
+	} else {
+		shost = lpfc_shost_from_vport(phba->pport);
+		scsi_unblock_requests(shost);
+	}
+
+	/*
+	 * Let SLI layer release mboxq if mbox command completed after timeout.
+	 */
+	if (mbxstatus != MBX_TIMEOUT)
+		mempool_free(pmboxq, phba->mbox_mem_pool);
+
+job_error:
+	/* make error code available to userspace */
+	job->reply->result = rc;
+	/* complete the job back to userspace if no error */
+	if (rc == 0)
+		job->job_done(job);
+	return rc;
+}
+
+/**
+ * lpfcdiag_loop_self_reg - obtains a remote port login id
+ * @phba: Pointer to HBA context object
+ * @rpi: Pointer to a remote port login id
+ *
+ * This function obtains a remote port login id so the diag loopback test
+ * can send and receive its own unsolicited CT command.
+ **/
+static int lpfcdiag_loop_self_reg(struct lpfc_hba *phba, uint16_t * rpi)
+{
+	LPFC_MBOXQ_t *mbox;
+	struct lpfc_dmabuf *dmabuff;
+	int status;
+
+	mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
+	if (!mbox)
+		return ENOMEM;
+
+	status = lpfc_reg_rpi(phba, 0, phba->pport->fc_myDID,
+				(uint8_t *)&phba->pport->fc_sparam, mbox, 0);
+	if (status) {
+		mempool_free(mbox, phba->mbox_mem_pool);
+		return ENOMEM;
+	}
+
+	dmabuff = (struct lpfc_dmabuf *) mbox->context1;
+	mbox->context1 = NULL;
+	status = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_TMO);
+
+	if ((status != MBX_SUCCESS) || (mbox->u.mb.mbxStatus)) {
+		lpfc_mbuf_free(phba, dmabuff->virt, dmabuff->phys);
+		kfree(dmabuff);
+		if (status != MBX_TIMEOUT)
+			mempool_free(mbox, phba->mbox_mem_pool);
+		return ENODEV;
+	}
+
+	*rpi = mbox->u.mb.un.varWords[0];
+
+	lpfc_mbuf_free(phba, dmabuff->virt, dmabuff->phys);
+	kfree(dmabuff);
+	mempool_free(mbox, phba->mbox_mem_pool);
+	return 0;
+}
+
+/**
+ * lpfcdiag_loop_self_unreg - unregs from the rpi
+ * @phba: Pointer to HBA context object
+ * @rpi: Remote port login id
+ *
+ * This function unregisters the rpi obtained in lpfcdiag_loop_self_reg
+ **/
+static int lpfcdiag_loop_self_unreg(struct lpfc_hba *phba, uint16_t rpi)
+{
+	LPFC_MBOXQ_t *mbox;
+	int status;
+
+	/* Allocate mboxq structure */
+	mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
+	if (mbox == NULL)
+		return ENOMEM;
+
+	lpfc_unreg_login(phba, 0, rpi, mbox);
+	status = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_TMO);
+
+	if ((status != MBX_SUCCESS) || (mbox->u.mb.mbxStatus)) {
+		if (status != MBX_TIMEOUT)
+			mempool_free(mbox, phba->mbox_mem_pool);
+		return EIO;
+	}
+
+	mempool_free(mbox, phba->mbox_mem_pool);
+	return 0;
+}
+
+/**
+ * lpfcdiag_loop_get_xri - obtains the transmit and receive ids
+ * @phba: Pointer to HBA context object
+ * @rpi: Remote port login id
+ * @txxri: Pointer to transmit exchange id
+ * @rxxri: Pointer to response exchabge id
+ *
+ * This function obtains the transmit and receive ids required to send
+ * an unsolicited ct command with a payload. A special lpfc FsType and CmdRsp
+ * flags are used to the unsolicted response handler is able to process
+ * the ct command sent on the same port.
+ **/
+static int lpfcdiag_loop_get_xri(struct lpfc_hba *phba, uint16_t rpi,
+			 uint16_t *txxri, uint16_t * rxxri)
+{
+	struct lpfc_bsg_event *evt;
+	struct lpfc_iocbq *cmdiocbq, *rspiocbq;
+	IOCB_t *cmd, *rsp;
+	struct lpfc_dmabuf *dmabuf;
+	struct ulp_bde64 *bpl = NULL;
+	struct lpfc_sli_ct_request *ctreq = NULL;
+	int ret_val = 0;
+	unsigned long flags;
+
+	*txxri = 0;
+	*rxxri = 0;
+	evt = lpfc_bsg_event_new(FC_REG_CT_EVENT, current->pid,
+				SLI_CT_ELX_LOOPBACK);
+	if (!evt)
+		return ENOMEM;
+
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
+	list_add(&evt->node, &phba->ct_ev_waiters);
+	lpfc_bsg_event_ref(evt);
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+
+	cmdiocbq = lpfc_sli_get_iocbq(phba);
+	rspiocbq = lpfc_sli_get_iocbq(phba);
+
+	dmabuf = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);
+	if (dmabuf) {
+		dmabuf->virt = lpfc_mbuf_alloc(phba, 0, &dmabuf->phys);
+		INIT_LIST_HEAD(&dmabuf->list);
+		bpl = (struct ulp_bde64 *) dmabuf->virt;
+		memset(bpl, 0, sizeof(*bpl));
+		ctreq = (struct lpfc_sli_ct_request *)(bpl + 1);
+		bpl->addrHigh =
+			le32_to_cpu(putPaddrHigh(dmabuf->phys + sizeof(*bpl)));
+		bpl->addrLow =
+			le32_to_cpu(putPaddrLow(dmabuf->phys + sizeof(*bpl)));
+		bpl->tus.f.bdeFlags = 0;
+		bpl->tus.f.bdeSize = ELX_LOOPBACK_HEADER_SZ;
+		bpl->tus.w = le32_to_cpu(bpl->tus.w);
+	}
+
+	if (cmdiocbq == NULL || rspiocbq == NULL ||
+	    dmabuf == NULL || bpl == NULL || ctreq == NULL) {
+		ret_val = ENOMEM;
+		goto err_get_xri_exit;
+	}
+
+	cmd = &cmdiocbq->iocb;
+	rsp = &rspiocbq->iocb;
+
+	memset(ctreq, 0, ELX_LOOPBACK_HEADER_SZ);
+
+	ctreq->RevisionId.bits.Revision = SLI_CT_REVISION;
+	ctreq->RevisionId.bits.InId = 0;
+	ctreq->FsType = SLI_CT_ELX_LOOPBACK;
+	ctreq->FsSubType = 0;
+	ctreq->CommandResponse.bits.CmdRsp = ELX_LOOPBACK_XRI_SETUP;
+	ctreq->CommandResponse.bits.Size = 0;
+
+
+	cmd->un.xseq64.bdl.addrHigh = putPaddrHigh(dmabuf->phys);
+	cmd->un.xseq64.bdl.addrLow = putPaddrLow(dmabuf->phys);
+	cmd->un.xseq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;
+	cmd->un.xseq64.bdl.bdeSize = sizeof(*bpl);
+
+	cmd->un.xseq64.w5.hcsw.Fctl = LA;
+	cmd->un.xseq64.w5.hcsw.Dfctl = 0;
+	cmd->un.xseq64.w5.hcsw.Rctl = FC_RCTL_DD_UNSOL_CTL;
+	cmd->un.xseq64.w5.hcsw.Type = FC_TYPE_CT;
+
+	cmd->ulpCommand = CMD_XMIT_SEQUENCE64_CR;
+	cmd->ulpBdeCount = 1;
+	cmd->ulpLe = 1;
+	cmd->ulpClass = CLASS3;
+	cmd->ulpContext = rpi;
+
+	cmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;
+	cmdiocbq->vport = phba->pport;
+
+	ret_val = lpfc_sli_issue_iocb_wait(phba, LPFC_ELS_RING, cmdiocbq,
+				rspiocbq,
+				(phba->fc_ratov * 2)
+				+ LPFC_DRVR_TIMEOUT);
+	if (ret_val)
+		goto err_get_xri_exit;
+
+	*txxri =  rsp->ulpContext;
+
+	evt->waiting = 1;
+	evt->wait_time_stamp = jiffies;
+	ret_val = wait_event_interruptible_timeout(
+		evt->wq, !list_empty(&evt->events_to_see),
+		((phba->fc_ratov * 2) + LPFC_DRVR_TIMEOUT) * HZ);
+	if (list_empty(&evt->events_to_see))
+		ret_val = (ret_val) ? EINTR : ETIMEDOUT;
+	else {
+		ret_val = IOCB_SUCCESS;
+		spin_lock_irqsave(&phba->ct_ev_lock, flags);
+		list_move(evt->events_to_see.prev, &evt->events_to_get);
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+		*rxxri = (list_entry(evt->events_to_get.prev,
+				     typeof(struct event_data),
+				     node))->immed_dat;
+	}
+	evt->waiting = 0;
+
+err_get_xri_exit:
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
+	lpfc_bsg_event_unref(evt); /* release ref */
+	lpfc_bsg_event_unref(evt); /* delete */
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+
+	if (dmabuf) {
+		if (dmabuf->virt)
+			lpfc_mbuf_free(phba, dmabuf->virt, dmabuf->phys);
+		kfree(dmabuf);
+	}
+
+	if (cmdiocbq && (ret_val != IOCB_TIMEDOUT))
+		lpfc_sli_release_iocbq(phba, cmdiocbq);
+	if (rspiocbq)
+		lpfc_sli_release_iocbq(phba, rspiocbq);
+	return ret_val;
+}
+
+/**
+ * diag_cmd_data_alloc - fills in a bde struct with dma buffers
+ * @phba: Pointer to HBA context object
+ * @bpl: Pointer to 64 bit bde structure
+ * @size: Number of bytes to process
+ * @nocopydata: Flag to copy user data into the allocated buffer
+ *
+ * This function allocates page size buffers and populates an lpfc_dmabufext.
+ * If allowed the user data pointed to with indataptr is copied into the kernel
+ * memory. The chained list of page size buffers is returned.
+ **/
+static struct lpfc_dmabufext *
+diag_cmd_data_alloc(struct lpfc_hba *phba,
+		   struct ulp_bde64 *bpl, uint32_t size,
+		   int nocopydata)
+{
+	struct lpfc_dmabufext *mlist = NULL;
+	struct lpfc_dmabufext *dmp;
+	int cnt, offset = 0, i = 0;
+	struct pci_dev *pcidev;
+
+	pcidev = phba->pcidev;
+
+	while (size) {
+		/* We get chunks of 4K */
+		if (size > BUF_SZ_4K)
+			cnt = BUF_SZ_4K;
+		else
+			cnt = size;
+
+		/* allocate struct lpfc_dmabufext buffer header */
+		dmp = kmalloc(sizeof(struct lpfc_dmabufext), GFP_KERNEL);
+		if (!dmp)
+			goto out;
+
+		INIT_LIST_HEAD(&dmp->dma.list);
+
+		/* Queue it to a linked list */
+		if (mlist)
+			list_add_tail(&dmp->dma.list, &mlist->dma.list);
+		else
+			mlist = dmp;
+
+		/* allocate buffer */
+		dmp->dma.virt = dma_alloc_coherent(&pcidev->dev,
+						   cnt,
+						   &(dmp->dma.phys),
+						   GFP_KERNEL);
+
+		if (!dmp->dma.virt)
+			goto out;
+
+		dmp->size = cnt;
+
+		if (nocopydata) {
+			bpl->tus.f.bdeFlags = 0;
+			pci_dma_sync_single_for_device(phba->pcidev,
+				dmp->dma.phys, LPFC_BPL_SIZE, PCI_DMA_TODEVICE);
+
+		} else {
+			memset((uint8_t *)dmp->dma.virt, 0, cnt);
+			bpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;
+		}
+
+		/* build buffer ptr list for IOCB */
+		bpl->addrLow = le32_to_cpu(putPaddrLow(dmp->dma.phys));
+		bpl->addrHigh = le32_to_cpu(putPaddrHigh(dmp->dma.phys));
+		bpl->tus.f.bdeSize = (ushort) cnt;
+		bpl->tus.w = le32_to_cpu(bpl->tus.w);
+		bpl++;
+
+		i++;
+		offset += cnt;
+		size -= cnt;
+	}
+
+	mlist->flag = i;
+	return mlist;
+out:
+	diag_cmd_data_free(phba, mlist);
+	return NULL;
+}
+
+/**
+ * lpfcdiag_loop_post_rxbufs - post the receive buffers for an unsol CT cmd
+ * @phba: Pointer to HBA context object
+ * @rxxri: Receive exchange id
+ * @len: Number of data bytes
+ *
+ * This function allocates and posts a data buffer of sufficient size to recieve
+ * an unsolicted CT command.
+ **/
+static int lpfcdiag_loop_post_rxbufs(struct lpfc_hba *phba, uint16_t rxxri,
+			     size_t len)
+{
+	struct lpfc_sli *psli = &phba->sli;
+	struct lpfc_sli_ring *pring = &psli->ring[LPFC_ELS_RING];
+	struct lpfc_iocbq *cmdiocbq;
+	IOCB_t *cmd = NULL;
+	struct list_head head, *curr, *next;
+	struct lpfc_dmabuf *rxbmp;
+	struct lpfc_dmabuf *dmp;
+	struct lpfc_dmabuf *mp[2] = {NULL, NULL};
+	struct ulp_bde64 *rxbpl = NULL;
+	uint32_t num_bde;
+	struct lpfc_dmabufext *rxbuffer = NULL;
+	int ret_val = 0;
+	int i = 0;
+
+	cmdiocbq = lpfc_sli_get_iocbq(phba);
+	rxbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);
+	if (rxbmp != NULL) {
+		rxbmp->virt = lpfc_mbuf_alloc(phba, 0, &rxbmp->phys);
+		INIT_LIST_HEAD(&rxbmp->list);
+		rxbpl = (struct ulp_bde64 *) rxbmp->virt;
+		rxbuffer = diag_cmd_data_alloc(phba, rxbpl, len, 0);
+	}
+
+	if (!cmdiocbq || !rxbmp || !rxbpl || !rxbuffer) {
+		ret_val = ENOMEM;
+		goto err_post_rxbufs_exit;
+	}
+
+	/* Queue buffers for the receive exchange */
+	num_bde = (uint32_t)rxbuffer->flag;
+	dmp = &rxbuffer->dma;
+
+	cmd = &cmdiocbq->iocb;
+	i = 0;
+
+	INIT_LIST_HEAD(&head);
+	list_add_tail(&head, &dmp->list);
+	list_for_each_safe(curr, next, &head) {
+		mp[i] = list_entry(curr, struct lpfc_dmabuf, list);
+		list_del(curr);
+
+		if (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {
+			mp[i]->buffer_tag = lpfc_sli_get_buffer_tag(phba);
+			cmd->un.quexri64cx.buff.bde.addrHigh =
+				putPaddrHigh(mp[i]->phys);
+			cmd->un.quexri64cx.buff.bde.addrLow =
+				putPaddrLow(mp[i]->phys);
+			cmd->un.quexri64cx.buff.bde.tus.f.bdeSize =
+				((struct lpfc_dmabufext *)mp[i])->size;
+			cmd->un.quexri64cx.buff.buffer_tag = mp[i]->buffer_tag;
+			cmd->ulpCommand = CMD_QUE_XRI64_CX;
+			cmd->ulpPU = 0;
+			cmd->ulpLe = 1;
+			cmd->ulpBdeCount = 1;
+			cmd->unsli3.que_xri64cx_ext_words.ebde_count = 0;
+
+		} else {
+			cmd->un.cont64[i].addrHigh = putPaddrHigh(mp[i]->phys);
+			cmd->un.cont64[i].addrLow = putPaddrLow(mp[i]->phys);
+			cmd->un.cont64[i].tus.f.bdeSize =
+				((struct lpfc_dmabufext *)mp[i])->size;
+					cmd->ulpBdeCount = ++i;
+
+			if ((--num_bde > 0) && (i < 2))
+				continue;
+
+			cmd->ulpCommand = CMD_QUE_XRI_BUF64_CX;
+			cmd->ulpLe = 1;
+		}
+
+		cmd->ulpClass = CLASS3;
+		cmd->ulpContext = rxxri;
+
+		ret_val = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq, 0);
+
+		if (ret_val == IOCB_ERROR) {
+			diag_cmd_data_free(phba,
+				(struct lpfc_dmabufext *)mp[0]);
+			if (mp[1])
+				diag_cmd_data_free(phba,
+					  (struct lpfc_dmabufext *)mp[1]);
+			dmp = list_entry(next, struct lpfc_dmabuf, list);
+			ret_val = EIO;
+			goto err_post_rxbufs_exit;
+		}
+
+		lpfc_sli_ringpostbuf_put(phba, pring, mp[0]);
+		if (mp[1]) {
+			lpfc_sli_ringpostbuf_put(phba, pring, mp[1]);
+			mp[1] = NULL;
+		}
+
+		/* The iocb was freed by lpfc_sli_issue_iocb */
+		cmdiocbq = lpfc_sli_get_iocbq(phba);
+		if (!cmdiocbq) {
+			dmp = list_entry(next, struct lpfc_dmabuf, list);
+			ret_val = EIO;
+			goto err_post_rxbufs_exit;
+		}
+
+		cmd = &cmdiocbq->iocb;
+		i = 0;
+	}
+	list_del(&head);
+
+err_post_rxbufs_exit:
+
+	if (rxbmp) {
+		if (rxbmp->virt)
+			lpfc_mbuf_free(phba, rxbmp->virt, rxbmp->phys);
+		kfree(rxbmp);
+	}
+
+	if (cmdiocbq)
+		lpfc_sli_release_iocbq(phba, cmdiocbq);
+	return ret_val;
+}
+
+/**
+ * lpfc_bsg_diag_test - with a port in loopback issues a Ct cmd to itself
+ * @job: LPFC_BSG_VENDOR_DIAG_TEST fc_bsg_job
+ *
+ * This function receives a user data buffer to be transmitted and received on
+ * the same port, the link must be up and in loopback mode prior
+ * to being called.
+ * 1. A kernel buffer is allocated to copy the user data into.
+ * 2. The port registers with "itself".
+ * 3. The transmit and receive exchange ids are obtained.
+ * 4. The receive exchange id is posted.
+ * 5. A new els loopback event is created.
+ * 6. The command and response iocbs are allocated.
+ * 7. The cmd iocb FsType is set to elx loopback and the CmdRsp to looppback.
+ *
+ * This function is meant to be called n times while the port is in loopback
+ * so it is the apps responsibility to issue a reset to take the port out
+ * of loopback mode.
+ **/
+static int
+lpfc_bsg_diag_test(struct fc_bsg_job *job)
+{
+	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
+	struct lpfc_hba *phba = vport->phba;
+	struct diag_mode_test *diag_mode;
+	struct lpfc_bsg_event *evt;
+	struct event_data *evdat;
+	struct lpfc_sli *psli = &phba->sli;
+	uint32_t size;
+	uint32_t full_size;
+	size_t segment_len = 0, segment_offset = 0, current_offset = 0;
+	uint16_t rpi;
+	struct lpfc_iocbq *cmdiocbq, *rspiocbq;
+	IOCB_t *cmd, *rsp;
+	struct lpfc_sli_ct_request *ctreq;
+	struct lpfc_dmabuf *txbmp;
+	struct ulp_bde64 *txbpl = NULL;
+	struct lpfc_dmabufext *txbuffer = NULL;
+	struct list_head head;
+	struct lpfc_dmabuf  *curr;
+	uint16_t txxri, rxxri;
+	uint32_t num_bde;
+	uint8_t *ptr = NULL, *rx_databuf = NULL;
+	int rc = 0;
+	unsigned long flags;
+	void *dataout = NULL;
+	uint32_t total_mem;
+
+	/* in case no data is returned return just the return code */
+	job->reply->reply_payload_rcv_len = 0;
+
+	if (job->request_len <
+	    sizeof(struct fc_bsg_request) + sizeof(struct diag_mode_test)) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2739 Received DIAG TEST request below minimum "
+				"size\n");
+		rc = -EINVAL;
+		goto loopback_test_exit;
+	}
+
+	if (job->request_payload.payload_len !=
+		job->reply_payload.payload_len) {
+		rc = -EINVAL;
+		goto loopback_test_exit;
+	}
+
+	diag_mode = (struct diag_mode_test *)
+		job->request->rqst_data.h_vendor.vendor_cmd;
+
+	if ((phba->link_state == LPFC_HBA_ERROR) ||
+	    (psli->sli_flag & LPFC_BLOCK_MGMT_IO) ||
+	    (!(psli->sli_flag & LPFC_SLI_ACTIVE))) {
+		rc = -EACCES;
+		goto loopback_test_exit;
+	}
+
+	if (!lpfc_is_link_up(phba) || !(phba->link_flag & LS_LOOPBACK_MODE)) {
+		rc = -EACCES;
+		goto loopback_test_exit;
+	}
+
+	size = job->request_payload.payload_len;
+	full_size = size + ELX_LOOPBACK_HEADER_SZ; /* plus the header */
+
+	if ((size == 0) || (size > 80 * BUF_SZ_4K)) {
+		rc = -ERANGE;
+		goto loopback_test_exit;
+	}
+
+	if (size >= BUF_SZ_4K) {
+		/*
+		 * Allocate memory for ioctl data. If buffer is bigger than 64k,
+		 * then we allocate 64k and re-use that buffer over and over to
+		 * xfer the whole block. This is because Linux kernel has a
+		 * problem allocating more than 120k of kernel space memory. Saw
+		 * problem with GET_FCPTARGETMAPPING...
+		 */
+		if (size <= (64 * 1024))
+			total_mem = size;
+		else
+			total_mem = 64 * 1024;
+	} else
+		/* Allocate memory for ioctl data */
+		total_mem = BUF_SZ_4K;
+
+	dataout = kmalloc(total_mem, GFP_KERNEL);
+	if (dataout == NULL) {
+		rc = -ENOMEM;
+		goto loopback_test_exit;
+	}
+
+	ptr = dataout;
+	ptr += ELX_LOOPBACK_HEADER_SZ;
+	sg_copy_to_buffer(job->request_payload.sg_list,
+				job->request_payload.sg_cnt,
+				ptr, size);
+
+	rc = lpfcdiag_loop_self_reg(phba, &rpi);
+	if (rc) {
+		rc = -ENOMEM;
+		goto loopback_test_exit;
+	}
+
+	rc = lpfcdiag_loop_get_xri(phba, rpi, &txxri, &rxxri);
+	if (rc) {
+		lpfcdiag_loop_self_unreg(phba, rpi);
+		rc = -ENOMEM;
+		goto loopback_test_exit;
+	}
+
+	rc = lpfcdiag_loop_post_rxbufs(phba, rxxri, full_size);
+	if (rc) {
+		lpfcdiag_loop_self_unreg(phba, rpi);
+		rc = -ENOMEM;
+		goto loopback_test_exit;
+	}
+
+	evt = lpfc_bsg_event_new(FC_REG_CT_EVENT, current->pid,
+				SLI_CT_ELX_LOOPBACK);
+	if (!evt) {
+		lpfcdiag_loop_self_unreg(phba, rpi);
+		rc = -ENOMEM;
+		goto loopback_test_exit;
+	}
+
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
+	list_add(&evt->node, &phba->ct_ev_waiters);
+	lpfc_bsg_event_ref(evt);
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+
+	cmdiocbq = lpfc_sli_get_iocbq(phba);
+	rspiocbq = lpfc_sli_get_iocbq(phba);
+	txbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);
+
+	if (txbmp) {
+		txbmp->virt = lpfc_mbuf_alloc(phba, 0, &txbmp->phys);
+		INIT_LIST_HEAD(&txbmp->list);
+		txbpl = (struct ulp_bde64 *) txbmp->virt;
+		if (txbpl)
+			txbuffer = diag_cmd_data_alloc(phba,
+							txbpl, full_size, 0);
+	}
+
+	if (!cmdiocbq || !rspiocbq || !txbmp || !txbpl || !txbuffer) {
+		rc = -ENOMEM;
+		goto err_loopback_test_exit;
+	}
+
+	cmd = &cmdiocbq->iocb;
+	rsp = &rspiocbq->iocb;
+
+	INIT_LIST_HEAD(&head);
+	list_add_tail(&head, &txbuffer->dma.list);
+	list_for_each_entry(curr, &head, list) {
+		segment_len = ((struct lpfc_dmabufext *)curr)->size;
+		if (current_offset == 0) {
+			ctreq = curr->virt;
+			memset(ctreq, 0, ELX_LOOPBACK_HEADER_SZ);
+			ctreq->RevisionId.bits.Revision = SLI_CT_REVISION;
+			ctreq->RevisionId.bits.InId = 0;
+			ctreq->FsType = SLI_CT_ELX_LOOPBACK;
+			ctreq->FsSubType = 0;
+			ctreq->CommandResponse.bits.CmdRsp = ELX_LOOPBACK_DATA;
+			ctreq->CommandResponse.bits.Size   = size;
+			segment_offset = ELX_LOOPBACK_HEADER_SZ;
+		} else
+			segment_offset = 0;
+
+		BUG_ON(segment_offset >= segment_len);
+		memcpy(curr->virt + segment_offset,
+			ptr + current_offset,
+			segment_len - segment_offset);
+
+		current_offset += segment_len - segment_offset;
+		BUG_ON(current_offset > size);
+	}
+	list_del(&head);
+
+	/* Build the XMIT_SEQUENCE iocb */
+
+	num_bde = (uint32_t)txbuffer->flag;
+
+	cmd->un.xseq64.bdl.addrHigh = putPaddrHigh(txbmp->phys);
+	cmd->un.xseq64.bdl.addrLow = putPaddrLow(txbmp->phys);
+	cmd->un.xseq64.bdl.bdeFlags = BUFF_TYPE_BLP_64;
+	cmd->un.xseq64.bdl.bdeSize = (num_bde * sizeof(struct ulp_bde64));
+
+	cmd->un.xseq64.w5.hcsw.Fctl = (LS | LA);
+	cmd->un.xseq64.w5.hcsw.Dfctl = 0;
+	cmd->un.xseq64.w5.hcsw.Rctl = FC_RCTL_DD_UNSOL_CTL;
+	cmd->un.xseq64.w5.hcsw.Type = FC_TYPE_CT;
+
+	cmd->ulpCommand = CMD_XMIT_SEQUENCE64_CX;
+	cmd->ulpBdeCount = 1;
+	cmd->ulpLe = 1;
+	cmd->ulpClass = CLASS3;
+	cmd->ulpContext = txxri;
+
+	cmdiocbq->iocb_flag |= LPFC_IO_LIBDFC;
+	cmdiocbq->vport = phba->pport;
+
+	rc = lpfc_sli_issue_iocb_wait(phba, LPFC_ELS_RING, cmdiocbq, rspiocbq,
+				      (phba->fc_ratov * 2) + LPFC_DRVR_TIMEOUT);
+
+	if ((rc != IOCB_SUCCESS) || (rsp->ulpStatus != IOCB_SUCCESS)) {
+		rc = -EIO;
+		goto err_loopback_test_exit;
+	}
+
+	evt->waiting = 1;
+	rc = wait_event_interruptible_timeout(
+		evt->wq, !list_empty(&evt->events_to_see),
+		((phba->fc_ratov * 2) + LPFC_DRVR_TIMEOUT) * HZ);
+	evt->waiting = 0;
+	if (list_empty(&evt->events_to_see))
+		rc = (rc) ? -EINTR : -ETIMEDOUT;
+	else {
+		spin_lock_irqsave(&phba->ct_ev_lock, flags);
+		list_move(evt->events_to_see.prev, &evt->events_to_get);
+		evdat = list_entry(evt->events_to_get.prev,
+				   typeof(*evdat), node);
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+		rx_databuf = evdat->data;
+		if (evdat->len != full_size) {
+			lpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,
+				"1603 Loopback test did not receive expected "
+				"data length. actual length 0x%x expected "
+				"length 0x%x\n",
+				evdat->len, full_size);
+			rc = -EIO;
+		} else if (rx_databuf == NULL)
+			rc = -EIO;
+		else {
+			rc = IOCB_SUCCESS;
+			/* skip over elx loopback header */
+			rx_databuf += ELX_LOOPBACK_HEADER_SZ;
+			job->reply->reply_payload_rcv_len =
+				sg_copy_from_buffer(job->reply_payload.sg_list,
+						    job->reply_payload.sg_cnt,
+						    rx_databuf, size);
+			job->reply->reply_payload_rcv_len = size;
+		}
+	}
+
+err_loopback_test_exit:
+	lpfcdiag_loop_self_unreg(phba, rpi);
+
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
+	lpfc_bsg_event_unref(evt); /* release ref */
+	lpfc_bsg_event_unref(evt); /* delete */
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+
+	if (cmdiocbq != NULL)
+		lpfc_sli_release_iocbq(phba, cmdiocbq);
+
+	if (rspiocbq != NULL)
+		lpfc_sli_release_iocbq(phba, rspiocbq);
+
+	if (txbmp != NULL) {
+		if (txbpl != NULL) {
+			if (txbuffer != NULL)
+				diag_cmd_data_free(phba, txbuffer);
+			lpfc_mbuf_free(phba, txbmp->virt, txbmp->phys);
+		}
+		kfree(txbmp);
+	}
+
+loopback_test_exit:
+	kfree(dataout);
+	/* make error code available to userspace */
+	job->reply->result = rc;
+	job->dd_data = NULL;
+	/* complete the job back to userspace if no error */
+	if (rc == 0)
+		job->job_done(job);
+	return rc;
+}
+
+/**
+ * lpfc_bsg_get_dfc_rev - process a GET_DFC_REV bsg vendor command
+ * @job: GET_DFC_REV fc_bsg_job
+ **/
+static int
+lpfc_bsg_get_dfc_rev(struct fc_bsg_job *job)
+{
+	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
+	struct lpfc_hba *phba = vport->phba;
+	struct get_mgmt_rev *event_req;
+	struct get_mgmt_rev_reply *event_reply;
+	int rc = 0;
+
+	if (job->request_len <
+	    sizeof(struct fc_bsg_request) + sizeof(struct get_mgmt_rev)) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2740 Received GET_DFC_REV request below "
+				"minimum size\n");
+		rc = -EINVAL;
+		goto job_error;
+	}
+
+	event_req = (struct get_mgmt_rev *)
+		job->request->rqst_data.h_vendor.vendor_cmd;
+
+	event_reply = (struct get_mgmt_rev_reply *)
+		job->reply->reply_data.vendor_reply.vendor_rsp;
+
+	if (job->reply_len <
+	    sizeof(struct fc_bsg_request) + sizeof(struct get_mgmt_rev_reply)) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2741 Received GET_DFC_REV reply below "
+				"minimum size\n");
+		rc = -EINVAL;
+		goto job_error;
+	}
+
+	event_reply->info.a_Major = MANAGEMENT_MAJOR_REV;
+	event_reply->info.a_Minor = MANAGEMENT_MINOR_REV;
+job_error:
+	job->reply->result = rc;
+	if (rc == 0)
+		job->job_done(job);
+	return rc;
+}
+
+/**
+ * lpfc_bsg_wake_mbox_wait - lpfc_bsg_issue_mbox mbox completion handler
+ * @phba: Pointer to HBA context object.
+ * @pmboxq: Pointer to mailbox command.
+ *
+ * This is completion handler function for mailbox commands issued from
+ * lpfc_bsg_issue_mbox function. This function is called by the
+ * mailbox event handler function with no lock held. This function
+ * will wake up thread waiting on the wait queue pointed by context1
+ * of the mailbox.
+ **/
+void
+lpfc_bsg_wake_mbox_wait(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)
+{
+	struct bsg_job_data *dd_data;
+	MAILBOX_t *pmb;
+	MAILBOX_t *mb;
+	struct fc_bsg_job *job;
+	uint32_t size;
+	unsigned long flags;
+
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
+	dd_data = pmboxq->context1;
+	if (!dd_data) {
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+		return;
+	}
+
+	pmb = &dd_data->context_un.mbox.pmboxq->u.mb;
+	mb = dd_data->context_un.mbox.mb;
+	job = dd_data->context_un.mbox.set_job;
+	memcpy(mb, pmb, sizeof(*pmb));
+	size = job->request_payload.payload_len;
+	job->reply->reply_payload_rcv_len =
+		sg_copy_from_buffer(job->reply_payload.sg_list,
+				job->reply_payload.sg_cnt,
+				mb, size);
+	job->reply->result = 0;
+	dd_data->context_un.mbox.set_job = NULL;
+	job->dd_data = NULL;
+	job->job_done(job);
+	spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+	mempool_free(dd_data->context_un.mbox.pmboxq, phba->mbox_mem_pool);
+	kfree(mb);
+	kfree(dd_data);
+	return;
+}
+
+/**
+ * lpfc_bsg_check_cmd_access - test for a supported mailbox command
+ * @phba: Pointer to HBA context object.
+ * @mb: Pointer to a mailbox object.
+ * @vport: Pointer to a vport object.
+ *
+ * Some commands require the port to be offline, some may not be called from
+ * the application.
+ **/
+static int lpfc_bsg_check_cmd_access(struct lpfc_hba *phba,
+	MAILBOX_t *mb, struct lpfc_vport *vport)
+{
+	/* return negative error values for bsg job */
+	switch (mb->mbxCommand) {
+	/* Offline only */
+	case MBX_INIT_LINK:
+	case MBX_DOWN_LINK:
+	case MBX_CONFIG_LINK:
+	case MBX_CONFIG_RING:
+	case MBX_RESET_RING:
+	case MBX_UNREG_LOGIN:
+	case MBX_CLEAR_LA:
+	case MBX_DUMP_CONTEXT:
+	case MBX_RUN_DIAGS:
+	case MBX_RESTART:
+	case MBX_SET_MASK:
+		if (!(vport->fc_flag & FC_OFFLINE_MODE)) {
+			lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2743 Command 0x%x is illegal in on-line "
+				"state\n",
+				mb->mbxCommand);
+			return -EPERM;
+		}
+	case MBX_WRITE_NV:
+	case MBX_WRITE_VPARMS:
+	case MBX_LOAD_SM:
+	case MBX_READ_NV:
+	case MBX_READ_CONFIG:
+	case MBX_READ_RCONFIG:
+	case MBX_READ_STATUS:
+	case MBX_READ_XRI:
+	case MBX_READ_REV:
+	case MBX_READ_LNK_STAT:
+	case MBX_DUMP_MEMORY:
+	case MBX_DOWN_LOAD:
+	case MBX_UPDATE_CFG:
+	case MBX_KILL_BOARD:
+	case MBX_LOAD_AREA:
+	case MBX_LOAD_EXP_ROM:
+	case MBX_BEACON:
+	case MBX_DEL_LD_ENTRY:
+	case MBX_SET_DEBUG:
+	case MBX_WRITE_WWN:
+	case MBX_SLI4_CONFIG:
+	case MBX_READ_EVENT_LOG_STATUS:
+	case MBX_WRITE_EVENT_LOG:
+	case MBX_PORT_CAPABILITIES:
+	case MBX_PORT_IOV_CONTROL:
+		break;
+	case MBX_SET_VARIABLE:
+	case MBX_RUN_BIU_DIAG64:
+	case MBX_READ_EVENT_LOG:
+	case MBX_READ_SPARM64:
+	case MBX_READ_LA:
+	case MBX_READ_LA64:
+	case MBX_REG_LOGIN:
+	case MBX_REG_LOGIN64:
+	case MBX_CONFIG_PORT:
+	case MBX_RUN_BIU_DIAG:
+	default:
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+			"2742 Unknown Command 0x%x\n",
+			mb->mbxCommand);
+		return -EPERM;
+	}
+
+	return 0; /* ok */
+}
+
+/**
+ * lpfc_bsg_issue_mbox - issues a mailbox command on behalf of an app
+ * @phba: Pointer to HBA context object.
+ * @mb: Pointer to a mailbox object.
+ * @vport: Pointer to a vport object.
+ *
+ * Allocate a tracking object, mailbox command memory, get a mailbox
+ * from the mailbox pool, copy the caller mailbox command.
+ *
+ * If offline and the sli is active we need to poll for the command (port is
+ * being reset) and com-plete the job, otherwise issue the mailbox command and
+ * let our completion handler finish the command.
+ **/
+static uint32_t
+lpfc_bsg_issue_mbox(struct lpfc_hba *phba, struct fc_bsg_job *job,
+	struct lpfc_vport *vport)
+{
+	LPFC_MBOXQ_t *pmboxq;
+	MAILBOX_t *pmb;
+	MAILBOX_t *mb;
+	struct bsg_job_data *dd_data;
+	uint32_t size;
+	int rc = 0;
+
+	/* allocate our bsg tracking structure */
+	dd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);
+	if (!dd_data) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2727 Failed allocation of dd_data\n");
+		return -ENOMEM;
+	}
+
+	mb = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!mb) {
+		kfree(dd_data);
+		return -ENOMEM;
+	}
+
+	pmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
+	if (!pmboxq) {
+		kfree(dd_data);
+		kfree(mb);
+		return -ENOMEM;
+	}
+
+	size = job->request_payload.payload_len;
+	job->reply->reply_payload_rcv_len =
+		sg_copy_to_buffer(job->request_payload.sg_list,
+				job->request_payload.sg_cnt,
+				mb, size);
+
+	rc = lpfc_bsg_check_cmd_access(phba, mb, vport);
+	if (rc != 0) {
+		kfree(dd_data);
+		kfree(mb);
+		mempool_free(pmboxq, phba->mbox_mem_pool);
+		return rc; /* must be negative */
+	}
+
+	memset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));
+	pmb = &pmboxq->u.mb;
+	memcpy(pmb, mb, sizeof(*pmb));
+	pmb->mbxOwner = OWN_HOST;
+	pmboxq->context1 = NULL;
+	pmboxq->vport = vport;
+
+	if ((vport->fc_flag & FC_OFFLINE_MODE) ||
+	    (!(phba->sli.sli_flag & LPFC_SLI_ACTIVE))) {
+		rc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);
+		if (rc != MBX_SUCCESS) {
+			if (rc != MBX_TIMEOUT) {
+				kfree(dd_data);
+				kfree(mb);
+				mempool_free(pmboxq, phba->mbox_mem_pool);
+			}
+			return  (rc == MBX_TIMEOUT) ? -ETIME : -ENODEV;
+		}
+
+		memcpy(mb, pmb, sizeof(*pmb));
+		job->reply->reply_payload_rcv_len =
+			sg_copy_from_buffer(job->reply_payload.sg_list,
+					job->reply_payload.sg_cnt,
+					mb, size);
+		kfree(dd_data);
+		kfree(mb);
+		mempool_free(pmboxq, phba->mbox_mem_pool);
+		/* not waiting mbox already done */
+		return 0;
+	}
+
+	/* setup wake call as IOCB callback */
+	pmboxq->mbox_cmpl = lpfc_bsg_wake_mbox_wait;
+	/* setup context field to pass wait_queue pointer to wake function */
+	pmboxq->context1 = dd_data;
+	dd_data->type = TYPE_MBOX;
+	dd_data->context_un.mbox.pmboxq = pmboxq;
+	dd_data->context_un.mbox.mb = mb;
+	dd_data->context_un.mbox.set_job = job;
+	job->dd_data = dd_data;
+	rc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_NOWAIT);
+	if ((rc != MBX_SUCCESS) && (rc != MBX_BUSY)) {
+		kfree(dd_data);
+		kfree(mb);
+		mempool_free(pmboxq, phba->mbox_mem_pool);
+		return -EIO;
+	}
+
+	return 1;
+}
+
+/**
+ * lpfc_bsg_mbox_cmd - process an fc bsg LPFC_BSG_VENDOR_MBOX command
+ * @job: MBOX fc_bsg_job for LPFC_BSG_VENDOR_MBOX.
+ **/
+static int
+lpfc_bsg_mbox_cmd(struct fc_bsg_job *job)
+{
+	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
+	struct lpfc_hba *phba = vport->phba;
+	int rc = 0;
+
+	/* in case no data is transferred */
+	job->reply->reply_payload_rcv_len = 0;
+	if (job->request_len <
+	    sizeof(struct fc_bsg_request) + sizeof(struct dfc_mbox_req)) {
+		lpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,
+				"2737 Received MBOX_REQ request below "
+				"minimum size\n");
+		rc = -EINVAL;
+		goto job_error;
+	}
+
+	if (job->request_payload.payload_len != PAGE_SIZE) {
+		rc = -EINVAL;
+		goto job_error;
+	}
+
+	if (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO) {
+		rc = -EAGAIN;
+		goto job_error;
+	}
+
+	rc = lpfc_bsg_issue_mbox(phba, job, vport);
+
+job_error:
+	if (rc == 0) {
+		/* job done */
+		job->reply->result = 0;
+		job->dd_data = NULL;
+		job->job_done(job);
+	} else if (rc == 1)
+		/* job submitted, will complete later*/
+		rc = 0; /* return zero, no error */
+	else {
+		/* some error occurred */
+		job->reply->result = rc;
+		job->dd_data = NULL;
+	}
+
+	return rc;
+}
+
+/**
+ * lpfc_bsg_hst_vendor - process a vendor-specific fc_bsg_job
+ * @job: fc_bsg_job to handle
+ **/
+static int
+lpfc_bsg_hst_vendor(struct fc_bsg_job *job)
+{
+	int command = job->request->rqst_data.h_vendor.vendor_cmd[0];
+	int rc;
+
+	switch (command) {
+	case LPFC_BSG_VENDOR_SET_CT_EVENT:
+		rc = lpfc_bsg_hba_set_event(job);
+		break;
+	case LPFC_BSG_VENDOR_GET_CT_EVENT:
+		rc = lpfc_bsg_hba_get_event(job);
+		break;
+	case LPFC_BSG_VENDOR_SEND_MGMT_RESP:
+		rc = lpfc_bsg_send_mgmt_rsp(job);
+		break;
+	case LPFC_BSG_VENDOR_DIAG_MODE:
+		rc = lpfc_bsg_diag_mode(job);
+		break;
+	case LPFC_BSG_VENDOR_DIAG_TEST:
+		rc = lpfc_bsg_diag_test(job);
+		break;
+	case LPFC_BSG_VENDOR_GET_MGMT_REV:
+		rc = lpfc_bsg_get_dfc_rev(job);
+		break;
+	case LPFC_BSG_VENDOR_MBOX:
+		rc = lpfc_bsg_mbox_cmd(job);
+		break;
+	default:
+		rc = -EINVAL;
+		job->reply->reply_payload_rcv_len = 0;
+		/* make error code available to userspace */
+		job->reply->result = rc;
+		break;
+	}
+
+	return rc;
+}
+
+/**
+ * lpfc_bsg_request - handle a bsg request from the FC transport
+ * @job: fc_bsg_job to handle
+ **/
+int
+lpfc_bsg_request(struct fc_bsg_job *job)
+{
+	uint32_t msgcode;
+	int rc;
+
+	msgcode = job->request->msgcode;
+	switch (msgcode) {
+	case FC_BSG_HST_VENDOR:
+		rc = lpfc_bsg_hst_vendor(job);
+		break;
+	case FC_BSG_RPT_ELS:
+		rc = lpfc_bsg_rport_els(job);
+		break;
+	case FC_BSG_RPT_CT:
+		rc = lpfc_bsg_send_mgmt_cmd(job);
+		break;
+	default:
+		rc = -EINVAL;
+		job->reply->reply_payload_rcv_len = 0;
+		/* make error code available to userspace */
+		job->reply->result = rc;
+		break;
+	}
+
+	return rc;
+}
+
+/**
+ * lpfc_bsg_timeout - handle timeout of a bsg request from the FC transport
+ * @job: fc_bsg_job that has timed out
+ *
+ * This function just aborts the job's IOCB.  The aborted IOCB will return to
+ * the waiting function which will handle passing the error back to userspace
+ **/
+int
+lpfc_bsg_timeout(struct fc_bsg_job *job)
+{
+	struct lpfc_vport *vport = (struct lpfc_vport *)job->shost->hostdata;
+	struct lpfc_hba *phba = vport->phba;
+	struct lpfc_iocbq *cmdiocb;
+	struct lpfc_bsg_event *evt;
+	struct lpfc_bsg_iocb *iocb;
+	struct lpfc_bsg_mbox *mbox;
+	struct lpfc_sli_ring *pring = &phba->sli.ring[LPFC_ELS_RING];
+	struct bsg_job_data *dd_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&phba->ct_ev_lock, flags);
+	dd_data = (struct bsg_job_data *)job->dd_data;
+	/* timeout and completion crossed paths if no dd_data */
+	if (!dd_data) {
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+		return 0;
+	}
+
+	switch (dd_data->type) {
+	case TYPE_IOCB:
+		iocb = &dd_data->context_un.iocb;
+		cmdiocb = iocb->cmdiocbq;
+		/* hint to completion handler that the job timed out */
+		job->reply->result = -EAGAIN;
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+		/* this will call our completion handler */
+		spin_lock_irq(&phba->hbalock);
+		lpfc_sli_issue_abort_iotag(phba, pring, cmdiocb);
+		spin_unlock_irq(&phba->hbalock);
+		break;
+	case TYPE_EVT:
+		evt = dd_data->context_un.evt;
+		/* this event has no job anymore */
+		evt->set_job = NULL;
+		job->dd_data = NULL;
+		job->reply->reply_payload_rcv_len = 0;
+		/* Return -EAGAIN which is our way of signallying the
+		 * app to retry.
+		 */
+		job->reply->result = -EAGAIN;
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+		job->job_done(job);
+		break;
+	case TYPE_MBOX:
+		mbox = &dd_data->context_un.mbox;
+		/* this mbox has no job anymore */
+		mbox->set_job = NULL;
+		job->dd_data = NULL;
+		job->reply->reply_payload_rcv_len = 0;
+		job->reply->result = -EAGAIN;
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+		job->job_done(job);
+		break;
+	default:
+		spin_unlock_irqrestore(&phba->ct_ev_lock, flags);
+		break;
+	}
 
+	/* scsi transport fc fc_bsg_job_timeout expects a zero return code,
+	 * otherwise an error message will be displayed on the console
+	 * so always return success (zero)
+	 */
 	return 0;
 }
--- a/drivers/scsi/lpfc/lpfc_bsg.h
+++ b/drivers/scsi/lpfc/lpfc_bsg.h
@@ -0,0 +1,98 @@
+/*******************************************************************
+ * This file is part of the Emulex Linux Device Driver for         *
+ * Fibre Channel Host Bus Adapters.                                *
+ * Copyright (C) 2010 Emulex.  All rights reserved.                *
+ * EMULEX and SLI are trademarks of Emulex.                        *
+ * www.emulex.com                                                  *
+ *                                                                 *
+ * This program is free software; you can redistribute it and/or   *
+ * modify it under the terms of version 2 of the GNU General       *
+ * Public License as published by the Free Software Foundation.    *
+ * This program is distributed in the hope that it will be useful. *
+ * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
+ * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
+ * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
+ * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
+ * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
+ * more details, a copy of which can be found in the file COPYING  *
+ * included with this package.                                     *
+ *******************************************************************/
+/* bsg definitions
+ * No pointers to user data are allowed, all application buffers and sizes will
+ * derived through the bsg interface.
+ *
+ * These are the vendor unique structures passed in using the bsg
+ * FC_BSG_HST_VENDOR message code type.
+ */
+#define LPFC_BSG_VENDOR_SET_CT_EVENT	1
+#define LPFC_BSG_VENDOR_GET_CT_EVENT	2
+#define LPFC_BSG_VENDOR_SEND_MGMT_RESP	3
+#define LPFC_BSG_VENDOR_DIAG_MODE	4
+#define LPFC_BSG_VENDOR_DIAG_TEST	5
+#define LPFC_BSG_VENDOR_GET_MGMT_REV	6
+#define LPFC_BSG_VENDOR_MBOX		7
+
+struct set_ct_event {
+	uint32_t command;
+	uint32_t type_mask;
+	uint32_t ev_req_id;
+	uint32_t ev_reg_id;
+};
+
+struct get_ct_event {
+	uint32_t command;
+	uint32_t ev_reg_id;
+	uint32_t ev_req_id;
+};
+
+struct get_ct_event_reply {
+	uint32_t immed_data;
+	uint32_t type;
+};
+
+struct send_mgmt_resp {
+	uint32_t command;
+	uint32_t tag;
+};
+
+
+#define INTERNAL_LOOP_BACK 0x1 /* adapter short cuts the loop internally */
+#define EXTERNAL_LOOP_BACK 0x2 /* requires an external loopback plug */
+
+struct diag_mode_set {
+	uint32_t command;
+	uint32_t type;
+	uint32_t timeout;
+};
+
+struct diag_mode_test {
+	uint32_t command;
+};
+
+#define LPFC_WWNN_TYPE		0
+#define LPFC_WWPN_TYPE		1
+
+struct get_mgmt_rev {
+	uint32_t command;
+};
+
+#define MANAGEMENT_MAJOR_REV   1
+#define MANAGEMENT_MINOR_REV   0
+
+/* the MgmtRevInfo structure */
+struct MgmtRevInfo {
+	uint32_t a_Major;
+	uint32_t a_Minor;
+};
+
+struct get_mgmt_rev_reply {
+	struct MgmtRevInfo info;
+};
+
+struct dfc_mbox_req {
+	uint32_t command;
+	uint32_t inExtWLen;
+	uint32_t outExtWLen;
+	uint8_t mbOffset;
+};
+
--- a/drivers/scsi/lpfc/lpfc_crtn.h
+++ b/drivers/scsi/lpfc/lpfc_crtn.h
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2008 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -21,12 +21,6 @@
 typedef int (*node_filter)(struct lpfc_nodelist *, void *);
 
 struct fc_rport;
-int lpfc_issue_els_auth(struct lpfc_vport *, struct lpfc_nodelist *,
-			uint8_t message_code, uint8_t *payload,
-			uint32_t payload_len);
-int lpfc_issue_els_auth_reject(struct lpfc_vport *vport,
-			       struct lpfc_nodelist *ndlp,
-			       uint8_t reason, uint8_t explanation);
 void lpfc_down_link(struct lpfc_hba *, LPFC_MBOXQ_t *);
 void lpfc_sli_read_link_ste(struct lpfc_hba *);
 void lpfc_dump_mem(struct lpfc_hba *, LPFC_MBOXQ_t *, uint16_t, uint16_t);
@@ -101,9 +95,7 @@ void lpfc_cleanup(struct lpfc_vport *);
 void lpfc_disc_timeout(unsigned long);
 
 struct lpfc_nodelist *__lpfc_findnode_rpi(struct lpfc_vport *, uint16_t);
-struct lpfc_nodelist *lpfc_findnode_wwnn(struct lpfc_vport *,
-					 struct lpfc_name *);
-void lpfc_port_auth_failed(struct lpfc_nodelist *, enum auth_state);
+
 void lpfc_worker_wake_up(struct lpfc_hba *);
 int lpfc_workq_post_event(struct lpfc_hba *, void *, void *, uint32_t);
 int lpfc_do_work(void *);
@@ -112,7 +104,7 @@ int lpfc_disc_state_machine(struct lpfc_
 
 void lpfc_do_scr_ns_plogi(struct lpfc_hba *, struct lpfc_vport *);
 int lpfc_check_sparm(struct lpfc_vport *, struct lpfc_nodelist *,
-		     struct serv_parm *, uint32_t);
+		     struct serv_parm *, uint32_t, int);
 int lpfc_els_abort(struct lpfc_hba *, struct lpfc_nodelist *);
 void lpfc_more_plogi(struct lpfc_vport *);
 void lpfc_more_adisc(struct lpfc_vport *);
@@ -141,8 +133,6 @@ int lpfc_els_rsp_prli_acc(struct lpfc_vp
 void lpfc_cancel_retry_delay_tmo(struct lpfc_vport *, struct lpfc_nodelist *);
 void lpfc_els_retry_delay(unsigned long);
 void lpfc_els_retry_delay_handler(struct lpfc_nodelist *);
-void lpfc_reauth_node(unsigned long);
-void lpfc_reauthentication_handler(struct lpfc_nodelist *);
 void lpfc_els_unsol_event(struct lpfc_hba *, struct lpfc_sli_ring *,
 			  struct lpfc_iocbq *);
 int lpfc_els_handle_rscn(struct lpfc_vport *);
@@ -342,29 +332,6 @@ void destroy_port(struct lpfc_vport *);
 int lpfc_get_instance(void);
 void lpfc_host_attrib_init(struct Scsi_Host *);
 
-extern struct workqueue_struct *security_work_q;
-extern struct list_head fc_security_user_list;
-extern int fc_service_state;
-void lpfc_fc_sc_security_online(struct work_struct *work);
-void lpfc_fc_sc_security_offline(struct work_struct *work);
-int lpfc_fc_queue_security_work(struct lpfc_vport *, struct work_struct *);
-void lpfc_rcv_nl_event(struct notifier_block *, unsigned long , void *);
-int lpfc_selective_reset(struct lpfc_hba *);
-int lpfc_security_wait(struct lpfc_vport *);
-int  lpfc_get_security_enabled(struct Scsi_Host *);
-void lpfc_security_service_online(struct Scsi_Host *);
-void lpfc_security_service_offline(struct Scsi_Host *);
-void lpfc_security_config(struct Scsi_Host *, int status, void *);
-int lpfc_security_config_wait(struct lpfc_vport *vport);
-void lpfc_dhchap_make_challenge(struct Scsi_Host *, int , void *, uint32_t);
-void lpfc_dhchap_make_response(struct Scsi_Host *, int , void *, uint32_t);
-void lpfc_dhchap_authenticate(struct Scsi_Host *, int , void *, uint32_t);
-int lpfc_start_node_authentication(struct lpfc_nodelist *);
-int lpfc_get_auth_config(struct lpfc_vport *, struct lpfc_nodelist *);
-void lpfc_start_discovery(struct lpfc_vport *vport);
-void lpfc_start_authentication(struct lpfc_vport *, struct lpfc_nodelist *);
-int lpfc_rcv_nl_msg(struct Scsi_Host *, void *, uint32_t, uint32_t);
-
 extern void lpfc_debugfs_initialize(struct lpfc_vport *);
 extern void lpfc_debugfs_terminate(struct lpfc_vport *);
 extern void lpfc_debugfs_disc_trc(struct lpfc_vport *, int, char *, uint32_t,
@@ -373,10 +340,6 @@ extern void lpfc_debugfs_slow_ring_trc(s
 	uint32_t, uint32_t);
 extern struct lpfc_hbq_init *lpfc_hbq_defs[];
 
-extern spinlock_t fc_security_user_lock;
-extern struct list_head fc_security_user_list;
-extern int fc_service_state;
-
 /* externs BlockGuard */
 extern char *_dump_buf_data;
 extern unsigned long _dump_buf_data_order;
@@ -420,5 +383,5 @@ struct lpfc_vport *lpfc_find_vport_by_vp
 /* functions to support SGIOv4/bsg interface */
 int lpfc_bsg_request(struct fc_bsg_job *);
 int lpfc_bsg_timeout(struct fc_bsg_job *);
-void lpfc_bsg_ct_unsol_event(struct lpfc_hba *, struct lpfc_sli_ring *,
+int lpfc_bsg_ct_unsol_event(struct lpfc_hba *, struct lpfc_sli_ring *,
 			     struct lpfc_iocbq *);
--- a/drivers/scsi/lpfc/lpfc_ct.c
+++ b/drivers/scsi/lpfc/lpfc_ct.c
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2009 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -97,7 +97,8 @@ lpfc_ct_unsol_event(struct lpfc_hba *phb
 	struct list_head head;
 	struct lpfc_dmabuf *bdeBuf;
 
-	lpfc_bsg_ct_unsol_event(phba, pring, piocbq);
+	if (lpfc_bsg_ct_unsol_event(phba, pring, piocbq) == 0)
+		return;
 
 	if (unlikely(icmd->ulpStatus == IOSTAT_NEED_BUFFER)) {
 		lpfc_sli_hbqbuf_add_hbqs(phba, LPFC_ELS_HBQ);
@@ -181,7 +182,8 @@ lpfc_sli4_ct_abort_unsol_event(struct lp
 	uint32_t size;
 
 	/* Forward abort event to any process registered to receive ct event */
-	lpfc_bsg_ct_unsol_event(phba, pring, piocbq);
+	if (lpfc_bsg_ct_unsol_event(phba, pring, piocbq) == 0)
+		return;
 
 	/* If there is no BDE associated with IOCB, there is nothing to do */
 	if (icmd->ulpBdeCount == 0)
--- a/drivers/scsi/lpfc/lpfc_disc.h
+++ b/drivers/scsi/lpfc/lpfc_disc.h
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2008 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -37,7 +37,6 @@ enum lpfc_work_type {
 	LPFC_EVT_KILL,
 	LPFC_EVT_ELS_RETRY,
 	LPFC_EVT_DEV_LOSS,
-	LPFC_EVT_REAUTH,
 	LPFC_EVT_FASTPATH_MGMT_EVT,
 };
 
@@ -100,13 +99,11 @@ struct lpfc_nodelist {
 #define NLP_USG_FREE_ACK_BIT	0x8	/* Indicate ndlp memory free invoked */
 
 	struct timer_list   nlp_delayfunc;	/* Used for delayed ELS cmds */
-	struct timer_list   nlp_reauth_tmr;	/* Used for re-authentication */
 	struct lpfc_hba *phba;
 	struct fc_rport *rport;			/* Corresponding FC transport
 						   port structure */
 	struct lpfc_vport *vport;
 	struct lpfc_work_evt els_retry_evt;
-	struct lpfc_work_evt els_reauth_evt;
 	struct lpfc_work_evt dev_loss_evt;
 	struct kref     kref;
 	atomic_t cmd_pending;
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2009 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -40,9 +40,6 @@
 #include "lpfc_crtn.h"
 #include "lpfc_vport.h"
 #include "lpfc_debugfs.h"
-#include "lpfc_auth_access.h"
-#include "lpfc_auth.h"
-#include "lpfc_security.h"
 
 static int lpfc_els_retry(struct lpfc_hba *, struct lpfc_iocbq *,
 			  struct lpfc_iocbq *);
@@ -606,11 +603,8 @@ lpfc_cmpl_els_flogi_fabric(struct lpfc_v
 		lpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);
 		if ((!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) &&
 			(vport->vpi_state & LPFC_VPI_REGISTERED)) {
-			if (vport->cfg_enable_auth) {
-				if (lpfc_get_auth_config(vport, NULL))
-					return 1;
-			} else
-				lpfc_start_discovery(vport);
+			lpfc_start_fdiscs(phba);
+			lpfc_do_scr_ns_plogi(phba, vport);
 		} else if (vport->fc_flag & FC_VFI_REGISTERED)
 			lpfc_register_new_vport(phba, vport, ndlp);
 		else
@@ -821,10 +815,7 @@ lpfc_cmpl_els_flogi(struct lpfc_hba *phb
 	prsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);
 
 	sp = prsp->virt + sizeof(uint32_t);
-	if (sp->cmn.security)
-		ndlp->nlp_flag |= NLP_SC_REQ;
-	else
-		ndlp->nlp_flag &= ~NLP_SC_REQ;
+
 	/* FLOGI completes successfully */
 	lpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,
 			 "0101 FLOGI completes sucessfully "
@@ -832,16 +823,6 @@ lpfc_cmpl_els_flogi(struct lpfc_hba *phb
 			 irsp->un.ulpWord[4], sp->cmn.e_d_tov,
 			 sp->cmn.w2.r_a_tov, sp->cmn.edtovResolution);
 
-	if (!vport->cfg_enable_auth) {
-		vport->auth.security_active = 0;
-		if (sp->cmn.security) {
-			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-					 "1055 Authentication parameter is "
-					 "disabled, but is required by "
-					 "the fabric.\n");
-			goto flogifail;
-		}
-	}
 	if (vport->port_state == LPFC_FLOGI) {
 		/*
 		 * If Common Service Parameters indicate Nport
@@ -931,10 +912,6 @@ lpfc_issue_els_flogi(struct lpfc_vport *
 	sp = (struct serv_parm *) pcmd;
 
 	/* Setup CSPs accordingly for Fabric */
-
-	if (vport->cfg_enable_auth)
-		sp->cmn.security = 1;
-
 	sp->cmn.e_d_tov = 0;
 	sp->cmn.w2.r_a_tov = 0;
 	sp->cls1.classValid = 0;
@@ -1054,15 +1031,6 @@ lpfc_initial_flogi(struct lpfc_vport *vp
 	struct lpfc_hba *phba = vport->phba;
 	struct lpfc_nodelist *ndlp;
 
-	if (vport->cfg_enable_auth && lpfc_security_wait(vport)) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "2725 Authentication is enabled but "
-				 "authentication service is not "
-				 "running\n");
-		vport->auth.auth_mode = FC_AUTHMODE_UNKNOWN;
-		return 0;
-	}
-
 	vport->port_state = LPFC_FLOGI;
 	lpfc_set_disctmo(vport);
 
@@ -1116,14 +1084,6 @@ lpfc_initial_fdisc(struct lpfc_vport *vp
 	struct lpfc_hba *phba = vport->phba;
 	struct lpfc_nodelist *ndlp;
 
-	if (vport->cfg_enable_auth && lpfc_security_wait(vport)) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1049 Authentication is enabled but "
-				 "authentication service is not "
-				 "running\n");
-		vport->auth.auth_mode = FC_AUTHMODE_UNKNOWN;
-		return 0;
-	}
 	/* First look for the Fabric ndlp */
 	ndlp = lpfc_findnode_did(vport, Fabric_DID);
 	if (!ndlp) {
@@ -2857,17 +2817,6 @@ lpfc_els_retry(struct lpfc_hba *phba, st
 			lpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);
 			lpfc_issue_els_logo(vport, ndlp, cmdiocb->retry);
 			return 1;
-		case ELS_CMD_AUTH_NEG:
-		case ELS_CMD_DH_CHA:
-		case ELS_CMD_DH_REP:
-		case ELS_CMD_DH_SUC:
-			ndlp->nlp_prev_state = ndlp->nlp_state;
-			ndlp->nlp_state = NLP_STE_NPR_NODE;
-			lpfc_printf_log(phba, KERN_INFO, LOG_ELS,
-					"0153 Authentication LS_RJT Logical "
-					"busy\n");
-			lpfc_start_authentication(vport, ndlp);
-			return 1;
 		}
 	}
 	/* No retry ELS command <elsCmd> to remote NPORT <did> */
@@ -4439,7 +4388,7 @@ lpfc_els_rcv_flogi(struct lpfc_vport *vp
 
 	did = Fabric_DID;
 
-	if ((lpfc_check_sparm(vport, ndlp, sp, CLASS3))) {
+	if ((lpfc_check_sparm(vport, ndlp, sp, CLASS3, 1))) {
 		/* For a FLOGI we accept, then if our portname is greater
 		 * then the remote portname we initiate Nport login.
 		 */
@@ -5298,362 +5247,6 @@ lpfc_els_flush_all_cmd(struct lpfc_hba  
 	return;
 }
 
-static void
-lpfc_els_rcv_auth_neg(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
-		  struct lpfc_nodelist *ndlp)
-{
-	struct Scsi_Host  *shost = lpfc_shost_from_vport(vport);
-	struct lpfc_dmabuf *pcmd = cmdiocb->context2;
-	struct lpfc_auth_message *authcmd;
-	uint8_t reason, explanation;
-	uint32_t message_len;
-	uint32_t trans_id;
-	struct fc_auth_req *fc_req;
-	struct fc_auth_rsp *fc_rsp;
-
-	authcmd = pcmd->virt;
-	message_len = be32_to_cpu(authcmd->message_len);
-	trans_id = be32_to_cpu(authcmd->trans_id);
-
-	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
-
-	vport->auth.trans_id = trans_id;
-
-	if (lpfc_unpack_auth_negotiate(vport, authcmd->data,
-				       &reason, &explanation)) {
-		lpfc_issue_els_auth_reject(vport, ndlp, reason, explanation);
-		return;
-	}
-	vport->auth.direction = AUTH_DIRECTION_NONE;
-	lpfc_printf_vlog(vport, KERN_WARNING, LOG_SECURITY,
-			 "1033 Received auth_negotiate from Nport:x%x\n",
-			 ndlp->nlp_DID);
-
-	fc_req = kzalloc(sizeof(struct fc_auth_req), GFP_KERNEL);
-
-	fc_req->local_wwpn = wwn_to_u64(vport->fc_portname.u.wwn);
-	if (ndlp->nlp_type & NLP_FABRIC)
-		fc_req->remote_wwpn = AUTH_FABRIC_WWN;
-	else
-		fc_req->remote_wwpn = wwn_to_u64(ndlp->nlp_portname.u.wwn);
-	fc_req->u.dhchap_challenge.transaction_id = vport->auth.trans_id;
-	fc_req->u.dhchap_challenge.dh_group_id = vport->auth.group_id;
-	fc_req->u.dhchap_challenge.hash_id = vport->auth.hash_id;
-
-	fc_rsp = kzalloc(MAX_AUTH_RSP_SIZE, GFP_KERNEL);
-
-	if (lpfc_fc_security_dhchap_make_challenge(shost,
-			      fc_req, sizeof(struct fc_auth_req),
-	fc_rsp, MAX_AUTH_RSP_SIZE)) {
-		kfree(fc_rsp);
-		lpfc_issue_els_auth_reject(vport, ndlp, LOGIC_ERR, 0);
-	}
-
-	kfree(fc_req);
-
-}
-
-static void
-lpfc_els_rcv_chap_chal(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
-		       struct lpfc_nodelist *ndlp)
-{
-
-	struct Scsi_Host  *shost = lpfc_shost_from_vport(vport);
-	struct lpfc_dmabuf *pcmd = cmdiocb->context2;
-	struct lpfc_auth_message *authcmd;
-	uint8_t reason, explanation;
-	uint32_t message_len;
-	uint32_t trans_id;
-	struct fc_auth_req *fc_req;
-	struct fc_auth_rsp *fc_rsp;
-	uint32_t fc_req_len;
-
-	authcmd = pcmd->virt;
-	message_len = be32_to_cpu(authcmd->message_len);
-	trans_id = be32_to_cpu(authcmd->trans_id);
-
-	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
-
-	if (vport->auth.auth_msg_state != LPFC_AUTH_NEGOTIATE) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1034 Not Expecting Challenge - Rejecting "
-				 "Challenge.\n");
-		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PROTOCOL);
-		return;
-	}
-
-	if (trans_id  != vport->auth.trans_id) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1035 Transport ID does not match - Rejecting "
-				 "Challenge.\n");
-		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PAYLOAD);
-		return;
-	}
-
-	if (lpfc_unpack_dhchap_challenge(vport, authcmd->data,
-					 &reason, &explanation)) {
-		lpfc_issue_els_auth_reject(vport, ndlp, reason, explanation);
-		return;
-	}
-	vport->auth.direction = AUTH_DIRECTION_NONE;
-
-	fc_req_len = (sizeof(struct fc_auth_req) +
-		      vport->auth.challenge_len +
-		      vport->auth.dh_pub_key_len);
-	fc_req = kzalloc(fc_req_len, GFP_KERNEL);
-	fc_req->local_wwpn = wwn_to_u64(vport->fc_portname.u.wwn);
-	if (ndlp->nlp_type & NLP_FABRIC)
-		fc_req->remote_wwpn = AUTH_FABRIC_WWN;
-	else
-		fc_req->remote_wwpn = wwn_to_u64(ndlp->nlp_portname.u.wwn);
-	fc_req->u.dhchap_reply.transaction_id = vport->auth.trans_id;
-	fc_req->u.dhchap_reply.dh_group_id = vport->auth.group_id;
-	fc_req->u.dhchap_reply.hash_id = vport->auth.hash_id;
-	fc_req->u.dhchap_reply.bidirectional = vport->auth.bidirectional;
-	fc_req->u.dhchap_reply.received_challenge_len =
-		vport->auth.challenge_len;
-	fc_req->u.dhchap_reply.received_public_key_len =
-			vport->auth.dh_pub_key_len;
-	memcpy(fc_req->u.dhchap_reply.data, vport->auth.challenge,
-	       vport->auth.challenge_len);
-	if (vport->auth.group_id != DH_GROUP_NULL) {
-		memcpy(fc_req->u.dhchap_reply.data + vport->auth.challenge_len,
-			vport->auth.dh_pub_key, vport->auth.dh_pub_key_len);
-	}
-
-	fc_rsp = kzalloc(MAX_AUTH_RSP_SIZE, GFP_KERNEL);
-
-	if (lpfc_fc_security_dhchap_make_response(shost,
-			fc_req, fc_req_len,
-			fc_rsp, MAX_AUTH_RSP_SIZE)) {
-		kfree(fc_rsp);
-		lpfc_issue_els_auth_reject(vport, ndlp, LOGIC_ERR, 0);
-	}
-
-	kfree(fc_req);
-
-}
-
-static void
-lpfc_els_rcv_auth_rjt(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
-		      struct lpfc_nodelist *ndlp)
-{
-
-	struct lpfc_dmabuf *pcmd = cmdiocb->context2;
-	struct lpfc_auth_message *authcmd;
-	uint32_t message_len;
-	uint32_t trans_id;
-	struct lpfc_auth_reject *rjt;
-	struct lpfc_hba *phba = vport->phba;
-
-	authcmd = pcmd->virt;
-	rjt = (struct lpfc_auth_reject *)authcmd->data;
-
-	message_len = be32_to_cpu(authcmd->message_len);
-	trans_id = be32_to_cpu(authcmd->trans_id);
-
-	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
-
-	if (vport->auth.auth_state == LPFC_AUTH_SUCCESS) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1036 Authentication transaction reject - "
-				 "re-auth request reason 0x%x exp 0x%x\n",
-				 rjt->reason, rjt->explanation);
-		lpfc_port_auth_failed(ndlp, LPFC_AUTH_FAIL_AUTH_RJT);
-		if (vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS) {
-			/* start authentication */
-			lpfc_start_authentication(vport, ndlp);
-		}
-	} else {
-		if (rjt->reason == LOGIC_ERR && rjt->explanation == RESTART) {
-			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-					 "1037 Authentication transaction "
-					 "reject - restarting authentication. "
-					 "reason 0x%x exp 0x%x\n",
-					 rjt->reason, rjt->explanation);
-			/* restart auth */
-			lpfc_start_authentication(vport, ndlp);
-		} else {
-			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				"1057 Authentication transaction "
-				"reject. reason 0x%x exp 0x%x\n",
-				rjt->reason, rjt->explanation);
-			lpfc_port_auth_failed(ndlp, LPFC_AUTH_FAIL_AUTH_RJT);
-			vport->auth.auth_msg_state = LPFC_AUTH_REJECT;
-			if (!(phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&
-			    (phba->link_state != LPFC_CLEAR_LA)) {
-				/* If Auth failed enable link interrupt. */
-				lpfc_issue_clear_la(phba, vport);
-			}
-		}
-	}
-}
-
-static void
-lpfc_els_rcv_chap_reply(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
-		  struct lpfc_nodelist *ndlp)
-{
-
-	struct Scsi_Host  *shost = lpfc_shost_from_vport(vport);
-	struct lpfc_dmabuf *pcmd = cmdiocb->context2;
-	struct lpfc_auth_message *authcmd;
-	uint32_t message_len;
-	uint32_t trans_id;
-	struct fc_auth_req *fc_req;
-	struct fc_auth_rsp *fc_rsp;
-	uint32_t data_len;
-
-	authcmd = pcmd->virt;
-	message_len = be32_to_cpu(authcmd->message_len);
-	trans_id = be32_to_cpu(authcmd->trans_id);
-
-	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
-
-	fc_req = kzalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
-
-	fc_req->local_wwpn = wwn_to_u64(vport->fc_portname.u.wwn);
-	if (ndlp->nlp_type & NLP_FABRIC)
-		fc_req->remote_wwpn = AUTH_FABRIC_WWN;
-	else
-		fc_req->remote_wwpn = wwn_to_u64(ndlp->nlp_portname.u.wwn);
-
-	if (vport->auth.auth_msg_state != LPFC_DHCHAP_CHALLENGE) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1039 Not Expecting Reply - rejecting. State "
-				 "0x%x\n", vport->auth.auth_state);
-
-		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PROTOCOL);
-		return;
-	}
-
-	if (trans_id  != vport->auth.trans_id) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1040 Bad Reply trans_id- rejecting. "
-				 "Trans_id: 0x%x Expecting: 0x%x \n",
-				 trans_id, vport->auth.trans_id);
-		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PAYLOAD);
-		return;
-	}
-
-	/* Zero is a valid length to be returned */
-	data_len = lpfc_unpack_dhchap_reply(vport, authcmd->data, fc_req);
-	fc_req->u.dhchap_success.hash_id = vport->auth.hash_id;
-	fc_req->u.dhchap_success.dh_group_id = vport->auth.group_id;
-	fc_req->u.dhchap_success.transaction_id = vport->auth.trans_id;
-	fc_req->u.dhchap_success.our_challenge_len = vport->auth.challenge_len;
-	memcpy(fc_req->u.dhchap_success.data, vport->auth.challenge,
-		vport->auth.challenge_len);
-
-	fc_rsp = kzalloc(MAX_AUTH_RSP_SIZE, GFP_KERNEL);
-
-	if (lpfc_fc_security_dhchap_authenticate(shost, fc_req,
-			(sizeof(struct fc_auth_req) +
-			data_len + vport->auth.challenge_len),
-			fc_rsp, MAX_AUTH_RSP_SIZE)) {
-		kfree(fc_rsp);
-		lpfc_issue_els_auth_reject(vport, ndlp, LOGIC_ERR, 0);
-	}
-
-	kfree(fc_req);
-
-}
-
-static void
-lpfc_els_rcv_chap_suc(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,
-		  struct lpfc_nodelist *ndlp)
-{
-
-	struct Scsi_Host  *shost = lpfc_shost_from_vport(vport);
-	struct lpfc_dmabuf *pcmd = cmdiocb->context2;
-	struct lpfc_auth_message *authcmd;
-	uint32_t message_len;
-	uint32_t trans_id;
-	struct fc_auth_req *fc_req;
-	struct fc_auth_rsp *fc_rsp;
-	uint32_t data_len;
-
-	authcmd = pcmd->virt;
-	message_len = be32_to_cpu(authcmd->message_len);
-	trans_id = be32_to_cpu(authcmd->trans_id);
-
-	lpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);
-
-	if (vport->auth.auth_msg_state != LPFC_DHCHAP_REPLY &&
-	    vport->auth.auth_msg_state != LPFC_DHCHAP_SUCCESS_REPLY) {
-		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PROTOCOL);
-		return;
-	}
-
-	if (trans_id  != vport->auth.trans_id) {
-		lpfc_issue_els_auth_reject(vport, ndlp, AUTH_ERR, BAD_PAYLOAD);
-		return;
-	}
-
-	if (vport->auth.auth_msg_state == LPFC_DHCHAP_REPLY &&
-	    vport->auth.bidirectional) {
-
-		fc_req = kzalloc(MAX_AUTH_REQ_SIZE, GFP_KERNEL);
-		if (!fc_req)
-			return;
-
-		fc_req->local_wwpn = wwn_to_u64(vport->fc_portname.u.wwn);
-		if (ndlp->nlp_type & NLP_FABRIC)
-			fc_req->remote_wwpn = AUTH_FABRIC_WWN;
-		else
-			fc_req->remote_wwpn =
-				wwn_to_u64(ndlp->nlp_portname.u.wwn);
-		fc_req->u.dhchap_success.hash_id = vport->auth.hash_id;
-		fc_req->u.dhchap_success.dh_group_id = vport->auth.group_id;
-		fc_req->u.dhchap_success.transaction_id = vport->auth.trans_id;
-		fc_req->u.dhchap_success.our_challenge_len =
-				vport->auth.challenge_len;
-
-		memcpy(fc_req->u.dhchap_success.data, vport->auth.challenge,
-		       vport->auth.challenge_len);
-
-		/* Zero is a valid return length */
-		data_len = lpfc_unpack_dhchap_success(vport,
-						      authcmd->data,
-						      fc_req);
-
-		fc_rsp = kzalloc(MAX_AUTH_RSP_SIZE, GFP_KERNEL);
-		if (!fc_rsp)
-			return;
-
-		if (lpfc_fc_security_dhchap_authenticate(shost,
-			fc_req, sizeof(struct fc_auth_req) + data_len,
-			fc_rsp, MAX_AUTH_RSP_SIZE)) {
-			kfree(fc_rsp);
-			lpfc_issue_els_auth_reject(vport, ndlp, LOGIC_ERR, 0);
-		}
-
-		kfree(fc_req);
-
-	} else {
-		vport->auth.auth_msg_state = LPFC_DHCHAP_SUCCESS;
-
-		kfree(vport->auth.challenge);
-		vport->auth.challenge = NULL;
-		vport->auth.challenge_len = 0;
-
-		if (vport->auth.auth_state != LPFC_AUTH_SUCCESS) {
-			vport->auth.auth_state = LPFC_AUTH_SUCCESS;
-			lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
-					 "1041 Authentication Successful\n");
-			lpfc_start_discovery(vport);
-		} else {
-			lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
-				"1042 Re-Authentication Successful\n");
-		}
-		/* If config requires re-authentication start the timer */
-		vport->auth.last_auth = jiffies;
-		if (vport->auth.reauth_interval)
-			mod_timer(&ndlp->nlp_reauth_tmr, jiffies +
-				vport->auth.reauth_interval * 60 * HZ);
-	}
-	vport->auth.direction |= AUTH_DIRECTION_REMOTE;
-}
-
 /**
  * lpfc_send_els_failure_event - Posts an ELS command failure event
  * @phba: Pointer to hba context object.
@@ -6079,40 +5672,6 @@ lpfc_els_unsol_buffer(struct lpfc_hba *p
 		if (newnode)
 			lpfc_nlp_put(ndlp);
 		break;
-	case ELS_CMD_AUTH_RJT:
-		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
-			"RCV AUTH_RJT:        did:x%x/ste:x%x flg:x%x",
-			did, vport->port_state, ndlp->nlp_flag);
-		lpfc_els_rcv_auth_rjt(vport, elsiocb, ndlp);
-		break;
-	case ELS_CMD_AUTH_NEG:
-		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
-			"RCV AUTH_NEG:        did:x%x/ste:x%x flg:x%x",
-			did, vport->port_state, ndlp->nlp_flag);
-		lpfc_els_rcv_auth_neg(vport, elsiocb, ndlp);
-		break;
-	case ELS_CMD_DH_CHA:
-		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
-			"RCV DH_CHA:        did:x%x/ste:x%x flg:x%x",
-			did, vport->port_state, ndlp->nlp_flag);
-		lpfc_els_rcv_chap_chal(vport, elsiocb, ndlp);
-		break;
-	case ELS_CMD_DH_REP:
-		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
-			"RCV DH_REP:        did:x%x/ste:x%x flg:x%x",
-			did, vport->port_state, ndlp->nlp_flag);
-		lpfc_els_rcv_chap_reply(vport, elsiocb, ndlp);
-		break;
-	case ELS_CMD_DH_SUC:
-		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
-			"RCV DH_SUC:        did:x%x/ste:x%x flg:x%x",
-			did, vport->port_state, ndlp->nlp_flag);
-		lpfc_els_rcv_chap_suc(vport, elsiocb, ndlp);
-		break;
-	case ELS_CMD_AUTH_DONE:
-		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
-			"RCV AUTH_DONE:        did:x%x/ste:x%x flg:x%x",
-			did, vport->port_state, ndlp->nlp_flag);
 	default:
 		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,
 			"RCV ELS cmd:     cmd:x%x did:x%x/ste:x%x",
@@ -6424,10 +5983,8 @@ lpfc_cmpl_reg_new_vport(struct lpfc_hba 
 				lpfc_start_fdiscs(phba);
 				lpfc_do_scr_ns_plogi(phba, vport);
 			}
-		} else if (vport->cfg_enable_auth)
-			lpfc_get_auth_config(vport, NULL);
-		else
-			lpfc_start_discovery(vport);
+		} else
+			lpfc_do_scr_ns_plogi(phba, vport);
 	}
 
 	/* Now, we decrement the ndlp reference count held for this
@@ -6591,8 +6148,6 @@ lpfc_cmpl_els_fdisc(struct lpfc_hba *phb
 	struct lpfc_nodelist *next_np;
 	IOCB_t *irsp = &rspiocb->iocb;
 	struct lpfc_iocbq *piocb;
-	struct lpfc_dmabuf *pcmd = cmdiocb->context2, *prsp;
-	struct serv_parm *sp;
 
 	lpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,
 			 "0123 FDISC completes. x%x/x%x prevDID: x%x\n",
@@ -6626,25 +6181,6 @@ lpfc_cmpl_els_fdisc(struct lpfc_hba *phb
 				 irsp->ulpStatus, irsp->un.ulpWord[4]);
 		goto fdisc_failed;
 	}
-	prsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);
-	sp = prsp->virt + sizeof(uint32_t);
-	if (sp->cmn.security)
-		ndlp->nlp_flag |= NLP_SC_REQ;
-	else
-		ndlp->nlp_flag &= ~NLP_SC_REQ;
-	if (vport->cfg_enable_auth) {
-		if (lpfc_get_auth_config(vport, NULL))
-			goto fdisc_failed;
-	} else {
-		vport->auth.security_active = 0;
-		if (sp->cmn.security) {
-			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-					 "1056 Authentication mode is "
-					 "disabled, but is required "
-					 "by the fabric.\n");
-			goto fdisc_failed;
-		}
-	}
 	spin_lock_irq(shost->host_lock);
 	vport->fc_flag &= ~FC_VPORT_CVL_RCVD;
 	vport->fc_flag |= FC_FABRIC;
@@ -6679,11 +6215,8 @@ lpfc_cmpl_els_fdisc(struct lpfc_hba *phb
 
 	if (vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)
 		lpfc_register_new_vport(phba, vport, ndlp);
-	else if (vport->cfg_enable_auth) {
-		if (lpfc_get_auth_config(vport, NULL))
-			goto fdisc_failed;
-	} else
-		lpfc_start_discovery(vport);
+	else
+		lpfc_do_scr_ns_plogi(phba, vport);
 	goto out;
 fdisc_failed:
 	lpfc_vport_set_state(vport, FC_VPORT_FAILED);
@@ -6765,8 +6298,6 @@ lpfc_issue_els_fdisc(struct lpfc_vport *
 	sp->cls1.classValid = 0;
 	sp->cls2.seqDelivery = 1;
 	sp->cls3.seqDelivery = 1;
-	if (vport->cfg_enable_auth)
-		sp->cmn.security = 1;
 
 	pcmd += sizeof(uint32_t); /* CSP Word 2 */
 	pcmd += sizeof(uint32_t); /* CSP Word 3 */
@@ -7237,191 +6768,6 @@ void lpfc_fabric_abort_hba(struct lpfc_h
 	lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
 			      IOERR_SLI_ABORTED);
 }
-static void
-lpfc_cmpl_els_auth(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,
-		   struct lpfc_iocbq *rspiocb)
-{
-	IOCB_t *irsp = &rspiocb->iocb;
-	struct lpfc_vport *vport = cmdiocb->vport;
-	struct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) cmdiocb->context1;
-	enum auth_state auth_state;
-	struct ls_rjt stat;
-
-	/* Check to see if link went down during discovery */
-	if (lpfc_els_chk_latt(vport)) {
-		vport->auth.auth_msg_state = LPFC_AUTH_NONE;
-		lpfc_els_free_iocb(phba, cmdiocb);
-		return;
-	}
-
-	if (irsp->ulpStatus) {
-		auth_state = LPFC_AUTH_FAIL;
-		if (irsp->ulpStatus == IOSTAT_LS_RJT) {
-			stat.un.lsRjtError = be32_to_cpu(irsp->un.ulpWord[4]);
-			lpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,
-					 "1043 Authentication LS_RJT\n");
-			if (stat.un.b.lsRjtRsnCode == LSRJT_LOGICAL_BSY)
-				auth_state = LPFC_AUTH_FAIL_LS_RJT_BUSY;
-			else
-				auth_state = LPFC_AUTH_FAIL_LS_RJT_GEN;
-		} else if (irsp->ulpStatus == IOSTAT_LOCAL_REJECT &&
-			   (irsp->un.ulpWord[4] & 0xff) ==
-				IOERR_SEQUENCE_TIMEOUT) {
-			auth_state = LPFC_AUTH_FAIL_ELS_TMO;
-		}
-		/* Check for retry */
-		if (!lpfc_els_retry(phba, cmdiocb, rspiocb)) {
-			if (irsp->ulpStatus != IOSTAT_LS_RJT) {
-				lpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,
-						 "1045 Issue AUTH_NEG failed."
-						 "Status:%x\n",
-						 irsp->ulpStatus);
-			}
-			if (vport->auth.auth_mode == FC_AUTHMODE_ACTIVE) {
-				lpfc_can_disctmo(vport);
-				lpfc_port_auth_failed(ndlp, auth_state);
-			}
-		}
-		if (!(phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&
-		    (phba->link_state != LPFC_CLEAR_LA))
-			lpfc_issue_clear_la(phba, vport);
-		lpfc_els_free_iocb(phba, cmdiocb);
-		return;
-	}
-
-	if (vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS ||
-	    vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS_REPLY) {
-
-		kfree(vport->auth.challenge);
-		vport->auth.challenge = NULL;
-		vport->auth.challenge_len = 0;
-		kfree(vport->auth.dh_pub_key);
-		vport->auth.dh_pub_key = NULL;
-		vport->auth.dh_pub_key_len = 0;
-
-		if (vport->auth.auth_msg_state == LPFC_DHCHAP_SUCCESS) {
-			if (vport->auth.auth_state != LPFC_AUTH_SUCCESS) {
-				lpfc_printf_vlog(vport, KERN_WARNING,
-						 LOG_SECURITY, "1046 "
-						 "Authentication Successful\n");
-				vport->auth.auth_state = LPFC_AUTH_SUCCESS;
-				lpfc_start_discovery(vport);
-			} else {
-				lpfc_printf_vlog(vport, KERN_WARNING,
-						 LOG_SECURITY,
-						 "1047 Re-Authentication"
-						 " Successful\n");
-			}
-		}
-		/* restart authentication timer */
-		vport->auth.last_auth = jiffies;
-		if (vport->auth.reauth_interval)
-			mod_timer(&ndlp->nlp_reauth_tmr,
-				jiffies +
-				vport->auth.reauth_interval * 60 * HZ);
-	}
-	lpfc_els_free_iocb(phba, cmdiocb);
-}
-
-int
-lpfc_issue_els_auth(struct lpfc_vport *vport,
-		    struct lpfc_nodelist *ndlp,
-		    uint8_t message_code,
-		    uint8_t *payload,
-		    uint32_t payload_len)
-{
-	struct lpfc_hba *phba = vport->phba;
-	struct lpfc_iocbq *elsiocb;
-	struct lpfc_auth_message *authreq;
-
-	elsiocb = lpfc_prep_els_iocb(vport, 1,
-			sizeof(struct lpfc_auth_message) + payload_len,
-			0, ndlp, ndlp->nlp_DID, ELS_CMD_AUTH);
-
-	if (!elsiocb)
-		return 1;
-	authreq = (struct lpfc_auth_message *)
-		(((struct lpfc_dmabuf *) elsiocb->context2)->virt);
-	authreq->command_code = ELS_CMD_AUTH_BYTE;
-	authreq->flags = 0;
-	authreq->message_code = message_code;
-	authreq->protocol_ver = AUTH_VERSION;
-	authreq->message_len = cpu_to_be32(payload_len);
-	authreq->trans_id = cpu_to_be32(vport->auth.trans_id);
-	memcpy(authreq->data, payload, payload_len);
-
-	elsiocb->iocb_cmpl = lpfc_cmpl_els_auth;
-
-	if (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING,
-				elsiocb, 0) == IOCB_ERROR) {
-		lpfc_els_free_iocb(phba, elsiocb);
-		return 1;
-	}
-
-	return 0;
-}
-
-static void
-lpfc_cmpl_els_auth_reject(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,
-		    struct lpfc_iocbq *rspiocb)
-{
-	struct lpfc_vport *vport = cmdiocb->vport;
-	IOCB_t *irsp = &rspiocb->iocb;
-
-	if (irsp->ulpStatus) {
-		/* Check for retry */
-		if (!lpfc_els_retry(phba, cmdiocb, rspiocb)) {
-			lpfc_printf_log(phba, KERN_ERR, LOG_ELS,
-					"1048 Issue AUTH_REJECT failed.\n");
-		}
-	} else
-	       vport->port_state = LPFC_VPORT_UNKNOWN;
-
-	lpfc_els_free_iocb(phba, cmdiocb);
-}
-
-int
-lpfc_issue_els_auth_reject(struct lpfc_vport *vport,
-					struct lpfc_nodelist *ndlp,
-					uint8_t reason, uint8_t explanation)
-{
-	struct lpfc_hba *phba = vport->phba;
-	struct lpfc_iocbq *elsiocb;
-	struct lpfc_auth_message *authreq;
-	struct lpfc_auth_reject *reject;
-
-	vport->auth.auth_msg_state = LPFC_AUTH_REJECT;
-
-	elsiocb = lpfc_prep_els_iocb(vport, 1, sizeof(struct lpfc_auth_message)
-				     + sizeof(struct lpfc_auth_reject), 0, ndlp,
-				     ndlp->nlp_DID, ELS_CMD_AUTH);
-
-	if (!elsiocb)
-		return 1;
-
-	authreq = (struct lpfc_auth_message *)
-		(((struct lpfc_dmabuf *) elsiocb->context2)->virt);
-	authreq->command_code = ELS_CMD_AUTH_BYTE;
-	authreq->flags = 0;
-	authreq->message_code = AUTH_REJECT;
-	authreq->protocol_ver = AUTH_VERSION;
-	reject = (struct lpfc_auth_reject *)authreq->data;
-	memset(reject, 0, sizeof(struct lpfc_auth_reject));
-	reject->reason = reason;
-	reject->explanation = explanation;
-
-	authreq->message_len = cpu_to_be32(sizeof(struct lpfc_auth_reject));
-	authreq->trans_id = cpu_to_be32(vport->auth.trans_id);
-	elsiocb->iocb_cmpl = lpfc_cmpl_els_auth_reject;
-
-	if (lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0)
-			== IOCB_ERROR) {
-		lpfc_els_free_iocb(phba, elsiocb);
-		return 1;
-	}
-
-	return 0;
-}
 
 /**
  * lpfc_sli4_els_xri_aborted - Slow-path process of els xri abort
--- a/drivers/scsi/lpfc/lpfc.h
+++ b/drivers/scsi/lpfc/lpfc.h
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2009 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -280,57 +280,6 @@ enum hba_state {
 	LPFC_HBA_ERROR       =  -1
 };
 
-enum auth_state {
-	LPFC_AUTH_UNKNOWN		=  0,
-	LPFC_AUTH_SUCCESS		=  1,
-	LPFC_AUTH_FAIL			=  2,
-	LPFC_AUTH_FAIL_ELS_TMO		=  3,
-	LPFC_AUTH_FAIL_TRANS_TMO	=  4,
-	LPFC_AUTH_FAIL_LS_RJT_GEN	=  5,
-	LPFC_AUTH_FAIL_LS_RJT_BUSY	=  6,
-	LPFC_AUTH_FAIL_AUTH_RJT		=  7,
-};
-enum auth_msg_state {
-	LPFC_AUTH_NONE			=  0,
-	LPFC_AUTH_REJECT		=  1,	/* Sent a Reject */
-	LPFC_AUTH_NEGOTIATE		=  2,	/* Auth Negotiate */
-	LPFC_DHCHAP_CHALLENGE		=  3,	/* Challenge */
-	LPFC_DHCHAP_REPLY		=  4,	/* Reply */
-	LPFC_DHCHAP_SUCCESS_REPLY	=  5,	/* Success with Reply */
-	LPFC_DHCHAP_SUCCESS		=  6,	/* Success */
-	LPFC_AUTH_DONE			=  7,
-};
-
-struct lpfc_auth {
-	uint8_t auth_mode;
-	uint8_t bidirectional;
-	uint8_t hash_priority[4];
-	uint32_t hash_len;
-	uint8_t dh_group_priority[8];
-	uint32_t dh_group_len;
-	uint32_t reauth_interval;
-
-	uint8_t security_active;
-	enum auth_state auth_state;
-	enum auth_msg_state auth_msg_state;
-	uint32_t trans_id;              /* current transaction id. Can be set
-					   by incomming transactions as well */
-	uint32_t group_id;
-	uint32_t hash_id;
-	uint32_t direction;
-#define AUTH_DIRECTION_NONE	0
-#define AUTH_DIRECTION_REMOTE	0x1
-#define AUTH_DIRECTION_LOCAL	0x2
-#define AUTH_DIRECTION_BIDI	(AUTH_DIRECTION_LOCAL|AUTH_DIRECTION_REMOTE)
-
-	uint8_t *challenge;
-	uint32_t challenge_len;
-	uint8_t *dh_pub_key;
-	uint32_t dh_pub_key_len;
-
-	unsigned long last_auth;
-};
-
 struct lpfc_vport {
 	struct lpfc_hba *phba;
 	struct list_head listentry;
@@ -431,15 +380,6 @@ struct lpfc_vport {
 	uint8_t load_flag;
 #define FC_LOADING		0x1	/* HBA in process of loading drvr */
 #define FC_UNLOADING		0x2	/* HBA in process of unloading drvr */
-	/* Fields used for accessing auth service */
-	struct lpfc_auth auth;
-	uint32_t sc_tran_id;
-	struct list_head sc_response_wait_queue;
-	struct list_head sc_users;
-	struct work_struct sc_online_work;
-	struct work_struct sc_offline_work;
-	uint8_t security_service_state;
-
 	/* Vport Config Parameters */
 	uint32_t cfg_scan_down;
 	uint32_t cfg_lun_queue_depth;
@@ -455,7 +395,6 @@ struct lpfc_vport {
 	uint32_t cfg_max_luns;
 	uint32_t cfg_enable_da_id;
 	uint32_t cfg_max_scsicmpl_time;
-	uint32_t cfg_enable_auth;
 
 	uint32_t dev_loss_tmo_changed;
 
@@ -512,6 +451,8 @@ struct unsol_rcv_ct_ctx {
 	uint32_t ctxt_id;
 	uint32_t SID;
 	uint32_t oxid;
+	uint32_t flags;
+#define UNSOL_VALID	0x00000001
 };
 
 struct lpfc_hba {
@@ -854,7 +795,7 @@ struct lpfc_hba {
 	uint16_t vlan_id;
 	struct list_head fcf_conn_rec_list;
 
-	struct mutex ct_event_mutex; /* synchronize access to ct_ev_waiters */
+	spinlock_t ct_ev_lock; /* synchronize access to ct_ev_waiters */
 	struct list_head ct_ev_waiters;
 	struct unsol_rcv_ct_ctx ct_ctx[64];
 	uint32_t ctx_idx;
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2009 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -41,8 +41,6 @@
 #include "lpfc_crtn.h"
 #include "lpfc_vport.h"
 #include "lpfc_debugfs.h"
-#include "lpfc_security.h"
-#include "lpfc_auth_access.h"
 
 /* AlpaArray for assignment of scsid for scan-down and bind_method */
 static uint8_t lpfcAlpaArray[] = {
@@ -66,26 +64,6 @@ static void lpfc_disc_flush_list(struct 
 static void lpfc_unregister_fcfi_cmpl(struct lpfc_hba *, LPFC_MBOXQ_t *);
 
 void
-lpfc_start_discovery(struct lpfc_vport *vport)
-{
-	struct lpfc_hba *phba = vport->phba;
-
-	if (vport->auth.security_active &&
-	    vport->auth.auth_state != LPFC_AUTH_SUCCESS) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,
-				 "0154 Authentication not complete.\n");
-		return;
-	}
-	if (vport->port_type == LPFC_NPIV_PORT) {
-		lpfc_do_scr_ns_plogi(phba, vport);
-		return;
-	}
-
-	lpfc_start_fdiscs(phba);
-	lpfc_do_scr_ns_plogi(phba, vport);
-}
-
-void
 lpfc_terminate_rport_io(struct fc_rport *rport)
 {
 	struct lpfc_rport_data *rdata;
@@ -444,15 +422,6 @@ lpfc_work_list_done(struct lpfc_hba *phb
 			 */
 			lpfc_nlp_put(ndlp);
 			break;
-		case LPFC_EVT_REAUTH:
-			ndlp = (struct lpfc_nodelist *) (evtp->evt_arg1);
-			lpfc_reauthentication_handler(ndlp);
-			free_evt = 0; /* evt is part of ndlp */
-			/* decrement the node reference count held
-			 * for this queued work
-			 */
-			lpfc_nlp_put(ndlp);
-			break;
 		case LPFC_EVT_DEV_LOSS:
 			ndlp = (struct lpfc_nodelist *)(evtp->evt_arg1);
 			lpfc_dev_loss_tmo_handler(ndlp);
@@ -712,9 +681,6 @@ lpfc_cleanup_rpis(struct lpfc_vport *vpo
 			continue;
 		if (ndlp->nlp_state == NLP_STE_UNUSED_NODE)
 			continue;
-		/* Stop re-authentication timer of all nodes. */
-		del_timer_sync(&ndlp->nlp_reauth_tmr);
-
 		if ((phba->sli3_options & LPFC_SLI3_VPORT_TEARDOWN) ||
 			((vport->port_type == LPFC_NPIV_PORT) &&
 			(ndlp->nlp_DID == NameServer_DID)))
@@ -769,25 +735,7 @@ lpfc_linkdown_port(struct lpfc_vport *vp
 		vport->port_state, vport->fc_ns_retry, vport->fc_flag);
 
 	lpfc_port_link_failure(vport);
-	if (vport->auth.auth_state < LPFC_AUTH_FAIL) {
-		vport->auth.auth_state = LPFC_AUTH_UNKNOWN;
-		vport->auth.auth_msg_state = LPFC_AUTH_NONE;
-	}
-}
-
-void
-lpfc_port_auth_failed(struct lpfc_nodelist *ndlp, enum auth_state fail_state)
-{
-	struct lpfc_vport *vport = ndlp->vport;
 
-	vport->auth.auth_state = fail_state;
-	vport->auth.auth_msg_state = LPFC_AUTH_NONE;
-	lpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);
-	if (ndlp->nlp_type & NLP_FABRIC) {
-		lpfc_port_link_failure(vport);
-		lpfc_vport_set_state(vport, FC_VPORT_FAILED);
-		lpfc_issue_els_logo(vport, ndlp, 0);
-	}
 }
 
 int
@@ -908,8 +856,6 @@ lpfc_linkup_port(struct lpfc_vport *vpor
 	if (vport->fc_flag & FC_LBIT)
 		lpfc_linkup_cleanup_nodes(vport);
 
-	vport->auth.auth_state = LPFC_AUTH_UNKNOWN;
-	vport->auth.auth_msg_state = LPFC_AUTH_NONE;
 }
 
 static int
@@ -1030,12 +976,8 @@ lpfc_mbx_cmpl_local_config_link(struct l
 	/* Start discovery by sending a FLOGI. port_state is identically
 	 * LPFC_FLOGI while waiting for FLOGI cmpl
 	 */
-	if ((vport->cfg_enable_auth) &&
-	    (vport->security_service_state == SECURITY_OFFLINE))
-		lpfc_issue_clear_la(phba, vport);
-	else if (vport->port_state != LPFC_FLOGI)
+	if (vport->port_state != LPFC_FLOGI)
 		lpfc_initial_flogi(vport);
-
 	return;
 
 out:
@@ -1894,10 +1836,8 @@ lpfc_mbx_cmpl_reg_vfi(struct lpfc_hba *p
 	vport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;
 
 	if (vport->port_state == LPFC_FABRIC_CFG_LINK) {
-		if (vport->cfg_enable_auth)
-			lpfc_get_auth_config(vport, NULL);
-		else
-			lpfc_start_discovery(vport);
+		lpfc_start_fdiscs(phba);
+		lpfc_do_scr_ns_plogi(phba, vport);
 	}
 fail_free_mem:
 	mempool_free(mboxq, phba->mbox_mem_pool);
@@ -2621,10 +2561,8 @@ lpfc_mbx_cmpl_fabric_reg_login(struct lp
 	lpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);
 
 	if (vport->port_state == LPFC_FABRIC_CFG_LINK) {
-		if (vport->cfg_enable_auth)
-			lpfc_get_auth_config(vport, NULL);
-		else
-			lpfc_start_discovery(vport);
+		lpfc_start_fdiscs(phba);
+		lpfc_do_scr_ns_plogi(phba, vport);
 	}
 
 	lpfc_mbuf_free(phba, mp->virt, mp->phys);
@@ -3009,13 +2947,9 @@ lpfc_initialize_node(struct lpfc_vport *
 {
 	INIT_LIST_HEAD(&ndlp->els_retry_evt.evt_listp);
 	INIT_LIST_HEAD(&ndlp->dev_loss_evt.evt_listp);
-	INIT_LIST_HEAD(&ndlp->els_reauth_evt.evt_listp);
 	init_timer(&ndlp->nlp_delayfunc);
 	ndlp->nlp_delayfunc.function = lpfc_els_retry_delay;
 	ndlp->nlp_delayfunc.data = (unsigned long)ndlp;
-	init_timer(&ndlp->nlp_reauth_tmr);
-	ndlp->nlp_reauth_tmr.function = lpfc_reauth_node;
-	ndlp->nlp_reauth_tmr.data = (unsigned long)ndlp;
 	ndlp->nlp_DID = did;
 	ndlp->vport = vport;
 	ndlp->phba = vport->phba;
@@ -3423,12 +3357,9 @@ lpfc_cleanup_node(struct lpfc_vport *vpo
 
 	ndlp->nlp_last_elscmd = 0;
 	del_timer_sync(&ndlp->nlp_delayfunc);
-	del_timer_sync(&ndlp->nlp_reauth_tmr);
 
 	list_del_init(&ndlp->els_retry_evt.evt_listp);
 	list_del_init(&ndlp->dev_loss_evt.evt_listp);
-	if (!list_empty(&ndlp->els_reauth_evt.evt_listp))
-		list_del_init(&ndlp->els_reauth_evt.evt_listp);
 
 	lpfc_unreg_rpi(vport, ndlp);
 
@@ -4232,14 +4163,7 @@ lpfc_filter_by_wwpn(struct lpfc_nodelist
 		      sizeof(ndlp->nlp_portname)) == 0;
 }
 
-static int
-lpfc_filter_by_wwnn(struct lpfc_nodelist *ndlp, void *param)
-{
-	return memcmp(&ndlp->nlp_nodename, param,
-		      sizeof(ndlp->nlp_nodename)) == 0;
-}
-
-struct lpfc_nodelist *
+static struct lpfc_nodelist *
 __lpfc_find_node(struct lpfc_vport *vport, node_filter filter, void *param)
 {
 	struct lpfc_nodelist *ndlp;
@@ -4252,22 +4176,6 @@ __lpfc_find_node(struct lpfc_vport *vpor
 }
 
 /*
- * Search node lists for a remote port matching filter criteria
- * Caller needs to hold host_lock before calling this routine.
- */
-struct lpfc_nodelist *
-lpfc_find_node(struct lpfc_vport *vport, node_filter filter, void *param)
-{
-	struct Scsi_Host     *shost = lpfc_shost_from_vport(vport);
-	struct lpfc_nodelist *ndlp;
-
-	spin_lock_irq(shost->host_lock);
-	ndlp = __lpfc_find_node(vport, filter, param);
-	spin_unlock_irq(shost->host_lock);
-	return ndlp;
-}
-
-/*
  * This routine looks up the ndlp lists for the given RPI. If rpi found it
  * returns the node list element pointer else return NULL.
  */
@@ -4293,21 +4201,6 @@ lpfc_findnode_wwpn(struct lpfc_vport *vp
 	return ndlp;
 }
 
-/*
- * This routine looks up the ndlp lists for the given WWNN. If WWNN found it
- * returns the node element list pointer else return NULL.
- */
-struct lpfc_nodelist *
-lpfc_findnode_wwnn(struct lpfc_vport *vport, struct lpfc_name *wwnn)
-{
-	struct Scsi_Host *shost = lpfc_shost_from_vport(vport);
-	struct lpfc_nodelist *ndlp;
-
-	spin_lock_irq(shost->host_lock);
-	ndlp = __lpfc_find_node(vport, lpfc_filter_by_wwnn, wwnn);
-	spin_unlock_irq(shost->host_lock);
-	return ndlp;
-}
 void
 lpfc_nlp_init(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
 	      uint32_t did)
--- a/drivers/scsi/lpfc/lpfc_hw.h
+++ b/drivers/scsi/lpfc/lpfc_hw.h
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2009 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -353,8 +353,7 @@ struct csp {
 
 	uint16_t huntgroup:1;	/* FC Word 1, bit 23 */
 	uint16_t simplex:1;	/* FC Word 1, bit 22 */
-	uint16_t security:1;    /* FC Word 1, bit 21 */
-	uint16_t word1Reserved1:2;	/* FC Word 1, bit 20:19 */
+	uint16_t word1Reserved1:3;	/* FC Word 1, bit 21:19 */
 	uint16_t dhd:1;		/* FC Word 1, bit 18 */
 	uint16_t contIncSeqCnt:1;	/* FC Word 1, bit 17 */
 	uint16_t payloadlength:1;	/* FC Word 1, bit 16 */
@@ -371,8 +370,7 @@ struct csp {
 	uint16_t payloadlength:1;	/* FC Word 1, bit 16 */
 	uint16_t contIncSeqCnt:1;	/* FC Word 1, bit 17 */
 	uint16_t dhd:1;		/* FC Word 1, bit 18 */
-	uint16_t word1Reserved1:2;	/* FC Word 1, bit 20:19 */
-	 uint16_t security:1;    /* FC Word 1, bit 21 */
+	uint16_t word1Reserved1:3;	/* FC Word 1, bit 21:19 */
 	uint16_t simplex:1;	/* FC Word 1, bit 22 */
 	uint16_t huntgroup:1;	/* FC Word 1, bit 23 */
 #endif
@@ -540,17 +538,6 @@ struct fc_vft_header {
 #define ELS_CMD_SCR       0x62000000
 #define ELS_CMD_RNID      0x78000000
 #define ELS_CMD_LIRR      0x7A000000
-/*
- * ELS commands for authentication
- * ELS_CMD_AUTH<<24 | AUTH_NEGOTIATE<<8 | AUTH_VERSION
- */
-#define ELS_CMD_AUTH      0x90000000
-#define ELS_CMD_AUTH_RJT  0x90000A01
-#define ELS_CMD_AUTH_NEG  0x90000B01
-#define ELS_CMD_AUTH_DONE 0x90000C01
-#define ELS_CMD_DH_CHA    0x90001001
-#define ELS_CMD_DH_REP    0x90001101
-#define ELS_CMD_DH_SUC    0x90001201
 #else	/*  __LITTLE_ENDIAN_BITFIELD */
 #define ELS_CMD_MASK      0xffff
 #define ELS_RSP_MASK      0xff
@@ -587,17 +574,6 @@ struct fc_vft_header {
 #define ELS_CMD_SCR       0x62
 #define ELS_CMD_RNID      0x78
 #define ELS_CMD_LIRR      0x7A
-/*
- * ELS commands for authentication
- * ELS_CMD_AUTH | AUTH_NEGOTIATE<<16 | AUTH_VERSION<<24
- */
-#define ELS_CMD_AUTH      0x00000090
-#define ELS_CMD_AUTH_RJT  0x010A0090
-#define ELS_CMD_AUTH_NEG  0x010B0090
-#define ELS_CMD_AUTH_DONE 0x010C0090
-#define ELS_CMD_DH_CHA    0x01100090
-#define ELS_CMD_DH_REP    0x01110090
-#define ELS_CMD_DH_SUC    0x01120090
 #endif
 
 /*
@@ -1370,6 +1346,9 @@ typedef struct {		/* FireFly BIU registe
 #define MBX_HEARTBEAT       0x31
 #define MBX_WRITE_VPARMS    0x32
 #define MBX_ASYNCEVT_ENABLE 0x33
+#define MBX_READ_EVENT_LOG_STATUS 0x37
+#define MBX_READ_EVENT_LOG  0x38
+#define MBX_WRITE_EVENT_LOG 0x39
 
 #define MBX_PORT_CAPABILITIES 0x3B
 #define MBX_PORT_IOV_CONTROL 0x3C
@@ -1489,17 +1468,13 @@ typedef struct {		/* FireFly BIU registe
 #define CMD_IOCB_LOGENTRY_CN		0x94
 #define CMD_IOCB_LOGENTRY_ASYNC_CN	0x96
 
-/* Unhandled Data Security SLI Commands */
-#define DSSCMD_IWRITE64_CR 		0xD8
-#define DSSCMD_IWRITE64_CX		0xD9
-#define DSSCMD_IREAD64_CR		0xDA
-#define DSSCMD_IREAD64_CX		0xDB
-#define DSSCMD_INVALIDATE_DEK		0xDC
-#define DSSCMD_SET_KEK			0xDD
-#define DSSCMD_GET_KEK_ID		0xDE
-#define DSSCMD_GEN_XFER			0xDF
+/* Data Security SLI Commands */
+#define DSSCMD_IWRITE64_CR		0xF8
+#define DSSCMD_IWRITE64_CX		0xF9
+#define DSSCMD_IREAD64_CR		0xFA
+#define DSSCMD_IREAD64_CX		0xFB
 
-#define CMD_MAX_IOCB_CMD        0xE6
+#define CMD_MAX_IOCB_CMD        0xFB
 #define CMD_IOCB_MASK           0xff
 
 #define MAX_MSG_DATA            28	/* max msg data in CMD_ADAPTER_MSG
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2009 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -47,14 +47,6 @@
 #include "lpfc_crtn.h"
 #include "lpfc_vport.h"
 #include "lpfc_version.h"
-#include "lpfc_auth_access.h"
-#include "lpfc_security.h"
-#include <net/sock.h>
-#include <linux/netlink.h>
-
-/* vendor ID used in SCSI netlink calls */
-#define LPFC_NL_VENDOR_ID (SCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_EMULEX)
-const char *security_work_q_name = "fc_sc_wq";
 
 char *_dump_buf_data;
 unsigned long _dump_buf_data_order;
@@ -536,9 +528,6 @@ lpfc_config_port_post(struct lpfc_hba *p
 	/* Set up error attention (ERATT) polling timer */
 	mod_timer(&phba->eratt_poll, jiffies + HZ * LPFC_ERATT_POLL_INTERVAL);
 
-	if (vport->cfg_enable_auth &&
-	    vport->security_service_state == SECURITY_OFFLINE)
-			vport->auth.auth_mode = FC_AUTHMODE_UNKNOWN;
 	if (phba->hba_flag & LINK_DISABLED) {
 		lpfc_printf_log(phba,
 			KERN_ERR, LOG_INIT,
@@ -2076,17 +2065,8 @@ lpfc_cleanup(struct lpfc_vport *vport)
 void
 lpfc_stop_vport_timers(struct lpfc_vport *vport)
 {
-	struct fc_security_request *fc_sc_req;
 	del_timer_sync(&vport->els_tmofunc);
 	del_timer_sync(&vport->fc_fdmitmo);
-	while (!list_empty(&vport->sc_response_wait_queue)) {
-		list_remove_head(&vport->sc_response_wait_queue, fc_sc_req,
-					   struct fc_security_request, rlist);
-		if (!fc_sc_req)
-			continue;
-		del_timer_sync(&fc_sc_req->timer);
-		kfree(fc_sc_req);
-	}
 	lpfc_can_disctmo(vport);
 	return;
 }
@@ -2416,12 +2396,6 @@ lpfc_create_port(struct lpfc_hba *phba, 
 	vport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;
 	vport->fc_rscn_flush = 0;
 
-	INIT_WORK(&vport->sc_online_work, lpfc_fc_sc_security_online);
-	INIT_WORK(&vport->sc_offline_work, lpfc_fc_sc_security_offline);
-	INIT_LIST_HEAD(&vport->sc_users);
-	INIT_LIST_HEAD(&vport->sc_response_wait_queue);
-	vport->security_service_state = SECURITY_OFFLINE;
-
 	lpfc_get_vport_cfgparam(vport);
 	shost->unique_id = instance;
 	shost->max_id = LPFC_MAX_TARGET;
@@ -2467,10 +2441,6 @@ lpfc_create_port(struct lpfc_hba *phba, 
 	error = scsi_add_host(shost, dev);
 	if (error)
 		goto out_put_shost;
-	vport->auth.challenge = NULL;
-	vport->auth.challenge_len = 0;
-	vport->auth.dh_pub_key = NULL;
-	vport->auth.dh_pub_key_len = 0;
 
 	spin_lock_irq(&phba->hbalock);
 	list_add_tail(&vport->listentry, &phba->port_list);
@@ -4360,7 +4330,7 @@ lpfc_hba_alloc(struct pci_dev *pdev)
 		return NULL;
 	}
 
-	mutex_init(&phba->ct_event_mutex);
+	spin_lock_init(&phba->ct_ev_lock);
 	INIT_LIST_HEAD(&phba->ct_ev_waiters);
 
 	return phba;
@@ -6956,7 +6926,6 @@ lpfc_pci_probe_one_s3(struct pci_dev *pd
 
 	/* Configure sysfs attributes */
 	vport = phba->pport;
-	shost = lpfc_shost_from_vport(vport);
 	error = lpfc_alloc_sysfs_attr(vport);
 	if (error) {
 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
@@ -6964,18 +6933,6 @@ lpfc_pci_probe_one_s3(struct pci_dev *pd
 		goto out_destroy_shost;
 	}
 
-	/* Add this shost to the security event list */
-	if ((lpfc_get_security_enabled)(shost)) {
-		spin_lock_irq(&fc_security_user_lock);
-		list_add_tail(&vport->sc_users, &fc_security_user_list);
-		spin_unlock_irq(&fc_security_user_lock);
-		/* Triggers fcauthd to register if it is running */
-		fc_host_post_event(shost, fc_get_event_number(),
-				   FCH_EVT_PORT_ONLINE, shost->host_no);
-		if (fc_service_state == FC_SC_SERVICESTATE_ONLINE)
-			lpfc_fc_queue_security_work(vport,
-						    &vport->sc_online_work);
-	}
 	shost = lpfc_shost_from_vport(vport); /* save shost for error cleanup */
 	/* Now, trying to enable interrupt and bring up the device */
 	cfg_mode = phba->cfg_use_msi;
@@ -7031,11 +6988,6 @@ out_remove_device:
 	lpfc_unset_hba(phba);
 out_free_sysfs_attr:
 	lpfc_free_sysfs_attr(vport);
-	if ((lpfc_get_security_enabled)(shost)) {
-		spin_lock_irq(&fc_security_user_lock);
-		list_del(&vport->sc_users);
-		spin_unlock_irq(&fc_security_user_lock);
-	}
 out_destroy_shost:
 	lpfc_destroy_shost(phba);
 out_unset_driver_resource:
@@ -7578,7 +7530,6 @@ lpfc_pci_probe_one_s4(struct pci_dev *pd
 
 	/* Configure sysfs attributes */
 	vport = phba->pport;
-	shost = lpfc_shost_from_vport(vport);
 	error = lpfc_alloc_sysfs_attr(vport);
 	if (error) {
 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
@@ -7586,20 +7537,6 @@ lpfc_pci_probe_one_s4(struct pci_dev *pd
 		goto out_destroy_shost;
 	}
 
-	/* Add this shost to the security event list */
-	if ((lpfc_get_security_enabled)(shost)) {
-#ifdef SCSI_NL_SHOST_VENDOR
-		/* Triggers fcauthd to register if it is running */
-		fc_host_post_event(shost, fc_get_event_number(),
-				   FCH_EVT_PORT_ONLINE, shost->host_no);
-#endif
-		spin_lock_irq(&fc_security_user_lock);
-		list_add_tail(&vport->sc_users, &fc_security_user_list);
-		spin_unlock_irq(&fc_security_user_lock);
-		if (fc_service_state == FC_SC_SERVICESTATE_ONLINE)
-			lpfc_fc_queue_security_work(vport,
-						    &vport->sc_online_work);
-	}
 	shost = lpfc_shost_from_vport(vport); /* save shost for error cleanup */
 	/* Now, trying to enable interrupt and bring up the device */
 	cfg_mode = phba->cfg_use_msi;
@@ -7660,11 +7597,6 @@ out_disable_intr:
 	lpfc_sli4_disable_intr(phba);
 out_free_sysfs_attr:
 	lpfc_free_sysfs_attr(vport);
-	if ((lpfc_get_security_enabled)(shost)) {
-		spin_lock_irq(&fc_security_user_lock);
-		list_del(&vport->sc_users);
-		spin_unlock_irq(&fc_security_user_lock);
-	}
 out_destroy_shost:
 	lpfc_destroy_shost(phba);
 out_unset_driver_resource:
@@ -8314,29 +8246,12 @@ lpfc_init(void)
 			return -ENOMEM;
 		}
 	}
-	error = scsi_nl_add_driver(LPFC_NL_VENDOR_ID, &lpfc_template,
-				   lpfc_rcv_nl_msg, lpfc_rcv_nl_event);
-	if (error)
-		goto out_release_transport;
-	security_work_q = create_singlethread_workqueue(security_work_q_name);
-	if (!security_work_q)
-		goto out_nl_remove_driver;
-	INIT_LIST_HEAD(&fc_security_user_list);
 	error = pci_register_driver(&lpfc_driver);
-	if (error)
-		goto out_destroy_workqueue;
-
-	return error;
-
-out_destroy_workqueue:
-	destroy_workqueue(security_work_q);
-	security_work_q = NULL;
-out_nl_remove_driver:
-	scsi_nl_remove_driver(LPFC_NL_VENDOR_ID);
-out_release_transport:
-	fc_release_transport(lpfc_transport_template);
-	if (lpfc_enable_npiv)
-		fc_release_transport(lpfc_vport_transport_template);
+	if (error) {
+		fc_release_transport(lpfc_transport_template);
+		if (lpfc_enable_npiv)
+			fc_release_transport(lpfc_vport_transport_template);
+	}
 
 	return error;
 }
@@ -8352,10 +8267,6 @@ static void __exit
 lpfc_exit(void)
 {
 	pci_unregister_driver(&lpfc_driver);
-	if (security_work_q)
-		destroy_workqueue(security_work_q);
-	security_work_q = NULL;
-	scsi_nl_remove_driver(LPFC_NL_VENDOR_ID);
 	fc_release_transport(lpfc_transport_template);
 	if (lpfc_enable_npiv)
 		fc_release_transport(lpfc_vport_transport_template);
--- a/drivers/scsi/lpfc/lpfc_nl.h
+++ b/drivers/scsi/lpfc/lpfc_nl.h
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2008 Emulex.  All rights reserved.                *
+ * Copyright (C) 2010 Emulex.  All rights reserved.                *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  *                                                                 *
@@ -177,23 +177,3 @@ struct temp_event {
 	uint32_t data;
 };
 
-/* bsg definitions */
-#define LPFC_BSG_VENDOR_SET_CT_EVENT	1
-#define LPFC_BSG_VENDOR_GET_CT_EVENT	2
-
-struct set_ct_event {
-	uint32_t command;
-	uint32_t ev_req_id;
-	uint32_t ev_reg_id;
-};
-
-struct get_ct_event {
-	uint32_t command;
-	uint32_t ev_reg_id;
-	uint32_t ev_req_id;
-};
-
-struct get_ct_event_reply {
-	uint32_t immed_data;
-	uint32_t type;
-};
--- a/drivers/scsi/lpfc/lpfc_nportdisc.c
+++ b/drivers/scsi/lpfc/lpfc_nportdisc.c
@@ -62,7 +62,7 @@ lpfc_check_adisc(struct lpfc_vport *vpor
 
 int
 lpfc_check_sparm(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
-		 struct serv_parm * sp, uint32_t class)
+		 struct serv_parm *sp, uint32_t class, int flogi)
 {
 	volatile struct serv_parm *hsp = &vport->fc_sparam;
 	uint16_t hsp_value, ssp_value = 0;
@@ -75,49 +75,56 @@ lpfc_check_sparm(struct lpfc_vport *vpor
 	 * correcting the byte values.
 	 */
 	if (sp->cls1.classValid) {
-		hsp_value = (hsp->cls1.rcvDataSizeMsb << 8) |
-				hsp->cls1.rcvDataSizeLsb;
-		ssp_value = (sp->cls1.rcvDataSizeMsb << 8) |
-				sp->cls1.rcvDataSizeLsb;
-		if (!ssp_value)
-			goto bad_service_param;
-		if (ssp_value > hsp_value) {
-			sp->cls1.rcvDataSizeLsb = hsp->cls1.rcvDataSizeLsb;
-			sp->cls1.rcvDataSizeMsb = hsp->cls1.rcvDataSizeMsb;
+		if (!flogi) {
+			hsp_value = ((hsp->cls1.rcvDataSizeMsb << 8) |
+				     hsp->cls1.rcvDataSizeLsb);
+			ssp_value = ((sp->cls1.rcvDataSizeMsb << 8) |
+				     sp->cls1.rcvDataSizeLsb);
+			if (!ssp_value)
+				goto bad_service_param;
+			if (ssp_value > hsp_value) {
+				sp->cls1.rcvDataSizeLsb =
+					hsp->cls1.rcvDataSizeLsb;
+				sp->cls1.rcvDataSizeMsb =
+					hsp->cls1.rcvDataSizeMsb;
+			}
 		}
-	} else if (class == CLASS1) {
+	} else if (class == CLASS1)
 		goto bad_service_param;
-	}
-
 	if (sp->cls2.classValid) {
-		hsp_value = (hsp->cls2.rcvDataSizeMsb << 8) |
-				hsp->cls2.rcvDataSizeLsb;
-		ssp_value = (sp->cls2.rcvDataSizeMsb << 8) |
-				sp->cls2.rcvDataSizeLsb;
-		if (!ssp_value)
-			goto bad_service_param;
-		if (ssp_value > hsp_value) {
-			sp->cls2.rcvDataSizeLsb = hsp->cls2.rcvDataSizeLsb;
-			sp->cls2.rcvDataSizeMsb = hsp->cls2.rcvDataSizeMsb;
+		if (!flogi) {
+			hsp_value = ((hsp->cls2.rcvDataSizeMsb << 8) |
+				     hsp->cls2.rcvDataSizeLsb);
+			ssp_value = ((sp->cls2.rcvDataSizeMsb << 8) |
+				     sp->cls2.rcvDataSizeLsb);
+			if (!ssp_value)
+				goto bad_service_param;
+			if (ssp_value > hsp_value) {
+				sp->cls2.rcvDataSizeLsb =
+					hsp->cls2.rcvDataSizeLsb;
+				sp->cls2.rcvDataSizeMsb =
+					hsp->cls2.rcvDataSizeMsb;
+			}
 		}
-	} else if (class == CLASS2) {
+	} else if (class == CLASS2)
 		goto bad_service_param;
-	}
-
 	if (sp->cls3.classValid) {
-		hsp_value = (hsp->cls3.rcvDataSizeMsb << 8) |
-				hsp->cls3.rcvDataSizeLsb;
-		ssp_value = (sp->cls3.rcvDataSizeMsb << 8) |
-				sp->cls3.rcvDataSizeLsb;
-		if (!ssp_value)
-			goto bad_service_param;
-		if (ssp_value > hsp_value) {
-			sp->cls3.rcvDataSizeLsb = hsp->cls3.rcvDataSizeLsb;
-			sp->cls3.rcvDataSizeMsb = hsp->cls3.rcvDataSizeMsb;
+		if (!flogi) {
+			hsp_value = ((hsp->cls3.rcvDataSizeMsb << 8) |
+				     hsp->cls3.rcvDataSizeLsb);
+			ssp_value = ((sp->cls3.rcvDataSizeMsb << 8) |
+				     sp->cls3.rcvDataSizeLsb);
+			if (!ssp_value)
+				goto bad_service_param;
+			if (ssp_value > hsp_value) {
+				sp->cls3.rcvDataSizeLsb =
+					hsp->cls3.rcvDataSizeLsb;
+				sp->cls3.rcvDataSizeMsb =
+					hsp->cls3.rcvDataSizeMsb;
+			}
 		}
-	} else if (class == CLASS3) {
+	} else if (class == CLASS3)
 		goto bad_service_param;
-	}
 
 	/*
 	 * Preserve the upper four bits of the MSB from the PLOGI response.
@@ -295,7 +302,7 @@ lpfc_rcv_plogi(struct lpfc_vport *vport,
 			NULL);
 		return 0;
 	}
-	if ((lpfc_check_sparm(vport, ndlp, sp, CLASS3) == 0)) {
+	if ((lpfc_check_sparm(vport, ndlp, sp, CLASS3, 0) == 0)) {
 		/* Reject this request because invalid parameters */
 		stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
 		stat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;
@@ -831,7 +838,7 @@ lpfc_cmpl_plogi_plogi_issue(struct lpfc_
 				 "0142 PLOGI RSP: Invalid WWN.\n");
 		goto out;
 	}
-	if (!lpfc_check_sparm(vport, ndlp, sp, CLASS3))
+	if (!lpfc_check_sparm(vport, ndlp, sp, CLASS3, 0))
 		goto out;
 	/* PLOGI chkparm OK */
 	lpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,
--- a/drivers/scsi/lpfc/lpfc_scsi.c
+++ b/drivers/scsi/lpfc/lpfc_scsi.c
@@ -3003,6 +3003,7 @@ lpfc_abort_handler(struct scsi_cmnd *cmn
 
 	/* ABTS WQE must go to the same WQ as the WQE to be aborted */
 	abtsiocb->fcp_wqidx = iocb->fcp_wqidx;
+	abtsiocb->iocb_flag |= LPFC_USE_FCPWQIDX;
 
 	if (lpfc_is_link_up(phba))
 		icmd->ulpCommand = CMD_ABORT_XRI_CN;
--- a/drivers/scsi/lpfc/lpfc_security.c
+++ b/drivers/scsi/lpfc/lpfc_security.c
@@ -1,339 +0,0 @@
-/*******************************************************************
- * This file is part of the Emulex Linux Device Driver for         *
- * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2006-2008 Emulex.  All rights reserved.           *
- * EMULEX and SLI are trademarks of Emulex.                        *
- * www.emulex.com                                                  *
- *                                                                 *
- * This program is free software; you can redistribute it and/or   *
- * modify it under the terms of version 2 of the GNU General       *
- * Public License as published by the Free Software Foundation.    *
- * This program is distributed in the hope that it will be useful. *
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
- * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
- * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
- * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
- * more details, a copy of which can be found in the file COPYING  *
- * included with this package.                                     *
- *******************************************************************/
-
-#include <linux/delay.h>
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-
-#include <scsi/scsi_tcq.h>
-#include <scsi/scsi_transport_fc.h>
-
-#include "lpfc_hw4.h"
-#include "lpfc_hw.h"
-#include "lpfc_sli.h"
-#include "lpfc_sli4.h"
-#include "lpfc_nl.h"
-#include "lpfc_disc.h"
-#include "lpfc.h"
-#include "lpfc_crtn.h"
-#include "lpfc_logmsg.h"
-#include "lpfc_security.h"
-#include "lpfc_auth_access.h"
-#include "lpfc_vport.h"
-
-void
-lpfc_security_service_online(struct Scsi_Host *shost)
-{
-	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
-
-	vport->security_service_state = SECURITY_ONLINE;
-	if (vport->cfg_enable_auth &&
-	    vport->auth.auth_mode == FC_AUTHMODE_UNKNOWN &&
-	    vport->phba->link_state == LPFC_HBA_ERROR)
-		lpfc_selective_reset(vport->phba);
-}
-
-void
-lpfc_security_service_offline(struct Scsi_Host *shost)
-{
-	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
-
-	vport->security_service_state = SECURITY_OFFLINE;
-}
-
-void
-lpfc_security_config(struct Scsi_Host *shost, int status, void *rsp)
-{
-	struct fc_auth_rsp *auth_rsp = (struct fc_auth_rsp *)rsp;
-	struct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;
-	struct lpfc_nodelist *ndlp;
-	uint32_t old_interval, new_interval;
-	unsigned long new_jiffies, temp_jiffies;
-	uint8_t last_auth_mode;
-
-	if (status)
-		return;
-	ndlp = lpfc_findnode_did(vport, Fabric_DID);
-	if (!ndlp || !NLP_CHK_NODE_ACT(ndlp))
-		return;
-
-	vport->auth.bidirectional =
-		auth_rsp->u.dhchap_security_config.bidirectional;
-	memcpy(&vport->auth.hash_priority[0],
-	       &auth_rsp->u.dhchap_security_config.hash_priority[0],
-	       sizeof(vport->auth.hash_priority));
-	vport->auth.hash_len = auth_rsp->u.dhchap_security_config.hash_len;
-	memcpy(&vport->auth.dh_group_priority[0],
-	       &auth_rsp->u.dhchap_security_config.
-	       dh_group_priority[0],
-	       sizeof(vport->auth.dh_group_priority));
-	vport->auth.dh_group_len =
-		auth_rsp->u.dhchap_security_config.dh_group_len;
-	old_interval = vport->auth.reauth_interval;
-	vport->auth.reauth_interval =
-		auth_rsp->u.dhchap_security_config.reauth_interval;
-	new_interval = vport->auth.reauth_interval;
-	/*
-	 * If interval changed we need to adjust the running timer
-	 *  If enabled then start timer now.
-	 *  If disabled then stop the timer.
-	 *  If changed to chorter then elapsed time, then set to fire now
-	 *  If changed to longer than elapsed time, extend the timer.
-	 */
-	if (old_interval != new_interval &&
-	    vport->auth.auth_state == LPFC_AUTH_SUCCESS) {
-		new_jiffies = msecs_to_jiffies(new_interval * 60000);
-		del_timer_sync(&ndlp->nlp_reauth_tmr);
-		if (old_interval == 0)
-			temp_jiffies = jiffies + new_jiffies;
-		if (new_interval == 0)
-			temp_jiffies = 0;
-		else if (new_jiffies < (jiffies - vport->auth.last_auth))
-			temp_jiffies = jiffies + msecs_to_jiffies(1);
-		else
-			temp_jiffies = jiffies + (new_jiffies -
-				(jiffies - vport->auth.last_auth));
-		if (temp_jiffies)
-			mod_timer(&ndlp->nlp_reauth_tmr, temp_jiffies);
-	}
-	last_auth_mode = vport->auth.auth_mode;
-	vport->auth.auth_mode =
-		auth_rsp->u.dhchap_security_config.auth_mode;
-	lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
-		"1025 Received security config local_wwpn:"
-		 "%llX remote_wwpn:%llX mode:0x%x "
-		 "hash(%d):%x:%x:%x:%x bidir:0x%x "
-		 "dh_group(%d):%x:%x:%x:%x:%x:%x:%x:%x "
-		 "reauth_interval:0x%x\n",
-		 (unsigned long long)auth_rsp->local_wwpn,
-		 (unsigned long long)auth_rsp->remote_wwpn,
-		 auth_rsp->u.dhchap_security_config.auth_mode,
-		 auth_rsp->u.dhchap_security_config.hash_len,
-		 auth_rsp->u.dhchap_security_config.hash_priority[0],
-		 auth_rsp->u.dhchap_security_config.hash_priority[1],
-		 auth_rsp->u.dhchap_security_config.hash_priority[2],
-		 auth_rsp->u.dhchap_security_config.hash_priority[3],
-		 auth_rsp->u.dhchap_security_config.bidirectional,
-		 auth_rsp->u.dhchap_security_config.dh_group_len,
-		 auth_rsp->u.dhchap_security_config.dh_group_priority[0],
-		 auth_rsp->u.dhchap_security_config.dh_group_priority[1],
-		 auth_rsp->u.dhchap_security_config.dh_group_priority[2],
-		 auth_rsp->u.dhchap_security_config.dh_group_priority[3],
-		 auth_rsp->u.dhchap_security_config.dh_group_priority[4],
-		 auth_rsp->u.dhchap_security_config.dh_group_priority[5],
-		 auth_rsp->u.dhchap_security_config.dh_group_priority[6],
-		 auth_rsp->u.dhchap_security_config.dh_group_priority[7],
-		 auth_rsp->u.dhchap_security_config.reauth_interval);
-	kfree(auth_rsp);
-	if (vport->auth.auth_mode == FC_AUTHMODE_ACTIVE)
-		vport->auth.security_active = 1;
-	else if (vport->auth.auth_mode == FC_AUTHMODE_PASSIVE) {
-		if (ndlp->nlp_flag & NLP_SC_REQ)
-			vport->auth.security_active = 1;
-		else {
-			lpfc_printf_vlog(vport, KERN_INFO, LOG_SECURITY,
-					 "1038 Authentication not "
-					 "required by the fabric. "
-					 "Disabled.\n");
-			vport->auth.security_active = 0;
-		}
-	} else {
-		vport->auth.security_active = 0;
-		/*
-		* If switch require authentication and authentication
-		* is disabled for this HBA/Fabric port, fail the
-		* discovery.
-		*/
-		if (ndlp->nlp_flag & NLP_SC_REQ) {
-			lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-					 "1050 Authentication mode is "
-					 "disabled, but is required by "
-					 "the fabric.\n");
-			lpfc_vport_set_state(vport, FC_VPORT_FAILED);
-			/* Cancel discovery timer */
-			lpfc_can_disctmo(vport);
-		}
-	}
-
-	if (last_auth_mode == FC_AUTHMODE_UNKNOWN) {
-		if (vport->auth.security_active)
-			lpfc_start_authentication(vport, ndlp);
-		else
-			lpfc_start_discovery(vport);
-	}
-}
-
-int
-lpfc_get_security_enabled(struct Scsi_Host *shost)
-{
-	struct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;
-
-	return vport->cfg_enable_auth;
-}
-
-int
-lpfc_security_wait(struct lpfc_vport *vport)
-{
-	int i = 0;
-	if (vport->security_service_state == SECURITY_ONLINE)
-		return 0;
-	lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-			"1058 Waiting for authentication service...\n");
-	while (vport->security_service_state == SECURITY_OFFLINE) {
-		i++;
-		if (i > SECURITY_WAIT_TMO * 2)
-			return -ETIMEDOUT;
-		/* Delay for half of a second */
-		msleep(500);
-	}
-	lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-			"1059 Authentication service online.\n");
-	return 0;
-}
-
-int
-lpfc_security_config_wait(struct lpfc_vport *vport)
-{
-	int i = 0;
-
-	while (vport->auth.auth_mode == FC_AUTHMODE_UNKNOWN) {
-		i++;
-		if (i > 120)
-			return -ETIMEDOUT;
-		/* Delay for half of a second */
-		msleep(500);
-	}
-	return 0;
-}
-
-void
-lpfc_reauth_node(unsigned long ptr)
-{
-	struct lpfc_nodelist *ndlp = (struct lpfc_nodelist *) ptr;
-	struct lpfc_vport *vport = ndlp->vport;
-	struct lpfc_hba   *phba = vport->phba;
-	unsigned long flags;
-	struct lpfc_work_evt  *evtp = &ndlp->els_reauth_evt;
-
-	ndlp = (struct lpfc_nodelist *) ptr;
-	phba = ndlp->phba;
-
-	spin_lock_irqsave(&phba->hbalock, flags);
-	if (!list_empty(&evtp->evt_listp)) {
-		spin_unlock_irqrestore(&phba->hbalock, flags);
-		return;
-	}
-
-	/* We need to hold the node resource by incrementing the reference
-	 * count until this queued work is done
-	 */
-	evtp->evt_arg1 = lpfc_nlp_get(ndlp);
-	if (evtp->evt_arg1) {
-		evtp->evt = LPFC_EVT_REAUTH;
-		list_add_tail(&evtp->evt_listp, &phba->work_list);
-		lpfc_worker_wake_up(phba);
-	}
-	spin_unlock_irqrestore(&phba->hbalock, flags);
-	return;
-}
-
-void
-lpfc_reauthentication_handler(struct lpfc_nodelist *ndlp)
-{
-	struct lpfc_vport *vport = ndlp->vport;
-	if (vport->auth.auth_msg_state != LPFC_DHCHAP_SUCCESS)
-		return;
-
-	if (lpfc_start_node_authentication(ndlp)) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1029 Reauthentication Failure\n");
-		if (vport->auth.auth_state == LPFC_AUTH_SUCCESS)
-			lpfc_port_auth_failed(ndlp, LPFC_AUTH_FAIL);
-	}
-}
-
-/*
- * This function will kick start authentication for a node.
- * This is used for re-authentication of a node or a user
- * initiated node authentication.
- */
-int
-lpfc_start_node_authentication(struct lpfc_nodelist *ndlp)
-{
-	struct lpfc_vport *vport;
-	int ret;
-
-	vport = ndlp->vport;
-	/* If there is authentication timer cancel the timer */
-	del_timer_sync(&ndlp->nlp_reauth_tmr);
-	ret = lpfc_get_auth_config(vport, ndlp);
-	if (ret)
-		return ret;
-	ret = lpfc_security_config_wait(vport);
-	if (ret) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1032 Start Authentication: get config "
-				 "timed out.\n");
-		return ret;
-	}
-	return 0;
-}
-
-int
-lpfc_get_auth_config(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)
-{
-	struct fc_auth_req auth_req;
-	struct fc_auth_rsp *auth_rsp;
-	struct Scsi_Host   *shost;
-	int ret;
-
-	shost = lpfc_shost_from_vport(vport);
-
-	auth_req.local_wwpn = wwn_to_u64(vport->fc_portname.u.wwn);
-	if ((ndlp == NULL) || (ndlp->nlp_type & NLP_FABRIC))
-		auth_req.remote_wwpn = AUTH_FABRIC_WWN;
-	else
-		auth_req.remote_wwpn = wwn_to_u64(ndlp->nlp_portname.u.wwn);
-	if (vport->security_service_state == SECURITY_OFFLINE) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1053 Start Authentication: "
-				 "Security service offline.\n");
-		return -EINVAL;
-	}
-	auth_rsp = kmalloc(sizeof(struct fc_auth_rsp), GFP_KERNEL);
-	if (!auth_rsp) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1028 Start Authentication: No buffers\n");
-		return -ENOMEM;
-	}
-	vport->auth.auth_mode = FC_AUTHMODE_UNKNOWN;
-	ret = lpfc_fc_security_get_config(shost, &auth_req,
-					  sizeof(struct fc_auth_req),
-					  auth_rsp,
-					  sizeof(struct fc_auth_rsp));
-	if (ret) {
-		lpfc_printf_vlog(vport, KERN_ERR, LOG_SECURITY,
-				 "1031 Start Authentication: Get config "
-				 "failed.\n");
-		kfree(auth_rsp);
-		return ret;
-	}
-	return 0;
-}
--- a/drivers/scsi/lpfc/lpfc_security.h
+++ b/drivers/scsi/lpfc/lpfc_security.h
@@ -1,24 +0,0 @@
-/*******************************************************************
- * This file is part of the Emulex Linux Device Driver for         *
- * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2006-2007 Emulex.  All rights reserved.           *
- * EMULEX and SLI are trademarks of Emulex.                        *
- * www.emulex.com                                                  *
- *                                                                 *
- * This program is free software; you can redistribute it and/or   *
- * modify it under the terms of version 2 of the GNU General       *
- * Public License as published by the Free Software Foundation.    *
- * This program is distributed in the hope that it will be useful. *
- * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *
- * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *
- * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *
- * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *
- * TO BE LEGALLY INVALID.  See the GNU General Public License for  *
- * more details, a copy of which can be found in the file COPYING  *
- * included with this package.                                     *
- *******************************************************************/
-
-#define SECURITY_OFFLINE     0x0
-#define SECURITY_ONLINE      0x1
-
-#define SECURITY_WAIT_TMO    30	/* seconds to wait for the auth service */
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@ -761,10 +761,6 @@ lpfc_sli_iocb_cmd_type(uint8_t iocb_cmnd
 	case DSSCMD_IWRITE64_CX:
 	case DSSCMD_IREAD64_CR:
 	case DSSCMD_IREAD64_CX:
-	case DSSCMD_INVALIDATE_DEK:
-	case DSSCMD_SET_KEK:
-	case DSSCMD_GET_KEK_ID:
-	case DSSCMD_GEN_XFER:
 		type = LPFC_SOL_IOCB;
 		break;
 	case CMD_ABORT_XRI_CN:
@@ -6175,15 +6171,15 @@ __lpfc_sli_issue_iocb_s4(struct lpfc_hba
 	if (lpfc_sli4_iocb2wqe(phba, piocb, &wqe))
 		return IOCB_ERROR;
 
-	if (piocb->iocb_flag &  LPFC_IO_FCP) {
+	if ((piocb->iocb_flag & LPFC_IO_FCP) ||
+		(piocb->iocb_flag & LPFC_USE_FCPWQIDX)) {
 		/*
 		 * For FCP command IOCB, get a new WQ index to distribute
 		 * WQE across the WQsr. On the other hand, for abort IOCB,
 		 * it carries the same WQ index to the original command
 		 * IOCB.
 		 */
-		if ((piocb->iocb.ulpCommand != CMD_ABORT_XRI_CN) &&
-		    (piocb->iocb.ulpCommand != CMD_CLOSE_XRI_CN))
+		if (piocb->iocb_flag & LPFC_IO_FCP)
 			piocb->fcp_wqidx = lpfc_sli4_scmd_to_wqidx_distr(phba);
 		if (lpfc_sli4_wq_put(phba->sli4_hba.fcp_wq[piocb->fcp_wqidx],
 				     &wqe))
@@ -7187,6 +7183,8 @@ lpfc_sli_issue_abort_iotag(struct lpfc_h
 
 	/* ABTS WQE must go to the same WQ as the WQE to be aborted */
 	abtsiocbp->fcp_wqidx = cmdiocb->fcp_wqidx;
+	if (cmdiocb->iocb_flag & LPFC_IO_FCP)
+		abtsiocbp->iocb_flag |= LPFC_USE_FCPWQIDX;
 
 	if (phba->link_state >= LPFC_LINK_UP)
 		iabt->ulpCommand = CMD_ABORT_XRI_CN;
@@ -7393,6 +7391,8 @@ lpfc_sli_abort_iocb(struct lpfc_vport *v
 
 		/* ABTS WQE must go to the same WQ as the WQE to be aborted */
 		abtsiocb->fcp_wqidx = iocbq->fcp_wqidx;
+		if (iocbq->iocb_flag & LPFC_IO_FCP)
+			abtsiocb->iocb_flag |= LPFC_USE_FCPWQIDX;
 
 		if (lpfc_is_link_up(phba))
 			abtsiocb->iocb.ulpCommand = CMD_ABORT_XRI_CN;
--- a/drivers/scsi/lpfc/lpfc_sli.h
+++ b/drivers/scsi/lpfc/lpfc_sli.h
@@ -61,6 +61,7 @@ struct lpfc_iocbq {
 #define LPFC_IO_FABRIC		0x10	/* Iocb send using fabric scheduler */
 #define LPFC_DELAY_MEM_FREE	0x20    /* Defer free'ing of FC data */
 #define LPFC_EXCHANGE_BUSY	0x40    /* SLI4 hba reported XB in response */
+#define LPFC_USE_FCPWQIDX	0x80    /* Submit to specified FCPWQ index */
 
 #define LPFC_FIP_ELS_ID_MASK	0xc000	/* ELS_ID range 0-3, non-shifted mask */
 #define LPFC_FIP_ELS_ID_SHIFT	14
--- a/drivers/scsi/lpfc/lpfc_version.h
+++ b/drivers/scsi/lpfc/lpfc_version.h
@@ -18,7 +18,7 @@
  * included with this package.                                     *
  *******************************************************************/
 
-#define LPFC_DRIVER_VERSION "8.3.5.3"
+#define LPFC_DRIVER_VERSION "8.3.5.4"
 #define LPFC_DRIVER_NAME		"lpfc"
 #define LPFC_SP_DRIVER_HANDLER_NAME	"lpfc:sp"
 #define LPFC_FP_DRIVER_HANDLER_NAME	"lpfc:fp"
--- a/drivers/scsi/lpfc/lpfc_vport.c
+++ b/drivers/scsi/lpfc/lpfc_vport.c
@@ -1,7 +1,7 @@
 /*******************************************************************
  * This file is part of the Emulex Linux Device Driver for         *
  * Fibre Channel Host Bus Adapters.                                *
- * Copyright (C) 2004-2008 Emulex.  All rights reserved.           *
+ * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
  * EMULEX and SLI are trademarks of Emulex.                        *
  * www.emulex.com                                                  *
  * Portions Copyright (C) 2004-2005 Christoph Hellwig              *
@@ -44,7 +44,6 @@
 #include "lpfc_crtn.h"
 #include "lpfc_version.h"
 #include "lpfc_vport.h"
-#include "lpfc_auth_access.h"
 
 inline void lpfc_vport_set_state(struct lpfc_vport *vport,
 				 enum fc_vport_state new_state)
@@ -379,21 +378,6 @@ lpfc_vport_create(struct fc_vport *fc_vp
 		goto error_out;
 	}
 
-	shost = lpfc_shost_from_vport(vport);
-
-	if ((lpfc_get_security_enabled)(shost)) {
-		/* Triggers fcauthd to register if it is running */
-		fc_host_post_event(shost, fc_get_event_number(),
-				   FCH_EVT_PORT_ONLINE, shost->host_no);
-		spin_lock_irq(&fc_security_user_lock);
-		list_add_tail(&vport->sc_users, &fc_security_user_list);
-		spin_unlock_irq(&fc_security_user_lock);
-		if (fc_service_state == FC_SC_SERVICESTATE_ONLINE) {
-			lpfc_fc_queue_security_work(vport,
-				&vport->sc_online_work);
-		}
-	}
-
 	/* Create binary sysfs attribute for vport */
 	lpfc_alloc_sysfs_attr(vport);
 
--- a/drivers/scsi/lpfc/Makefile
+++ b/drivers/scsi/lpfc/Makefile
@@ -1,7 +1,7 @@
 #/*******************************************************************
 # * This file is part of the Emulex Linux Device Driver for         *
 # * Fibre Channel Host Bus Adapters.                                *
-# * Copyright (C) 2004-2009 Emulex.  All rights reserved.           *
+# * Copyright (C) 2004-2010 Emulex.  All rights reserved.           *
 # * EMULEX and SLI are trademarks of Emulex.                        *
 # * www.emulex.com                                                  *
 # *                                                                 *
@@ -28,5 +28,4 @@ obj-$(CONFIG_SCSI_LPFC) := lpfc.o
 
 lpfc-objs := lpfc_mem.o lpfc_sli.o lpfc_ct.o lpfc_els.o lpfc_hbadisc.o	\
 	lpfc_init.o lpfc_mbox.o lpfc_nportdisc.o lpfc_scsi.o lpfc_attr.o \
-	lpfc_vport.o lpfc_debugfs.o lpfc_security.o lpfc_auth_access.o \
-	lpfc_auth.o lpfc_bsg.o
+	lpfc_vport.o lpfc_debugfs.o lpfc_bsg.o
