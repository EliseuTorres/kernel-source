From: Dan Williams <dan.j.williams@intel.com>
Date: Wed, 29 Jun 2011 13:09:25 -0700
Subject: [PATCH 263/273] isci: unify isci_port and scic_sds_port
Git-commit: ffe191c92ff195d73f9130b1490045ca2dd4c5e0
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Remove the distinction between these two implementations and unify on
isci_port (local instances named iport).  The duplicate '->owning_port' and
'->isci_port' in both isci_phy and isci_remote_device will be fixed in a later
patch... this is just the straightforward rename/unification.

Reported-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/host.c          |   32 +-
 drivers/scsi/isci/host.h          |   11 +-
 drivers/scsi/isci/phy.c           |   10 +-
 drivers/scsi/isci/phy.h           |   10 +-
 drivers/scsi/isci/port.c          |  622 ++++++++++++++++++-------------------
 drivers/scsi/isci/port.h          |  174 +++--------
 drivers/scsi/isci/port_config.c   |   99 +++---
 drivers/scsi/isci/remote_device.c |   61 ++--
 drivers/scsi/isci/remote_device.h |   10 +-
 drivers/scsi/isci/request.c       |   33 +-
 10 files changed, 481 insertions(+), 581 deletions(-)

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index c5c2733..4e11f9e 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1054,9 +1054,9 @@ static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 
 	/* Start all of the ports on this controller */
 	for (index = 0; index < scic->logical_port_entries; index++) {
-		struct scic_sds_port *sci_port = &ihost->ports[index].sci;
+		struct isci_port *iport = &ihost->ports[index];
 
-		result = scic_sds_port_start(sci_port);
+		result = scic_sds_port_start(iport);
 		if (result)
 			return result;
 	}
@@ -1306,8 +1306,8 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	/* Cancel any/all outstanding port timers */
 	for (i = 0; i < ihost->sci.logical_port_entries; i++) {
-		struct scic_sds_port *sci_port = &ihost->ports[i].sci;
-		del_timer_sync(&sci_port->timer.timer);
+		struct isci_port *iport = &ihost->ports[i];
+		del_timer_sync(&iport->timer.timer);
 	}
 
 	/* Cancel any/all outstanding phy timers */
@@ -1552,9 +1552,9 @@ static enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller
 	struct isci_host *ihost = scic_to_ihost(scic);
 
 	for (index = 0; index < scic->logical_port_entries; index++) {
-		struct scic_sds_port *sci_port = &ihost->ports[index].sci;
+		struct isci_port *iport = &ihost->ports[index];
 
-		port_status = scic_sds_port_stop(sci_port);
+		port_status = scic_sds_port_stop(iport);
 
 		if ((port_status != SCI_SUCCESS) &&
 		    (port_status != SCI_FAILURE_INVALID_STATE)) {
@@ -1564,7 +1564,7 @@ static enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller
 				 "%s: Controller stop operation failed to "
 				 "stop port %d because of status %d.\n",
 				 __func__,
-				 sci_port->logical_port_index,
+				 iport->logical_port_index,
 				 port_status);
 		}
 	}
@@ -1780,14 +1780,14 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 
 	/* Construct the ports for this controller */
 	for (i = 0; i < SCI_MAX_PORTS; i++)
-		scic_sds_port_construct(&ihost->ports[i].sci, i, scic);
-	scic_sds_port_construct(&ihost->ports[i].sci, SCIC_SDS_DUMMY_PORT, scic);
+		scic_sds_port_construct(&ihost->ports[i], i, scic);
+	scic_sds_port_construct(&ihost->ports[i], SCIC_SDS_DUMMY_PORT, scic);
 
 	/* Construct the phys for this controller */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
 		/* Add all the PHYs to the dummy port */
 		scic_sds_phy_construct(&ihost->phys[i],
-				       &ihost->ports[SCI_MAX_PORTS].sci, i);
+				       &ihost->ports[SCI_MAX_PORTS], i);
 	}
 
 	scic->invalid_phy_mask = 0;
@@ -2233,7 +2233,7 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 	}
 
 	for (i = 0; i < scic->logical_port_entries; i++) {
-		result = scic_sds_port_initialize(&ihost->ports[i].sci,
+		result = scic_sds_port_initialize(&ihost->ports[i],
 						  &scic->scu_registers->peg0.ptsg.port[i],
 						  &scic->scu_registers->peg0.ptsg.protocol_engine,
 						  &scic->scu_registers->peg0.viit[i]);
@@ -2484,19 +2484,19 @@ int isci_host_init(struct isci_host *isci_host)
 }
 
 void scic_sds_controller_link_up(struct scic_sds_controller *scic,
-		struct scic_sds_port *port, struct isci_phy *iphy)
+		struct isci_port *iport, struct isci_phy *iphy)
 {
 	switch (scic->sm.current_state_id) {
 	case SCIC_STARTING:
 		sci_del_timer(&scic->phy_timer);
 		scic->phy_startup_timer_pending = false;
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
-						 port, iphy);
+						 iport, iphy);
 		scic_sds_controller_start_next_phy(scic);
 		break;
 	case SCIC_READY:
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
-						 port, iphy);
+						 iport, iphy);
 		break;
 	default:
 		dev_dbg(scic_to_dev(scic),
@@ -2507,13 +2507,13 @@ void scic_sds_controller_link_up(struct scic_sds_controller *scic,
 }
 
 void scic_sds_controller_link_down(struct scic_sds_controller *scic,
-		struct scic_sds_port *port, struct isci_phy *iphy)
+		struct isci_port *iport, struct isci_phy *iphy)
 {
 	switch (scic->sm.current_state_id) {
 	case SCIC_STARTING:
 	case SCIC_READY:
 		scic->port_agent.link_down_handler(scic, &scic->port_agent,
-						   port, iphy);
+						   iport, iphy);
 		break;
 	default:
 		dev_dbg(scic_to_dev(scic),
diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 1edd135..fb8048e 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -108,7 +108,7 @@ struct scic_power_control {
 struct scic_sds_port_configuration_agent;
 typedef void (*port_config_fn)(struct scic_sds_controller *,
 			       struct scic_sds_port_configuration_agent *,
-			       struct scic_sds_port *, struct isci_phy *);
+			       struct isci_port *, struct isci_phy *);
 
 struct scic_sds_port_configuration_agent {
 	u16 phy_configured_mask;
@@ -532,9 +532,8 @@ static inline struct device *sciphy_to_dev(struct isci_phy *iphy)
 	return &iphy->isci_port->isci_host->pdev->dev;
 }
 
-static inline struct device *sciport_to_dev(struct scic_sds_port *sci_port)
+static inline struct device *sciport_to_dev(struct isci_port *iport)
 {
-	struct isci_port *iport = sci_port_to_iport(sci_port);
 
 	if (!iport || !iport->isci_host)
 		return NULL;
@@ -613,12 +612,12 @@ void scic_sds_controller_power_control_queue_remove(
 
 void scic_sds_controller_link_up(
 	struct scic_sds_controller *scic,
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy);
 
 void scic_sds_controller_link_down(
 	struct scic_sds_controller *scic,
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy);
 
 void scic_sds_controller_remote_device_stopped(
@@ -649,7 +648,7 @@ void isci_host_deinit(
 
 void isci_host_port_link_up(
 	struct isci_host *,
-	struct scic_sds_port *,
+	struct isci_port *,
 	struct isci_phy *);
 int isci_host_dev_found(struct domain_device *);
 
diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 0e60fb7..fd0e973 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -286,7 +286,7 @@ done:
  * port (i.e. it's contained in the dummy port). !NULL All other
  * values indicate a handle/pointer to the port containing the phy.
  */
-struct scic_sds_port *phy_get_non_dummy_port(
+struct isci_port *phy_get_non_dummy_port(
 	struct isci_phy *iphy)
 {
 	if (scic_sds_port_get_index(iphy->owning_port) == SCIC_SDS_DUMMY_PORT)
@@ -304,9 +304,9 @@ struct scic_sds_port *phy_get_non_dummy_port(
  */
 void scic_sds_phy_set_port(
 	struct isci_phy *iphy,
-	struct scic_sds_port *sci_port)
+	struct isci_port *iport)
 {
-	iphy->owning_port = sci_port;
+	iphy->owning_port = iport;
 
 	if (iphy->bcn_received_while_port_unassigned) {
 		iphy->bcn_received_while_port_unassigned = false;
@@ -1291,12 +1291,12 @@ static const struct sci_base_state scic_sds_phy_state_table[] = {
 };
 
 void scic_sds_phy_construct(struct isci_phy *iphy,
-			    struct scic_sds_port *owning_port, u8 phy_index)
+			    struct isci_port *iport, u8 phy_index)
 {
 	sci_init_sm(&iphy->sm, scic_sds_phy_state_table, SCI_PHY_INITIAL);
 
 	/* Copy the rest of the input data to our locals */
-	iphy->owning_port = owning_port;
+	iphy->owning_port = iport;
 	iphy->phy_index = phy_index;
 	iphy->bcn_received_while_port_unassigned = false;
 	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
diff --git a/drivers/scsi/isci/phy.h b/drivers/scsi/isci/phy.h
index 345fbea..19aa444 100644
--- a/drivers/scsi/isci/phy.h
+++ b/drivers/scsi/isci/phy.h
@@ -93,7 +93,7 @@ enum scic_sds_phy_protocol {
  */
 struct isci_phy {
 	struct sci_base_state_machine sm;
-	struct scic_sds_port *owning_port;
+	struct isci_port *owning_port;
 	enum sas_linkrate max_negotiated_speed;
 	enum scic_sds_phy_protocol protocol;
 	u8 phy_index;
@@ -178,7 +178,7 @@ struct scic_phy_properties {
 	 * supplied phy.  This field may be set to NULL
 	 * if the phy is not currently contained in a port.
 	 */
-	struct scic_sds_port *owning_port;
+	struct isci_port *iport;
 
 	/**
 	 * This field specifies the link rate at which the phy is
@@ -459,14 +459,14 @@ enum scic_sds_phy_states {
 
 void scic_sds_phy_construct(
 	struct isci_phy *iphy,
-	struct scic_sds_port *owning_port,
+	struct isci_port *iport,
 	u8 phy_index);
 
-struct scic_sds_port *phy_get_non_dummy_port(struct isci_phy *iphy);
+struct isci_port *phy_get_non_dummy_port(struct isci_phy *iphy);
 
 void scic_sds_phy_set_port(
 	struct isci_phy *iphy,
-	struct scic_sds_port *owning_port);
+	struct isci_port *iport);
 
 enum sci_status scic_sds_phy_initialize(
 	struct isci_phy *iphy,
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index d53c0b1..0459188 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -83,7 +83,7 @@ static void isci_port_change_state(struct isci_port *iport, enum isci_status sta
  *    transmit_identification register.
  */
 static void
-scic_sds_port_get_protocols(struct scic_sds_port *sci_port,
+scic_sds_port_get_protocols(struct isci_port *iport,
 			    struct scic_phy_proto *protocols)
 {
 	u8 index;
@@ -91,8 +91,8 @@ scic_sds_port_get_protocols(struct scic_sds_port *sci_port,
 	protocols->all = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
-			scic_sds_phy_get_protocols(sci_port->phy_table[index],
+		if (iport->phy_table[index] != NULL) {
+			scic_sds_phy_get_protocols(iport->phy_table[index],
 						   protocols);
 		}
 	}
@@ -107,7 +107,7 @@ scic_sds_port_get_protocols(struct scic_sds_port *sci_port,
  * Return a bit mask indicating which phys are a part of this port. Each bit
  * corresponds to a phy identifier (e.g. bit 0 = phy id 0).
  */
-static u32 scic_sds_port_get_phys(struct scic_sds_port *sci_port)
+static u32 scic_sds_port_get_phys(struct isci_port *iport)
 {
 	u32 index;
 	u32 mask;
@@ -115,7 +115,7 @@ static u32 scic_sds_port_get_phys(struct scic_sds_port *sci_port)
 	mask = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
+		if (iport->phy_table[index] != NULL) {
 			mask |= (1 << index);
 		}
 	}
@@ -136,30 +136,29 @@ static u32 scic_sds_port_get_phys(struct scic_sds_port *sci_port)
  * value is returned if the specified port is not valid.  When this value is
  * returned, no data is copied to the properties output parameter.
  */
-static enum sci_status scic_port_get_properties(struct scic_sds_port *port,
+static enum sci_status scic_port_get_properties(struct isci_port *iport,
 						struct scic_port_properties *prop)
 {
-	if ((port == NULL) ||
-	    (port->logical_port_index == SCIC_SDS_DUMMY_PORT))
+	if (!iport || iport->logical_port_index == SCIC_SDS_DUMMY_PORT)
 		return SCI_FAILURE_INVALID_PORT;
 
-	prop->index    = port->logical_port_index;
-	prop->phy_mask = scic_sds_port_get_phys(port);
-	scic_sds_port_get_sas_address(port, &prop->local.sas_address);
-	scic_sds_port_get_protocols(port, &prop->local.protocols);
-	scic_sds_port_get_attached_sas_address(port, &prop->remote.sas_address);
+	prop->index    = iport->logical_port_index;
+	prop->phy_mask = scic_sds_port_get_phys(iport);
+	scic_sds_port_get_sas_address(iport, &prop->local.sas_address);
+	scic_sds_port_get_protocols(iport, &prop->local.protocols);
+	scic_sds_port_get_attached_sas_address(iport, &prop->remote.sas_address);
 
 	return SCI_SUCCESS;
 }
 
-static void scic_port_bcn_enable(struct scic_sds_port *sci_port)
+static void scic_port_bcn_enable(struct isci_port *iport)
 {
 	struct isci_phy *iphy;
 	u32 val;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(sci_port->phy_table); i++) {
-		iphy = sci_port->phy_table[i];
+	for (i = 0; i < ARRAY_SIZE(iport->phy_table); i++) {
+		iphy = iport->phy_table[i];
 		if (!iphy)
 			continue;
 		val = readl(&iphy->link_layer_registers->link_layer_control);
@@ -179,8 +178,8 @@ void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
 	if (!test_and_clear_bit(IPORT_BCN_PENDING, &iport->flags))
 		return;
 
-	for (i = 0; i < ARRAY_SIZE(iport->sci.phy_table); i++) {
-		struct isci_phy *iphy = iport->sci.phy_table[i];
+	for (i = 0; i < ARRAY_SIZE(iport->phy_table); i++) {
+		struct isci_phy *iphy = iport->phy_table[i];
 
 		if (!iphy)
 			continue;
@@ -191,12 +190,10 @@ void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
 	}
 }
 
-void isci_port_bc_change_received(struct isci_host *ihost,
-				  struct scic_sds_port *sci_port,
-				  struct isci_phy *iphy)
+static void isci_port_bc_change_received(struct isci_host *ihost,
+					 struct isci_port *iport,
+					 struct isci_phy *iphy)
 {
-	struct isci_port *iport = iphy->isci_port;
-
 	if (iport && test_bit(IPORT_BCN_BLOCKED, &iport->flags)) {
 		dev_dbg(&ihost->pdev->dev,
 			"%s: disabled BCN; isci_phy = %p, sas_phy = %p\n",
@@ -212,31 +209,30 @@ void isci_port_bc_change_received(struct isci_host *ihost,
 		ihost->sas_ha.notify_port_event(&iphy->sas_phy,
 						PORTE_BROADCAST_RCVD);
 	}
-	scic_port_bcn_enable(sci_port);
+	scic_port_bcn_enable(iport);
 }
 
 static void isci_port_link_up(struct isci_host *isci_host,
-			      struct scic_sds_port *port,
+			      struct isci_port *iport,
 			      struct isci_phy *iphy)
 {
 	unsigned long flags;
 	struct scic_port_properties properties;
-	struct isci_port *isci_port = sci_port_to_iport(port);
 	unsigned long success = true;
 
 	BUG_ON(iphy->isci_port != NULL);
 
-	iphy->isci_port = isci_port;
+	iphy->isci_port = iport;
 
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n",
-		__func__, isci_port);
+		__func__, iport);
 
 	spin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);
 
 	isci_port_change_state(iphy->isci_port, isci_starting);
 
-	scic_port_get_properties(port, &properties);
+	scic_port_get_properties(iport, &properties);
 
 	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
 		u64 attached_sas_address;
@@ -370,7 +366,7 @@ static void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *i
 }
 
 static void isci_port_stop_complete(struct scic_sds_controller *scic,
-				    struct scic_sds_port *sci_port,
+				    struct isci_port *iport,
 				    enum sci_status completion_status)
 {
 	dev_dbg(&scic_to_ihost(scic)->pdev->dev, "Port stop complete\n");
@@ -408,30 +404,30 @@ static void isci_port_hard_reset_complete(struct isci_port *isci_port,
  * assignment for the port false if this is not a valid phy assignment for the
  * port
  */
-bool scic_sds_port_is_valid_phy_assignment(struct scic_sds_port *sci_port,
+bool scic_sds_port_is_valid_phy_assignment(struct isci_port *iport,
 					   u32 phy_index)
 {
 	/* Initialize to invalid value. */
 	u32 existing_phy_index = SCI_MAX_PHYS;
 	u32 index;
 
-	if ((sci_port->physical_port_index == 1) && (phy_index != 1)) {
+	if ((iport->physical_port_index == 1) && (phy_index != 1)) {
 		return false;
 	}
 
-	if (sci_port->physical_port_index == 3 && phy_index != 3) {
+	if (iport->physical_port_index == 3 && phy_index != 3) {
 		return false;
 	}
 
 	if (
-		(sci_port->physical_port_index == 2)
+		(iport->physical_port_index == 2)
 		&& ((phy_index == 0) || (phy_index == 1))
 		) {
 		return false;
 	}
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if ((sci_port->phy_table[index] != NULL)
+		if ((iport->phy_table[index] != NULL)
 		    && (index != phy_index)) {
 			existing_phy_index = index;
 		}
@@ -442,9 +438,9 @@ bool scic_sds_port_is_valid_phy_assignment(struct scic_sds_port *sci_port,
 	 * operating at the same maximum link rate. */
 	if (
 		(existing_phy_index < SCI_MAX_PHYS)
-		&& (sci_port->owning_controller->user_parameters.sds1.phys[
+		&& (iport->owning_controller->user_parameters.sds1.phys[
 			    phy_index].max_speed_generation !=
-		    sci_port->owning_controller->user_parameters.sds1.phys[
+		    iport->owning_controller->user_parameters.sds1.phys[
 			    existing_phy_index].max_speed_generation)
 		)
 		return false;
@@ -465,25 +461,25 @@ bool scic_sds_port_is_valid_phy_assignment(struct scic_sds_port *sci_port,
  * port false if this is not a valid phy assignment for the port
  */
 static bool scic_sds_port_is_phy_mask_valid(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	u32 phy_mask)
 {
-	if (sci_port->physical_port_index == 0) {
+	if (iport->physical_port_index == 0) {
 		if (((phy_mask & 0x0F) == 0x0F)
 		    || ((phy_mask & 0x03) == 0x03)
 		    || ((phy_mask & 0x01) == 0x01)
 		    || (phy_mask == 0))
 			return true;
-	} else if (sci_port->physical_port_index == 1) {
+	} else if (iport->physical_port_index == 1) {
 		if (((phy_mask & 0x02) == 0x02)
 		    || (phy_mask == 0))
 			return true;
-	} else if (sci_port->physical_port_index == 2) {
+	} else if (iport->physical_port_index == 2) {
 		if (((phy_mask & 0x0C) == 0x0C)
 		    || ((phy_mask & 0x04) == 0x04)
 		    || (phy_mask == 0))
 			return true;
-	} else if (sci_port->physical_port_index == 3) {
+	} else if (iport->physical_port_index == 3) {
 		if (((phy_mask & 0x08) == 0x08)
 		    || (phy_mask == 0))
 			return true;
@@ -500,7 +496,7 @@ static bool scic_sds_port_is_phy_mask_valid(
  * point) phys contained in the port. All other values specify a struct scic_sds_phy
  * object that is active in the port.
  */
-static struct isci_phy *scic_sds_port_get_a_connected_phy(struct scic_sds_port *sci_port)
+static struct isci_phy *scic_sds_port_get_a_connected_phy(struct isci_port *iport)
 {
 	u32 index;
 	struct isci_phy *iphy;
@@ -509,29 +505,29 @@ static struct isci_phy *scic_sds_port_get_a_connected_phy(struct scic_sds_port *
 		/* Ensure that the phy is both part of the port and currently
 		 * connected to the remote end-point.
 		 */
-		iphy = sci_port->phy_table[index];
-		if (iphy && scic_sds_port_active_phy(sci_port, iphy))
+		iphy = iport->phy_table[index];
+		if (iphy && scic_sds_port_active_phy(iport, iphy))
 			return iphy;
 	}
 
 	return NULL;
 }
 
-static enum sci_status scic_sds_port_set_phy(struct scic_sds_port *port, struct isci_phy *iphy)
+static enum sci_status scic_sds_port_set_phy(struct isci_port *iport, struct isci_phy *iphy)
 {
 	/* Check to see if we can add this phy to a port
 	 * that means that the phy is not part of a port and that the port does
 	 * not already have a phy assinged to the phy index.
 	 */
-	if (!port->phy_table[iphy->phy_index] &&
+	if (!iport->phy_table[iphy->phy_index] &&
 	    !phy_get_non_dummy_port(iphy) &&
-	    scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index)) {
+	    scic_sds_port_is_valid_phy_assignment(iport, iphy->phy_index)) {
 		/* Phy is being added in the stopped state so we are in MPC mode
 		 * make logical port index = physical port index
 		 */
-		port->logical_port_index = port->physical_port_index;
-		port->phy_table[iphy->phy_index] = iphy;
-		scic_sds_phy_set_port(iphy, port);
+		iport->logical_port_index = iport->physical_port_index;
+		iport->phy_table[iphy->phy_index] = iphy;
+		scic_sds_phy_set_port(iphy, iport);
 
 		return SCI_SUCCESS;
 	}
@@ -539,18 +535,18 @@ static enum sci_status scic_sds_port_set_phy(struct scic_sds_port *port, struct
 	return SCI_FAILURE;
 }
 
-static enum sci_status scic_sds_port_clear_phy(struct scic_sds_port *port,
+static enum sci_status scic_sds_port_clear_phy(struct isci_port *iport,
 					       struct isci_phy *iphy)
 {
 	/* Make sure that this phy is part of this port */
-	if (port->phy_table[iphy->phy_index] == iphy &&
-	    phy_get_non_dummy_port(iphy) == port) {
-		struct scic_sds_controller *scic = port->owning_controller;
+	if (iport->phy_table[iphy->phy_index] == iphy &&
+	    phy_get_non_dummy_port(iphy) == iport) {
+		struct scic_sds_controller *scic = iport->owning_controller;
 		struct isci_host *ihost = scic_to_ihost(scic);
 
 		/* Yep it is assigned to this port so remove it */
-		scic_sds_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS].sci);
-		port->phy_table[iphy->phy_index] = NULL;
+		scic_sds_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS]);
+		iport->phy_table[iphy->phy_index] = NULL;
 		return SCI_SUCCESS;
 	}
 
@@ -568,7 +564,7 @@ static enum sci_status scic_sds_port_clear_phy(struct scic_sds_port *port,
  *
  */
 void scic_sds_port_get_sas_address(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct sci_sas_address *sas_address)
 {
 	u32 index;
@@ -577,8 +573,8 @@ void scic_sds_port_get_sas_address(
 	sas_address->low  = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
-			scic_sds_phy_get_sas_address(sci_port->phy_table[index], sas_address);
+		if (iport->phy_table[index] != NULL) {
+			scic_sds_phy_get_sas_address(iport->phy_table[index], sas_address);
 		}
 	}
 }
@@ -594,7 +590,7 @@ void scic_sds_port_get_sas_address(
  *
  */
 void scic_sds_port_get_attached_sas_address(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct sci_sas_address *sas_address)
 {
 	struct isci_phy *iphy;
@@ -603,7 +599,7 @@ void scic_sds_port_get_attached_sas_address(
 	 * Ensure that the phy is both part of the port and currently
 	 * connected to the remote end-point.
 	 */
-	iphy = scic_sds_port_get_a_connected_phy(sci_port);
+	iphy = scic_sds_port_get_a_connected_phy(iport);
 	if (iphy) {
 		if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
 			scic_sds_phy_get_attached_sas_address(iphy,
@@ -628,11 +624,11 @@ void scic_sds_port_get_attached_sas_address(
  * This structure will be posted to the hardware to work around a scheduler
  * error in the hardware.
  */
-static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u16 rni)
+static void scic_sds_port_construct_dummy_rnc(struct isci_port *iport, u16 rni)
 {
 	union scu_remote_node_context *rnc;
 
-	rnc = &sci_port->owning_controller->remote_node_context_table[rni];
+	rnc = &iport->owning_controller->remote_node_context_table[rni];
 
 	memset(rnc, 0, sizeof(union scu_remote_node_context));
 
@@ -641,7 +637,7 @@ static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u1
 
 	rnc->ssp.remote_node_index = rni;
 	rnc->ssp.remote_node_port_width = 1;
-	rnc->ssp.logical_port_index = sci_port->physical_port_index;
+	rnc->ssp.logical_port_index = iport->physical_port_index;
 
 	rnc->ssp.nexus_loss_timer_enable = false;
 	rnc->ssp.check_bit = false;
@@ -656,9 +652,9 @@ static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u1
  * structure will be posted to the hardwre to work around a scheduler error
  * in the hardware.
  */
-static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u16 tag)
+static void scic_sds_port_construct_dummy_task(struct isci_port *iport, u16 tag)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct scu_task_context *task_context;
 
 	task_context = &scic->task_context_table[ISCI_TAG_TCI(tag)];
@@ -666,29 +662,29 @@ static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u
 
 	task_context->initiator_request = 1;
 	task_context->connection_rate = 1;
-	task_context->logical_port_index = sci_port->physical_port_index;
+	task_context->logical_port_index = iport->physical_port_index;
 	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;
 	task_context->task_index = ISCI_TAG_TCI(tag);
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
-	task_context->remote_node_index = sci_port->reserved_rni;
+	task_context->remote_node_index = iport->reserved_rni;
 	task_context->do_not_dma_ssp_good_response = 1;
 	task_context->task_phase = 0x01;
 }
 
-static void scic_sds_port_destroy_dummy_resources(struct scic_sds_port *sci_port)
+static void scic_sds_port_destroy_dummy_resources(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 
-	if (sci_port->reserved_tag != SCI_CONTROLLER_INVALID_IO_TAG)
-		isci_free_tag(scic_to_ihost(scic), sci_port->reserved_tag);
+	if (iport->reserved_tag != SCI_CONTROLLER_INVALID_IO_TAG)
+		isci_free_tag(scic_to_ihost(scic), iport->reserved_tag);
 
-	if (sci_port->reserved_rni != SCU_DUMMY_INDEX)
+	if (iport->reserved_rni != SCU_DUMMY_INDEX)
 		scic_sds_remote_node_table_release_remote_node_index(&scic->available_remote_nodes,
-								     1, sci_port->reserved_rni);
+								     1, iport->reserved_rni);
 
-	sci_port->reserved_rni = SCU_DUMMY_INDEX;
-	sci_port->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
+	iport->reserved_rni = SCU_DUMMY_INDEX;
+	iport->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
 }
 
 /**
@@ -704,14 +700,14 @@ static void scic_sds_port_destroy_dummy_resources(struct scic_sds_port *sci_port
  * if the phy being added to the port
  */
 enum sci_status scic_sds_port_initialize(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	void __iomem *port_task_scheduler_registers,
 	void __iomem *port_configuration_regsiter,
 	void __iomem *viit_registers)
 {
-	sci_port->port_task_scheduler_registers  = port_task_scheduler_registers;
-	sci_port->port_pe_configuration_register = port_configuration_regsiter;
-	sci_port->viit_registers                 = viit_registers;
+	iport->port_task_scheduler_registers  = port_task_scheduler_registers;
+	iport->port_pe_configuration_register = port_configuration_regsiter;
+	iport->viit_registers                 = viit_registers;
 
 	return SCI_SUCCESS;
 }
@@ -720,20 +716,20 @@ enum sci_status scic_sds_port_initialize(
 /**
  * This method assigns the direct attached device ID for this port.
  *
- * @param[in] sci_port The port for which the direct attached device id is to
+ * @param[in] iport The port for which the direct attached device id is to
  *       be assigned.
  * @param[in] device_id The direct attached device ID to assign to the port.
  *       This will be the RNi for the device
  */
 void scic_sds_port_setup_transports(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	u32 device_id)
 {
 	u8 index;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->active_phy_mask & (1 << index))
-			scic_sds_phy_setup_transport(sci_port->phy_table[index], device_id);
+		if (iport->active_phy_mask & (1 << index))
+			scic_sds_phy_setup_transport(iport->phy_table[index], device_id);
 	}
 }
 
@@ -749,39 +745,38 @@ void scic_sds_port_setup_transports(
  * the phy to the port - enabling the Protocol Engine in the silicon. -
  * notifying the user that the link is up. none
  */
-static void scic_sds_port_activate_phy(struct scic_sds_port *sci_port,
+static void scic_sds_port_activate_phy(struct isci_port *iport,
 				       struct isci_phy *iphy,
 				       bool do_notify_user)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 
 	if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
 		scic_sds_phy_resume(iphy);
 
-	sci_port->active_phy_mask |= 1 << iphy->phy_index;
+	iport->active_phy_mask |= 1 << iphy->phy_index;
 
 	scic_sds_controller_clear_invalid_phy(scic, iphy);
 
 	if (do_notify_user == true)
-		isci_port_link_up(ihost, sci_port, iphy);
+		isci_port_link_up(ihost, iport, iphy);
 }
 
-void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
+void scic_sds_port_deactivate_phy(struct isci_port *iport,
 				  struct isci_phy *iphy,
 				  bool do_notify_user)
 {
-	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
+	struct scic_sds_controller *scic = scic_sds_port_get_controller(iport);
 	struct isci_host *ihost = scic_to_ihost(scic);
 
-	sci_port->active_phy_mask &= ~(1 << iphy->phy_index);
+	iport->active_phy_mask &= ~(1 << iphy->phy_index);
 
 	iphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
 
 	/* Re-assign the phy back to the LP as if it were a narrow port */
 	writel(iphy->phy_index,
-		&sci_port->port_pe_configuration_register[iphy->phy_index]);
+		&iport->port_pe_configuration_register[iphy->phy_index]);
 
 	if (do_notify_user == true)
 		isci_port_link_down(ihost, iphy, iport);
@@ -795,10 +790,10 @@ void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
  * This function will disable the phy and report that the phy is not valid for
  * this port object. None
  */
-static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
+static void scic_sds_port_invalid_link_up(struct isci_port *iport,
 					  struct isci_phy *iphy)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 
 	/*
 	 * Check to see if we have alreay reported this link as bad and if
@@ -825,17 +820,17 @@ static bool is_port_ready_state(enum scic_sds_port_states state)
 }
 
 /* flag dummy rnc hanling when exiting a ready state */
-static void port_state_machine_change(struct scic_sds_port *sci_port,
+static void port_state_machine_change(struct isci_port *iport,
 				      enum scic_sds_port_states state)
 {
-	struct sci_base_state_machine *sm = &sci_port->sm;
+	struct sci_base_state_machine *sm = &iport->sm;
 	enum scic_sds_port_states old_state = sm->current_state_id;
 
 	if (is_port_ready_state(old_state) && !is_port_ready_state(state))
-		sci_port->ready_exit = true;
+		iport->ready_exit = true;
 
 	sci_change_state(sm, state);
-	sci_port->ready_exit = false;
+	iport->ready_exit = false;
 }
 
 /**
@@ -851,14 +846,14 @@ static void port_state_machine_change(struct scic_sds_port *sci_port,
  * part of a port if it's attached SAS ADDRESS is the same as all other PHYs in
  * the same port. none
  */
-static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port,
+static void scic_sds_port_general_link_up_handler(struct isci_port *iport,
 						  struct isci_phy *iphy,
 						  bool do_notify_user)
 {
 	struct sci_sas_address port_sas_address;
 	struct sci_sas_address phy_sas_address;
 
-	scic_sds_port_get_attached_sas_address(sci_port, &port_sas_address);
+	scic_sds_port_get_attached_sas_address(iport, &port_sas_address);
 	scic_sds_phy_get_attached_sas_address(iphy, &phy_sas_address);
 
 	/* If the SAS address of the new phy matches the SAS address of
@@ -868,14 +863,14 @@ static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port
 	 */
 	if ((phy_sas_address.high == port_sas_address.high &&
 	     phy_sas_address.low  == port_sas_address.low) ||
-	    sci_port->active_phy_mask == 0) {
-		struct sci_base_state_machine *sm = &sci_port->sm;
+	    iport->active_phy_mask == 0) {
+		struct sci_base_state_machine *sm = &iport->sm;
 
-		scic_sds_port_activate_phy(sci_port, iphy, do_notify_user);
+		scic_sds_port_activate_phy(iport, iphy, do_notify_user);
 		if (sm->current_state_id == SCI_PORT_RESETTING)
-			port_state_machine_change(sci_port, SCI_PORT_READY);
+			port_state_machine_change(iport, SCI_PORT_READY);
 	} else
-		scic_sds_port_invalid_link_up(sci_port, iphy);
+		scic_sds_port_invalid_link_up(iport, iphy);
 }
 
 
@@ -889,13 +884,13 @@ static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port
  * bool true Is returned if this is a wide ported port. false Is returned if
  * this is a narrow port.
  */
-static bool scic_sds_port_is_wide(struct scic_sds_port *sci_port)
+static bool scic_sds_port_is_wide(struct isci_port *iport)
 {
 	u32 index;
 	u32 phy_count = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
+		if (iport->phy_table[index] != NULL) {
 			phy_count++;
 		}
 	}
@@ -918,13 +913,13 @@ static bool scic_sds_port_is_wide(struct scic_sds_port *sci_port)
  * devices this could become an invalid port configuration.
  */
 bool scic_sds_port_link_detected(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
-	if ((sci_port->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
+	if ((iport->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
 	    (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
-	    scic_sds_port_is_wide(sci_port)) {
-		scic_sds_port_invalid_link_up(sci_port, iphy);
+	    scic_sds_port_is_wide(iport)) {
+		scic_sds_port_invalid_link_up(iport, iphy);
 
 		return false;
 	}
@@ -935,8 +930,8 @@ bool scic_sds_port_link_detected(
 static void port_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
-	struct scic_sds_port *sci_port = container_of(tmr, typeof(*sci_port), timer);
-	struct isci_host *ihost = scic_to_ihost(sci_port->owning_controller);
+	struct isci_port *iport = container_of(tmr, typeof(*iport), timer);
+	struct isci_host *ihost = scic_to_ihost(iport->owning_controller);
 	unsigned long flags;
 	u32 current_state;
 
@@ -945,33 +940,33 @@ static void port_timeout(unsigned long data)
 	if (tmr->cancel)
 		goto done;
 
-	current_state = sci_port->sm.current_state_id;
+	current_state = iport->sm.current_state_id;
 
 	if (current_state == SCI_PORT_RESETTING) {
 		/* if the port is still in the resetting state then the timeout
 		 * fired before the reset completed.
 		 */
-		port_state_machine_change(sci_port, SCI_PORT_FAILED);
+		port_state_machine_change(iport, SCI_PORT_FAILED);
 	} else if (current_state == SCI_PORT_STOPPED) {
 		/* if the port is stopped then the start request failed In this
 		 * case stay in the stopped state.
 		 */
-		dev_err(sciport_to_dev(sci_port),
+		dev_err(sciport_to_dev(iport),
 			"%s: SCIC Port 0x%p failed to stop before tiemout.\n",
 			__func__,
-			sci_port);
+			iport);
 	} else if (current_state == SCI_PORT_STOPPING) {
 		/* if the port is still stopping then the stop has not completed */
-		isci_port_stop_complete(sci_port->owning_controller,
-					sci_port,
+		isci_port_stop_complete(iport->owning_controller,
+					iport,
 					SCI_FAILURE_TIMEOUT);
 	} else {
 		/* The port is in the ready state and we have a timer
 		 * reporting a timeout this should not happen.
 		 */
-		dev_err(sciport_to_dev(sci_port),
+		dev_err(sciport_to_dev(iport),
 			"%s: SCIC Port 0x%p is processing a timeout operation "
-			"in state %d.\n", __func__, sci_port, current_state);
+			"in state %d.\n", __func__, iport, current_state);
 	}
 
 done:
@@ -985,29 +980,29 @@ done:
  *
  *
  */
-static void scic_sds_port_update_viit_entry(struct scic_sds_port *sci_port)
+static void scic_sds_port_update_viit_entry(struct isci_port *iport)
 {
 	struct sci_sas_address sas_address;
 
-	scic_sds_port_get_sas_address(sci_port, &sas_address);
+	scic_sds_port_get_sas_address(iport, &sas_address);
 
 	writel(sas_address.high,
-		&sci_port->viit_registers->initiator_sas_address_hi);
+		&iport->viit_registers->initiator_sas_address_hi);
 	writel(sas_address.low,
-		&sci_port->viit_registers->initiator_sas_address_lo);
+		&iport->viit_registers->initiator_sas_address_lo);
 
 	/* This value get cleared just in case its not already cleared */
-	writel(0, &sci_port->viit_registers->reserved);
+	writel(0, &iport->viit_registers->reserved);
 
 	/* We are required to update the status register last */
 	writel(SCU_VIIT_ENTRY_ID_VIIT |
 	       SCU_VIIT_IPPT_INITIATOR |
-	       ((1 << sci_port->physical_port_index) << SCU_VIIT_ENTRY_LPVIE_SHIFT) |
+	       ((1 << iport->physical_port_index) << SCU_VIIT_ENTRY_LPVIE_SHIFT) |
 	       SCU_VIIT_STATUS_ALL_VALID,
-	       &sci_port->viit_registers->status);
+	       &iport->viit_registers->status);
 }
 
-enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct scic_sds_port *sci_port)
+enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct isci_port *iport)
 {
 	u16 index;
 	struct isci_phy *iphy;
@@ -1017,8 +1012,8 @@ enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct scic_sds_port *sci_
 	 * Loop through all of the phys in this port and find the phy with the
 	 * lowest maximum link rate. */
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		iphy = sci_port->phy_table[index];
-		if (iphy && scic_sds_port_active_phy(sci_port, iphy) &&
+		iphy = iport->phy_table[index];
+		if (iphy && scic_sds_port_active_phy(iport, iphy) &&
 		    iphy->max_negotiated_speed < max_allowed_speed)
 			max_allowed_speed = iphy->max_negotiated_speed;
 	}
@@ -1026,13 +1021,13 @@ enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct scic_sds_port *sci_
 	return max_allowed_speed;
 }
 
-static void scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port)
+static void scic_sds_port_suspend_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value = readl(&iport->port_task_scheduler_registers->control);
 	pts_control_value |= SCU_PTSxCR_GEN_BIT(SUSPEND);
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
 /**
@@ -1044,10 +1039,10 @@ static void scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port
  * ongoing requests.
  *
  */
-static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
+static void scic_sds_port_post_dummy_request(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u16 tag = sci_port->reserved_tag;
+	struct scic_sds_controller *scic = iport->owning_controller;
+	u16 tag = iport->reserved_tag;
 	struct scu_task_context *tc;
 	u32 command;
 
@@ -1055,7 +1050,7 @@ static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
 	tc->abort = 0;
 
 	command = SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
-		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
+		  iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
 		  ISCI_TAG_TCI(tag);
 
 	scic_sds_controller_post_request(scic, command);
@@ -1068,10 +1063,10 @@ static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
  * @sci_port: The port on which the task must be aborted.
  *
  */
-static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
+static void scic_sds_port_abort_dummy_request(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u16 tag = sci_port->reserved_tag;
+	struct scic_sds_controller *scic = iport->owning_controller;
+	u16 tag = iport->reserved_tag;
 	struct scu_task_context *tc;
 	u32 command;
 
@@ -1079,7 +1074,7 @@ static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
 	tc->abort = 1;
 
 	command = SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT |
-		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
+		  iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
 		  ISCI_TAG_TCI(tag);
 
 	scic_sds_controller_post_request(scic, command);
@@ -1087,31 +1082,31 @@ static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
 
 /**
  *
- * @sci_port: This is the struct scic_sds_port object to resume.
+ * @sci_port: This is the struct isci_port object to resume.
  *
  * This method will resume the port task scheduler for this port object. none
  */
 static void
-scic_sds_port_resume_port_task_scheduler(struct scic_sds_port *port)
+scic_sds_port_resume_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value = readl(&iport->port_task_scheduler_registers->control);
 	pts_control_value &= ~SCU_PTSxCR_GEN_BIT(SUSPEND);
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
 static void scic_sds_port_ready_substate_waiting_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	scic_sds_port_suspend_port_task_scheduler(sci_port);
+	scic_sds_port_suspend_port_task_scheduler(iport);
 
-	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
+	iport->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
 
-	if (sci_port->active_phy_mask != 0) {
+	if (iport->active_phy_mask != 0) {
 		/* At least one of the phys on the port is ready */
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_OPERATIONAL);
 	}
 }
@@ -1119,38 +1114,37 @@ static void scic_sds_port_ready_substate_waiting_enter(struct sci_base_state_mac
 static void scic_sds_port_ready_substate_operational_enter(struct sci_base_state_machine *sm)
 {
 	u32 index;
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
 
 	isci_port_ready(ihost, iport);
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index]) {
-			writel(sci_port->physical_port_index,
-				&sci_port->port_pe_configuration_register[
-					sci_port->phy_table[index]->phy_index]);
+		if (iport->phy_table[index]) {
+			writel(iport->physical_port_index,
+				&iport->port_pe_configuration_register[
+					iport->phy_table[index]->phy_index]);
 		}
 	}
 
-	scic_sds_port_update_viit_entry(sci_port);
+	scic_sds_port_update_viit_entry(iport);
 
-	scic_sds_port_resume_port_task_scheduler(sci_port);
+	scic_sds_port_resume_port_task_scheduler(iport);
 
 	/*
 	 * Post the dummy task for the port so the hardware can schedule
 	 * io correctly
 	 */
-	scic_sds_port_post_dummy_request(sci_port);
+	scic_sds_port_post_dummy_request(iport);
 }
 
-static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci_port)
+static void scic_sds_port_invalidate_dummy_remote_node(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u8 phys_index = sci_port->physical_port_index;
+	struct scic_sds_controller *scic = iport->owning_controller;
+	u8 phys_index = iport->physical_port_index;
 	union scu_remote_node_context *rnc;
-	u16 rni = sci_port->reserved_rni;
+	u16 rni = iport->reserved_rni;
 	u32 command;
 
 	rnc = &scic->remote_node_context_table[rni];
@@ -1172,73 +1166,71 @@ static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci
 
 /**
  *
- * @object: This is the object which is cast to a struct scic_sds_port object.
+ * @object: This is the object which is cast to a struct isci_port object.
  *
- * This method will perform the actions required by the struct scic_sds_port on
+ * This method will perform the actions required by the struct isci_port on
  * exiting the SCI_PORT_SUB_OPERATIONAL. This function reports
  * the port not ready and suspends the port task scheduler. none
  */
 static void scic_sds_port_ready_substate_operational_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
 
 	/*
 	 * Kill the dummy task for this port if it has not yet posted
 	 * the hardware will treat this as a NOP and just return abort
 	 * complete.
 	 */
-	scic_sds_port_abort_dummy_request(sci_port);
+	scic_sds_port_abort_dummy_request(iport);
 
 	isci_port_not_ready(ihost, iport);
 
-	if (sci_port->ready_exit)
-		scic_sds_port_invalidate_dummy_remote_node(sci_port);
+	if (iport->ready_exit)
+		scic_sds_port_invalidate_dummy_remote_node(iport);
 }
 
 static void scic_sds_port_ready_substate_configuring_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
 
-	if (sci_port->active_phy_mask == 0) {
+	if (iport->active_phy_mask == 0) {
 		isci_port_not_ready(ihost, iport);
 
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_WAITING);
-	} else if (sci_port->started_request_count == 0)
-		port_state_machine_change(sci_port,
+	} else if (iport->started_request_count == 0)
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_OPERATIONAL);
 }
 
 static void scic_sds_port_ready_substate_configuring_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	scic_sds_port_suspend_port_task_scheduler(sci_port);
-	if (sci_port->ready_exit)
-		scic_sds_port_invalidate_dummy_remote_node(sci_port);
+	scic_sds_port_suspend_port_task_scheduler(iport);
+	if (iport->ready_exit)
+		scic_sds_port_invalidate_dummy_remote_node(iport);
 }
 
-enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
+enum sci_status scic_sds_port_start(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 	enum sci_status status = SCI_SUCCESS;
 	enum scic_sds_port_states state;
 	u32 phy_mask;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	if (state != SCI_PORT_STOPPED) {
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	if (sci_port->assigned_device_count > 0) {
+	if (iport->assigned_device_count > 0) {
 		/* TODO This is a start failure operation because
 		 * there are still devices assigned to this port.
 		 * There must be no devices assigned to a port on a
@@ -1247,18 +1239,18 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
 	}
 
-	if (sci_port->reserved_rni == SCU_DUMMY_INDEX) {
+	if (iport->reserved_rni == SCU_DUMMY_INDEX) {
 		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
 				&scic->available_remote_nodes, 1);
 
 		if (rni != SCU_DUMMY_INDEX)
-			scic_sds_port_construct_dummy_rnc(sci_port, rni);
+			scic_sds_port_construct_dummy_rnc(iport, rni);
 		else
 			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
-		sci_port->reserved_rni = rni;
+		iport->reserved_rni = rni;
 	}
 
-	if (sci_port->reserved_tag == SCI_CONTROLLER_INVALID_IO_TAG) {
+	if (iport->reserved_tag == SCI_CONTROLLER_INVALID_IO_TAG) {
 		struct isci_host *ihost = scic_to_ihost(scic);
 		u16 tag;
 
@@ -1266,20 +1258,20 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 		if (tag == SCI_CONTROLLER_INVALID_IO_TAG)
 			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
 		else
-			scic_sds_port_construct_dummy_task(sci_port, tag);
-		sci_port->reserved_tag = tag;
+			scic_sds_port_construct_dummy_task(iport, tag);
+		iport->reserved_tag = tag;
 	}
 
 	if (status == SCI_SUCCESS) {
-		phy_mask = scic_sds_port_get_phys(sci_port);
+		phy_mask = scic_sds_port_get_phys(iport);
 
 		/*
 		 * There are one or more phys assigned to this port.  Make sure
 		 * the port's phy mask is in fact legal and supported by the
 		 * silicon.
 		 */
-		if (scic_sds_port_is_phy_mask_valid(sci_port, phy_mask) == true) {
-			port_state_machine_change(sci_port,
+		if (scic_sds_port_is_phy_mask_valid(iport, phy_mask) == true) {
+			port_state_machine_change(iport,
 						  SCI_PORT_READY);
 
 			return SCI_SUCCESS;
@@ -1288,16 +1280,16 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 	}
 
 	if (status != SCI_SUCCESS)
-		scic_sds_port_destroy_dummy_resources(sci_port);
+		scic_sds_port_destroy_dummy_resources(iport);
 
 	return status;
 }
 
-enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port)
+enum sci_status scic_sds_port_stop(struct isci_port *iport)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_STOPPED:
 		return SCI_SUCCESS;
@@ -1305,34 +1297,34 @@ enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port)
 	case SCI_PORT_SUB_OPERATIONAL:
 	case SCI_PORT_SUB_CONFIGURING:
 	case SCI_PORT_RESETTING:
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_STOPPING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32 timeout)
+static enum sci_status scic_port_hard_reset(struct isci_port *iport, u32 timeout)
 {
 	enum sci_status status = SCI_FAILURE_INVALID_PHY;
 	struct isci_phy *iphy = NULL;
 	enum scic_sds_port_states state;
 	u32 phy_index;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	if (state != SCI_PORT_SUB_OPERATIONAL) {
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
 	/* Select a phy on which we can send the hard reset request. */
 	for (phy_index = 0; phy_index < SCI_MAX_PHYS && !iphy; phy_index++) {
-		iphy = sci_port->phy_table[phy_index];
-		if (iphy && !scic_sds_port_active_phy(sci_port, iphy)) {
+		iphy = iport->phy_table[phy_index];
+		if (iphy && !scic_sds_port_active_phy(iport, iphy)) {
 			/*
 			 * We found a phy but it is not ready select
 			 * different phy
@@ -1349,10 +1341,10 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
 	if (status != SCI_SUCCESS)
 		return status;
 
-	sci_mod_timer(&sci_port->timer, timeout);
-	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
+	sci_mod_timer(&iport->timer, timeout);
+	iport->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
 
-	port_state_machine_change(sci_port, SCI_PORT_RESETTING);
+	port_state_machine_change(iport, SCI_PORT_RESETTING);
 	return SCI_SUCCESS;
 }
 
@@ -1365,19 +1357,19 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
  * enum sci_status. SCI_SUCCESS the phy has been added to the port. Any other
  * status is a failure to add the phy to the port.
  */
-enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_add_phy(struct isci_port *iport,
 				      struct isci_phy *iphy)
 {
 	enum sci_status status;
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_STOPPED: {
 		struct sci_sas_address port_sas_address;
 
 		/* Read the port assigned SAS Address if there is one */
-		scic_sds_port_get_sas_address(sci_port, &port_sas_address);
+		scic_sds_port_get_sas_address(iport, &port_sas_address);
 
 		if (port_sas_address.high != 0 && port_sas_address.low != 0) {
 			struct sci_sas_address phy_sas_address;
@@ -1391,35 +1383,35 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
 			    port_sas_address.low  != phy_sas_address.low)
 				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
 		}
-		return scic_sds_port_set_phy(sci_port, iphy);
+		return scic_sds_port_set_phy(iport, iphy);
 	}
 	case SCI_PORT_SUB_WAITING:
 	case SCI_PORT_SUB_OPERATIONAL:
-		status = scic_sds_port_set_phy(sci_port, iphy);
+		status = scic_sds_port_set_phy(iport, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
 
-		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
-		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
-		port_state_machine_change(sci_port, SCI_PORT_SUB_CONFIGURING);
+		scic_sds_port_general_link_up_handler(iport, iphy, true);
+		iport->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+		port_state_machine_change(iport, SCI_PORT_SUB_CONFIGURING);
 
 		return status;
 	case SCI_PORT_SUB_CONFIGURING:
-		status = scic_sds_port_set_phy(sci_port, iphy);
+		status = scic_sds_port_set_phy(iport, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
-		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
+		scic_sds_port_general_link_up_handler(iport, iphy, true);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port.
 		 */
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -1434,65 +1426,65 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
  * an enum sci_status. SCI_SUCCESS the phy has been removed from the port. Any
  * other status is a failure to add the phy to the port.
  */
-enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_remove_phy(struct isci_port *iport,
 					 struct isci_phy *iphy)
 {
 	enum sci_status status;
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PORT_STOPPED:
-		return scic_sds_port_clear_phy(sci_port, iphy);
+		return scic_sds_port_clear_phy(iport, iphy);
 	case SCI_PORT_SUB_OPERATIONAL:
-		status = scic_sds_port_clear_phy(sci_port, iphy);
+		status = scic_sds_port_clear_phy(iport, iphy);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		scic_sds_port_deactivate_phy(sci_port, iphy, true);
-		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
-		port_state_machine_change(sci_port,
+		scic_sds_port_deactivate_phy(iport, iphy, true);
+		iport->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_CONFIGURING:
-		status = scic_sds_port_clear_phy(sci_port, iphy);
+		status = scic_sds_port_clear_phy(iport, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
-		scic_sds_port_deactivate_phy(sci_port, iphy, true);
+		scic_sds_port_deactivate_phy(iport, iphy, true);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port
 		 */
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_link_up(struct isci_port *iport,
 				      struct isci_phy *iphy)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_SUB_WAITING:
 		/* Since this is the first phy going link up for the port we
 		 * can just enable it and continue
 		 */
-		scic_sds_port_activate_phy(sci_port, iphy, true);
+		scic_sds_port_activate_phy(iport, iphy, true);
 
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_OPERATIONAL);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
+		scic_sds_port_general_link_up_handler(iport, iphy, true);
 		return SCI_SUCCESS;
 	case SCI_PORT_RESETTING:
 		/* TODO We should  make  sure  that  the phy  that  has gone
@@ -1509,82 +1501,82 @@ enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications.
 		 */
-		scic_sds_port_general_link_up_handler(sci_port, iphy, false);
+		scic_sds_port_general_link_up_handler(iport, iphy, false);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_link_down(struct isci_port *iport,
 					struct isci_phy *iphy)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_deactivate_phy(sci_port, iphy, true);
+		scic_sds_port_deactivate_phy(iport, iphy, true);
 
 		/* If there are no active phys left in the port, then
 		 * transition the port to the WAITING state until such time
 		 * as a phy goes link up
 		 */
-		if (sci_port->active_phy_mask == 0)
-			port_state_machine_change(sci_port,
+		if (iport->active_phy_mask == 0)
+			port_state_machine_change(iport,
 						  SCI_PORT_SUB_WAITING);
 		return SCI_SUCCESS;
 	case SCI_PORT_RESETTING:
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications. */
-		scic_sds_port_deactivate_phy(sci_port, iphy, false);
+		scic_sds_port_deactivate_phy(iport, iphy, false);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-enum sci_status scic_sds_port_start_io(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_start_io(struct isci_port *iport,
 				       struct scic_sds_remote_device *sci_dev,
 				       struct isci_request *ireq)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_SUB_WAITING:
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_PORT_SUB_OPERATIONAL:
-		sci_port->started_request_count++;
+		iport->started_request_count++;
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-enum sci_status scic_sds_port_complete_io(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_complete_io(struct isci_port *iport,
 					  struct scic_sds_remote_device *sci_dev,
 					  struct isci_request *ireq)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_STOPPED:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_PORT_STOPPING:
-		scic_sds_port_decrement_request_count(sci_port);
+		scic_sds_port_decrement_request_count(iport);
 
-		if (sci_port->started_request_count == 0)
-			port_state_machine_change(sci_port,
+		if (iport->started_request_count == 0)
+			port_state_machine_change(iport,
 						  SCI_PORT_STOPPED);
 		break;
 	case SCI_PORT_READY:
@@ -1592,12 +1584,12 @@ enum sci_status scic_sds_port_complete_io(struct scic_sds_port *sci_port,
 	case SCI_PORT_FAILED:
 	case SCI_PORT_SUB_WAITING:
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_decrement_request_count(sci_port);
+		scic_sds_port_decrement_request_count(iport);
 		break;
 	case SCI_PORT_SUB_CONFIGURING:
-		scic_sds_port_decrement_request_count(sci_port);
-		if (sci_port->started_request_count == 0) {
-			port_state_machine_change(sci_port,
+		scic_sds_port_decrement_request_count(iport);
+		if (iport->started_request_count == 0) {
+			port_state_machine_change(iport,
 						  SCI_PORT_SUB_OPERATIONAL);
 		}
 		break;
@@ -1613,13 +1605,13 @@ enum sci_status scic_sds_port_complete_io(struct scic_sds_port *sci_port,
  * will leave the port task scheduler in a suspended state. none
  */
 static void
-scic_sds_port_enable_port_task_scheduler(struct scic_sds_port *port)
+scic_sds_port_enable_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value = readl(&iport->port_task_scheduler_registers->control);
 	pts_control_value |= SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND);
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
 /**
@@ -1630,22 +1622,22 @@ scic_sds_port_enable_port_task_scheduler(struct scic_sds_port *port)
  * none
  */
 static void
-scic_sds_port_disable_port_task_scheduler(struct scic_sds_port *port)
+scic_sds_port_disable_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value = readl(&iport->port_task_scheduler_registers->control);
 	pts_control_value &=
 		~(SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND));
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
-static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
+static void scic_sds_port_post_dummy_remote_node(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u8 phys_index = sci_port->physical_port_index;
+	struct scic_sds_controller *scic = iport->owning_controller;
+	u8 phys_index = iport->physical_port_index;
 	union scu_remote_node_context *rnc;
-	u16 rni = sci_port->reserved_rni;
+	u16 rni = iport->reserved_rni;
 	u32 command;
 
 	rnc = &scic->remote_node_context_table[rni];
@@ -1670,67 +1662,65 @@ static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
 
 static void scic_sds_port_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	if (sci_port->sm.previous_state_id == SCI_PORT_STOPPING) {
+	if (iport->sm.previous_state_id == SCI_PORT_STOPPING) {
 		/*
 		 * If we enter this state becasuse of a request to stop
 		 * the port then we want to disable the hardwares port
 		 * task scheduler. */
-		scic_sds_port_disable_port_task_scheduler(sci_port);
+		scic_sds_port_disable_port_task_scheduler(iport);
 	}
 }
 
 static void scic_sds_port_stopped_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
 	/* Enable and suspend the port task scheduler */
-	scic_sds_port_enable_port_task_scheduler(sci_port);
+	scic_sds_port_enable_port_task_scheduler(iport);
 }
 
 static void scic_sds_port_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
 	u32 prev_state;
 
-	prev_state = sci_port->sm.previous_state_id;
+	prev_state = iport->sm.previous_state_id;
 	if (prev_state  == SCI_PORT_RESETTING)
 		isci_port_hard_reset_complete(iport, SCI_SUCCESS);
 	else
 		isci_port_not_ready(ihost, iport);
 
 	/* Post and suspend the dummy remote node context for this port. */
-	scic_sds_port_post_dummy_remote_node(sci_port);
+	scic_sds_port_post_dummy_remote_node(iport);
 
 	/* Start the ready substate machine */
-	port_state_machine_change(sci_port,
+	port_state_machine_change(iport,
 				  SCI_PORT_SUB_WAITING);
 }
 
 static void scic_sds_port_resetting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	sci_del_timer(&sci_port->timer);
+	sci_del_timer(&iport->timer);
 }
 
 static void scic_sds_port_stopping_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	sci_del_timer(&sci_port->timer);
+	sci_del_timer(&iport->timer);
 
-	scic_sds_port_destroy_dummy_resources(sci_port);
+	scic_sds_port_destroy_dummy_resources(iport);
 }
 
 static void scic_sds_port_failed_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
 	isci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);
 }
@@ -1767,30 +1757,30 @@ static const struct sci_base_state scic_sds_port_state_table[] = {
 	}
 };
 
-void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
+void scic_sds_port_construct(struct isci_port *iport, u8 index,
 			     struct scic_sds_controller *scic)
 {
-	sci_init_sm(&sci_port->sm, scic_sds_port_state_table, SCI_PORT_STOPPED);
+	sci_init_sm(&iport->sm, scic_sds_port_state_table, SCI_PORT_STOPPED);
 
-	sci_port->logical_port_index  = SCIC_SDS_DUMMY_PORT;
-	sci_port->physical_port_index = index;
-	sci_port->active_phy_mask     = 0;
-	sci_port->ready_exit	      = false;
+	iport->logical_port_index  = SCIC_SDS_DUMMY_PORT;
+	iport->physical_port_index = index;
+	iport->active_phy_mask     = 0;
+	iport->ready_exit	      = false;
 
-	sci_port->owning_controller = scic;
+	iport->owning_controller = scic;
 
-	sci_port->started_request_count = 0;
-	sci_port->assigned_device_count = 0;
+	iport->started_request_count = 0;
+	iport->assigned_device_count = 0;
 
-	sci_port->reserved_rni = SCU_DUMMY_INDEX;
-	sci_port->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
+	iport->reserved_rni = SCU_DUMMY_INDEX;
+	iport->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
 
-	sci_init_timer(&sci_port->timer, port_timeout);
+	sci_init_timer(&iport->timer, port_timeout);
 
-	sci_port->port_task_scheduler_registers = NULL;
+	iport->port_task_scheduler_registers = NULL;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++)
-		sci_port->phy_table[index] = NULL;
+		iport->phy_table[index] = NULL;
 }
 
 void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
@@ -1817,14 +1807,14 @@ enum isci_status isci_port_get_state(
 }
 
 void scic_sds_port_broadcast_change_received(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 
 	/* notify the user. */
-	isci_port_bc_change_received(ihost, sci_port, iphy);
+	isci_port_bc_change_received(ihost, iport, iphy);
 }
 
 int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,
@@ -1842,7 +1832,7 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT
-	status = scic_port_hard_reset(&iport->sci, ISCI_PORT_RESET_TIMEOUT);
+	status = scic_port_hard_reset(iport, ISCI_PORT_RESET_TIMEOUT);
 
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
@@ -1878,14 +1868,12 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 		/* Down all phys in the port. */
 		spin_lock_irqsave(&ihost->scic_lock, flags);
 		for (idx = 0; idx < SCI_MAX_PHYS; ++idx) {
+			struct isci_phy *iphy = iport->phy_table[idx];
 
-			if (iport->sci.phy_table[idx] != NULL) {
-
-				scic_sds_phy_stop(
-					iport->sci.phy_table[idx]);
-				scic_sds_phy_start(
-					iport->sci.phy_table[idx]);
-			}
+			if (!iphy)
+				continue;
+			scic_sds_phy_stop(iphy);
+			scic_sds_phy_start(iphy);
 		}
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 	}
diff --git a/drivers/scsi/isci/port.h b/drivers/scsi/isci/port.h
index b6ce56a..cdea48e 100644
--- a/drivers/scsi/isci/port.h
+++ b/drivers/scsi/isci/port.h
@@ -76,100 +76,19 @@ enum isci_status {
 };
 
 /**
- * struct scic_sds_port
- *
- * The core port object provides the the abstraction for an SCU port.
- */
-struct scic_sds_port {
-	/**
-	 * This field contains the information for the base port state machine.
-	 */
-	struct sci_base_state_machine sm;
-
-	bool ready_exit;
-
-	/**
-	 * This field is the port index that is reported to the SCI USER.
-	 * This allows the actual hardware physical port to change without
-	 * the SCI USER getting a different answer for the get port index.
-	 */
-	u8 logical_port_index;
-
-	/**
-	 * This field is the port index used to program the SCU hardware.
-	 */
-	u8 physical_port_index;
-
-	/**
-	 * This field contains the active phy mask for the port.
-	 * This mask is used in conjunction with the phy state to determine
-	 * which phy to select for some port operations.
-	 */
-	u8 active_phy_mask;
-
-	u16 reserved_rni;
-	u16 reserved_tag;
-
-	/**
-	 * This field contains the count of the io requests started on this port
-	 * object.  It is used to control controller shutdown.
-	 */
-	u32 started_request_count;
-
-	/**
-	 * This field contains the number of devices assigned to this port.
-	 * It is used to control port start requests.
-	 */
-	u32 assigned_device_count;
-
-	/**
-	 * This field contains the reason for the port not going ready.  It is
-	 * assigned in the state handlers and used in the state transition.
-	 */
-	u32 not_ready_reason;
-
-	/**
-	 * This field is the table of phys assigned to the port.
-	 */
-	struct isci_phy *phy_table[SCI_MAX_PHYS];
-
-	/**
-	 * This field is a pointer back to the controller that owns this
-	 * port object.
-	 */
-	struct scic_sds_controller *owning_controller;
-
-	/* timer used for port start/stop operations */
-	struct sci_timer	timer;
-
-	/**
-	 * This field is the pointer to the port task scheduler registers
-	 * for the SCU hardware.
-	 */
-	struct scu_port_task_scheduler_registers __iomem
-		*port_task_scheduler_registers;
-
-	/**
-	 * This field is identical for all port objects and points to the port
-	 * task scheduler group PE configuration registers.
-	 * It is used to assign PEs to a port.
-	 */
-	u32 __iomem *port_pe_configuration_register;
-
-	/**
-	 * This field is the VIIT register space for ths port object.
-	 */
-	struct scu_viit_entry __iomem *viit_registers;
-};
-
-
-
-/**
- * struct isci_port - This class represents the port object used to internally
- *    represent libsas port objects. It also keeps a list of remote device
- *    objects.
- *
- *
+ * struct isci_port - isci direct attached sas port object
+ * @event: counts bcns and port stop events (for bcn filtering)
+ * @ready_exit: several states constitute 'ready'. When exiting ready we
+ *              need to take extra port-teardown actions that are
+ *              skipped when exiting to another 'ready' state.
+ * @logical_port_index: software port index
+ * @physical_port_index: hardware port index
+ * @active_phy_mask: identifies phy members
+ * @reserved_tag:
+ * @reserved_rni: reserver for port task scheduler workaround
+ * @started_request_count: reference count for outstanding commands
+ * @not_ready_reason: set during state transitions and notified
+ * @timer: timeout start/stop operations
  */
 struct isci_port {
 	enum isci_status status;
@@ -185,16 +104,25 @@ struct isci_port {
 	struct completion start_complete;
 	struct completion hard_reset_complete;
 	enum sci_status hard_reset_status;
-	struct scic_sds_port sci;
+	struct sci_base_state_machine sm;
+	bool ready_exit;
+	u8 logical_port_index;
+	u8 physical_port_index;
+	u8 active_phy_mask;
+	u16 reserved_rni;
+	u16 reserved_tag;
+	u32 started_request_count;
+	u32 assigned_device_count;
+	u32 not_ready_reason;
+	struct isci_phy *phy_table[SCI_MAX_PHYS];
+	struct scic_sds_controller *owning_controller;
+	struct sci_timer timer;
+	struct scu_port_task_scheduler_registers __iomem *port_task_scheduler_registers;
+	/* XXX rework: only one register, no need to replicate per-port */
+	u32 __iomem *port_pe_configuration_register;
+	struct scu_viit_entry __iomem *viit_registers;
 };
 
-static inline struct isci_port *sci_port_to_iport(struct scic_sds_port *sci_port)
-{
-	struct isci_port *iport = container_of(sci_port, typeof(*iport), sci);
-
-	return iport;
-}
-
 enum scic_port_not_ready_reason_code {
 	SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS,
 	SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED,
@@ -299,90 +227,90 @@ enum scic_sds_port_states {
 	((this_port)->physical_port_index)
 
 
-static inline void scic_sds_port_decrement_request_count(struct scic_sds_port *sci_port)
+static inline void scic_sds_port_decrement_request_count(struct isci_port *iport)
 {
-	if (WARN_ONCE(sci_port->started_request_count == 0,
+	if (WARN_ONCE(iport->started_request_count == 0,
 		       "%s: tried to decrement started_request_count past 0!?",
 			__func__))
 		/* pass */;
 	else
-		sci_port->started_request_count--;
+		iport->started_request_count--;
 }
 
 #define scic_sds_port_active_phy(port, phy) \
 	(((port)->active_phy_mask & (1 << (phy)->phy_index)) != 0)
 
 void scic_sds_port_construct(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	u8 port_index,
 	struct scic_sds_controller *scic);
 
 enum sci_status scic_sds_port_initialize(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	void __iomem *port_task_scheduler_registers,
 	void __iomem *port_configuration_regsiter,
 	void __iomem *viit_registers);
 
-enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port);
-enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port);
+enum sci_status scic_sds_port_start(struct isci_port *iport);
+enum sci_status scic_sds_port_stop(struct isci_port *iport);
 
 enum sci_status scic_sds_port_add_phy(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy);
 
 enum sci_status scic_sds_port_remove_phy(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy);
 
 void scic_sds_port_setup_transports(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	u32 device_id);
 
 void isci_port_bcn_enable(struct isci_host *, struct isci_port *);
 
 void scic_sds_port_deactivate_phy(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy,
 	bool do_notify_user);
 
 bool scic_sds_port_link_detected(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy);
 
-enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_link_up(struct isci_port *iport,
 				      struct isci_phy *iphy);
-enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_link_down(struct isci_port *iport,
 					struct isci_phy *iphy);
 
 struct isci_request;
 struct scic_sds_remote_device;
 enum sci_status scic_sds_port_start_io(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct scic_sds_remote_device *sci_dev,
 	struct isci_request *ireq);
 
 enum sci_status scic_sds_port_complete_io(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct scic_sds_remote_device *sci_dev,
 	struct isci_request *ireq);
 
 enum sas_linkrate scic_sds_port_get_max_allowed_speed(
-	struct scic_sds_port *sci_port);
+	struct isci_port *iport);
 
 void scic_sds_port_broadcast_change_received(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy);
 
 bool scic_sds_port_is_valid_phy_assignment(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	u32 phy_index);
 
 void scic_sds_port_get_sas_address(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct sci_sas_address *sas_address);
 
 void scic_sds_port_get_attached_sas_address(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct sci_sas_address *sas_address);
 
 enum isci_status isci_port_get_state(
diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 8444fd8..bb62d2a 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -112,7 +112,7 @@ static s32 sci_sas_address_compare(
  * port. port address if the port can be found to match the phy.
  * NULL if there is no matching port for the phy.
  */
-static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
+static struct isci_port *scic_sds_port_configuration_agent_find_port(
 	struct scic_sds_controller *scic,
 	struct isci_phy *iphy)
 {
@@ -132,14 +132,14 @@ static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
 
 	for (i = 0; i < scic->logical_port_entries; i++) {
 		struct isci_host *ihost = scic_to_ihost(scic);
-		struct scic_sds_port *sci_port = &ihost->ports[i].sci;
+		struct isci_port *iport = &ihost->ports[i];
 
-		scic_sds_port_get_sas_address(sci_port, &port_sas_address);
-		scic_sds_port_get_attached_sas_address(sci_port, &port_attached_device_address);
+		scic_sds_port_get_sas_address(iport, &port_sas_address);
+		scic_sds_port_get_attached_sas_address(iport, &port_attached_device_address);
 
 		if (sci_sas_address_compare(port_sas_address, phy_sas_address) == 0 &&
 		    sci_sas_address_compare(port_attached_device_address, phy_attached_device_address) == 0)
-			return sci_port;
+			return iport;
 	}
 
 	return NULL;
@@ -315,7 +315,7 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 			port_agent->phy_valid_port_range[phy_index].min_index = port_index;
 			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
 
-			scic_sds_port_add_phy(&ihost->ports[port_index].sci,
+			scic_sds_port_add_phy(&ihost->ports[port_index],
 					      &ihost->phys[phy_index]);
 
 			assigned_phy_mask |= (1 << phy_index);
@@ -367,22 +367,20 @@ done:
 
 static void scic_sds_mpc_agent_link_up(struct scic_sds_controller *controller,
 				       struct scic_sds_port_configuration_agent *port_agent,
-				       struct scic_sds_port *port,
+				       struct isci_port *iport,
 				       struct isci_phy *iphy)
 {
-	/* If the port has an invalid handle then the phy was not assigned to
-	 * a port.  This is because the phy was not given the same SAS Address
-	 * as the other PHYs in the port.
+	/* If the port is NULL then the phy was not assigned to a port.
+	 * This is because the phy was not given the same SAS Address as
+	 * the other PHYs in the port.
 	 */
-	if (port != NULL) {
-		port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(iphy));
-
-		scic_sds_port_link_up(port, iphy);
+	if (!iport)
+		return;
 
-		if ((port->active_phy_mask & (1 << scic_sds_phy_get_index(iphy))) != 0) {
-			port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(iphy));
-		}
-	}
+	port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(iphy));
+	scic_sds_port_link_up(iport, iphy);
+	if ((iport->active_phy_mask & (1 << scic_sds_phy_get_index(iphy))))
+		port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(iphy));
 }
 
 /**
@@ -405,10 +403,10 @@ static void scic_sds_mpc_agent_link_up(struct scic_sds_controller *controller,
 static void scic_sds_mpc_agent_link_down(
 	struct scic_sds_controller *scic,
 	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
-	if (sci_port != NULL) {
+	if (iport != NULL) {
 		/*
 		 * If we can form a new port from the remainder of the phys
 		 * then we want to start the timer to allow the SCI User to
@@ -436,7 +434,7 @@ static void scic_sds_mpc_agent_link_down(
 				      SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
 		}
 
-		scic_sds_port_link_down(sci_port, iphy);
+		scic_sds_port_link_down(iport, iphy);
 	}
 }
 
@@ -496,14 +494,14 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 {
 	u8 port_index;
 	enum sci_status status;
-	struct scic_sds_port *port;
+	struct isci_port *iport;
 	enum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;
 	struct isci_host *ihost = scic_to_ihost(controller);
 
-	port = scic_sds_port_configuration_agent_find_port(controller, iphy);
+	iport = scic_sds_port_configuration_agent_find_port(controller, iphy);
 
-	if (port != NULL) {
-		if (scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index))
+	if (iport) {
+		if (scic_sds_port_is_valid_phy_assignment(iport, iphy->phy_index))
 			apc_activity = SCIC_SDS_APC_ADD_PHY;
 		else
 			apc_activity = SCIC_SDS_APC_SKIP_PHY;
@@ -514,21 +512,19 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 		 * the timer and wait to see if a wider port can be made.
 		 *
 		 * Note the break when we reach the condition of the port id == phy id */
-		for (
-			port_index = port_agent->phy_valid_port_range[iphy->phy_index].min_index;
-			port_index <= port_agent->phy_valid_port_range[iphy->phy_index].max_index;
-			port_index++
-			) {
+		for (port_index = port_agent->phy_valid_port_range[iphy->phy_index].min_index;
+		     port_index <= port_agent->phy_valid_port_range[iphy->phy_index].max_index;
+		     port_index++) {
 
-			port = &ihost->ports[port_index].sci;
+			iport = &ihost->ports[port_index];
 
 			/* First we must make sure that this PHY can be added to this Port. */
-			if (scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index)) {
+			if (scic_sds_port_is_valid_phy_assignment(iport, iphy->phy_index)) {
 				/*
 				 * Port contains a PHY with a greater PHY ID than the current
 				 * PHY that has gone link up.  This phy can not be part of any
 				 * port so skip it and move on. */
-				if (port->active_phy_mask > (1 << iphy->phy_index)) {
+				if (iport->active_phy_mask > (1 << iphy->phy_index)) {
 					apc_activity = SCIC_SDS_APC_SKIP_PHY;
 					break;
 				}
@@ -537,7 +533,7 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 				 * We have reached the end of our Port list and have not found
 				 * any reason why we should not either add the PHY to the port
 				 * or wait for more phys to become active. */
-				if (port->physical_port_index == iphy->phy_index) {
+				if (iport->physical_port_index == iphy->phy_index) {
 					/*
 					 * The Port either has no active PHYs.
 					 * Consider that if the port had any active PHYs we would have
@@ -554,10 +550,10 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 				 * The current Port has no active PHYs and this PHY could be part
 				 * of this Port.  Since we dont know as yet setup to start the
 				 * timer and see if there is a better configuration. */
-				if (port->active_phy_mask == 0) {
+				if (iport->active_phy_mask == 0) {
 					apc_activity = SCIC_SDS_APC_START_TIMER;
 				}
-			} else if (port->active_phy_mask != 0) {
+			} else if (iport->active_phy_mask != 0) {
 				/*
 				 * The Port has an active phy and the current Phy can not
 				 * participate in this port so skip the PHY and see if
@@ -583,7 +579,7 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 
 	switch (apc_activity) {
 	case SCIC_SDS_APC_ADD_PHY:
-		status = scic_sds_port_add_phy(port, iphy);
+		status = scic_sds_port_add_phy(iport, iphy);
 
 		if (status == SCI_SUCCESS) {
 			port_agent->phy_configured_mask |= (1 << iphy->phy_index);
@@ -625,18 +621,18 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
  */
 static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 				       struct scic_sds_port_configuration_agent *port_agent,
-				       struct scic_sds_port *sci_port,
+				       struct isci_port *iport,
 				       struct isci_phy *iphy)
 {
 	u8 phy_index  = iphy->phy_index;
 
-	if (!sci_port) {
+	if (!iport) {
 		/* the phy is not the part of this port */
 		port_agent->phy_ready_mask |= 1 << phy_index;
 		scic_sds_apc_agent_configure_ports(scic, port_agent, iphy, true);
 	} else {
 		/* the phy is already the part of the port */
-		u32 port_state = sci_port->sm.current_state_id;
+		u32 port_state = iport->sm.current_state_id;
 
 		/* if the PORT'S state is resetting then the link up is from
 		 * port hard reset in this case, we need to tell the port
@@ -644,7 +640,7 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 		 */
 		BUG_ON(port_state != SCI_PORT_RESETTING);
 		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_port_link_up(sci_port, iphy);
+		scic_sds_port_link_up(iport, iphy);
 	}
 }
 
@@ -652,9 +648,9 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
  *
  * @controller: This is the controller object that receives the link down
  *    notification.
- * @port: This is the port object associated with the phy.  If the is no
+ * @iport: This is the port object associated with the phy.  If the is no
  *    associated port this is an NULL.
- * @phy: This is the phy object which has gone link down.
+ * @iphy: This is the phy object which has gone link down.
  *
  * This method handles the automatic port configuration link down
  * notifications. not associated with a port there is no action taken. Is it
@@ -664,21 +660,20 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 static void scic_sds_apc_agent_link_down(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_port *port,
+	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
 	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(iphy));
 
-	if (port != NULL) {
-		if (port_agent->phy_configured_mask & (1 << iphy->phy_index)) {
-			enum sci_status status;
+	if (!iport)
+		return;
+	if (port_agent->phy_configured_mask & (1 << iphy->phy_index)) {
+		enum sci_status status;
 
-			status = scic_sds_port_remove_phy(port, iphy);
+		status = scic_sds_port_remove_phy(iport, iphy);
 
-			if (status == SCI_SUCCESS) {
-				port_agent->phy_configured_mask &= ~(1 << iphy->phy_index);
-			}
-		}
+		if (status == SCI_SUCCESS)
+			port_agent->phy_configured_mask &= ~(1 << iphy->phy_index);
 	}
 }
 
diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 71ab908..627cf73 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -450,11 +450,11 @@ static void scic_sds_remote_device_start_request(struct scic_sds_remote_device *
 						 struct isci_request *ireq,
 						 enum sci_status status)
 {
-	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	struct isci_port *iport = sci_dev->owning_port;
 
 	/* cleanup requests that failed after starting on the port */
 	if (status != SCI_SUCCESS)
-		scic_sds_port_complete_io(sci_port, sci_dev, ireq);
+		scic_sds_port_complete_io(iport, sci_dev, ireq);
 	else {
 		kref_get(&sci_dev_to_idev(sci_dev)->kref);
 		scic_sds_remote_device_increment_request_count(sci_dev);
@@ -467,7 +467,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 {
 	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	struct isci_port *iport = sci_dev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -489,7 +489,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		 * successful it will start the request for the port object then
 		 * increment its own request count.
 		 */
-		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -511,7 +511,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		enum scic_sds_remote_device_states new_state;
 		struct sas_task *task = isci_request_access_task(ireq);
 
-		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -536,7 +536,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		struct sas_task *task = isci_request_access_task(ireq);
 
 		if (task->ata_task.use_ncq) {
-			status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+			status = scic_sds_port_start_io(iport, sci_dev, ireq);
 			if (status != SCI_SUCCESS)
 				return status;
 
@@ -552,7 +552,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	case SCI_STP_DEV_AWAIT_RESET:
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 	case SCI_SMP_DEV_IDLE:
-		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -579,7 +579,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	return status;
 }
 
-static enum sci_status common_complete_io(struct scic_sds_port *sci_port,
+static enum sci_status common_complete_io(struct isci_port *iport,
 					  struct scic_sds_remote_device *sci_dev,
 					  struct isci_request *ireq)
 {
@@ -589,7 +589,7 @@ static enum sci_status common_complete_io(struct scic_sds_port *sci_port,
 	if (status != SCI_SUCCESS)
 		return status;
 
-	status = scic_sds_port_complete_io(sci_port, sci_dev, ireq);
+	status = scic_sds_port_complete_io(iport, sci_dev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -603,7 +603,7 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 {
 	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	struct isci_port *iport = sci_dev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -621,12 +621,12 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 	case SCI_DEV_READY:
 	case SCI_STP_DEV_AWAIT_RESET:
 	case SCI_DEV_RESETTING:
-		status = common_complete_io(sci_port, sci_dev, ireq);
+		status = common_complete_io(iport, sci_dev, ireq);
 		break;
 	case SCI_STP_DEV_CMD:
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
-		status = common_complete_io(sci_port, sci_dev, ireq);
+		status = common_complete_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -641,13 +641,13 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 			sci_change_state(sm, SCI_STP_DEV_IDLE);
 		break;
 	case SCI_SMP_DEV_CMD:
-		status = common_complete_io(sci_port, sci_dev, ireq);
+		status = common_complete_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 		sci_change_state(sm, SCI_SMP_DEV_IDLE);
 		break;
 	case SCI_DEV_STOPPING:
-		status = common_complete_io(sci_port, sci_dev, ireq);
+		status = common_complete_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -661,7 +661,7 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 	if (status != SCI_SUCCESS)
 		dev_err(scirdev_to_dev(sci_dev),
 			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
-			"could not complete\n", __func__, sci_port,
+			"could not complete\n", __func__, iport,
 			sci_dev, ireq, status);
 	else
 		isci_put_device(sci_dev_to_idev(sci_dev));
@@ -684,7 +684,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 {
 	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	struct isci_port *iport = sci_dev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -706,7 +706,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
 	case SCI_STP_DEV_AWAIT_RESET:
-		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -746,7 +746,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 		 */
 		return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
 	case SCI_DEV_READY:
-		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -1064,10 +1064,10 @@ static const struct sci_base_state scic_sds_remote_device_state_table[] = {
  * scic_remote_device_[de]a_construct().  scic_remote_device_destruct()
  * frees the remote_node_context(s) for the device.
  */
-static void scic_remote_device_construct(struct scic_sds_port *sci_port,
+static void scic_remote_device_construct(struct isci_port *iport,
 				  struct scic_sds_remote_device *sci_dev)
 {
-	sci_dev->owning_port = sci_port;
+	sci_dev->owning_port = iport;
 	sci_dev->started_request_count = 0;
 
 	sci_init_sm(&sci_dev->sm, scic_sds_remote_device_state_table, SCI_DEV_INITIAL);
@@ -1090,20 +1090,20 @@ static void scic_remote_device_construct(struct scic_sds_port *sci_port,
  * sata-only controller instance.
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
-static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci_port,
+static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
 						       struct scic_sds_remote_device *sci_dev)
 {
 	enum sci_status status;
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 
-	scic_remote_device_construct(sci_port, sci_dev);
+	scic_remote_device_construct(iport, sci_dev);
 
 	/*
 	 * This information is request to determine how many remote node context
 	 * entries will be needed to store the remote node.
 	 */
 	sci_dev->is_direct_attached = true;
-	status = scic_sds_controller_allocate_remote_node_context(sci_port->owning_controller,
+	status = scic_sds_controller_allocate_remote_node_context(iport->owning_controller,
 								  sci_dev,
 								  &sci_dev->rnc.remote_node_index);
 
@@ -1116,7 +1116,7 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 	else
 		return SCI_FAILURE_UNSUPPORTED_PROTOCOL;
 
-	sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(sci_port);
+	sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(iport);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
 	sci_dev->device_port_width = 1;
@@ -1136,15 +1136,15 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
  * sata-only controller instance.
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
-static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci_port,
+static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
 						       struct scic_sds_remote_device *sci_dev)
 {
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 	enum sci_status status;
 
-	scic_remote_device_construct(sci_port, sci_dev);
+	scic_remote_device_construct(iport, sci_dev);
 
-	status = scic_sds_controller_allocate_remote_node_context(sci_port->owning_controller,
+	status = scic_sds_controller_allocate_remote_node_context(iport->owning_controller,
 								  sci_dev,
 								  &sci_dev->rnc.remote_node_index);
 	if (status != SCI_SUCCESS)
@@ -1163,7 +1163,7 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
 	 * connection the logical link rate is that same as the
 	 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
 	 * one another, so this code works for both situations. */
-	sci_dev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(sci_port),
+	sci_dev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(iport),
 					 dev->linkrate);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
@@ -1212,15 +1212,14 @@ static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *s
 static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 						    struct isci_remote_device *idev)
 {
-	struct scic_sds_port *sci_port = &iport->sci;
 	struct isci_host *ihost = iport->isci_host;
 	struct domain_device *dev = idev->domain_dev;
 	enum sci_status status;
 
 	if (dev->parent && dev_is_expander(dev->parent))
-		status = scic_remote_device_ea_construct(sci_port, &idev->sci);
+		status = scic_remote_device_ea_construct(iport, &idev->sci);
 	else
-		status = scic_remote_device_da_construct(sci_port, &idev->sci);
+		status = scic_remote_device_da_construct(iport, &idev->sci);
 
 	if (status != SCI_SUCCESS) {
 		dev_dbg(&ihost->pdev->dev, "%s: construct failed: %d\n",
diff --git a/drivers/scsi/isci/remote_device.h b/drivers/scsi/isci/remote_device.h
index 6ac5dfb..578d75b 100644
--- a/drivers/scsi/isci/remote_device.h
+++ b/drivers/scsi/isci/remote_device.h
@@ -100,7 +100,7 @@ struct scic_sds_remote_device {
 	 * This filed contains a pointer back to the port to which this device
 	 * is assigned.
 	 */
-	struct scic_sds_port *owning_port;
+	struct isci_port *owning_port;
 
 	/**
 	 * This field contains the SCU silicon remote node context specific
@@ -388,14 +388,6 @@ static inline bool dev_is_expander(struct domain_device *dev)
 	((sci_dev)->started_request_count)
 
 /**
- * scic_sds_remote_device_get_port() -
- *
- * This macro returns the owning port of this remote device obejct.
- */
-#define scic_sds_remote_device_get_port(sci_dev) \
-	((sci_dev)->owning_port)
-
-/**
  * scic_sds_remote_device_get_controller() -
  *
  * This macro returns the controller object that contains this device object
diff --git a/drivers/scsi/isci/request.c b/drivers/scsi/isci/request.c
index c544bc7..2d29abf 100644
--- a/drivers/scsi/isci/request.c
+++ b/drivers/scsi/isci/request.c
@@ -210,10 +210,10 @@ static void scu_ssp_reqeust_construct_task_context(
 {
 	dma_addr_t dma_addr;
 	struct scic_sds_remote_device *target_device;
-	struct scic_sds_port *target_port;
+	struct isci_port *iport;
 
 	target_device = scic_sds_request_get_device(ireq);
-	target_port = scic_sds_request_get_port(ireq);
+	iport = scic_sds_request_get_port(ireq);
 
 	/* Fill in the TC with the its required data */
 	task_context->abort = 0;
@@ -222,8 +222,7 @@ static void scu_ssp_reqeust_construct_task_context(
 	task_context->connection_rate = target_device->connection_rate;
 	task_context->protocol_engine_index =
 		scic_sds_controller_get_protocol_engine_group(controller);
-	task_context->logical_port_index =
-		scic_sds_port_get_index(target_port);
+	task_context->logical_port_index = scic_sds_port_get_index(iport);
 	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
@@ -245,11 +244,11 @@ static void scu_ssp_reqeust_construct_task_context(
 	task_context->task_phase = 0x01;
 
 	ireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
-				     (scic_sds_controller_get_protocol_engine_group(controller) <<
-				      SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
-				     (scic_sds_port_get_index(target_port) <<
-				      SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
-				     ISCI_TAG_TCI(ireq->io_tag));
+			      (scic_sds_controller_get_protocol_engine_group(controller) <<
+			       SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
+			      (scic_sds_port_get_index(iport) <<
+			       SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
+			      ISCI_TAG_TCI(ireq->io_tag));
 
 	/*
 	 * Copy the physical address for the command buffer to the
@@ -350,10 +349,10 @@ static void scu_sata_reqeust_construct_task_context(
 {
 	dma_addr_t dma_addr;
 	struct scic_sds_remote_device *target_device;
-	struct scic_sds_port *target_port;
+	struct isci_port *iport;
 
 	target_device = scic_sds_request_get_device(ireq);
-	target_port = scic_sds_request_get_port(ireq);
+	iport = scic_sds_request_get_port(ireq);
 
 	/* Fill in the TC with the its required data */
 	task_context->abort = 0;
@@ -363,7 +362,7 @@ static void scu_sata_reqeust_construct_task_context(
 	task_context->protocol_engine_index =
 		scic_sds_controller_get_protocol_engine_group(controller);
 	task_context->logical_port_index =
-		scic_sds_port_get_index(target_port);
+		scic_sds_port_get_index(iport);
 	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_STP;
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
@@ -391,7 +390,7 @@ static void scu_sata_reqeust_construct_task_context(
 	ireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
 				 (scic_sds_controller_get_protocol_engine_group(controller) <<
 				  SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
-				 (scic_sds_port_get_index(target_port) <<
+				 (scic_sds_port_get_index(iport) <<
 				  SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
 				 ISCI_TAG_TCI(ireq->io_tag));
 	/*
@@ -3105,7 +3104,7 @@ scic_io_request_construct_smp(struct device *dev,
 	struct scatterlist *sg = &task->smp_task.smp_req;
 	struct scic_sds_remote_device *sci_dev;
 	struct scu_task_context *task_context;
-	struct scic_sds_port *sci_port;
+	struct isci_port *iport;
 	struct smp_req *smp_req;
 	void *kaddr;
 	u8 req_len;
@@ -3149,7 +3148,7 @@ scic_io_request_construct_smp(struct device *dev,
 	task_context = ireq->tc;
 
 	sci_dev = scic_sds_request_get_device(ireq);
-	sci_port = scic_sds_request_get_port(ireq);
+	iport = scic_sds_request_get_port(ireq);
 
 	/*
 	 * Fill in the TC with the its required data
@@ -3160,7 +3159,7 @@ scic_io_request_construct_smp(struct device *dev,
 	task_context->connection_rate = sci_dev->connection_rate;
 	task_context->protocol_engine_index =
 		scic_sds_controller_get_protocol_engine_group(scic);
-	task_context->logical_port_index = scic_sds_port_get_index(sci_port);
+	task_context->logical_port_index = scic_sds_port_get_index(iport);
 	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SMP;
 	task_context->abort = 0;
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
@@ -3204,7 +3203,7 @@ scic_io_request_construct_smp(struct device *dev,
 	ireq->post_context = (SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
 				 (scic_sds_controller_get_protocol_engine_group(scic) <<
 				  SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
-				 (scic_sds_port_get_index(sci_port) <<
+				 (scic_sds_port_get_index(iport) <<
 				  SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
 				 ISCI_TAG_TCI(ireq->io_tag));
 	/*
-- 
1.6.0.2

