From: Yuval Mintz <yuvalmin@broadcom.com>
Date: Mon, 23 Jul 2012 21:16:06 +0000
Subject: [PATCH 04/77] bnx2x: Correct EEE statistics gathering
Patch-mainline: v3.6-rc1
Git-commit: c20cd5d753a452807b080bbf390e2f844d7991b3
References: bnc#790597 FATE#313915

In boards with 4-ports, Tx LPI statistics were gathered incorrectly.
This patch guarantees that each pmf will only query its own port for
these statistics.

Signed-off-by: Yuval Mintz <yuvalmin@broadcom.com>
Signed-off-by: Eilon Greenstein <eilong@broadcom.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Benjamin Poirier <bpoirier@suse.de>
---
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h   |    4 ++++
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c |    8 +++++---
 2 files changed, 9 insertions(+), 3 deletions(-)

--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_reg.h
@@ -1603,6 +1603,10 @@
  * of counts that the SM entered the EEE LPI state. Clock 25MHz. Read only
  * register. Reset on hard reset. */
 #define MISC_REG_CPMU_LP_SM_ENT_CNT_P0				 0xa8b8
+/* [RW 16] EEE LPI Entry Events Counter. A statistic counter with the number
+ * of counts that the SM entered the EEE LPI state. Clock 25MHz. Read only
+ * register. Reset on hard reset. */
+#define MISC_REG_CPMU_LP_SM_ENT_CNT_P1				 0xa8bc
 /* [RW 32] The following driver registers(1...16) represent 16 drivers and
    32 clients. Each client can be controlled by one driver only. One in each
    bit represent that this driver control the appropriate client (Ex: bit 5
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_stats.c
@@ -785,9 +785,11 @@ static int bnx2x_hw_stats_update(struct
 
 	pstats->host_port_stats_counter++;
 
-	if (CHIP_IS_E3(bp))
-		estats->eee_tx_lpi += REG_RD(bp,
-					     MISC_REG_CPMU_LP_SM_ENT_CNT_P0);
+	if (CHIP_IS_E3(bp)) {
+		u32 lpi_reg = BP_PORT(bp) ? MISC_REG_CPMU_LP_SM_ENT_CNT_P1
+					  : MISC_REG_CPMU_LP_SM_ENT_CNT_P0;
+		estats->eee_tx_lpi += REG_RD(bp, lpi_reg);
+	}
 
 	if (!BP_NOMCP(bp)) {
 		u32 nig_timer_max =
