From: Dave Jiang <dave.jiang@intel.com>
Date: Wed, 4 May 2011 18:22:33 -0700
Subject: [PATCH 161/273] isci: fixup SAS iaf protocols data structure
Git-commit: d7b90fc3436fa6d5b5251eec3128386af1a4d7b8
References: FATE#311808,bnc#709528
Patch-Mainline: 3.0

Moved the actual data structure that's read from the phy register to phy
header.  Removed the parsing of identify address frame protocol bits as
that seemed not necessary and we can use existing information.

Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/isci/core/intel_sas.h     |   27 ---------
 drivers/scsi/isci/core/scic_phy.h      |   26 +++++++--
 drivers/scsi/isci/core/scic_port.h     |    4 +-
 drivers/scsi/isci/core/scic_sds_phy.c  |   28 +--------
 drivers/scsi/isci/core/scic_sds_phy.h  |    9 +--
 drivers/scsi/isci/core/scic_sds_port.c |   97 ++++++++++----------------------
 drivers/scsi/isci/port.c               |    6 +-
 7 files changed, 59 insertions(+), 138 deletions(-)

diff --git a/drivers/scsi/isci/core/intel_sas.h b/drivers/scsi/isci/core/intel_sas.h
index 58bf1fb..f2d5ca1 100644
--- a/drivers/scsi/isci/core/intel_sas.h
+++ b/drivers/scsi/isci/core/intel_sas.h
@@ -85,33 +85,6 @@ struct sci_sas_address {
 };
 
 /**
- * struct sci_sas_identify_address_frame_protocols - This structure depicts the
- *    contents of bytes 2 and 3 in the SAS IDENTIFY ADDRESS FRAME (IAF).
- *
- * For specific information on each of these individual fields please reference
- * the SAS specification Link layer section on address frames.
- */
-struct sci_sas_identify_address_frame_protocols {
-	union {
-		struct {
-			u16 restricted1:1;
-			u16 smp_initiator:1;
-			u16 stp_initiator:1;
-			u16 ssp_initiator:1;
-			u16 reserved3:4;
-			u16 restricted2:1;
-			u16 smp_target:1;
-			u16 stp_target:1;
-			u16 ssp_target:1;
-			u16 reserved4:4;
-		} bits;
-
-		u16 all;
-	} u;
-
-};
-
-/**
  * enum _SCI_SAS_TASK_ATTRIBUTE - This enumeration depicts the SAM/SAS
  *    specification defined task attribute values for a command information
  *    unit.
diff --git a/drivers/scsi/isci/core/scic_phy.h b/drivers/scsi/isci/core/scic_phy.h
index 3f43e8d..451d797 100644
--- a/drivers/scsi/isci/core/scic_phy.h
+++ b/drivers/scsi/isci/core/scic_phy.h
@@ -103,6 +103,26 @@ struct scic_phy_cap {
 	};
 }  __packed;
 
+/* this data structure reflects the link layer transmit identification reg */
+struct scic_phy_proto {
+	union {
+		struct {
+			u16 _r_a:1;
+			u16 smp_iport:1;
+			u16 stp_iport:1;
+			u16 ssp_iport:1;
+			u16 _r_b:4;
+			u16 _r_c:1;
+			u16 smp_tport:1;
+			u16 stp_tport:1;
+			u16 ssp_tport:1;
+			u16 _r_d:4;
+		};
+		u16 all;
+	};
+} __packed;
+
+
 /**
  * struct scic_phy_properties - This structure defines the properties common to
  *    all phys that can be retrieved.
@@ -124,16 +144,10 @@ struct scic_phy_properties {
 	enum sas_linkrate negotiated_link_rate;
 
 	/**
-	 * This field indicates the protocols supported by the phy.
-	 */
-	struct sci_sas_identify_address_frame_protocols protocols;
-
-	/**
 	 * This field specifies the index of the phy in relation to other
 	 * phys within the controller.  This index is zero relative.
 	 */
 	u8 index;
-
 };
 
 /**
diff --git a/drivers/scsi/isci/core/scic_port.h b/drivers/scsi/isci/core/scic_port.h
index 56d0507..4ae9b6c 100644
--- a/drivers/scsi/isci/core/scic_port.h
+++ b/drivers/scsi/isci/core/scic_port.h
@@ -57,6 +57,7 @@
 #define _SCIC_PORT_H_
 
 #include "sci_status.h"
+#include "scic_phy.h"
 #include "intel_sas.h"
 
 struct scic_sds_port;
@@ -72,8 +73,7 @@ enum scic_port_not_ready_reason_code {
 
 struct scic_port_end_point_properties {
 	struct sci_sas_address sas_address;
-	struct sci_sas_identify_address_frame_protocols protocols;
-
+	struct scic_phy_proto protocols;
 };
 
 struct scic_port_properties {
diff --git a/drivers/scsi/isci/core/scic_sds_phy.c b/drivers/scsi/isci/core/scic_sds_phy.c
index 4afdb42..b9d6fc7 100644
--- a/drivers/scsi/isci/core/scic_sds_phy.c
+++ b/drivers/scsi/isci/core/scic_sds_phy.c
@@ -442,37 +442,15 @@ void scic_sds_phy_get_attached_sas_address(struct scic_sds_phy *sci_phy,
 	memcpy(sas_address, iaf->sas_addr, SAS_ADDR_SIZE);
 }
 
-void scic_sds_phy_get_protocols(
-	struct scic_sds_phy *sci_phy,
-	struct sci_sas_identify_address_frame_protocols *protocols)
+void scic_sds_phy_get_protocols(struct scic_sds_phy *sci_phy,
+				struct scic_phy_proto *protocols)
 {
-	protocols->u.all =
+	protocols->all =
 		(u16)(readl(&sci_phy->
 			link_layer_registers->transmit_identification) &
 				0x0000FFFF);
 }
 
-void scic_sds_phy_get_attached_phy_protocols(
-	struct scic_sds_phy *sci_phy,
-	struct sci_sas_identify_address_frame_protocols *protocols)
-{
-	protocols->u.all = 0;
-
-	if (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
-		struct isci_phy *iphy = sci_phy->iphy;
-		struct sas_identify_frame *iaf;
-
-		iaf = &iphy->frame_rcvd.iaf;
-		memcpy(&protocols->u.all, &iaf->initiator_bits, 2);
-	} else if (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA)
-		protocols->u.bits.stp_target = 1;
-}
-
-/*
- * *****************************************************************************
- * * SCIC SDS PHY Handler Redirects
- * ***************************************************************************** */
-
 /**
  * This method will attempt to start the phy object. This request is only valid
  *    when the phy is in the stopped state
diff --git a/drivers/scsi/isci/core/scic_sds_phy.h b/drivers/scsi/isci/core/scic_sds_phy.h
index e91f283..b0cebdc 100644
--- a/drivers/scsi/isci/core/scic_sds_phy.h
+++ b/drivers/scsi/isci/core/scic_sds_phy.h
@@ -57,6 +57,7 @@
 #define _SCIC_SDS_PHY_H_
 
 #include "intel_sas.h"
+#include "scic_phy.h"
 #include "scu_registers.h"
 #include "sci_base_state_machine.h"
 #include <scsi/libsas.h>
@@ -438,11 +439,7 @@ void scic_sds_phy_get_attached_sas_address(
 	struct sci_sas_address *sas_address);
 
 void scic_sds_phy_get_protocols(
-	struct scic_sds_phy *this_phy,
-	struct sci_sas_identify_address_frame_protocols *protocols);
-
-void scic_sds_phy_get_attached_phy_protocols(
-	struct scic_sds_phy *this_phy,
-	struct sci_sas_identify_address_frame_protocols *protocols);
+	struct scic_sds_phy *sci_phy,
+	struct scic_phy_proto *protocols);
 
 #endif /* _SCIC_SDS_PHY_H_ */
diff --git a/drivers/scsi/isci/core/scic_sds_port.c b/drivers/scsi/isci/core/scic_sds_port.c
index 3697211..05bc3bf 100644
--- a/drivers/scsi/isci/core/scic_sds_port.c
+++ b/drivers/scsi/isci/core/scic_sds_port.c
@@ -53,6 +53,7 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "sas.h"
 #include "intel_sas.h"
 #include "scic_controller.h"
 #include "scic_phy.h"
@@ -362,33 +363,32 @@ void scic_sds_port_get_sas_address(
 	}
 }
 
-/**
- * This method will indicate which protocols are supported by this port.
+/*
+ * This function will indicate which protocols are supported by this port.
  * @sci_port: a handle corresponding to the SAS port for which to return the
  *    supported protocols.
- * @protocols: This parameter specifies a pointer to an IAF protocol field
- *    structure into which the core will copy the protocol values for the port.
- *     The values are returned as part of a bit mask in order to allow for
- *    multi-protocol support.
- *
+ * @protocols: This parameter specifies a pointer to a data structure
+ *    which the core will copy the protocol values for the port from the
+ *    transmit_identification register.
  */
-static void scic_sds_port_get_protocols(
-	struct scic_sds_port *sci_port,
-	struct sci_sas_identify_address_frame_protocols *protocols)
+static void
+scic_sds_port_get_protocols(struct scic_sds_port *sci_port,
+			    struct scic_phy_proto *protocols)
 {
 	u8 index;
 
-	protocols->u.all = 0;
+	protocols->all = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
 		if (sci_port->phy_table[index] != NULL) {
-			scic_sds_phy_get_protocols(sci_port->phy_table[index], protocols);
+			scic_sds_phy_get_protocols(sci_port->phy_table[index],
+						   protocols);
 		}
 	}
 }
 
-/**
- * This method requests the SAS address for the device directly attached to
+/*
+ * This function requests the SAS address for the device directly attached to
  *    this SAS port.
  * @sci_port: a handle corresponding to the SAS port for which to return the
  *    SAS address.
@@ -401,21 +401,20 @@ void scic_sds_port_get_attached_sas_address(
 	struct scic_sds_port *sci_port,
 	struct sci_sas_address *sas_address)
 {
-	struct sci_sas_identify_address_frame_protocols protocols;
-	struct scic_sds_phy *phy;
+	struct scic_sds_phy *sci_phy;
 
 	/*
 	 * Ensure that the phy is both part of the port and currently
-	 * connected to the remote end-point. */
-	phy = scic_sds_port_get_a_connected_phy(sci_port);
-	if (phy != NULL) {
-		scic_sds_phy_get_attached_phy_protocols(phy, &protocols);
-
-		if (!protocols.u.bits.stp_target) {
-			scic_sds_phy_get_attached_sas_address(phy, sas_address);
+	 * connected to the remote end-point.
+	 */
+	sci_phy = scic_sds_port_get_a_connected_phy(sci_port);
+	if (sci_phy) {
+		if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
+			scic_sds_phy_get_attached_sas_address(sci_phy,
+							      sas_address);
 		} else {
-			scic_sds_phy_get_sas_address(phy, sas_address);
-			sas_address->low += phy->phy_index;
+			scic_sds_phy_get_sas_address(sci_phy, sas_address);
+			sas_address->low += sci_phy->phy_index;
 		}
 	} else {
 		sas_address->high = 0;
@@ -424,33 +423,6 @@ void scic_sds_port_get_attached_sas_address(
 }
 
 /**
- * This method will indicate which protocols are supported by this remote
- *    device.
- * @sci_port: a handle corresponding to the SAS port for which to return the
- *    supported protocols.
- * @protocols: This parameter specifies a pointer to an IAF protocol field
- *    structure into which the core will copy the protocol values for the port.
- *     The values are returned as part of a bit mask in order to allow for
- *    multi-protocol support.
- *
- */
-static void scic_sds_port_get_attached_protocols(
-	struct scic_sds_port *sci_port,
-	struct sci_sas_identify_address_frame_protocols *protocols)
-{
-	struct scic_sds_phy *phy;
-
-	/*
-	 * Ensure that the phy is both part of the port and currently
-	 * connected to the remote end-point. */
-	phy = scic_sds_port_get_a_connected_phy(sci_port);
-	if (phy != NULL)
-		scic_sds_phy_get_attached_phy_protocols(phy, protocols);
-	else
-		protocols->u.all = 0;
-}
-
-/**
  * scic_sds_port_construct_dummy_rnc() - create dummy rnc for si workaround
  *
  * @sci_port: logical port on which we need to create the remote node context
@@ -595,7 +567,6 @@ enum sci_status scic_port_get_properties(
 	scic_sds_port_get_sas_address(port, &prop->local.sas_address);
 	scic_sds_port_get_protocols(port, &prop->local.protocols);
 	scic_sds_port_get_attached_sas_address(port, &prop->remote.sas_address);
-	scic_sds_port_get_attached_protocols(port, &prop->remote.protocols);
 
 	return SCI_SUCCESS;
 }
@@ -655,14 +626,10 @@ static void scic_sds_port_activate_phy(struct scic_sds_port *sci_port,
 				       struct scic_sds_phy *sci_phy,
 				       bool do_notify_user)
 {
-	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
-	struct sci_sas_identify_address_frame_protocols protocols;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic->ihost;
 
-	scic_sds_phy_get_attached_phy_protocols(sci_phy, &protocols);
-
-	/* If this is sata port then the phy has already been resumed */
-	if (!protocols.u.bits.stp_target)
+	if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
 		scic_sds_phy_resume(sci_phy);
 
 	sci_port->active_phy_mask |= 1 << sci_phy->phy_index;
@@ -803,15 +770,9 @@ bool scic_sds_port_link_detected(
 	struct scic_sds_port *sci_port,
 	struct scic_sds_phy *sci_phy)
 {
-	struct sci_sas_identify_address_frame_protocols protocols;
-
-	scic_sds_phy_get_attached_phy_protocols(sci_phy, &protocols);
-
-	if (
-		(sci_port->logical_port_index != SCIC_SDS_DUMMY_PORT)
-		&& (protocols.u.bits.stp_target)
-		&& scic_sds_port_is_wide(sci_port)
-		) {
+	if ((sci_port->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
+	    (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
+	    scic_sds_port_is_wide(sci_port)) {
 		scic_sds_port_invalid_link_up(sci_port, sci_phy);
 
 		return false;
diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 96a2002..2decafb 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -187,7 +187,7 @@ void isci_port_link_up(
 
 	scic_port_get_properties(port, &properties);
 
-	if (properties.remote.protocols.u.bits.stp_target) {
+	if (phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
 		u64 attached_sas_address;
 
 		isci_phy->sas_phy.oob_mode = SATA_OOB_MODE;
@@ -207,9 +207,7 @@ void isci_port_link_up(
 
 		memcpy(&isci_phy->sas_phy.attached_sas_addr,
 		       &attached_sas_address, sizeof(attached_sas_address));
-
-	} else if (properties.remote.protocols.u.bits.ssp_target ||
-		   properties.remote.protocols.u.bits.smp_target) {
+	} else if (phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
 		isci_phy->sas_phy.oob_mode = SAS_OOB_MODE;
 		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct sas_identify_frame);
 
-- 
1.6.0.2

