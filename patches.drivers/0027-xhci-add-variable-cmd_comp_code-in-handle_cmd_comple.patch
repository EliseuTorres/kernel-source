From 5e7cefc38110bcba0c2902cd6fec51a3aed629fd Mon Sep 17 00:00:00 2001
From: Xenia Ragiadakou <burzalodowa@gmail.com>
Date: Mon, 9 Sep 2013 13:29:56 +0300
Subject: [PATCH 27/50] xhci: add variable 'cmd_comp_code' in
 handle_cmd_completion()
Git-Commit: e7a79a1d6af31c050b4264099c4ab0cbee9122b8
Patch-Mainline: v3.13
References: bnc#920620

This patch adds a new variable 'cmd_comp_code' to hold the command completion
status code aiming to reduce code duplication and to improve code readability.

Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Signed-off-by: Oliver Neukum <oneukum@suse.de>
Conflicts:
	drivers/usb/host/xhci-ring.c
---
 drivers/usb/host/xhci-ring.c | 19 ++++++++-----------
 1 file changed, 8 insertions(+), 11 deletions(-)

diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 7c88bf4..8f3d9fa 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -1438,6 +1438,7 @@ static void handle_cmd_completion(struct xhci_hcd *xhci,
 	struct xhci_virt_device *virt_dev;
 	unsigned int ep_index;
 	unsigned int ep_state;
+	u32 cmd_comp_code;
 
 	cmd_dma = le64_to_cpu(event->cmd_trb);
 	cmd_dequeue_dma = xhci_trb_virt_to_dma(xhci->cmd_ring->deq_seg,
@@ -1453,16 +1454,15 @@ static void handle_cmd_completion(struct xhci_hcd *xhci,
 		return;
 	}
 
-	if ((GET_COMP_CODE(le32_to_cpu(event->status)) == COMP_CMD_ABORT) ||
-		(GET_COMP_CODE(le32_to_cpu(event->status)) == COMP_CMD_STOP)) {
+	cmd_comp_code = GET_COMP_CODE(le32_to_cpu(event->status));
+	if (cmd_comp_code == COMP_CMD_ABORT || cmd_comp_code == COMP_CMD_STOP) {
 		/* If the return value is 0, we think the trb pointed by
 		 * command ring dequeue pointer is a good trb. The good
 		 * trb means we don't want to cancel the trb, but it have
 		 * been stopped by host. So we should handle it normally.
 		 * Otherwise, driver should invoke inc_deq() and return.
 		 */
-		if (handle_stopped_cmd_ring(xhci,
-				GET_COMP_CODE(le32_to_cpu(event->status)))) {
+		if (handle_stopped_cmd_ring(xhci, cmd_comp_code)) {
 			inc_deq(xhci, xhci->cmd_ring);
 			return;
 		}
@@ -1477,8 +1477,7 @@ static void handle_cmd_completion(struct xhci_hcd *xhci,
 	switch (le32_to_cpu(xhci->cmd_ring->dequeue->generic.field[3])
 		& TRB_TYPE_BITMASK) {
 	case TRB_TYPE(TRB_ENABLE_SLOT):
-		xhci_handle_cmd_enable_slot(xhci, slot_id,
-				GET_COMP_CODE(le32_to_cpu(event->status)));
+		xhci_handle_cmd_enable_slot(xhci, slot_id, cmd_comp_code);
 		break;
 	case TRB_TYPE(TRB_DISABLE_SLOT):
 		xhci_handle_cmd_disable_slot(xhci, slot_id);
@@ -1528,16 +1527,14 @@ static void handle_cmd_completion(struct xhci_hcd *xhci,
 bandwidth_change:
 		xhci_dbg(xhci, "Completed config ep cmd\n");
 		xhci->devs[slot_id]->cmd_status =
-			GET_COMP_CODE(le32_to_cpu(event->status));
+			cmd_comp_code;
 		complete(&xhci->devs[slot_id]->cmd_completion);
 		break;
 	case TRB_TYPE(TRB_EVAL_CONTEXT):
-		xhci_handle_cmd_eval_ctx(xhci, slot_id, event,
-				GET_COMP_CODE(le32_to_cpu(event->status)));
+		xhci_handle_cmd_eval_ctx(xhci, slot_id, event, cmd_comp_code);
 		break;
 	case TRB_TYPE(TRB_ADDR_DEV):
-		xhci_handle_cmd_addr_dev(xhci, slot_id,
-				GET_COMP_CODE(le32_to_cpu(event->status)));
+		xhci_handle_cmd_addr_dev(xhci, slot_id, cmd_comp_code);
 		break;
 	case TRB_TYPE(TRB_STOP_RING):
 		handle_stopped_endpoint(xhci, xhci->cmd_ring->dequeue, event);
-- 
1.8.4.5

