From 905c27bb0de30dab178a54c06dc284177e24088a Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Wed, 17 Oct 2012 11:32:56 +0200
Subject: drm/i915: don't save/restore irq regs for kms
Git-commit: 905c27bb0de30dab178a54c06dc284177e24088a
Patch-mainline: v3.8-rc1

We already call drm_irq_install/uninstall at the right time, which
will set up the irq registers with the correct values (through the
preinstall hooks).

For kms this is at best harmless, in the worst case we get an
interrupt when we don't really expect it.

v2: Fixup the logic, noticed by Paulo Zanoni.

Reviewed-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
Tested-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/i915/i915_suspend.c |   56 ++++++++++++++++++----------------
 1 files changed, 30 insertions(+), 26 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_suspend.c b/drivers/gpu/drm/i915/i915_suspend.c
index 69b2d7f..6bd06b7 100644
--- a/drivers/gpu/drm/i915/i915_suspend.c
+++ b/drivers/gpu/drm/i915/i915_suspend.c
@@ -818,20 +818,22 @@ int i915_save_state(struct drm_device *dev)
 
 	i915_save_display(dev);
 
-	/* Interrupt state */
-	if (HAS_PCH_SPLIT(dev)) {
-		dev_priv->saveDEIER = I915_READ(DEIER);
-		dev_priv->saveDEIMR = I915_READ(DEIMR);
-		dev_priv->saveGTIER = I915_READ(GTIER);
-		dev_priv->saveGTIMR = I915_READ(GTIMR);
-		dev_priv->saveFDI_RXA_IMR = I915_READ(_FDI_RXA_IMR);
-		dev_priv->saveFDI_RXB_IMR = I915_READ(_FDI_RXB_IMR);
-		dev_priv->saveMCHBAR_RENDER_STANDBY =
-			I915_READ(RSTDBYCTL);
-		dev_priv->savePCH_PORT_HOTPLUG = I915_READ(PCH_PORT_HOTPLUG);
-	} else {
-		dev_priv->saveIER = I915_READ(IER);
-		dev_priv->saveIMR = I915_READ(IMR);
+	if (!drm_core_check_feature(dev, DRIVER_MODESET)) {
+		/* Interrupt state */
+		if (HAS_PCH_SPLIT(dev)) {
+			dev_priv->saveDEIER = I915_READ(DEIER);
+			dev_priv->saveDEIMR = I915_READ(DEIMR);
+			dev_priv->saveGTIER = I915_READ(GTIER);
+			dev_priv->saveGTIMR = I915_READ(GTIMR);
+			dev_priv->saveFDI_RXA_IMR = I915_READ(_FDI_RXA_IMR);
+			dev_priv->saveFDI_RXB_IMR = I915_READ(_FDI_RXB_IMR);
+			dev_priv->saveMCHBAR_RENDER_STANDBY =
+				I915_READ(RSTDBYCTL);
+			dev_priv->savePCH_PORT_HOTPLUG = I915_READ(PCH_PORT_HOTPLUG);
+		} else {
+			dev_priv->saveIER = I915_READ(IER);
+			dev_priv->saveIMR = I915_READ(IMR);
+		}
 	}
 
 	intel_disable_gt_powersave(dev);
@@ -869,18 +871,20 @@ int i915_restore_state(struct drm_device *dev)
 
 	i915_restore_display(dev);
 
-	/* Interrupt state */
-	if (HAS_PCH_SPLIT(dev)) {
-		I915_WRITE(DEIER, dev_priv->saveDEIER);
-		I915_WRITE(DEIMR, dev_priv->saveDEIMR);
-		I915_WRITE(GTIER, dev_priv->saveGTIER);
-		I915_WRITE(GTIMR, dev_priv->saveGTIMR);
-		I915_WRITE(_FDI_RXA_IMR, dev_priv->saveFDI_RXA_IMR);
-		I915_WRITE(_FDI_RXB_IMR, dev_priv->saveFDI_RXB_IMR);
-		I915_WRITE(PCH_PORT_HOTPLUG, dev_priv->savePCH_PORT_HOTPLUG);
-	} else {
-		I915_WRITE(IER, dev_priv->saveIER);
-		I915_WRITE(IMR, dev_priv->saveIMR);
+	if (!drm_core_check_feature(dev, DRIVER_MODESET)) {
+		/* Interrupt state */
+		if (HAS_PCH_SPLIT(dev)) {
+			I915_WRITE(DEIER, dev_priv->saveDEIER);
+			I915_WRITE(DEIMR, dev_priv->saveDEIMR);
+			I915_WRITE(GTIER, dev_priv->saveGTIER);
+			I915_WRITE(GTIMR, dev_priv->saveGTIMR);
+			I915_WRITE(_FDI_RXA_IMR, dev_priv->saveFDI_RXA_IMR);
+			I915_WRITE(_FDI_RXB_IMR, dev_priv->saveFDI_RXB_IMR);
+			I915_WRITE(PCH_PORT_HOTPLUG, dev_priv->savePCH_PORT_HOTPLUG);
+		} else {
+			I915_WRITE(IER, dev_priv->saveIER);
+			I915_WRITE(IMR, dev_priv->saveIMR);
+		}
 	}
 
 	/* Cache mode state */

