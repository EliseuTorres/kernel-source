From: Dave Airlie <airlied@redhat.com>
Date: Fri Jan 24 09:50:18 2014 +1000
Subject: drm: ast,cirrus,mgag200: use drm_can_sleep
Patch-mainline: Upstream/v3.14-rc1
Git-commit: f4b4718b61d1d5a7442a4fd6863ea80c3a10e508

References: bnc#883380, FATE#317582, bsc#935572
Signed-off-by: Egbert Eich <eich@suse.com>

these 3 were checking in_interrupt but we have situations where
calling vunmap under this could cause a BUG to be hit in
smp_call_function_many. Use the drm_can_sleep macro instead,
which should stop this path from been taken in this case.

Cc: stable@vger.kernel.org
Signed-off-by: Dave Airlie <airlied@redhat.com>
---
 drivers/gpu/drm/ast/ast_fb.c          |    2 +-
 drivers/gpu/drm/cirrus/cirrus_fbdev.c |    2 +-
 drivers/gpu/drm/mgag200/mgag200_fb.c  |    2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

--- a/drivers/gpu/drm/ast/ast_fb.c
+++ b/drivers/gpu/drm/ast/ast_fb.c
@@ -64,7 +64,7 @@ static void ast_dirty_update(struct ast_
 	 * then the BO is being moved and we should
 	 * store up the damage until later.
 	 */
-	if (!in_interrupt())
+	if (!drm_can_sleep())
 		ret = ast_bo_reserve(bo, true);
 	if (ret) {
 		if (ret != -EBUSY)
--- a/drivers/gpu/drm/cirrus/cirrus_fbdev.c
+++ b/drivers/gpu/drm/cirrus/cirrus_fbdev.c
@@ -30,7 +30,7 @@ static void cirrus_dirty_update(struct c
 	obj = afbdev->gfb.obj;
 	bo = gem_to_cirrus_bo(obj);
 
-	if (!in_interrupt())
+	if (!drm_can_sleep())
 		ret = cirrus_bo_reserve(bo, true);
 	if (ret) {
 		DRM_ERROR("failed to reserve fb bo\n");
--- a/drivers/gpu/drm/mgag200/mgag200_fb.c
+++ b/drivers/gpu/drm/mgag200/mgag200_fb.c
@@ -32,7 +32,7 @@ static void mga_dirty_update(struct mga_
 	obj = mfbdev->mfb.obj;
 	bo = gem_to_mga_bo(obj);
 
-	if (!in_interrupt())
+	if (!drm_can_sleep())
 		ret = mgag200_bo_reserve(bo, true);
 	if (ret) {
 		DRM_ERROR("failed to reserve fb bo\n");
