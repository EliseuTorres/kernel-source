From d1f257e3b7d22c74e30befeccd609e98f1b3b35a Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Fri, 16 Jul 2010 14:46:28 -0400
Patch-mainline: 2.6.36
References: fate#310916
Git-commit: b329530ca7cdf6bf014f2124efd983e01265d623
Subject: [PATCH 1025/2588] drm/i915/dp: Correctly report eDP in the core
 connector type

Do this for both real eDP and for PCH_DP_D when used as the eDP
connection.

Signed-off-by: Adam Jackson <ajax@redhat.com>
Signed-off-by: Eric Anholt <eric@anholt.net>
(cherry picked from commit b329530ca7cdf6bf014f2124efd983e01265d623)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/intel_dp.c |   26 ++++++++++++++------------
 1 files changed, 14 insertions(+), 12 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
index a06d186..016a923 100644
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -1492,6 +1492,7 @@ intel_dp_init(struct drm_device *dev, int output_reg)
 	struct intel_connector *intel_connector;
 	struct intel_dp_priv *dp_priv;
 	const char *name = NULL;
+	int type;
 
 	intel_encoder = kcalloc(sizeof(struct intel_encoder) +
 			       sizeof(struct intel_dp_priv), 1, GFP_KERNEL);
@@ -1506,18 +1507,24 @@ intel_dp_init(struct drm_device *dev, int output_reg)
 
 	dp_priv = (struct intel_dp_priv *)(intel_encoder + 1);
 
+	if (HAS_PCH_SPLIT(dev) && (output_reg == PCH_DP_D))
+		if (intel_dpd_is_edp(dev))
+			dp_priv->is_pch_edp = true;
+
+	if (output_reg == DP_A || IS_PCH_eDP(dp_priv)) {
+		type = DRM_MODE_CONNECTOR_eDP;
+		intel_encoder->type = INTEL_OUTPUT_EDP;
+	} else {
+		type = DRM_MODE_CONNECTOR_DisplayPort;
+		intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;
+	}
+
 	connector = &intel_connector->base;
-	drm_connector_init(dev, connector, &intel_dp_connector_funcs,
-			   DRM_MODE_CONNECTOR_DisplayPort);
+	drm_connector_init(dev, connector, &intel_dp_connector_funcs, type);
 	drm_connector_helper_add(connector, &intel_dp_connector_helper_funcs);
 
 	connector->polled = DRM_CONNECTOR_POLL_HPD;
 
-	if (output_reg == DP_A)
-		intel_encoder->type = INTEL_OUTPUT_EDP;
-	else
-		intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;
-
 	if (output_reg == DP_B || output_reg == PCH_DP_B)
 		intel_encoder->clone_mask = (1 << INTEL_DP_B_CLONE_BIT);
 	else if (output_reg == DP_C || output_reg == PCH_DP_C)
@@ -1528,11 +1535,6 @@ intel_dp_init(struct drm_device *dev, int output_reg)
 	if (IS_eDP(intel_encoder))
 		intel_encoder->clone_mask = (1 << INTEL_EDP_CLONE_BIT);
 
-	if (HAS_PCH_SPLIT(dev) && (output_reg == PCH_DP_D)) {
-		if (intel_dpd_is_edp(dev))
-			dp_priv->is_pch_edp = true;
-	}
-
 	intel_encoder->crtc_mask = (1 << 0) | (1 << 1);
 	connector->interlace_allowed = true;
 	connector->doublescan_allowed = 0;
-- 
1.7.6

