From bf6546b4219d2b188529f3242efda4048f5b1b41 Mon Sep 17 00:00:00 2001
From: Martin Peres <martin.peres@labri.fr>
Date: Sun, 2 Sep 2012 03:20:45 +0200
Subject: drm/nouveau/fan: rewrite the fan tachometer driver to get more
 precision, faster
Git-commit: bf6546b4219d2b188529f3242efda4048f5b1b41
Patch-mainline: v3.7-rc3

The previous driver waited for 250ms to accumulate data. This version times a
complete fan rotation and extrapolates to RPM.

The fan rotational speed should now be read in less than 250ms (worst case)
and usually in less 50ms.

Signed-off-by: Martin Peres <martin.peres@labri.fr>
Reviewed-by: Ben Skeggs <bskeggs@redhat.com>
Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/nouveau/core/subdev/therm/fan.c |   23 +++++++++++++++--------
 1 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/core/subdev/therm/fan.c b/drivers/gpu/drm/nouveau/core/subdev/therm/fan.c
index 9ad6e16..b7339b5 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/therm/fan.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/therm/fan.c
@@ -105,30 +105,37 @@ nouveau_therm_fan_sense(struct nouveau_therm *therm)
 	struct nouveau_gpio *gpio = nouveau_gpio(therm);
 	struct dcb_gpio_func func;
 	u32 cycles, cur, prev;
-	u64 start;
+	u64 start, end, tach;
 
 	if (gpio->find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff, &func))
 		return -ENODEV;
 
-	/* Monitor the GPIO input 0x3b for 250ms.
+	/* Time a complete rotation and extrapolate to RPM:
 	 * When the fan spins, it changes the value of GPIO FAN_SENSE.
-	 * We get 4 changes (0 -> 1 -> 0 -> 1 -> [...]) per complete rotation.
+	 * We get 4 changes (0 -> 1 -> 0 -> 1) per complete rotation.
 	 */
 	start = ptimer->read(ptimer);
 	prev = gpio->get(gpio, 0, func.func, func.line);
 	cycles = 0;
 	do {
+		usleep_range(500, 1000); /* supports 0 < rpm < 7500 */
+
 		cur = gpio->get(gpio, 0, func.func, func.line);
 		if (prev != cur) {
+			if (!start)
+				start = ptimer->read(ptimer);
 			cycles++;
 			prev = cur;
 		}
+	} while (cycles < 5 && ptimer->read(ptimer) - start < 250000000);
+	end = ptimer->read(ptimer);
 
-		usleep_range(500, 1000); /* supports 0 < rpm < 7500 */
-	} while (ptimer->read(ptimer) - start < 250000000);
-
-	/* interpolate to get rpm */
-	return cycles / 4 * 4 * 60;
+	if (cycles == 5) {
+		tach = (u64)60000000000;
+		do_div(tach, (end - start));
+		return tach;
+	} else
+		return 0;
 }
 
 static void

