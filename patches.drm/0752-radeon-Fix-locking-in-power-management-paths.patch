From ce3e577b7c05cdfc69abc480eb6ce7d5b756c75f Mon Sep 17 00:00:00 2001
From: Matthew Garrett <mjg@redhat.com>
Date: Tue, 27 Apr 2010 17:16:58 -0400
Patch-mainline: 2.6.35
References: fate#310916
Git-commit: 612e06ce9c78840c3a1a207dfbe489a059d87c28
Subject: [PATCH 0752/2588] radeon: Fix locking in power management paths

The ttm code could take vram_mutex followed by cp_mutex, while the
reclocking code would do the reverse. Hilarity could ensue.

Signed-off-by: Matthew Garrett <mjg@redhat.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 612e06ce9c78840c3a1a207dfbe489a059d87c28)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/radeon/radeon_pm.c |   18 ++++--------------
 1 files changed, 4 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index 7cc54c8..134b195 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
@@ -61,6 +61,8 @@ static void radeon_pm_set_clocks(struct radeon_device *rdev, int static_switch)
 	if (!static_switch)
 		radeon_get_power_state(rdev, rdev->pm.planned_action);
 
+	mutex_lock(&rdev->ddev->struct_mutex);
+	mutex_lock(&rdev->vram_mutex);
 	mutex_lock(&rdev->cp.mutex);
 
 	/* wait for GPU idle */
@@ -73,8 +75,6 @@ static void radeon_pm_set_clocks(struct radeon_device *rdev, int static_switch)
 	rdev->irq.gui_idle = false;
 	radeon_irq_set(rdev);
 
-	mutex_lock(&rdev->vram_mutex);
-
 	radeon_unmap_vram_bos(rdev);
 
 	if (!static_switch) {
@@ -97,8 +97,6 @@ static void radeon_pm_set_clocks(struct radeon_device *rdev, int static_switch)
 		}
 	}
 
-	mutex_unlock(&rdev->vram_mutex);
-	
 	/* update display watermarks based on new power state */
 	radeon_update_bandwidth_info(rdev);
 	if (rdev->pm.active_crtc_count)
@@ -107,6 +105,8 @@ static void radeon_pm_set_clocks(struct radeon_device *rdev, int static_switch)
 	rdev->pm.planned_action = PM_ACTION_NONE;
 
 	mutex_unlock(&rdev->cp.mutex);
+	mutex_unlock(&rdev->vram_mutex);
+	mutex_unlock(&rdev->ddev->struct_mutex);
 }
 
 static ssize_t radeon_get_power_state_static(struct device *dev,
@@ -134,7 +134,6 @@ static ssize_t radeon_set_power_state_static(struct device *dev,
 		return count;
 	}
 
-	mutex_lock(&rdev->ddev->struct_mutex);
 	mutex_lock(&rdev->pm.mutex);
 	if ((ps >= 0) && (ps < rdev->pm.num_power_states) &&
 	    (cm >= 0) && (cm < rdev->pm.power_state[ps].num_clock_modes)) {
@@ -152,7 +151,6 @@ static ssize_t radeon_set_power_state_static(struct device *dev,
 	} else
 		DRM_ERROR("Invalid power state: %d.%d\n\n", ps, cm);
 	mutex_unlock(&rdev->pm.mutex);
-	mutex_unlock(&rdev->ddev->struct_mutex);
 
 	return count;
 }
@@ -189,13 +187,11 @@ static ssize_t radeon_set_dynpm(struct device *dev,
 	} else if (tmp == 1) {
 		if (rdev->pm.num_power_states > 1) {
 			/* enable dynpm */
-			mutex_lock(&rdev->ddev->struct_mutex);
 			mutex_lock(&rdev->pm.mutex);
 			rdev->pm.state = PM_STATE_PAUSED;
 			rdev->pm.planned_action = PM_ACTION_DEFAULT;
 			radeon_get_power_state(rdev, rdev->pm.planned_action);
 			mutex_unlock(&rdev->pm.mutex);
-			mutex_unlock(&rdev->ddev->struct_mutex);
 			/* update power mode info */
 			radeon_pm_compute_clocks(rdev);
 			DRM_INFO("radeon: dynamic power management enabled\n");
@@ -318,11 +314,9 @@ void radeon_pm_fini(struct radeon_device *rdev)
 		   (rdev->pm.current_clock_mode_index != 0)) {
 		rdev->pm.requested_power_state_index = rdev->pm.default_power_state_index;
 		rdev->pm.requested_clock_mode_index = 0;
-		mutex_lock(&rdev->ddev->struct_mutex);
 		mutex_lock(&rdev->pm.mutex);
 		radeon_pm_set_clocks(rdev, true);
 		mutex_unlock(&rdev->pm.mutex);
-		mutex_unlock(&rdev->ddev->struct_mutex);
 	}
 
 	device_remove_file(rdev->dev, &dev_attr_power_state);
@@ -341,7 +335,6 @@ void radeon_pm_compute_clocks(struct radeon_device *rdev)
 	if (rdev->pm.state == PM_STATE_DISABLED)
 		return;
 
-	mutex_lock(&rdev->ddev->struct_mutex);
 	mutex_lock(&rdev->pm.mutex);
 
 	rdev->pm.active_crtcs = 0;
@@ -392,7 +385,6 @@ void radeon_pm_compute_clocks(struct radeon_device *rdev)
 	}
 
 	mutex_unlock(&rdev->pm.mutex);
-	mutex_unlock(&rdev->ddev->struct_mutex);
 }
 
 bool radeon_pm_debug_check_in_vbl(struct radeon_device *rdev, bool finish)
@@ -468,7 +460,6 @@ static void radeon_pm_idle_work_handler(struct work_struct *work)
 				pm.idle_work.work);
 
 	resched = ttm_bo_lock_delayed_workqueue(&rdev->mman.bdev);
-	mutex_lock(&rdev->ddev->struct_mutex);
 	mutex_lock(&rdev->pm.mutex);
 	if (rdev->pm.state == PM_STATE_ACTIVE) {
 		unsigned long irq_flags;
@@ -513,7 +504,6 @@ static void radeon_pm_idle_work_handler(struct work_struct *work)
 		}
 	}
 	mutex_unlock(&rdev->pm.mutex);
-	mutex_unlock(&rdev->ddev->struct_mutex);
 	ttm_bo_unlock_delayed_workqueue(&rdev->mman.bdev, resched);
 
 	queue_delayed_work(rdev->wq, &rdev->pm.idle_work,
-- 
1.7.6

