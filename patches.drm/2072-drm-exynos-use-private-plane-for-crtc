From b5d2eb3bd691c0b6869a2013e719a61c595d73a6 Mon Sep 17 00:00:00 2001
From: Joonyoung Shim <jy0922.shim@samsung.com>
Date: Wed, 27 Jun 2012 14:27:04 +0900
Subject: drm/exynos: use private plane for crtc
Git-commit: b5d2eb3bd691c0b6869a2013e719a61c595d73a6
Patch-mainline: v3.6-rc1

The crtc can use private plane instead it has overlay struct. It will be
helpful use plane feature from crtc later.

Signed-off-by: Joonyoung Shim <jy0922.shim@samsung.com>
Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
Signed-off-by: Inki Dae <inki.dae@samsung.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/exynos/exynos_drm_crtc.c  |   31 ++++++++++++-------------
 drivers/gpu/drm/exynos/exynos_drm_crtc.h  |    2 -
 drivers/gpu/drm/exynos/exynos_drm_drv.c   |    7 ++++-
 drivers/gpu/drm/exynos/exynos_drm_plane.c |   34 ++++++++++++++++++++--------
 drivers/gpu/drm/exynos/exynos_drm_plane.h |    4 ++-
 5 files changed, 47 insertions(+), 31 deletions(-)

diff --git a/drivers/gpu/drm/exynos/exynos_drm_crtc.c b/drivers/gpu/drm/exynos/exynos_drm_crtc.c
index a3fa7cd..eaf6fb5 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_crtc.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_crtc.c
@@ -29,11 +29,12 @@
 #include "drmP.h"
 #include "drm_crtc_helper.h"
 
-#include "exynos_drm_crtc.h"
 #include "exynos_drm_drv.h"
+#include "exynos_drm_crtc.h"
 #include "exynos_drm_fb.h"
 #include "exynos_drm_encoder.h"
 #include "exynos_drm_gem.h"
+#include "exynos_drm_plane.h"
 
 #define to_exynos_crtc(x)	container_of(x, struct exynos_drm_crtc,\
 				drm_crtc)
@@ -42,8 +43,7 @@
  * Exynos specific crtc structure.
  *
  * @drm_crtc: crtc object.
- * @overlay: contain information common to display controller and hdmi and
- *	contents of this overlay object would be copied to sub driver size.
+ * @drm_plane: pointer of private plane object for this crtc
  * @pipe: a crtc index created at load() with a new crtc object creation
  *	and the crtc object would be set to private->crtc array
  *	to get a crtc object corresponding to this pipe from private->crtc
@@ -55,7 +55,7 @@
  */
 struct exynos_drm_crtc {
 	struct drm_crtc			drm_crtc;
-	struct exynos_drm_overlay	overlay;
+	struct drm_plane		*plane;
 	unsigned int			pipe;
 	unsigned int			dpms;
 };
@@ -63,7 +63,8 @@ struct exynos_drm_crtc {
 static void exynos_drm_crtc_apply(struct drm_crtc *crtc)
 {
 	struct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);
-	struct exynos_drm_overlay *overlay = &exynos_crtc->overlay;
+	struct exynos_drm_overlay *overlay =
+		get_exynos_drm_overlay(exynos_crtc->plane);
 
 	exynos_drm_fn_encoder(crtc, overlay,
 			exynos_drm_encoder_crtc_mode_set);
@@ -141,7 +142,7 @@ static int exynos_drm_crtc_update(struct drm_crtc *crtc)
 		return -EINVAL;
 
 	exynos_crtc = to_exynos_crtc(crtc);
-	overlay = &exynos_crtc->overlay;
+	overlay = get_exynos_drm_overlay(exynos_crtc->plane);
 
 	memset(&pos, 0, sizeof(struct exynos_drm_crtc_pos));
 
@@ -250,7 +251,8 @@ exynos_drm_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode,
 			  struct drm_framebuffer *old_fb)
 {
 	struct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);
-	struct exynos_drm_overlay *overlay = &exynos_crtc->overlay;
+	struct exynos_drm_overlay *overlay =
+		get_exynos_drm_overlay(exynos_crtc->plane);
 	int pipe = exynos_crtc->pipe;
 	int ret;
 
@@ -378,14 +380,6 @@ static struct drm_crtc_funcs exynos_crtc_funcs = {
 	.destroy	= exynos_drm_crtc_destroy,
 };
 
-struct exynos_drm_overlay *get_exynos_drm_overlay(struct drm_device *dev,
-		struct drm_crtc *crtc)
-{
-	struct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);
-
-	return &exynos_crtc->overlay;
-}
-
 int exynos_drm_crtc_create(struct drm_device *dev, unsigned int nr)
 {
 	struct exynos_drm_crtc *exynos_crtc;
@@ -402,7 +396,12 @@ int exynos_drm_crtc_create(struct drm_device *dev, unsigned int nr)
 
 	exynos_crtc->pipe = nr;
 	exynos_crtc->dpms = DRM_MODE_DPMS_OFF;
-	exynos_crtc->overlay.zpos = DEFAULT_ZPOS;
+	exynos_crtc->plane = exynos_plane_init(dev, 1 << nr, true);
+	if (!exynos_crtc->plane) {
+		kfree(exynos_crtc);
+		return -ENOMEM;
+	}
+
 	crtc = &exynos_crtc->drm_crtc;
 
 	private->crtc[nr] = crtc;
diff --git a/drivers/gpu/drm/exynos/exynos_drm_crtc.h b/drivers/gpu/drm/exynos/exynos_drm_crtc.h
index 16b8e21..b1c6e83 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_crtc.h
+++ b/drivers/gpu/drm/exynos/exynos_drm_crtc.h
@@ -29,8 +29,6 @@
 #ifndef _EXYNOS_DRM_CRTC_H_
 #define _EXYNOS_DRM_CRTC_H_
 
-struct exynos_drm_overlay *get_exynos_drm_overlay(struct drm_device *dev,
-		struct drm_crtc *crtc);
 int exynos_drm_crtc_create(struct drm_device *dev, unsigned int nr);
 int exynos_drm_crtc_enable_vblank(struct drm_device *dev, int crtc);
 void exynos_drm_crtc_disable_vblank(struct drm_device *dev, int crtc);
diff --git a/drivers/gpu/drm/exynos/exynos_drm_drv.c b/drivers/gpu/drm/exynos/exynos_drm_drv.c
index d6de2e0..e313dc2 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_drv.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_drv.c
@@ -85,8 +85,11 @@ static int exynos_drm_load(struct drm_device *dev, unsigned long flags)
 	}
 
 	for (nr = 0; nr < MAX_PLANE; nr++) {
-		ret = exynos_plane_init(dev, nr);
-		if (ret)
+		struct drm_plane *plane;
+		unsigned int possible_crtcs = (1 << MAX_CRTC) - 1;
+
+		plane = exynos_plane_init(dev, possible_crtcs, false);
+		if (!plane)
 			goto err_crtc;
 	}
 
diff --git a/drivers/gpu/drm/exynos/exynos_drm_plane.c b/drivers/gpu/drm/exynos/exynos_drm_plane.c
index 17510f5..9ef5b8c 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_plane.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_plane.c
@@ -12,8 +12,8 @@
 #include "drmP.h"
 
 #include "exynos_drm.h"
-#include "exynos_drm_crtc.h"
 #include "exynos_drm_drv.h"
+#include "exynos_drm_crtc.h"
 #include "exynos_drm_encoder.h"
 
 #define to_exynos_plane(x)	container_of(x, struct exynos_plane, base)
@@ -108,23 +108,30 @@ static struct drm_plane_funcs exynos_plane_funcs = {
 	.destroy	= exynos_plane_destroy,
 };
 
-int exynos_plane_init(struct drm_device *dev, unsigned int nr)
+struct drm_plane *exynos_plane_init(struct drm_device *dev,
+				    unsigned int possible_crtcs, bool priv)
 {
 	struct exynos_plane *exynos_plane;
-	uint32_t possible_crtcs;
+	int err;
 
 	exynos_plane = kzalloc(sizeof(struct exynos_plane), GFP_KERNEL);
-	if (!exynos_plane)
-		return -ENOMEM;
-
-	/* all CRTCs are available */
-	possible_crtcs = (1 << MAX_CRTC) - 1;
+	if (!exynos_plane) {
+		DRM_ERROR("failed to allocate plane\n");
+		return NULL;
+	}
 
 	exynos_plane->overlay.zpos = DEFAULT_ZPOS;
 
-	return drm_plane_init(dev, &exynos_plane->base, possible_crtcs,
+	err = drm_plane_init(dev, &exynos_plane->base, possible_crtcs,
 			      &exynos_plane_funcs, formats, ARRAY_SIZE(formats),
-			      false);
+			      priv);
+	if (err) {
+		DRM_ERROR("failed to initialize plane\n");
+		kfree(exynos_plane);
+		return NULL;
+	}
+
+	return &exynos_plane->base;
 }
 
 int exynos_plane_set_zpos_ioctl(struct drm_device *dev, void *data,
@@ -168,3 +175,10 @@ out:
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
+
+struct exynos_drm_overlay *get_exynos_drm_overlay(struct drm_plane *plane)
+{
+	struct exynos_plane *exynos_plane = to_exynos_plane(plane);
+
+	return &exynos_plane->overlay;
+}
diff --git a/drivers/gpu/drm/exynos/exynos_drm_plane.h b/drivers/gpu/drm/exynos/exynos_drm_plane.h
index 16b71f8..d0529181 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_plane.h
+++ b/drivers/gpu/drm/exynos/exynos_drm_plane.h
@@ -9,6 +9,8 @@
  *
  */
 
-int exynos_plane_init(struct drm_device *dev, unsigned int nr);
+struct drm_plane *exynos_plane_init(struct drm_device *dev,
+				    unsigned int possible_crtcs, bool priv);
 int exynos_plane_set_zpos_ioctl(struct drm_device *dev, void *data,
 				struct drm_file *file_priv);
+struct exynos_drm_overlay *get_exynos_drm_overlay(struct drm_plane *plane);

