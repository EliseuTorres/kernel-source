From 7739c33ba48174204b24c1b867b455318e752787 Mon Sep 17 00:00:00 2001
From: Paulo Zanoni <paulo.r.zanoni@intel.com>
Date: Mon, 15 Oct 2012 15:51:29 -0300
Subject: drm/i915: add DP support to intel_ddi_enable_pipe_func
Git-commit: 7739c33ba48174204b24c1b867b455318e752787
Patch-mainline: v3.8-rc1

Signed-off-by: Paulo Zanoni <paulo.r.zanoni@intel.com>
Reviewed-by: Jani Nikula <jani.nikula@intel.com>
Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/i915/intel_ddi.c |   34 ++++++++++++++++++++++++++++++----
 drivers/gpu/drm/i915/intel_dp.c  |    5 -----
 drivers/gpu/drm/i915/intel_drv.h |    5 +++++
 3 files changed, 35 insertions(+), 9 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_ddi.c b/drivers/gpu/drm/i915/intel_ddi.c
index a78860a..9659c227 100644
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@ -831,8 +831,10 @@ void intel_ddi_enable_pipe_func(struct drm_crtc *crtc)
 {
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 	struct intel_encoder *intel_encoder = intel_ddi_get_crtc_encoder(crtc);
+	struct drm_encoder *encoder = &intel_encoder->base;
 	struct drm_i915_private *dev_priv = crtc->dev->dev_private;
 	enum pipe pipe = intel_crtc->pipe;
+	int type = intel_encoder->type;
 	uint32_t temp;
 
 	/* Enable PIPE_DDI_FUNC_CTL for the pipe to work in HDMI mode */
@@ -861,9 +863,8 @@ void intel_ddi_enable_pipe_func(struct drm_crtc *crtc)
 	if (crtc->mode.flags & DRM_MODE_FLAG_PHSYNC)
 		temp |= PIPE_DDI_PHSYNC;
 
-	if (intel_encoder->type == INTEL_OUTPUT_HDMI) {
-		struct intel_hdmi *intel_hdmi =
-			enc_to_intel_hdmi(&intel_encoder->base);
+	if (type == INTEL_OUTPUT_HDMI) {
+		struct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);
 
 		if (intel_hdmi->has_hdmi_sink)
 			temp |= PIPE_DDI_MODE_SELECT_HDMI;
@@ -871,9 +872,34 @@ void intel_ddi_enable_pipe_func(struct drm_crtc *crtc)
 			temp |= PIPE_DDI_MODE_SELECT_DVI;
 
 		temp |= PIPE_DDI_SELECT_PORT(intel_hdmi->ddi_port);
-	} else if (intel_encoder->type == INTEL_OUTPUT_ANALOG) {
+
+	} else if (type == INTEL_OUTPUT_ANALOG) {
 		temp |= PIPE_DDI_MODE_SELECT_FDI;
 		temp |= PIPE_DDI_SELECT_PORT(PORT_E);
+
+	} else if (type == INTEL_OUTPUT_DISPLAYPORT ||
+		   type == INTEL_OUTPUT_EDP) {
+		struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
+
+		temp |= PIPE_DDI_MODE_SELECT_DP_SST;
+		temp |= PIPE_DDI_SELECT_PORT(intel_dp->port);
+
+		switch (intel_dp->lane_count) {
+		case 1:
+			temp |= PIPE_DDI_PORT_WIDTH_X1;
+			break;
+		case 2:
+			temp |= PIPE_DDI_PORT_WIDTH_X2;
+			break;
+		case 4:
+			temp |= PIPE_DDI_PORT_WIDTH_X4;
+			break;
+		default:
+			temp |= PIPE_DDI_PORT_WIDTH_X4;
+			WARN(1, "Unsupported lane count %d\n",
+			     intel_dp->lane_count);
+		}
+
 	} else {
 		WARN(1, "Invalid encoder type %d for pipe %d\n",
 		     intel_encoder->type, pipe);
diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
index fcce392..871bc17 100644
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -77,11 +77,6 @@ static bool is_cpu_edp(struct intel_dp *intel_dp)
 	return is_edp(intel_dp) && !is_pch_edp(intel_dp);
 }
 
-static struct intel_dp *enc_to_intel_dp(struct drm_encoder *encoder)
-{
-	return container_of(encoder, struct intel_dp, base.base);
-}
-
 static struct intel_dp *intel_attached_dp(struct drm_connector *connector)
 {
 	return container_of(intel_attached_encoder(connector),
diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h
index 245319a..7e1e670 100644
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -474,6 +474,11 @@ static inline struct intel_encoder *intel_attached_encoder(struct drm_connector
 	return to_intel_connector(connector)->encoder;
 }
 
+static inline struct intel_dp *enc_to_intel_dp(struct drm_encoder *encoder)
+{
+	return container_of(encoder, struct intel_dp, base.base);
+}
+
 extern void intel_connector_attach_encoder(struct intel_connector *connector,
 					   struct intel_encoder *encoder);
 extern struct drm_encoder *intel_best_encoder(struct drm_connector *connector);

