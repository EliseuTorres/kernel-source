From c4afbe74cebf887d3d8e7a11aa93bebcb6a3e2e1 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Sat, 4 Aug 2012 18:26:50 +1000
Subject: drm/nvc0-/gr: share headers between fermi and kepler graphics code
Git-commit: c4afbe74cebf887d3d8e7a11aa93bebcb6a3e2e1
Patch-mainline: v3.7-rc3

v2: Ben Skeggs <bskeggs@redhat.com>
- de-inline nv_icmd, triggers some gcc issue causing ctxnv[ce]0.c to
  take a *very* *very* long time to build on some configs.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 .../gpu/drm/nouveau/core/engine/graph/ctxnvc0.c    |   49 +++++------
 .../gpu/drm/nouveau/core/engine/graph/ctxnve0.c    |   21 +----
 drivers/gpu/drm/nouveau/core/engine/graph/nvc0.c   |   58 ++++++------
 drivers/gpu/drm/nouveau/core/engine/graph/nvc0.h   |   85 +++++++++++++++---
 drivers/gpu/drm/nouveau/core/engine/graph/nve0.c   |   40 ++++----
 drivers/gpu/drm/nouveau/core/engine/graph/nve0.h   |   94 --------------------
 6 files changed, 143 insertions(+), 204 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/core/engine/graph/ctxnvc0.c b/drivers/gpu/drm/nouveau/core/engine/graph/ctxnvc0.c
index af6167a..5735301 100644
--- a/drivers/gpu/drm/nouveau/core/engine/graph/ctxnvc0.c
+++ b/drivers/gpu/drm/nouveau/core/engine/graph/ctxnvc0.c
@@ -27,7 +27,7 @@
 #include <core/mm.h>
 #include "nvc0.h"
 
-static void
+void
 nv_icmd(struct drm_device *priv, u32 icmd, u32 data)
 {
 	nv_wr32(priv, 0x400204, data);
@@ -36,13 +36,6 @@ nv_icmd(struct drm_device *priv, u32 icmd, u32 data)
 }
 
 static void
-nv_mthd(struct drm_device *priv, u32 class, u32 mthd, u32 data)
-{
-	nv_wr32(priv, 0x40448c, data);
-	nv_wr32(priv, 0x404488, 0x80000000 | (mthd << 14) | class);
-}
-
-static void
 nvc0_grctx_generate_9097(struct drm_device *priv)
 {
 	u32 fermi = nvc0_graph_class(priv);
@@ -1823,22 +1816,22 @@ nvc0_grctx_generate(struct nouveau_channel *chan)
 
 	for (tp = 0, id = 0; tp < 4; tp++) {
 		for (gpc = 0; gpc < oprv->gpc_nr; gpc++) {
-			if (tp < oprv->tp_nr[gpc]) {
-				nv_wr32(priv, TP_UNIT(gpc, tp, 0x698), id);
-				nv_wr32(priv, TP_UNIT(gpc, tp, 0x4e8), id);
+			if (tp < oprv->tpc_nr[gpc]) {
+				nv_wr32(priv, TPC_UNIT(gpc, tp, 0x698), id);
+				nv_wr32(priv, TPC_UNIT(gpc, tp, 0x4e8), id);
 				nv_wr32(priv, GPC_UNIT(gpc, 0x0c10 + tp * 4), id);
-				nv_wr32(priv, TP_UNIT(gpc, tp, 0x088), id);
+				nv_wr32(priv, TPC_UNIT(gpc, tp, 0x088), id);
 				id++;
 			}
 
-			nv_wr32(priv, GPC_UNIT(gpc, 0x0c08), oprv->tp_nr[gpc]);
-			nv_wr32(priv, GPC_UNIT(gpc, 0x0c8c), oprv->tp_nr[gpc]);
+			nv_wr32(priv, GPC_UNIT(gpc, 0x0c08), oprv->tpc_nr[gpc]);
+			nv_wr32(priv, GPC_UNIT(gpc, 0x0c8c), oprv->tpc_nr[gpc]);
 		}
 	}
 
 	tmp = 0;
 	for (i = 0; i < oprv->gpc_nr; i++)
-		tmp |= oprv->tp_nr[i] << (i * 4);
+		tmp |= oprv->tpc_nr[i] << (i * 4);
 	nv_wr32(priv, 0x406028, tmp);
 	nv_wr32(priv, 0x405870, tmp);
 
@@ -1850,13 +1843,13 @@ nvc0_grctx_generate(struct nouveau_channel *chan)
 	nv_wr32(priv, 0x40587c, 0x00000000);
 
 	if (1) {
-		u8 tpnr[GPC_MAX], data[TP_MAX];
+		u8 tpnr[GPC_MAX], data[TPC_MAX];
 
-		memcpy(tpnr, oprv->tp_nr, sizeof(oprv->tp_nr));
+		memcpy(tpnr, oprv->tpc_nr, sizeof(oprv->tpc_nr));
 		memset(data, 0x1f, sizeof(data));
 
 		gpc = -1;
-		for (tp = 0; tp < oprv->tp_total; tp++) {
+		for (tp = 0; tp < oprv->tpc_total; tp++) {
 			do {
 				gpc = (gpc + 1) % oprv->gpc_nr;
 			} while (!tpnr[gpc]);
@@ -1874,10 +1867,10 @@ nvc0_grctx_generate(struct nouveau_channel *chan)
 		u8 shift, ntpcv;
 
 		/* calculate first set of magics */
-		memcpy(tpnr, oprv->tp_nr, sizeof(oprv->tp_nr));
+		memcpy(tpnr, oprv->tpc_nr, sizeof(oprv->tpc_nr));
 
 		gpc = -1;
-		for (tp = 0; tp < oprv->tp_total; tp++) {
+		for (tp = 0; tp < oprv->tpc_total; tp++) {
 			do {
 				gpc = (gpc + 1) % oprv->gpc_nr;
 			} while (!tpnr[gpc]);
@@ -1891,7 +1884,7 @@ nvc0_grctx_generate(struct nouveau_channel *chan)
 
 		/* and the second... */
 		shift = 0;
-		ntpcv = oprv->tp_total;
+		ntpcv = oprv->tpc_total;
 		while (!(ntpcv & (1 << 4))) {
 			ntpcv <<= 1;
 			shift++;
@@ -1904,13 +1897,13 @@ nvc0_grctx_generate(struct nouveau_channel *chan)
 			data2[1] |= ((1 << (i + 5)) % ntpcv) << ((i - 1) * 5);
 
 		/* GPC_BROADCAST */
-		nv_wr32(priv, 0x418bb8, (oprv->tp_total << 8) |
+		nv_wr32(priv, 0x418bb8, (oprv->tpc_total << 8) |
 					oprv->magic_not_rop_nr);
 		for (i = 0; i < 6; i++)
 			nv_wr32(priv, 0x418b08 + (i * 4), data[i]);
 
 		/* GPC_BROADCAST.TP_BROADCAST */
-		nv_wr32(priv, 0x419bd0, (oprv->tp_total << 8) |
+		nv_wr32(priv, 0x419bd0, (oprv->tpc_total << 8) |
 				       oprv->magic_not_rop_nr |
 				       data2[0]);
 		nv_wr32(priv, 0x419be4, data2[1]);
@@ -1918,7 +1911,7 @@ nvc0_grctx_generate(struct nouveau_channel *chan)
 			nv_wr32(priv, 0x419b00 + (i * 4), data[i]);
 
 		/* UNK78xx */
-		nv_wr32(priv, 0x4078bc, (oprv->tp_total << 8) |
+		nv_wr32(priv, 0x4078bc, (oprv->tpc_total << 8) |
 					oprv->magic_not_rop_nr);
 		for (i = 0; i < 6; i++)
 			nv_wr32(priv, 0x40780c + (i * 4), data[i]);
@@ -1928,18 +1921,18 @@ nvc0_grctx_generate(struct nouveau_channel *chan)
 		u32 tp_mask = 0, tp_set = 0;
 		u8  tpnr[GPC_MAX], a, b;
 
-		memcpy(tpnr, oprv->tp_nr, sizeof(oprv->tp_nr));
+		memcpy(tpnr, oprv->tpc_nr, sizeof(oprv->tpc_nr));
 		for (gpc = 0; gpc < oprv->gpc_nr; gpc++)
-			tp_mask |= ((1 << oprv->tp_nr[gpc]) - 1) << (gpc * 8);
+			tp_mask |= ((1 << oprv->tpc_nr[gpc]) - 1) << (gpc * 8);
 
 		for (i = 0, gpc = -1, b = -1; i < 32; i++) {
-			a = (i * (oprv->tp_total - 1)) / 32;
+			a = (i * (oprv->tpc_total - 1)) / 32;
 			if (a != b) {
 				b = a;
 				do {
 					gpc = (gpc + 1) % oprv->gpc_nr;
 				} while (!tpnr[gpc]);
-				tp = oprv->tp_nr[gpc] - tpnr[gpc]--;
+				tp = oprv->tpc_nr[gpc] - tpnr[gpc]--;
 
 				tp_set |= 1 << ((gpc * 8) + tp);
 			}
diff --git a/drivers/gpu/drm/nouveau/core/engine/graph/ctxnve0.c b/drivers/gpu/drm/nouveau/core/engine/graph/ctxnve0.c
index f03c667..47bea8a 100644
--- a/drivers/gpu/drm/nouveau/core/engine/graph/ctxnve0.c
+++ b/drivers/gpu/drm/nouveau/core/engine/graph/ctxnve0.c
@@ -25,15 +25,7 @@
 #include "drmP.h"
 #include "nouveau_drv.h"
 #include <core/mm.h>
-#include "nve0.h"
-
-static void
-nv_icmd(struct drm_device *priv, u32 icmd, u32 data)
-{
-	nv_wr32(priv, 0x400204, data);
-	nv_wr32(priv, 0x400200, icmd);
-	while (nv_rd32(priv, 0x400700) & 0x00000002) {}
-}
+#include "nvc0.h"
 
 static void
 nve0_grctx_generate_icmd(struct drm_device *priv)
@@ -924,13 +916,6 @@ nve0_grctx_generate_icmd(struct drm_device *priv)
 }
 
 static void
-nv_mthd(struct drm_device *priv, u32 class, u32 mthd, u32 data)
-{
-	nv_wr32(priv, 0x40448c, data);
-	nv_wr32(priv, 0x404488, 0x80000000 | (mthd << 14) | class);
-}
-
-static void
 nve0_grctx_generate_a097(struct drm_device *priv)
 {
 	nv_mthd(priv, 0xa097, 0x0800, 0x00000000);
@@ -2621,8 +2606,8 @@ nve0_graph_generate_tpcunk(struct drm_device *priv)
 int
 nve0_grctx_generate(struct nouveau_channel *chan)
 {
-	struct nve0_graph_priv *oprv = nv_engine(chan->dev, NVOBJ_ENGINE_GR);
-	struct nve0_graph_chan *grch = chan->engctx[NVOBJ_ENGINE_GR];
+	struct nvc0_graph_priv *oprv = nv_engine(chan->dev, NVOBJ_ENGINE_GR);
+	struct nvc0_graph_chan *grch = chan->engctx[NVOBJ_ENGINE_GR];
 	struct drm_device *priv = chan->dev;
 	u32 data[6] = {}, data2[2] = {}, tmp;
 	u32 tpc_set = 0, tpc_mask = 0;
diff --git a/drivers/gpu/drm/nouveau/core/engine/graph/nvc0.c b/drivers/gpu/drm/nouveau/core/engine/graph/nvc0.c
index b741b03..158d576 100644
--- a/drivers/gpu/drm/nouveau/core/engine/graph/nvc0.c
+++ b/drivers/gpu/drm/nouveau/core/engine/graph/nvc0.c
@@ -229,8 +229,8 @@ nvc0_graph_create_context_mmio_list(struct nouveau_channel *chan)
 		nv_wo32(grch->mmio, i++ * 4, 0x00405830);
 		nv_wo32(grch->mmio, i++ * 4, magic);
 		for (gpc = 0; gpc < priv->gpc_nr; gpc++) {
-			for (tp = 0; tp < priv->tp_nr[gpc]; tp++) {
-				u32 reg = TP_UNIT(gpc, tp, 0x520);
+			for (tp = 0; tp < priv->tpc_nr[gpc]; tp++) {
+				u32 reg = TPC_UNIT(gpc, tp, 0x520);
 				nv_wo32(grch->mmio, i++ * 4, reg);
 				nv_wo32(grch->mmio, i++ * 4, magic);
 				magic += 0x0324;
@@ -243,14 +243,14 @@ nvc0_graph_create_context_mmio_list(struct nouveau_channel *chan)
 		nv_wo32(grch->mmio, i++ * 4, 0x004064c4);
 		nv_wo32(grch->mmio, i++ * 4, 0x0086ffff);
 		for (gpc = 0; gpc < priv->gpc_nr; gpc++) {
-			for (tp = 0; tp < priv->tp_nr[gpc]; tp++) {
-				u32 reg = TP_UNIT(gpc, tp, 0x520);
+			for (tp = 0; tp < priv->tpc_nr[gpc]; tp++) {
+				u32 reg = TPC_UNIT(gpc, tp, 0x520);
 				nv_wo32(grch->mmio, i++ * 4, reg);
 				nv_wo32(grch->mmio, i++ * 4, (1 << 28) | magic);
 				magic += 0x0324;
 			}
-			for (tp = 0; tp < priv->tp_nr[gpc]; tp++) {
-				u32 reg = TP_UNIT(gpc, tp, 0x544);
+			for (tp = 0; tp < priv->tpc_nr[gpc]; tp++) {
+				u32 reg = TPC_UNIT(gpc, tp, 0x544);
 				nv_wo32(grch->mmio, i++ * 4, reg);
 				nv_wo32(grch->mmio, i++ * 4, magic);
 				magic += 0x0324;
@@ -393,12 +393,12 @@ static void
 nvc0_graph_init_gpc_0(struct drm_device *dev)
 {
 	struct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
-	const u32 magicgpc918 = DIV_ROUND_UP(0x00800000, priv->tp_total);
-	u32 data[TP_MAX / 8];
+	const u32 magicgpc918 = DIV_ROUND_UP(0x00800000, priv->tpc_total);
+	u32 data[TPC_MAX / 8];
 	u8  tpnr[GPC_MAX];
 	int i, gpc, tpc;
 
-	nv_wr32(dev, TP_UNIT(0, 0, 0x5c), 1); /* affects TFB offset queries */
+	nv_wr32(dev, TPC_UNIT(0, 0, 0x5c), 1); /* affects TFB offset queries */
 
 	/*
 	 *      TP      ROP UNKVAL(magic_not_rop_nr)
@@ -410,12 +410,12 @@ nvc0_graph_init_gpc_0(struct drm_device *dev)
 	 */
 
 	memset(data, 0x00, sizeof(data));
-	memcpy(tpnr, priv->tp_nr, sizeof(priv->tp_nr));
-	for (i = 0, gpc = -1; i < priv->tp_total; i++) {
+	memcpy(tpnr, priv->tpc_nr, sizeof(priv->tpc_nr));
+	for (i = 0, gpc = -1; i < priv->tpc_total; i++) {
 		do {
 			gpc = (gpc + 1) % priv->gpc_nr;
 		} while (!tpnr[gpc]);
-		tpc = priv->tp_nr[gpc] - tpnr[gpc]--;
+		tpc = priv->tpc_nr[gpc] - tpnr[gpc]--;
 
 		data[i / 8] |= tpc << ((i % 8) * 4);
 	}
@@ -427,8 +427,8 @@ nvc0_graph_init_gpc_0(struct drm_device *dev)
 
 	for (gpc = 0; gpc < priv->gpc_nr; gpc++) {
 		nv_wr32(dev, GPC_UNIT(gpc, 0x0914), priv->magic_not_rop_nr << 8 |
-						  priv->tp_nr[gpc]);
-		nv_wr32(dev, GPC_UNIT(gpc, 0x0910), 0x00040000 | priv->tp_total);
+						  priv->tpc_nr[gpc]);
+		nv_wr32(dev, GPC_UNIT(gpc, 0x0910), 0x00040000 | priv->tpc_total);
 		nv_wr32(dev, GPC_UNIT(gpc, 0x0918), magicgpc918);
 	}
 
@@ -463,14 +463,14 @@ nvc0_graph_init_gpc_1(struct drm_device *dev)
 		nv_wr32(dev, GPC_UNIT(gpc, 0x0900), 0xc0000000);
 		nv_wr32(dev, GPC_UNIT(gpc, 0x1028), 0xc0000000);
 		nv_wr32(dev, GPC_UNIT(gpc, 0x0824), 0xc0000000);
-		for (tp = 0; tp < priv->tp_nr[gpc]; tp++) {
-			nv_wr32(dev, TP_UNIT(gpc, tp, 0x508), 0xffffffff);
-			nv_wr32(dev, TP_UNIT(gpc, tp, 0x50c), 0xffffffff);
-			nv_wr32(dev, TP_UNIT(gpc, tp, 0x224), 0xc0000000);
-			nv_wr32(dev, TP_UNIT(gpc, tp, 0x48c), 0xc0000000);
-			nv_wr32(dev, TP_UNIT(gpc, tp, 0x084), 0xc0000000);
-			nv_wr32(dev, TP_UNIT(gpc, tp, 0x644), 0x001ffffe);
-			nv_wr32(dev, TP_UNIT(gpc, tp, 0x64c), 0x0000000f);
+		for (tp = 0; tp < priv->tpc_nr[gpc]; tp++) {
+			nv_wr32(dev, TPC_UNIT(gpc, tp, 0x508), 0xffffffff);
+			nv_wr32(dev, TPC_UNIT(gpc, tp, 0x50c), 0xffffffff);
+			nv_wr32(dev, TPC_UNIT(gpc, tp, 0x224), 0xc0000000);
+			nv_wr32(dev, TPC_UNIT(gpc, tp, 0x48c), 0xc0000000);
+			nv_wr32(dev, TPC_UNIT(gpc, tp, 0x084), 0xc0000000);
+			nv_wr32(dev, TPC_UNIT(gpc, tp, 0x644), 0x001ffffe);
+			nv_wr32(dev, TPC_UNIT(gpc, tp, 0x64c), 0x0000000f);
 		}
 		nv_wr32(dev, GPC_UNIT(gpc, 0x2c90), 0xffffffff);
 		nv_wr32(dev, GPC_UNIT(gpc, 0x2c94), 0xffffffff);
@@ -858,20 +858,20 @@ nvc0_graph_create(struct drm_device *dev)
 	priv->gpc_nr  =  nv_rd32(dev, 0x409604) & 0x0000001f;
 	priv->rop_nr = (nv_rd32(dev, 0x409604) & 0x001f0000) >> 16;
 	for (gpc = 0; gpc < priv->gpc_nr; gpc++) {
-		priv->tp_nr[gpc] = nv_rd32(dev, GPC_UNIT(gpc, 0x2608));
-		priv->tp_total += priv->tp_nr[gpc];
+		priv->tpc_nr[gpc] = nv_rd32(dev, GPC_UNIT(gpc, 0x2608));
+		priv->tpc_total += priv->tpc_nr[gpc];
 	}
 
 	/*XXX: these need figuring out... */
 	switch (dev_priv->chipset) {
 	case 0xc0:
-		if (priv->tp_total == 11) { /* 465, 3/4/4/0, 4 */
+		if (priv->tpc_total == 11) { /* 465, 3/4/4/0, 4 */
 			priv->magic_not_rop_nr = 0x07;
 		} else
-		if (priv->tp_total == 14) { /* 470, 3/3/4/4, 5 */
+		if (priv->tpc_total == 14) { /* 470, 3/3/4/4, 5 */
 			priv->magic_not_rop_nr = 0x05;
 		} else
-		if (priv->tp_total == 15) { /* 480, 3/4/4/4, 6 */
+		if (priv->tpc_total == 15) { /* 480, 3/4/4/4, 6 */
 			priv->magic_not_rop_nr = 0x06;
 		}
 		break;
@@ -900,8 +900,8 @@ nvc0_graph_create(struct drm_device *dev)
 
 	if (!priv->magic_not_rop_nr) {
 		NV_ERROR(dev, "PGRAPH: unknown config: %d/%d/%d/%d, %d\n",
-			 priv->tp_nr[0], priv->tp_nr[1], priv->tp_nr[2],
-			 priv->tp_nr[3], priv->rop_nr);
+			 priv->tpc_nr[0], priv->tpc_nr[1], priv->tpc_nr[2],
+			 priv->tpc_nr[3], priv->rop_nr);
 		priv->magic_not_rop_nr = 0x00;
 	}
 
diff --git a/drivers/gpu/drm/nouveau/core/engine/graph/nvc0.h b/drivers/gpu/drm/nouveau/core/engine/graph/nvc0.h
index ffeb4a0..ba9b80f 100644
--- a/drivers/gpu/drm/nouveau/core/engine/graph/nvc0.h
+++ b/drivers/gpu/drm/nouveau/core/engine/graph/nvc0.h
@@ -26,13 +26,26 @@
 #define __NVC0_GRAPH_H__
 
 #define GPC_MAX 4
-#define TP_MAX 32
+#define TPC_MAX 32
 
-#define ROP_BCAST(r)     (0x408800 + (r))
-#define ROP_UNIT(u, r)   (0x410000 + (u) * 0x400 + (r))
-#define GPC_BCAST(r)     (0x418000 + (r))
-#define GPC_UNIT(t, r)   (0x500000 + (t) * 0x8000 + (r))
-#define TP_UNIT(t, m, r) (0x504000 + (t) * 0x8000 + (m) * 0x800 + (r))
+#define ROP_BCAST(r)      (0x408800 + (r))
+#define ROP_UNIT(u, r)    (0x410000 + (u) * 0x400 + (r))
+#define GPC_BCAST(r)      (0x418000 + (r))
+#define GPC_UNIT(t, r)    (0x500000 + (t) * 0x8000 + (r))
+#define TPC_UNIT(t, m, r) (0x504000 + (t) * 0x8000 + (m) * 0x800 + (r))
+
+struct nvc0_graph_data {
+	u32 size;
+	u32 align;
+	u32 access;
+};
+
+struct nvc0_graph_mmio {
+	u32 addr;
+	u32 data;
+	u32 shift;
+	u32 buffer;
+};
 
 struct nvc0_graph_fuc {
 	u32 *data;
@@ -46,11 +59,12 @@ struct nvc0_graph_priv {
 	struct nvc0_graph_fuc fuc409d;
 	struct nvc0_graph_fuc fuc41ac;
 	struct nvc0_graph_fuc fuc41ad;
+	bool firmware;
 
-	u8 gpc_nr;
 	u8 rop_nr;
-	u8 tp_nr[GPC_MAX];
-	u8 tp_total;
+	u8 gpc_nr;
+	u8 tpc_nr[GPC_MAX];
+	u8 tpc_total;
 
 	u32  grctx_size;
 	u32 *grctx_vals;
@@ -63,24 +77,22 @@ struct nvc0_graph_priv {
 struct nvc0_graph_chan {
 	struct nouveau_gpuobj *grctx;
 	struct nouveau_vma     grctx_vma;
-	struct nouveau_gpuobj *unk408004; /* 0x418810 too */
+	struct nouveau_gpuobj *unk408004; /* 0x418808 too */
 	struct nouveau_vma     unk408004_vma;
 	struct nouveau_gpuobj *unk40800c; /* 0x419004 too */
 	struct nouveau_vma     unk40800c_vma;
 	struct nouveau_gpuobj *unk418810; /* 0x419848 too */
 	struct nouveau_vma     unk418810_vma;
+
 	struct nouveau_gpuobj *mmio;
 	struct nouveau_vma     mmio_vma;
 	int mmio_nr;
 };
 
-int nvc0_grctx_generate(struct nouveau_channel *);
-
-/* nvc0_graph.c uses this also to determine supported chipsets */
 static inline u32
-nvc0_graph_class(struct drm_device *dev)
+nvc0_graph_class(struct drm_device *priv)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct drm_nouveau_private *dev_priv = priv->dev_private;
 
 	switch (dev_priv->chipset) {
 	case 0xc0:
@@ -94,9 +106,52 @@ nvc0_graph_class(struct drm_device *dev)
 	case 0xc8:
 	case 0xd9:
 		return 0x9297;
+	case 0xe4:
+	case 0xe7:
+		return 0xa097;
 	default:
 		return 0;
 	}
 }
 
+void nv_icmd(struct drm_device *priv, u32 icmd, u32 data);
+
+static inline void
+nv_mthd(struct drm_device *priv, u32 class, u32 mthd, u32 data)
+{
+	nv_wr32(priv, 0x40448c, data);
+	nv_wr32(priv, 0x404488, 0x80000000 | (mthd << 14) | class);
+}
+
+struct nvc0_grctx {
+	struct nvc0_graph_priv *priv;
+	struct nvc0_graph_data *data;
+	struct nvc0_graph_mmio *mmio;
+	struct nouveau_gpuobj *chan;
+	int buffer_nr;
+	u64 buffer[4];
+	u64 addr;
+};
+
+int  nvc0_grctx_generate(struct nouveau_channel *);
+int  nvc0_grctx_init(struct nvc0_graph_priv *, struct nvc0_grctx *);
+void nvc0_grctx_data(struct nvc0_grctx *, u32, u32, u32);
+void nvc0_grctx_mmio(struct nvc0_grctx *, u32, u32, u32, u32);
+int  nvc0_grctx_fini(struct nvc0_grctx *);
+
+int  nve0_grctx_generate(struct nouveau_channel *);
+
+#define mmio_data(s,a,p) nvc0_grctx_data(&info, (s), (a), (p))
+#define mmio_list(r,d,s,b) nvc0_grctx_mmio(&info, (r), (d), (s), (b))
+
+int  nvc0_graph_ctor_fw(struct nvc0_graph_priv *, const char *,
+			struct nvc0_graph_fuc *);
+void nvc0_graph_dtor(struct nouveau_object *);
+void nvc0_graph_init_fw(struct nvc0_graph_priv *, u32 base,
+			struct nvc0_graph_fuc *, struct nvc0_graph_fuc *);
+int  nvc0_graph_context_ctor(struct nouveau_object *, struct nouveau_object *,
+			     struct nouveau_oclass *, void *, u32,
+			     struct nouveau_object **);
+void nvc0_graph_context_dtor(struct nouveau_object *);
+
 #endif
diff --git a/drivers/gpu/drm/nouveau/core/engine/graph/nve0.c b/drivers/gpu/drm/nouveau/core/engine/graph/nve0.c
index 47bda63..2bd55d8 100644
--- a/drivers/gpu/drm/nouveau/core/engine/graph/nve0.c
+++ b/drivers/gpu/drm/nouveau/core/engine/graph/nve0.c
@@ -31,7 +31,7 @@
 #include <core/mm.h>
 #include <engine/fifo.h>
 
-#include "nve0.h"
+#include "nvc0.h"
 
 static void
 nve0_graph_ctxctl_debug_unit(struct drm_device *dev, u32 base)
@@ -88,8 +88,8 @@ nve0_graph_unload_context_to(struct drm_device *dev, u64 chan)
 static int
 nve0_graph_construct_context(struct nouveau_channel *chan)
 {
-	struct nve0_graph_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_GR);
-	struct nve0_graph_chan *grch = chan->engctx[NVOBJ_ENGINE_GR];
+	struct nvc0_graph_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_GR);
+	struct nvc0_graph_chan *grch = chan->engctx[NVOBJ_ENGINE_GR];
 	struct drm_device *dev = chan->dev;
 	int ret, i;
 	u32 *ctx;
@@ -128,8 +128,8 @@ err:
 static int
 nve0_graph_create_context_mmio_list(struct nouveau_channel *chan)
 {
-	struct nve0_graph_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_GR);
-	struct nve0_graph_chan *grch = chan->engctx[NVOBJ_ENGINE_GR];
+	struct nvc0_graph_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_GR);
+	struct nvc0_graph_chan *grch = chan->engctx[NVOBJ_ENGINE_GR];
 	struct drm_device *dev = chan->dev;
 	u32 magic[GPC_MAX][2];
 	u16 offset = 0x0000;
@@ -220,8 +220,8 @@ static int
 nve0_graph_context_new(struct nouveau_channel *chan, int engine)
 {
 	struct drm_device *dev = chan->dev;
-	struct nve0_graph_priv *priv = nv_engine(dev, engine);
-	struct nve0_graph_chan *grch;
+	struct nvc0_graph_priv *priv = nv_engine(dev, engine);
+	struct nvc0_graph_chan *grch;
 	struct nouveau_gpuobj *grctx;
 	int ret, i;
 
@@ -279,7 +279,7 @@ error:
 static void
 nve0_graph_context_del(struct nouveau_channel *chan, int engine)
 {
-	struct nve0_graph_chan *grch = chan->engctx[engine];
+	struct nvc0_graph_chan *grch = chan->engctx[engine];
 
 	nouveau_gpuobj_unmap(&grch->mmio_vma);
 	nouveau_gpuobj_unmap(&grch->unk418810_vma);
@@ -310,7 +310,7 @@ nve0_graph_fini(struct drm_device *dev, int engine, bool suspend)
 static void
 nve0_graph_init_obj418880(struct drm_device *dev)
 {
-	struct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
+	struct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
 	int i;
 
 	nv_wr32(dev, GPC_BCAST(0x0880), 0x00000000);
@@ -362,7 +362,7 @@ nve0_graph_init_units(struct drm_device *dev)
 static void
 nve0_graph_init_gpc_0(struct drm_device *dev)
 {
-	struct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
+	struct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
 	const u32 magicgpc918 = DIV_ROUND_UP(0x00800000, priv->tpc_total);
 	u32 data[TPC_MAX / 8];
 	u8  tpcnr[GPC_MAX];
@@ -400,7 +400,7 @@ nve0_graph_init_gpc_0(struct drm_device *dev)
 static void
 nve0_graph_init_gpc_1(struct drm_device *dev)
 {
-	struct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
+	struct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
 	int gpc, tpc;
 
 	for (gpc = 0; gpc < priv->gpc_nr; gpc++) {
@@ -426,7 +426,7 @@ nve0_graph_init_gpc_1(struct drm_device *dev)
 static void
 nve0_graph_init_rop(struct drm_device *dev)
 {
-	struct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
+	struct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
 	int rop;
 
 	for (rop = 0; rop < priv->rop_nr; rop++) {
@@ -439,7 +439,7 @@ nve0_graph_init_rop(struct drm_device *dev)
 
 static void
 nve0_graph_init_fuc(struct drm_device *dev, u32 fuc_base,
-		    struct nve0_graph_fuc *code, struct nve0_graph_fuc *data)
+		    struct nvc0_graph_fuc *code, struct nvc0_graph_fuc *data)
 {
 	int i;
 
@@ -458,7 +458,7 @@ nve0_graph_init_fuc(struct drm_device *dev, u32 fuc_base,
 static int
 nve0_graph_init_ctxctl(struct drm_device *dev)
 {
-	struct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
+	struct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
 	u32 r000260;
 
 	/* load fuc microcode */
@@ -613,7 +613,7 @@ nve0_graph_ctxctl_isr(struct drm_device *dev)
 static void
 nve0_graph_trap_isr(struct drm_device *dev, int chid)
 {
-	struct nve0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
+	struct nvc0_graph_priv *priv = nv_engine(dev, NVOBJ_ENGINE_GR);
 	u32 trap = nv_rd32(dev, 0x400108);
 	int rop;
 
@@ -716,7 +716,7 @@ nve0_graph_isr(struct drm_device *dev)
 
 static int
 nve0_graph_create_fw(struct drm_device *dev, const char *fwname,
-		     struct nve0_graph_fuc *fuc)
+		     struct nvc0_graph_fuc *fuc)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	const struct firmware *fw;
@@ -735,7 +735,7 @@ nve0_graph_create_fw(struct drm_device *dev, const char *fwname,
 }
 
 static void
-nve0_graph_destroy_fw(struct nve0_graph_fuc *fuc)
+nve0_graph_destroy_fw(struct nvc0_graph_fuc *fuc)
 {
 	if (fuc->data) {
 		kfree(fuc->data);
@@ -746,7 +746,7 @@ nve0_graph_destroy_fw(struct nve0_graph_fuc *fuc)
 static void
 nve0_graph_destroy(struct drm_device *dev, int engine)
 {
-	struct nve0_graph_priv *priv = nv_engine(dev, engine);
+	struct nvc0_graph_priv *priv = nv_engine(dev, engine);
 
 	nve0_graph_destroy_fw(&priv->fuc409c);
 	nve0_graph_destroy_fw(&priv->fuc409d);
@@ -769,11 +769,11 @@ int
 nve0_graph_create(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nve0_graph_priv *priv;
+	struct nvc0_graph_priv *priv;
 	int ret, gpc, i;
 	u32 kepler;
 
-	kepler = nve0_graph_class(dev);
+	kepler = nvc0_graph_class(dev);
 	if (!kepler) {
 		NV_ERROR(dev, "PGRAPH: unsupported chipset, please report!\n");
 		return 0;
diff --git a/drivers/gpu/drm/nouveau/core/engine/graph/nve0.h b/drivers/gpu/drm/nouveau/core/engine/graph/nve0.h
deleted file mode 100644
index b136cd5..0000000
--- a/drivers/gpu/drm/nouveau/core/engine/graph/nve0.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright 2012 Red Hat Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- *
- * Authors: Ben Skeggs
- */
-
-#ifndef __NVE0_GRAPH_H__
-#define __NVE0_GRAPH_H__
-
-#define GPC_MAX 4
-#define TPC_MAX 32
-
-#define ROP_BCAST(r)     (0x408800 + (r))
-#define ROP_UNIT(u, r)   (0x410000 + (u) * 0x400 + (r))
-#define GPC_BCAST(r)     (0x418000 + (r))
-#define GPC_UNIT(t, r)   (0x500000 + (t) * 0x8000 + (r))
-#define TPC_UNIT(t, m, r) (0x504000 + (t) * 0x8000 + (m) * 0x800 + (r))
-
-struct nve0_graph_fuc {
-	u32 *data;
-	u32  size;
-};
-
-struct nve0_graph_priv {
-	struct nouveau_exec_engine base;
-
-	struct nve0_graph_fuc fuc409c;
-	struct nve0_graph_fuc fuc409d;
-	struct nve0_graph_fuc fuc41ac;
-	struct nve0_graph_fuc fuc41ad;
-
-	u8 gpc_nr;
-	u8 rop_nr;
-	u8 tpc_nr[GPC_MAX];
-	u8 tpc_total;
-
-	u32  grctx_size;
-	u32 *grctx_vals;
-	struct nouveau_gpuobj *unk4188b4;
-	struct nouveau_gpuobj *unk4188b8;
-
-	u8 magic_not_rop_nr;
-};
-
-struct nve0_graph_chan {
-	struct nouveau_gpuobj *grctx;
-	struct nouveau_vma     grctx_vma;
-	struct nouveau_gpuobj *unk408004; /* 0x418810 too */
-	struct nouveau_vma     unk408004_vma;
-	struct nouveau_gpuobj *unk40800c; /* 0x419004 too */
-	struct nouveau_vma     unk40800c_vma;
-	struct nouveau_gpuobj *unk418810; /* 0x419848 too */
-	struct nouveau_vma     unk418810_vma;
-	struct nouveau_gpuobj *mmio;
-	struct nouveau_vma     mmio_vma;
-	int mmio_nr;
-};
-
-int nve0_grctx_generate(struct nouveau_channel *);
-
-/* nve0_graph.c uses this also to determine supported chipsets */
-static inline u32
-nve0_graph_class(struct drm_device *dev)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-
-	switch (dev_priv->chipset) {
-	case 0xe4:
-	case 0xe7:
-		return 0xa097;
-	default:
-		return 0;
-	}
-}
-
-#endif

