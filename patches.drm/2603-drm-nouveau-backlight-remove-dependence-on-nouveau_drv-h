From 51a3d3425663698a79e8a9d01998a8a32ddee13b Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Thu, 26 Jul 2012 09:12:47 +1000
Subject: drm/nouveau/backlight: remove dependence on nouveau_drv.h
Git-commit: 51a3d3425663698a79e8a9d01998a8a32ddee13b
Patch-mainline: v3.7-rc3

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/nouveau/Makefile            |    5 +-
 drivers/gpu/drm/nouveau/nouveau_backlight.c |   90 ++++++++++++++-------------
 drivers/gpu/drm/nouveau/nouveau_drm.h       |    2 +
 drivers/gpu/drm/nouveau/nouveau_drv.h       |   10 ++-
 drivers/gpu/drm/nouveau/nouveau_encoder.h   |    3 +-
 drivers/gpu/drm/nouveau/nv04_display.h      |    9 +--
 6 files changed, 60 insertions(+), 59 deletions(-)

Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/Makefile
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/Makefile
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/Makefile
@@ -170,6 +170,7 @@ nouveau-y += nv50_fbcon.o nvc0_fbcon.o
 # other random bits
 nouveau-$(CONFIG_COMPAT) += nouveau_ioc32.o
 nouveau-$(CONFIG_ACPI) += nouveau_acpi.o
+nouveau-$(CONFIG_DRM_NOUVEAU_BACKLIGHT) += nouveau_backlight.o
 
 ##
 ## unported bits below
@@ -201,8 +202,4 @@ nouveau-y += nouveau_pm.o nouveau_volt.o
 nouveau-y += nv04_pm.o nv40_pm.o nv50_pm.o nva3_pm.o nvc0_pm.o
 nouveau-y += nouveau_mem.o
 
-# optional stuff
-nouveau-$(CONFIG_DRM_NOUVEAU_BACKLIGHT) += nouveau_backlight.o
-
-
 obj-$(CONFIG_DRM_NOUVEAU)+= nouveau.o
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_backlight.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -33,18 +33,17 @@
 #include <linux/backlight.h>
 #include <linux/acpi.h>
 
-#include <drm/drmP.h>
-#include "nouveau_drv.h"
-#include <nouveau_drm.h>
+#include "nouveau_drm.h"
 #include "nouveau_reg.h"
 #include "nouveau_encoder.h"
 
 static int
 nv40_get_intensity(struct backlight_device *bd)
 {
-	struct drm_device *dev = bl_get_data(bd);
-	int val = (nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK)
-									>> 16;
+	struct nouveau_drm *drm = bl_get_data(bd);
+	struct nouveau_device *device = nv_device(drm->device);
+	int val = (nv_rd32(device, NV40_PMC_BACKLIGHT) &
+				   NV40_PMC_BACKLIGHT_MASK) >> 16;
 
 	return val;
 }
@@ -52,11 +51,12 @@ nv40_get_intensity(struct backlight_devi
 static int
 nv40_set_intensity(struct backlight_device *bd)
 {
-	struct drm_device *dev = bl_get_data(bd);
+	struct nouveau_drm *drm = bl_get_data(bd);
+	struct nouveau_device *device = nv_device(drm->device);
 	int val = bd->props.brightness;
-	int reg = nv_rd32(dev, NV40_PMC_BACKLIGHT);
+	int reg = nv_rd32(device, NV40_PMC_BACKLIGHT);
 
-	nv_wr32(dev, NV40_PMC_BACKLIGHT,
+	nv_wr32(device, NV40_PMC_BACKLIGHT,
 		 (val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));
 
 	return 0;
@@ -71,23 +71,20 @@ static const struct backlight_ops nv40_b
 static int
 nv40_backlight_init(struct drm_connector *connector)
 {
-	struct drm_device *dev = connector->dev;
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_drm *drm = nouveau_newpriv(connector->dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	struct backlight_properties props;
 	struct backlight_device *bd;
 
-	if (!(nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
+	if (!(nv_rd32(device, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))
 		return 0;
 
 	memset(&props, 0, sizeof(struct backlight_properties));
 	props.type = BACKLIGHT_RAW;
 	props.max_brightness = 31;
-	bd = backlight_device_register("nv_backlight", &connector->kdev, dev,
+	bd = backlight_device_register("nv_backlight", &connector->kdev, drm,
 				       &nv40_bl_ops, &props);
-	if (IS_ERR(bd))
-		return PTR_ERR(bd);
-
-	dev_priv->backlight = bd;
+	drm->backlight = bd;
 	bd->props.brightness = nv40_get_intensity(bd);
 	backlight_update_status(bd);
 
@@ -98,12 +95,13 @@ static int
 nv50_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct drm_device *dev = nv_encoder->base.base.dev;
+	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val;
 
-	val  = nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(or));
+	val  = nv_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));
 	val &= NV50_PDISP_SOR_PWM_CTL_VAL;
 	return ((val * 100) + (div / 2)) / div;
 }
@@ -112,13 +110,14 @@ static int
 nv50_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct drm_device *dev = nv_encoder->base.base.dev;
+	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div = 1025;
 	u32 val = (bd->props.brightness * div) / 100;
 
-	nv_wr32(dev, NV50_PDISP_SOR_PWM_CTL(or),
-		     NV50_PDISP_SOR_PWM_CTL_NEW | val);
+	nv_wr32(device, NV50_PDISP_SOR_PWM_CTL(or),
+			NV50_PDISP_SOR_PWM_CTL_NEW | val);
 	return 0;
 }
 
@@ -132,12 +131,13 @@ static int
 nva3_get_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct drm_device *dev = nv_encoder->base.base.dev;
+	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div, val;
 
-	div  = nv_rd32(dev, NV50_PDISP_SOR_PWM_DIV(or));
-	val  = nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(or));
+	div  = nv_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
+	val  = nv_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));
 	val &= NVA3_PDISP_SOR_PWM_CTL_VAL;
 	if (div && div >= val)
 		return ((val * 100) + (div / 2)) / div;
@@ -149,16 +149,17 @@ static int
 nva3_set_intensity(struct backlight_device *bd)
 {
 	struct nouveau_encoder *nv_encoder = bl_get_data(bd);
-	struct drm_device *dev = nv_encoder->base.base.dev;
+	struct nouveau_drm *drm = nouveau_newpriv(nv_encoder->base.base.dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	int or = nv_encoder->or;
 	u32 div, val;
 
-	div = nv_rd32(dev, NV50_PDISP_SOR_PWM_DIV(or));
+	div = nv_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));
 	val = (bd->props.brightness * div) / 100;
 	if (div) {
-		nv_wr32(dev, NV50_PDISP_SOR_PWM_CTL(or), val |
-			     NV50_PDISP_SOR_PWM_CTL_NEW |
-			     NVA3_PDISP_SOR_PWM_CTL_UNK);
+		nv_wr32(device, NV50_PDISP_SOR_PWM_CTL(or), val |
+				NV50_PDISP_SOR_PWM_CTL_NEW |
+				NVA3_PDISP_SOR_PWM_CTL_UNK);
 		return 0;
 	}
 
@@ -174,8 +175,8 @@ static const struct backlight_ops nva3_b
 static int
 nv50_backlight_init(struct drm_connector *connector)
 {
-	struct drm_device *dev = connector->dev;
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_drm *drm = nouveau_newpriv(connector->dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	struct nouveau_encoder *nv_encoder;
 	struct backlight_properties props;
 	struct backlight_device *bd;
@@ -188,12 +189,12 @@ nv50_backlight_init(struct drm_connector
 			return -ENODEV;
 	}
 
-	if (!nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
+	if (!nv_rd32(device, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))
 		return 0;
 
-	if (dev_priv->chipset <= 0xa0 ||
-	    dev_priv->chipset == 0xaa ||
-	    dev_priv->chipset == 0xac)
+	if (device->chipset <= 0xa0 ||
+	    device->chipset == 0xaa ||
+	    device->chipset == 0xac)
 		ops = &nv50_bl_ops;
 	else
 		ops = &nva3_bl_ops;
@@ -206,7 +207,7 @@ nv50_backlight_init(struct drm_connector
 	if (IS_ERR(bd))
 		return PTR_ERR(bd);
 
-	dev_priv->backlight = bd;
+	drm->backlight = bd;
 	bd->props.brightness = bd->ops->get_brightness(bd);
 	backlight_update_status(bd);
 	return 0;
@@ -215,12 +216,13 @@ nv50_backlight_init(struct drm_connector
 int
 nouveau_backlight_init(struct drm_device *dev)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_device *device = nv_device(drm->device);
 	struct drm_connector *connector;
 
 #ifdef CONFIG_ACPI
 	if (acpi_video_backlight_support()) {
-		NV_INFO(dev, "ACPI backlight interface available, "
+		NV_INFO(drm, "ACPI backlight interface available, "
 			     "not registering our own\n");
 		return 0;
 	}
@@ -231,7 +233,7 @@ nouveau_backlight_init(struct drm_device
 		    connector->connector_type != DRM_MODE_CONNECTOR_eDP)
 			continue;
 
-		switch (dev_priv->card_type) {
+		switch (device->card_type) {
 		case NV_40:
 			return nv40_backlight_init(connector);
 		case NV_50:
@@ -248,10 +250,10 @@ nouveau_backlight_init(struct drm_device
 void
 nouveau_backlight_exit(struct drm_device *dev)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
 
-	if (dev_priv->backlight) {
-		backlight_device_unregister(dev_priv->backlight);
-		dev_priv->backlight = NULL;
+	if (drm->backlight) {
+		backlight_device_unregister(drm->backlight);
+		drm->backlight = NULL;
 	}
 }
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drm.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_drm.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drm.h
@@ -95,6 +95,8 @@ struct nouveau_drm {
 		struct nouveau_drm_tile reg[15];
 		spinlock_t lock;
 	} tile;
+
+	struct backlight_device *backlight;
 };
 
 static inline struct nouveau_drm *
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -308,9 +308,6 @@ struct drm_nouveau_private {
 	spinlock_t context_switch_lock;
 
 	struct nvbios vbios;
-	u8 *mxms;
-
-	struct backlight_device *backlight;
 };
 
 static inline struct drm_nouveau_private *
@@ -544,4 +541,11 @@ nv_match_device(struct drm_device *dev,
 		dev->pdev->subsystem_device == sub_device;
 }
 
+static inline struct nv04_display *
+nv04_display(struct drm_device *dev)
+{
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	return dev_priv->engine.display.priv;
+}
+
 #endif /* __NOUVEAU_DRV_H__ */
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_encoder.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_encoder.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_encoder.h
@@ -27,8 +27,9 @@
 #ifndef __NOUVEAU_ENCODER_H__
 #define __NOUVEAU_ENCODER_H__
 
+#include <subdev/bios/dcb.h>
+
 #include <drm/drm_encoder_slave.h>
-#include "nouveau_drv.h"
 #include "nv04_display.h"
 
 #define NV_DPMS_CLEARED 0x80
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_display.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv04_display.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_display.h
@@ -1,6 +1,8 @@
 #ifndef __NV04_DISPLAY_H__
 #define __NV04_DISPLAY_H__
 
+#include <subdev/bios/pll.h>
+
 enum nv04_fp_display_regs {
 	FP_DISPLAY_END,
 	FP_TOTAL,
@@ -78,13 +80,6 @@ struct nv04_display {
 	uint32_t dac_users[4];
 };
 
-static inline struct nv04_display *
-nv04_display(struct drm_device *dev)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	return dev_priv->engine.display.priv;
-}
-
 /* nv04_display.c */
 int nv04_display_early_init(struct drm_device *);
 void nv04_display_late_takedown(struct drm_device *);
