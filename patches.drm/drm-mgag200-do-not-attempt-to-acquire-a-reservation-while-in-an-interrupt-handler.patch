From: Maarten Lankhorst <m.b.lankhorst@gmail.com>
Date: Thu Jun 27 13:38:25 2013 +0200
Subject: drm/mgag200: do not attempt to acquire a reservation while in an interrupt handler
Patch-mainline: Upstream/v3.11-rc1
Git-commit: a06b9a74c73750835b8fd69fe0d0bd7877da111b

References: FATE#317582
Signed-off-by: Egbert Eich <eich@suse.com>

Mutexes should not be acquired in interrupt context. While the trylock
fastpath is arguably safe on all implementations, the slowpath
unlock path definitely isn't.

Signed-off-by: Maarten Lankhorst <maarten.lankhorst@canonical.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
---
 drivers/gpu/drm/mgag200/mgag200_fb.c |    5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

--- a/drivers/gpu/drm/mgag200/mgag200_fb.c
+++ b/drivers/gpu/drm/mgag200/mgag200_fb.c
@@ -26,13 +26,14 @@ static void mga_dirty_update(struct mga_
 	struct mgag200_bo *bo;
 	int src_offset, dst_offset;
 	int bpp = (mfbdev->mfb.base.bits_per_pixel + 7)/8;
-	int ret;
+	int ret = -EBUSY;
 	bool unmap = false;
 
 	obj = mfbdev->mfb.obj;
 	bo = gem_to_mga_bo(obj);
 
-	ret = mgag200_bo_reserve(bo, true);
+	if (!in_interrupt())
+		ret = mgag200_bo_reserve(bo, true);
 	if (ret) {
 		DRM_ERROR("failed to reserve fb bo\n");
 		return;
