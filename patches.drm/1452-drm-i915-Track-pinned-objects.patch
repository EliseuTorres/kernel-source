From babea8ae4b8dd5ffabe93b26df1574d9b0200bae Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Mon, 20 Sep 2010 17:36:15 +0100
Patch-mainline: 2.6.37
References: fate#310916
Git-commit: f13d3f7311add99d1f874a6b67d56426afa35664
Subject: [PATCH 1452/2588] drm/i915: Track pinned objects

Keep a list of pinned objects and display it via debugfs. Now all
objects that exist in the GTT are always tracked on one of the
active, flushing, inactive or pinned lists.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit f13d3f7311add99d1f874a6b67d56426afa35664)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_debugfs.c |   16 ++++++++++++----
 drivers/gpu/drm/i915/i915_drv.h     |    6 ++++++
 drivers/gpu/drm/i915/i915_gem.c     |   18 ++++++++----------
 3 files changed, 26 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
index ac48115..36f0e36 100644
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@ -40,10 +40,13 @@
 
 #if defined(CONFIG_DEBUG_FS)
 
-#define RENDER_LIST	1
-#define BSD_LIST	2
-#define FLUSHING_LIST	3
-#define INACTIVE_LIST	4
+enum {
+	RENDER_LIST,
+	BSD_LIST,
+	FLUSHING_LIST,
+	INACTIVE_LIST,
+	PINNED_LIST
+};
 
 static const char *yesno(int v)
 {
@@ -150,6 +153,10 @@ static int i915_gem_object_list_info(struct seq_file *m, void *data)
 		seq_printf(m, "Inactive:\n");
 		head = &dev_priv->mm.inactive_list;
 		break;
+	case PINNED_LIST:
+		seq_printf(m, "Pinned:\n");
+		head = &dev_priv->mm.pinned_list;
+		break;
 	case FLUSHING_LIST:
 		seq_printf(m, "Flushing:\n");
 		head = &dev_priv->mm.flushing_list;
@@ -983,6 +990,7 @@ static struct drm_info_list i915_debugfs_list[] = {
 	{"i915_gem_bsd_active", i915_gem_object_list_info, 0, (void *) BSD_LIST},
 	{"i915_gem_flushing", i915_gem_object_list_info, 0, (void *) FLUSHING_LIST},
 	{"i915_gem_inactive", i915_gem_object_list_info, 0, (void *) INACTIVE_LIST},
+	{"i915_gem_pinned", i915_gem_object_list_info, 0, (void *) PINNED_LIST},
 	{"i915_gem_pageflip", i915_gem_pageflip_info, 0},
 	{"i915_gem_request", i915_gem_request_info, 0},
 	{"i915_gem_seqno", i915_gem_seqno_info, 0},
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index ce8ff8f..12e9f85 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -569,6 +569,12 @@ typedef struct drm_i915_private {
 		 */
 		struct list_head inactive_list;
 
+		/**
+		 * LRU list of objects which are not in the ringbuffer but
+		 * are still pinned in the GTT.
+		 */
+		struct list_head pinned_list;
+
 		/** LRU list of objects with fence regs on them. */
 		struct list_head fence_list;
 
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index b02409a..d20470b 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -1053,7 +1053,6 @@ i915_gem_set_domain_ioctl(struct drm_device *dev, void *data,
 		ret = i915_gem_object_set_to_cpu_domain(obj, write_domain != 0);
 	}
 
-	
 	/* Maintain LRU order of "inactive" objects */
 	if (ret == 0 && i915_gem_object_is_inactive(obj_priv))
 		list_move_tail(&obj_priv->list, &dev_priv->mm.inactive_list);
@@ -1554,7 +1553,7 @@ i915_gem_object_move_to_inactive(struct drm_gem_object *obj)
 
 	i915_verify_inactive(dev, __FILE__, __LINE__);
 	if (obj_priv->pin_count != 0)
-		list_del_init(&obj_priv->list);
+		list_move_tail(&obj_priv->list, &dev_priv->mm.pinned_list);
 	else
 		list_move_tail(&obj_priv->list, &dev_priv->mm.inactive_list);
 
@@ -2046,9 +2045,7 @@ i915_gem_object_unbind(struct drm_gem_object *obj)
 		obj_priv->gtt_space = NULL;
 	}
 
-	/* Remove ourselves from the LRU list if present. */
-	if (!list_empty(&obj_priv->list))
-		list_del_init(&obj_priv->list);
+	list_del_init(&obj_priv->list);
 
 	if (i915_gem_object_is_purgeable(obj_priv))
 		i915_gem_object_truncate(obj);
@@ -4033,6 +4030,7 @@ int
 i915_gem_object_pin(struct drm_gem_object *obj, uint32_t alignment)
 {
 	struct drm_device *dev = obj->dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_i915_gem_object *obj_priv = to_intel_bo(obj);
 	int ret;
 
@@ -4068,9 +4066,9 @@ i915_gem_object_pin(struct drm_gem_object *obj, uint32_t alignment)
 	if (obj_priv->pin_count == 1) {
 		atomic_inc(&dev->pin_count);
 		atomic_add(obj->size, &dev->pin_memory);
-		if (!obj_priv->active &&
-		    (obj->write_domain & I915_GEM_GPU_DOMAINS) == 0)
-			list_del_init(&obj_priv->list);
+		if (!obj_priv->active)
+			list_move_tail(&obj_priv->list,
+				       &dev_priv->mm.pinned_list);
 	}
 	i915_verify_inactive(dev, __FILE__, __LINE__);
 
@@ -4094,8 +4092,7 @@ i915_gem_object_unpin(struct drm_gem_object *obj)
 	 * the inactive list
 	 */
 	if (obj_priv->pin_count == 0) {
-		if (!obj_priv->active &&
-		    (obj->write_domain & I915_GEM_GPU_DOMAINS) == 0)
+		if (!obj_priv->active)
 			list_move_tail(&obj_priv->list,
 				       &dev_priv->mm.inactive_list);
 		atomic_dec(&dev->pin_count);
@@ -4617,6 +4614,7 @@ i915_gem_load(struct drm_device *dev)
 	INIT_LIST_HEAD(&dev_priv->mm.flushing_list);
 	INIT_LIST_HEAD(&dev_priv->mm.gpu_write_list);
 	INIT_LIST_HEAD(&dev_priv->mm.inactive_list);
+	INIT_LIST_HEAD(&dev_priv->mm.pinned_list);
 	INIT_LIST_HEAD(&dev_priv->mm.fence_list);
 	INIT_LIST_HEAD(&dev_priv->mm.deferred_free_list);
 	INIT_LIST_HEAD(&dev_priv->render_ring.active_list);
-- 
1.7.6

