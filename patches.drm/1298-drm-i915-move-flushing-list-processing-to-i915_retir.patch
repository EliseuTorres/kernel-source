From 040db4835f4ed0244fead394d979367252779806 Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Thu, 11 Feb 2010 22:29:04 +0100
Patch-mainline: 2.6.37
References: fate#310916
Git-commit: 8a1a49f954734040dbc7b87e3b1221a050045e43
Subject: [PATCH 1298/2588] drm/i915: move flushing list processing to
 i915_retire_commands

... instead of threading flush_domains through the execbuf code to
i915_add_request.

With this change 2 small cleanups are possible (likewise the majority
of the patch):

- The flush_domains parameter of i915_add_request is always 0. Drop it
  and the corresponding logic.
- Ditto for the seqno param of i915_gem_process_flushing_list.

Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit 8a1a49f954734040dbc7b87e3b1221a050045e43)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_drv.h         |    9 +++-
 drivers/gpu/drm/i915/i915_gem.c         |   64 +++++++++++--------------------
 drivers/gpu/drm/i915/intel_overlay.c    |   17 ++++----
 drivers/gpu/drm/i915/intel_ringbuffer.c |    4 ++
 4 files changed, 41 insertions(+), 53 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index fb8d681..f983130 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -991,12 +991,15 @@ int i915_gpu_idle(struct drm_device *dev);
 int i915_gem_idle(struct drm_device *dev);
 uint32_t i915_add_request(struct drm_device *dev,
 		struct drm_file *file_priv,
-		uint32_t flush_domains,
 		struct intel_ring_buffer *ring);
 int i915_do_wait_request(struct drm_device *dev,
-		uint32_t seqno, int interruptible,
-		struct intel_ring_buffer *ring);
+			 uint32_t seqno,
+			 bool interruptible,
+			 struct intel_ring_buffer *ring);
 int i915_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf);
+void i915_gem_process_flushing_list(struct drm_device *dev,
+				    uint32_t flush_domains,
+				    struct intel_ring_buffer *ring);
 int i915_gem_object_set_to_gtt_domain(struct drm_gem_object *obj,
 				      int write);
 int i915_gem_object_set_to_display_plane(struct drm_gem_object *obj);
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index c15b98b..cb9a8bc 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -1572,9 +1572,9 @@ i915_gem_object_move_to_inactive(struct drm_gem_object *obj)
 	i915_verify_inactive(dev, __FILE__, __LINE__);
 }
 
-static void
+void
 i915_gem_process_flushing_list(struct drm_device *dev,
-			       uint32_t flush_domains, uint32_t seqno,
+			       uint32_t flush_domains,
 			       struct intel_ring_buffer *ring)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
@@ -1592,7 +1592,7 @@ i915_gem_process_flushing_list(struct drm_device *dev,
 
 			obj->write_domain = 0;
 			list_del_init(&obj_priv->gpu_write_list);
-			i915_gem_object_move_to_active(obj, seqno, ring);
+			i915_gem_object_move_to_active(obj, 0, ring);
 
 			/* update the fence lru list */
 			if (obj_priv->fence_reg != I915_FENCE_REG_NONE) {
@@ -1610,8 +1610,9 @@ i915_gem_process_flushing_list(struct drm_device *dev,
 }
 
 uint32_t
-i915_add_request(struct drm_device *dev, struct drm_file *file_priv,
-		 uint32_t flush_domains, struct intel_ring_buffer *ring)
+i915_add_request(struct drm_device *dev,
+		 struct drm_file *file_priv,
+		 struct intel_ring_buffer *ring)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	struct drm_i915_file_private *i915_file_priv = NULL;
@@ -1626,7 +1627,7 @@ i915_add_request(struct drm_device *dev, struct drm_file *file_priv,
 	if (request == NULL)
 		return 0;
 
-	seqno = ring->add_request(dev, ring, file_priv, flush_domains);
+	seqno = ring->add_request(dev, ring, file_priv, 0);
 
 	request->seqno = seqno;
 	request->ring = ring;
@@ -1641,12 +1642,6 @@ i915_add_request(struct drm_device *dev, struct drm_file *file_priv,
 		INIT_LIST_HEAD(&request->client_list);
 	}
 
-	/* Associate any objects on the flushing list matching the write
-	 * domain we're flushing with our request.
-	 */
-	if (flush_domains != 0) 
-		i915_gem_process_flushing_list(dev, flush_domains, seqno, ring);
-
 	if (!dev_priv->mm.suspended) {
 		mod_timer(&dev_priv->hangcheck_timer, jiffies + DRM_I915_HANGCHECK_PERIOD);
 		if (was_empty)
@@ -1661,7 +1656,7 @@ i915_add_request(struct drm_device *dev, struct drm_file *file_priv,
  * Ensures that all commands in the ring are finished
  * before signalling the CPU
  */
-static uint32_t
+static void
 i915_retire_commands(struct drm_device *dev, struct intel_ring_buffer *ring)
 {
 	uint32_t flush_domains = 0;
@@ -1672,7 +1667,6 @@ i915_retire_commands(struct drm_device *dev, struct intel_ring_buffer *ring)
 
 	ring->flush(dev, ring,
 			I915_GEM_DOMAIN_COMMAND, flush_domains);
-	return flush_domains;
 }
 
 /**
@@ -1839,7 +1833,7 @@ i915_gem_retire_work_handler(struct work_struct *work)
 
 int
 i915_do_wait_request(struct drm_device *dev, uint32_t seqno,
-		int interruptible, struct intel_ring_buffer *ring)
+		     bool interruptible, struct intel_ring_buffer *ring)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	u32 ier;
@@ -1848,7 +1842,7 @@ i915_do_wait_request(struct drm_device *dev, uint32_t seqno,
 	BUG_ON(seqno == 0);
 
 	if (seqno == dev_priv->next_seqno) {
-		seqno = i915_add_request(dev, NULL, 0, ring);
+		seqno = i915_add_request(dev, NULL, ring);
 		if (seqno == 0)
 			return -ENOMEM;
 	}
@@ -1936,17 +1930,6 @@ i915_gem_flush(struct drm_device *dev,
 		dev_priv->bsd_ring.flush(dev, &dev_priv->bsd_ring,
 				invalidate_domains,
 				flush_domains);
-
-	/* Associate any objects on the flushing list matching the write
-	 * domain we're flushing with the next request.
-	 */
-	if (flush_domains != 0)  {
-		i915_gem_process_flushing_list(dev, flush_domains, 0,
-					       &dev_priv->render_ring);
-		if (HAS_BSD(dev))
-			i915_gem_process_flushing_list(dev, flush_domains, 0,
-						       &dev_priv->bsd_ring);
-	}
 }
 
 /**
@@ -2080,24 +2063,23 @@ i915_gpu_idle(struct drm_device *dev)
 
 	/* Flush everything onto the inactive list. */
 	i915_gem_flush(dev, I915_GEM_GPU_DOMAINS, I915_GEM_GPU_DOMAINS);
-	seqno1 = i915_add_request(dev, NULL, 0,
-			&dev_priv->render_ring);
+	seqno1 = i915_add_request(dev, NULL, &dev_priv->render_ring);
 	if (seqno1 == 0)
 		return -ENOMEM;
 	ret = i915_wait_request(dev, seqno1, &dev_priv->render_ring);
+	if (ret)
+		return ret;
 
 	if (HAS_BSD(dev)) {
-		seqno2 = i915_add_request(dev, NULL, 0,
-				&dev_priv->bsd_ring);
+		seqno2 = i915_add_request(dev, NULL, &dev_priv->bsd_ring);
 		if (seqno2 == 0)
 			return -ENOMEM;
-
 		ret = i915_wait_request(dev, seqno2, &dev_priv->bsd_ring);
 		if (ret)
 			return ret;
 	}
 
-	return ret;
+	return 0;
 }
 
 int
@@ -2653,7 +2635,7 @@ i915_gem_object_flush_gpu_write_domain(struct drm_gem_object *obj)
 	/* Queue the GPU write cache flushing we need. */
 	old_write_domain = obj->write_domain;
 	i915_gem_flush(dev, 0, obj->write_domain);
-	if (i915_add_request(dev, NULL, obj->write_domain, obj_priv->ring) == 0)
+	if (i915_add_request(dev, NULL, obj_priv->ring) == 0)
 		return -ENOMEM;
 
 	trace_i915_gem_object_change_domain(obj,
@@ -3578,7 +3560,7 @@ i915_gem_do_execbuffer(struct drm_device *dev, void *data,
 	struct drm_i915_gem_relocation_entry *relocs = NULL;
 	int ret = 0, ret2, i, pinned = 0;
 	uint64_t exec_offset;
-	uint32_t seqno, flush_domains, reloc_index;
+	uint32_t seqno, reloc_index;
 	int pin_tries, flips;
 
 	struct intel_ring_buffer *ring = NULL;
@@ -3794,13 +3776,11 @@ i915_gem_do_execbuffer(struct drm_device *dev, void *data,
 	}
 
 	if (dev_priv->render_ring.outstanding_lazy_request) {
-		(void)i915_add_request(dev, file_priv, 0,
-				       &dev_priv->render_ring);
+		(void)i915_add_request(dev, file_priv, &dev_priv->render_ring);
 		dev_priv->render_ring.outstanding_lazy_request = false;
 	}
 	if (dev_priv->bsd_ring.outstanding_lazy_request) {
-		(void)i915_add_request(dev, file_priv, 0,
-				       &dev_priv->bsd_ring);
+		(void)i915_add_request(dev, file_priv, &dev_priv->bsd_ring);
 		dev_priv->bsd_ring.outstanding_lazy_request = false;
 	}
 
@@ -3849,7 +3829,7 @@ i915_gem_do_execbuffer(struct drm_device *dev, void *data,
 	 * Ensure that the commands in the batch buffer are
 	 * finished before the interrupt fires
 	 */
-	flush_domains = i915_retire_commands(dev, ring);
+	i915_retire_commands(dev, ring);
 
 	i915_verify_inactive(dev, __FILE__, __LINE__);
 
@@ -3860,7 +3840,7 @@ i915_gem_do_execbuffer(struct drm_device *dev, void *data,
 	 * *some* interrupts representing completion of buffers that we can
 	 * wait on when trying to clear up gtt space).
 	 */
-	seqno = i915_add_request(dev, file_priv, flush_domains, ring);
+	seqno = i915_add_request(dev, file_priv, ring);
 	BUG_ON(seqno == 0);
 	for (i = 0; i < args->buffer_count; i++) {
 		struct drm_gem_object *obj = object_list[i];
@@ -4258,7 +4238,7 @@ i915_gem_busy_ioctl(struct drm_device *dev, void *data,
 		 */
 		if (obj->write_domain) {
 			i915_gem_flush(dev, 0, obj->write_domain);
-			(void)i915_add_request(dev, file_priv, obj->write_domain, obj_priv->ring);
+			(void)i915_add_request(dev, file_priv, obj_priv->ring);
 		}
 
 		/* Update the active list for the hardware's current position.
diff --git a/drivers/gpu/drm/i915/intel_overlay.c b/drivers/gpu/drm/i915/intel_overlay.c
index 1d306a4..a203b5c 100644
--- a/drivers/gpu/drm/i915/intel_overlay.c
+++ b/drivers/gpu/drm/i915/intel_overlay.c
@@ -230,7 +230,7 @@ static int intel_overlay_on(struct intel_overlay *overlay)
 	ADVANCE_LP_RING();
 
 	overlay->last_flip_req =
-		i915_add_request(dev, NULL, 0, &dev_priv->render_ring);
+		i915_add_request(dev, NULL, &dev_priv->render_ring);
 	if (overlay->last_flip_req == 0)
 		return -ENOMEM;
 
@@ -269,7 +269,7 @@ static void intel_overlay_continue(struct intel_overlay *overlay,
         ADVANCE_LP_RING();
 
 	overlay->last_flip_req =
-		i915_add_request(dev, NULL, 0, &dev_priv->render_ring);
+		i915_add_request(dev, NULL, &dev_priv->render_ring);
 }
 
 static int intel_overlay_wait_flip(struct intel_overlay *overlay)
@@ -301,7 +301,7 @@ static int intel_overlay_wait_flip(struct intel_overlay *overlay)
         ADVANCE_LP_RING();
 
 	overlay->last_flip_req =
-		i915_add_request(dev, NULL, 0, &dev_priv->render_ring);
+		i915_add_request(dev, NULL, &dev_priv->render_ring);
 	if (overlay->last_flip_req == 0)
 		return -ENOMEM;
 
@@ -342,7 +342,7 @@ static int intel_overlay_off(struct intel_overlay *overlay)
         ADVANCE_LP_RING();
 
 	overlay->last_flip_req =
-		i915_add_request(dev, NULL, 0, &dev_priv->render_ring);
+		i915_add_request(dev, NULL, &dev_priv->render_ring);
 	if (overlay->last_flip_req == 0)
 		return -ENOMEM;
 
@@ -362,7 +362,7 @@ static int intel_overlay_off(struct intel_overlay *overlay)
 	ADVANCE_LP_RING();
 
 	overlay->last_flip_req =
-		i915_add_request(dev, NULL, 0, &dev_priv->render_ring);
+		i915_add_request(dev, NULL, &dev_priv->render_ring);
 	if (overlay->last_flip_req == 0)
 		return -ENOMEM;
 
@@ -409,7 +409,7 @@ int intel_overlay_recover_from_interrupt(struct intel_overlay *overlay,
 
 	if (overlay->last_flip_req == 0) {
 		overlay->last_flip_req =
-			i915_add_request(dev, NULL, 0, &dev_priv->render_ring);
+			i915_add_request(dev, NULL, &dev_priv->render_ring);
 		if (overlay->last_flip_req == 0)
 			return -ENOMEM;
 	}
@@ -439,8 +439,9 @@ int intel_overlay_recover_from_interrupt(struct intel_overlay *overlay,
 			OUT_RING(MI_NOOP);
 			ADVANCE_LP_RING();
 
-			overlay->last_flip_req = i915_add_request(dev, NULL,
-					0, &dev_priv->render_ring);
+			overlay->last_flip_req =
+				i915_add_request(dev, NULL,
+						 &dev_priv->render_ring);
 			if (overlay->last_flip_req == 0)
 				return -ENOMEM;
 
diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.c b/drivers/gpu/drm/i915/intel_ringbuffer.c
index cb3508f..1ae2b25 100644
--- a/drivers/gpu/drm/i915/intel_ringbuffer.c
+++ b/drivers/gpu/drm/i915/intel_ringbuffer.c
@@ -116,6 +116,8 @@ render_ring_flush(struct drm_device *dev,
 		intel_ring_emit(dev, ring, MI_NOOP);
 		intel_ring_advance(dev, ring);
 	}
+
+	i915_gem_process_flushing_list(dev, flush_domains, ring);
 }
 
 static unsigned int render_ring_get_head(struct drm_device *dev,
@@ -384,6 +386,8 @@ bsd_ring_flush(struct drm_device *dev,
 	intel_ring_emit(dev, ring, MI_FLUSH);
 	intel_ring_emit(dev, ring, MI_NOOP);
 	intel_ring_advance(dev, ring);
+
+	i915_gem_process_flushing_list(dev, flush_domains, ring);
 }
 
 static inline unsigned int bsd_ring_get_head(struct drm_device *dev,
-- 
1.7.6

