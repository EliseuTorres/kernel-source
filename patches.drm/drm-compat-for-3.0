From: Takashi Iwai <tiwai@suse.de>
Subject: drm: add compatibility definitions
Patch-mainline: Never
References: fate#310916

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/i915_drv.h            |    2 
 drivers/gpu/drm/i915/i915_gem.c            |   12 ++---
 drivers/gpu/drm/i915/i915_gem_execbuffer.c |    4 -
 drivers/gpu/drm/i915/intel_opregion.c      |    2 
 drivers/gpu/drm/radeon/radeon_clocks.c     |    3 -
 drivers/gpu/drm/ttm/ttm_page_alloc.c       |    2 
 include/drm/drmP.h                         |    2 
 include/drm/drm_compat.h                   |   67 +++++++++++++++++++++++++++++
 include/drm/drm_fb_helper.h                |    2 
 include/drm/ttm/ttm_bo_driver.h            |    1 
 10 files changed, 84 insertions(+), 13 deletions(-)

--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -87,6 +87,8 @@
 #include "drm_hashtab.h"
 #include "drm_mm.h"
 
+#include "drm_compat.h"
+
 #define DRM_UT_CORE 		0x01
 #define DRM_UT_DRIVER		0x02
 #define DRM_UT_KMS		0x04
--- /dev/null
+++ b/include/drm/drm_compat.h
@@ -0,0 +1,67 @@
+/*
+ * some compat hacks for drm-3.0 backports
+ */
+
+#ifndef __DRM_COMPAT_H
+#define __DRM_COMPAT_H
+
+#define FBINFO_CAN_FORCE_OUTPUT		0
+
+#define in_dbg_master()		0
+
+#define dma_set_coherent_mask(x, y) \
+	((x)->coherent_dma_mask = (y))
+
+#define noop_llseek		NULL
+
+#define alloc_workqueue(name, flags, number) \
+	create_singlethread_workqueue(name)
+
+#include <linux/vmalloc.h>
+static inline void *vzalloc(size_t size)
+{
+	void *p = vmalloc(size);
+	if (p)
+		memset(p, 0, size);
+	return p;
+}
+
+#include <linux/kref.h>
+static inline int kref_sub(struct kref *kref, unsigned int count,
+			   void (*release) (struct kref *kref))
+{
+	if (atomic_sub_and_test((int) count, &kref->refcount)) {
+		release(kref);
+		return 1;
+	}
+	return 0;
+}
+
+#define acpi_os_ioremap(x, y)	ioremap(x, y)
+
+#define abs64(x) ({				\
+		s64 __x = (x);			\
+		(__x < 0) ? -__x : __x;		\
+	})
+
+/* XXX */
+#define flush_work_sync(x)	flush_work(x)
+
+#define console_lock()		acquire_console_sem()
+#define console_unlock()	release_console_sem()
+
+#ifndef round_up
+/*
+ * This looks more complex than it should be. But we need to
+ * get the type for the ~ right in round_down (it needs to be
+ * as wide as the result!), and we want to evaluate the macro
+ * arguments just once each.
+ */
+#define __round_mask(x, y) ((__typeof__(x))((y)-1))
+#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)
+#define round_down(x, y) ((x) & ~__round_mask(x, y))
+#endif
+
+#define of_machine_is_compatible(x)	machine_is_compatible(x)
+
+#endif /* __DRM_COMPAT_H */
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -909,7 +909,7 @@
 
 struct drm_i915_file_private {
 	struct {
-		struct spinlock lock;
+		spinlock_t lock;
 		struct list_head request_list;
 	} mm;
 };
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -366,11 +366,11 @@
 		if (IS_ERR(page))
 			return PTR_ERR(page);
 
-		vaddr = kmap_atomic(page);
+		vaddr = kmap_atomic(page, KM_USER0);
 		ret = __copy_to_user_inatomic(user_data,
 					      vaddr + page_offset,
 					      page_length);
-		kunmap_atomic(vaddr);
+		kunmap_atomic(vaddr, KM_USER0);
 
 		mark_page_accessed(page);
 		page_cache_release(page);
@@ -3960,9 +3960,9 @@
 	for (i = 0; i < page_count; i++) {
 		struct page *page = shmem_read_mapping_page(mapping, i);
 		if (!IS_ERR(page)) {
-			char *dst = kmap_atomic(page);
+			char *dst = kmap_atomic(page, KM_USER0);
 			memcpy(dst, vaddr + i*PAGE_SIZE, PAGE_SIZE);
-			kunmap_atomic(dst);
+			kunmap_atomic(dst, KM_USER0);
 
 			drm_clflush_pages(&page, 1);
 
@@ -4023,10 +4023,10 @@
 		if (IS_ERR(page))
 			return PTR_ERR(page);
 
-		src = kmap_atomic(page);
+		src = kmap_atomic(page, KM_USER0);
 		dst = obj->phys_obj->handle->vaddr + (i * PAGE_SIZE);
 		memcpy(dst, src, PAGE_SIZE);
-		kunmap_atomic(src);
+		kunmap_atomic(src, KM_USER0);
 
 		mark_page_accessed(page);
 		page_cache_release(page);
--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
@@ -355,9 +355,9 @@
 		uint32_t page_offset = reloc->offset & ~PAGE_MASK;
 		char *vaddr;
 
-		vaddr = kmap_atomic(obj->pages[reloc->offset >> PAGE_SHIFT]);
+		vaddr = kmap_atomic(obj->pages[reloc->offset >> PAGE_SHIFT], KM_USER0);
 		*(uint32_t *)(vaddr + page_offset) = reloc->delta;
-		kunmap_atomic(vaddr);
+		kunmap_atomic(vaddr, KM_USER0);
 	} else {
 		struct drm_i915_private *dev_priv = dev->dev_private;
 		uint32_t __iomem *reloc_entry;
--- a/drivers/gpu/drm/i915/intel_opregion.c
+++ b/drivers/gpu/drm/i915/intel_opregion.c
@@ -26,7 +26,7 @@
  */
 
 #include <linux/acpi.h>
-#include <linux/acpi_io.h>
+/*#include <linux/acpi_io.h>*/
 #include <acpi/video.h>
 
 #include "drmP.h"
--- a/drivers/gpu/drm/ttm/ttm_page_alloc.c
+++ b/drivers/gpu/drm/ttm/ttm_page_alloc.c
@@ -205,7 +205,7 @@
 	return snprintf(buffer, PAGE_SIZE, "%u\n", val);
 }
 
-static const struct sysfs_ops ttm_pool_sysfs_ops = {
+static struct sysfs_ops ttm_pool_sysfs_ops = {
 	.show = &ttm_pool_show,
 	.store = &ttm_pool_store,
 };
--- a/include/drm/ttm/ttm_bo_driver.h
+++ b/include/drm/ttm/ttm_bo_driver.h
@@ -35,6 +35,7 @@
 #include "ttm/ttm_module.h"
 #include "drm_mm.h"
 #include "drm_global.h"
+#include "drm_compat.h"
 #include "linux/workqueue.h"
 #include "linux/fs.h"
 #include "linux/spinlock.h"
--- a/include/drm/drm_fb_helper.h
+++ b/include/drm/drm_fb_helper.h
@@ -32,7 +32,7 @@
 
 struct drm_fb_helper;
 
-#include <linux/kgdb.h>
+/* #include <linux/kgdb.h> */
 
 struct drm_fb_helper_crtc {
 	uint32_t crtc_id;
--- a/drivers/gpu/drm/radeon/radeon_clocks.c
+++ b/drivers/gpu/drm/radeon/radeon_clocks.c
@@ -91,7 +91,8 @@
 	return mclk;
 }
 
-#ifdef CONFIG_OF
+/* #ifdef CONFIG_OF */
+#if 0 /* not for SLE11-SP2 */
 /*
  * Read XTAL (ref clock), SCLK and MCLK from Open Firmware device
  * tree. Hopefully, ATI OF driver is kind enough to fill these
