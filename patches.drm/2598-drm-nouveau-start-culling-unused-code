From 08c770969a45361277d556f9fd3e2d70da42be65 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Sun, 22 Jul 2012 15:03:09 +1000
Subject: drm/nouveau: start culling unused code
Git-commit: 08c770969a45361277d556f9fd3e2d70da42be65
Patch-mainline: v3.7-rc3

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/nouveau/nouveau_drv.c   |    7 --
 drivers/gpu/drm/nouveau/nouveau_drv.h   |  135 -------------------------------
 drivers/gpu/drm/nouveau/nouveau_hw.c    |    8 +-
 drivers/gpu/drm/nouveau/nouveau_hw.h    |   25 ------
 drivers/gpu/drm/nouveau/nouveau_irq.c   |    1 -
 drivers/gpu/drm/nouveau/nouveau_mem.c   |   23 -----
 drivers/gpu/drm/nouveau/nouveau_state.c |   32 -------
 drivers/gpu/drm/nouveau/nvd0_display.c  |   12 ---
 8 files changed, 4 insertions(+), 239 deletions(-)

Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_drv.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.c
@@ -86,13 +86,6 @@ MODULE_PARM_DESC(tv_norm, "Default TV no
 char *nouveau_tv_norm;
 module_param_named(tv_norm, nouveau_tv_norm, charp, 0400);
 
-MODULE_PARM_DESC(reg_debug, "Register access debug bitmask:\n"
-		"\t\t0x1 mc, 0x2 video, 0x4 fb, 0x8 extdev,\n"
-		"\t\t0x10 crtc, 0x20 ramdac, 0x40 vgacrtc, 0x80 rmvio,\n"
-		"\t\t0x100 vgaattr, 0x200 EVO (G80+)");
-int nouveau_reg_debug;
-module_param_named(reg_debug, nouveau_reg_debug, int, 0600);
-
 MODULE_PARM_DESC(perflvl, "Performance level (default: boot)");
 char *nouveau_perflvl;
 module_param_named(perflvl, nouveau_perflvl, charp, 0400);
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -64,15 +64,10 @@ enum blah {
 	NV_MEM_TYPE_GDDR5
 };
 
-#define DRM_FILE_PAGE_OFFSET (0x100000000ULL >> PAGE_SHIFT)
-
 #include <drm/nouveau_drm.h>
 #include "nouveau_reg.h"
 #include <nouveau_bios.h>
 
-struct nouveau_grctx;
-struct nouveau_mem;
-
 #include <subdev/bios/pll.h>
 #include "nouveau_compat.h"
 
@@ -85,18 +80,9 @@ struct nouveau_mem;
 #define nv50_vm_flush_engine(d,e) \
 	_nv50_vm_flush_engine((d), (e))
 
-#define MAX_NUM_DCB_ENTRIES 16
-
-#define NOUVEAU_MAX_CHANNEL_NR 4096
-
 #include "nouveau_bo.h"
 #include "nouveau_gem.h"
 
-enum nouveau_flags {
-	NV_NFORCE   = 0x10000000,
-	NV_NFORCE2  = 0x20000000
-};
-
 struct nouveau_page_flip_state {
 	struct list_head head;
 	struct drm_pending_vblank_event *event;
@@ -104,11 +90,6 @@ struct nouveau_page_flip_state {
 	uint64_t offset;
 };
 
-enum nouveau_channel_mutex_class {
-	NOUVEAU_UCHANNEL_MUTEX,
-	NOUVEAU_KCHANNEL_MUTEX
-};
-
 struct nouveau_display_engine {
 	void *priv;
 	int (*early_init)(struct drm_device *);
@@ -306,11 +287,8 @@ enum nouveau_card_type {
 	NV_E0      = 0xe0,
 };
 
-struct nouveau_channel;
-
 struct drm_nouveau_private {
 	struct drm_device *dev;
-	bool noaccel;
 
 	void *newpriv;
 
@@ -318,11 +296,8 @@ struct drm_nouveau_private {
 	enum nouveau_card_type card_type;
 	/* exact chipset, derived from NV_PMC_BOOT_0 */
 	int chipset;
-	int flags;
 	u32 crystal;
 
-	struct nouveau_bo *vga_ram;
-
 	/* interrupt handling */
 	void (*irq_handler[32])(struct drm_device *);
 	bool msi_enabled;
@@ -332,16 +307,8 @@ struct drm_nouveau_private {
 	/* For PFIFO and PGRAPH. */
 	spinlock_t context_switch_lock;
 
-	/* RAMIN configuration, RAMFC, RAMHT and RAMRO offsets */
-	struct nouveau_ramht  *ramht;
-
-	uint64_t fb_available_size;
-	uint64_t fb_mappable_pages;
-	int fb_mtrr;
-
 	struct nvbios vbios;
 	u8 *mxms;
-	struct list_head i2c_ports;
 
 	struct backlight_device *backlight;
 };
@@ -363,9 +330,7 @@ extern char *nouveau_vram_type;
 extern int nouveau_fbpercrtc;
 extern int nouveau_tv_disable;
 extern char *nouveau_tv_norm;
-extern int nouveau_reg_debug;
 extern int nouveau_ignorelid;
-extern int nouveau_noaccel;
 extern int nouveau_force_post;
 extern int nouveau_override_conntype;
 extern char *nouveau_perflvl;
@@ -382,34 +347,13 @@ extern int  nouveau_load(struct drm_devi
 extern int  nouveau_firstopen(struct drm_device *);
 extern void nouveau_lastclose(struct drm_device *);
 extern int  nouveau_unload(struct drm_device *);
-extern bool nouveau_wait_for_idle(struct drm_device *);
 extern int  nouveau_card_init(struct drm_device *);
 
 /* nouveau_mem.c */
-extern int  nouveau_mem_vram_init(struct drm_device *);
-extern void nouveau_mem_vram_fini(struct drm_device *);
-extern int  nouveau_mem_gart_init(struct drm_device *);
-extern void nouveau_mem_gart_fini(struct drm_device *);
-extern void nouveau_mem_close(struct drm_device *);
-extern bool nouveau_mem_flags_valid(struct drm_device *, u32 tile_flags);
 extern int  nouveau_mem_timing_calc(struct drm_device *, u32 freq,
 				    struct nouveau_pm_memtiming *);
 extern void nouveau_mem_timing_read(struct drm_device *,
 				    struct nouveau_pm_memtiming *);
-extern int nouveau_mem_vbios_type(struct drm_device *);
-extern struct nouveau_tile_reg *nv10_mem_set_tiling(
-	struct drm_device *dev, uint32_t addr, uint32_t size,
-	uint32_t pitch, uint32_t flags);
-extern void nv10_mem_put_tile_region(struct drm_device *dev,
-				     struct nouveau_tile_reg *tile,
-				     struct nouveau_fence *fence);
-
-extern int  nouveau_channel_idle(struct nouveau_channel *chan);
-
-/* nouveau_gpuobj.c */
-int  nouveau_gpuobj_map_vm(struct nouveau_gpuobj *gpuobj, struct nouveau_vm *vm,
-			   u32 flags, struct nouveau_vma *vma);
-void nouveau_gpuobj_unmap(struct nouveau_vma *vma);
 
 /* nouveau_irq.c */
 extern int         nouveau_irq_init(struct drm_device *);
@@ -586,26 +530,6 @@ int nouveau_display_dumb_destroy(struct
 	}                                                                      \
 } while(0)
 
-/* nouveau_reg_debug bitmask */
-enum {
-	NOUVEAU_REG_DEBUG_MC             = 0x1,
-	NOUVEAU_REG_DEBUG_VIDEO          = 0x2,
-	NOUVEAU_REG_DEBUG_FB             = 0x4,
-	NOUVEAU_REG_DEBUG_EXTDEV         = 0x8,
-	NOUVEAU_REG_DEBUG_CRTC           = 0x10,
-	NOUVEAU_REG_DEBUG_RAMDAC         = 0x20,
-	NOUVEAU_REG_DEBUG_VGACRTC        = 0x40,
-	NOUVEAU_REG_DEBUG_RMVIO          = 0x80,
-	NOUVEAU_REG_DEBUG_VGAATTR        = 0x100,
-	NOUVEAU_REG_DEBUG_EVO            = 0x200,
-	NOUVEAU_REG_DEBUG_AUXCH          = 0x400
-};
-
-#define NV_REG_DEBUG(type, dev, fmt, arg...) do { \
-	if (nouveau_reg_debug & NOUVEAU_REG_DEBUG_##type) \
-		NV_PRINTK(KERN_DEBUG, dev, "%s: " fmt, __func__, ##arg); \
-} while (0)
-
 static inline bool
 nv_two_heads(struct drm_device *dev)
 {
@@ -645,63 +569,4 @@ nv_match_device(struct drm_device *dev,
 		dev->pdev->subsystem_device == sub_device;
 }
 
-/* returns 1 if device is one of the nv4x using the 0x4497 object class,
- * helpful to determine a number of other hardware features
- */
-static inline int
-nv44_graph_class(struct drm_device *dev)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-
-	if ((dev_priv->chipset & 0xf0) == 0x60)
-		return 1;
-
-	return !(0x0baf & (1 << (dev_priv->chipset & 0x0f)));
-}
-
-/* memory type/access flags, do not match hardware values */
-#define NV_MEM_ACCESS_RO  1
-#define NV_MEM_ACCESS_WO  2
-#define NV_MEM_ACCESS_RW (NV_MEM_ACCESS_RO | NV_MEM_ACCESS_WO)
-#define NV_MEM_ACCESS_SYS 4
-#define NV_MEM_ACCESS_VM  8
-#define NV_MEM_ACCESS_NOSNOOP 16
-
-#define NV_MEM_TARGET_VRAM        0
-#define NV_MEM_TARGET_PCI         1
-#define NV_MEM_TARGET_PCI_NOSNOOP 2
-#define NV_MEM_TARGET_VM          3
-#define NV_MEM_TARGET_GART        4
-
-#define NV_MEM_TYPE_VM 0x7f
-#define NV_MEM_COMP_VM 0x03
-
-/* FIFO methods */
-#define NV01_SUBCHAN_OBJECT                                          0x00000000
-#define NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH                          0x00000010
-#define NV84_SUBCHAN_SEMAPHORE_ADDRESS_LOW                           0x00000014
-#define NV84_SUBCHAN_SEMAPHORE_SEQUENCE                              0x00000018
-#define NV84_SUBCHAN_SEMAPHORE_TRIGGER                               0x0000001c
-#define NV84_SUBCHAN_SEMAPHORE_TRIGGER_ACQUIRE_EQUAL                 0x00000001
-#define NV84_SUBCHAN_SEMAPHORE_TRIGGER_WRITE_LONG                    0x00000002
-#define NV84_SUBCHAN_SEMAPHORE_TRIGGER_ACQUIRE_GEQUAL                0x00000004
-#define NVC0_SUBCHAN_SEMAPHORE_TRIGGER_YIELD                         0x00001000
-#define NV84_SUBCHAN_NOTIFY_INTR                                     0x00000020
-#define NV84_SUBCHAN_WRCACHE_FLUSH                                   0x00000024
-#define NV10_SUBCHAN_REF_CNT                                         0x00000050
-#define NVSW_SUBCHAN_PAGE_FLIP                                       0x00000054
-#define NV11_SUBCHAN_DMA_SEMAPHORE                                   0x00000060
-#define NV11_SUBCHAN_SEMAPHORE_OFFSET                                0x00000064
-#define NV11_SUBCHAN_SEMAPHORE_ACQUIRE                               0x00000068
-#define NV11_SUBCHAN_SEMAPHORE_RELEASE                               0x0000006c
-#define NV40_SUBCHAN_YIELD                                           0x00000080
-
-/* NV_SW object class */
-#define NV_SW                                                        0x0000506e
-#define NV_SW_DMA_VBLSEM                                             0x0000018c
-#define NV_SW_VBLSEM_OFFSET                                          0x00000400
-#define NV_SW_VBLSEM_RELEASE_VALUE                                   0x00000404
-#define NV_SW_VBLSEM_RELEASE                                         0x00000408
-#define NV_SW_PAGE_FLIP                                              0x00000500
-
 #endif /* __NOUVEAU_DRV_H__ */
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_hw.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_hw.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_hw.c
@@ -674,10 +674,10 @@ nv_load_state_ext(struct drm_device *dev
 		nvWriteVIDEO(dev, NV_PVIDEO_INTR_EN, 0);
 		nvWriteVIDEO(dev, NV_PVIDEO_OFFSET_BUFF(0), 0);
 		nvWriteVIDEO(dev, NV_PVIDEO_OFFSET_BUFF(1), 0);
-		nvWriteVIDEO(dev, NV_PVIDEO_LIMIT(0), dev_priv->fb_available_size - 1);
-		nvWriteVIDEO(dev, NV_PVIDEO_LIMIT(1), dev_priv->fb_available_size - 1);
-		nvWriteVIDEO(dev, NV_PVIDEO_UVPLANE_LIMIT(0), dev_priv->fb_available_size - 1);
-		nvWriteVIDEO(dev, NV_PVIDEO_UVPLANE_LIMIT(1), dev_priv->fb_available_size - 1);
+		nvWriteVIDEO(dev, NV_PVIDEO_LIMIT(0), 0); //dev_priv->fb_available_size - 1);
+		nvWriteVIDEO(dev, NV_PVIDEO_LIMIT(1), 0); //dev_priv->fb_available_size - 1);
+		nvWriteVIDEO(dev, NV_PVIDEO_UVPLANE_LIMIT(0), 0); //dev_priv->fb_available_size - 1);
+		nvWriteVIDEO(dev, NV_PVIDEO_UVPLANE_LIMIT(1), 0); //dev_priv->fb_available_size - 1);
 		nvWriteMC(dev, NV_PBUS_POWERCTRL_2, 0);
 
 		NVWriteCRTC(dev, head, NV_PCRTC_CURSOR_CONFIG, regp->cursor_cfg);
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_hw.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_hw.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_hw.h
@@ -61,14 +61,12 @@ static inline uint32_t
 nvReadMC(struct drm_device *dev, uint32_t reg)
 {
 	uint32_t val = nv_rd32(dev, reg);
-	NV_REG_DEBUG(MC, dev, "reg %08x val %08x\n", reg, val);
 	return val;
 }
 
 static inline void
 nvWriteMC(struct drm_device *dev, uint32_t reg, uint32_t val)
 {
-	NV_REG_DEBUG(MC, dev, "reg %08x val %08x\n", reg, val);
 	nv_wr32(dev, reg, val);
 }
 
@@ -76,14 +74,12 @@ static inline uint32_t
 nvReadVIDEO(struct drm_device *dev, uint32_t reg)
 {
 	uint32_t val = nv_rd32(dev, reg);
-	NV_REG_DEBUG(VIDEO, dev, "reg %08x val %08x\n", reg, val);
 	return val;
 }
 
 static inline void
 nvWriteVIDEO(struct drm_device *dev, uint32_t reg, uint32_t val)
 {
-	NV_REG_DEBUG(VIDEO, dev, "reg %08x val %08x\n", reg, val);
 	nv_wr32(dev, reg, val);
 }
 
@@ -91,14 +87,12 @@ static inline uint32_t
 nvReadFB(struct drm_device *dev, uint32_t reg)
 {
 	uint32_t val = nv_rd32(dev, reg);
-	NV_REG_DEBUG(FB, dev, "reg %08x val %08x\n", reg, val);
 	return val;
 }
 
 static inline void
 nvWriteFB(struct drm_device *dev, uint32_t reg, uint32_t val)
 {
-	NV_REG_DEBUG(FB, dev, "reg %08x val %08x\n", reg, val);
 	nv_wr32(dev, reg, val);
 }
 
@@ -106,14 +100,12 @@ static inline uint32_t
 nvReadEXTDEV(struct drm_device *dev, uint32_t reg)
 {
 	uint32_t val = nv_rd32(dev, reg);
-	NV_REG_DEBUG(EXTDEV, dev, "reg %08x val %08x\n", reg, val);
 	return val;
 }
 
 static inline void
 nvWriteEXTDEV(struct drm_device *dev, uint32_t reg, uint32_t val)
 {
-	NV_REG_DEBUG(EXTDEV, dev, "reg %08x val %08x\n", reg, val);
 	nv_wr32(dev, reg, val);
 }
 
@@ -124,7 +116,6 @@ static inline uint32_t NVReadCRTC(struct
 	if (head)
 		reg += NV_PCRTC0_SIZE;
 	val = nv_rd32(dev, reg);
-	NV_REG_DEBUG(CRTC, dev, "head %d reg %08x val %08x\n", head, reg, val);
 	return val;
 }
 
@@ -133,7 +124,6 @@ static inline void NVWriteCRTC(struct dr
 {
 	if (head)
 		reg += NV_PCRTC0_SIZE;
-	NV_REG_DEBUG(CRTC, dev, "head %d reg %08x val %08x\n", head, reg, val);
 	nv_wr32(dev, reg, val);
 }
 
@@ -144,8 +134,6 @@ static inline uint32_t NVReadRAMDAC(stru
 	if (head)
 		reg += NV_PRAMDAC0_SIZE;
 	val = nv_rd32(dev, reg);
-	NV_REG_DEBUG(RAMDAC, dev, "head %d reg %08x val %08x\n",
-							head, reg, val);
 	return val;
 }
 
@@ -154,8 +142,6 @@ static inline void NVWriteRAMDAC(struct
 {
 	if (head)
 		reg += NV_PRAMDAC0_SIZE;
-	NV_REG_DEBUG(RAMDAC, dev, "head %d reg %08x val %08x\n",
-							head, reg, val);
 	nv_wr32(dev, reg, val);
 }
 
@@ -182,8 +168,6 @@ static inline void nv_write_tmds(struct
 static inline void NVWriteVgaCrtc(struct drm_device *dev,
 					int head, uint8_t index, uint8_t value)
 {
-	NV_REG_DEBUG(VGACRTC, dev, "head %d index 0x%02x data 0x%02x\n",
-							head, index, value);
 	nv_wr08(dev, NV_PRMCIO_CRX__COLOR + head * NV_PRMCIO_SIZE, index);
 	nv_wr08(dev, NV_PRMCIO_CR__COLOR + head * NV_PRMCIO_SIZE, value);
 }
@@ -194,8 +178,6 @@ static inline uint8_t NVReadVgaCrtc(stru
 	uint8_t val;
 	nv_wr08(dev, NV_PRMCIO_CRX__COLOR + head * NV_PRMCIO_SIZE, index);
 	val = nv_rd08(dev, NV_PRMCIO_CR__COLOR + head * NV_PRMCIO_SIZE);
-	NV_REG_DEBUG(VGACRTC, dev, "head %d index 0x%02x data 0x%02x\n",
-							head, index, val);
 	return val;
 }
 
@@ -238,7 +220,6 @@ static inline uint8_t NVReadPRMVIO(struc
 		reg += NV_PRMVIO_SIZE;
 
 	val = nv_rd08(dev, reg);
-	NV_REG_DEBUG(RMVIO, dev, "head %d reg %08x val %02x\n", head, reg, val);
 	return val;
 }
 
@@ -252,8 +233,6 @@ static inline void NVWritePRMVIO(struct
 	if (head && dev_priv->card_type == NV_40)
 		reg += NV_PRMVIO_SIZE;
 
-	NV_REG_DEBUG(RMVIO, dev, "head %d reg %08x val %02x\n",
-						head, reg, value);
 	nv_wr08(dev, reg, value);
 }
 
@@ -278,8 +257,6 @@ static inline void NVWriteVgaAttr(struct
 		index |= 0x20;
 
 	nv_rd08(dev, NV_PRMCIO_INP0__COLOR + head * NV_PRMCIO_SIZE);
-	NV_REG_DEBUG(VGAATTR, dev, "head %d index 0x%02x data 0x%02x\n",
-							head, index, value);
 	nv_wr08(dev, NV_PRMCIO_ARX + head * NV_PRMCIO_SIZE, index);
 	nv_wr08(dev, NV_PRMCIO_AR__WRITE + head * NV_PRMCIO_SIZE, value);
 }
@@ -296,8 +273,6 @@ static inline uint8_t NVReadVgaAttr(stru
 	nv_rd08(dev, NV_PRMCIO_INP0__COLOR + head * NV_PRMCIO_SIZE);
 	nv_wr08(dev, NV_PRMCIO_ARX + head * NV_PRMCIO_SIZE, index);
 	val = nv_rd08(dev, NV_PRMCIO_AR__READ + head * NV_PRMCIO_SIZE);
-	NV_REG_DEBUG(VGAATTR, dev, "head %d index 0x%02x data 0x%02x\n",
-							head, index, val);
 	return val;
 }
 
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_irq.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_irq.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_irq.c
@@ -34,7 +34,6 @@
 #include <nouveau_drm.h>
 #include "nouveau_drv.h"
 #include "nouveau_reg.h"
-#include <core/ramht.h>
 
 void
 nouveau_irq_preinstall(struct drm_device *dev)
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_mem.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_mem.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_mem.c
@@ -628,26 +628,3 @@ nouveau_mem_exec(struct nouveau_mem_exec
 
 	return 0;
 }
-
-int
-nouveau_mem_vbios_type(struct drm_device *dev)
-{
-	struct bit_entry M;
-	u8 ramcfg = (nv_rd32(dev, 0x101000) & 0x0000003c) >> 2;
-	if (!bit_table(dev, 'M', &M) || M.version != 2 || M.length < 5) {
-		u8 *table = ROMPTR(dev, M.data[3]);
-		if (table && table[0] == 0x10 && ramcfg < table[3]) {
-			u8 *entry = table + table[1] + (ramcfg * table[2]);
-			switch (entry[0] & 0x0f) {
-			case 0: return NV_MEM_TYPE_DDR2;
-			case 1: return NV_MEM_TYPE_DDR3;
-			case 2: return NV_MEM_TYPE_GDDR3;
-			case 3: return NV_MEM_TYPE_GDDR5;
-			default:
-				break;
-			}
-
-		}
-	}
-	return NV_MEM_TYPE_UNKNOWN;
-}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_state.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_state.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_state.c
@@ -348,11 +348,6 @@ static void nouveau_card_takedown(struct
 	nouveau_backlight_exit(dev);
 	nouveau_display_destroy(dev);
 
-	if (dev_priv->vga_ram) {
-		nouveau_bo_unpin(dev_priv->vga_ram);
-		nouveau_bo_ref(NULL, &dev_priv->vga_ram);
-	}
-
 	nouveau_bios_takedown(dev);
 	engine->display.late_takedown(dev);
 
@@ -407,8 +402,6 @@ int nouveau_load(struct drm_device *dev,
 	dev->dev_private = dev_priv;
 	dev_priv->dev = dev;
 
-	dev_priv->flags = flags & NOUVEAU_FLAGS;
-
 	NV_DEBUG(dev, "vendor: 0x%X device: 0x%X class: 0x%X\n",
 		 dev->pci_vendor, dev->pci_device, dev->pdev->class);
 
@@ -481,12 +474,6 @@ int nouveau_load(struct drm_device *dev,
 
 	nouveau_OF_copy_vbios_to_ramin(dev);
 
-	/* Special flags */
-	if (dev->pci_device == 0x01a0)
-		dev_priv->flags |= NV_NFORCE;
-	else if (dev->pci_device == 0x01f0)
-		dev_priv->flags |= NV_NFORCE2;
-
 	/* For kernel modesetting, init card now and bring up fbcon */
 	ret = nouveau_card_init(dev);
 	if (ret)
@@ -516,22 +503,3 @@ int nouveau_unload(struct drm_device *de
 	kfree(dev_priv);
 	return 0;
 }
-
-/* Waits for PGRAPH to go completely idle */
-bool nouveau_wait_for_idle(struct drm_device *dev)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	uint32_t mask = ~0;
-
-	if (dev_priv->card_type == NV_40)
-		mask &= ~NV40_PGRAPH_STATUS_SYNC_STALL;
-
-	if (!nv_wait(dev, NV04_PGRAPH_STATUS, mask, 0)) {
-		NV_ERROR(dev, "PGRAPH idle timed out with status 0x%08x\n",
-			 nv_rd32(dev, NV04_PGRAPH_STATUS));
-		return false;
-	}
-
-	return true;
-}
-
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nvd0_display.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nvd0_display.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nvd0_display.c
@@ -115,9 +115,6 @@ evo_wait(struct drm_device *dev, int id,
 		put = 0;
 	}
 
-	if (nouveau_reg_debug & NOUVEAU_REG_DEBUG_EVO)
-		NV_INFO(dev, "Evo%d: %p START\n", id, disp->evo[id].ptr + put);
-
 	return disp->evo[id].ptr + put;
 }
 
@@ -126,15 +123,6 @@ evo_kick(u32 *push, struct drm_device *d
 {
 	struct nvd0_display *disp = nvd0_display(dev);
 
-	if (nouveau_reg_debug & NOUVEAU_REG_DEBUG_EVO) {
-		u32 curp = nv_rd32(dev, 0x640000 + (id * 0x1000)) >> 2;
-		u32 *cur = disp->evo[id].ptr + curp;
-
-		while (cur < push)
-			NV_INFO(dev, "Evo%d: 0x%08x\n", id, *cur++);
-		NV_INFO(dev, "Evo%d: %p KICK!\n", id, push);
-	}
-
 	nv_wr32(dev, 0x640000 + (id * 0x1000), (push - disp->evo[id].ptr) << 2);
 }
 
