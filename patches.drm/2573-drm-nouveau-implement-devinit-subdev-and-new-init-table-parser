From cb75d97e9c77743ecfcc43375be135a55a4d9b25 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Wed, 11 Jul 2012 10:44:20 +1000
Subject: drm/nouveau: implement devinit subdev, and new init table parser
Git-commit: cb75d97e9c77743ecfcc43375be135a55a4d9b25
Patch-mainline: v3.7-rc3

v2:
- make sure not to execute display scripts unless resuming

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/nouveau/Makefile                   |   10 +
 .../drm/nouveau/core/include/subdev/bios/conn.h    |   27 +
 .../gpu/drm/nouveau/core/include/subdev/bios/dcb.h |   73 +-
 .../gpu/drm/nouveau/core/include/subdev/bios/dp.h  |    8 +
 .../drm/nouveau/core/include/subdev/bios/init.h    |   21 +
 .../gpu/drm/nouveau/core/include/subdev/devinit.h  |   40 +
 drivers/gpu/drm/nouveau/core/subdev/bios/conn.c    |   55 +
 drivers/gpu/drm/nouveau/core/subdev/bios/dp.c      |   76 +
 drivers/gpu/drm/nouveau/core/subdev/bios/init.c    | 2120 ++++++++++++
 drivers/gpu/drm/nouveau/core/subdev/device/nv04.c  |    3 +
 drivers/gpu/drm/nouveau/core/subdev/device/nv10.c  |    9 +
 drivers/gpu/drm/nouveau/core/subdev/device/nv20.c  |    5 +
 drivers/gpu/drm/nouveau/core/subdev/device/nv30.c  |    6 +
 drivers/gpu/drm/nouveau/core/subdev/device/nv40.c  |   17 +
 drivers/gpu/drm/nouveau/core/subdev/device/nv50.c  |   15 +
 drivers/gpu/drm/nouveau/core/subdev/device/nvc0.c  |    9 +
 drivers/gpu/drm/nouveau/core/subdev/device/nve0.c  |    3 +
 drivers/gpu/drm/nouveau/core/subdev/devinit/base.c |   69 +
 .../gpu/drm/nouveau/core/subdev/devinit/fbmem.h    |   98 +
 drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c |  189 ++
 drivers/gpu/drm/nouveau/core/subdev/devinit/nv05.c |  159 +
 drivers/gpu/drm/nouveau/core/subdev/devinit/nv10.c |  124 +
 drivers/gpu/drm/nouveau/core/subdev/devinit/nv1a.c |   58 +
 drivers/gpu/drm/nouveau/core/subdev/devinit/nv20.c |   96 +
 drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.c |   87 +
 drivers/gpu/drm/nouveau/nouveau_agp.c              |   72 +-
 drivers/gpu/drm/nouveau/nouveau_agp.h              |    8 +-
 drivers/gpu/drm/nouveau/nouveau_backlight.c        |    4 +-
 drivers/gpu/drm/nouveau/nouveau_bios.c             | 3535 +-------------------
 drivers/gpu/drm/nouveau/nouveau_bios.h             |   64 +-
 drivers/gpu/drm/nouveau/nouveau_compat.c           |   38 +
 drivers/gpu/drm/nouveau/nouveau_compat.h           |    6 +
 drivers/gpu/drm/nouveau/nouveau_connector.c        |   84 +-
 drivers/gpu/drm/nouveau/nouveau_dp.c               |    4 +-
 drivers/gpu/drm/nouveau/nouveau_drm.c              |   36 +
 drivers/gpu/drm/nouveau/nouveau_drm.h              |   10 +
 drivers/gpu/drm/nouveau/nouveau_drv.c              |    7 -
 drivers/gpu/drm/nouveau/nouveau_drv.h              |   23 +-
 drivers/gpu/drm/nouveau/nouveau_encoder.h          |   14 +-
 drivers/gpu/drm/nouveau/nouveau_hw.h               |    4 +-
 drivers/gpu/drm/nouveau/nouveau_mem.c              |    6 +-
 drivers/gpu/drm/nouveau/nouveau_mxm.c              |    4 +-
 drivers/gpu/drm/nouveau/nouveau_state.c            |    4 -
 drivers/gpu/drm/nouveau/nv04_crtc.c                |   10 +-
 drivers/gpu/drm/nouveau/nv04_dac.c                 |   26 +-
 drivers/gpu/drm/nouveau/nv04_dfp.c                 |   46 +-
 drivers/gpu/drm/nouveau/nv04_display.c             |   76 +-
 drivers/gpu/drm/nouveau/nv04_tv.c                  |    2 +-
 drivers/gpu/drm/nouveau/nv17_tv.c                  |   12 +-
 drivers/gpu/drm/nouveau/nv50_dac.c                 |    6 +-
 drivers/gpu/drm/nouveau/nv50_display.c             |  128 +-
 drivers/gpu/drm/nouveau/nv50_display.h             |    2 +-
 drivers/gpu/drm/nouveau/nv50_sor.c                 |   30 +-
 drivers/gpu/drm/nouveau/nvd0_display.c             |   70 +-
 54 files changed, 3795 insertions(+), 3913 deletions(-)

Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/Makefile
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/Makefile
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/Makefile
@@ -20,9 +20,12 @@ nouveau-y += core/core/subdev.o
 
 nouveau-y += core/subdev/bios/base.o
 nouveau-y += core/subdev/bios/bit.o
+nouveau-y += core/subdev/bios/conn.o
 nouveau-y += core/subdev/bios/dcb.o
+nouveau-y += core/subdev/bios/dp.o
 nouveau-y += core/subdev/bios/gpio.o
 nouveau-y += core/subdev/bios/i2c.o
+nouveau-y += core/subdev/bios/init.o
 nouveau-y += core/subdev/bios/pll.o
 nouveau-y += core/subdev/clock/nv04.o
 nouveau-y += core/subdev/clock/nv40.o
@@ -40,6 +43,13 @@ nouveau-y += core/subdev/device/nv40.o
 nouveau-y += core/subdev/device/nv50.o
 nouveau-y += core/subdev/device/nvc0.o
 nouveau-y += core/subdev/device/nve0.o
+nouveau-y += core/subdev/devinit/base.o
+nouveau-y += core/subdev/devinit/nv04.o
+nouveau-y += core/subdev/devinit/nv05.o
+nouveau-y += core/subdev/devinit/nv10.o
+nouveau-y += core/subdev/devinit/nv1a.o
+nouveau-y += core/subdev/devinit/nv20.o
+nouveau-y += core/subdev/devinit/nv50.o
 nouveau-y += core/subdev/fb/nv04.o
 nouveau-y += core/subdev/fb/nv10.o
 nouveau-y += core/subdev/fb/nv20.o
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/include/subdev/bios/conn.h
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/include/subdev/bios/conn.h
@@ -0,0 +1,27 @@
+#ifndef __NVBIOS_CONN_H__
+#define __NVBIOS_CONN_H__
+
+enum dcb_connector_type {
+	DCB_CONNECTOR_VGA = 0x00,
+	DCB_CONNECTOR_TV_0 = 0x10,
+	DCB_CONNECTOR_TV_1 = 0x11,
+	DCB_CONNECTOR_TV_3 = 0x13,
+	DCB_CONNECTOR_DVI_I = 0x30,
+	DCB_CONNECTOR_DVI_D = 0x31,
+	DCB_CONNECTOR_DMS59_0 = 0x38,
+	DCB_CONNECTOR_DMS59_1 = 0x39,
+	DCB_CONNECTOR_LVDS = 0x40,
+	DCB_CONNECTOR_LVDS_SPWG = 0x41,
+	DCB_CONNECTOR_DP = 0x46,
+	DCB_CONNECTOR_eDP = 0x47,
+	DCB_CONNECTOR_HDMI_0 = 0x60,
+	DCB_CONNECTOR_HDMI_1 = 0x61,
+	DCB_CONNECTOR_DMS59_DP0 = 0x64,
+	DCB_CONNECTOR_DMS59_DP1 = 0x65,
+	DCB_CONNECTOR_NONE = 0xff
+};
+
+u16 dcb_conntab(struct nouveau_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len);
+u16 dcb_conn(struct nouveau_bios *bios, u8 idx, u8 *ver, u8 *len);
+
+#endif
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/include/subdev/bios/dcb.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/core/include/subdev/bios/dcb.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/include/subdev/bios/dcb.h
@@ -1,14 +1,56 @@
 #ifndef __NVBIOS_DCB_H__
 #define __NVBIOS_DCB_H__
 
+struct nouveau_bios;
+
 enum dcb_output_type {
 	DCB_OUTPUT_ANALOG	= 0x0,
 	DCB_OUTPUT_TV		= 0x1,
 	DCB_OUTPUT_TMDS		= 0x2,
 	DCB_OUTPUT_LVDS		= 0x3,
-	DCB_OUTPUT_DP		= 0x4,
+	DCB_OUTPUT_DP		= 0x6,
 	DCB_OUTPUT_EOL		= 0xe,
 	DCB_OUTPUT_UNUSED	= 0xf,
+	DCB_OUTPUT_ANY = -1,
+};
+
+struct dcb_output {
+	int index;	/* may not be raw dcb index if merging has happened */
+	enum dcb_output_type type;
+	uint8_t i2c_index;
+	uint8_t heads;
+	uint8_t connector;
+	uint8_t bus;
+	uint8_t location;
+	uint8_t or;
+	bool duallink_possible;
+	union {
+		struct sor_conf {
+			int link;
+		} sorconf;
+		struct {
+			int maxfreq;
+		} crtconf;
+		struct {
+			struct sor_conf sor;
+			bool use_straps_for_mode;
+			bool use_acpi_for_edid;
+			bool use_power_scripts;
+		} lvdsconf;
+		struct {
+			bool has_component_output;
+		} tvconf;
+		struct {
+			struct sor_conf sor;
+			int link_nr;
+			int link_bw;
+		} dpconf;
+		struct {
+			struct sor_conf sor;
+			int slave_addr;
+		} tmdsconf;
+	};
+	bool i2c_upper_default;
 };
 
 u16 dcb_table(struct nouveau_bios *, u8 *ver, u8 *hdr, u8 *ent, u8 *len);
@@ -16,4 +58,33 @@ u16 dcb_outp(struct nouveau_bios *, u8 i
 int dcb_outp_foreach(struct nouveau_bios *, void *data, int (*exec)
 		     (struct nouveau_bios *, void *, int index, u16 entry));
 
+
+/* BIT 'U'/'d' table encoder subtables have hashes matching them to
+ * a particular set of encoders.
+ *
+ * This function returns true if a particular DCB entry matches.
+ */
+static inline bool
+dcb_hash_match(struct dcb_output *dcb, u32 hash)
+{
+	if ((hash & 0x000000f0) != (dcb->location << 4))
+		return false;
+	if ((hash & 0x0000000f) != dcb->type)
+		return false;
+	if (!(hash & (dcb->or << 16)))
+		return false;
+
+	switch (dcb->type) {
+	case DCB_OUTPUT_TMDS:
+	case DCB_OUTPUT_LVDS:
+	case DCB_OUTPUT_DP:
+		if (hash & 0x00c00000) {
+			if (!(hash & (dcb->sorconf.link << 22)))
+				return false;
+		}
+	default:
+		return true;
+	}
+}
+
 #endif
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/include/subdev/bios/dp.h
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/include/subdev/bios/dp.h
@@ -0,0 +1,8 @@
+#ifndef __NVBIOS_DP_H__
+#define __NVBIOS_DP_H__
+
+u16 dp_table(struct nouveau_bios *, u8 *ver, u8 *hdr, u8 *cnt, u8 *len);
+u16 dp_outp(struct nouveau_bios *, u8 idx, u8 *ver, u8 *len);
+u16 dp_outp_match(struct nouveau_bios *, struct dcb_output *, u8 *ver, u8 *len);
+
+#endif
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/include/subdev/bios/init.h
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/include/subdev/bios/init.h
@@ -0,0 +1,21 @@
+#ifndef __NVBIOS_INIT_H__
+#define __NVBIOS_INIT_H__
+
+struct nvbios_init {
+	struct nouveau_subdev *subdev;
+	struct nouveau_bios *bios;
+	u16 offset;
+	struct dcb_output *outp;
+	int crtc;
+
+	/* internal state used during parsing */
+	u8 execute;
+	u32 nested;
+	u16 repeat;
+	u16 repend;
+};
+
+int nvbios_exec(struct nvbios_init *);
+int nvbios_init(struct nouveau_subdev *, bool execute);
+
+#endif
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/include/subdev/devinit.h
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/include/subdev/devinit.h
@@ -0,0 +1,40 @@
+#ifndef __NOUVEAU_DEVINIT_H__
+#define __NOUVEAU_DEVINIT_H__
+
+#include <core/subdev.h>
+#include <core/device.h>
+
+struct nouveau_devinit {
+	struct nouveau_subdev base;
+	bool post;
+	void (*meminit)(struct nouveau_devinit *);
+};
+
+static inline struct nouveau_devinit *
+nouveau_devinit(void *obj)
+{
+	return (void *)nv_device(obj)->subdev[NVDEV_SUBDEV_DEVINIT];
+}
+
+#define nouveau_devinit_create(p,e,o,d)                                        \
+	nouveau_devinit_create_((p), (e), (o), sizeof(**d), (void **)d)
+#define nouveau_devinit_destroy(p)                                             \
+	nouveau_subdev_destroy(&(p)->base)
+
+int nouveau_devinit_create_(struct nouveau_object *, struct nouveau_object *,
+			    struct nouveau_oclass *, int, void **);
+int nouveau_devinit_init(struct nouveau_devinit *);
+int nouveau_devinit_fini(struct nouveau_devinit *, bool suspend);
+
+extern struct nouveau_oclass nv04_devinit_oclass;
+extern struct nouveau_oclass nv05_devinit_oclass;
+extern struct nouveau_oclass nv10_devinit_oclass;
+extern struct nouveau_oclass nv1a_devinit_oclass;
+extern struct nouveau_oclass nv20_devinit_oclass;
+extern struct nouveau_oclass nv50_devinit_oclass;
+
+void nv04_devinit_dtor(struct nouveau_object *);
+int  nv04_devinit_init(struct nouveau_object *);
+int  nv04_devinit_fini(struct nouveau_object *, bool);
+
+#endif
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/bios/conn.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/bios/conn.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/device.h>
+
+#include <subdev/bios.h>
+#include <subdev/bios/dcb.h>
+
+u16
+dcb_conntab(struct nouveau_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len)
+{
+	u16 dcb = dcb_table(bios, ver, hdr, cnt, len);
+	if (dcb && *ver >= 0x30 && *hdr >= 0x16) {
+		u16 data = nv_ro16(bios, dcb + 0x14);
+		if (data) {
+			*ver = nv_ro08(bios, data + 0);
+			*hdr = nv_ro08(bios, data + 1);
+			*cnt = nv_ro08(bios, data + 2);
+			*len = nv_ro08(bios, data + 3);
+			return data;
+		}
+	}
+	return 0x0000;
+}
+
+u16
+dcb_conn(struct nouveau_bios *bios, u8 idx, u8 *ver, u8 *len)
+{
+	u8  hdr, cnt;
+	u16 data = dcb_conntab(bios, ver, &hdr, &cnt, len);
+	if (data && idx < cnt)
+		return data + hdr + (idx * *len);
+	return 0x0000;
+}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/bios/dp.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/bios/dp.c
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+
+#include "subdev/bios.h"
+#include "subdev/bios/bit.h"
+#include "subdev/bios/dcb.h"
+#include "subdev/bios/dp.h"
+
+u16
+dp_table(struct nouveau_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len)
+{
+	struct bit_entry bit_d;
+
+	if (!bit_entry(bios, 'd', &bit_d)) {
+		if (bit_d.version == 1) {
+			u16 data = nv_ro16(bios, bit_d.offset);
+			if (data) {
+				*ver = nv_ro08(bios, data + 0);
+				*hdr = nv_ro08(bios, data + 1);
+				*len = nv_ro08(bios, data + 2);
+				*cnt = nv_ro08(bios, data + 3);
+				return data;
+			}
+		}
+	}
+
+	return 0x0000;
+}
+
+u16
+dp_outp(struct nouveau_bios *bios, u8 idx, u8 *ver, u8 *len)
+{
+	u8  hdr, cnt;
+	u16 table = dp_table(bios, ver, &hdr, &cnt, len);
+	if (table && idx < cnt)
+		return nv_ro16(bios, table + hdr + (idx * *len));
+	return 0xffff;
+}
+
+u16
+dp_outp_match(struct nouveau_bios *bios, struct dcb_output *outp,
+	      u8 *ver, u8 *len)
+{
+	u8  idx = 0;
+	u16 data;
+	while ((data = dp_outp(bios, idx++, ver, len)) != 0xffff) {
+		if (data) {
+			u32 hash = nv_ro32(bios, data);
+			if (dcb_hash_match(outp, hash))
+				return data;
+		}
+	}
+	return 0x0000;
+}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/bios/init.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/bios/init.c
@@ -0,0 +1,2120 @@
+#include <core/engine.h>
+#include <core/device.h>
+
+#include <subdev/bios.h>
+#include <subdev/bios/conn.h>
+#include <subdev/bios/bmp.h>
+#include <subdev/bios/bit.h>
+#include <subdev/bios/dcb.h>
+#include <subdev/bios/dp.h>
+#include <subdev/bios/init.h>
+#include <subdev/devinit.h>
+#include <subdev/clock.h>
+#include <subdev/i2c.h>
+#include <subdev/vga.h>
+#include <subdev/gpio.h>
+
+#define bioslog(lvl, fmt, args...) do {                                        \
+	nv_printk(init->bios, lvl, "0x%04x[%c]: "fmt, init->offset,            \
+		  init_exec(init) ? '0' + (init->nested - 1) : ' ', ##args);   \
+} while(0)
+#define cont(fmt, args...) do {                                                \
+	if (nv_subdev(init->bios)->debug >= NV_DBG_TRACE)                      \
+		printk(fmt, ##args);                                           \
+} while(0)
+#define trace(fmt, args...) bioslog(TRACE, fmt, ##args)
+#define warn(fmt, args...) bioslog(WARN, fmt, ##args)
+#define error(fmt, args...) bioslog(ERROR, fmt, ##args)
+
+/******************************************************************************
+ * init parser control flow helpers
+ *****************************************************************************/
+
+static inline bool
+init_exec(struct nvbios_init *init)
+{
+	return (init->execute == 1) || ((init->execute & 5) == 5);
+}
+
+static inline void
+init_exec_set(struct nvbios_init *init, bool exec)
+{
+	if (exec) init->execute &= 0xfd;
+	else      init->execute |= 0x02;
+}
+
+static inline void
+init_exec_inv(struct nvbios_init *init)
+{
+	init->execute ^= 0x02;
+}
+
+static inline void
+init_exec_force(struct nvbios_init *init, bool exec)
+{
+	if (exec) init->execute |= 0x04;
+	else      init->execute &= 0xfb;
+}
+
+/******************************************************************************
+ * init parser wrappers for normal register/i2c/whatever accessors
+ *****************************************************************************/
+
+static inline int
+init_or(struct nvbios_init *init)
+{
+	if (init->outp)
+		return ffs(init->outp->or) - 1;
+	error("script needs OR!!\n");
+	return 0;
+}
+
+static inline int
+init_link(struct nvbios_init *init)
+{
+	if (init->outp)
+		return !(init->outp->sorconf.link & 1);
+	error("script needs OR link\n");
+	return 0;
+}
+
+static inline int
+init_crtc(struct nvbios_init *init)
+{
+	if (init->crtc >= 0)
+		return init->crtc;
+	error("script needs crtc\n");
+	return 0;
+}
+
+static u8
+init_conn(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+
+	if (init->outp) {
+		u8  ver, len;
+		u16 conn = dcb_conn(bios, init->outp->connector, &ver, &len);
+		if (conn)
+			return nv_ro08(bios, conn);
+	}
+
+	error("script needs connector type\n");
+	return 0x00;
+}
+
+static inline u32
+init_nvreg(struct nvbios_init *init, u32 reg)
+{
+	/* C51 (at least) sometimes has the lower bits set which the VBIOS
+	 * interprets to mean that access needs to go through certain IO
+	 * ports instead.  The NVIDIA binary driver has been seen to access
+	 * these through the NV register address, so lets assume we can
+	 * do the same
+	 */
+	reg &= ~0x00000003;
+
+	/* GF8+ display scripts need register addresses mangled a bit to
+	 * select a specific CRTC/OR
+	 */
+	if (nv_device(init->bios)->card_type >= NV_50) {
+		if (reg & 0x80000000) {
+			reg += init_crtc(init) * 0x800;
+			reg &= ~0x80000000;
+		}
+
+		if (reg & 0x40000000) {
+			reg += init_or(init) * 0x800;
+			reg &= ~0x40000000;
+			if (reg & 0x20000000) {
+				reg += init_link(init) * 0x80;
+				reg &= ~0x20000000;
+			}
+		}
+	}
+
+	if (reg & ~0x00fffffc)
+		warn("unknown bits in register 0x%08x\n", reg);
+	return reg;
+}
+
+static u32
+init_rd32(struct nvbios_init *init, u32 reg)
+{
+	reg = init_nvreg(init, reg);
+	if (init_exec(init))
+		return nv_rd32(init->subdev, reg);
+	return 0x00000000;
+}
+
+static void
+init_wr32(struct nvbios_init *init, u32 reg, u32 val)
+{
+	reg = init_nvreg(init, reg);
+	if (init_exec(init))
+		nv_wr32(init->subdev, reg, val);
+}
+
+static u32
+init_mask(struct nvbios_init *init, u32 reg, u32 mask, u32 val)
+{
+	reg = init_nvreg(init, reg);
+	if (init_exec(init)) {
+		u32 tmp = nv_rd32(init->subdev, reg);
+		nv_wr32(init->subdev, reg, (tmp & ~mask) | val);
+		return tmp;
+	}
+	return 0x00000000;
+}
+
+static u8
+init_rdport(struct nvbios_init *init, u16 port)
+{
+	if (init_exec(init))
+		return nv_rdport(init->subdev, init->crtc, port);
+	return 0x00;
+}
+
+static void
+init_wrport(struct nvbios_init *init, u16 port, u8 value)
+{
+	if (init_exec(init))
+		nv_wrport(init->subdev, init->crtc, port, value);
+}
+
+static u8
+init_rdvgai(struct nvbios_init *init, u16 port, u8 index)
+{
+	struct nouveau_subdev *subdev = init->subdev;
+	if (init_exec(init)) {
+		int head = init->crtc < 0 ? 0 : init->crtc;
+		return nv_rdvgai(subdev, head, port, index);
+	}
+	return 0x00;
+}
+
+static void
+init_wrvgai(struct nvbios_init *init, u16 port, u8 index, u8 value)
+{
+	/* force head 0 for updates to cr44, it only exists on first head */
+	if (nv_device(init->subdev)->card_type < NV_50) {
+		if (port == 0x03d4 && index == 0x44)
+			init->crtc = 0;
+	}
+
+	if (init_exec(init)) {
+		int head = init->crtc < 0 ? 0 : init->crtc;
+		nv_wrvgai(init->subdev, head, port, index, value);
+	}
+
+	/* select head 1 if cr44 write selected it */
+	if (nv_device(init->subdev)->card_type < NV_50) {
+		if (port == 0x03d4 && index == 0x44 && value == 3)
+			init->crtc = 1;
+	}
+}
+
+static struct nouveau_i2c_port *
+init_i2c(struct nvbios_init *init, int index)
+{
+	struct nouveau_i2c *i2c = nouveau_i2c(init->bios);
+
+	if (index == 0xff) {
+		index = NV_I2C_DEFAULT(0);
+		if (init->outp && init->outp->i2c_upper_default)
+			index = NV_I2C_DEFAULT(1);
+	} else
+	if (index < 0) {
+		if (!init->outp) {
+			error("script needs output for i2c\n");
+			return NULL;
+		}
+
+		index = init->outp->i2c_index;
+	}
+
+	return i2c->find(i2c, index);
+}
+
+static int
+init_rdi2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg)
+{
+	struct nouveau_i2c_port *port = init_i2c(init, index);
+	if (port && init_exec(init))
+		return nv_rdi2cr(port, addr, reg);
+	return -ENODEV;
+}
+
+static int
+init_wri2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg, u8 val)
+{
+	struct nouveau_i2c_port *port = init_i2c(init, index);
+	if (port && init_exec(init))
+		return nv_wri2cr(port, addr, reg, val);
+	return -ENODEV;
+}
+
+static int
+init_rdauxr(struct nvbios_init *init, u32 addr)
+{
+	struct nouveau_i2c_port *port = init_i2c(init, -1);
+	u8 data;
+
+	if (port && init_exec(init)) {
+		int ret = nv_rdaux(port, addr, &data, 1);
+		if (ret)
+			return ret;
+		return data;
+	}
+
+	return -ENODEV;
+}
+
+static int
+init_wrauxr(struct nvbios_init *init, u32 addr, u8 data)
+{
+	struct nouveau_i2c_port *port = init_i2c(init, -1);
+	if (port && init_exec(init))
+		return nv_wraux(port, addr, &data, 1);
+	return -ENODEV;
+}
+
+static void
+init_prog_pll(struct nvbios_init *init, u32 id, u32 freq)
+{
+	struct nouveau_clock *clk = nouveau_clock(init->bios);
+	if (clk && clk->pll_set && init_exec(init)) {
+		int ret = clk->pll_set(clk, id, freq);
+		if (ret)
+			warn("failed to prog pll 0x%08x to %dkHz\n", id, freq);
+	}
+}
+
+/******************************************************************************
+ * parsing of bios structures that are required to execute init tables
+ *****************************************************************************/
+
+static u16
+init_table(struct nouveau_bios *bios, u16 *len)
+{
+	struct bit_entry bit_I;
+
+	if (!bit_entry(bios, 'I', &bit_I)) {
+		*len = bit_I.length;
+		return bit_I.offset;
+	}
+
+	if (bmp_version(bios) >= 0x0510) {
+		*len = 14;
+		return bios->bmp_offset + 75;
+	}
+
+	return 0x0000;
+}
+
+static u16
+init_table_(struct nvbios_init *init, u16 offset, const char *name)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 len, data = init_table(bios, &len);
+	if (data) {
+		if (len >= offset + 2) {
+			data = nv_ro16(bios, data + offset);
+			if (data)
+				return data;
+
+			warn("%s pointer invalid\n", name);
+			return 0x0000;
+		}
+
+		warn("init data too short for %s pointer", name);
+		return 0x0000;
+	}
+
+	warn("init data not found\n");
+	return 0x0000;
+}
+
+#define init_script_table(b) init_table_((b), 0x00, "script table")
+#define init_macro_index_table(b) init_table_((b), 0x02, "macro index table")
+#define init_macro_table(b) init_table_((b), 0x04, "macro table")
+#define init_condition_table(b) init_table_((b), 0x06, "condition table")
+#define init_io_condition_table(b) init_table_((b), 0x08, "io condition table")
+#define init_io_flag_condition_table(b) init_table_((b), 0x0a, "io flag conditon table")
+#define init_function_table(b) init_table_((b), 0x0c, "function table")
+#define init_xlat_table(b) init_table_((b), 0x10, "xlat table");
+
+static u16
+init_script(struct nouveau_bios *bios, int index)
+{
+	struct nvbios_init init = { .bios = bios };
+	u16 data;
+
+	if (bmp_version(bios) && bmp_version(bios) < 0x0510) {
+		if (index > 1)
+			return 0x0000;
+
+		data = bios->bmp_offset + (bios->version.major < 2 ? 14 : 18);
+		return nv_ro16(bios, data + (index * 2));
+	}
+
+	data = init_script_table(&init);
+	if (data)
+		return nv_ro16(bios, data + (index * 2));
+
+	return 0x0000;
+}
+
+static u16
+init_unknown_script(struct nouveau_bios *bios)
+{
+	u16 len, data = init_table(bios, &len);
+	if (data && len >= 16)
+		return nv_ro16(bios, data + 14);
+	return 0x0000;
+}
+
+static u16
+init_ram_restrict_table(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	struct bit_entry bit_M;
+	u16 data = 0x0000;
+
+	if (!bit_entry(bios, 'M', &bit_M)) {
+		if (bit_M.version == 1 && bit_M.length >= 5)
+			data = nv_ro16(bios, bit_M.offset + 3);
+		if (bit_M.version == 2 && bit_M.length >= 3)
+			data = nv_ro16(bios, bit_M.offset + 1);
+	}
+
+	if (data == 0x0000)
+		warn("ram restrict table not found\n");
+	return data;
+}
+
+static u8
+init_ram_restrict_group_count(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	struct bit_entry bit_M;
+
+	if (!bit_entry(bios, 'M', &bit_M)) {
+		if (bit_M.version == 1 && bit_M.length >= 5)
+			return nv_ro08(bios, bit_M.offset + 2);
+		if (bit_M.version == 2 && bit_M.length >= 3)
+			return nv_ro08(bios, bit_M.offset + 0);
+	}
+
+	return 0x00;
+}
+
+static u8
+init_ram_restrict(struct nvbios_init *init)
+{
+	u32 strap = (init_rd32(init, 0x101000) & 0x0000003c) >> 2;
+	u16 table = init_ram_restrict_table(init);
+	if (table)
+		return nv_ro08(init->bios, table + strap);
+	return 0x00;
+}
+
+static u8
+init_xlat_(struct nvbios_init *init, u8 index, u8 offset)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 table = init_xlat_table(init);
+	if (table) {
+		u16 data = nv_ro16(bios, table + (index * 2));
+		if (data)
+			return nv_ro08(bios, data + offset);
+		warn("xlat table pointer %d invalid\n", index);
+	}
+	return 0x00;
+}
+
+/******************************************************************************
+ * utility functions used by various init opcode handlers
+ *****************************************************************************/
+
+static bool
+init_condition_met(struct nvbios_init *init, u8 cond)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 table = init_condition_table(init);
+	if (table) {
+		u32 reg = nv_ro32(bios, table + (cond * 12) + 0);
+		u32 msk = nv_ro32(bios, table + (cond * 12) + 4);
+		u32 val = nv_ro32(bios, table + (cond * 12) + 8);
+		trace("\t[0x%02x] (R[0x%06x] & 0x%08x) == 0x%08x\n",
+		      cond, reg, msk, val);
+		return (init_rd32(init, reg) & msk) == val;
+	}
+	return false;
+}
+
+static bool
+init_io_condition_met(struct nvbios_init *init, u8 cond)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 table = init_io_condition_table(init);
+	if (table) {
+		u16 port = nv_ro16(bios, table + (cond * 5) + 0);
+		u8 index = nv_ro08(bios, table + (cond * 5) + 2);
+		u8  mask = nv_ro08(bios, table + (cond * 5) + 3);
+		u8 value = nv_ro08(bios, table + (cond * 5) + 4);
+		trace("\t[0x%02x] (0x%04x[0x%02x] & 0x%02x) == 0x%02x\n",
+		      cond, port, index, mask, value);
+		return (init_rdvgai(init, port, index) & mask) == value;
+	}
+	return false;
+}
+
+static bool
+init_io_flag_condition_met(struct nvbios_init *init, u8 cond)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 table = init_io_flag_condition_table(init);
+	if (table) {
+		u16 port = nv_ro16(bios, table + (cond * 9) + 0);
+		u8 index = nv_ro08(bios, table + (cond * 9) + 2);
+		u8  mask = nv_ro08(bios, table + (cond * 9) + 3);
+		u8 shift = nv_ro08(bios, table + (cond * 9) + 4);
+		u16 data = nv_ro16(bios, table + (cond * 9) + 5);
+		u8 dmask = nv_ro08(bios, table + (cond * 9) + 7);
+		u8 value = nv_ro08(bios, table + (cond * 9) + 8);
+		u8 ioval = (init_rdvgai(init, port, index) & mask) >> shift;
+		return (nv_ro08(bios, data + ioval) & dmask) == value;
+	}
+	return false;
+}
+
+static inline u32
+init_shift(u32 data, u8 shift)
+{
+	if (shift < 0x80)
+		return data >> shift;
+	return data << (0x100 - shift);
+}
+
+static u32
+init_tmds_reg(struct nvbios_init *init, u8 tmds)
+{
+	/* For mlv < 0x80, it is an index into a table of TMDS base addresses.
+	 * For mlv == 0x80 use the "or" value of the dcb_entry indexed by
+	 * CR58 for CR57 = 0 to index a table of offsets to the basic
+	 * 0x6808b0 address.
+	 * For mlv == 0x81 use the "or" value of the dcb_entry indexed by
+	 * CR58 for CR57 = 0 to index a table of offsets to the basic
+	 * 0x6808b0 address, and then flip the offset by 8.
+	 */
+
+	const int pramdac_offset[13] = {
+		0, 0, 0x8, 0, 0x2000, 0, 0, 0, 0x2008, 0, 0, 0, 0x2000 };
+	const u32 pramdac_table[4] = {
+		0x6808b0, 0x6808b8, 0x6828b0, 0x6828b8 };
+
+	if (tmds >= 0x80) {
+		if (init->outp) {
+			u32 dacoffset = pramdac_offset[init->outp->or];
+			if (tmds == 0x81)
+				dacoffset ^= 8;
+			return 0x6808b0 + dacoffset;
+		}
+
+		error("tmds opcodes need dcb\n");
+	} else {
+		if (tmds < ARRAY_SIZE(pramdac_table))
+			return pramdac_table[tmds];
+
+		error("tmds selector 0x%02x unknown\n", tmds);
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ * init opcode handlers
+ *****************************************************************************/
+
+/**
+ * init_reserved - stub for various unknown/unused single-byte opcodes
+ *
+ */
+static void
+init_reserved(struct nvbios_init *init)
+{
+	u8 opcode = nv_ro08(init->bios, init->offset);
+	trace("RESERVED\t0x%02x\n", opcode);
+	init->offset += 1;
+}
+
+/**
+ * INIT_DONE - opcode 0x71
+ *
+ */
+static void
+init_done(struct nvbios_init *init)
+{
+	trace("DONE\n");
+	init->offset = 0x0000;
+}
+
+/**
+ * INIT_IO_RESTRICT_PROG - opcode 0x32
+ *
+ */
+static void
+init_io_restrict_prog(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8 index = nv_ro08(bios, init->offset + 3);
+	u8  mask = nv_ro08(bios, init->offset + 4);
+	u8 shift = nv_ro08(bios, init->offset + 5);
+	u8 count = nv_ro08(bios, init->offset + 6);
+	u32  reg = nv_ro32(bios, init->offset + 7);
+	u8 conf, i;
+
+	trace("IO_RESTRICT_PROG\tR[0x%06x] = "
+	      "((0x%04x[0x%02x] & 0x%02x) >> %d) [{\n",
+	      reg, port, index, mask, shift);
+	init->offset += 11;
+
+	conf = (init_rdvgai(init, port, index) & mask) >> shift;
+	for (i = 0; i < count; i++) {
+		u32 data = nv_ro32(bios, init->offset);
+
+		if (i == conf) {
+			trace("\t0x%08x *\n", data);
+			init_wr32(init, reg, data);
+		} else {
+			trace("\t0x%08x\n", data);
+		}
+
+		init->offset += 4;
+	}
+	trace("}]\n");
+}
+
+/**
+ * INIT_REPEAT - opcode 0x33
+ *
+ */
+static void
+init_repeat(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 count = nv_ro08(bios, init->offset + 1);
+	u16 repeat = init->repeat;
+
+	trace("REPEAT\t0x%02x\n", count);
+	init->offset += 2;
+
+	init->repeat = init->offset;
+	init->repend = init->offset;
+	while (count--) {
+		init->offset = init->repeat;
+		nvbios_exec(init);
+		if (count)
+			trace("REPEAT\t0x%02x\n", count);
+	}
+	init->offset = init->repend;
+	init->repeat = repeat;
+}
+
+/**
+ * INIT_IO_RESTRICT_PLL - opcode 0x34
+ *
+ */
+static void
+init_io_restrict_pll(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8 index = nv_ro08(bios, init->offset + 3);
+	u8  mask = nv_ro08(bios, init->offset + 4);
+	u8 shift = nv_ro08(bios, init->offset + 5);
+	s8  iofc = nv_ro08(bios, init->offset + 6);
+	u8 count = nv_ro08(bios, init->offset + 7);
+	u32  reg = nv_ro32(bios, init->offset + 8);
+	u8 conf, i;
+
+	trace("IO_RESTRICT_PLL\tR[0x%06x] =PLL= "
+	      "((0x%04x[0x%02x] & 0x%02x) >> 0x%02x) IOFCOND 0x%02x [{\n",
+	      reg, port, index, mask, shift, iofc);
+	init->offset += 12;
+
+	conf = (init_rdvgai(init, port, index) & mask) >> shift;
+	for (i = 0; i < count; i++) {
+		u32 freq = nv_ro16(bios, init->offset) * 10;
+
+		if (i == conf) {
+			trace("\t%dkHz *\n", freq);
+			if (iofc > 0 && init_io_flag_condition_met(init, iofc))
+				freq *= 2;
+			init_prog_pll(init, reg, freq);
+		} else {
+			trace("\t%dkHz\n", freq);
+		}
+
+		init->offset += 2;
+	}
+	trace("}]\n");
+}
+
+/**
+ * INIT_END_REPEAT - opcode 0x36
+ *
+ */
+static void
+init_end_repeat(struct nvbios_init *init)
+{
+	trace("END_REPEAT\n");
+	init->offset += 1;
+
+	if (init->repeat) {
+		init->repend = init->offset;
+		init->offset = 0;
+	}
+}
+
+/**
+ * INIT_COPY - opcode 0x37
+ *
+ */
+static void
+init_copy(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u8 shift = nv_ro08(bios, init->offset + 5);
+	u8 smask = nv_ro08(bios, init->offset + 6);
+	u16 port = nv_ro16(bios, init->offset + 7);
+	u8 index = nv_ro08(bios, init->offset + 9);
+	u8  mask = nv_ro08(bios, init->offset + 10);
+	u8  data;
+
+	trace("COPY\t0x%04x[0x%02x] &= 0x%02x |= "
+	      "((R[0x%06x] %s 0x%02x) & 0x%02x)\n",
+	      port, index, mask, reg, (shift & 0x80) ? "<<" : ">>",
+	      (shift & 0x80) ? (0x100 - shift) : shift, smask);
+	init->offset += 11;
+
+	data  = init_rdvgai(init, port, index) & mask;
+	data |= init_shift(init_rd32(init, reg), shift) & smask;
+	init_wrvgai(init, port, index, data);
+}
+
+/**
+ * INIT_NOT - opcode 0x38
+ *
+ */
+static void
+init_not(struct nvbios_init *init)
+{
+	trace("NOT\n");
+	init->offset += 1;
+	init_exec_inv(init);
+}
+
+/**
+ * INIT_IO_FLAG_CONDITION - opcode 0x39
+ *
+ */
+static void
+init_io_flag_condition(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 cond = nv_ro08(bios, init->offset + 1);
+
+	trace("IO_FLAG_CONDITION\t0x%02x\n", cond);
+	init->offset += 2;
+
+	if (!init_io_flag_condition_met(init, cond))
+		init_exec_set(init, false);
+}
+
+/**
+ * INIT_DP_CONDITION - opcode 0x3a
+ *
+ */
+static void
+init_dp_condition(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  cond = nv_ro08(bios, init->offset + 1);
+	u8  unkn = nv_ro08(bios, init->offset + 2);
+	u8  ver, len;
+	u16 data;
+
+	trace("DP_CONDITION\t0x%02x 0x%02x\n", cond, unkn);
+	init->offset += 3;
+
+	switch (cond) {
+	case 0:
+		if (init_conn(init) != DCB_CONNECTOR_eDP)
+			init_exec_set(init, false);
+		break;
+	case 1:
+	case 2:
+		if ( init->outp &&
+		    (data = dp_outp_match(bios, init->outp, &ver, &len))) {
+			if (ver <= 0x40 && !(nv_ro08(bios, data + 5) & cond))
+				init_exec_set(init, false);
+			if (ver == 0x40 && !(nv_ro08(bios, data + 4) & cond))
+				init_exec_set(init, false);
+			break;
+		}
+
+		warn("script needs dp output table data\n");
+		break;
+	case 5:
+		if (!(init_rdauxr(init, 0x0d) & 1))
+			init_exec_set(init, false);
+		break;
+	default:
+		warn("unknown dp condition 0x%02x\n", cond);
+		break;
+	}
+}
+
+/**
+ * INIT_IO_MASK_OR - opcode 0x3b
+ *
+ */
+static void
+init_io_mask_or(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8    or = init_or(init);
+	u8  data;
+
+	trace("IO_MASK_OR\t0x03d4[0x%02x] &= ~(1 << 0x%02x)", index, or);
+	init->offset += 2;
+
+	data = init_rdvgai(init, 0x03d4, index);
+	init_wrvgai(init, 0x03d4, index, data &= ~(1 << or));
+}
+
+/**
+ * INIT_IO_OR - opcode 0x3c
+ *
+ */
+static void
+init_io_or(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8    or = init_or(init);
+	u8  data;
+
+	trace("IO_OR\t0x03d4[0x%02x] |= (1 << 0x%02x)", index, or);
+	init->offset += 2;
+
+	data = init_rdvgai(init, 0x03d4, index);
+	init_wrvgai(init, 0x03d4, index, data | (1 << or));
+}
+
+/**
+ * INIT_INDEX_ADDRESS_LATCHED - opcode 0x49
+ *
+ */
+static void
+init_idx_addr_latched(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 creg = nv_ro32(bios, init->offset + 1);
+	u32 dreg = nv_ro32(bios, init->offset + 5);
+	u32 mask = nv_ro32(bios, init->offset + 9);
+	u32 data = nv_ro32(bios, init->offset + 13);
+	u8 count = nv_ro08(bios, init->offset + 17);
+
+	trace("INDEX_ADDRESS_LATCHED\t"
+	      "R[0x%06x] : R[0x%06x]\n\tCTRL &= 0x%08x |= 0x%08x\n",
+	      creg, dreg, mask, data);
+	init->offset += 18;
+
+	while (count--) {
+		u8 iaddr = nv_ro08(bios, init->offset + 0);
+		u8 idata = nv_ro08(bios, init->offset + 1);
+
+		trace("\t[0x%02x] = 0x%02x\n", iaddr, idata);
+		init->offset += 2;
+
+		init_wr32(init, dreg, idata);
+		init_mask(init, creg, ~mask, data | idata);
+	}
+}
+
+/**
+ * INIT_IO_RESTRICT_PLL2 - opcode 0x4a
+ *
+ */
+static void
+init_io_restrict_pll2(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8 index = nv_ro08(bios, init->offset + 3);
+	u8  mask = nv_ro08(bios, init->offset + 4);
+	u8 shift = nv_ro08(bios, init->offset + 5);
+	u8 count = nv_ro08(bios, init->offset + 6);
+	u32  reg = nv_ro32(bios, init->offset + 7);
+	u8  conf, i;
+
+	trace("IO_RESTRICT_PLL2\t"
+	      "R[0x%06x] =PLL= ((0x%04x[0x%02x] & 0x%02x) >> 0x%02x) [{\n",
+	      reg, port, index, mask, shift);
+	init->offset += 11;
+
+	conf = (init_rdvgai(init, port, index) & mask) >> shift;
+	for (i = 0; i < count; i++) {
+		u32 freq = nv_ro32(bios, init->offset);
+		if (i == conf) {
+			trace("\t%dkHz *\n", freq);
+			init_prog_pll(init, reg, freq);
+		} else {
+			trace("\t%dkHz\n", freq);
+		}
+		init->offset += 4;
+	}
+	trace("}]\n");
+}
+
+/**
+ * INIT_PLL2 - opcode 0x4b
+ *
+ */
+static void
+init_pll2(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u32 freq = nv_ro32(bios, init->offset + 5);
+
+	trace("PLL2\tR[0x%06x] =PLL= %dkHz\n", reg, freq);
+	init->offset += 9;
+
+	init_prog_pll(init, reg, freq);
+}
+
+/**
+ * INIT_I2C_BYTE - opcode 0x4c
+ *
+ */
+static void
+init_i2c_byte(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
+	u8 count = nv_ro08(bios, init->offset + 3);
+
+	trace("I2C_BYTE\tI2C[0x%02x][0x%02x]\n", index, addr);
+	init->offset += 4;
+
+	while (count--) {
+		u8  reg = nv_ro08(bios, init->offset + 0);
+		u8 mask = nv_ro08(bios, init->offset + 1);
+		u8 data = nv_ro08(bios, init->offset + 2);
+		int val;
+
+		trace("\t[0x%02x] &= 0x%02x |= 0x%02x\n", reg, mask, data);
+		init->offset += 3;
+
+		val = init_rdi2cr(init, index, addr, reg);
+		if (val < 0)
+			continue;
+		init_wri2cr(init, index, addr, reg, (val & mask) | data);
+	}
+}
+
+/**
+ * INIT_ZM_I2C_BYTE - opcode 0x4d
+ *
+ */
+static void
+init_zm_i2c_byte(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
+	u8 count = nv_ro08(bios, init->offset + 3);
+
+	trace("ZM_I2C_BYTE\tI2C[0x%02x][0x%02x]\n", index, addr);
+	init->offset += 4;
+
+	while (count--) {
+		u8  reg = nv_ro08(bios, init->offset + 0);
+		u8 data = nv_ro08(bios, init->offset + 1);
+
+		trace("\t[0x%02x] = 0x%02x\n", reg, data);
+		init->offset += 2;
+
+		init_wri2cr(init, index, addr, reg, data);
+	}
+
+}
+
+/**
+ * INIT_ZM_I2C - opcode 0x4e
+ *
+ */
+static void
+init_zm_i2c(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
+	u8 count = nv_ro08(bios, init->offset + 3);
+	u8 data[256], i;
+
+	trace("ZM_I2C\tI2C[0x%02x][0x%02x]\n", index, addr);
+	init->offset += 4;
+
+	for (i = 0; i < count; i++) {
+		data[i] = nv_ro08(bios, init->offset);
+		trace("\t0x%02x\n", data[i]);
+		init->offset++;
+	}
+
+	if (init_exec(init)) {
+		struct nouveau_i2c_port *port = init_i2c(init, index);
+		struct i2c_msg msg = {
+			.addr = addr, .flags = 0, .len = count, .buf = data,
+		};
+		int ret;
+
+		if (port && (ret = i2c_transfer(&port->adapter, &msg, 1)) != 1)
+			warn("i2c wr failed, %d\n", ret);
+	}
+}
+
+/**
+ * INIT_TMDS - opcode 0x4f
+ *
+ */
+static void
+init_tmds(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 tmds = nv_ro08(bios, init->offset + 1);
+	u8 addr = nv_ro08(bios, init->offset + 2);
+	u8 mask = nv_ro08(bios, init->offset + 3);
+	u8 data = nv_ro08(bios, init->offset + 4);
+	u32 reg = init_tmds_reg(init, tmds);
+
+	trace("TMDS\tT[0x%02x][0x%02x] &= 0x%02x |= 0x%02x\n",
+	      tmds, addr, mask, data);
+	init->offset += 5;
+
+	if (reg == 0)
+		return;
+
+	init_wr32(init, reg + 0, addr | 0x00010000);
+	init_wr32(init, reg + 4, data | (init_rd32(init, reg + 4) & mask));
+	init_wr32(init, reg + 0, addr);
+}
+
+/**
+ * INIT_ZM_TMDS_GROUP - opcode 0x50
+ *
+ */
+static void
+init_zm_tmds_group(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  tmds = nv_ro08(bios, init->offset + 1);
+	u8 count = nv_ro08(bios, init->offset + 2);
+	u32  reg = init_tmds_reg(init, tmds);
+
+	trace("TMDS_ZM_GROUP\tT[0x%02x]\n", tmds);
+	init->offset += 3;
+
+	while (count--) {
+		u8 addr = nv_ro08(bios, init->offset + 0);
+		u8 data = nv_ro08(bios, init->offset + 1);
+
+		trace("\t[0x%02x] = 0x%02x\n", addr, data);
+		init->offset += 2;
+
+		init_wr32(init, reg + 4, data);
+		init_wr32(init, reg + 0, addr);
+	}
+}
+
+/**
+ * INIT_CR_INDEX_ADDRESS_LATCHED - opcode 0x51
+ *
+ */
+static void
+init_cr_idx_adr_latch(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 addr0 = nv_ro08(bios, init->offset + 1);
+	u8 addr1 = nv_ro08(bios, init->offset + 2);
+	u8  base = nv_ro08(bios, init->offset + 3);
+	u8 count = nv_ro08(bios, init->offset + 4);
+	u8 save0;
+
+	trace("CR_INDEX_ADDR C[%02x] C[%02x]\n", addr0, addr1);
+	init->offset += 5;
+
+	save0 = init_rdvgai(init, 0x03d4, addr0);
+	while (count--) {
+		u8 data = nv_ro08(bios, init->offset);
+
+		trace("\t\t[0x%02x] = 0x%02x\n", base, data);
+		init->offset += 1;
+
+		init_wrvgai(init, 0x03d4, addr0, base++);
+		init_wrvgai(init, 0x03d4, addr1, data);
+	}
+	init_wrvgai(init, 0x03d4, addr0, save0);
+}
+
+/**
+ * INIT_CR - opcode 0x52
+ *
+ */
+static void
+init_cr(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 addr = nv_ro08(bios, init->offset + 1);
+	u8 mask = nv_ro08(bios, init->offset + 2);
+	u8 data = nv_ro08(bios, init->offset + 3);
+	u8 val;
+
+	trace("CR\t\tC[0x%02x] &= 0x%02x |= 0x%02x\n", addr, mask, data);
+	init->offset += 4;
+
+	val = init_rdvgai(init, 0x03d4, addr) & mask;
+	init_wrvgai(init, 0x03d4, addr, val | data);
+}
+
+/**
+ * INIT_ZM_CR - opcode 0x53
+ *
+ */
+static void
+init_zm_cr(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 addr = nv_ro08(bios, init->offset + 1);
+	u8 data = nv_ro08(bios, init->offset + 2);
+
+	trace("ZM_CR\tC[0x%02x] = 0x%02x\n", addr,  data);
+	init->offset += 3;
+
+	init_wrvgai(init, 0x03d4, addr, data);
+}
+
+/**
+ * INIT_ZM_CR_GROUP - opcode 0x54
+ *
+ */
+static void
+init_zm_cr_group(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 count = nv_ro08(bios, init->offset + 1);
+
+	trace("ZM_CR_GROUP\n");
+	init->offset += 2;
+
+	while (count--) {
+		u8 addr = nv_ro08(bios, init->offset + 0);
+		u8 data = nv_ro08(bios, init->offset + 1);
+
+		trace("\t\tC[0x%02x] = 0x%02x\n", addr, data);
+		init->offset += 2;
+
+		init_wrvgai(init, 0x03d4, addr, data);
+	}
+}
+
+/**
+ * INIT_CONDITION_TIME - opcode 0x56
+ *
+ */
+static void
+init_condition_time(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  cond = nv_ro08(bios, init->offset + 1);
+	u8 retry = nv_ro08(bios, init->offset + 2);
+	u8  wait = min((u16)retry * 50, 100);
+
+	trace("CONDITION_TIME\t0x%02x 0x%02x\n", cond, retry);
+	init->offset += 3;
+
+	if (!init_exec(init))
+		return;
+
+	while (wait--) {
+		if (init_condition_met(init, cond))
+			return;
+		mdelay(20);
+	}
+
+	init_exec_set(init, false);
+}
+
+/**
+ * INIT_LTIME - opcode 0x57
+ *
+ */
+static void
+init_ltime(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 msec = nv_ro16(bios, init->offset + 1);
+
+	trace("LTIME\t0x%04x\n", msec);
+	init->offset += 3;
+
+	if (init_exec(init))
+		mdelay(msec);
+}
+
+/**
+ * INIT_ZM_REG_SEQUENCE - opcode 0x58
+ *
+ */
+static void
+init_zm_reg_sequence(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 base = nv_ro32(bios, init->offset + 1);
+	u8 count = nv_ro08(bios, init->offset + 5);
+
+	trace("ZM_REG_SEQUENCE\t0x%02x\n", count);
+	init->offset += 6;
+
+	while (count--) {
+		u32 data = nv_ro32(bios, init->offset);
+
+		trace("\t\tR[0x%06x] = 0x%08x\n", base, data);
+		init->offset += 4;
+
+		init_wr32(init, base, data);
+		base += 4;
+	}
+}
+
+/**
+ * INIT_SUB_DIRECT - opcode 0x5b
+ *
+ */
+static void
+init_sub_direct(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 addr = nv_ro16(bios, init->offset + 1);
+	u16 save;
+
+	trace("SUB_DIRECT\t0x%04x\n", addr);
+
+	if (init_exec(init)) {
+		save = init->offset;
+		init->offset = addr;
+		if (nvbios_exec(init)) {
+			error("error parsing sub-table\n");
+			return;
+		}
+		init->offset = save;
+	}
+
+	init->offset += 3;
+}
+
+/**
+ * INIT_JUMP - opcode 0x5c
+ *
+ */
+static void
+init_jump(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 offset = nv_ro16(bios, init->offset + 1);
+
+	trace("JUMP\t0x%04x\n", offset);
+	init->offset = offset;
+}
+
+/**
+ * INIT_I2C_IF - opcode 0x5e
+ *
+ */
+static void
+init_i2c_if(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8  addr = nv_ro08(bios, init->offset + 2);
+	u8   reg = nv_ro08(bios, init->offset + 3);
+	u8  mask = nv_ro08(bios, init->offset + 4);
+	u8  data = nv_ro08(bios, init->offset + 5);
+	u8 value;
+
+	trace("I2C_IF\tI2C[0x%02x][0x%02x][0x%02x] & 0x%02x == 0x%02x\n",
+	      index, addr, reg, mask, data);
+	init->offset += 6;
+	init_exec_force(init, true);
+
+	value = init_rdi2cr(init, index, addr, reg);
+	if ((value & mask) != data)
+		init_exec_set(init, false);
+
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_COPY_NV_REG - opcode 0x5f
+ *
+ */
+static void
+init_copy_nv_reg(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  sreg = nv_ro32(bios, init->offset + 1);
+	u8  shift = nv_ro08(bios, init->offset + 5);
+	u32 smask = nv_ro32(bios, init->offset + 6);
+	u32  sxor = nv_ro32(bios, init->offset + 10);
+	u32  dreg = nv_ro32(bios, init->offset + 14);
+	u32 dmask = nv_ro32(bios, init->offset + 18);
+	u32 data;
+
+	trace("COPY_NV_REG\tR[0x%06x] &= 0x%08x |= "
+	      "((R[0x%06x] %s 0x%02x) & 0x%08x ^ 0x%08x)\n",
+	      dreg, dmask, sreg, (shift & 0x80) ? "<<" : ">>",
+	      (shift & 0x80) ? (0x100 - shift) : shift, smask, sxor);
+	init->offset += 22;
+
+	data = init_shift(init_rd32(init, sreg), shift);
+	init_mask(init, dreg, ~dmask, (data & smask) ^ sxor);
+}
+
+/**
+ * INIT_ZM_INDEX_IO - opcode 0x62
+ *
+ */
+static void
+init_zm_index_io(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8 index = nv_ro08(bios, init->offset + 3);
+	u8  data = nv_ro08(bios, init->offset + 4);
+
+	trace("ZM_INDEX_IO\tI[0x%04x][0x%02x] = 0x%02x\n", port, index, data);
+	init->offset += 5;
+
+	init_wrvgai(init, port, index, data);
+}
+
+/**
+ * INIT_COMPUTE_MEM - opcode 0x63
+ *
+ */
+static void
+init_compute_mem(struct nvbios_init *init)
+{
+	struct nouveau_devinit *devinit = nouveau_devinit(init->bios);
+
+	trace("COMPUTE_MEM\n");
+	init->offset += 1;
+
+	init_exec_force(init, true);
+	if (init_exec(init) && devinit->meminit)
+		devinit->meminit(devinit);
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_RESET - opcode 0x65
+ *
+ */
+static void
+init_reset(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32   reg = nv_ro32(bios, init->offset + 1);
+	u32 data1 = nv_ro32(bios, init->offset + 5);
+	u32 data2 = nv_ro32(bios, init->offset + 9);
+	u32 savepci19;
+
+	trace("RESET\tR[0x%08x] = 0x%08x, 0x%08x", reg, data1, data2);
+	init->offset += 13;
+	init_exec_force(init, true);
+
+	savepci19 = init_mask(init, 0x00184c, 0x00000f00, 0x00000000);
+	init_wr32(init, reg, data1);
+	udelay(10);
+	init_wr32(init, reg, data2);
+	init_wr32(init, 0x00184c, savepci19);
+	init_mask(init, 0x001850, 0x00000001, 0x00000000);
+
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_CONFIGURE_MEM - opcode 0x66
+ *
+ */
+static u16
+init_configure_mem_clk(struct nvbios_init *init)
+{
+	u16 mdata = bmp_mem_init_table(init->bios);
+	if (mdata)
+		mdata += (init_rdvgai(init, 0x03d4, 0x3c) >> 4) * 66;
+	return mdata;
+}
+
+static void
+init_configure_mem(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 mdata, sdata;
+	u32 addr, data;
+
+	trace("CONFIGURE_MEM\n");
+	init->offset += 1;
+
+	if (bios->version.major > 2) {
+		init_done(init);
+		return;
+	}
+	init_exec_force(init, true);
+
+	mdata = init_configure_mem_clk(init);
+	sdata = bmp_sdr_seq_table(bios);
+	if (nv_ro08(bios, mdata) & 0x01)
+		sdata = bmp_ddr_seq_table(bios);
+	mdata += 6; /* skip to data */
+
+	data = init_rdvgai(init, 0x03c4, 0x01);
+	init_wrvgai(init, 0x03c4, 0x01, data | 0x20);
+
+	while ((addr = nv_ro32(bios, sdata)) != 0xffffffff) {
+		switch (addr) {
+		case 0x10021c: /* CKE_NORMAL */
+		case 0x1002d0: /* CMD_REFRESH */
+		case 0x1002d4: /* CMD_PRECHARGE */
+			data = 0x00000001;
+			break;
+		default:
+			data = nv_ro32(bios, mdata);
+			mdata += 4;
+			if (data == 0xffffffff)
+				continue;
+			break;
+		}
+
+		init_wr32(init, addr, data);
+	}
+
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_CONFIGURE_CLK - opcode 0x67
+ *
+ */
+static void
+init_configure_clk(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 mdata, clock;
+
+	trace("CONFIGURE_CLK\n");
+	init->offset += 1;
+
+	if (bios->version.major > 2) {
+		init_done(init);
+		return;
+	}
+	init_exec_force(init, true);
+
+	mdata = init_configure_mem_clk(init);
+
+	/* NVPLL */
+	clock = nv_ro16(bios, mdata + 4) * 10;
+	init_prog_pll(init, 0x680500, clock);
+
+	/* MPLL */
+	clock = nv_ro16(bios, mdata + 2) * 10;
+	if (nv_ro08(bios, mdata) & 0x01)
+		clock *= 2;
+	init_prog_pll(init, 0x680504, clock);
+
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_CONFIGURE_PREINIT - opcode 0x68
+ *
+ */
+static void
+init_configure_preinit(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 strap;
+
+	trace("CONFIGURE_PREINIT\n");
+	init->offset += 1;
+
+	if (bios->version.major > 2) {
+		init_done(init);
+		return;
+	}
+	init_exec_force(init, true);
+
+	strap = init_rd32(init, 0x101000);
+	strap = ((strap << 2) & 0xf0) | ((strap & 0x40) >> 6);
+	init_wrvgai(init, 0x03d4, 0x3c, strap);
+
+	init_exec_force(init, false);
+}
+
+/**
+ * INIT_IO - opcode 0x69
+ *
+ */
+static void
+init_io(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8  mask = nv_ro16(bios, init->offset + 3);
+	u8  data = nv_ro16(bios, init->offset + 4);
+	u8 value;
+
+	trace("IO\t\tI[0x%04x] &= 0x%02x |= 0x%02x\n", port, mask, data);
+	init->offset += 5;
+
+	/* ummm.. yes.. should really figure out wtf this is and why it's
+	 * needed some day..  it's almost certainly wrong, but, it also
+	 * somehow makes things work...
+	 */
+	if (nv_device(init->bios)->card_type >= NV_50 &&
+	    port == 0x03c3 && data == 0x01) {
+		init_mask(init, 0x614100, 0xf0800000, 0x00800000);
+		init_mask(init, 0x00e18c, 0x00020000, 0x00020000);
+		init_mask(init, 0x614900, 0xf0800000, 0x00800000);
+		init_mask(init, 0x000200, 0x40000000, 0x00000000);
+		mdelay(10);
+		init_mask(init, 0x00e18c, 0x00020000, 0x00000000);
+		init_mask(init, 0x000200, 0x40000000, 0x40000000);
+		init_wr32(init, 0x614100, 0x00800018);
+		init_wr32(init, 0x614900, 0x00800018);
+		mdelay(10);
+		init_wr32(init, 0x614100, 0x10000018);
+		init_wr32(init, 0x614900, 0x10000018);
+		return;
+	}
+
+	value = init_rdport(init, port) & mask;
+	init_wrport(init, port, data | value);
+}
+
+/**
+ * INIT_SUB - opcode 0x6b
+ *
+ */
+static void
+init_sub(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u16 addr, save;
+
+	trace("SUB\t0x%02x\n", index);
+
+	addr = init_script(bios, index);
+	if (addr && init_exec(init)) {
+		save = init->offset;
+		init->offset = addr;
+		if (nvbios_exec(init)) {
+			error("error parsing sub-table\n");
+			return;
+		}
+		init->offset = save;
+	}
+
+	init->offset += 2;
+}
+
+/**
+ * INIT_RAM_CONDITION - opcode 0x6d
+ *
+ */
+static void
+init_ram_condition(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  mask = nv_ro08(bios, init->offset + 1);
+	u8 value = nv_ro08(bios, init->offset + 2);
+
+	trace("RAM_CONDITION\t"
+	      "(R[0x100000] & 0x%02x) == 0x%02x\n", mask, value);
+	init->offset += 3;
+
+	if ((init_rd32(init, 0x100000) & mask) != value)
+		init_exec_set(init, false);
+}
+
+/**
+ * INIT_NV_REG - opcode 0x6e
+ *
+ */
+static void
+init_nv_reg(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u32 mask = nv_ro32(bios, init->offset + 5);
+	u32 data = nv_ro32(bios, init->offset + 9);
+
+	trace("NV_REG\tR[0x%06x] &= 0x%08x |= 0x%08x\n", reg, mask, data);
+	init->offset += 13;
+
+	init_mask(init, reg, ~mask, data);
+}
+
+/**
+ * INIT_MACRO - opcode 0x6f
+ *
+ */
+static void
+init_macro(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  macro = nv_ro08(bios, init->offset + 1);
+	u16 table;
+
+	trace("MACRO\t0x%02x\n", macro);
+
+	table = init_macro_table(init);
+	if (table) {
+		u32 addr = nv_ro32(bios, table + (macro * 8) + 0);
+		u32 data = nv_ro32(bios, table + (macro * 8) + 4);
+		trace("\t\tR[0x%06x] = 0x%08x\n", addr, data);
+		init_wr32(init, addr, data);
+	}
+
+	init->offset += 2;
+}
+
+/**
+ * INIT_RESUME - opcode 0x72
+ *
+ */
+static void
+init_resume(struct nvbios_init *init)
+{
+	trace("RESUME\n");
+	init->offset += 1;
+	init_exec_set(init, true);
+}
+
+/**
+ * INIT_TIME - opcode 0x74
+ *
+ */
+static void
+init_time(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 usec = nv_ro16(bios, init->offset + 1);
+
+	trace("TIME\t0x%04x\n", usec);
+	init->offset += 3;
+
+	if (init_exec(init)) {
+		if (usec < 1000)
+			udelay(usec);
+		else
+			mdelay((usec + 900) / 1000);
+	}
+}
+
+/**
+ * INIT_CONDITION - opcode 0x75
+ *
+ */
+static void
+init_condition(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 cond = nv_ro08(bios, init->offset + 1);
+
+	trace("CONDITION\t0x%02x\n", cond);
+	init->offset += 2;
+
+	if (!init_condition_met(init, cond))
+		init_exec_set(init, false);
+}
+
+/**
+ * INIT_IO_CONDITION - opcode 0x76
+ *
+ */
+static void
+init_io_condition(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 cond = nv_ro08(bios, init->offset + 1);
+
+	trace("IO_CONDITION\t0x%02x\n", cond);
+	init->offset += 2;
+
+	if (!init_io_condition_met(init, cond))
+		init_exec_set(init, false);
+}
+
+/**
+ * INIT_INDEX_IO - opcode 0x78
+ *
+ */
+static void
+init_index_io(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u16 port = nv_ro16(bios, init->offset + 1);
+	u8 index = nv_ro16(bios, init->offset + 3);
+	u8  mask = nv_ro08(bios, init->offset + 4);
+	u8  data = nv_ro08(bios, init->offset + 5);
+	u8 value;
+
+	trace("INDEX_IO\tI[0x%04x][0x%02x] &= 0x%02x |= 0x%02x\n",
+	      port, index, mask, data);
+	init->offset += 6;
+
+	value = init_rdvgai(init, port, index) & mask;
+	init_wrvgai(init, port, index, data | value);
+}
+
+/**
+ * INIT_PLL - opcode 0x79
+ *
+ */
+static void
+init_pll(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32  reg = nv_ro32(bios, init->offset + 1);
+	u32 freq = nv_ro16(bios, init->offset + 5) * 10;
+
+	trace("PLL\tR[0x%06x] =PLL= %dkHz\n", reg, freq);
+	init->offset += 7;
+
+	init_prog_pll(init, reg, freq);
+}
+
+/**
+ * INIT_ZM_REG - opcode 0x7a
+ *
+ */
+static void
+init_zm_reg(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u32 data = nv_ro32(bios, init->offset + 5);
+
+	trace("ZM_REG\tR[0x%06x] = 0x%08x\n", addr, data);
+	init->offset += 9;
+
+	if (addr == 0x000200)
+		data |= 0x00000001;
+
+	init_wr32(init, addr, data);
+}
+
+/**
+ * INIT_RAM_RESTRICT_PLL - opcde 0x87
+ *
+ */
+static void
+init_ram_restrict_pll(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8  type = nv_ro08(bios, init->offset + 1);
+	u8 count = init_ram_restrict_group_count(init);
+	u8 strap = init_ram_restrict(init);
+	u8 cconf;
+
+	trace("RAM_RESTRICT_PLL\t0x%02x\n", type);
+	init->offset += 2;
+
+	for (cconf = 0; cconf < count; cconf++) {
+		u32 freq = nv_ro32(bios, init->offset);
+
+		if (cconf == strap) {
+			trace("%dkHz *\n", freq);
+			init_prog_pll(init, type, freq);
+		} else {
+			trace("%dkHz\n", freq);
+		}
+
+		init->offset += 4;
+	}
+}
+
+/**
+ * INIT_GPIO - opcode 0x8e
+ *
+ */
+static void
+init_gpio(struct nvbios_init *init)
+{
+	struct nouveau_gpio *gpio = nouveau_gpio(init->bios);
+
+	trace("GPIO\n");
+	init->offset += 1;
+
+	if (init_exec(init) && gpio && gpio->reset)
+		gpio->reset(gpio);
+}
+
+/**
+ * INIT_RAM_RESTRICT_ZM_GROUP - opcode 0x8f
+ *
+ */
+static void
+init_ram_restrict_zm_reg_group(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u8  incr = nv_ro08(bios, init->offset + 5);
+	u8   num = nv_ro08(bios, init->offset + 6);
+	u8 count = init_ram_restrict_group_count(init);
+	u8 index = init_ram_restrict(init);
+	u8 i, j;
+
+	trace("RAM_RESTRICT_ZM_REG_GROUP\t"
+	      "R[%08x] 0x%02x 0x%02x\n", addr, incr, num);
+	init->offset += 7;
+
+	for (i = 0; i < num; i++) {
+		trace("\tR[0x%06x] = {\n", addr);
+		for (j = 0; j < count; j++) {
+			u32 data = nv_ro32(bios, init->offset);
+
+			if (j == index) {
+				trace("\t\t0x%08x *\n", data);
+				init_wr32(init, addr, data);
+			} else {
+				trace("\t\t0x%08x\n", data);
+			}
+
+			init->offset += 4;
+		}
+		trace("\t}\n");
+		addr += incr;
+	}
+}
+
+/**
+ * INIT_COPY_ZM_REG - opcode 0x90
+ *
+ */
+static void
+init_copy_zm_reg(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 sreg = nv_ro32(bios, init->offset + 1);
+	u32 dreg = nv_ro32(bios, init->offset + 5);
+
+	trace("COPY_ZM_REG\tR[0x%06x] = R[0x%06x]\n", sreg, dreg);
+	init->offset += 9;
+
+	init_wr32(init, dreg, init_rd32(init, sreg));
+}
+
+/**
+ * INIT_ZM_REG_GROUP - opcode 0x91
+ *
+ */
+static void
+init_zm_reg_group(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u8 count = nv_ro08(bios, init->offset + 5);
+
+	trace("ZM_REG_GROUP\tR[0x%06x] =\n");
+	init->offset += 6;
+
+	while (count--) {
+		u32 data = nv_ro32(bios, init->offset);
+		trace("\t0x%08x\n", data);
+		init_wr32(init, addr, data);
+		init->offset += 4;
+	}
+}
+
+/**
+ * INIT_XLAT - opcode 0x96
+ *
+ */
+static void
+init_xlat(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 saddr = nv_ro32(bios, init->offset + 1);
+	u8 sshift = nv_ro08(bios, init->offset + 5);
+	u8  smask = nv_ro08(bios, init->offset + 6);
+	u8  index = nv_ro08(bios, init->offset + 7);
+	u32 daddr = nv_ro32(bios, init->offset + 8);
+	u32 dmask = nv_ro32(bios, init->offset + 12);
+	u8  shift = nv_ro08(bios, init->offset + 16);
+	u32 data;
+
+	trace("INIT_XLAT\tR[0x%06x] &= 0x%08x |= "
+	      "(X%02x((R[0x%06x] %s 0x%02x) & 0x%02x) << 0x%02x)\n",
+	      daddr, dmask, index, saddr, (sshift & 0x80) ? "<<" : ">>",
+	      (sshift & 0x80) ? (0x100 - sshift) : sshift, smask, shift);
+	init->offset += 17;
+
+	data = init_shift(init_rd32(init, saddr), sshift) & smask;
+	data = init_xlat_(init, index, data) << shift;
+	init_mask(init, daddr, ~dmask, data);
+}
+
+/**
+ * INIT_ZM_MASK_ADD - opcode 0x97
+ *
+ */
+static void
+init_zm_mask_add(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u32 mask = nv_ro32(bios, init->offset + 5);
+	u32  add = nv_ro32(bios, init->offset + 9);
+	u32 data;
+
+	trace("ZM_MASK_ADD\tR[0x%06x] &= 0x%08x += 0x%08x\n", addr, mask, add);
+	init->offset += 13;
+
+	data  =  init_rd32(init, addr) & mask;
+	data |= ((data + add) & ~mask);
+	init_wr32(init, addr, data);
+}
+
+/**
+ * INIT_AUXCH - opcode 0x98
+ *
+ */
+static void
+init_auxch(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u8 count = nv_ro08(bios, init->offset + 5);
+
+	trace("AUXCH\tAUX[0x%08x] 0x%02x\n", addr, count);
+	init->offset += 6;
+
+	while (count--) {
+		u8 mask = nv_ro08(bios, init->offset + 0);
+		u8 data = nv_ro08(bios, init->offset + 1);
+		trace("\tAUX[0x%08x] &= 0x%02x |= 0x%02x\n", addr, mask, data);
+		mask = init_rdauxr(init, addr) & mask;
+		init_wrauxr(init, addr, mask | data);
+		init->offset += 2;
+	}
+}
+
+/**
+ * INIT_AUXCH - opcode 0x99
+ *
+ */
+static void
+init_zm_auxch(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u32 addr = nv_ro32(bios, init->offset + 1);
+	u8 count = nv_ro08(bios, init->offset + 5);
+
+	trace("ZM_AUXCH\tAUX[0x%08x] 0x%02x\n", addr, count);
+	init->offset += 6;
+
+	while (count--) {
+		u8 data = nv_ro08(bios, init->offset + 0);
+		trace("\tAUX[0x%08x] = 0x%02x\n", addr, data);
+		init_wrauxr(init, addr, data);
+		init->offset += 1;
+	}
+}
+
+/**
+ * INIT_I2C_LONG_IF - opcode 0x9a
+ *
+ */
+static void
+init_i2c_long_if(struct nvbios_init *init)
+{
+	struct nouveau_bios *bios = init->bios;
+	u8 index = nv_ro08(bios, init->offset + 1);
+	u8  addr = nv_ro08(bios, init->offset + 2) >> 1;
+	u8 reglo = nv_ro08(bios, init->offset + 3);
+	u8 reghi = nv_ro08(bios, init->offset + 4);
+	u8  mask = nv_ro08(bios, init->offset + 5);
+	u8  data = nv_ro08(bios, init->offset + 6);
+	struct nouveau_i2c_port *port;
+
+	trace("I2C_LONG_IF\t"
+	      "I2C[0x%02x][0x%02x][0x%02x%02x] & 0x%02x == 0x%02x\n",
+	      index, addr, reglo, reghi, mask, data);
+	init->offset += 7;
+
+	port = init_i2c(init, index);
+	if (port) {
+		u8 i[2] = { reghi, reglo };
+		u8 o[1] = {};
+		struct i2c_msg msg[] = {
+			{ .addr = addr, .flags = 0, .len = 2, .buf = i },
+			{ .addr = addr, .flags = I2C_M_RD, .len = 1, .buf = o }
+		};
+		int ret;
+
+		ret = i2c_transfer(&port->adapter, msg, 2);
+		if (ret == 2 && ((o[0] & mask) == data))
+			return;
+	}
+
+	init_exec_set(init, false);
+}
+
+static struct nvbios_init_opcode {
+	void (*exec)(struct nvbios_init *);
+} init_opcode[] = {
+	[0x32] = { init_io_restrict_prog },
+	[0x33] = { init_repeat },
+	[0x34] = { init_io_restrict_pll },
+	[0x36] = { init_end_repeat },
+	[0x37] = { init_copy },
+	[0x38] = { init_not },
+	[0x39] = { init_io_flag_condition },
+	[0x3a] = { init_dp_condition },
+	[0x3b] = { init_io_mask_or },
+	[0x3c] = { init_io_or },
+	[0x49] = { init_idx_addr_latched },
+	[0x4a] = { init_io_restrict_pll2 },
+	[0x4b] = { init_pll2 },
+	[0x4c] = { init_i2c_byte },
+	[0x4d] = { init_zm_i2c_byte },
+	[0x4e] = { init_zm_i2c },
+	[0x4f] = { init_tmds },
+	[0x50] = { init_zm_tmds_group },
+	[0x51] = { init_cr_idx_adr_latch },
+	[0x52] = { init_cr },
+	[0x53] = { init_zm_cr },
+	[0x54] = { init_zm_cr_group },
+	[0x56] = { init_condition_time },
+	[0x57] = { init_ltime },
+	[0x58] = { init_zm_reg_sequence },
+	[0x5b] = { init_sub_direct },
+	[0x5c] = { init_jump },
+	[0x5e] = { init_i2c_if },
+	[0x5f] = { init_copy_nv_reg },
+	[0x62] = { init_zm_index_io },
+	[0x63] = { init_compute_mem },
+	[0x65] = { init_reset },
+	[0x66] = { init_configure_mem },
+	[0x67] = { init_configure_clk },
+	[0x68] = { init_configure_preinit },
+	[0x69] = { init_io },
+	[0x6b] = { init_sub },
+	[0x6d] = { init_ram_condition },
+	[0x6e] = { init_nv_reg },
+	[0x6f] = { init_macro },
+	[0x71] = { init_done },
+	[0x72] = { init_resume },
+	[0x74] = { init_time },
+	[0x75] = { init_condition },
+	[0x76] = { init_io_condition },
+	[0x78] = { init_index_io },
+	[0x79] = { init_pll },
+	[0x7a] = { init_zm_reg },
+	[0x87] = { init_ram_restrict_pll },
+	[0x8c] = { init_reserved },
+	[0x8d] = { init_reserved },
+	[0x8e] = { init_gpio },
+	[0x8f] = { init_ram_restrict_zm_reg_group },
+	[0x90] = { init_copy_zm_reg },
+	[0x91] = { init_zm_reg_group },
+	[0x92] = { init_reserved },
+	[0x96] = { init_xlat },
+	[0x97] = { init_zm_mask_add },
+	[0x98] = { init_auxch },
+	[0x99] = { init_zm_auxch },
+	[0x9a] = { init_i2c_long_if },
+};
+
+#define init_opcode_nr (sizeof(init_opcode) / sizeof(init_opcode[0]))
+
+int
+nvbios_exec(struct nvbios_init *init)
+{
+	init->nested++;
+	while (init->offset) {
+		u8 opcode = nv_ro08(init->bios, init->offset);
+		if (opcode >= init_opcode_nr || !init_opcode[opcode].exec) {
+			error("unknown opcode 0x%02x\n", opcode);
+			return -EINVAL;
+		}
+
+		init_opcode[opcode].exec(init);
+	}
+	init->nested--;
+	return 0;
+}
+
+int
+nvbios_init(struct nouveau_subdev *subdev, bool execute)
+{
+	struct nouveau_bios *bios = nouveau_bios(subdev);
+	int ret = 0;
+	int i = -1;
+	u16 data;
+
+	if (execute)
+		nv_info(bios, "running init tables\n");
+	while (!ret && (data = (init_script(bios, ++i)))) {
+		struct nvbios_init init = {
+			.subdev = subdev,
+			.bios = bios,
+			.offset = data,
+			.outp = NULL,
+			.crtc = -1,
+			.execute = execute ? 1 : 0,
+		};
+
+		ret = nvbios_exec(&init);
+	}
+
+	/* the vbios parser will run this right after the normal init
+	 * tables, whereas the binary driver appears to run it later.
+	 */
+	if (!ret && (data = init_unknown_script(bios))) {
+		struct nvbios_init init = {
+			.subdev = subdev,
+			.bios = bios,
+			.offset = data,
+			.outp = NULL,
+			.crtc = -1,
+			.execute = execute ? 1 : 0,
+		};
+
+		ret = nvbios_exec(&init);
+	}
+
+	return 0;
+}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv04.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/core/subdev/device/nv04.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv04.c
@@ -26,6 +26,7 @@
 #include <subdev/bios.h>
 #include <subdev/i2c.h>
 #include <subdev/clock.h>
+#include <subdev/devinit.h>
 
 int
 nv04_identify(struct nouveau_device *device)
@@ -35,11 +36,13 @@ nv04_identify(struct nouveau_device *dev
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv04_devinit_oclass;
 		break;
 	case 0x05:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv05_devinit_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown RIVA chipset\n");
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv10.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/core/subdev/device/nv10.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv10.c
@@ -27,6 +27,7 @@
 #include <subdev/gpio.h>
 #include <subdev/i2c.h>
 #include <subdev/clock.h>
+#include <subdev/devinit.h>
 
 int
 nv10_identify(struct nouveau_device *device)
@@ -37,48 +38,56 @@ nv10_identify(struct nouveau_device *dev
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv10_devinit_oclass;
 		break;
 	case 0x15:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv10_devinit_oclass;
 		break;
 	case 0x16:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv10_devinit_oclass;
 		break;
 	case 0x1a:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x11:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv10_devinit_oclass;
 		break;
 	case 0x17:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv10_devinit_oclass;
 		break;
 	case 0x1f:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x18:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv10_devinit_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Celsius chipset\n");
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv20.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/core/subdev/device/nv20.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv20.c
@@ -27,6 +27,7 @@
 #include <subdev/gpio.h>
 #include <subdev/i2c.h>
 #include <subdev/clock.h>
+#include <subdev/devinit.h>
 
 int
 nv20_identify(struct nouveau_device *device)
@@ -37,24 +38,28 @@ nv20_identify(struct nouveau_device *dev
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv20_devinit_oclass;
 		break;
 	case 0x25:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv20_devinit_oclass;
 		break;
 	case 0x28:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv20_devinit_oclass;
 		break;
 	case 0x2a:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv20_devinit_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Kelvin chipset\n");
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv30.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/core/subdev/device/nv30.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv30.c
@@ -27,6 +27,7 @@
 #include <subdev/gpio.h>
 #include <subdev/i2c.h>
 #include <subdev/clock.h>
+#include <subdev/devinit.h>
 
 int
 nv30_identify(struct nouveau_device *device)
@@ -37,30 +38,35 @@ nv30_identify(struct nouveau_device *dev
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv20_devinit_oclass;
 		break;
 	case 0x35:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv20_devinit_oclass;
 		break;
 	case 0x31:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv20_devinit_oclass;
 		break;
 	case 0x36:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv20_devinit_oclass;
 		break;
 	case 0x34:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv04_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv10_devinit_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Rankine chipset\n");
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv40.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/core/subdev/device/nv40.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv40.c
@@ -27,6 +27,7 @@
 #include <subdev/gpio.h>
 #include <subdev/i2c.h>
 #include <subdev/clock.h>
+#include <subdev/devinit.h>
 
 int
 nv40_identify(struct nouveau_device *device)
@@ -37,96 +38,112 @@ nv40_identify(struct nouveau_device *dev
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x41:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x42:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x43:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x45:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x47:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x49:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x4b:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x44:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x46:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x4a:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x4c:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x4e:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x63:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x67:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	case 0x68:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv40_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv1a_devinit_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Curie chipset\n");
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv50.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/core/subdev/device/nv50.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nv50.c
@@ -27,6 +27,7 @@
 #include <subdev/gpio.h>
 #include <subdev/i2c.h>
 #include <subdev/clock.h>
+#include <subdev/devinit.h>
 
 int
 nv50_identify(struct nouveau_device *device)
@@ -37,84 +38,98 @@ nv50_identify(struct nouveau_device *dev
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv50_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0x84:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv50_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0x86:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv50_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0x92:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv50_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0x94:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv50_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0x96:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv50_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0x98:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv50_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xa0:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv50_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xaa:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv50_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xac:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nv50_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xa3:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nva3_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xa5:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nva3_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xa8:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nva3_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xaf:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nva3_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Tesla chipset\n");
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nvc0.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/core/subdev/device/nvc0.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nvc0.c
@@ -27,6 +27,7 @@
 #include <subdev/gpio.h>
 #include <subdev/i2c.h>
 #include <subdev/clock.h>
+#include <subdev/devinit.h>
 
 int
 nvc0_identify(struct nouveau_device *device)
@@ -37,48 +38,56 @@ nvc0_identify(struct nouveau_device *dev
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nvc0_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xc4:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nvc0_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xc3:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nvc0_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xce:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nvc0_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xcf:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nvc0_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xc1:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nvc0_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xc8:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nvc0_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xd9:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nvd0_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nvc0_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Fermi chipset\n");
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nve0.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/core/subdev/device/nve0.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/device/nve0.c
@@ -27,6 +27,7 @@
 #include <subdev/gpio.h>
 #include <subdev/i2c.h>
 #include <subdev/clock.h>
+#include <subdev/devinit.h>
 
 int
 nve0_identify(struct nouveau_device *device)
@@ -37,12 +38,14 @@ nve0_identify(struct nouveau_device *dev
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nvd0_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nvc0_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	case 0xe7:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
 		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nvd0_gpio_oclass;
 		device->oclass[NVDEV_SUBDEV_I2C    ] = &nouveau_i2c_oclass;
 		device->oclass[NVDEV_SUBDEV_CLOCK  ] = &nvc0_clock_oclass;
+		device->oclass[NVDEV_SUBDEV_DEVINIT] = &nv50_devinit_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Kepler chipset\n");
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/base.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/base.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <core/option.h>
+
+#include <subdev/devinit.h>
+#include <subdev/bios.h>
+#include <subdev/bios/init.h>
+
+int
+nouveau_devinit_init(struct nouveau_devinit *devinit)
+{
+	int ret = nouveau_subdev_init(&devinit->base);
+	if (ret)
+		return ret;
+
+	return nvbios_init(&devinit->base, devinit->post);
+}
+
+int
+nouveau_devinit_fini(struct nouveau_devinit *devinit, bool suspend)
+{
+	/* force full reinit on resume */
+	if (suspend)
+		devinit->post = true;
+
+	return nouveau_subdev_fini(&devinit->base, suspend);
+}
+
+int
+nouveau_devinit_create_(struct nouveau_object *parent,
+			struct nouveau_object *engine,
+			struct nouveau_oclass *oclass,
+			int size, void **pobject)
+{
+	struct nouveau_device *device = nv_device(parent);
+	struct nouveau_devinit *devinit;
+	int ret;
+
+	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "DEVINIT",
+				     "init", size, pobject);
+	devinit = *pobject;
+	if (ret)
+		return ret;
+
+	devinit->post = nouveau_boolopt(device->cfgopt, "NvForcePost", false);
+	return 0;
+}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/fbmem.h
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/fbmem.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2010 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#define NV04_PFB_BOOT_0						0x00100000
+#	define NV04_PFB_BOOT_0_RAM_AMOUNT			0x00000003
+#	define NV04_PFB_BOOT_0_RAM_AMOUNT_32MB			0x00000000
+#	define NV04_PFB_BOOT_0_RAM_AMOUNT_4MB			0x00000001
+#	define NV04_PFB_BOOT_0_RAM_AMOUNT_8MB			0x00000002
+#	define NV04_PFB_BOOT_0_RAM_AMOUNT_16MB			0x00000003
+#	define NV04_PFB_BOOT_0_RAM_WIDTH_128			0x00000004
+#	define NV04_PFB_BOOT_0_RAM_TYPE				0x00000028
+#	define NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_8MBIT		0x00000000
+#	define NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_16MBIT		0x00000008
+#	define NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_16MBIT_4BANK	0x00000010
+#	define NV04_PFB_BOOT_0_RAM_TYPE_SDRAM_16MBIT		0x00000018
+#	define NV04_PFB_BOOT_0_RAM_TYPE_SDRAM_64MBIT		0x00000020
+#	define NV04_PFB_BOOT_0_RAM_TYPE_SDRAM_64MBITX16		0x00000028
+#	define NV04_PFB_BOOT_0_UMA_ENABLE			0x00000100
+#	define NV04_PFB_BOOT_0_UMA_SIZE				0x0000f000
+#define NV04_PFB_DEBUG_0					0x00100080
+#	define NV04_PFB_DEBUG_0_PAGE_MODE			0x00000001
+#	define NV04_PFB_DEBUG_0_REFRESH_OFF			0x00000010
+#	define NV04_PFB_DEBUG_0_REFRESH_COUNTX64		0x00003f00
+#	define NV04_PFB_DEBUG_0_REFRESH_SLOW_CLK		0x00004000
+#	define NV04_PFB_DEBUG_0_SAFE_MODE			0x00008000
+#	define NV04_PFB_DEBUG_0_ALOM_ENABLE			0x00010000
+#	define NV04_PFB_DEBUG_0_CASOE				0x00100000
+#	define NV04_PFB_DEBUG_0_CKE_INVERT			0x10000000
+#	define NV04_PFB_DEBUG_0_REFINC				0x20000000
+#	define NV04_PFB_DEBUG_0_SAVE_POWER_OFF			0x40000000
+#define NV04_PFB_CFG0						0x00100200
+#	define NV04_PFB_CFG0_SCRAMBLE				0x20000000
+#define NV04_PFB_CFG1						0x00100204
+#define NV04_PFB_SCRAMBLE(i)                         (0x00100400 + 4 * (i))
+
+#define NV10_PFB_REFCTRL					0x00100210
+#	define NV10_PFB_REFCTRL_VALID_1				(1 << 31)
+
+static inline struct io_mapping *
+fbmem_init(struct pci_dev *pdev)
+{
+	return io_mapping_create_wc(pci_resource_start(pdev, 1),
+				    pci_resource_len(pdev, 1));
+}
+
+static inline void
+fbmem_fini(struct io_mapping *fb)
+{
+	io_mapping_free(fb);
+}
+
+static inline u32
+fbmem_peek(struct io_mapping *fb, u32 off)
+{
+	u8 __iomem *p = io_mapping_map_atomic_wc(fb, off & PAGE_MASK);
+	u32 val = ioread32(p + (off & ~PAGE_MASK));
+	io_mapping_unmap_atomic(p);
+	return val;
+}
+
+static inline void
+fbmem_poke(struct io_mapping *fb, u32 off, u32 val)
+{
+	u8 __iomem *p = io_mapping_map_atomic_wc(fb, off & PAGE_MASK);
+	iowrite32(val, p + (off & ~PAGE_MASK));
+	wmb();
+	io_mapping_unmap_atomic(p);
+}
+
+static inline bool
+fbmem_readback(struct io_mapping *fb, u32 off, u32 val)
+{
+	fbmem_poke(fb, off, val);
+	return val == fbmem_peek(fb, off);
+}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2010 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <subdev/devinit.h>
+#include <subdev/vga.h>
+
+#include "fbmem.h"
+
+struct nv04_devinit_priv {
+	struct nouveau_devinit base;
+	int owner;
+};
+
+static void
+nv04_devinit_meminit(struct nouveau_devinit *devinit)
+{
+	struct nv04_devinit_priv *priv = (void *)devinit;
+	u32 patt = 0xdeadbeef;
+	struct io_mapping *fb;
+	int i;
+
+	/* Map the framebuffer aperture */
+	fb = fbmem_init(nv_device(priv)->pdev);
+	if (!fb) {
+		nv_error(priv, "failed to map fb\n");
+		return;
+	}
+
+	/* Sequencer and refresh off */
+	nv_wrvgas(priv, 0, 1, nv_rdvgas(priv, 0, 1) | 0x20);
+	nv_mask(priv, NV04_PFB_DEBUG_0, 0, NV04_PFB_DEBUG_0_REFRESH_OFF);
+
+	nv_mask(priv, NV04_PFB_BOOT_0, ~0,
+		      NV04_PFB_BOOT_0_RAM_AMOUNT_16MB |
+		      NV04_PFB_BOOT_0_RAM_WIDTH_128 |
+		      NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_16MBIT);
+
+	for (i = 0; i < 4; i++)
+		fbmem_poke(fb, 4 * i, patt);
+
+	fbmem_poke(fb, 0x400000, patt + 1);
+
+	if (fbmem_peek(fb, 0) == patt + 1) {
+		nv_mask(priv, NV04_PFB_BOOT_0,
+			      NV04_PFB_BOOT_0_RAM_TYPE,
+			      NV04_PFB_BOOT_0_RAM_TYPE_SDRAM_16MBIT);
+		nv_mask(priv, NV04_PFB_DEBUG_0,
+			      NV04_PFB_DEBUG_0_REFRESH_OFF, 0);
+
+		for (i = 0; i < 4; i++)
+			fbmem_poke(fb, 4 * i, patt);
+
+		if ((fbmem_peek(fb, 0xc) & 0xffff) != (patt & 0xffff))
+			nv_mask(priv, NV04_PFB_BOOT_0,
+				      NV04_PFB_BOOT_0_RAM_WIDTH_128 |
+				      NV04_PFB_BOOT_0_RAM_AMOUNT,
+				      NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);
+	} else
+	if ((fbmem_peek(fb, 0xc) & 0xffff0000) != (patt & 0xffff0000)) {
+		nv_mask(priv, NV04_PFB_BOOT_0,
+			      NV04_PFB_BOOT_0_RAM_WIDTH_128 |
+			      NV04_PFB_BOOT_0_RAM_AMOUNT,
+			      NV04_PFB_BOOT_0_RAM_AMOUNT_4MB);
+	} else
+	if (fbmem_peek(fb, 0) != patt) {
+		if (fbmem_readback(fb, 0x800000, patt))
+			nv_mask(priv, NV04_PFB_BOOT_0,
+				      NV04_PFB_BOOT_0_RAM_AMOUNT,
+				      NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);
+		else
+			nv_mask(priv, NV04_PFB_BOOT_0,
+				      NV04_PFB_BOOT_0_RAM_AMOUNT,
+				      NV04_PFB_BOOT_0_RAM_AMOUNT_4MB);
+
+		nv_mask(priv, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_TYPE,
+			      NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_8MBIT);
+	} else
+	if (!fbmem_readback(fb, 0x800000, patt)) {
+		nv_mask(priv, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_AMOUNT,
+			      NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);
+
+	}
+
+	/* Refresh on, sequencer on */
+	nv_mask(priv, NV04_PFB_DEBUG_0, NV04_PFB_DEBUG_0_REFRESH_OFF, 0);
+	nv_wrvgas(priv, 0, 1, nv_rdvgas(priv, 0, 1) & ~0x20);
+	fbmem_fini(fb);
+}
+
+static int
+nv04_devinit_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+		  struct nouveau_oclass *oclass, void *data, u32 size,
+		  struct nouveau_object **pobject)
+{
+	struct nv04_devinit_priv *priv;
+	int ret;
+
+	ret = nouveau_devinit_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	priv->base.meminit = nv04_devinit_meminit;
+	priv->owner = -1;
+	return 0;
+}
+
+void
+nv04_devinit_dtor(struct nouveau_object *object)
+{
+	struct nv04_devinit_priv *priv = (void *)object;
+
+	/* restore vga owner saved at first init, and lock crtc regs  */
+	nv_wrvgaowner(priv, priv->owner);
+	nv_lockvgac(priv, true);
+
+	nouveau_devinit_destroy(&priv->base);
+}
+
+int
+nv04_devinit_init(struct nouveau_object *object)
+{
+	struct nv04_devinit_priv *priv = (void *)object;
+
+	if (!priv->base.post) {
+		u32 htotal = nv_rdvgac(priv, 0, 0x06);
+		htotal |= (nv_rdvgac(priv, 0, 0x07) & 0x01) << 8;
+		htotal |= (nv_rdvgac(priv, 0, 0x07) & 0x20) << 4;
+		htotal |= (nv_rdvgac(priv, 0, 0x25) & 0x01) << 10;
+		htotal |= (nv_rdvgac(priv, 0, 0x41) & 0x01) << 11;
+		if (!htotal) {
+			nv_info(priv, "adaptor not initialised\n");
+			priv->base.post = true;
+		}
+	}
+
+	return nouveau_devinit_init(&priv->base);
+}
+
+int
+nv04_devinit_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nv04_devinit_priv *priv = (void *)object;
+
+	/* make i2c busses accessible */
+	nv_mask(priv, 0x000200, 0x00000001, 0x00000001);
+
+	/* unlock extended vga crtc regs, and unslave crtcs */
+	nv_lockvgac(priv, false);
+	if (priv->owner < 0)
+		priv->owner = nv_rdvgaowner(priv);
+	nv_wrvgaowner(priv, 0);
+
+	return nouveau_devinit_fini(&priv->base, suspend);
+}
+
+struct nouveau_oclass
+nv04_devinit_oclass = {
+	.handle = NV_SUBDEV(DEVINIT, 0x04),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv04_devinit_ctor,
+		.dtor = nv04_devinit_dtor,
+		.init = nv04_devinit_init,
+		.fini = nv04_devinit_fini,
+	},
+};
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv05.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv05.c
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2010 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <subdev/devinit.h>
+#include <subdev/bios.h>
+#include <subdev/bios/bmp.h>
+#include <subdev/vga.h>
+
+#include "fbmem.h"
+
+struct nv05_devinit_priv {
+	struct nouveau_devinit base;
+	u8 owner;
+};
+
+static void
+nv05_devinit_meminit(struct nouveau_devinit *devinit)
+{
+	static const u8 default_config_tab[][2] = {
+		{ 0x24, 0x00 },
+		{ 0x28, 0x00 },
+		{ 0x24, 0x01 },
+		{ 0x1f, 0x00 },
+		{ 0x0f, 0x00 },
+		{ 0x17, 0x00 },
+		{ 0x06, 0x00 },
+		{ 0x00, 0x00 }
+	};
+	struct nv05_devinit_priv *priv = (void *)devinit;
+	struct nouveau_bios *bios = nouveau_bios(priv);
+	struct io_mapping *fb;
+	u32 patt = 0xdeadbeef;
+	u16 data;
+	u8 strap, ramcfg[2];
+	int i, v;
+
+	/* Map the framebuffer aperture */
+	fb = fbmem_init(nv_device(priv)->pdev);
+	if (!fb) {
+		nv_error(priv, "failed to map fb\n");
+		return;
+	}
+
+	strap = (nv_rd32(priv, 0x101000) & 0x0000003c) >> 2;
+	if ((data = bmp_mem_init_table(bios))) {
+		ramcfg[0] = nv_ro08(bios, data + 2 * strap + 0);
+		ramcfg[1] = nv_ro08(bios, data + 2 * strap + 1);
+	} else {
+		ramcfg[0] = default_config_tab[strap][0];
+		ramcfg[1] = default_config_tab[strap][1];
+	}
+
+	/* Sequencer off */
+	nv_wrvgas(priv, 0, 1, nv_rdvgas(priv, 0, 1) | 0x20);
+
+	if (nv_rd32(priv, NV04_PFB_BOOT_0) & NV04_PFB_BOOT_0_UMA_ENABLE)
+		goto out;
+
+	nv_mask(priv, NV04_PFB_DEBUG_0, NV04_PFB_DEBUG_0_REFRESH_OFF, 0);
+
+	/* If present load the hardcoded scrambling table */
+	if (data) {
+		for (i = 0, data += 0x10; i < 8; i++, data += 4) {
+			u32 scramble = nv_ro32(bios, data);
+			nv_wr32(priv, NV04_PFB_SCRAMBLE(i), scramble);
+		}
+	}
+
+	/* Set memory type/width/length defaults depending on the straps */
+	nv_mask(priv, NV04_PFB_BOOT_0, 0x3f, ramcfg[0]);
+
+	if (ramcfg[1] & 0x80)
+		nv_mask(priv, NV04_PFB_CFG0, 0, NV04_PFB_CFG0_SCRAMBLE);
+
+	nv_mask(priv, NV04_PFB_CFG1, 0x700001, (ramcfg[1] & 1) << 20);
+	nv_mask(priv, NV04_PFB_CFG1, 0, 1);
+
+	/* Probe memory bus width */
+	for (i = 0; i < 4; i++)
+		fbmem_poke(fb, 4 * i, patt);
+
+	if (fbmem_peek(fb, 0xc) != patt)
+		nv_mask(priv, NV04_PFB_BOOT_0,
+			  NV04_PFB_BOOT_0_RAM_WIDTH_128, 0);
+
+	/* Probe memory length */
+	v = nv_rd32(priv, NV04_PFB_BOOT_0) & NV04_PFB_BOOT_0_RAM_AMOUNT;
+
+	if (v == NV04_PFB_BOOT_0_RAM_AMOUNT_32MB &&
+	    (!fbmem_readback(fb, 0x1000000, ++patt) ||
+	     !fbmem_readback(fb, 0, ++patt)))
+		nv_mask(priv, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_AMOUNT,
+			  NV04_PFB_BOOT_0_RAM_AMOUNT_16MB);
+
+	if (v == NV04_PFB_BOOT_0_RAM_AMOUNT_16MB &&
+	    !fbmem_readback(fb, 0x800000, ++patt))
+		nv_mask(priv, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_AMOUNT,
+			  NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);
+
+	if (!fbmem_readback(fb, 0x400000, ++patt))
+		nv_mask(priv, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_AMOUNT,
+			  NV04_PFB_BOOT_0_RAM_AMOUNT_4MB);
+
+out:
+	/* Sequencer on */
+	nv_wrvgas(priv, 0, 1, nv_rdvgas(priv, 0, 1) & ~0x20);
+	fbmem_fini(fb);
+}
+
+static int
+nv05_devinit_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+		  struct nouveau_oclass *oclass, void *data, u32 size,
+		  struct nouveau_object **pobject)
+{
+	struct nv05_devinit_priv *priv;
+	int ret;
+
+	ret = nouveau_devinit_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	priv->base.meminit = nv05_devinit_meminit;
+	return 0;
+}
+
+struct nouveau_oclass
+nv05_devinit_oclass = {
+	.handle = NV_SUBDEV(DEVINIT, 0x05),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv05_devinit_ctor,
+		.dtor = nv04_devinit_dtor,
+		.init = nv04_devinit_init,
+		.fini = nv04_devinit_fini,
+	},
+};
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv10.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv10.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2010 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <subdev/devinit.h>
+#include <subdev/vga.h>
+
+#include "fbmem.h"
+
+struct nv10_devinit_priv {
+	struct nouveau_devinit base;
+	u8 owner;
+};
+
+static void
+nv10_devinit_meminit(struct nouveau_devinit *devinit)
+{
+	struct nv10_devinit_priv *priv = (void *)devinit;
+	const int mem_width[] = { 0x10, 0x00, 0x20 };
+	const int mem_width_count = nv_device(priv)->chipset >= 0x17 ? 3 : 2;
+	uint32_t patt = 0xdeadbeef;
+	struct io_mapping *fb;
+	int i, j, k;
+
+	/* Map the framebuffer aperture */
+	fb = fbmem_init(nv_device(priv)->pdev);
+	if (!fb) {
+		nv_error(priv, "failed to map fb\n");
+		return;
+	}
+
+	nv_wr32(priv, NV10_PFB_REFCTRL, NV10_PFB_REFCTRL_VALID_1);
+
+	/* Probe memory bus width */
+	for (i = 0; i < mem_width_count; i++) {
+		nv_mask(priv, NV04_PFB_CFG0, 0x30, mem_width[i]);
+
+		for (j = 0; j < 4; j++) {
+			for (k = 0; k < 4; k++)
+				fbmem_poke(fb, 0x1c, 0);
+
+			fbmem_poke(fb, 0x1c, patt);
+			fbmem_poke(fb, 0x3c, 0);
+
+			if (fbmem_peek(fb, 0x1c) == patt)
+				goto mem_width_found;
+		}
+	}
+
+mem_width_found:
+	patt <<= 1;
+
+	/* Probe amount of installed memory */
+	for (i = 0; i < 4; i++) {
+		int off = nv_rd32(priv, 0x10020c) - 0x100000;
+
+		fbmem_poke(fb, off, patt);
+		fbmem_poke(fb, 0, 0);
+
+		fbmem_peek(fb, 0);
+		fbmem_peek(fb, 0);
+		fbmem_peek(fb, 0);
+		fbmem_peek(fb, 0);
+
+		if (fbmem_peek(fb, off) == patt)
+			goto amount_found;
+	}
+
+	/* IC missing - disable the upper half memory space. */
+	nv_mask(priv, NV04_PFB_CFG0, 0x1000, 0);
+
+amount_found:
+	fbmem_fini(fb);
+}
+
+static int
+nv10_devinit_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+		  struct nouveau_oclass *oclass, void *data, u32 size,
+		  struct nouveau_object **pobject)
+{
+	struct nv10_devinit_priv *priv;
+	int ret;
+
+	ret = nouveau_devinit_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	priv->base.meminit = nv10_devinit_meminit;
+	return 0;
+}
+
+struct nouveau_oclass
+nv10_devinit_oclass = {
+	.handle = NV_SUBDEV(DEVINIT, 0x10),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv10_devinit_ctor,
+		.dtor = nv04_devinit_dtor,
+		.init = nv04_devinit_init,
+		.fini = nv04_devinit_fini,
+	},
+};
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv1a.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv1a.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <subdev/devinit.h>
+#include <subdev/vga.h>
+
+struct nv1a_devinit_priv {
+	struct nouveau_devinit base;
+	u8 owner;
+};
+
+static int
+nv1a_devinit_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+		  struct nouveau_oclass *oclass, void *data, u32 size,
+		  struct nouveau_object **pobject)
+{
+	struct nv1a_devinit_priv *priv;
+	int ret;
+
+	ret = nouveau_devinit_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+struct nouveau_oclass
+nv1a_devinit_oclass = {
+	.handle = NV_SUBDEV(DEVINIT, 0x1a),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv1a_devinit_ctor,
+		.dtor = nv04_devinit_dtor,
+		.init = nv04_devinit_init,
+		.fini = nv04_devinit_fini,
+	},
+};
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv20.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv20.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2010 Francisco Jerez.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <subdev/devinit.h>
+#include <subdev/vga.h>
+
+#include "fbmem.h"
+
+struct nv20_devinit_priv {
+	struct nouveau_devinit base;
+	u8 owner;
+};
+
+static void
+nv20_devinit_meminit(struct nouveau_devinit *devinit)
+{
+	struct nv20_devinit_priv *priv = (void *)devinit;
+	struct nouveau_device *device = nv_device(priv);
+	uint32_t mask = (device->chipset >= 0x25 ? 0x300 : 0x900);
+	uint32_t amount, off;
+	struct io_mapping *fb;
+
+	/* Map the framebuffer aperture */
+	fb = fbmem_init(nv_device(priv)->pdev);
+	if (!fb) {
+		nv_error(priv, "failed to map fb\n");
+		return;
+	}
+
+	nv_wr32(priv, NV10_PFB_REFCTRL, NV10_PFB_REFCTRL_VALID_1);
+
+	/* Allow full addressing */
+	nv_mask(priv, NV04_PFB_CFG0, 0, mask);
+
+	amount = nv_rd32(priv, 0x10020c);
+	for (off = amount; off > 0x2000000; off -= 0x2000000)
+		fbmem_poke(fb, off - 4, off);
+
+	amount = nv_rd32(priv, 0x10020c);
+	if (amount != fbmem_peek(fb, amount - 4))
+		/* IC missing - disable the upper half memory space. */
+		nv_mask(priv, NV04_PFB_CFG0, mask, 0);
+
+	fbmem_fini(fb);
+}
+
+static int
+nv20_devinit_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+		  struct nouveau_oclass *oclass, void *data, u32 size,
+		  struct nouveau_object **pobject)
+{
+	struct nv20_devinit_priv *priv;
+	int ret;
+
+	ret = nouveau_devinit_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	priv->base.meminit = nv20_devinit_meminit;
+	return 0;
+}
+
+struct nouveau_oclass
+nv20_devinit_oclass = {
+	.handle = NV_SUBDEV(DEVINIT, 0x20),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv20_devinit_ctor,
+		.dtor = nv04_devinit_dtor,
+		.init = nv04_devinit_init,
+		.fini = nv04_devinit_fini,
+	},
+};
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <subdev/devinit.h>
+#include <subdev/vga.h>
+
+struct nv50_devinit_priv {
+	struct nouveau_devinit base;
+};
+
+static int
+nv50_devinit_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+		  struct nouveau_oclass *oclass, void *data, u32 size,
+		  struct nouveau_object **pobject)
+{
+	struct nv50_devinit_priv *priv;
+	int ret;
+
+	ret = nouveau_devinit_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static void
+nv50_devinit_dtor(struct nouveau_object *object)
+{
+	struct nv50_devinit_priv *priv = (void *)object;
+	nouveau_devinit_destroy(&priv->base);
+}
+
+static int
+nv50_devinit_init(struct nouveau_object *object)
+{
+	struct nv50_devinit_priv *priv = (void *)object;
+
+	if (!priv->base.post) {
+		if (!nv_rdvgac(priv, 0, 0x00) &&
+		    !nv_rdvgac(priv, 0, 0x1a)) {
+			nv_info(priv, "adaptor not initialised\n");
+			priv->base.post = true;
+		}
+	}
+
+	return nouveau_devinit_init(&priv->base);
+}
+
+static int
+nv50_devinit_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nv50_devinit_priv *priv = (void *)object;
+	return nouveau_devinit_fini(&priv->base, suspend);
+}
+
+struct nouveau_oclass
+nv50_devinit_oclass = {
+	.handle = NV_SUBDEV(DEVINIT, 0x50),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv50_devinit_ctor,
+		.dtor = nv50_devinit_dtor,
+		.init = nv50_devinit_init,
+		.fini = nv50_devinit_fini,
+	},
+};
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_agp.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_agp.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_agp.c
@@ -1,10 +1,10 @@
 #include <linux/module.h>
 
-#include "drmP.h"
-#include "drm.h"
+#include <core/device.h>
 
-#include "nouveau_drv.h"
+#include "nouveau_drm.h"
 #include "nouveau_agp.h"
+#include "nouveau_reg.h"
 
 #if __OS_HAS_AGP
 MODULE_PARM_DESC(agpmode, "AGP mode (0 to disable AGP)");
@@ -12,15 +12,15 @@ static int nouveau_agpmode = -1;
 module_param_named(agpmode, nouveau_agpmode, int, 0400);
 
 static unsigned long
-get_agp_mode(struct drm_device *dev, unsigned long mode)
+get_agp_mode(struct nouveau_drm *drm, unsigned long mode)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_device *device = nv_device(drm->device);
 
 	/*
 	 * FW seems to be broken on nv18, it makes the card lock up
 	 * randomly.
 	 */
-	if (dev_priv->chipset == 0x18)
+	if (device->chipset == 0x18)
 		mode &= ~PCI_AGP_COMMAND_FW;
 
 	/*
@@ -37,42 +37,39 @@ get_agp_mode(struct drm_device *dev, uns
 }
 
 static bool
-nouveau_agp_enabled(struct drm_device *dev)
+nouveau_agp_enabled(struct nouveau_drm *drm)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct drm_device *dev = drm->dev;
 
 	if (!drm_pci_device_is_agp(dev) || !dev->agp)
 		return false;
 
-	switch (dev_priv->gart_info.type) {
-	case NOUVEAU_GART_NONE:
+	if (drm->agp.stat == UNKNOWN) {
 		if (!nouveau_agpmode)
 			return false;
-		break;
-	case NOUVEAU_GART_AGP:
-		break;
-	default:
-		return false;
+		return true;
 	}
 
-	return true;
+	return (drm->agp.stat == ENABLED);
 }
 #endif
 
 void
-nouveau_agp_reset(struct drm_device *dev)
+nouveau_agp_reset(struct nouveau_drm *drm)
 {
 #if __OS_HAS_AGP
+	struct nouveau_device *device = nv_device(drm->device);
+	struct drm_device *dev = drm->dev;
 	u32 save[2];
 	int ret;
 
-	if (!nouveau_agp_enabled(dev))
+	if (!nouveau_agp_enabled(drm))
 		return;
 
 	/* First of all, disable fast writes, otherwise if it's
 	 * already enabled in the AGP bridge and we disable the card's
 	 * AGP controller we might be locking ourselves out of it. */
-	if ((nv_rd32(dev, NV04_PBUS_PCI_NV_19) |
+	if ((nv_rd32(device, NV04_PBUS_PCI_NV_19) |
 	     dev->agp->mode) & PCI_AGP_COMMAND_FW) {
 		struct drm_agp_info info;
 		struct drm_agp_mode mode;
@@ -81,7 +78,7 @@ nouveau_agp_reset(struct drm_device *dev
 		if (ret)
 			return;
 
-		mode.mode  = get_agp_mode(dev, info.mode);
+		mode.mode  = get_agp_mode(drm, info.mode);
 		mode.mode &= ~PCI_AGP_COMMAND_FW;
 
 		ret = drm_agp_enable(dev, mode);
@@ -91,61 +88,64 @@ nouveau_agp_reset(struct drm_device *dev
 
 
 	/* clear busmaster bit, and disable AGP */
-	save[0] = nv_mask(dev, NV04_PBUS_PCI_NV_1, 0x00000004, 0x00000000);
-	nv_wr32(dev, NV04_PBUS_PCI_NV_19, 0);
+	save[0] = nv_mask(device, NV04_PBUS_PCI_NV_1, 0x00000004, 0x00000000);
+	nv_wr32(device, NV04_PBUS_PCI_NV_19, 0);
 
 	/* reset PGRAPH, PFIFO and PTIMER */
-	save[1] = nv_mask(dev, 0x000200, 0x00011100, 0x00000000);
-	nv_mask(dev, 0x000200, 0x00011100, save[1]);
+	save[1] = nv_mask(device, 0x000200, 0x00011100, 0x00000000);
+	nv_mask(device, 0x000200, 0x00011100, save[1]);
 
 	/* and restore bustmaster bit (gives effect of resetting AGP) */
-	nv_wr32(dev, NV04_PBUS_PCI_NV_1, save[0]);
+	nv_wr32(device, NV04_PBUS_PCI_NV_1, save[0]);
 #endif
 }
 
 void
-nouveau_agp_init(struct drm_device *dev)
+nouveau_agp_init(struct nouveau_drm *drm)
 {
 #if __OS_HAS_AGP
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_device *device = nv_device(drm->device);
+	struct drm_device *dev = drm->dev;
 	struct drm_agp_info info;
 	struct drm_agp_mode mode;
 	int ret;
 
-	if (!nouveau_agp_enabled(dev))
+	if (!nouveau_agp_enabled(drm))
 		return;
+	drm->agp.stat = DISABLE;
 
 	ret = drm_agp_acquire(dev);
 	if (ret) {
-		NV_ERROR(dev, "Unable to acquire AGP: %d\n", ret);
+		nv_error(device, "unable to acquire AGP: %d\n", ret);
 		return;
 	}
 
 	ret = drm_agp_info(dev, &info);
 	if (ret) {
-		NV_ERROR(dev, "Unable to get AGP info: %d\n", ret);
+		nv_error(device, "unable to get AGP info: %d\n", ret);
 		return;
 	}
 
 	/* see agp.h for the AGPSTAT_* modes available */
-	mode.mode = get_agp_mode(dev, info.mode);
+	mode.mode = get_agp_mode(drm, info.mode);
 
 	ret = drm_agp_enable(dev, mode);
 	if (ret) {
-		NV_ERROR(dev, "Unable to enable AGP: %d\n", ret);
+		nv_error(device, "unable to enable AGP: %d\n", ret);
 		return;
 	}
 
-	dev_priv->gart_info.type = NOUVEAU_GART_AGP;
-	dev_priv->gart_info.aper_base = info.aperture_base;
-	dev_priv->gart_info.aper_size = info.aperture_size;
+	drm->agp.stat = ENABLED;
+	drm->agp.base = info.aperture_base;
+	drm->agp.size = info.aperture_size;
 #endif
 }
 
 void
-nouveau_agp_fini(struct drm_device *dev)
+nouveau_agp_fini(struct nouveau_drm *drm)
 {
 #if __OS_HAS_AGP
+	struct drm_device *dev = drm->dev;
 	if (dev->agp && dev->agp->acquired)
 		drm_agp_release(dev);
 #endif
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_agp.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_agp.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_agp.h
@@ -1,8 +1,10 @@
 #ifndef __NOUVEAU_AGP_H__
 #define __NOUVEAU_AGP_H__
 
-void nouveau_agp_reset(struct drm_device *);
-void nouveau_agp_init(struct drm_device *);
-void nouveau_agp_fini(struct drm_device *);
+struct nouveau_drm;
+
+void nouveau_agp_reset(struct nouveau_drm *);
+void nouveau_agp_init(struct nouveau_drm *);
+void nouveau_agp_fini(struct nouveau_drm *);
 
 #endif
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_backlight.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_backlight.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_backlight.c
@@ -181,9 +181,9 @@ nv50_backlight_init(struct drm_connector
 	struct backlight_device *bd;
 	const struct backlight_ops *ops;
 
-	nv_encoder = find_encoder(connector, OUTPUT_LVDS);
+	nv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);
 	if (!nv_encoder) {
-		nv_encoder = find_encoder(connector, OUTPUT_DP);
+		nv_encoder = find_encoder(connector, DCB_OUTPUT_DP);
 		if (!nv_encoder)
 			return -ENODEV;
 	}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_bios.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_bios.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_bios.c
@@ -64,3372 +64,6 @@ static bool nv_cksum(const uint8_t *data
 	return false;
 }
 
-struct init_tbl_entry {
-	char *name;
-	uint8_t id;
-	/* Return:
-	 *  > 0: success, length of opcode
-	 *    0: success, but abort further parsing of table (INIT_DONE etc)
-	 *  < 0: failure, table parsing will be aborted
-	 */
-	int (*handler)(struct nvbios *, uint16_t, struct init_exec *);
-};
-
-static int parse_init_table(struct nvbios *, uint16_t, struct init_exec *);
-
-#define MACRO_INDEX_SIZE	2
-#define MACRO_SIZE		8
-#define CONDITION_SIZE		12
-#define IO_FLAG_CONDITION_SIZE	9
-#define IO_CONDITION_SIZE	5
-#define MEM_INIT_SIZE		66
-
-static void still_alive(void)
-{
-#if 0
-	sync();
-	mdelay(2);
-#endif
-}
-
-static uint32_t
-munge_reg(struct nvbios *bios, uint32_t reg)
-{
-	struct drm_nouveau_private *dev_priv = bios->dev->dev_private;
-	struct dcb_entry *dcbent = bios->display.output;
-
-	if (dev_priv->card_type < NV_50)
-		return reg;
-
-	if (reg & 0x80000000) {
-		BUG_ON(bios->display.crtc < 0);
-		reg += bios->display.crtc * 0x800;
-	}
-
-	if (reg & 0x40000000) {
-		BUG_ON(!dcbent);
-
-		reg += (ffs(dcbent->or) - 1) * 0x800;
-		if ((reg & 0x20000000) && !(dcbent->sorconf.link & 1))
-			reg += 0x00000080;
-	}
-
-	reg &= ~0xe0000000;
-	return reg;
-}
-
-static int
-valid_reg(struct nvbios *bios, uint32_t reg)
-{
-	struct drm_nouveau_private *dev_priv = bios->dev->dev_private;
-	struct drm_device *dev = bios->dev;
-
-	/* C51 has misaligned regs on purpose. Marvellous */
-	if (reg & 0x2 ||
-	    (reg & 0x1 && dev_priv->vbios.chip_version != 0x51))
-		NV_ERROR(dev, "======= misaligned reg 0x%08X =======\n", reg);
-
-	/* warn on C51 regs that haven't been verified accessible in tracing */
-	if (reg & 0x1 && dev_priv->vbios.chip_version == 0x51 &&
-	    reg != 0x130d && reg != 0x1311 && reg != 0x60081d)
-		NV_WARN(dev, "=== C51 misaligned reg 0x%08X not verified ===\n",
-			reg);
-
-	if (reg >= (8*1024*1024)) {
-		NV_ERROR(dev, "=== reg 0x%08x out of mapped bounds ===\n", reg);
-		return 0;
-	}
-
-	return 1;
-}
-
-static bool
-valid_idx_port(struct nvbios *bios, uint16_t port)
-{
-	struct drm_nouveau_private *dev_priv = bios->dev->dev_private;
-	struct drm_device *dev = bios->dev;
-
-	/*
-	 * If adding more ports here, the read/write functions below will need
-	 * updating so that the correct mmio range (PRMCIO, PRMDIO, PRMVIO) is
-	 * used for the port in question
-	 */
-	if (dev_priv->card_type < NV_50) {
-		if (port == NV_CIO_CRX__COLOR)
-			return true;
-		if (port == NV_VIO_SRX)
-			return true;
-	} else {
-		if (port == NV_CIO_CRX__COLOR)
-			return true;
-	}
-
-	NV_ERROR(dev, "========== unknown indexed io port 0x%04X ==========\n",
-		 port);
-
-	return false;
-}
-
-static bool
-valid_port(struct nvbios *bios, uint16_t port)
-{
-	struct drm_device *dev = bios->dev;
-
-	/*
-	 * If adding more ports here, the read/write functions below will need
-	 * updating so that the correct mmio range (PRMCIO, PRMDIO, PRMVIO) is
-	 * used for the port in question
-	 */
-	if (port == NV_VIO_VSE2)
-		return true;
-
-	NV_ERROR(dev, "========== unknown io port 0x%04X ==========\n", port);
-
-	return false;
-}
-
-static uint32_t
-bios_rd32(struct nvbios *bios, uint32_t reg)
-{
-	uint32_t data;
-
-	reg = munge_reg(bios, reg);
-	if (!valid_reg(bios, reg))
-		return 0;
-
-	/*
-	 * C51 sometimes uses regs with bit0 set in the address. For these
-	 * cases there should exist a translation in a BIOS table to an IO
-	 * port address which the BIOS uses for accessing the reg
-	 *
-	 * These only seem to appear for the power control regs to a flat panel,
-	 * and the GPIO regs at 0x60081*.  In C51 mmio traces the normal regs
-	 * for 0x1308 and 0x1310 are used - hence the mask below.  An S3
-	 * suspend-resume mmio trace from a C51 will be required to see if this
-	 * is true for the power microcode in 0x14.., or whether the direct IO
-	 * port access method is needed
-	 */
-	if (reg & 0x1)
-		reg &= ~0x1;
-
-	data = nv_rd32(bios->dev, reg);
-
-	BIOSLOG(bios, "	Read:  Reg: 0x%08X, Data: 0x%08X\n", reg, data);
-
-	return data;
-}
-
-static void
-bios_wr32(struct nvbios *bios, uint32_t reg, uint32_t data)
-{
-	struct drm_nouveau_private *dev_priv = bios->dev->dev_private;
-
-	reg = munge_reg(bios, reg);
-	if (!valid_reg(bios, reg))
-		return;
-
-	/* see note in bios_rd32 */
-	if (reg & 0x1)
-		reg &= 0xfffffffe;
-
-	LOG_OLD_VALUE(bios_rd32(bios, reg));
-	BIOSLOG(bios, "	Write: Reg: 0x%08X, Data: 0x%08X\n", reg, data);
-
-	if (dev_priv->vbios.execute) {
-		still_alive();
-		nv_wr32(bios->dev, reg, data);
-	}
-}
-
-static uint8_t
-bios_idxprt_rd(struct nvbios *bios, uint16_t port, uint8_t index)
-{
-	struct drm_nouveau_private *dev_priv = bios->dev->dev_private;
-	struct drm_device *dev = bios->dev;
-	uint8_t data;
-
-	if (!valid_idx_port(bios, port))
-		return 0;
-
-	if (dev_priv->card_type < NV_50) {
-		if (port == NV_VIO_SRX)
-			data = NVReadVgaSeq(dev, bios->state.crtchead, index);
-		else	/* assume NV_CIO_CRX__COLOR */
-			data = NVReadVgaCrtc(dev, bios->state.crtchead, index);
-	} else {
-		uint32_t data32;
-
-		data32 = bios_rd32(bios, NV50_PDISPLAY_VGACRTC(index & ~3));
-		data = (data32 >> ((index & 3) << 3)) & 0xff;
-	}
-
-	BIOSLOG(bios, "	Indexed IO read:  Port: 0x%04X, Index: 0x%02X, "
-		      "Head: 0x%02X, Data: 0x%02X\n",
-		port, index, bios->state.crtchead, data);
-	return data;
-}
-
-static void
-bios_idxprt_wr(struct nvbios *bios, uint16_t port, uint8_t index, uint8_t data)
-{
-	struct drm_nouveau_private *dev_priv = bios->dev->dev_private;
-	struct drm_device *dev = bios->dev;
-
-	if (!valid_idx_port(bios, port))
-		return;
-
-	/*
-	 * The current head is maintained in the nvbios member  state.crtchead.
-	 * We trap changes to CR44 and update the head variable and hence the
-	 * register set written.
-	 * As CR44 only exists on CRTC0, we update crtchead to head0 in advance
-	 * of the write, and to head1 after the write
-	 */
-	if (port == NV_CIO_CRX__COLOR && index == NV_CIO_CRE_44 &&
-	    data != NV_CIO_CRE_44_HEADB)
-		bios->state.crtchead = 0;
-
-	LOG_OLD_VALUE(bios_idxprt_rd(bios, port, index));
-	BIOSLOG(bios, "	Indexed IO write: Port: 0x%04X, Index: 0x%02X, "
-		      "Head: 0x%02X, Data: 0x%02X\n",
-		port, index, bios->state.crtchead, data);
-
-	if (bios->execute && dev_priv->card_type < NV_50) {
-		still_alive();
-		if (port == NV_VIO_SRX)
-			NVWriteVgaSeq(dev, bios->state.crtchead, index, data);
-		else	/* assume NV_CIO_CRX__COLOR */
-			NVWriteVgaCrtc(dev, bios->state.crtchead, index, data);
-	} else
-	if (bios->execute) {
-		uint32_t data32, shift = (index & 3) << 3;
-
-		still_alive();
-
-		data32  = bios_rd32(bios, NV50_PDISPLAY_VGACRTC(index & ~3));
-		data32 &= ~(0xff << shift);
-		data32 |= (data << shift);
-		bios_wr32(bios, NV50_PDISPLAY_VGACRTC(index & ~3), data32);
-	}
-
-	if (port == NV_CIO_CRX__COLOR &&
-	    index == NV_CIO_CRE_44 && data == NV_CIO_CRE_44_HEADB)
-		bios->state.crtchead = 1;
-}
-
-static uint8_t
-bios_port_rd(struct nvbios *bios, uint16_t port)
-{
-	uint8_t data, head = bios->state.crtchead;
-
-	if (!valid_port(bios, port))
-		return 0;
-
-	data = NVReadPRMVIO(bios->dev, head, NV_PRMVIO0_OFFSET + port);
-
-	BIOSLOG(bios, "	IO read:  Port: 0x%04X, Head: 0x%02X, Data: 0x%02X\n",
-		port, head, data);
-
-	return data;
-}
-
-static void
-bios_port_wr(struct nvbios *bios, uint16_t port, uint8_t data)
-{
-	int head = bios->state.crtchead;
-
-	if (!valid_port(bios, port))
-		return;
-
-	LOG_OLD_VALUE(bios_port_rd(bios, port));
-	BIOSLOG(bios, "	IO write: Port: 0x%04X, Head: 0x%02X, Data: 0x%02X\n",
-		port, head, data);
-
-	if (!bios->execute)
-		return;
-
-	still_alive();
-	NVWritePRMVIO(bios->dev, head, NV_PRMVIO0_OFFSET + port, data);
-}
-
-static bool
-io_flag_condition_met(struct nvbios *bios, uint16_t offset, uint8_t cond)
-{
-	/*
-	 * The IO flag condition entry has 2 bytes for the CRTC port; 1 byte
-	 * for the CRTC index; 1 byte for the mask to apply to the value
-	 * retrieved from the CRTC; 1 byte for the shift right to apply to the
-	 * masked CRTC value; 2 bytes for the offset to the flag array, to
-	 * which the shifted value is added; 1 byte for the mask applied to the
-	 * value read from the flag array; and 1 byte for the value to compare
-	 * against the masked byte from the flag table.
-	 */
-
-	uint16_t condptr = bios->io_flag_condition_tbl_ptr + cond * IO_FLAG_CONDITION_SIZE;
-	uint16_t crtcport = ROM16(bios->data[condptr]);
-	uint8_t crtcindex = bios->data[condptr + 2];
-	uint8_t mask = bios->data[condptr + 3];
-	uint8_t shift = bios->data[condptr + 4];
-	uint16_t flagarray = ROM16(bios->data[condptr + 5]);
-	uint8_t flagarraymask = bios->data[condptr + 7];
-	uint8_t cmpval = bios->data[condptr + 8];
-	uint8_t data;
-
-	BIOSLOG(bios, "0x%04X: Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X, "
-		      "Shift: 0x%02X, FlagArray: 0x%04X, FAMask: 0x%02X, "
-		      "Cmpval: 0x%02X\n",
-		offset, crtcport, crtcindex, mask, shift, flagarray, flagarraymask, cmpval);
-
-	data = bios_idxprt_rd(bios, crtcport, crtcindex);
-
-	data = bios->data[flagarray + ((data & mask) >> shift)];
-	data &= flagarraymask;
-
-	BIOSLOG(bios, "0x%04X: Checking if 0x%02X equals 0x%02X\n",
-		offset, data, cmpval);
-
-	return (data == cmpval);
-}
-
-static bool
-bios_condition_met(struct nvbios *bios, uint16_t offset, uint8_t cond)
-{
-	/*
-	 * The condition table entry has 4 bytes for the address of the
-	 * register to check, 4 bytes for a mask to apply to the register and
-	 * 4 for a test comparison value
-	 */
-
-	uint16_t condptr = bios->condition_tbl_ptr + cond * CONDITION_SIZE;
-	uint32_t reg = ROM32(bios->data[condptr]);
-	uint32_t mask = ROM32(bios->data[condptr + 4]);
-	uint32_t cmpval = ROM32(bios->data[condptr + 8]);
-	uint32_t data;
-
-	BIOSLOG(bios, "0x%04X: Cond: 0x%02X, Reg: 0x%08X, Mask: 0x%08X\n",
-		offset, cond, reg, mask);
-
-	data = bios_rd32(bios, reg) & mask;
-
-	BIOSLOG(bios, "0x%04X: Checking if 0x%08X equals 0x%08X\n",
-		offset, data, cmpval);
-
-	return (data == cmpval);
-}
-
-static bool
-io_condition_met(struct nvbios *bios, uint16_t offset, uint8_t cond)
-{
-	/*
-	 * The IO condition entry has 2 bytes for the IO port address; 1 byte
-	 * for the index to write to io_port; 1 byte for the mask to apply to
-	 * the byte read from io_port+1; and 1 byte for the value to compare
-	 * against the masked byte.
-	 */
-
-	uint16_t condptr = bios->io_condition_tbl_ptr + cond * IO_CONDITION_SIZE;
-	uint16_t io_port = ROM16(bios->data[condptr]);
-	uint8_t port_index = bios->data[condptr + 2];
-	uint8_t mask = bios->data[condptr + 3];
-	uint8_t cmpval = bios->data[condptr + 4];
-
-	uint8_t data = bios_idxprt_rd(bios, io_port, port_index) & mask;
-
-	BIOSLOG(bios, "0x%04X: Checking if 0x%02X equals 0x%02X\n",
-		offset, data, cmpval);
-
-	return (data == cmpval);
-}
-
-static int dcb_entry_idx_from_crtchead(struct drm_device *dev)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nvbios *bios = &dev_priv->vbios;
-
-	/*
-	 * For the results of this function to be correct, CR44 must have been
-	 * set (using bios_idxprt_wr to set crtchead), CR58 set for CR57 = 0,
-	 * and the DCB table parsed, before the script calling the function is
-	 * run.  run_digital_op_script is example of how to do such setup
-	 */
-
-	uint8_t dcb_entry = NVReadVgaCrtc5758(dev, bios->state.crtchead, 0);
-
-	if (dcb_entry > bios->dcb.entries) {
-		NV_ERROR(dev, "CR58 doesn't have a valid DCB entry currently "
-				"(%02X)\n", dcb_entry);
-		dcb_entry = 0x7f;	/* unused / invalid marker */
-	}
-
-	return dcb_entry;
-}
-
-static struct nouveau_i2c_port *
-init_i2c_device_find(struct drm_device *dev, int i2c_index)
-{
-	if (i2c_index == 0xff) {
-		struct drm_nouveau_private *dev_priv = dev->dev_private;
-		struct dcb_table *dcb = &dev_priv->vbios.dcb;
-		/* note: dcb_entry_idx_from_crtchead needs pre-script set-up */
-		int idx = dcb_entry_idx_from_crtchead(dev);
-
-		i2c_index = 0x80; //NV_I2C_DEFAULT(0);
-		if (idx != 0x7f && dcb->entry[idx].i2c_upper_default)
-			i2c_index = 0x81; //NV_I2C_DEFAULT(1);
-	}
-
-	return nouveau_i2c_find(dev, i2c_index);
-}
-
-static uint32_t
-get_tmds_index_reg(struct drm_device *dev, uint8_t mlv)
-{
-	/*
-	 * For mlv < 0x80, it is an index into a table of TMDS base addresses.
-	 * For mlv == 0x80 use the "or" value of the dcb_entry indexed by
-	 * CR58 for CR57 = 0 to index a table of offsets to the basic
-	 * 0x6808b0 address.
-	 * For mlv == 0x81 use the "or" value of the dcb_entry indexed by
-	 * CR58 for CR57 = 0 to index a table of offsets to the basic
-	 * 0x6808b0 address, and then flip the offset by 8.
-	 */
-
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nvbios *bios = &dev_priv->vbios;
-	const int pramdac_offset[13] = {
-		0, 0, 0x8, 0, 0x2000, 0, 0, 0, 0x2008, 0, 0, 0, 0x2000 };
-	const uint32_t pramdac_table[4] = {
-		0x6808b0, 0x6808b8, 0x6828b0, 0x6828b8 };
-
-	if (mlv >= 0x80) {
-		int dcb_entry, dacoffset;
-
-		/* note: dcb_entry_idx_from_crtchead needs pre-script set-up */
-		dcb_entry = dcb_entry_idx_from_crtchead(dev);
-		if (dcb_entry == 0x7f)
-			return 0;
-		dacoffset = pramdac_offset[bios->dcb.entry[dcb_entry].or];
-		if (mlv == 0x81)
-			dacoffset ^= 8;
-		return 0x6808b0 + dacoffset;
-	} else {
-		if (mlv >= ARRAY_SIZE(pramdac_table)) {
-			NV_ERROR(dev, "Magic Lookup Value too big (%02X)\n",
-									mlv);
-			return 0;
-		}
-		return pramdac_table[mlv];
-	}
-}
-
-static int
-init_io_restrict_prog(struct nvbios *bios, uint16_t offset,
-		      struct init_exec *iexec)
-{
-	/*
-	 * INIT_IO_RESTRICT_PROG   opcode: 0x32 ('2')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (16 bit): CRTC port
-	 * offset + 3  (8  bit): CRTC index
-	 * offset + 4  (8  bit): mask
-	 * offset + 5  (8  bit): shift
-	 * offset + 6  (8  bit): count
-	 * offset + 7  (32 bit): register
-	 * offset + 11 (32 bit): configuration 1
-	 * ...
-	 *
-	 * Starting at offset + 11 there are "count" 32 bit values.
-	 * To find out which value to use read index "CRTC index" on "CRTC
-	 * port", AND this value with "mask" and then bit shift right "shift"
-	 * bits.  Read the appropriate value using this index and write to
-	 * "register"
-	 */
-
-	uint16_t crtcport = ROM16(bios->data[offset + 1]);
-	uint8_t crtcindex = bios->data[offset + 3];
-	uint8_t mask = bios->data[offset + 4];
-	uint8_t shift = bios->data[offset + 5];
-	uint8_t count = bios->data[offset + 6];
-	uint32_t reg = ROM32(bios->data[offset + 7]);
-	uint8_t config;
-	uint32_t configval;
-	int len = 11 + count * 4;
-
-	if (!iexec->execute)
-		return len;
-
-	BIOSLOG(bios, "0x%04X: Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X, "
-		      "Shift: 0x%02X, Count: 0x%02X, Reg: 0x%08X\n",
-		offset, crtcport, crtcindex, mask, shift, count, reg);
-
-	config = (bios_idxprt_rd(bios, crtcport, crtcindex) & mask) >> shift;
-	if (config > count) {
-		NV_ERROR(bios->dev,
-			 "0x%04X: Config 0x%02X exceeds maximal bound 0x%02X\n",
-			 offset, config, count);
-		return len;
-	}
-
-	configval = ROM32(bios->data[offset + 11 + config * 4]);
-
-	BIOSLOG(bios, "0x%04X: Writing config %02X\n", offset, config);
-
-	bios_wr32(bios, reg, configval);
-
-	return len;
-}
-
-static int
-init_repeat(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_REPEAT   opcode: 0x33 ('3')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): count
-	 *
-	 * Execute script following this opcode up to INIT_REPEAT_END
-	 * "count" times
-	 */
-
-	uint8_t count = bios->data[offset + 1];
-	uint8_t i;
-
-	/* no iexec->execute check by design */
-
-	BIOSLOG(bios, "0x%04X: Repeating following segment %d times\n",
-		offset, count);
-
-	iexec->repeat = true;
-
-	/*
-	 * count - 1, as the script block will execute once when we leave this
-	 * opcode -- this is compatible with bios behaviour as:
-	 * a) the block is always executed at least once, even if count == 0
-	 * b) the bios interpreter skips to the op following INIT_END_REPEAT,
-	 * while we don't
-	 */
-	for (i = 0; i < count - 1; i++)
-		parse_init_table(bios, offset + 2, iexec);
-
-	iexec->repeat = false;
-
-	return 2;
-}
-
-static int
-init_io_restrict_pll(struct nvbios *bios, uint16_t offset,
-		     struct init_exec *iexec)
-{
-	/*
-	 * INIT_IO_RESTRICT_PLL   opcode: 0x34 ('4')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (16 bit): CRTC port
-	 * offset + 3  (8  bit): CRTC index
-	 * offset + 4  (8  bit): mask
-	 * offset + 5  (8  bit): shift
-	 * offset + 6  (8  bit): IO flag condition index
-	 * offset + 7  (8  bit): count
-	 * offset + 8  (32 bit): register
-	 * offset + 12 (16 bit): frequency 1
-	 * ...
-	 *
-	 * Starting at offset + 12 there are "count" 16 bit frequencies (10kHz).
-	 * Set PLL register "register" to coefficients for frequency n,
-	 * selected by reading index "CRTC index" of "CRTC port" ANDed with
-	 * "mask" and shifted right by "shift".
-	 *
-	 * If "IO flag condition index" > 0, and condition met, double
-	 * frequency before setting it.
-	 */
-
-	uint16_t crtcport = ROM16(bios->data[offset + 1]);
-	uint8_t crtcindex = bios->data[offset + 3];
-	uint8_t mask = bios->data[offset + 4];
-	uint8_t shift = bios->data[offset + 5];
-	int8_t io_flag_condition_idx = bios->data[offset + 6];
-	uint8_t count = bios->data[offset + 7];
-	uint32_t reg = ROM32(bios->data[offset + 8]);
-	uint8_t config;
-	uint16_t freq;
-	int len = 12 + count * 2;
-
-	if (!iexec->execute)
-		return len;
-
-	BIOSLOG(bios, "0x%04X: Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X, "
-		      "Shift: 0x%02X, IO Flag Condition: 0x%02X, "
-		      "Count: 0x%02X, Reg: 0x%08X\n",
-		offset, crtcport, crtcindex, mask, shift,
-		io_flag_condition_idx, count, reg);
-
-	config = (bios_idxprt_rd(bios, crtcport, crtcindex) & mask) >> shift;
-	if (config > count) {
-		NV_ERROR(bios->dev,
-			 "0x%04X: Config 0x%02X exceeds maximal bound 0x%02X\n",
-			 offset, config, count);
-		return len;
-	}
-
-	freq = ROM16(bios->data[offset + 12 + config * 2]);
-
-	if (io_flag_condition_idx > 0) {
-		if (io_flag_condition_met(bios, offset, io_flag_condition_idx)) {
-			BIOSLOG(bios, "0x%04X: Condition fulfilled -- "
-				      "frequency doubled\n", offset);
-			freq *= 2;
-		} else
-			BIOSLOG(bios, "0x%04X: Condition not fulfilled -- "
-				      "frequency unchanged\n", offset);
-	}
-
-	BIOSLOG(bios, "0x%04X: Reg: 0x%08X, Config: 0x%02X, Freq: %d0kHz\n",
-		offset, reg, config, freq);
-
-	setPLL(bios->dev, reg, freq * 10);
-
-	return len;
-}
-
-static int
-init_end_repeat(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_END_REPEAT   opcode: 0x36 ('6')
-	 *
-	 * offset      (8 bit): opcode
-	 *
-	 * Marks the end of the block for INIT_REPEAT to repeat
-	 */
-
-	/* no iexec->execute check by design */
-
-	/*
-	 * iexec->repeat flag necessary to go past INIT_END_REPEAT opcode when
-	 * we're not in repeat mode
-	 */
-	if (iexec->repeat)
-		return 0;
-
-	return 1;
-}
-
-static int
-init_copy(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_COPY   opcode: 0x37 ('7')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): register
-	 * offset + 5  (8  bit): shift
-	 * offset + 6  (8  bit): srcmask
-	 * offset + 7  (16 bit): CRTC port
-	 * offset + 9  (8 bit): CRTC index
-	 * offset + 10  (8 bit): mask
-	 *
-	 * Read index "CRTC index" on "CRTC port", AND with "mask", OR with
-	 * (REGVAL("register") >> "shift" & "srcmask") and write-back to CRTC
-	 * port
-	 */
-
-	uint32_t reg = ROM32(bios->data[offset + 1]);
-	uint8_t shift = bios->data[offset + 5];
-	uint8_t srcmask = bios->data[offset + 6];
-	uint16_t crtcport = ROM16(bios->data[offset + 7]);
-	uint8_t crtcindex = bios->data[offset + 9];
-	uint8_t mask = bios->data[offset + 10];
-	uint32_t data;
-	uint8_t crtcdata;
-
-	if (!iexec->execute)
-		return 11;
-
-	BIOSLOG(bios, "0x%04X: Reg: 0x%08X, Shift: 0x%02X, SrcMask: 0x%02X, "
-		      "Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X\n",
-		offset, reg, shift, srcmask, crtcport, crtcindex, mask);
-
-	data = bios_rd32(bios, reg);
-
-	if (shift < 0x80)
-		data >>= shift;
-	else
-		data <<= (0x100 - shift);
-
-	data &= srcmask;
-
-	crtcdata  = bios_idxprt_rd(bios, crtcport, crtcindex) & mask;
-	crtcdata |= (uint8_t)data;
-	bios_idxprt_wr(bios, crtcport, crtcindex, crtcdata);
-
-	return 11;
-}
-
-static int
-init_not(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_NOT   opcode: 0x38 ('8')
-	 *
-	 * offset      (8  bit): opcode
-	 *
-	 * Invert the current execute / no-execute condition (i.e. "else")
-	 */
-	if (iexec->execute)
-		BIOSLOG(bios, "0x%04X: ------ Skipping following commands  ------\n", offset);
-	else
-		BIOSLOG(bios, "0x%04X: ------ Executing following commands ------\n", offset);
-
-	iexec->execute = !iexec->execute;
-	return 1;
-}
-
-static int
-init_io_flag_condition(struct nvbios *bios, uint16_t offset,
-		       struct init_exec *iexec)
-{
-	/*
-	 * INIT_IO_FLAG_CONDITION   opcode: 0x39 ('9')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): condition number
-	 *
-	 * Check condition "condition number" in the IO flag condition table.
-	 * If condition not met skip subsequent opcodes until condition is
-	 * inverted (INIT_NOT), or we hit INIT_RESUME
-	 */
-
-	uint8_t cond = bios->data[offset + 1];
-
-	if (!iexec->execute)
-		return 2;
-
-	if (io_flag_condition_met(bios, offset, cond))
-		BIOSLOG(bios, "0x%04X: Condition fulfilled -- continuing to execute\n", offset);
-	else {
-		BIOSLOG(bios, "0x%04X: Condition not fulfilled -- skipping following commands\n", offset);
-		iexec->execute = false;
-	}
-
-	return 2;
-}
-
-static int
-init_dp_condition(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_DP_CONDITION   opcode: 0x3A ('')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): "sub" opcode
-	 * offset + 2  (8 bit): unknown
-	 *
-	 */
-
-	struct dcb_entry *dcb = bios->display.output;
-	struct drm_device *dev = bios->dev;
-	uint8_t cond = bios->data[offset + 1];
-	uint8_t *table, *entry;
-
-	BIOSLOG(bios, "0x%04X: subop 0x%02X\n", offset, cond);
-
-	if (!iexec->execute)
-		return 3;
-
-	table = nouveau_dp_bios_data(dev, dcb, &entry);
-	if (!table)
-		return 3;
-
-	switch (cond) {
-	case 0:
-		entry = dcb_conn(dev, dcb->connector);
-		if (!entry || entry[0] != DCB_CONNECTOR_eDP)
-			iexec->execute = false;
-		break;
-	case 1:
-	case 2:
-		if ((table[0]  < 0x40 && !(entry[5] & cond)) ||
-		    (table[0] == 0x40 && !(entry[4] & cond)))
-			iexec->execute = false;
-		break;
-	case 5:
-	{
-		struct nouveau_i2c_port *auxch;
-		int ret;
-
-		auxch = nouveau_i2c_find(dev, bios->display.output->i2c_index);
-		if (!auxch) {
-			NV_ERROR(dev, "0x%04X: couldn't get auxch\n", offset);
-			return 3;
-		}
-
-		ret = auxch_rd(dev, auxch, 0xd, &cond, 1);
-		if (ret) {
-			NV_ERROR(dev, "0x%04X: auxch rd fail: %d\n", offset, ret);
-			return 3;
-		}
-
-		if (!(cond & 1))
-			iexec->execute = false;
-	}
-		break;
-	default:
-		NV_WARN(dev, "0x%04X: unknown INIT_3A op: %d\n", offset, cond);
-		break;
-	}
-
-	if (iexec->execute)
-		BIOSLOG(bios, "0x%04X: continuing to execute\n", offset);
-	else
-		BIOSLOG(bios, "0x%04X: skipping following commands\n", offset);
-
-	return 3;
-}
-
-static int
-init_op_3b(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_3B   opcode: 0x3B ('')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): crtc index
-	 *
-	 */
-
-	uint8_t or = ffs(bios->display.output->or) - 1;
-	uint8_t index = bios->data[offset + 1];
-	uint8_t data;
-
-	if (!iexec->execute)
-		return 2;
-
-	data = bios_idxprt_rd(bios, 0x3d4, index);
-	bios_idxprt_wr(bios, 0x3d4, index, data & ~(1 << or));
-	return 2;
-}
-
-static int
-init_op_3c(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_3C   opcode: 0x3C ('')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): crtc index
-	 *
-	 */
-
-	uint8_t or = ffs(bios->display.output->or) - 1;
-	uint8_t index = bios->data[offset + 1];
-	uint8_t data;
-
-	if (!iexec->execute)
-		return 2;
-
-	data = bios_idxprt_rd(bios, 0x3d4, index);
-	bios_idxprt_wr(bios, 0x3d4, index, data | (1 << or));
-	return 2;
-}
-
-static int
-init_idx_addr_latched(struct nvbios *bios, uint16_t offset,
-		      struct init_exec *iexec)
-{
-	/*
-	 * INIT_INDEX_ADDRESS_LATCHED   opcode: 0x49 ('I')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): control register
-	 * offset + 5  (32 bit): data register
-	 * offset + 9  (32 bit): mask
-	 * offset + 13 (32 bit): data
-	 * offset + 17 (8  bit): count
-	 * offset + 18 (8  bit): address 1
-	 * offset + 19 (8  bit): data 1
-	 * ...
-	 *
-	 * For each of "count" address and data pairs, write "data n" to
-	 * "data register", read the current value of "control register",
-	 * and write it back once ANDed with "mask", ORed with "data",
-	 * and ORed with "address n"
-	 */
-
-	uint32_t controlreg = ROM32(bios->data[offset + 1]);
-	uint32_t datareg = ROM32(bios->data[offset + 5]);
-	uint32_t mask = ROM32(bios->data[offset + 9]);
-	uint32_t data = ROM32(bios->data[offset + 13]);
-	uint8_t count = bios->data[offset + 17];
-	int len = 18 + count * 2;
-	uint32_t value;
-	int i;
-
-	if (!iexec->execute)
-		return len;
-
-	BIOSLOG(bios, "0x%04X: ControlReg: 0x%08X, DataReg: 0x%08X, "
-		      "Mask: 0x%08X, Data: 0x%08X, Count: 0x%02X\n",
-		offset, controlreg, datareg, mask, data, count);
-
-	for (i = 0; i < count; i++) {
-		uint8_t instaddress = bios->data[offset + 18 + i * 2];
-		uint8_t instdata = bios->data[offset + 19 + i * 2];
-
-		BIOSLOG(bios, "0x%04X: Address: 0x%02X, Data: 0x%02X\n",
-			offset, instaddress, instdata);
-
-		bios_wr32(bios, datareg, instdata);
-		value  = bios_rd32(bios, controlreg) & mask;
-		value |= data;
-		value |= instaddress;
-		bios_wr32(bios, controlreg, value);
-	}
-
-	return len;
-}
-
-static int
-init_io_restrict_pll2(struct nvbios *bios, uint16_t offset,
-		      struct init_exec *iexec)
-{
-	/*
-	 * INIT_IO_RESTRICT_PLL2   opcode: 0x4A ('J')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (16 bit): CRTC port
-	 * offset + 3  (8  bit): CRTC index
-	 * offset + 4  (8  bit): mask
-	 * offset + 5  (8  bit): shift
-	 * offset + 6  (8  bit): count
-	 * offset + 7  (32 bit): register
-	 * offset + 11 (32 bit): frequency 1
-	 * ...
-	 *
-	 * Starting at offset + 11 there are "count" 32 bit frequencies (kHz).
-	 * Set PLL register "register" to coefficients for frequency n,
-	 * selected by reading index "CRTC index" of "CRTC port" ANDed with
-	 * "mask" and shifted right by "shift".
-	 */
-
-	uint16_t crtcport = ROM16(bios->data[offset + 1]);
-	uint8_t crtcindex = bios->data[offset + 3];
-	uint8_t mask = bios->data[offset + 4];
-	uint8_t shift = bios->data[offset + 5];
-	uint8_t count = bios->data[offset + 6];
-	uint32_t reg = ROM32(bios->data[offset + 7]);
-	int len = 11 + count * 4;
-	uint8_t config;
-	uint32_t freq;
-
-	if (!iexec->execute)
-		return len;
-
-	BIOSLOG(bios, "0x%04X: Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X, "
-		      "Shift: 0x%02X, Count: 0x%02X, Reg: 0x%08X\n",
-		offset, crtcport, crtcindex, mask, shift, count, reg);
-
-	if (!reg)
-		return len;
-
-	config = (bios_idxprt_rd(bios, crtcport, crtcindex) & mask) >> shift;
-	if (config > count) {
-		NV_ERROR(bios->dev,
-			 "0x%04X: Config 0x%02X exceeds maximal bound 0x%02X\n",
-			 offset, config, count);
-		return len;
-	}
-
-	freq = ROM32(bios->data[offset + 11 + config * 4]);
-
-	BIOSLOG(bios, "0x%04X: Reg: 0x%08X, Config: 0x%02X, Freq: %dkHz\n",
-		offset, reg, config, freq);
-
-	setPLL(bios->dev, reg, freq);
-
-	return len;
-}
-
-static int
-init_pll2(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_PLL2   opcode: 0x4B ('K')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): register
-	 * offset + 5  (32 bit): freq
-	 *
-	 * Set PLL register "register" to coefficients for frequency "freq"
-	 */
-
-	uint32_t reg = ROM32(bios->data[offset + 1]);
-	uint32_t freq = ROM32(bios->data[offset + 5]);
-
-	if (!iexec->execute)
-		return 9;
-
-	BIOSLOG(bios, "0x%04X: Reg: 0x%04X, Freq: %dkHz\n",
-		offset, reg, freq);
-
-	setPLL(bios->dev, reg, freq);
-	return 9;
-}
-
-static int
-init_i2c_byte(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_I2C_BYTE   opcode: 0x4C ('L')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): DCB I2C table entry index
-	 * offset + 2  (8 bit): I2C slave address
-	 * offset + 3  (8 bit): count
-	 * offset + 4  (8 bit): I2C register 1
-	 * offset + 5  (8 bit): mask 1
-	 * offset + 6  (8 bit): data 1
-	 * ...
-	 *
-	 * For each of "count" registers given by "I2C register n" on the device
-	 * addressed by "I2C slave address" on the I2C bus given by
-	 * "DCB I2C table entry index", read the register, AND the result with
-	 * "mask n" and OR it with "data n" before writing it back to the device
-	 */
-
-	struct drm_device *dev = bios->dev;
-	uint8_t i2c_index = bios->data[offset + 1];
-	uint8_t i2c_address = bios->data[offset + 2] >> 1;
-	uint8_t count = bios->data[offset + 3];
-	struct nouveau_i2c_port *chan;
-	int len = 4 + count * 3;
-	int ret, i;
-
-	if (!iexec->execute)
-		return len;
-
-	BIOSLOG(bios, "0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X, "
-		      "Count: 0x%02X\n",
-		offset, i2c_index, i2c_address, count);
-
-	chan = init_i2c_device_find(dev, i2c_index);
-	if (!chan) {
-		NV_ERROR(dev, "0x%04X: i2c bus not found\n", offset);
-		return len;
-	}
-
-	for (i = 0; i < count; i++) {
-		uint8_t reg = bios->data[offset + 4 + i * 3];
-		uint8_t mask = bios->data[offset + 5 + i * 3];
-		uint8_t data = bios->data[offset + 6 + i * 3];
-		union i2c_smbus_data val;
-
-		ret = i2c_smbus_xfer(nouveau_i2c_adapter(chan), i2c_address, 0,
-				     I2C_SMBUS_READ, reg,
-				     I2C_SMBUS_BYTE_DATA, &val);
-		if (ret < 0) {
-			NV_ERROR(dev, "0x%04X: i2c rd fail: %d\n", offset, ret);
-			return len;
-		}
-
-		BIOSLOG(bios, "0x%04X: I2CReg: 0x%02X, Value: 0x%02X, "
-			      "Mask: 0x%02X, Data: 0x%02X\n",
-			offset, reg, val.byte, mask, data);
-
-		if (!bios->execute)
-			continue;
-
-		val.byte &= mask;
-		val.byte |= data;
-		ret = i2c_smbus_xfer(nouveau_i2c_adapter(chan), i2c_address, 0,
-				     I2C_SMBUS_WRITE, reg,
-				     I2C_SMBUS_BYTE_DATA, &val);
-		if (ret < 0) {
-			NV_ERROR(dev, "0x%04X: i2c wr fail: %d\n", offset, ret);
-			return len;
-		}
-	}
-
-	return len;
-}
-
-static int
-init_zm_i2c_byte(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_ZM_I2C_BYTE   opcode: 0x4D ('M')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): DCB I2C table entry index
-	 * offset + 2  (8 bit): I2C slave address
-	 * offset + 3  (8 bit): count
-	 * offset + 4  (8 bit): I2C register 1
-	 * offset + 5  (8 bit): data 1
-	 * ...
-	 *
-	 * For each of "count" registers given by "I2C register n" on the device
-	 * addressed by "I2C slave address" on the I2C bus given by
-	 * "DCB I2C table entry index", set the register to "data n"
-	 */
-
-	struct drm_device *dev = bios->dev;
-	uint8_t i2c_index = bios->data[offset + 1];
-	uint8_t i2c_address = bios->data[offset + 2] >> 1;
-	uint8_t count = bios->data[offset + 3];
-	struct nouveau_i2c_port *chan;
-	int len = 4 + count * 2;
-	int ret, i;
-
-	if (!iexec->execute)
-		return len;
-
-	BIOSLOG(bios, "0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X, "
-		      "Count: 0x%02X\n",
-		offset, i2c_index, i2c_address, count);
-
-	chan = init_i2c_device_find(dev, i2c_index);
-	if (!chan) {
-		NV_ERROR(dev, "0x%04X: i2c bus not found\n", offset);
-		return len;
-	}
-
-	for (i = 0; i < count; i++) {
-		uint8_t reg = bios->data[offset + 4 + i * 2];
-		union i2c_smbus_data val;
-
-		val.byte = bios->data[offset + 5 + i * 2];
-
-		BIOSLOG(bios, "0x%04X: I2CReg: 0x%02X, Data: 0x%02X\n",
-			offset, reg, val.byte);
-
-		if (!bios->execute)
-			continue;
-
-		ret = i2c_smbus_xfer(nouveau_i2c_adapter(chan), i2c_address, 0,
-				     I2C_SMBUS_WRITE, reg,
-				     I2C_SMBUS_BYTE_DATA, &val);
-		if (ret < 0) {
-			NV_ERROR(dev, "0x%04X: i2c wr fail: %d\n", offset, ret);
-			return len;
-		}
-	}
-
-	return len;
-}
-
-static int
-init_zm_i2c(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_ZM_I2C   opcode: 0x4E ('N')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): DCB I2C table entry index
-	 * offset + 2  (8 bit): I2C slave address
-	 * offset + 3  (8 bit): count
-	 * offset + 4  (8 bit): data 1
-	 * ...
-	 *
-	 * Send "count" bytes ("data n") to the device addressed by "I2C slave
-	 * address" on the I2C bus given by "DCB I2C table entry index"
-	 */
-
-	struct drm_device *dev = bios->dev;
-	uint8_t i2c_index = bios->data[offset + 1];
-	uint8_t i2c_address = bios->data[offset + 2] >> 1;
-	uint8_t count = bios->data[offset + 3];
-	int len = 4 + count;
-	struct nouveau_i2c_port *chan;
-	struct i2c_msg msg;
-	uint8_t data[256];
-	int ret, i;
-
-	if (!iexec->execute)
-		return len;
-
-	BIOSLOG(bios, "0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X, "
-		      "Count: 0x%02X\n",
-		offset, i2c_index, i2c_address, count);
-
-	chan = init_i2c_device_find(dev, i2c_index);
-	if (!chan) {
-		NV_ERROR(dev, "0x%04X: i2c bus not found\n", offset);
-		return len;
-	}
-
-	for (i = 0; i < count; i++) {
-		data[i] = bios->data[offset + 4 + i];
-
-		BIOSLOG(bios, "0x%04X: Data: 0x%02X\n", offset, data[i]);
-	}
-
-	if (bios->execute) {
-		msg.addr = i2c_address;
-		msg.flags = 0;
-		msg.len = count;
-		msg.buf = data;
-		ret = i2c_transfer(nouveau_i2c_adapter(chan), &msg, 1);
-		if (ret != 1) {
-			NV_ERROR(dev, "0x%04X: i2c wr fail: %d\n", offset, ret);
-			return len;
-		}
-	}
-
-	return len;
-}
-
-static int
-init_tmds(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_TMDS   opcode: 0x4F ('O')	(non-canon name)
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): magic lookup value
-	 * offset + 2  (8 bit): TMDS address
-	 * offset + 3  (8 bit): mask
-	 * offset + 4  (8 bit): data
-	 *
-	 * Read the data reg for TMDS address "TMDS address", AND it with mask
-	 * and OR it with data, then write it back
-	 * "magic lookup value" determines which TMDS base address register is
-	 * used -- see get_tmds_index_reg()
-	 */
-
-	struct drm_device *dev = bios->dev;
-	uint8_t mlv = bios->data[offset + 1];
-	uint32_t tmdsaddr = bios->data[offset + 2];
-	uint8_t mask = bios->data[offset + 3];
-	uint8_t data = bios->data[offset + 4];
-	uint32_t reg, value;
-
-	if (!iexec->execute)
-		return 5;
-
-	BIOSLOG(bios, "0x%04X: MagicLookupValue: 0x%02X, TMDSAddr: 0x%02X, "
-		      "Mask: 0x%02X, Data: 0x%02X\n",
-		offset, mlv, tmdsaddr, mask, data);
-
-	reg = get_tmds_index_reg(bios->dev, mlv);
-	if (!reg) {
-		NV_ERROR(dev, "0x%04X: no tmds_index_reg\n", offset);
-		return 5;
-	}
-
-	bios_wr32(bios, reg,
-		  tmdsaddr | NV_PRAMDAC_FP_TMDS_CONTROL_WRITE_DISABLE);
-	value = (bios_rd32(bios, reg + 4) & mask) | data;
-	bios_wr32(bios, reg + 4, value);
-	bios_wr32(bios, reg, tmdsaddr);
-
-	return 5;
-}
-
-static int
-init_zm_tmds_group(struct nvbios *bios, uint16_t offset,
-		   struct init_exec *iexec)
-{
-	/*
-	 * INIT_ZM_TMDS_GROUP   opcode: 0x50 ('P')	(non-canon name)
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): magic lookup value
-	 * offset + 2  (8 bit): count
-	 * offset + 3  (8 bit): addr 1
-	 * offset + 4  (8 bit): data 1
-	 * ...
-	 *
-	 * For each of "count" TMDS address and data pairs write "data n" to
-	 * "addr n".  "magic lookup value" determines which TMDS base address
-	 * register is used -- see get_tmds_index_reg()
-	 */
-
-	struct drm_device *dev = bios->dev;
-	uint8_t mlv = bios->data[offset + 1];
-	uint8_t count = bios->data[offset + 2];
-	int len = 3 + count * 2;
-	uint32_t reg;
-	int i;
-
-	if (!iexec->execute)
-		return len;
-
-	BIOSLOG(bios, "0x%04X: MagicLookupValue: 0x%02X, Count: 0x%02X\n",
-		offset, mlv, count);
-
-	reg = get_tmds_index_reg(bios->dev, mlv);
-	if (!reg) {
-		NV_ERROR(dev, "0x%04X: no tmds_index_reg\n", offset);
-		return len;
-	}
-
-	for (i = 0; i < count; i++) {
-		uint8_t tmdsaddr = bios->data[offset + 3 + i * 2];
-		uint8_t tmdsdata = bios->data[offset + 4 + i * 2];
-
-		bios_wr32(bios, reg + 4, tmdsdata);
-		bios_wr32(bios, reg, tmdsaddr);
-	}
-
-	return len;
-}
-
-static int
-init_cr_idx_adr_latch(struct nvbios *bios, uint16_t offset,
-		      struct init_exec *iexec)
-{
-	/*
-	 * INIT_CR_INDEX_ADDRESS_LATCHED   opcode: 0x51 ('Q')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): CRTC index1
-	 * offset + 2  (8 bit): CRTC index2
-	 * offset + 3  (8 bit): baseaddr
-	 * offset + 4  (8 bit): count
-	 * offset + 5  (8 bit): data 1
-	 * ...
-	 *
-	 * For each of "count" address and data pairs, write "baseaddr + n" to
-	 * "CRTC index1" and "data n" to "CRTC index2"
-	 * Once complete, restore initial value read from "CRTC index1"
-	 */
-	uint8_t crtcindex1 = bios->data[offset + 1];
-	uint8_t crtcindex2 = bios->data[offset + 2];
-	uint8_t baseaddr = bios->data[offset + 3];
-	uint8_t count = bios->data[offset + 4];
-	int len = 5 + count;
-	uint8_t oldaddr, data;
-	int i;
-
-	if (!iexec->execute)
-		return len;
-
-	BIOSLOG(bios, "0x%04X: Index1: 0x%02X, Index2: 0x%02X, "
-		      "BaseAddr: 0x%02X, Count: 0x%02X\n",
-		offset, crtcindex1, crtcindex2, baseaddr, count);
-
-	oldaddr = bios_idxprt_rd(bios, NV_CIO_CRX__COLOR, crtcindex1);
-
-	for (i = 0; i < count; i++) {
-		bios_idxprt_wr(bios, NV_CIO_CRX__COLOR, crtcindex1,
-				     baseaddr + i);
-		data = bios->data[offset + 5 + i];
-		bios_idxprt_wr(bios, NV_CIO_CRX__COLOR, crtcindex2, data);
-	}
-
-	bios_idxprt_wr(bios, NV_CIO_CRX__COLOR, crtcindex1, oldaddr);
-
-	return len;
-}
-
-static int
-init_cr(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_CR   opcode: 0x52 ('R')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (8  bit): CRTC index
-	 * offset + 2  (8  bit): mask
-	 * offset + 3  (8  bit): data
-	 *
-	 * Assign the value of at "CRTC index" ANDed with mask and ORed with
-	 * data back to "CRTC index"
-	 */
-
-	uint8_t crtcindex = bios->data[offset + 1];
-	uint8_t mask = bios->data[offset + 2];
-	uint8_t data = bios->data[offset + 3];
-	uint8_t value;
-
-	if (!iexec->execute)
-		return 4;
-
-	BIOSLOG(bios, "0x%04X: Index: 0x%02X, Mask: 0x%02X, Data: 0x%02X\n",
-		offset, crtcindex, mask, data);
-
-	value  = bios_idxprt_rd(bios, NV_CIO_CRX__COLOR, crtcindex) & mask;
-	value |= data;
-	bios_idxprt_wr(bios, NV_CIO_CRX__COLOR, crtcindex, value);
-
-	return 4;
-}
-
-static int
-init_zm_cr(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_ZM_CR   opcode: 0x53 ('S')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): CRTC index
-	 * offset + 2  (8 bit): value
-	 *
-	 * Assign "value" to CRTC register with index "CRTC index".
-	 */
-
-	uint8_t crtcindex = ROM32(bios->data[offset + 1]);
-	uint8_t data = bios->data[offset + 2];
-
-	if (!iexec->execute)
-		return 3;
-
-	bios_idxprt_wr(bios, NV_CIO_CRX__COLOR, crtcindex, data);
-
-	return 3;
-}
-
-static int
-init_zm_cr_group(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_ZM_CR_GROUP   opcode: 0x54 ('T')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): count
-	 * offset + 2  (8 bit): CRTC index 1
-	 * offset + 3  (8 bit): value 1
-	 * ...
-	 *
-	 * For "count", assign "value n" to CRTC register with index
-	 * "CRTC index n".
-	 */
-
-	uint8_t count = bios->data[offset + 1];
-	int len = 2 + count * 2;
-	int i;
-
-	if (!iexec->execute)
-		return len;
-
-	for (i = 0; i < count; i++)
-		init_zm_cr(bios, offset + 2 + 2 * i - 1, iexec);
-
-	return len;
-}
-
-static int
-init_condition_time(struct nvbios *bios, uint16_t offset,
-		    struct init_exec *iexec)
-{
-	/*
-	 * INIT_CONDITION_TIME   opcode: 0x56 ('V')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): condition number
-	 * offset + 2  (8 bit): retries / 50
-	 *
-	 * Check condition "condition number" in the condition table.
-	 * Bios code then sleeps for 2ms if the condition is not met, and
-	 * repeats up to "retries" times, but on one C51 this has proved
-	 * insufficient.  In mmiotraces the driver sleeps for 20ms, so we do
-	 * this, and bail after "retries" times, or 2s, whichever is less.
-	 * If still not met after retries, clear execution flag for this table.
-	 */
-
-	uint8_t cond = bios->data[offset + 1];
-	uint16_t retries = bios->data[offset + 2] * 50;
-	unsigned cnt;
-
-	if (!iexec->execute)
-		return 3;
-
-	if (retries > 100)
-		retries = 100;
-
-	BIOSLOG(bios, "0x%04X: Condition: 0x%02X, Retries: 0x%02X\n",
-		offset, cond, retries);
-
-	if (!bios->execute) /* avoid 2s delays when "faking" execution */
-		retries = 1;
-
-	for (cnt = 0; cnt < retries; cnt++) {
-		if (bios_condition_met(bios, offset, cond)) {
-			BIOSLOG(bios, "0x%04X: Condition met, continuing\n",
-								offset);
-			break;
-		} else {
-			BIOSLOG(bios, "0x%04X: "
-				"Condition not met, sleeping for 20ms\n",
-								offset);
-			mdelay(20);
-		}
-	}
-
-	if (!bios_condition_met(bios, offset, cond)) {
-		NV_WARN(bios->dev,
-			"0x%04X: Condition still not met after %dms, "
-			"skipping following opcodes\n", offset, 20 * retries);
-		iexec->execute = false;
-	}
-
-	return 3;
-}
-
-static int
-init_ltime(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_LTIME   opcode: 0x57 ('V')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (16 bit): time
-	 *
-	 * Sleep for "time" milliseconds.
-	 */
-
-	unsigned time = ROM16(bios->data[offset + 1]);
-
-	if (!iexec->execute)
-		return 3;
-
-	BIOSLOG(bios, "0x%04X: Sleeping for 0x%04X milliseconds\n",
-		offset, time);
-
-	mdelay(time);
-
-	return 3;
-}
-
-static int
-init_zm_reg_sequence(struct nvbios *bios, uint16_t offset,
-		     struct init_exec *iexec)
-{
-	/*
-	 * INIT_ZM_REG_SEQUENCE   opcode: 0x58 ('X')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): base register
-	 * offset + 5  (8  bit): count
-	 * offset + 6  (32 bit): value 1
-	 * ...
-	 *
-	 * Starting at offset + 6 there are "count" 32 bit values.
-	 * For "count" iterations set "base register" + 4 * current_iteration
-	 * to "value current_iteration"
-	 */
-
-	uint32_t basereg = ROM32(bios->data[offset + 1]);
-	uint32_t count = bios->data[offset + 5];
-	int len = 6 + count * 4;
-	int i;
-
-	if (!iexec->execute)
-		return len;
-
-	BIOSLOG(bios, "0x%04X: BaseReg: 0x%08X, Count: 0x%02X\n",
-		offset, basereg, count);
-
-	for (i = 0; i < count; i++) {
-		uint32_t reg = basereg + i * 4;
-		uint32_t data = ROM32(bios->data[offset + 6 + i * 4]);
-
-		bios_wr32(bios, reg, data);
-	}
-
-	return len;
-}
-
-static int
-init_sub_direct(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_SUB_DIRECT   opcode: 0x5B ('[')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (16 bit): subroutine offset (in bios)
-	 *
-	 * Calls a subroutine that will execute commands until INIT_DONE
-	 * is found.
-	 */
-
-	uint16_t sub_offset = ROM16(bios->data[offset + 1]);
-
-	if (!iexec->execute)
-		return 3;
-
-	BIOSLOG(bios, "0x%04X: Executing subroutine at 0x%04X\n",
-		offset, sub_offset);
-
-	parse_init_table(bios, sub_offset, iexec);
-
-	BIOSLOG(bios, "0x%04X: End of 0x%04X subroutine\n", offset, sub_offset);
-
-	return 3;
-}
-
-static int
-init_jump(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_JUMP   opcode: 0x5C ('\')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (16 bit): offset (in bios)
-	 *
-	 * Continue execution of init table from 'offset'
-	 */
-
-	uint16_t jmp_offset = ROM16(bios->data[offset + 1]);
-
-	if (!iexec->execute)
-		return 3;
-
-	BIOSLOG(bios, "0x%04X: Jump to 0x%04X\n", offset, jmp_offset);
-	return jmp_offset - offset;
-}
-
-static int
-init_i2c_if(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_I2C_IF   opcode: 0x5E ('^')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): DCB I2C table entry index
-	 * offset + 2  (8 bit): I2C slave address
-	 * offset + 3  (8 bit): I2C register
-	 * offset + 4  (8 bit): mask
-	 * offset + 5  (8 bit): data
-	 *
-	 * Read the register given by "I2C register" on the device addressed
-	 * by "I2C slave address" on the I2C bus given by "DCB I2C table
-	 * entry index". Compare the result AND "mask" to "data".
-	 * If they're not equal, skip subsequent opcodes until condition is
-	 * inverted (INIT_NOT), or we hit INIT_RESUME
-	 */
-
-	uint8_t i2c_index = bios->data[offset + 1];
-	uint8_t i2c_address = bios->data[offset + 2] >> 1;
-	uint8_t reg = bios->data[offset + 3];
-	uint8_t mask = bios->data[offset + 4];
-	uint8_t data = bios->data[offset + 5];
-	struct nouveau_i2c_port *chan;
-	union i2c_smbus_data val;
-	int ret;
-
-	/* no execute check by design */
-
-	BIOSLOG(bios, "0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X\n",
-		offset, i2c_index, i2c_address);
-
-	chan = init_i2c_device_find(bios->dev, i2c_index);
-	if (!chan)
-		return -ENODEV;
-
-	ret = i2c_smbus_xfer(nouveau_i2c_adapter(chan), i2c_address, 0,
-			     I2C_SMBUS_READ, reg,
-			     I2C_SMBUS_BYTE_DATA, &val);
-	if (ret < 0) {
-		BIOSLOG(bios, "0x%04X: I2CReg: 0x%02X, Value: [no device], "
-			      "Mask: 0x%02X, Data: 0x%02X\n",
-			offset, reg, mask, data);
-		iexec->execute = 0;
-		return 6;
-	}
-
-	BIOSLOG(bios, "0x%04X: I2CReg: 0x%02X, Value: 0x%02X, "
-		      "Mask: 0x%02X, Data: 0x%02X\n",
-		offset, reg, val.byte, mask, data);
-
-	iexec->execute = ((val.byte & mask) == data);
-
-	return 6;
-}
-
-static int
-init_copy_nv_reg(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_COPY_NV_REG   opcode: 0x5F ('_')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): src reg
-	 * offset + 5  (8  bit): shift
-	 * offset + 6  (32 bit): src mask
-	 * offset + 10 (32 bit): xor
-	 * offset + 14 (32 bit): dst reg
-	 * offset + 18 (32 bit): dst mask
-	 *
-	 * Shift REGVAL("src reg") right by (signed) "shift", AND result with
-	 * "src mask", then XOR with "xor". Write this OR'd with
-	 * (REGVAL("dst reg") AND'd with "dst mask") to "dst reg"
-	 */
-
-	uint32_t srcreg = *((uint32_t *)(&bios->data[offset + 1]));
-	uint8_t shift = bios->data[offset + 5];
-	uint32_t srcmask = *((uint32_t *)(&bios->data[offset + 6]));
-	uint32_t xor = *((uint32_t *)(&bios->data[offset + 10]));
-	uint32_t dstreg = *((uint32_t *)(&bios->data[offset + 14]));
-	uint32_t dstmask = *((uint32_t *)(&bios->data[offset + 18]));
-	uint32_t srcvalue, dstvalue;
-
-	if (!iexec->execute)
-		return 22;
-
-	BIOSLOG(bios, "0x%04X: SrcReg: 0x%08X, Shift: 0x%02X, SrcMask: 0x%08X, "
-		      "Xor: 0x%08X, DstReg: 0x%08X, DstMask: 0x%08X\n",
-		offset, srcreg, shift, srcmask, xor, dstreg, dstmask);
-
-	srcvalue = bios_rd32(bios, srcreg);
-
-	if (shift < 0x80)
-		srcvalue >>= shift;
-	else
-		srcvalue <<= (0x100 - shift);
-
-	srcvalue = (srcvalue & srcmask) ^ xor;
-
-	dstvalue = bios_rd32(bios, dstreg) & dstmask;
-
-	bios_wr32(bios, dstreg, dstvalue | srcvalue);
-
-	return 22;
-}
-
-static int
-init_zm_index_io(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_ZM_INDEX_IO   opcode: 0x62 ('b')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (16 bit): CRTC port
-	 * offset + 3  (8  bit): CRTC index
-	 * offset + 4  (8  bit): data
-	 *
-	 * Write "data" to index "CRTC index" of "CRTC port"
-	 */
-	uint16_t crtcport = ROM16(bios->data[offset + 1]);
-	uint8_t crtcindex = bios->data[offset + 3];
-	uint8_t data = bios->data[offset + 4];
-
-	if (!iexec->execute)
-		return 5;
-
-	bios_idxprt_wr(bios, crtcport, crtcindex, data);
-
-	return 5;
-}
-
-static inline void
-bios_md32(struct nvbios *bios, uint32_t reg,
-	  uint32_t mask, uint32_t val)
-{
-	bios_wr32(bios, reg, (bios_rd32(bios, reg) & ~mask) | val);
-}
-
-static uint32_t
-peek_fb(struct drm_device *dev, struct io_mapping *fb,
-	uint32_t off)
-{
-	uint32_t val = 0;
-
-	if (off < pci_resource_len(dev->pdev, 1)) {
-		uint8_t __iomem *p =
-			io_mapping_map_atomic_wc(fb, off & PAGE_MASK);
-
-		val = ioread32(p + (off & ~PAGE_MASK));
-
-		io_mapping_unmap_atomic(p);
-	}
-
-	return val;
-}
-
-static void
-poke_fb(struct drm_device *dev, struct io_mapping *fb,
-	uint32_t off, uint32_t val)
-{
-	if (off < pci_resource_len(dev->pdev, 1)) {
-		uint8_t __iomem *p =
-			io_mapping_map_atomic_wc(fb, off & PAGE_MASK);
-
-		iowrite32(val, p + (off & ~PAGE_MASK));
-		wmb();
-
-		io_mapping_unmap_atomic(p);
-	}
-}
-
-static inline bool
-read_back_fb(struct drm_device *dev, struct io_mapping *fb,
-	     uint32_t off, uint32_t val)
-{
-	poke_fb(dev, fb, off, val);
-	return val == peek_fb(dev, fb, off);
-}
-
-static int
-nv04_init_compute_mem(struct nvbios *bios)
-{
-	struct drm_device *dev = bios->dev;
-	uint32_t patt = 0xdeadbeef;
-	struct io_mapping *fb;
-	int i;
-
-	/* Map the framebuffer aperture */
-	fb = io_mapping_create_wc(pci_resource_start(dev->pdev, 1),
-				  pci_resource_len(dev->pdev, 1));
-	if (!fb)
-		return -ENOMEM;
-
-	/* Sequencer and refresh off */
-	NVWriteVgaSeq(dev, 0, 1, NVReadVgaSeq(dev, 0, 1) | 0x20);
-	bios_md32(bios, NV04_PFB_DEBUG_0, 0, NV04_PFB_DEBUG_0_REFRESH_OFF);
-
-	bios_md32(bios, NV04_PFB_BOOT_0, ~0,
-		  NV04_PFB_BOOT_0_RAM_AMOUNT_16MB |
-		  NV04_PFB_BOOT_0_RAM_WIDTH_128 |
-		  NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_16MBIT);
-
-	for (i = 0; i < 4; i++)
-		poke_fb(dev, fb, 4 * i, patt);
-
-	poke_fb(dev, fb, 0x400000, patt + 1);
-
-	if (peek_fb(dev, fb, 0) == patt + 1) {
-		bios_md32(bios, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_TYPE,
-			  NV04_PFB_BOOT_0_RAM_TYPE_SDRAM_16MBIT);
-		bios_md32(bios, NV04_PFB_DEBUG_0,
-			  NV04_PFB_DEBUG_0_REFRESH_OFF, 0);
-
-		for (i = 0; i < 4; i++)
-			poke_fb(dev, fb, 4 * i, patt);
-
-		if ((peek_fb(dev, fb, 0xc) & 0xffff) != (patt & 0xffff))
-			bios_md32(bios, NV04_PFB_BOOT_0,
-				  NV04_PFB_BOOT_0_RAM_WIDTH_128 |
-				  NV04_PFB_BOOT_0_RAM_AMOUNT,
-				  NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);
-
-	} else if ((peek_fb(dev, fb, 0xc) & 0xffff0000) !=
-		   (patt & 0xffff0000)) {
-		bios_md32(bios, NV04_PFB_BOOT_0,
-			  NV04_PFB_BOOT_0_RAM_WIDTH_128 |
-			  NV04_PFB_BOOT_0_RAM_AMOUNT,
-			  NV04_PFB_BOOT_0_RAM_AMOUNT_4MB);
-
-	} else if (peek_fb(dev, fb, 0) != patt) {
-		if (read_back_fb(dev, fb, 0x800000, patt))
-			bios_md32(bios, NV04_PFB_BOOT_0,
-				  NV04_PFB_BOOT_0_RAM_AMOUNT,
-				  NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);
-		else
-			bios_md32(bios, NV04_PFB_BOOT_0,
-				  NV04_PFB_BOOT_0_RAM_AMOUNT,
-				  NV04_PFB_BOOT_0_RAM_AMOUNT_4MB);
-
-		bios_md32(bios, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_TYPE,
-			  NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_8MBIT);
-
-	} else if (!read_back_fb(dev, fb, 0x800000, patt)) {
-		bios_md32(bios, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_AMOUNT,
-			  NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);
-
-	}
-
-	/* Refresh on, sequencer on */
-	bios_md32(bios, NV04_PFB_DEBUG_0, NV04_PFB_DEBUG_0_REFRESH_OFF, 0);
-	NVWriteVgaSeq(dev, 0, 1, NVReadVgaSeq(dev, 0, 1) & ~0x20);
-
-	io_mapping_free(fb);
-	return 0;
-}
-
-static const uint8_t *
-nv05_memory_config(struct nvbios *bios)
-{
-	/* Defaults for BIOSes lacking a memory config table */
-	static const uint8_t default_config_tab[][2] = {
-		{ 0x24, 0x00 },
-		{ 0x28, 0x00 },
-		{ 0x24, 0x01 },
-		{ 0x1f, 0x00 },
-		{ 0x0f, 0x00 },
-		{ 0x17, 0x00 },
-		{ 0x06, 0x00 },
-		{ 0x00, 0x00 }
-	};
-	int i = (bios_rd32(bios, NV_PEXTDEV_BOOT_0) &
-		 NV_PEXTDEV_BOOT_0_RAMCFG) >> 2;
-
-	if (bios->legacy.mem_init_tbl_ptr)
-		return &bios->data[bios->legacy.mem_init_tbl_ptr + 2 * i];
-	else
-		return default_config_tab[i];
-}
-
-static int
-nv05_init_compute_mem(struct nvbios *bios)
-{
-	struct drm_device *dev = bios->dev;
-	const uint8_t *ramcfg = nv05_memory_config(bios);
-	uint32_t patt = 0xdeadbeef;
-	struct io_mapping *fb;
-	int i, v;
-
-	/* Map the framebuffer aperture */
-	fb = io_mapping_create_wc(pci_resource_start(dev->pdev, 1),
-				  pci_resource_len(dev->pdev, 1));
-	if (!fb)
-		return -ENOMEM;
-
-	/* Sequencer off */
-	NVWriteVgaSeq(dev, 0, 1, NVReadVgaSeq(dev, 0, 1) | 0x20);
-
-	if (bios_rd32(bios, NV04_PFB_BOOT_0) & NV04_PFB_BOOT_0_UMA_ENABLE)
-		goto out;
-
-	bios_md32(bios, NV04_PFB_DEBUG_0, NV04_PFB_DEBUG_0_REFRESH_OFF, 0);
-
-	/* If present load the hardcoded scrambling table */
-	if (bios->legacy.mem_init_tbl_ptr) {
-		uint32_t *scramble_tab = (uint32_t *)&bios->data[
-			bios->legacy.mem_init_tbl_ptr + 0x10];
-
-		for (i = 0; i < 8; i++)
-			bios_wr32(bios, NV04_PFB_SCRAMBLE(i),
-				  ROM32(scramble_tab[i]));
-	}
-
-	/* Set memory type/width/length defaults depending on the straps */
-	bios_md32(bios, NV04_PFB_BOOT_0, 0x3f, ramcfg[0]);
-
-	if (ramcfg[1] & 0x80)
-		bios_md32(bios, NV04_PFB_CFG0, 0, NV04_PFB_CFG0_SCRAMBLE);
-
-	bios_md32(bios, NV04_PFB_CFG1, 0x700001, (ramcfg[1] & 1) << 20);
-	bios_md32(bios, NV04_PFB_CFG1, 0, 1);
-
-	/* Probe memory bus width */
-	for (i = 0; i < 4; i++)
-		poke_fb(dev, fb, 4 * i, patt);
-
-	if (peek_fb(dev, fb, 0xc) != patt)
-		bios_md32(bios, NV04_PFB_BOOT_0,
-			  NV04_PFB_BOOT_0_RAM_WIDTH_128, 0);
-
-	/* Probe memory length */
-	v = bios_rd32(bios, NV04_PFB_BOOT_0) & NV04_PFB_BOOT_0_RAM_AMOUNT;
-
-	if (v == NV04_PFB_BOOT_0_RAM_AMOUNT_32MB &&
-	    (!read_back_fb(dev, fb, 0x1000000, ++patt) ||
-	     !read_back_fb(dev, fb, 0, ++patt)))
-		bios_md32(bios, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_AMOUNT,
-			  NV04_PFB_BOOT_0_RAM_AMOUNT_16MB);
-
-	if (v == NV04_PFB_BOOT_0_RAM_AMOUNT_16MB &&
-	    !read_back_fb(dev, fb, 0x800000, ++patt))
-		bios_md32(bios, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_AMOUNT,
-			  NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);
-
-	if (!read_back_fb(dev, fb, 0x400000, ++patt))
-		bios_md32(bios, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_AMOUNT,
-			  NV04_PFB_BOOT_0_RAM_AMOUNT_4MB);
-
-out:
-	/* Sequencer on */
-	NVWriteVgaSeq(dev, 0, 1, NVReadVgaSeq(dev, 0, 1) & ~0x20);
-
-	io_mapping_free(fb);
-	return 0;
-}
-
-static int
-nv10_init_compute_mem(struct nvbios *bios)
-{
-	struct drm_device *dev = bios->dev;
-	struct drm_nouveau_private *dev_priv = bios->dev->dev_private;
-	const int mem_width[] = { 0x10, 0x00, 0x20 };
-	const int mem_width_count = (dev_priv->chipset >= 0x17 ? 3 : 2);
-	uint32_t patt = 0xdeadbeef;
-	struct io_mapping *fb;
-	int i, j, k;
-
-	/* Map the framebuffer aperture */
-	fb = io_mapping_create_wc(pci_resource_start(dev->pdev, 1),
-				  pci_resource_len(dev->pdev, 1));
-	if (!fb)
-		return -ENOMEM;
-
-	bios_wr32(bios, NV10_PFB_REFCTRL, NV10_PFB_REFCTRL_VALID_1);
-
-	/* Probe memory bus width */
-	for (i = 0; i < mem_width_count; i++) {
-		bios_md32(bios, NV04_PFB_CFG0, 0x30, mem_width[i]);
-
-		for (j = 0; j < 4; j++) {
-			for (k = 0; k < 4; k++)
-				poke_fb(dev, fb, 0x1c, 0);
-
-			poke_fb(dev, fb, 0x1c, patt);
-			poke_fb(dev, fb, 0x3c, 0);
-
-			if (peek_fb(dev, fb, 0x1c) == patt)
-				goto mem_width_found;
-		}
-	}
-
-mem_width_found:
-	patt <<= 1;
-
-	/* Probe amount of installed memory */
-	for (i = 0; i < 4; i++) {
-		int off = bios_rd32(bios, NV04_PFB_FIFO_DATA) - 0x100000;
-
-		poke_fb(dev, fb, off, patt);
-		poke_fb(dev, fb, 0, 0);
-
-		peek_fb(dev, fb, 0);
-		peek_fb(dev, fb, 0);
-		peek_fb(dev, fb, 0);
-		peek_fb(dev, fb, 0);
-
-		if (peek_fb(dev, fb, off) == patt)
-			goto amount_found;
-	}
-
-	/* IC missing - disable the upper half memory space. */
-	bios_md32(bios, NV04_PFB_CFG0, 0x1000, 0);
-
-amount_found:
-	io_mapping_free(fb);
-	return 0;
-}
-
-static int
-nv20_init_compute_mem(struct nvbios *bios)
-{
-	struct drm_device *dev = bios->dev;
-	struct drm_nouveau_private *dev_priv = bios->dev->dev_private;
-	uint32_t mask = (dev_priv->chipset >= 0x25 ? 0x300 : 0x900);
-	uint32_t amount, off;
-	struct io_mapping *fb;
-
-	/* Map the framebuffer aperture */
-	fb = io_mapping_create_wc(pci_resource_start(dev->pdev, 1),
-				  pci_resource_len(dev->pdev, 1));
-	if (!fb)
-		return -ENOMEM;
-
-	bios_wr32(bios, NV10_PFB_REFCTRL, NV10_PFB_REFCTRL_VALID_1);
-
-	/* Allow full addressing */
-	bios_md32(bios, NV04_PFB_CFG0, 0, mask);
-
-	amount = bios_rd32(bios, NV04_PFB_FIFO_DATA);
-	for (off = amount; off > 0x2000000; off -= 0x2000000)
-		poke_fb(dev, fb, off - 4, off);
-
-	amount = bios_rd32(bios, NV04_PFB_FIFO_DATA);
-	if (amount != peek_fb(dev, fb, amount - 4))
-		/* IC missing - disable the upper half memory space. */
-		bios_md32(bios, NV04_PFB_CFG0, mask, 0);
-
-	io_mapping_free(fb);
-	return 0;
-}
-
-static int
-init_compute_mem(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_COMPUTE_MEM   opcode: 0x63 ('c')
-	 *
-	 * offset      (8 bit): opcode
-	 *
-	 * This opcode is meant to set the PFB memory config registers
-	 * appropriately so that we can correctly calculate how much VRAM it
-	 * has (on nv10 and better chipsets the amount of installed VRAM is
-	 * subsequently reported in NV_PFB_CSTATUS (0x10020C)).
-	 *
-	 * The implementation of this opcode in general consists of several
-	 * parts:
-	 *
-	 * 1) Determination of memory type and density. Only necessary for
-	 *    really old chipsets, the memory type reported by the strap bits
-	 *    (0x101000) is assumed to be accurate on nv05 and newer.
-	 *
-	 * 2) Determination of the memory bus width. Usually done by a cunning
-	 *    combination of writes to offsets 0x1c and 0x3c in the fb, and
-	 *    seeing whether the written values are read back correctly.
-	 *
-	 *    Only necessary on nv0x-nv1x and nv34, on the other cards we can
-	 *    trust the straps.
-	 *
-	 * 3) Determination of how many of the card's RAM pads have ICs
-	 *    attached, usually done by a cunning combination of writes to an
-	 *    offset slightly less than the maximum memory reported by
-	 *    NV_PFB_CSTATUS, then seeing if the test pattern can be read back.
-	 *
-	 * This appears to be a NOP on IGPs and NV4x or newer chipsets, both io
-	 * logs of the VBIOS and kmmio traces of the binary driver POSTing the
-	 * card show nothing being done for this opcode. Why is it still listed
-	 * in the table?!
-	 */
-
-	/* no iexec->execute check by design */
-
-	struct drm_nouveau_private *dev_priv = bios->dev->dev_private;
-	int ret;
-
-	if (dev_priv->chipset >= 0x40 ||
-	    dev_priv->chipset == 0x1a ||
-	    dev_priv->chipset == 0x1f)
-		ret = 0;
-	else if (dev_priv->chipset >= 0x20 &&
-		 dev_priv->chipset != 0x34)
-		ret = nv20_init_compute_mem(bios);
-	else if (dev_priv->chipset >= 0x10)
-		ret = nv10_init_compute_mem(bios);
-	else if (dev_priv->chipset >= 0x5)
-		ret = nv05_init_compute_mem(bios);
-	else
-		ret = nv04_init_compute_mem(bios);
-
-	if (ret)
-		return ret;
-
-	return 1;
-}
-
-static int
-init_reset(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_RESET   opcode: 0x65 ('e')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): register
-	 * offset + 5  (32 bit): value1
-	 * offset + 9  (32 bit): value2
-	 *
-	 * Assign "value1" to "register", then assign "value2" to "register"
-	 */
-
-	uint32_t reg = ROM32(bios->data[offset + 1]);
-	uint32_t value1 = ROM32(bios->data[offset + 5]);
-	uint32_t value2 = ROM32(bios->data[offset + 9]);
-	uint32_t pci_nv_19, pci_nv_20;
-
-	/* no iexec->execute check by design */
-
-	pci_nv_19 = bios_rd32(bios, NV_PBUS_PCI_NV_19);
-	bios_wr32(bios, NV_PBUS_PCI_NV_19, pci_nv_19 & ~0xf00);
-
-	bios_wr32(bios, reg, value1);
-
-	udelay(10);
-
-	bios_wr32(bios, reg, value2);
-	bios_wr32(bios, NV_PBUS_PCI_NV_19, pci_nv_19);
-
-	pci_nv_20 = bios_rd32(bios, NV_PBUS_PCI_NV_20);
-	pci_nv_20 &= ~NV_PBUS_PCI_NV_20_ROM_SHADOW_ENABLED;	/* 0xfffffffe */
-	bios_wr32(bios, NV_PBUS_PCI_NV_20, pci_nv_20);
-
-	return 13;
-}
-
-static int
-init_configure_mem(struct nvbios *bios, uint16_t offset,
-		   struct init_exec *iexec)
-{
-	/*
-	 * INIT_CONFIGURE_MEM   opcode: 0x66 ('f')
-	 *
-	 * offset      (8 bit): opcode
-	 *
-	 * Equivalent to INIT_DONE on bios version 3 or greater.
-	 * For early bios versions, sets up the memory registers, using values
-	 * taken from the memory init table
-	 */
-
-	/* no iexec->execute check by design */
-
-	uint16_t meminitoffs = bios->legacy.mem_init_tbl_ptr + MEM_INIT_SIZE * (bios_idxprt_rd(bios, NV_CIO_CRX__COLOR, NV_CIO_CRE_SCRATCH4__INDEX) >> 4);
-	uint16_t seqtbloffs = bios->legacy.sdr_seq_tbl_ptr, meminitdata = meminitoffs + 6;
-	uint32_t reg, data;
-
-	if (bios->major_version > 2)
-		return 0;
-
-	bios_idxprt_wr(bios, NV_VIO_SRX, NV_VIO_SR_CLOCK_INDEX, bios_idxprt_rd(
-		       bios, NV_VIO_SRX, NV_VIO_SR_CLOCK_INDEX) | 0x20);
-
-	if (bios->data[meminitoffs] & 1)
-		seqtbloffs = bios->legacy.ddr_seq_tbl_ptr;
-
-	for (reg = ROM32(bios->data[seqtbloffs]);
-	     reg != 0xffffffff;
-	     reg = ROM32(bios->data[seqtbloffs += 4])) {
-
-		switch (reg) {
-		case NV04_PFB_PRE:
-			data = NV04_PFB_PRE_CMD_PRECHARGE;
-			break;
-		case NV04_PFB_PAD:
-			data = NV04_PFB_PAD_CKE_NORMAL;
-			break;
-		case NV04_PFB_REF:
-			data = NV04_PFB_REF_CMD_REFRESH;
-			break;
-		default:
-			data = ROM32(bios->data[meminitdata]);
-			meminitdata += 4;
-			if (data == 0xffffffff)
-				continue;
-		}
-
-		bios_wr32(bios, reg, data);
-	}
-
-	return 1;
-}
-
-static int
-init_configure_clk(struct nvbios *bios, uint16_t offset,
-		   struct init_exec *iexec)
-{
-	/*
-	 * INIT_CONFIGURE_CLK   opcode: 0x67 ('g')
-	 *
-	 * offset      (8 bit): opcode
-	 *
-	 * Equivalent to INIT_DONE on bios version 3 or greater.
-	 * For early bios versions, sets up the NVClk and MClk PLLs, using
-	 * values taken from the memory init table
-	 */
-
-	/* no iexec->execute check by design */
-
-	uint16_t meminitoffs = bios->legacy.mem_init_tbl_ptr + MEM_INIT_SIZE * (bios_idxprt_rd(bios, NV_CIO_CRX__COLOR, NV_CIO_CRE_SCRATCH4__INDEX) >> 4);
-	int clock;
-
-	if (bios->major_version > 2)
-		return 0;
-
-	clock = ROM16(bios->data[meminitoffs + 4]) * 10;
-	setPLL(bios->dev, NV_PRAMDAC_NVPLL_COEFF, clock);
-
-	clock = ROM16(bios->data[meminitoffs + 2]) * 10;
-	if (bios->data[meminitoffs] & 1) /* DDR */
-		clock *= 2;
-	setPLL(bios->dev, NV_PRAMDAC_MPLL_COEFF, clock);
-
-	return 1;
-}
-
-static int
-init_configure_preinit(struct nvbios *bios, uint16_t offset,
-		       struct init_exec *iexec)
-{
-	/*
-	 * INIT_CONFIGURE_PREINIT   opcode: 0x68 ('h')
-	 *
-	 * offset      (8 bit): opcode
-	 *
-	 * Equivalent to INIT_DONE on bios version 3 or greater.
-	 * For early bios versions, does early init, loading ram and crystal
-	 * configuration from straps into CR3C
-	 */
-
-	/* no iexec->execute check by design */
-
-	uint32_t straps = bios_rd32(bios, NV_PEXTDEV_BOOT_0);
-	uint8_t cr3c = ((straps << 2) & 0xf0) | (straps & 0x40) >> 6;
-
-	if (bios->major_version > 2)
-		return 0;
-
-	bios_idxprt_wr(bios, NV_CIO_CRX__COLOR,
-			     NV_CIO_CRE_SCRATCH4__INDEX, cr3c);
-
-	return 1;
-}
-
-static int
-init_io(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_IO   opcode: 0x69 ('i')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (16 bit): CRTC port
-	 * offset + 3  (8  bit): mask
-	 * offset + 4  (8  bit): data
-	 *
-	 * Assign ((IOVAL("crtc port") & "mask") | "data") to "crtc port"
-	 */
-
-	struct drm_nouveau_private *dev_priv = bios->dev->dev_private;
-	uint16_t crtcport = ROM16(bios->data[offset + 1]);
-	uint8_t mask = bios->data[offset + 3];
-	uint8_t data = bios->data[offset + 4];
-
-	if (!iexec->execute)
-		return 5;
-
-	BIOSLOG(bios, "0x%04X: Port: 0x%04X, Mask: 0x%02X, Data: 0x%02X\n",
-		offset, crtcport, mask, data);
-
-	/*
-	 * I have no idea what this does, but NVIDIA do this magic sequence
-	 * in the places where this INIT_IO happens..
-	 */
-	if (dev_priv->card_type >= NV_50 && crtcport == 0x3c3 && data == 1) {
-		int i;
-
-		bios_wr32(bios, 0x614100, (bios_rd32(
-			  bios, 0x614100) & 0x0fffffff) | 0x00800000);
-
-		bios_wr32(bios, 0x00e18c, bios_rd32(
-			  bios, 0x00e18c) | 0x00020000);
-
-		bios_wr32(bios, 0x614900, (bios_rd32(
-			  bios, 0x614900) & 0x0fffffff) | 0x00800000);
-
-		bios_wr32(bios, 0x000200, bios_rd32(
-			  bios, 0x000200) & ~0x40000000);
-
-		mdelay(10);
-
-		bios_wr32(bios, 0x00e18c, bios_rd32(
-			  bios, 0x00e18c) & ~0x00020000);
-
-		bios_wr32(bios, 0x000200, bios_rd32(
-			  bios, 0x000200) | 0x40000000);
-
-		bios_wr32(bios, 0x614100, 0x00800018);
-		bios_wr32(bios, 0x614900, 0x00800018);
-
-		mdelay(10);
-
-		bios_wr32(bios, 0x614100, 0x10000018);
-		bios_wr32(bios, 0x614900, 0x10000018);
-
-		for (i = 0; i < 3; i++)
-			bios_wr32(bios, 0x614280 + (i*0x800), bios_rd32(
-				  bios, 0x614280 + (i*0x800)) & 0xf0f0f0f0);
-
-		for (i = 0; i < 2; i++)
-			bios_wr32(bios, 0x614300 + (i*0x800), bios_rd32(
-				  bios, 0x614300 + (i*0x800)) & 0xfffff0f0);
-
-		for (i = 0; i < 3; i++)
-			bios_wr32(bios, 0x614380 + (i*0x800), bios_rd32(
-				  bios, 0x614380 + (i*0x800)) & 0xfffff0f0);
-
-		for (i = 0; i < 2; i++)
-			bios_wr32(bios, 0x614200 + (i*0x800), bios_rd32(
-				  bios, 0x614200 + (i*0x800)) & 0xfffffff0);
-
-		for (i = 0; i < 2; i++)
-			bios_wr32(bios, 0x614108 + (i*0x800), bios_rd32(
-				  bios, 0x614108 + (i*0x800)) & 0x0fffffff);
-		return 5;
-	}
-
-	bios_port_wr(bios, crtcport, (bios_port_rd(bios, crtcport) & mask) |
-									data);
-	return 5;
-}
-
-static int
-init_sub(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_SUB   opcode: 0x6B ('k')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): script number
-	 *
-	 * Execute script number "script number", as a subroutine
-	 */
-
-	uint8_t sub = bios->data[offset + 1];
-
-	if (!iexec->execute)
-		return 2;
-
-	BIOSLOG(bios, "0x%04X: Calling script %d\n", offset, sub);
-
-	parse_init_table(bios,
-			 ROM16(bios->data[bios->init_script_tbls_ptr + sub * 2]),
-			 iexec);
-
-	BIOSLOG(bios, "0x%04X: End of script %d\n", offset, sub);
-
-	return 2;
-}
-
-static int
-init_ram_condition(struct nvbios *bios, uint16_t offset,
-		   struct init_exec *iexec)
-{
-	/*
-	 * INIT_RAM_CONDITION   opcode: 0x6D ('m')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): mask
-	 * offset + 2  (8 bit): cmpval
-	 *
-	 * Test if (NV04_PFB_BOOT_0 & "mask") equals "cmpval".
-	 * If condition not met skip subsequent opcodes until condition is
-	 * inverted (INIT_NOT), or we hit INIT_RESUME
-	 */
-
-	uint8_t mask = bios->data[offset + 1];
-	uint8_t cmpval = bios->data[offset + 2];
-	uint8_t data;
-
-	if (!iexec->execute)
-		return 3;
-
-	data = bios_rd32(bios, NV04_PFB_BOOT_0) & mask;
-
-	BIOSLOG(bios, "0x%04X: Checking if 0x%08X equals 0x%08X\n",
-		offset, data, cmpval);
-
-	if (data == cmpval)
-		BIOSLOG(bios, "0x%04X: Condition fulfilled -- continuing to execute\n", offset);
-	else {
-		BIOSLOG(bios, "0x%04X: Condition not fulfilled -- skipping following commands\n", offset);
-		iexec->execute = false;
-	}
-
-	return 3;
-}
-
-static int
-init_nv_reg(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_NV_REG   opcode: 0x6E ('n')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): register
-	 * offset + 5  (32 bit): mask
-	 * offset + 9  (32 bit): data
-	 *
-	 * Assign ((REGVAL("register") & "mask") | "data") to "register"
-	 */
-
-	uint32_t reg = ROM32(bios->data[offset + 1]);
-	uint32_t mask = ROM32(bios->data[offset + 5]);
-	uint32_t data = ROM32(bios->data[offset + 9]);
-
-	if (!iexec->execute)
-		return 13;
-
-	BIOSLOG(bios, "0x%04X: Reg: 0x%08X, Mask: 0x%08X, Data: 0x%08X\n",
-		offset, reg, mask, data);
-
-	bios_wr32(bios, reg, (bios_rd32(bios, reg) & mask) | data);
-
-	return 13;
-}
-
-static int
-init_macro(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_MACRO   opcode: 0x6F ('o')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): macro number
-	 *
-	 * Look up macro index "macro number" in the macro index table.
-	 * The macro index table entry has 1 byte for the index in the macro
-	 * table, and 1 byte for the number of times to repeat the macro.
-	 * The macro table entry has 4 bytes for the register address and
-	 * 4 bytes for the value to write to that register
-	 */
-
-	uint8_t macro_index_tbl_idx = bios->data[offset + 1];
-	uint16_t tmp = bios->macro_index_tbl_ptr + (macro_index_tbl_idx * MACRO_INDEX_SIZE);
-	uint8_t macro_tbl_idx = bios->data[tmp];
-	uint8_t count = bios->data[tmp + 1];
-	uint32_t reg, data;
-	int i;
-
-	if (!iexec->execute)
-		return 2;
-
-	BIOSLOG(bios, "0x%04X: Macro: 0x%02X, MacroTableIndex: 0x%02X, "
-		      "Count: 0x%02X\n",
-		offset, macro_index_tbl_idx, macro_tbl_idx, count);
-
-	for (i = 0; i < count; i++) {
-		uint16_t macroentryptr = bios->macro_tbl_ptr + (macro_tbl_idx + i) * MACRO_SIZE;
-
-		reg = ROM32(bios->data[macroentryptr]);
-		data = ROM32(bios->data[macroentryptr + 4]);
-
-		bios_wr32(bios, reg, data);
-	}
-
-	return 2;
-}
-
-static int
-init_done(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_DONE   opcode: 0x71 ('q')
-	 *
-	 * offset      (8  bit): opcode
-	 *
-	 * End the current script
-	 */
-
-	/* mild retval abuse to stop parsing this table */
-	return 0;
-}
-
-static int
-init_resume(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_RESUME   opcode: 0x72 ('r')
-	 *
-	 * offset      (8  bit): opcode
-	 *
-	 * End the current execute / no-execute condition
-	 */
-
-	if (iexec->execute)
-		return 1;
-
-	iexec->execute = true;
-	BIOSLOG(bios, "0x%04X: ---- Executing following commands ----\n", offset);
-
-	return 1;
-}
-
-static int
-init_time(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_TIME   opcode: 0x74 ('t')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (16 bit): time
-	 *
-	 * Sleep for "time" microseconds.
-	 */
-
-	unsigned time = ROM16(bios->data[offset + 1]);
-
-	if (!iexec->execute)
-		return 3;
-
-	BIOSLOG(bios, "0x%04X: Sleeping for 0x%04X microseconds\n",
-		offset, time);
-
-	if (time < 1000)
-		udelay(time);
-	else
-		mdelay((time + 900) / 1000);
-
-	return 3;
-}
-
-static int
-init_condition(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_CONDITION   opcode: 0x75 ('u')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): condition number
-	 *
-	 * Check condition "condition number" in the condition table.
-	 * If condition not met skip subsequent opcodes until condition is
-	 * inverted (INIT_NOT), or we hit INIT_RESUME
-	 */
-
-	uint8_t cond = bios->data[offset + 1];
-
-	if (!iexec->execute)
-		return 2;
-
-	BIOSLOG(bios, "0x%04X: Condition: 0x%02X\n", offset, cond);
-
-	if (bios_condition_met(bios, offset, cond))
-		BIOSLOG(bios, "0x%04X: Condition fulfilled -- continuing to execute\n", offset);
-	else {
-		BIOSLOG(bios, "0x%04X: Condition not fulfilled -- skipping following commands\n", offset);
-		iexec->execute = false;
-	}
-
-	return 2;
-}
-
-static int
-init_io_condition(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_IO_CONDITION  opcode: 0x76
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): condition number
-	 *
-	 * Check condition "condition number" in the io condition table.
-	 * If condition not met skip subsequent opcodes until condition is
-	 * inverted (INIT_NOT), or we hit INIT_RESUME
-	 */
-
-	uint8_t cond = bios->data[offset + 1];
-
-	if (!iexec->execute)
-		return 2;
-
-	BIOSLOG(bios, "0x%04X: IO condition: 0x%02X\n", offset, cond);
-
-	if (io_condition_met(bios, offset, cond))
-		BIOSLOG(bios, "0x%04X: Condition fulfilled -- continuing to execute\n", offset);
-	else {
-		BIOSLOG(bios, "0x%04X: Condition not fulfilled -- skipping following commands\n", offset);
-		iexec->execute = false;
-	}
-
-	return 2;
-}
-
-static int
-init_index_io(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_INDEX_IO   opcode: 0x78 ('x')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (16 bit): CRTC port
-	 * offset + 3  (8  bit): CRTC index
-	 * offset + 4  (8  bit): mask
-	 * offset + 5  (8  bit): data
-	 *
-	 * Read value at index "CRTC index" on "CRTC port", AND with "mask",
-	 * OR with "data", write-back
-	 */
-
-	uint16_t crtcport = ROM16(bios->data[offset + 1]);
-	uint8_t crtcindex = bios->data[offset + 3];
-	uint8_t mask = bios->data[offset + 4];
-	uint8_t data = bios->data[offset + 5];
-	uint8_t value;
-
-	if (!iexec->execute)
-		return 6;
-
-	BIOSLOG(bios, "0x%04X: Port: 0x%04X, Index: 0x%02X, Mask: 0x%02X, "
-		      "Data: 0x%02X\n",
-		offset, crtcport, crtcindex, mask, data);
-
-	value = (bios_idxprt_rd(bios, crtcport, crtcindex) & mask) | data;
-	bios_idxprt_wr(bios, crtcport, crtcindex, value);
-
-	return 6;
-}
-
-static int
-init_pll(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_PLL   opcode: 0x79 ('y')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): register
-	 * offset + 5  (16 bit): freq
-	 *
-	 * Set PLL register "register" to coefficients for frequency (10kHz)
-	 * "freq"
-	 */
-
-	uint32_t reg = ROM32(bios->data[offset + 1]);
-	uint16_t freq = ROM16(bios->data[offset + 5]);
-
-	if (!iexec->execute)
-		return 7;
-
-	BIOSLOG(bios, "0x%04X: Reg: 0x%08X, Freq: %d0kHz\n", offset, reg, freq);
-
-	setPLL(bios->dev, reg, freq * 10);
-
-	return 7;
-}
-
-static int
-init_zm_reg(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_ZM_REG   opcode: 0x7A ('z')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): register
-	 * offset + 5  (32 bit): value
-	 *
-	 * Assign "value" to "register"
-	 */
-
-	uint32_t reg = ROM32(bios->data[offset + 1]);
-	uint32_t value = ROM32(bios->data[offset + 5]);
-
-	if (!iexec->execute)
-		return 9;
-
-	if (reg == 0x000200)
-		value |= 1;
-
-	bios_wr32(bios, reg, value);
-
-	return 9;
-}
-
-static int
-init_ram_restrict_pll(struct nvbios *bios, uint16_t offset,
-		      struct init_exec *iexec)
-{
-	/*
-	 * INIT_RAM_RESTRICT_PLL   opcode: 0x87 ('')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): PLL type
-	 * offset + 2 (32 bit): frequency 0
-	 *
-	 * Uses the RAMCFG strap of PEXTDEV_BOOT as an index into the table at
-	 * ram_restrict_table_ptr.  The value read from there is used to select
-	 * a frequency from the table starting at 'frequency 0' to be
-	 * programmed into the PLL corresponding to 'type'.
-	 *
-	 * The PLL limits table on cards using this opcode has a mapping of
-	 * 'type' to the relevant registers.
-	 */
-
-	struct drm_device *dev = bios->dev;
-	uint32_t strap = (bios_rd32(bios, NV_PEXTDEV_BOOT_0) & 0x0000003c) >> 2;
-	uint8_t index = bios->data[bios->ram_restrict_tbl_ptr + strap];
-	uint8_t type = bios->data[offset + 1];
-	uint32_t freq = ROM32(bios->data[offset + 2 + (index * 4)]);
-	uint8_t *pll_limits = &bios->data[bios->pll_limit_tbl_ptr], *entry;
-	int len = 2 + bios->ram_restrict_group_count * 4;
-	int i;
-
-	if (!iexec->execute)
-		return len;
-
-	if (!bios->pll_limit_tbl_ptr || (pll_limits[0] & 0xf0) != 0x30) {
-		NV_ERROR(dev, "PLL limits table not version 3.x\n");
-		return len; /* deliberate, allow default clocks to remain */
-	}
-
-	entry = pll_limits + pll_limits[1];
-	for (i = 0; i < pll_limits[3]; i++, entry += pll_limits[2]) {
-		if (entry[0] == type) {
-			uint32_t reg = ROM32(entry[3]);
-
-			BIOSLOG(bios, "0x%04X: "
-				      "Type %02x Reg 0x%08x Freq %dKHz\n",
-				offset, type, reg, freq);
-
-			setPLL(bios->dev, reg, freq);
-			return len;
-		}
-	}
-
-	NV_ERROR(dev, "PLL type 0x%02x not found in PLL limits table", type);
-	return len;
-}
-
-static int
-init_8c(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_8C   opcode: 0x8C ('')
-	 *
-	 * NOP so far....
-	 *
-	 */
-
-	return 1;
-}
-
-static int
-init_8d(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_8D   opcode: 0x8D ('')
-	 *
-	 * NOP so far....
-	 *
-	 */
-
-	return 1;
-}
-
-static int
-init_gpio(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_GPIO   opcode: 0x8E ('')
-	 *
-	 * offset      (8 bit): opcode
-	 *
-	 * Loop over all entries in the DCB GPIO table, and initialise
-	 * each GPIO according to various values listed in each entry
-	 */
-
-	if (iexec->execute && bios->execute)
-		nouveau_gpio_reset(bios->dev);
-
-	return 1;
-}
-
-static int
-init_ram_restrict_zm_reg_group(struct nvbios *bios, uint16_t offset,
-			       struct init_exec *iexec)
-{
-	/*
-	 * INIT_RAM_RESTRICT_ZM_REG_GROUP   opcode: 0x8F ('')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): reg
-	 * offset + 5  (8  bit): regincrement
-	 * offset + 6  (8  bit): count
-	 * offset + 7  (32 bit): value 1,1
-	 * ...
-	 *
-	 * Use the RAMCFG strap of PEXTDEV_BOOT as an index into the table at
-	 * ram_restrict_table_ptr. The value read from here is 'n', and
-	 * "value 1,n" gets written to "reg". This repeats "count" times and on
-	 * each iteration 'm', "reg" increases by "regincrement" and
-	 * "value m,n" is used. The extent of n is limited by a number read
-	 * from the 'M' BIT table, herein called "blocklen"
-	 */
-
-	uint32_t reg = ROM32(bios->data[offset + 1]);
-	uint8_t regincrement = bios->data[offset + 5];
-	uint8_t count = bios->data[offset + 6];
-	uint32_t strap_ramcfg, data;
-	/* previously set by 'M' BIT table */
-	uint16_t blocklen = bios->ram_restrict_group_count * 4;
-	int len = 7 + count * blocklen;
-	uint8_t index;
-	int i;
-
-	/* critical! to know the length of the opcode */;
-	if (!blocklen) {
-		NV_ERROR(bios->dev,
-			 "0x%04X: Zero block length - has the M table "
-			 "been parsed?\n", offset);
-		return -EINVAL;
-	}
-
-	if (!iexec->execute)
-		return len;
-
-	strap_ramcfg = (bios_rd32(bios, NV_PEXTDEV_BOOT_0) >> 2) & 0xf;
-	index = bios->data[bios->ram_restrict_tbl_ptr + strap_ramcfg];
-
-	BIOSLOG(bios, "0x%04X: Reg: 0x%08X, RegIncrement: 0x%02X, "
-		      "Count: 0x%02X, StrapRamCfg: 0x%02X, Index: 0x%02X\n",
-		offset, reg, regincrement, count, strap_ramcfg, index);
-
-	for (i = 0; i < count; i++) {
-		data = ROM32(bios->data[offset + 7 + index * 4 + blocklen * i]);
-
-		bios_wr32(bios, reg, data);
-
-		reg += regincrement;
-	}
-
-	return len;
-}
-
-static int
-init_copy_zm_reg(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_COPY_ZM_REG   opcode: 0x90 ('')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): src reg
-	 * offset + 5  (32 bit): dst reg
-	 *
-	 * Put contents of "src reg" into "dst reg"
-	 */
-
-	uint32_t srcreg = ROM32(bios->data[offset + 1]);
-	uint32_t dstreg = ROM32(bios->data[offset + 5]);
-
-	if (!iexec->execute)
-		return 9;
-
-	bios_wr32(bios, dstreg, bios_rd32(bios, srcreg));
-
-	return 9;
-}
-
-static int
-init_zm_reg_group_addr_latched(struct nvbios *bios, uint16_t offset,
-			       struct init_exec *iexec)
-{
-	/*
-	 * INIT_ZM_REG_GROUP_ADDRESS_LATCHED   opcode: 0x91 ('')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): dst reg
-	 * offset + 5  (8  bit): count
-	 * offset + 6  (32 bit): data 1
-	 * ...
-	 *
-	 * For each of "count" values write "data n" to "dst reg"
-	 */
-
-	uint32_t reg = ROM32(bios->data[offset + 1]);
-	uint8_t count = bios->data[offset + 5];
-	int len = 6 + count * 4;
-	int i;
-
-	if (!iexec->execute)
-		return len;
-
-	for (i = 0; i < count; i++) {
-		uint32_t data = ROM32(bios->data[offset + 6 + 4 * i]);
-		bios_wr32(bios, reg, data);
-	}
-
-	return len;
-}
-
-static int
-init_reserved(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_RESERVED   opcode: 0x92 ('')
-	 *
-	 * offset      (8 bit): opcode
-	 *
-	 * Seemingly does nothing
-	 */
-
-	return 1;
-}
-
-static int
-init_96(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_96   opcode: 0x96 ('')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): sreg
-	 * offset + 5  (8  bit): sshift
-	 * offset + 6  (8  bit): smask
-	 * offset + 7  (8  bit): index
-	 * offset + 8  (32 bit): reg
-	 * offset + 12 (32 bit): mask
-	 * offset + 16 (8  bit): shift
-	 *
-	 */
-
-	uint16_t xlatptr = bios->init96_tbl_ptr + (bios->data[offset + 7] * 2);
-	uint32_t reg = ROM32(bios->data[offset + 8]);
-	uint32_t mask = ROM32(bios->data[offset + 12]);
-	uint32_t val;
-
-	val = bios_rd32(bios, ROM32(bios->data[offset + 1]));
-	if (bios->data[offset + 5] < 0x80)
-		val >>= bios->data[offset + 5];
-	else
-		val <<= (0x100 - bios->data[offset + 5]);
-	val &= bios->data[offset + 6];
-
-	val   = bios->data[ROM16(bios->data[xlatptr]) + val];
-	val <<= bios->data[offset + 16];
-
-	if (!iexec->execute)
-		return 17;
-
-	bios_wr32(bios, reg, (bios_rd32(bios, reg) & mask) | val);
-	return 17;
-}
-
-static int
-init_97(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_97   opcode: 0x97 ('')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): register
-	 * offset + 5  (32 bit): mask
-	 * offset + 9  (32 bit): value
-	 *
-	 * Adds "value" to "register" preserving the fields specified
-	 * by "mask"
-	 */
-
-	uint32_t reg = ROM32(bios->data[offset + 1]);
-	uint32_t mask = ROM32(bios->data[offset + 5]);
-	uint32_t add = ROM32(bios->data[offset + 9]);
-	uint32_t val;
-
-	val = bios_rd32(bios, reg);
-	val = (val & mask) | ((val + add) & ~mask);
-
-	if (!iexec->execute)
-		return 13;
-
-	bios_wr32(bios, reg, val);
-	return 13;
-}
-
-static int
-init_auxch(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_AUXCH   opcode: 0x98 ('')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): address
-	 * offset + 5  (8  bit): count
-	 * offset + 6  (8  bit): mask 0
-	 * offset + 7  (8  bit): data 0
-	 *  ...
-	 *
-	 */
-
-	struct drm_device *dev = bios->dev;
-	struct nouveau_i2c_port *auxch;
-	uint32_t addr = ROM32(bios->data[offset + 1]);
-	uint8_t count = bios->data[offset + 5];
-	int len = 6 + count * 2;
-	int ret, i;
-
-	if (!bios->display.output) {
-		NV_ERROR(dev, "INIT_AUXCH: no active output\n");
-		return len;
-	}
-
-	auxch = init_i2c_device_find(dev, bios->display.output->i2c_index);
-	if (!auxch) {
-		NV_ERROR(dev, "INIT_AUXCH: couldn't get auxch %d\n",
-			 bios->display.output->i2c_index);
-		return len;
-	}
-
-	if (!iexec->execute)
-		return len;
-
-	offset += 6;
-	for (i = 0; i < count; i++, offset += 2) {
-		uint8_t data;
-
-		ret = auxch_rd(dev, auxch, addr, &data, 1);
-		if (ret) {
-			NV_ERROR(dev, "INIT_AUXCH: rd auxch fail %d\n", ret);
-			return len;
-		}
-
-		data &= bios->data[offset + 0];
-		data |= bios->data[offset + 1];
-
-		ret = auxch_wr(dev, auxch, addr, &data, 1);
-		if (ret) {
-			NV_ERROR(dev, "INIT_AUXCH: wr auxch fail %d\n", ret);
-			return len;
-		}
-	}
-
-	return len;
-}
-
-static int
-init_zm_auxch(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_ZM_AUXCH   opcode: 0x99 ('')
-	 *
-	 * offset      (8  bit): opcode
-	 * offset + 1  (32 bit): address
-	 * offset + 5  (8  bit): count
-	 * offset + 6  (8  bit): data 0
-	 *  ...
-	 *
-	 */
-
-	struct drm_device *dev = bios->dev;
-	struct nouveau_i2c_port *auxch;
-	uint32_t addr = ROM32(bios->data[offset + 1]);
-	uint8_t count = bios->data[offset + 5];
-	int len = 6 + count;
-	int ret, i;
-
-	if (!bios->display.output) {
-		NV_ERROR(dev, "INIT_ZM_AUXCH: no active output\n");
-		return len;
-	}
-
-	auxch = init_i2c_device_find(dev, bios->display.output->i2c_index);
-	if (!auxch) {
-		NV_ERROR(dev, "INIT_ZM_AUXCH: couldn't get auxch %d\n",
-			 bios->display.output->i2c_index);
-		return len;
-	}
-
-	if (!iexec->execute)
-		return len;
-
-	offset += 6;
-	for (i = 0; i < count; i++, offset++) {
-		ret = auxch_wr(dev, auxch, addr, &bios->data[offset], 1);
-		if (ret) {
-			NV_ERROR(dev, "INIT_ZM_AUXCH: wr auxch fail %d\n", ret);
-			return len;
-		}
-	}
-
-	return len;
-}
-
-static int
-init_i2c_long_if(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * INIT_I2C_LONG_IF   opcode: 0x9A ('')
-	 *
-	 * offset      (8 bit): opcode
-	 * offset + 1  (8 bit): DCB I2C table entry index
-	 * offset + 2  (8 bit): I2C slave address
-	 * offset + 3  (16 bit): I2C register
-	 * offset + 5  (8 bit): mask
-	 * offset + 6  (8 bit): data
-	 *
-	 * Read the register given by "I2C register" on the device addressed
-	 * by "I2C slave address" on the I2C bus given by "DCB I2C table
-	 * entry index". Compare the result AND "mask" to "data".
-	 * If they're not equal, skip subsequent opcodes until condition is
-	 * inverted (INIT_NOT), or we hit INIT_RESUME
-	 */
-
-	uint8_t i2c_index = bios->data[offset + 1];
-	uint8_t i2c_address = bios->data[offset + 2] >> 1;
-	uint8_t reglo = bios->data[offset + 3];
-	uint8_t reghi = bios->data[offset + 4];
-	uint8_t mask = bios->data[offset + 5];
-	uint8_t data = bios->data[offset + 6];
-	struct nouveau_i2c_port *chan;
-	uint8_t buf0[2] = { reghi, reglo };
-	uint8_t buf1[1];
-	struct i2c_msg msg[2] = {
-		{ i2c_address, 0, 1, buf0 },
-		{ i2c_address, I2C_M_RD, 1, buf1 },
-	};
-	int ret;
-
-	/* no execute check by design */
-
-	BIOSLOG(bios, "0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X\n",
-		offset, i2c_index, i2c_address);
-
-	chan = init_i2c_device_find(bios->dev, i2c_index);
-	if (!chan)
-		return -ENODEV;
-
-
-	ret = i2c_transfer(nouveau_i2c_adapter(chan), msg, 2);
-	if (ret < 0) {
-		BIOSLOG(bios, "0x%04X: I2CReg: 0x%02X:0x%02X, Value: [no device], "
-			      "Mask: 0x%02X, Data: 0x%02X\n",
-			offset, reghi, reglo, mask, data);
-		iexec->execute = 0;
-		return 7;
-	}
-
-	BIOSLOG(bios, "0x%04X: I2CReg: 0x%02X:0x%02X, Value: 0x%02X, "
-		      "Mask: 0x%02X, Data: 0x%02X\n",
-		offset, reghi, reglo, buf1[0], mask, data);
-
-	iexec->execute = ((buf1[0] & mask) == data);
-
-	return 7;
-}
-
-static struct init_tbl_entry itbl_entry[] = {
-	/* command name                       , id  , length  , offset  , mult    , command handler                 */
-	/* INIT_PROG (0x31, 15, 10, 4) removed due to no example of use */
-	{ "INIT_IO_RESTRICT_PROG"             , 0x32, init_io_restrict_prog           },
-	{ "INIT_REPEAT"                       , 0x33, init_repeat                     },
-	{ "INIT_IO_RESTRICT_PLL"              , 0x34, init_io_restrict_pll            },
-	{ "INIT_END_REPEAT"                   , 0x36, init_end_repeat                 },
-	{ "INIT_COPY"                         , 0x37, init_copy                       },
-	{ "INIT_NOT"                          , 0x38, init_not                        },
-	{ "INIT_IO_FLAG_CONDITION"            , 0x39, init_io_flag_condition          },
-	{ "INIT_DP_CONDITION"                 , 0x3A, init_dp_condition               },
-	{ "INIT_OP_3B"                        , 0x3B, init_op_3b                      },
-	{ "INIT_OP_3C"                        , 0x3C, init_op_3c                      },
-	{ "INIT_INDEX_ADDRESS_LATCHED"        , 0x49, init_idx_addr_latched           },
-	{ "INIT_IO_RESTRICT_PLL2"             , 0x4A, init_io_restrict_pll2           },
-	{ "INIT_PLL2"                         , 0x4B, init_pll2                       },
-	{ "INIT_I2C_BYTE"                     , 0x4C, init_i2c_byte                   },
-	{ "INIT_ZM_I2C_BYTE"                  , 0x4D, init_zm_i2c_byte                },
-	{ "INIT_ZM_I2C"                       , 0x4E, init_zm_i2c                     },
-	{ "INIT_TMDS"                         , 0x4F, init_tmds                       },
-	{ "INIT_ZM_TMDS_GROUP"                , 0x50, init_zm_tmds_group              },
-	{ "INIT_CR_INDEX_ADDRESS_LATCHED"     , 0x51, init_cr_idx_adr_latch           },
-	{ "INIT_CR"                           , 0x52, init_cr                         },
-	{ "INIT_ZM_CR"                        , 0x53, init_zm_cr                      },
-	{ "INIT_ZM_CR_GROUP"                  , 0x54, init_zm_cr_group                },
-	{ "INIT_CONDITION_TIME"               , 0x56, init_condition_time             },
-	{ "INIT_LTIME"                        , 0x57, init_ltime                      },
-	{ "INIT_ZM_REG_SEQUENCE"              , 0x58, init_zm_reg_sequence            },
-	/* INIT_INDIRECT_REG (0x5A, 7, 0, 0) removed due to no example of use */
-	{ "INIT_SUB_DIRECT"                   , 0x5B, init_sub_direct                 },
-	{ "INIT_JUMP"                         , 0x5C, init_jump                       },
-	{ "INIT_I2C_IF"                       , 0x5E, init_i2c_if                     },
-	{ "INIT_COPY_NV_REG"                  , 0x5F, init_copy_nv_reg                },
-	{ "INIT_ZM_INDEX_IO"                  , 0x62, init_zm_index_io                },
-	{ "INIT_COMPUTE_MEM"                  , 0x63, init_compute_mem                },
-	{ "INIT_RESET"                        , 0x65, init_reset                      },
-	{ "INIT_CONFIGURE_MEM"                , 0x66, init_configure_mem              },
-	{ "INIT_CONFIGURE_CLK"                , 0x67, init_configure_clk              },
-	{ "INIT_CONFIGURE_PREINIT"            , 0x68, init_configure_preinit          },
-	{ "INIT_IO"                           , 0x69, init_io                         },
-	{ "INIT_SUB"                          , 0x6B, init_sub                        },
-	{ "INIT_RAM_CONDITION"                , 0x6D, init_ram_condition              },
-	{ "INIT_NV_REG"                       , 0x6E, init_nv_reg                     },
-	{ "INIT_MACRO"                        , 0x6F, init_macro                      },
-	{ "INIT_DONE"                         , 0x71, init_done                       },
-	{ "INIT_RESUME"                       , 0x72, init_resume                     },
-	/* INIT_RAM_CONDITION2 (0x73, 9, 0, 0) removed due to no example of use */
-	{ "INIT_TIME"                         , 0x74, init_time                       },
-	{ "INIT_CONDITION"                    , 0x75, init_condition                  },
-	{ "INIT_IO_CONDITION"                 , 0x76, init_io_condition               },
-	{ "INIT_INDEX_IO"                     , 0x78, init_index_io                   },
-	{ "INIT_PLL"                          , 0x79, init_pll                        },
-	{ "INIT_ZM_REG"                       , 0x7A, init_zm_reg                     },
-	{ "INIT_RAM_RESTRICT_PLL"             , 0x87, init_ram_restrict_pll           },
-	{ "INIT_8C"                           , 0x8C, init_8c                         },
-	{ "INIT_8D"                           , 0x8D, init_8d                         },
-	{ "INIT_GPIO"                         , 0x8E, init_gpio                       },
-	{ "INIT_RAM_RESTRICT_ZM_REG_GROUP"    , 0x8F, init_ram_restrict_zm_reg_group  },
-	{ "INIT_COPY_ZM_REG"                  , 0x90, init_copy_zm_reg                },
-	{ "INIT_ZM_REG_GROUP_ADDRESS_LATCHED" , 0x91, init_zm_reg_group_addr_latched  },
-	{ "INIT_RESERVED"                     , 0x92, init_reserved                   },
-	{ "INIT_96"                           , 0x96, init_96                         },
-	{ "INIT_97"                           , 0x97, init_97                         },
-	{ "INIT_AUXCH"                        , 0x98, init_auxch                      },
-	{ "INIT_ZM_AUXCH"                     , 0x99, init_zm_auxch                   },
-	{ "INIT_I2C_LONG_IF"                  , 0x9A, init_i2c_long_if                },
-	{ NULL                                , 0   , NULL                            }
-};
-
-#define MAX_TABLE_OPS 1000
-
-static int
-parse_init_table(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
-{
-	/*
-	 * Parses all commands in an init table.
-	 *
-	 * We start out executing all commands found in the init table. Some
-	 * opcodes may change the status of iexec->execute to SKIP, which will
-	 * cause the following opcodes to perform no operation until the value
-	 * is changed back to EXECUTE.
-	 */
-
-	int count = 0, i, ret;
-	uint8_t id;
-
-	/* catch NULL script pointers */
-	if (offset == 0)
-		return 0;
-
-	/*
-	 * Loop until INIT_DONE causes us to break out of the loop
-	 * (or until offset > bios length just in case... )
-	 * (and no more than MAX_TABLE_OPS iterations, just in case... )
-	 */
-	while ((offset < bios->length) && (count++ < MAX_TABLE_OPS)) {
-		id = bios->data[offset];
-
-		/* Find matching id in itbl_entry */
-		for (i = 0; itbl_entry[i].name && (itbl_entry[i].id != id); i++)
-			;
-
-		if (!itbl_entry[i].name) {
-			NV_ERROR(bios->dev,
-				 "0x%04X: Init table command not found: "
-				 "0x%02X\n", offset, id);
-			return -ENOENT;
-		}
-
-		BIOSLOG(bios, "0x%04X: [ (0x%02X) - %s ]\n", offset,
-			itbl_entry[i].id, itbl_entry[i].name);
-
-		/* execute eventual command handler */
-		ret = (*itbl_entry[i].handler)(bios, offset, iexec);
-		if (ret < 0) {
-			NV_ERROR(bios->dev, "0x%04X: Failed parsing init "
-				 "table opcode: %s %d\n", offset,
-				 itbl_entry[i].name, ret);
-		}
-
-		if (ret <= 0)
-			break;
-
-		/*
-		 * Add the offset of the current command including all data
-		 * of that command. The offset will then be pointing on the
-		 * next op code.
-		 */
-		offset += ret;
-	}
-
-	if (offset >= bios->length)
-		NV_WARN(bios->dev,
-			"Offset 0x%04X greater than known bios image length.  "
-			"Corrupt image?\n", offset);
-	if (count >= MAX_TABLE_OPS)
-		NV_WARN(bios->dev,
-			"More than %d opcodes to a table is unlikely, "
-			"is the bios image corrupt?\n", MAX_TABLE_OPS);
-
-	return 0;
-}
-
-static void
-parse_init_tables(struct nvbios *bios)
-{
-	/* Loops and calls parse_init_table() for each present table. */
-
-	int i = 0;
-	uint16_t table;
-	struct init_exec iexec = {true, false};
-
-	if (bios->old_style_init) {
-		if (bios->init_script_tbls_ptr)
-			parse_init_table(bios, bios->init_script_tbls_ptr, &iexec);
-		if (bios->extra_init_script_tbl_ptr)
-			parse_init_table(bios, bios->extra_init_script_tbl_ptr, &iexec);
-
-		return;
-	}
-
-	while ((table = ROM16(bios->data[bios->init_script_tbls_ptr + i]))) {
-		NV_INFO(bios->dev,
-			"Parsing VBIOS init table %d at offset 0x%04X\n",
-			i / 2, table);
-		BIOSLOG(bios, "0x%04X: ------ Executing following commands ------\n", table);
-
-		parse_init_table(bios, table, &iexec);
-		i += 2;
-	}
-}
-
 static uint16_t clkcmptable(struct nvbios *bios, uint16_t clktable, int pxclk)
 {
 	int compare_record_len, i = 0;
@@ -3458,28 +92,22 @@ static uint16_t clkcmptable(struct nvbio
 
 static void
 run_digital_op_script(struct drm_device *dev, uint16_t scriptptr,
-		      struct dcb_entry *dcbent, int head, bool dl)
+		      struct dcb_output *dcbent, int head, bool dl)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nvbios *bios = &dev_priv->vbios;
-	struct init_exec iexec = {true, false};
-
 	NV_TRACE(dev, "0x%04X: Parsing digital output script table\n",
 		 scriptptr);
-	bios_idxprt_wr(bios, NV_CIO_CRX__COLOR, NV_CIO_CRE_44,
-		       head ? NV_CIO_CRE_44_HEADB : NV_CIO_CRE_44_HEADA);
-	/* note: if dcb entries have been merged, index may be misleading */
-	NVWriteVgaCrtc5758(dev, head, 0, dcbent->index);
-	parse_init_table(bios, scriptptr, &iexec);
+	NVWriteVgaCrtc(dev, 0, NV_CIO_CRE_44, head ? NV_CIO_CRE_44_HEADB :
+					         NV_CIO_CRE_44_HEADA);
+	nouveau_bios_run_init_table(dev, scriptptr, dcbent, head);
 
 	nv04_dfp_bind_head(dev, dcbent, head, dl);
 }
 
-static int call_lvds_manufacturer_script(struct drm_device *dev, struct dcb_entry *dcbent, int head, enum LVDS_script script)
+static int call_lvds_manufacturer_script(struct drm_device *dev, struct dcb_output *dcbent, int head, enum LVDS_script script)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nvbios *bios = &dev_priv->vbios;
-	uint8_t sub = bios->data[bios->fp.xlated_entry + script] + (bios->fp.link_c_increment && dcbent->or & OUTPUT_C ? 1 : 0);
+	uint8_t sub = bios->data[bios->fp.xlated_entry + script] + (bios->fp.link_c_increment && dcbent->or & DCB_OUTPUT_C ? 1 : 0);
 	uint16_t scriptofs = ROM16(bios->data[bios->init_script_tbls_ptr + sub * 2]);
 
 	if (!bios->fp.xlated_entry || !sub || !scriptofs)
@@ -3502,7 +130,7 @@ static int call_lvds_manufacturer_script
 	return 0;
 }
 
-static int run_lvds_table(struct drm_device *dev, struct dcb_entry *dcbent, int head, enum LVDS_script script, int pxclk)
+static int run_lvds_table(struct drm_device *dev, struct dcb_output *dcbent, int head, enum LVDS_script script, int pxclk)
 {
 	/*
 	 * The BIT LVDS table's header has the information to setup the
@@ -3575,7 +203,7 @@ static int run_lvds_table(struct drm_dev
 	return 0;
 }
 
-int call_lvds_script(struct drm_device *dev, struct dcb_entry *dcbent, int head, enum LVDS_script script, int pxclk)
+int call_lvds_script(struct drm_device *dev, struct dcb_output *dcbent, int head, enum LVDS_script script, int pxclk)
 {
 	/*
 	 * LVDS operations are multiplexed in an effort to present a single API
@@ -3606,7 +234,7 @@ int call_lvds_script(struct drm_device *
 	NV_TRACE(dev, "Calling LVDS script %d:\n", script);
 
 	/* don't let script change pll->head binding */
-	sel_clk_binding = bios_rd32(bios, NV_PRAMDAC_SEL_CLK) & 0x50000;
+	sel_clk_binding = nv_rd32(dev, NV_PRAMDAC_SEL_CLK) & 0x50000;
 
 	if (lvds_ver < 0x30)
 		ret = call_lvds_manufacturer_script(dev, dcbent, head, script);
@@ -3700,9 +328,9 @@ get_fp_strap(struct drm_device *dev, str
 		return NVReadVgaCrtc5758(dev, 0, 0xf) & 0xf;
 
 	if (dev_priv->card_type >= NV_50)
-		return (bios_rd32(bios, NV_PEXTDEV_BOOT_0) >> 24) & 0xf;
+		return (nv_rd32(dev, NV_PEXTDEV_BOOT_0) >> 24) & 0xf;
 	else
-		return (bios_rd32(bios, NV_PEXTDEV_BOOT_0) >> 16) & 0xf;
+		return (nv_rd32(dev, NV_PEXTDEV_BOOT_0) >> 16) & 0xf;
 }
 
 static int parse_fp_mode_table(struct drm_device *dev, struct nvbios *bios)
@@ -3994,7 +622,7 @@ int nouveau_bios_parse_lvds_table(struct
  * This function returns true if a particular DCB entry matches.
  */
 bool
-bios_encoder_match(struct dcb_entry *dcb, u32 hash)
+bios_encoder_match(struct dcb_output *dcb, u32 hash)
 {
 	if ((hash & 0x000000f0) != (dcb->location << 4))
 		return false;
@@ -4004,9 +632,9 @@ bios_encoder_match(struct dcb_entry *dcb
 		return false;
 
 	switch (dcb->type) {
-	case OUTPUT_TMDS:
-	case OUTPUT_LVDS:
-	case OUTPUT_DP:
+	case DCB_OUTPUT_TMDS:
+	case DCB_OUTPUT_LVDS:
+	case DCB_OUTPUT_DP:
 		if (hash & 0x00c00000) {
 			if (!(hash & (dcb->sorconf.link << 22)))
 				return false;
@@ -4018,7 +646,7 @@ bios_encoder_match(struct dcb_entry *dcb
 
 int
 nouveau_bios_run_display_table(struct drm_device *dev, u16 type, int pclk,
-			       struct dcb_entry *dcbent, int crtc)
+			       struct dcb_output *dcbent, int crtc)
 {
 	/*
 	 * The display script table is located by the BIT 'U' table.
@@ -4188,7 +816,7 @@ nouveau_bios_run_display_table(struct dr
 }
 
 
-int run_tmds_table(struct drm_device *dev, struct dcb_entry *dcbent, int head, int pxclk)
+int run_tmds_table(struct drm_device *dev, struct dcb_output *dcbent, int head, int pxclk)
 {
 	/*
 	 * the pxclk parameter is in kHz
@@ -4233,7 +861,7 @@ int run_tmds_table(struct drm_device *de
 	}
 
 	/* don't let script change pll->head binding */
-	sel_clk_binding = bios_rd32(bios, NV_PRAMDAC_SEL_CLK) & 0x50000;
+	sel_clk_binding = nv_rd32(dev, NV_PRAMDAC_SEL_CLK) & 0x50000;
 	run_digital_op_script(dev, scriptptr, dcbent, head, pxclk >= 165000);
 	sel_clk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK) & ~0x50000;
 	NVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, sel_clk | sel_clk_binding);
@@ -4967,9 +1595,9 @@ olddcb_outp_foreach(struct drm_device *d
 		if (ROM32(outp[0]) == 0xffffffff)
 			break; /* seen on an NV17 with DCB v2.0 */
 
-		if ((outp[0] & 0x0f) == OUTPUT_UNUSED)
+		if ((outp[0] & 0x0f) == DCB_OUTPUT_UNUSED)
 			continue;
-		if ((outp[0] & 0x0f) == OUTPUT_EOL)
+		if ((outp[0] & 0x0f) == DCB_OUTPUT_EOL)
 			break;
 
 		ret = exec(dev, data, idx, outp);
@@ -4981,7 +1609,7 @@ olddcb_outp_foreach(struct drm_device *d
 }
 
 u8 *
-dcb_conntab(struct drm_device *dev)
+olddcb_conntab(struct drm_device *dev)
 {
 	u8 *dcb = olddcb_table(dev);
 	if (dcb && dcb[0] >= 0x30 && dcb[1] >= 0x16) {
@@ -4993,19 +1621,19 @@ dcb_conntab(struct drm_device *dev)
 }
 
 u8 *
-dcb_conn(struct drm_device *dev, u8 idx)
+olddcb_conn(struct drm_device *dev, u8 idx)
 {
-	u8 *conntab = dcb_conntab(dev);
+	u8 *conntab = olddcb_conntab(dev);
 	if (conntab && idx < conntab[2])
 		return conntab + conntab[1] + (idx * conntab[3]);
 	return NULL;
 }
 
-static struct dcb_entry *new_dcb_entry(struct dcb_table *dcb)
+static struct dcb_output *new_dcb_entry(struct dcb_table *dcb)
 {
-	struct dcb_entry *entry = &dcb->entry[dcb->entries];
+	struct dcb_output *entry = &dcb->entry[dcb->entries];
 
-	memset(entry, 0, sizeof(struct dcb_entry));
+	memset(entry, 0, sizeof(struct dcb_output));
 	entry->index = dcb->entries++;
 
 	return entry;
@@ -5014,19 +1642,19 @@ static struct dcb_entry *new_dcb_entry(s
 static void fabricate_dcb_output(struct dcb_table *dcb, int type, int i2c,
 				 int heads, int or)
 {
-	struct dcb_entry *entry = new_dcb_entry(dcb);
+	struct dcb_output *entry = new_dcb_entry(dcb);
 
 	entry->type = type;
 	entry->i2c_index = i2c;
 	entry->heads = heads;
-	if (type != OUTPUT_ANALOG)
+	if (type != DCB_OUTPUT_ANALOG)
 		entry->location = !DCB_LOC_ON_CHIP; /* ie OFF CHIP */
 	entry->or = or;
 }
 
 static bool
 parse_dcb20_entry(struct drm_device *dev, struct dcb_table *dcb,
-		  uint32_t conn, uint32_t conf, struct dcb_entry *entry)
+		  uint32_t conn, uint32_t conf, struct dcb_output *entry)
 {
 	entry->type = conn & 0xf;
 	entry->i2c_index = (conn >> 4) & 0xf;
@@ -5037,7 +1665,7 @@ parse_dcb20_entry(struct drm_device *dev
 	entry->or = (conn >> 24) & 0xf;
 
 	switch (entry->type) {
-	case OUTPUT_ANALOG:
+	case DCB_OUTPUT_ANALOG:
 		/*
 		 * Although the rest of a CRT conf dword is usually
 		 * zeros, mac biosen have stuff there so we must mask
@@ -5046,7 +1674,7 @@ parse_dcb20_entry(struct drm_device *dev
 					 (conf & 0xffff) * 10 :
 					 (conf & 0xff) * 10000;
 		break;
-	case OUTPUT_LVDS:
+	case DCB_OUTPUT_LVDS:
 		{
 		uint32_t mask;
 		if (conf & 0x1)
@@ -5086,7 +1714,7 @@ parse_dcb20_entry(struct drm_device *dev
 		}
 		break;
 		}
-	case OUTPUT_TV:
+	case DCB_OUTPUT_TV:
 	{
 		if (dcb->version >= 0x30)
 			entry->tvconf.has_component_output = conf & (0x8 << 4);
@@ -5095,7 +1723,7 @@ parse_dcb20_entry(struct drm_device *dev
 
 		break;
 	}
-	case OUTPUT_DP:
+	case DCB_OUTPUT_DP:
 		entry->dpconf.sor.link = (conf & 0x00000030) >> 4;
 		switch ((conf & 0x00e00000) >> 21) {
 		case 0:
@@ -5117,7 +1745,7 @@ parse_dcb20_entry(struct drm_device *dev
 			break;
 		}
 		break;
-	case OUTPUT_TMDS:
+	case DCB_OUTPUT_TMDS:
 		if (dcb->version >= 0x40)
 			entry->tmdsconf.sor.link = (conf & 0x00000030) >> 4;
 		else if (dcb->version >= 0x30)
@@ -5126,7 +1754,7 @@ parse_dcb20_entry(struct drm_device *dev
 			entry->tmdsconf.slave_addr = (conf & 0x00000070) >> 4;
 
 		break;
-	case OUTPUT_EOL:
+	case DCB_OUTPUT_EOL:
 		/* weird g80 mobile type that "nv" treats as a terminator */
 		dcb->entries--;
 		return false;
@@ -5153,24 +1781,24 @@ parse_dcb20_entry(struct drm_device *dev
 
 static bool
 parse_dcb15_entry(struct drm_device *dev, struct dcb_table *dcb,
-		  uint32_t conn, uint32_t conf, struct dcb_entry *entry)
+		  uint32_t conn, uint32_t conf, struct dcb_output *entry)
 {
 	switch (conn & 0x0000000f) {
 	case 0:
-		entry->type = OUTPUT_ANALOG;
+		entry->type = DCB_OUTPUT_ANALOG;
 		break;
 	case 1:
-		entry->type = OUTPUT_TV;
+		entry->type = DCB_OUTPUT_TV;
 		break;
 	case 2:
 	case 4:
 		if (conn & 0x10)
-			entry->type = OUTPUT_LVDS;
+			entry->type = DCB_OUTPUT_LVDS;
 		else
-			entry->type = OUTPUT_TMDS;
+			entry->type = DCB_OUTPUT_TMDS;
 		break;
 	case 3:
-		entry->type = OUTPUT_LVDS;
+		entry->type = DCB_OUTPUT_LVDS;
 		break;
 	default:
 		NV_ERROR(dev, "Unknown DCB type %d\n", conn & 0x0000000f);
@@ -5185,13 +1813,13 @@ parse_dcb15_entry(struct drm_device *dev
 	entry->duallink_possible = false;
 
 	switch (entry->type) {
-	case OUTPUT_ANALOG:
+	case DCB_OUTPUT_ANALOG:
 		entry->crtconf.maxfreq = (conf & 0xffff) * 10;
 		break;
-	case OUTPUT_TV:
+	case DCB_OUTPUT_TV:
 		entry->tvconf.has_component_output = false;
 		break;
-	case OUTPUT_LVDS:
+	case DCB_OUTPUT_LVDS:
 		if ((conn & 0x00003f00) >> 8 != 0x10)
 			entry->lvdsconf.use_straps_for_mode = true;
 		entry->lvdsconf.use_power_scripts = true;
@@ -5215,11 +1843,11 @@ void merge_like_dcb_entries(struct drm_d
 	int i, newentries = 0;
 
 	for (i = 0; i < dcb->entries; i++) {
-		struct dcb_entry *ient = &dcb->entry[i];
+		struct dcb_output *ient = &dcb->entry[i];
 		int j;
 
 		for (j = i + 1; j < dcb->entries; j++) {
-			struct dcb_entry *jent = &dcb->entry[j];
+			struct dcb_output *jent = &dcb->entry[j];
 
 			if (jent->type == 100) /* already merged entry */
 				continue;
@@ -5282,7 +1910,7 @@ apply_dcb_encoder_quirks(struct drm_devi
 	 */
 	if (nv_match_device(dev, 0x0201, 0x1462, 0x8851)) {
 		if (*conn == 0xf2005014 && *conf == 0xffffffff) {
-			fabricate_dcb_output(dcb, OUTPUT_TMDS, 1, 1, 1);
+			fabricate_dcb_output(dcb, DCB_OUTPUT_TMDS, 1, 1, 1);
 			return false;
 		}
 	}
@@ -5368,24 +1996,24 @@ fabricate_dcb_encoder_table(struct drm_d
 #ifdef __powerpc__
 	/* Apple iMac G4 NV17 */
 	if (of_machine_is_compatible("PowerMac4,5")) {
-		fabricate_dcb_output(dcb, OUTPUT_TMDS, 0, all_heads, 1);
-		fabricate_dcb_output(dcb, OUTPUT_ANALOG, 1, all_heads, 2);
+		fabricate_dcb_output(dcb, DCB_OUTPUT_TMDS, 0, all_heads, 1);
+		fabricate_dcb_output(dcb, DCB_OUTPUT_ANALOG, 1, all_heads, 2);
 		return;
 	}
 #endif
 
 	/* Make up some sane defaults */
-	fabricate_dcb_output(dcb, OUTPUT_ANALOG,
+	fabricate_dcb_output(dcb, DCB_OUTPUT_ANALOG,
 			     bios->legacy.i2c_indices.crt, 1, 1);
 
 	if (nv04_tv_identify(dev, bios->legacy.i2c_indices.tv) >= 0)
-		fabricate_dcb_output(dcb, OUTPUT_TV,
+		fabricate_dcb_output(dcb, DCB_OUTPUT_TV,
 				     bios->legacy.i2c_indices.tv,
 				     all_heads, 0);
 
 	else if (bios->tmds.output0_script_ptr ||
 		 bios->tmds.output1_script_ptr)
-		fabricate_dcb_output(dcb, OUTPUT_TMDS,
+		fabricate_dcb_output(dcb, DCB_OUTPUT_TMDS,
 				     bios->legacy.i2c_indices.panel,
 				     all_heads, 1);
 }
@@ -5400,7 +2028,7 @@ parse_dcb_entry(struct drm_device *dev,
 	bool ret;
 
 	if (apply_dcb_encoder_quirks(dev, idx, &conn, &conf)) {
-		struct dcb_entry *entry = new_dcb_entry(dcb);
+		struct dcb_output *entry = new_dcb_entry(dcb);
 
 		NV_TRACEWARN(dev, "DCB outp %02d: %08x %08x\n", idx, conn, conf);
 
@@ -5415,7 +2043,7 @@ parse_dcb_entry(struct drm_device *dev,
 		 * are cards with bogus values (nv31m in bug 23212),
 		 * and it's otherwise useless.
 		 */
-		if (entry->type == OUTPUT_TV &&
+		if (entry->type == DCB_OUTPUT_TV &&
 		    entry->location == DCB_LOC_ON_CHIP)
 			entry->i2c_index = 0x0f;
 	}
@@ -5463,7 +2091,7 @@ dcb_fake_connectors(struct nvbios *bios)
 	 * table - just in case it has random, rather than stub, entries.
 	 */
 	if (i > 1) {
-		u8 *conntab = dcb_conntab(bios->dev);
+		u8 *conntab = olddcb_conntab(bios->dev);
 		if (conntab)
 			conntab[0] = 0x00;
 	}
@@ -5504,10 +2132,10 @@ parse_dcb_table(struct drm_device *dev,
 
 	/* dump connector table entries to log, if any exist */
 	idx = -1;
-	while ((conn = dcb_conn(dev, ++idx))) {
+	while ((conn = olddcb_conn(dev, ++idx))) {
 		if (conn[0] != 0xff) {
 			NV_TRACE(dev, "DCB conn %02d: ", idx);
-			if (dcb_conntab(dev)[3] < 4)
+			if (olddcb_conntab(dev)[3] < 4)
 				printk("%04x\n", ROM16(conn[0]));
 			else
 				printk("%08x\n", ROM32(conn[0]));
@@ -5550,15 +2178,15 @@ static int load_nv17_hwsq_ucode_entry(st
 	hwsq_entry_offset = hwsq_offset + 2 + entry * bytes_to_write;
 
 	/* set sequencer control */
-	bios_wr32(bios, 0x00001304, ROM32(bios->data[hwsq_entry_offset]));
+	nv_wr32(dev, 0x00001304, ROM32(bios->data[hwsq_entry_offset]));
 	bytes_to_write -= 4;
 
 	/* write ucode */
 	for (i = 0; i < bytes_to_write; i += 4)
-		bios_wr32(bios, 0x00001400 + i, ROM32(bios->data[hwsq_entry_offset + i + 4]));
+		nv_wr32(dev, 0x00001400 + i, ROM32(bios->data[hwsq_entry_offset + i + 4]));
 
 	/* twiddle NV_PBUS_DEBUG_4 */
-	bios_wr32(bios, NV_PBUS_DEBUG_4, bios_rd32(bios, NV_PBUS_DEBUG_4) | 0x18);
+	nv_wr32(dev, NV_PBUS_DEBUG_4, nv_rd32(dev, NV_PBUS_DEBUG_4) | 0x18);
 
 	return 0;
 }
@@ -5618,32 +2246,6 @@ uint8_t *nouveau_bios_embedded_edid(stru
 	return bios->fp.edid = &bios->data[offset];
 }
 
-void
-nouveau_bios_run_init_table(struct drm_device *dev, uint16_t table,
-			    struct dcb_entry *dcbent, int crtc)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nvbios *bios = &dev_priv->vbios;
-	struct init_exec iexec = { true, false };
-
-	spin_lock_bh(&bios->lock);
-	bios->display.output = dcbent;
-	bios->display.crtc = crtc;
-	parse_init_table(bios, table, &iexec);
-	bios->display.output = NULL;
-	spin_unlock_bh(&bios->lock);
-}
-
-void
-nouveau_bios_init_exec(struct drm_device *dev, uint16_t table)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nvbios *bios = &dev_priv->vbios;
-	struct init_exec iexec = { true, false };
-
-	parse_init_table(bios, table, &iexec);
-}
-
 static bool NVInitVBIOS(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
@@ -5704,23 +2306,8 @@ nouveau_run_vbios_init(struct drm_device
 		bios->fp.lvds_init_run = false;
 	}
 
-	parse_init_tables(bios);
-
-	/*
-	 * Runs some additional script seen on G8x VBIOSen.  The VBIOS'
-	 * parser will run this right after the init tables, the binary
-	 * driver appears to run it at some point later.
-	 */
-	if (bios->some_script_ptr) {
-		struct init_exec iexec = {true, false};
-
-		NV_INFO(dev, "Parsing VBIOS init table at offset 0x%04X\n",
-			bios->some_script_ptr);
-		parse_init_table(bios, bios->some_script_ptr, &iexec);
-	}
-
 	if (dev_priv->card_type >= NV_50) {
-		for (i = 0; i < bios->dcb.entries; i++) {
+		for (i = 0; bios->execute && i < bios->dcb.entries; i++) {
 			nouveau_bios_run_display_table(dev, 0, 0,
 						       &bios->dcb.entry[i], -1);
 		}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_bios.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_bios.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_bios.h
@@ -72,66 +72,18 @@ enum dcb_connector_type {
 	DCB_CONNECTOR_NONE = 0xff
 };
 
-enum dcb_type {
-	OUTPUT_ANALOG = 0,
-	OUTPUT_TV = 1,
-	OUTPUT_TMDS = 2,
-	OUTPUT_LVDS = 3,
-	OUTPUT_DP = 6,
-	OUTPUT_EOL = 14, /* DCB 4.0+, appears to be end-of-list */
-	OUTPUT_UNUSED = 15,
-	OUTPUT_ANY = -1
-};
-
-struct dcb_entry {
-	int index;	/* may not be raw dcb index if merging has happened */
-	enum dcb_type type;
-	uint8_t i2c_index;
-	uint8_t heads;
-	uint8_t connector;
-	uint8_t bus;
-	uint8_t location;
-	uint8_t or;
-	bool duallink_possible;
-	union {
-		struct sor_conf {
-			int link;
-		} sorconf;
-		struct {
-			int maxfreq;
-		} crtconf;
-		struct {
-			struct sor_conf sor;
-			bool use_straps_for_mode;
-			bool use_acpi_for_edid;
-			bool use_power_scripts;
-		} lvdsconf;
-		struct {
-			bool has_component_output;
-		} tvconf;
-		struct {
-			struct sor_conf sor;
-			int link_nr;
-			int link_bw;
-		} dpconf;
-		struct {
-			struct sor_conf sor;
-			int slave_addr;
-		} tmdsconf;
-	};
-	bool i2c_upper_default;
-};
+#include <subdev/bios/dcb.h>
 
 struct dcb_table {
 	uint8_t version;
 	int entries;
-	struct dcb_entry entry[DCB_MAX_NUM_ENTRIES];
+	struct dcb_output entry[DCB_MAX_NUM_ENTRIES];
 };
 
 enum nouveau_or {
-	OUTPUT_A = (1 << 0),
-	OUTPUT_B = (1 << 1),
-	OUTPUT_C = (1 << 2)
+	DCB_OUTPUT_A = (1 << 0),
+	DCB_OUTPUT_B = (1 << 1),
+	DCB_OUTPUT_C = (1 << 2)
 };
 
 enum LVDS_script {
@@ -195,7 +147,7 @@ struct nvbios {
 	} state;
 
 	struct {
-		struct dcb_entry *output;
+		struct dcb_output *output;
 		int crtc;
 		uint16_t script_table_ptr;
 	} display;
@@ -244,7 +196,7 @@ void *olddcb_table(struct drm_device *);
 void *olddcb_outp(struct drm_device *, u8 idx);
 int olddcb_outp_foreach(struct drm_device *, void *data,
 		     int (*)(struct drm_device *, void *, int idx, u8 *outp));
-u8 *dcb_conntab(struct drm_device *);
-u8 *dcb_conn(struct drm_device *, u8 idx);
+u8 *olddcb_conntab(struct drm_device *);
+u8 *olddcb_conn(struct drm_device *, u8 idx);
 
 #endif
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_compat.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_compat.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_compat.c
@@ -2,6 +2,8 @@
 #include "nouveau_compat.h"
 
 #include <subdev/bios.h>
+#include <subdev/bios/dcb.h>
+#include <subdev/bios/init.h>
 #include <subdev/bios/pll.h>
 #include <subdev/gpio.h>
 #include <subdev/i2c.h>
@@ -9,6 +11,18 @@
 
 void *nouveau_newpriv(struct drm_device *);
 
+int
+nvdrm_gart_init(struct drm_device *dev, u64 *base, u64 *size)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	if (drm->agp.stat == ENABLED) {
+		*base = drm->agp.base;
+		*size = drm->agp.base;
+		return 0;
+	}
+	return -ENODEV;
+}
+
 u8
 _nv_rd08(struct drm_device *dev, u32 reg)
 {
@@ -255,3 +269,27 @@ nva3_calc_pll(struct drm_device *dev, st
 
 	return nva3_pll_calc(clk, info, freq, N, fN, M, P);
 }
+
+void
+nouveau_bios_run_init_table(struct drm_device *dev, uint16_t table,
+			    struct dcb_output *dcbent, int crtc)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_bios *bios = nouveau_bios(drm->device);
+	struct nvbios_init init = {
+		.subdev = nv_subdev(bios),
+		.bios = bios,
+		.offset = table,
+		.outp = dcbent,
+		.crtc = crtc,
+		.execute = 1
+	};
+
+	nvbios_exec(&init);
+}
+
+void
+nouveau_bios_init_exec(struct drm_device *dev, uint16_t table)
+{
+	nouveau_bios_run_init_table(dev, table, NULL, 0);
+}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_compat.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_compat.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_compat.h
@@ -1,6 +1,8 @@
 #ifndef __NOUVEAU_COMPAT_H__
 #define __NOUVEAU_COMPAT_H__
 
+int nvdrm_gart_init(struct drm_device *, u64 *, u64 *);
+
 u8   _nv_rd08(struct drm_device *, u32);
 void _nv_wr08(struct drm_device *, u32, u8);
 u32  _nv_rd32(struct drm_device *, u32);
@@ -45,4 +47,8 @@ int nva3_calc_pll(struct drm_device *dev
 	      int *N, int *fN, int *M, int *P);
 int nouveau_hw_setpll(struct drm_device *, u32, struct nouveau_pll_vals *);
 
+struct dcb_output;
+void nouveau_bios_run_init_table(struct drm_device *, u16, struct dcb_output *, int);
+void nouveau_bios_init_exec(struct drm_device *, u16);
+
 #endif
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_connector.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_connector.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_connector.c
@@ -59,7 +59,7 @@ find_encoder(struct drm_connector *conne
 			continue;
 		nv_encoder = nouveau_encoder(obj_to_encoder(obj));
 
-		if (type == OUTPUT_ANY || nv_encoder->dcb->type == type)
+		if (type == DCB_OUTPUT_ANY || nv_encoder->dcb->type == type)
 			return nv_encoder;
 	}
 
@@ -149,8 +149,8 @@ nouveau_connector_of_detect(struct drm_c
 	struct device_node *cn, *dn = pci_device_to_OF_node(dev->pdev);
 
 	if (!dn ||
-	    !((nv_encoder = find_encoder(connector, OUTPUT_TMDS)) ||
-	      (nv_encoder = find_encoder(connector, OUTPUT_ANALOG))))
+	    !((nv_encoder = find_encoder(connector, DCB_OUTPUT_TMDS)) ||
+	      (nv_encoder = find_encoder(connector, DCB_OUTPUT_ANALOG))))
 		return NULL;
 
 	for_each_child_of_node(dn, cn) {
@@ -185,8 +185,8 @@ nouveau_connector_set_encoder(struct drm
 		connector->interlace_allowed = true;
 		connector->doublescan_allowed = true;
 	} else
-	if (nv_encoder->dcb->type == OUTPUT_LVDS ||
-	    nv_encoder->dcb->type == OUTPUT_TMDS) {
+	if (nv_encoder->dcb->type == DCB_OUTPUT_LVDS ||
+	    nv_encoder->dcb->type == DCB_OUTPUT_TMDS) {
 		connector->doublescan_allowed = false;
 		connector->interlace_allowed = false;
 	} else {
@@ -204,7 +204,7 @@ nouveau_connector_set_encoder(struct drm
 	if (nv_connector->type == DCB_CONNECTOR_DVI_I) {
 		drm_connector_property_set_value(connector,
 			dev->mode_config.dvi_i_subconnector_property,
-			nv_encoder->dcb->type == OUTPUT_TMDS ?
+			nv_encoder->dcb->type == DCB_OUTPUT_TMDS ?
 			DRM_MODE_SUBCONNECTOR_DVID :
 			DRM_MODE_SUBCONNECTOR_DVIA);
 	}
@@ -238,7 +238,7 @@ nouveau_connector_detect(struct drm_conn
 			goto detect_analog;
 		}
 
-		if (nv_encoder->dcb->type == OUTPUT_DP &&
+		if (nv_encoder->dcb->type == DCB_OUTPUT_DP &&
 		    !nouveau_dp_detect(to_drm_encoder(nv_encoder))) {
 			NV_ERROR(dev, "Detected %s, but failed init\n",
 				 drm_get_connector_name(connector));
@@ -251,19 +251,19 @@ nouveau_connector_detect(struct drm_conn
 		 * isn't necessarily correct.
 		 */
 		nv_partner = NULL;
-		if (nv_encoder->dcb->type == OUTPUT_TMDS)
-			nv_partner = find_encoder(connector, OUTPUT_ANALOG);
-		if (nv_encoder->dcb->type == OUTPUT_ANALOG)
-			nv_partner = find_encoder(connector, OUTPUT_TMDS);
-
-		if (nv_partner && ((nv_encoder->dcb->type == OUTPUT_ANALOG &&
-				    nv_partner->dcb->type == OUTPUT_TMDS) ||
-				   (nv_encoder->dcb->type == OUTPUT_TMDS &&
-				    nv_partner->dcb->type == OUTPUT_ANALOG))) {
+		if (nv_encoder->dcb->type == DCB_OUTPUT_TMDS)
+			nv_partner = find_encoder(connector, DCB_OUTPUT_ANALOG);
+		if (nv_encoder->dcb->type == DCB_OUTPUT_ANALOG)
+			nv_partner = find_encoder(connector, DCB_OUTPUT_TMDS);
+
+		if (nv_partner && ((nv_encoder->dcb->type == DCB_OUTPUT_ANALOG &&
+				    nv_partner->dcb->type == DCB_OUTPUT_TMDS) ||
+				   (nv_encoder->dcb->type == DCB_OUTPUT_TMDS &&
+				    nv_partner->dcb->type == DCB_OUTPUT_ANALOG))) {
 			if (nv_connector->edid->input & DRM_EDID_INPUT_DIGITAL)
-				type = OUTPUT_TMDS;
+				type = DCB_OUTPUT_TMDS;
 			else
-				type = OUTPUT_ANALOG;
+				type = DCB_OUTPUT_ANALOG;
 
 			nv_encoder = find_encoder(connector, type);
 		}
@@ -279,9 +279,9 @@ nouveau_connector_detect(struct drm_conn
 	}
 
 detect_analog:
-	nv_encoder = find_encoder(connector, OUTPUT_ANALOG);
+	nv_encoder = find_encoder(connector, DCB_OUTPUT_ANALOG);
 	if (!nv_encoder && !nouveau_tv_disable)
-		nv_encoder = find_encoder(connector, OUTPUT_TV);
+		nv_encoder = find_encoder(connector, DCB_OUTPUT_TV);
 	if (nv_encoder && force) {
 		struct drm_encoder *encoder = to_drm_encoder(nv_encoder);
 		struct drm_encoder_helper_funcs *helper =
@@ -314,7 +314,7 @@ nouveau_connector_detect_lvds(struct drm
 		nv_connector->edid = NULL;
 	}
 
-	nv_encoder = find_encoder(connector, OUTPUT_LVDS);
+	nv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);
 	if (!nv_encoder)
 		return connector_status_disconnected;
 
@@ -386,11 +386,11 @@ nouveau_connector_force(struct drm_conne
 
 	if (nv_connector->type == DCB_CONNECTOR_DVI_I) {
 		if (connector->force == DRM_FORCE_ON_DIGITAL)
-			type = OUTPUT_TMDS;
+			type = DCB_OUTPUT_TMDS;
 		else
-			type = OUTPUT_ANALOG;
+			type = DCB_OUTPUT_ANALOG;
 	} else
-		type = OUTPUT_ANY;
+		type = DCB_OUTPUT_ANY;
 
 	nv_encoder = find_encoder(connector, type);
 	if (!nv_encoder) {
@@ -533,7 +533,7 @@ nouveau_connector_set_property(struct dr
 		}
 	}
 
-	if (nv_encoder && nv_encoder->dcb->type == OUTPUT_TV)
+	if (nv_encoder && nv_encoder->dcb->type == DCB_OUTPUT_TV)
 		return get_slave_funcs(encoder)->set_property(
 			encoder, connector, property, value);
 
@@ -662,7 +662,7 @@ nouveau_connector_detect_depth(struct dr
 	}
 
 	/* we're out of options unless we're LVDS, default to 8bpc */
-	if (nv_encoder->dcb->type != OUTPUT_LVDS) {
+	if (nv_encoder->dcb->type != DCB_OUTPUT_LVDS) {
 		connector->display_info.bpc = 8;
 		return;
 	}
@@ -710,7 +710,7 @@ nouveau_connector_get_modes(struct drm_c
 	if (nv_connector->edid)
 		ret = drm_add_edid_modes(connector, nv_connector->edid);
 	else
-	if (nv_encoder->dcb->type == OUTPUT_LVDS &&
+	if (nv_encoder->dcb->type == DCB_OUTPUT_LVDS &&
 	    (nv_encoder->dcb->lvdsconf.use_straps_for_mode ||
 	     dev_priv->vbios.fp_no_ddc) && nouveau_bios_fp_mode(dev, NULL)) {
 		struct drm_display_mode mode;
@@ -747,7 +747,7 @@ nouveau_connector_get_modes(struct drm_c
 	if (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)
 		nouveau_connector_detect_depth(connector);
 
-	if (nv_encoder->dcb->type == OUTPUT_TV)
+	if (nv_encoder->dcb->type == DCB_OUTPUT_TV)
 		ret = get_slave_funcs(encoder)->get_modes(encoder, connector);
 
 	if (nv_connector->type == DCB_CONNECTOR_LVDS ||
@@ -763,7 +763,7 @@ get_tmds_link_bandwidth(struct drm_conne
 {
 	struct nouveau_connector *nv_connector = nouveau_connector(connector);
 	struct drm_nouveau_private *dev_priv = connector->dev->dev_private;
-	struct dcb_entry *dcb = nv_connector->detected_encoder->dcb;
+	struct dcb_output *dcb = nv_connector->detected_encoder->dcb;
 
 	if (dcb->location != DCB_LOC_ON_CHIP ||
 	    dev_priv->chipset >= 0x46)
@@ -787,7 +787,7 @@ nouveau_connector_mode_valid(struct drm_
 	unsigned clock = mode->clock;
 
 	switch (nv_encoder->dcb->type) {
-	case OUTPUT_LVDS:
+	case DCB_OUTPUT_LVDS:
 		if (nv_connector->native_mode &&
 		    (mode->hdisplay > nv_connector->native_mode->hdisplay ||
 		     mode->vdisplay > nv_connector->native_mode->vdisplay))
@@ -796,19 +796,19 @@ nouveau_connector_mode_valid(struct drm_
 		min_clock = 0;
 		max_clock = 400000;
 		break;
-	case OUTPUT_TMDS:
+	case DCB_OUTPUT_TMDS:
 		max_clock = get_tmds_link_bandwidth(connector);
 		if (nouveau_duallink && nv_encoder->dcb->duallink_possible)
 			max_clock *= 2;
 		break;
-	case OUTPUT_ANALOG:
+	case DCB_OUTPUT_ANALOG:
 		max_clock = nv_encoder->dcb->crtconf.maxfreq;
 		if (!max_clock)
 			max_clock = 350000;
 		break;
-	case OUTPUT_TV:
+	case DCB_OUTPUT_TV:
 		return get_slave_funcs(encoder)->mode_valid(encoder, mode);
-	case OUTPUT_DP:
+	case DCB_OUTPUT_DP:
 		max_clock  = nv_encoder->dp.link_nr;
 		max_clock *= nv_encoder->dp.link_bw;
 		clock = clock * (connector->display_info.bpc * 3) / 10;
@@ -923,7 +923,7 @@ nouveau_connector_create(struct drm_devi
 	nv_connector->index = index;
 
 	/* attempt to parse vbios connector type and hotplug gpio */
-	nv_connector->dcb = dcb_conn(dev, index);
+	nv_connector->dcb = olddcb_conn(dev, index);
 	if (nv_connector->dcb) {
 		static const u8 hpd[16] = {
 			0xff, 0x07, 0x08, 0xff, 0xff, 0x51, 0x52, 0xff,
@@ -931,7 +931,7 @@ nouveau_connector_create(struct drm_devi
 		};
 
 		u32 entry = ROM16(nv_connector->dcb[0]);
-		if (dcb_conntab(dev)[3] >= 4)
+		if (olddcb_conntab(dev)[3] >= 4)
 			entry |= (u32)ROM16(nv_connector->dcb[2]) << 16;
 
 		nv_connector->hpd = ffs((entry & 0x07033000) >> 12);
@@ -975,25 +975,25 @@ nouveau_connector_create(struct drm_devi
 				encoders |= (1 << dcbt->entry[i].type);
 		}
 
-		if (encoders & (1 << OUTPUT_DP)) {
-			if (encoders & (1 << OUTPUT_TMDS))
+		if (encoders & (1 << DCB_OUTPUT_DP)) {
+			if (encoders & (1 << DCB_OUTPUT_TMDS))
 				nv_connector->type = DCB_CONNECTOR_DP;
 			else
 				nv_connector->type = DCB_CONNECTOR_eDP;
 		} else
-		if (encoders & (1 << OUTPUT_TMDS)) {
-			if (encoders & (1 << OUTPUT_ANALOG))
+		if (encoders & (1 << DCB_OUTPUT_TMDS)) {
+			if (encoders & (1 << DCB_OUTPUT_ANALOG))
 				nv_connector->type = DCB_CONNECTOR_DVI_I;
 			else
 				nv_connector->type = DCB_CONNECTOR_DVI_D;
 		} else
-		if (encoders & (1 << OUTPUT_ANALOG)) {
+		if (encoders & (1 << DCB_OUTPUT_ANALOG)) {
 			nv_connector->type = DCB_CONNECTOR_VGA;
 		} else
-		if (encoders & (1 << OUTPUT_LVDS)) {
+		if (encoders & (1 << DCB_OUTPUT_LVDS)) {
 			nv_connector->type = DCB_CONNECTOR_LVDS;
 		} else
-		if (encoders & (1 << OUTPUT_TV)) {
+		if (encoders & (1 << DCB_OUTPUT_TV)) {
 			nv_connector->type = DCB_CONNECTOR_TV_0;
 		}
 	}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_dp.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_dp.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_dp.c
@@ -31,7 +31,7 @@
 #include "nouveau_crtc.h"
 
 u8 *
-nouveau_dp_bios_data(struct drm_device *dev, struct dcb_entry *dcb, u8 **entry)
+nouveau_dp_bios_data(struct drm_device *dev, struct dcb_output *dcb, u8 **entry)
 {
 	struct bit_entry d;
 	u8 *table;
@@ -80,7 +80,7 @@ nouveau_dp_bios_data(struct drm_device *
 struct dp_state {
 	struct nouveau_i2c_port *auxch;
 	struct dp_train_func *func;
-	struct dcb_entry *dcb;
+	struct dcb_output *dcb;
 	int crtc;
 	u8 *dpcd;
 	int link_nr;
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drm.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_drm.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drm.c
@@ -32,6 +32,7 @@
 #include <subdev/device.h>
 
 #include "nouveau_drm.h"
+#include "nouveau_agp.h"
 
 int __devinit nouveau_pci_probe(struct pci_dev *, const struct pci_device_id *);
 void nouveau_pci_remove(struct pci_dev *);
@@ -123,6 +124,30 @@ nouveau_drm_load(struct drm_device *dev,
 	INIT_LIST_HEAD(&drm->clients);
 	drm->dev = dev;
 
+	/* make sure AGP controller is in a consistent state before we
+	 * (possibly) execute vbios init tables (see nouveau_agp.h)
+	 */
+	if (drm_pci_device_is_agp(dev) && dev->agp) {
+		/* dummy device object, doesn't init anything, but allows
+		 * agp code access to registers
+		 */
+		ret = nouveau_object_new(nv_object(drm), NVDRM_CLIENT,
+					 NVDRM_DEVICE, 0x0080,
+					 &(struct nv_device_class) {
+						.device = ~0,
+						.disable =
+						 ~(NV_DEVICE_DISABLE_MMIO |
+						   NV_DEVICE_DISABLE_IDENTIFY),
+						.debug0 = ~0,
+					 }, sizeof(struct nv_device_class),
+					 &drm->device);
+		if (ret)
+			return ret;
+
+		nouveau_agp_reset(drm);
+		nouveau_object_del(nv_object(drm), NVDRM_CLIENT, NVDRM_DEVICE);
+	}
+
 	ret = nouveau_object_new(nv_object(drm), NVDRM_CLIENT, NVDRM_DEVICE,
 				 0x0080, &(struct nv_device_class) {
 					.device = ~0,
@@ -133,6 +158,9 @@ nouveau_drm_load(struct drm_device *dev,
 	if (ret)
 		goto fail_device;
 
+	/* initialise AGP */
+	nouveau_agp_init(drm);
+
 	ret = nouveau_load(dev, flags);
 	if (ret)
 		goto fail_device;
@@ -155,6 +183,8 @@ nouveau_drm_unload(struct drm_device *de
 	if (ret)
 		return ret;
 
+	nouveau_agp_fini(drm);
+
 	pci_set_drvdata(pdev, drm->client.base.device);
 	nouveau_cli_destroy(&drm->client);
 	return 0;
@@ -195,6 +225,8 @@ nouveau_drm_suspend(struct pci_dev *pdev
 	if (ret)
 		goto fail_client;
 
+	nouveau_agp_fini(drm);
+
 	pci_save_state(pdev);
 	if (pm_state.event == PM_EVENT_SUSPEND) {
 		pci_disable_device(pdev);
@@ -230,12 +262,16 @@ nouveau_drm_resume(struct pci_dev *pdev)
 		return ret;
 	pci_set_master(pdev);
 
+	nouveau_agp_reset(drm);
+
 	nouveau_client_init(&drm->client.base);
 
 	list_for_each_entry(cli, &drm->clients, head) {
 		nouveau_client_init(&cli->base);
 	}
 
+	nouveau_agp_init(drm);
+
 	return nouveau_pci_resume(pdev);
 }
 
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drm.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_drm.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drm.h
@@ -23,6 +23,16 @@ struct nouveau_drm {
 
 	struct nouveau_object *device;
 	struct list_head clients;
+
+	struct {
+		enum {
+			UNKNOWN = 0,
+			DISABLE = 1,
+			ENABLED = 2
+		} stat;
+		u32 base;
+		u32 size;
+	} agp;
 };
 
 int nouveau_drm_suspend(struct pci_dev *, pm_message_t);
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_drv.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.c
@@ -28,7 +28,6 @@
 #include <drm/drmP.h>
 #include <drm/drm_crtc_helper.h>
 #include "nouveau_drv.h"
-#include "nouveau_agp.h"
 #include "nouveau_abi16.h"
 #include "nouveau_hw.h"
 #include "nouveau_fb.h"
@@ -218,7 +217,6 @@ nouveau_pci_suspend(struct pci_dev *pdev
 		goto out_abort;
 	}
 
-	nouveau_agp_fini(dev);
 	return 0;
 
 out_abort:
@@ -240,9 +238,6 @@ nouveau_pci_resume(struct pci_dev *pdev)
 	struct drm_crtc *crtc;
 	int ret, i;
 
-	/* Make sure the AGP controller is in a consistent state */
-	nouveau_agp_reset(dev);
-
 	/* Make the CRTCs accessible */
 	engine->display.early_init(dev);
 
@@ -251,8 +246,6 @@ nouveau_pci_resume(struct pci_dev *pdev)
 	if (ret)
 		return ret;
 
-	nouveau_agp_init(dev);
-
 	NV_INFO(dev, "Restoring GPU objects...\n");
 	nouveau_gpuobj_resume(dev);
 
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -1040,22 +1040,19 @@ static inline void nouveau_backlight_exi
 extern int nouveau_bios_init(struct drm_device *);
 extern void nouveau_bios_takedown(struct drm_device *dev);
 extern int nouveau_run_vbios_init(struct drm_device *);
-extern void nouveau_bios_run_init_table(struct drm_device *, uint16_t table,
-					struct dcb_entry *, int crtc);
-extern void nouveau_bios_init_exec(struct drm_device *, uint16_t table);
 extern struct dcb_connector_table_entry *
 nouveau_bios_connector_entry(struct drm_device *, int index);
 extern int nouveau_bios_run_display_table(struct drm_device *, u16 id, int clk,
-					  struct dcb_entry *, int crtc);
+					  struct dcb_output *, int crtc);
 extern bool nouveau_bios_fp_mode(struct drm_device *, struct drm_display_mode *);
 extern uint8_t *nouveau_bios_embedded_edid(struct drm_device *);
 extern int nouveau_bios_parse_lvds_table(struct drm_device *, int pxclk,
 					 bool *dl, bool *if_is_24bit);
-extern int run_tmds_table(struct drm_device *, struct dcb_entry *,
+extern int run_tmds_table(struct drm_device *, struct dcb_output *,
 			  int head, int pxclk);
-extern int call_lvds_script(struct drm_device *, struct dcb_entry *, int head,
+extern int call_lvds_script(struct drm_device *, struct dcb_output *, int head,
 			    enum LVDS_script, int pxclk);
-bool bios_encoder_match(struct dcb_entry *, u32 hash);
+bool bios_encoder_match(struct dcb_output *, u32 hash);
 
 /* nouveau_mxm.c */
 int  nouveau_mxm_init(struct drm_device *dev);
@@ -1234,26 +1231,26 @@ extern long nouveau_compat_ioctl(struct
 				 unsigned long arg);
 
 /* nv04_dac.c */
-extern int nv04_dac_create(struct drm_connector *, struct dcb_entry *);
+extern int nv04_dac_create(struct drm_connector *, struct dcb_output *);
 extern uint32_t nv17_dac_sample_load(struct drm_encoder *encoder);
 extern int nv04_dac_output_offset(struct drm_encoder *encoder);
 extern void nv04_dac_update_dacclk(struct drm_encoder *encoder, bool enable);
 extern bool nv04_dac_in_use(struct drm_encoder *encoder);
 
 /* nv04_dfp.c */
-extern int nv04_dfp_create(struct drm_connector *, struct dcb_entry *);
-extern int nv04_dfp_get_bound_head(struct drm_device *dev, struct dcb_entry *dcbent);
-extern void nv04_dfp_bind_head(struct drm_device *dev, struct dcb_entry *dcbent,
+extern int nv04_dfp_create(struct drm_connector *, struct dcb_output *);
+extern int nv04_dfp_get_bound_head(struct drm_device *dev, struct dcb_output *dcbent);
+extern void nv04_dfp_bind_head(struct drm_device *dev, struct dcb_output *dcbent,
 			       int head, bool dl);
 extern void nv04_dfp_disable(struct drm_device *dev, int head);
 extern void nv04_dfp_update_fp_control(struct drm_encoder *encoder, int mode);
 
 /* nv04_tv.c */
 extern int nv04_tv_identify(struct drm_device *dev, int i2c_index);
-extern int nv04_tv_create(struct drm_connector *, struct dcb_entry *);
+extern int nv04_tv_create(struct drm_connector *, struct dcb_output *);
 
 /* nv17_tv.c */
-extern int nv17_tv_create(struct drm_connector *, struct dcb_entry *);
+extern int nv17_tv_create(struct drm_connector *, struct dcb_output *);
 
 /* nv04_display.c */
 extern int nv04_display_early_init(struct drm_device *);
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_encoder.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_encoder.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_encoder.h
@@ -35,17 +35,17 @@
 struct nouveau_i2c_port;
 
 struct dp_train_func {
-	void (*link_set)(struct drm_device *, struct dcb_entry *, int crtc,
+	void (*link_set)(struct drm_device *, struct dcb_output *, int crtc,
 			 int nr, u32 bw, bool enhframe);
-	void (*train_set)(struct drm_device *, struct dcb_entry *, u8 pattern);
-	void (*train_adj)(struct drm_device *, struct dcb_entry *,
+	void (*train_set)(struct drm_device *, struct dcb_output *, u8 pattern);
+	void (*train_adj)(struct drm_device *, struct dcb_output *,
 			  u8 lane, u8 swing, u8 preem);
 };
 
 struct nouveau_encoder {
 	struct drm_encoder_slave base;
 
-	struct dcb_entry *dcb;
+	struct dcb_output *dcb;
 	int or;
 
 	/* different to drm_encoder.crtc, this reflects what's
@@ -92,13 +92,13 @@ get_slave_funcs(struct drm_encoder *enc)
 bool nouveau_dp_detect(struct drm_encoder *);
 void nouveau_dp_dpms(struct drm_encoder *, int mode, u32 datarate,
 		     struct dp_train_func *);
-u8 *nouveau_dp_bios_data(struct drm_device *, struct dcb_entry *, u8 **);
+u8 *nouveau_dp_bios_data(struct drm_device *, struct dcb_output *, u8 **);
 
 struct nouveau_connector *
 nouveau_encoder_connector_get(struct nouveau_encoder *encoder);
-int nv50_sor_create(struct drm_connector *, struct dcb_entry *);
+int nv50_sor_create(struct drm_connector *, struct dcb_output *);
 void nv50_sor_dp_calc_tu(struct drm_device *, int, int, u32, u32);
-int nv50_dac_create(struct drm_connector *, struct dcb_entry *);
+int nv50_dac_create(struct drm_connector *, struct dcb_output *);
 
 
 #endif /* __NOUVEAU_ENCODER_H__ */
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_hw.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_hw.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_hw.h
@@ -161,7 +161,7 @@ static inline void NVWriteRAMDAC(struct
 static inline uint8_t nv_read_tmds(struct drm_device *dev,
 					int or, int dl, uint8_t address)
 {
-	int ramdac = (or & OUTPUT_C) >> 2;
+	int ramdac = (or & DCB_OUTPUT_C) >> 2;
 
 	NVWriteRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_CONTROL + dl * 8,
 	NV_PRAMDAC_FP_TMDS_CONTROL_WRITE_DISABLE | address);
@@ -172,7 +172,7 @@ static inline void nv_write_tmds(struct
 					int or, int dl, uint8_t address,
 					uint8_t data)
 {
-	int ramdac = (or & OUTPUT_C) >> 2;
+	int ramdac = (or & DCB_OUTPUT_C) >> 2;
 
 	NVWriteRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_DATA + dl * 8, data);
 	NVWriteRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_CONTROL + dl * 8, address);
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_mem.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_mem.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_mem.c
@@ -34,7 +34,6 @@
 #include <drm/drmP.h>
 
 #include "nouveau_drv.h"
-#include "nouveau_agp.h"
 #include "nouveau_pm.h"
 #include <core/mm.h>
 #include <subdev/vm.h>
@@ -171,7 +170,6 @@ void
 nouveau_mem_gart_fini(struct drm_device *dev)
 {
 	nouveau_sgdma_takedown(dev);
-	nouveau_agp_fini(dev);
 }
 
 bool
@@ -306,7 +304,9 @@ nouveau_mem_gart_init(struct drm_device
 	struct ttm_bo_device *bdev = &dev_priv->ttm.bdev;
 	int ret;
 
-	nouveau_agp_init(dev);
+	if (!nvdrm_gart_init(dev, &dev_priv->gart_info.aper_base,
+				  &dev_priv->gart_info.aper_size))
+		dev_priv->gart_info.type = NOUVEAU_GART_AGP;
 
 	if (dev_priv->gart_info.type == NOUVEAU_GART_NONE) {
 		ret = nouveau_sgdma_init(dev);
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_mxm.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_mxm.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_mxm.c
@@ -390,7 +390,7 @@ mxm_dcb_sanitise_entry(struct drm_device
 	 * vbios mxm table
 	 */
 	i2cidx = mxm_ddc_map(dev, ctx.desc.ddc_port);
-	if ((ctx.outp[0] & 0x0000000f) != OUTPUT_DP)
+	if ((ctx.outp[0] & 0x0000000f) != DCB_OUTPUT_DP)
 		i2cidx = (i2cidx & 0x0f) << 4;
 	else
 		i2cidx = (i2cidx & 0xf0);
@@ -419,7 +419,7 @@ mxm_dcb_sanitise_entry(struct drm_device
 	 * and the mxm data says the connector is really HDMI.  another
 	 * common example is DP->eDP.
 	 */
-	conn = dcb_conn(dev, (ctx.outp[0] & 0x0000f000) >> 12);
+	conn = olddcb_conn(dev, (ctx.outp[0] & 0x0000f000) >> 12);
 	type = conn[0];
 	switch (ctx.desc.conn_type) {
 	case 0x01: /* LVDS */
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_state.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_state.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_state.c
@@ -32,7 +32,6 @@
 
 #include "nouveau_drv.h"
 #include <drm/nouveau_drm.h>
-#include "nouveau_agp.h"
 #include "nouveau_fbcon.h"
 #include <core/ramht.h>
 #include "nouveau_pm.h"
@@ -514,9 +513,6 @@ nouveau_card_init(struct drm_device *dev
 	spin_lock_init(&dev_priv->context_switch_lock);
 	spin_lock_init(&dev_priv->vm_lock);
 
-	/* Make sure the AGP controller is in a consistent state */
-	nouveau_agp_reset(dev);
-
 	/* Make the CRTCs and I2C buses accessible */
 	ret = engine->display.early_init(dev);
 	if (ret)
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_crtc.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv04_crtc.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_crtc.c
@@ -251,8 +251,8 @@ nv_crtc_mode_set_vga(struct drm_crtc *cr
 		struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
 
 		if (encoder->crtc == crtc &&
-		    (nv_encoder->dcb->type == OUTPUT_LVDS ||
-		     nv_encoder->dcb->type == OUTPUT_TMDS))
+		    (nv_encoder->dcb->type == DCB_OUTPUT_LVDS ||
+		     nv_encoder->dcb->type == DCB_OUTPUT_TMDS))
 			fp_output = true;
 	}
 
@@ -467,11 +467,11 @@ nv_crtc_mode_set_regs(struct drm_crtc *c
 		if (encoder->crtc != crtc)
 			continue;
 
-		if (nv_encoder->dcb->type == OUTPUT_LVDS)
+		if (nv_encoder->dcb->type == DCB_OUTPUT_LVDS)
 			digital = lvds_output = true;
-		if (nv_encoder->dcb->type == OUTPUT_TV)
+		if (nv_encoder->dcb->type == DCB_OUTPUT_TV)
 			tv_output = true;
-		if (nv_encoder->dcb->type == OUTPUT_TMDS)
+		if (nv_encoder->dcb->type == DCB_OUTPUT_TMDS)
 			digital = tmds_output = true;
 		if (nv_encoder->dcb->location != DCB_LOC_ON_CHIP && digital)
 			off_chip_digital = true;
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_dac.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv04_dac.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_dac.c
@@ -38,12 +38,12 @@
 
 int nv04_dac_output_offset(struct drm_encoder *encoder)
 {
-	struct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;
+	struct dcb_output *dcb = nouveau_encoder(encoder)->dcb;
 	int offset = 0;
 
-	if (dcb->or & (8 | OUTPUT_C))
+	if (dcb->or & (8 | DCB_OUTPUT_C))
 		offset += 0x68;
-	if (dcb->or & (8 | OUTPUT_B))
+	if (dcb->or & (8 | DCB_OUTPUT_B))
 		offset += 0x2000;
 
 	return offset;
@@ -222,14 +222,14 @@ uint32_t nv17_dac_sample_load(struct drm
 {
 	struct drm_device *dev = encoder->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;
+	struct dcb_output *dcb = nouveau_encoder(encoder)->dcb;
 	uint32_t sample, testval, regoffset = nv04_dac_output_offset(encoder);
 	uint32_t saved_powerctrl_2 = 0, saved_powerctrl_4 = 0, saved_routput,
 		saved_rtest_ctrl, saved_gpio0, saved_gpio1, temp, routput;
 	int head;
 
 #define RGB_TEST_DATA(r, g, b) (r << 0 | g << 10 | b << 20)
-	if (dcb->type == OUTPUT_TV) {
+	if (dcb->type == DCB_OUTPUT_TV) {
 		testval = RGB_TEST_DATA(0xa0, 0xa0, 0xa0);
 
 		if (dev_priv->vbios.tvdactestval)
@@ -256,8 +256,8 @@ uint32_t nv17_dac_sample_load(struct drm
 	saved_gpio1 = nouveau_gpio_func_get(dev, DCB_GPIO_TVDAC1);
 	saved_gpio0 = nouveau_gpio_func_get(dev, DCB_GPIO_TVDAC0);
 
-	nouveau_gpio_func_set(dev, DCB_GPIO_TVDAC1, dcb->type == OUTPUT_TV);
-	nouveau_gpio_func_set(dev, DCB_GPIO_TVDAC0, dcb->type == OUTPUT_TV);
+	nouveau_gpio_func_set(dev, DCB_GPIO_TVDAC1, dcb->type == DCB_OUTPUT_TV);
+	nouveau_gpio_func_set(dev, DCB_GPIO_TVDAC0, dcb->type == DCB_OUTPUT_TV);
 
 	msleep(4);
 
@@ -272,7 +272,7 @@ uint32_t nv17_dac_sample_load(struct drm
 	routput = (saved_routput & 0xfffffece) | head << 8;
 
 	if (dev_priv->card_type >= NV_40) {
-		if (dcb->type == OUTPUT_TV)
+		if (dcb->type == DCB_OUTPUT_TV)
 			routput |= 0x1a << 16;
 		else
 			routput &= ~(0x1a << 16);
@@ -317,7 +317,7 @@ static enum drm_connector_status
 nv17_dac_detect(struct drm_encoder *encoder, struct drm_connector *connector)
 {
 	struct drm_device *dev = encoder->dev;
-	struct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;
+	struct dcb_output *dcb = nouveau_encoder(encoder)->dcb;
 
 	if (nv04_dac_in_use(encoder))
 		return connector_status_disconnected;
@@ -373,7 +373,7 @@ static void nv04_dac_mode_set(struct drm
 		/* force any other vga encoders to bind to the other crtc */
 		list_for_each_entry(rebind, &dev->mode_config.encoder_list, head) {
 			if (rebind == encoder
-			    || nouveau_encoder(rebind)->dcb->type != OUTPUT_ANALOG)
+			    || nouveau_encoder(rebind)->dcb->type != DCB_OUTPUT_ANALOG)
 				continue;
 
 			dac_offset = nv04_dac_output_offset(rebind);
@@ -408,7 +408,7 @@ void nv04_dac_update_dacclk(struct drm_e
 {
 	struct drm_device *dev = encoder->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;
+	struct dcb_output *dcb = nouveau_encoder(encoder)->dcb;
 
 	if (nv_gf4_disp_arch(dev)) {
 		uint32_t *dac_users = &dev_priv->dac_users[ffs(dcb->or) - 1];
@@ -433,7 +433,7 @@ void nv04_dac_update_dacclk(struct drm_e
 bool nv04_dac_in_use(struct drm_encoder *encoder)
 {
 	struct drm_nouveau_private *dev_priv = encoder->dev->dev_private;
-	struct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;
+	struct dcb_output *dcb = nouveau_encoder(encoder)->dcb;
 
 	return nv_gf4_disp_arch(encoder->dev) &&
 		(dev_priv->dac_users[ffs(dcb->or) - 1] & ~(1 << dcb->index));
@@ -513,7 +513,7 @@ static const struct drm_encoder_funcs nv
 };
 
 int
-nv04_dac_create(struct drm_connector *connector, struct dcb_entry *entry)
+nv04_dac_create(struct drm_connector *connector, struct dcb_output *entry)
 {
 	const struct drm_encoder_helper_funcs *helper;
 	struct nouveau_encoder *nv_encoder = NULL;
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_dfp.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv04_dfp.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_dfp.c
@@ -49,20 +49,20 @@ static inline bool is_fpc_off(uint32_t f
 			FP_TG_CONTROL_OFF);
 }
 
-int nv04_dfp_get_bound_head(struct drm_device *dev, struct dcb_entry *dcbent)
+int nv04_dfp_get_bound_head(struct drm_device *dev, struct dcb_output *dcbent)
 {
 	/* special case of nv_read_tmds to find crtc associated with an output.
 	 * this does not give a correct answer for off-chip dvi, but there's no
 	 * use for such an answer anyway
 	 */
-	int ramdac = (dcbent->or & OUTPUT_C) >> 2;
+	int ramdac = (dcbent->or & DCB_OUTPUT_C) >> 2;
 
 	NVWriteRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_CONTROL,
 	NV_PRAMDAC_FP_TMDS_CONTROL_WRITE_DISABLE | 0x4);
 	return ((NVReadRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_DATA) & 0x8) >> 3) ^ ramdac;
 }
 
-void nv04_dfp_bind_head(struct drm_device *dev, struct dcb_entry *dcbent,
+void nv04_dfp_bind_head(struct drm_device *dev, struct dcb_output *dcbent,
 			int head, bool dl)
 {
 	/* The BIOS scripts don't do this for us, sadly
@@ -72,13 +72,13 @@ void nv04_dfp_bind_head(struct drm_devic
 	 * (for VT restore etc.)
 	 */
 
-	int ramdac = (dcbent->or & OUTPUT_C) >> 2;
+	int ramdac = (dcbent->or & DCB_OUTPUT_C) >> 2;
 	uint8_t tmds04 = 0x80;
 
 	if (head != ramdac)
 		tmds04 = 0x88;
 
-	if (dcbent->type == OUTPUT_LVDS)
+	if (dcbent->type == DCB_OUTPUT_LVDS)
 		tmds04 |= 0x01;
 
 	nv_write_tmds(dev, dcbent->or, 0, 0x04, tmds04);
@@ -151,10 +151,10 @@ void nv04_dfp_update_fp_control(struct d
 static struct drm_encoder *get_tmds_slave(struct drm_encoder *encoder)
 {
 	struct drm_device *dev = encoder->dev;
-	struct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;
+	struct dcb_output *dcb = nouveau_encoder(encoder)->dcb;
 	struct drm_encoder *slave;
 
-	if (dcb->type != OUTPUT_TMDS || dcb->location == DCB_LOC_ON_CHIP)
+	if (dcb->type != DCB_OUTPUT_TMDS || dcb->location == DCB_LOC_ON_CHIP)
 		return NULL;
 
 	/* Some BIOSes (e.g. the one in a Quadro FX1000) report several
@@ -168,9 +168,9 @@ static struct drm_encoder *get_tmds_slav
 	 * let's do the same.
 	 */
 	list_for_each_entry(slave, &dev->mode_config.encoder_list, head) {
-		struct dcb_entry *slave_dcb = nouveau_encoder(slave)->dcb;
+		struct dcb_output *slave_dcb = nouveau_encoder(slave)->dcb;
 
-		if (slave_dcb->type == OUTPUT_TMDS && get_slave_funcs(slave) &&
+		if (slave_dcb->type == DCB_OUTPUT_TMDS && get_slave_funcs(slave) &&
 		    slave_dcb->tmdsconf.slave_addr == dcb->tmdsconf.slave_addr)
 			return slave;
 	}
@@ -204,7 +204,7 @@ static void nv04_dfp_prepare_sel_clk(str
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nv04_mode_state *state = &dev_priv->mode_reg;
-	uint32_t bits1618 = nv_encoder->dcb->or & OUTPUT_A ? 0x10000 : 0x40000;
+	uint32_t bits1618 = nv_encoder->dcb->or & DCB_OUTPUT_A ? 0x10000 : 0x40000;
 
 	if (nv_encoder->dcb->location != DCB_LOC_ON_CHIP)
 		return;
@@ -233,7 +233,7 @@ static void nv04_dfp_prepare_sel_clk(str
 	 * 	and which bit-pair to use, is unclear on nv40 (for earlier cards, the fp table
 	 * 	entry has the necessary info)
 	 */
-	if (nv_encoder->dcb->type == OUTPUT_LVDS && dev_priv->saved_reg.sel_clk & 0xf0) {
+	if (nv_encoder->dcb->type == DCB_OUTPUT_LVDS && dev_priv->saved_reg.sel_clk & 0xf0) {
 		int shift = (dev_priv->saved_reg.sel_clk & 0x50) ? 0 : 1;
 
 		state->sel_clk &= ~0xf0;
@@ -263,7 +263,7 @@ static void nv04_dfp_prepare(struct drm_
 			*cr_lcd |= head ? 0x0 : 0x8;
 		else {
 			*cr_lcd |= (nv_encoder->dcb->or << 4) & 0x30;
-			if (nv_encoder->dcb->type == OUTPUT_LVDS)
+			if (nv_encoder->dcb->type == DCB_OUTPUT_LVDS)
 				*cr_lcd |= 0x30;
 			if ((*cr_lcd & 0x30) == (*cr_lcd_oth & 0x30)) {
 				/* avoid being connected to both crtcs */
@@ -340,7 +340,7 @@ static void nv04_dfp_mode_set(struct drm
 	if (nv_encoder->dcb->location != DCB_LOC_ON_CHIP &&
 	    output_mode->clock > 165000)
 		regp->fp_control |= (2 << 24);
-	if (nv_encoder->dcb->type == OUTPUT_LVDS) {
+	if (nv_encoder->dcb->type == DCB_OUTPUT_LVDS) {
 		bool duallink = false, dummy;
 		if (nv_connector->edid &&
 		    nv_connector->type == DCB_CONNECTOR_LVDS_SPWG) {
@@ -448,13 +448,13 @@ static void nv04_dfp_commit(struct drm_e
 	struct drm_encoder_helper_funcs *helper = encoder->helper_private;
 	struct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);
 	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
-	struct dcb_entry *dcbe = nv_encoder->dcb;
+	struct dcb_output *dcbe = nv_encoder->dcb;
 	int head = nouveau_crtc(encoder->crtc)->index;
 	struct drm_encoder *slave_encoder;
 
-	if (dcbe->type == OUTPUT_TMDS)
+	if (dcbe->type == DCB_OUTPUT_TMDS)
 		run_tmds_table(dev, dcbe, head, nv_encoder->mode.clock);
-	else if (dcbe->type == OUTPUT_LVDS)
+	else if (dcbe->type == DCB_OUTPUT_LVDS)
 		call_lvds_script(dev, dcbe, head, LVDS_RESET, nv_encoder->mode.clock);
 
 	/* update fp_control state for any changes made by scripts,
@@ -588,7 +588,7 @@ static void nv04_dfp_restore(struct drm_
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	int head = nv_encoder->restore.head;
 
-	if (nv_encoder->dcb->type == OUTPUT_LVDS) {
+	if (nv_encoder->dcb->type == DCB_OUTPUT_LVDS) {
 		struct nouveau_connector *connector =
 			nouveau_encoder_connector_get(nv_encoder);
 
@@ -597,7 +597,7 @@ static void nv04_dfp_restore(struct drm_
 					 LVDS_PANEL_ON,
 					 connector->native_mode->clock);
 
-	} else if (nv_encoder->dcb->type == OUTPUT_TMDS) {
+	} else if (nv_encoder->dcb->type == DCB_OUTPUT_TMDS) {
 		int clock = nouveau_hw_pllvals_to_clk
 					(&dev_priv->saved_reg.crtc_reg[head].pllvals);
 
@@ -623,7 +623,7 @@ static void nv04_dfp_destroy(struct drm_
 static void nv04_tmds_slave_init(struct drm_encoder *encoder)
 {
 	struct drm_device *dev = encoder->dev;
-	struct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;
+	struct dcb_output *dcb = nouveau_encoder(encoder)->dcb;
 	struct nouveau_i2c_port *i2c = nouveau_i2c_find(dev, 2);
 	struct i2c_board_info info[] = {
 		{
@@ -676,7 +676,7 @@ static const struct drm_encoder_funcs nv
 };
 
 int
-nv04_dfp_create(struct drm_connector *connector, struct dcb_entry *entry)
+nv04_dfp_create(struct drm_connector *connector, struct dcb_output *entry)
 {
 	const struct drm_encoder_helper_funcs *helper;
 	struct nouveau_encoder *nv_encoder = NULL;
@@ -684,11 +684,11 @@ nv04_dfp_create(struct drm_connector *co
 	int type;
 
 	switch (entry->type) {
-	case OUTPUT_TMDS:
+	case DCB_OUTPUT_TMDS:
 		type = DRM_MODE_ENCODER_TMDS;
 		helper = &nv04_tmds_helper_funcs;
 		break;
-	case OUTPUT_LVDS:
+	case DCB_OUTPUT_LVDS:
 		type = DRM_MODE_ENCODER_LVDS;
 		helper = &nv04_lvds_helper_funcs;
 		break;
@@ -711,7 +711,7 @@ nv04_dfp_create(struct drm_connector *co
 	encoder->possible_crtcs = entry->heads;
 	encoder->possible_clones = 0;
 
-	if (entry->type == OUTPUT_TMDS &&
+	if (entry->type == DCB_OUTPUT_TMDS &&
 	    entry->location != DCB_LOC_ON_CHIP)
 		nv04_tmds_slave_init(encoder);
 
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_display.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv04_display.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_display.c
@@ -34,69 +34,9 @@
 static void nv04_vblank_crtc0_isr(struct drm_device *);
 static void nv04_vblank_crtc1_isr(struct drm_device *);
 
-static void
-nv04_display_store_initial_head_owner(struct drm_device *dev)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-
-	if (dev_priv->chipset != 0x11) {
-		dev_priv->crtc_owner = NVReadVgaCrtc(dev, 0, NV_CIO_CRE_44);
-		return;
-	}
-
-	/* reading CR44 is broken on nv11, so we attempt to infer it */
-	if (nvReadMC(dev, NV_PBUS_DEBUG_1) & (1 << 28))	/* heads tied, restore both */
-		dev_priv->crtc_owner = 0x4;
-	else {
-		uint8_t slaved_on_A, slaved_on_B;
-		bool tvA = false;
-		bool tvB = false;
-
-		slaved_on_B = NVReadVgaCrtc(dev, 1, NV_CIO_CRE_PIXEL_INDEX) &
-									0x80;
-		if (slaved_on_B)
-			tvB = !(NVReadVgaCrtc(dev, 1, NV_CIO_CRE_LCD__INDEX) &
-					MASK(NV_CIO_CRE_LCD_LCD_SELECT));
-
-		slaved_on_A = NVReadVgaCrtc(dev, 0, NV_CIO_CRE_PIXEL_INDEX) &
-									0x80;
-		if (slaved_on_A)
-			tvA = !(NVReadVgaCrtc(dev, 0, NV_CIO_CRE_LCD__INDEX) &
-					MASK(NV_CIO_CRE_LCD_LCD_SELECT));
-
-		if (slaved_on_A && !tvA)
-			dev_priv->crtc_owner = 0x0;
-		else if (slaved_on_B && !tvB)
-			dev_priv->crtc_owner = 0x3;
-		else if (slaved_on_A)
-			dev_priv->crtc_owner = 0x0;
-		else if (slaved_on_B)
-			dev_priv->crtc_owner = 0x3;
-		else
-			dev_priv->crtc_owner = 0x0;
-	}
-}
-
 int
 nv04_display_early_init(struct drm_device *dev)
 {
-	/* Make the I2C buses accessible. */
-	if (!nv_gf4_disp_arch(dev)) {
-		uint32_t pmc_enable = nv_rd32(dev, NV03_PMC_ENABLE);
-
-		if (!(pmc_enable & 1))
-			nv_wr32(dev, NV03_PMC_ENABLE, pmc_enable | 1);
-	}
-
-	/* Unlock the VGA CRTCs. */
-	NVLockVgaCrtcs(dev, false);
-
-	/* Make sure the CRTCs aren't in slaved mode. */
-	if (nv_two_heads(dev)) {
-		nv04_display_store_initial_head_owner(dev);
-		NVSetOwner(dev, 0);
-	}
-
 	/* ensure vblank interrupts are off, they can't be enabled until
 	 * drm_vblank has been initialised
 	 */
@@ -110,12 +50,6 @@ nv04_display_early_init(struct drm_devic
 void
 nv04_display_late_takedown(struct drm_device *dev)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-
-	if (nv_two_heads(dev))
-		NVSetOwner(dev, dev_priv->crtc_owner);
-
-	NVLockVgaCrtcs(dev, true);
 }
 
 int
@@ -137,21 +71,21 @@ nv04_display_create(struct drm_device *d
 		nv04_crtc_create(dev, 1);
 
 	for (i = 0; i < dcb->entries; i++) {
-		struct dcb_entry *dcbent = &dcb->entry[i];
+		struct dcb_output *dcbent = &dcb->entry[i];
 
 		connector = nouveau_connector_create(dev, dcbent->connector);
 		if (IS_ERR(connector))
 			continue;
 
 		switch (dcbent->type) {
-		case OUTPUT_ANALOG:
+		case DCB_OUTPUT_ANALOG:
 			ret = nv04_dac_create(connector, dcbent);
 			break;
-		case OUTPUT_LVDS:
-		case OUTPUT_TMDS:
+		case DCB_OUTPUT_LVDS:
+		case DCB_OUTPUT_TMDS:
 			ret = nv04_dfp_create(connector, dcbent);
 			break;
-		case OUTPUT_TV:
+		case DCB_OUTPUT_TV:
 			if (dcbent->location == DCB_LOC_ON_CHIP)
 				ret = nv17_tv_create(connector, dcbent);
 			else
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_tv.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv04_tv.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv04_tv.c
@@ -181,7 +181,7 @@ static const struct drm_encoder_funcs nv
 };
 
 int
-nv04_tv_create(struct drm_connector *connector, struct dcb_entry *entry)
+nv04_tv_create(struct drm_connector *connector, struct dcb_output *entry)
 {
 	struct nouveau_encoder *nv_encoder;
 	struct drm_encoder *encoder;
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv17_tv.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv17_tv.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv17_tv.c
@@ -144,7 +144,7 @@ nv17_tv_detect(struct drm_encoder *encod
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct drm_mode_config *conf = &dev->mode_config;
 	struct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);
-	struct dcb_entry *dcb = tv_enc->base.dcb;
+	struct dcb_output *dcb = tv_enc->base.dcb;
 	bool reliable = get_tv_detect_quirks(dev, &tv_enc->pin_mask);
 
 	if (nv04_dac_in_use(encoder))
@@ -411,10 +411,10 @@ static void nv17_tv_prepare(struct drm_e
 		struct drm_encoder *enc;
 
 		list_for_each_entry(enc, &dev->mode_config.encoder_list, head) {
-			struct dcb_entry *dcb = nouveau_encoder(enc)->dcb;
+			struct dcb_output *dcb = nouveau_encoder(enc)->dcb;
 
-			if ((dcb->type == OUTPUT_TMDS ||
-			     dcb->type == OUTPUT_LVDS) &&
+			if ((dcb->type == DCB_OUTPUT_TMDS ||
+			     dcb->type == DCB_OUTPUT_LVDS) &&
 			     !enc->crtc &&
 			     nv04_dfp_get_bound_head(dev, dcb) == head) {
 				nv04_dfp_bind_head(dev, dcb, head ^ 1,
@@ -633,7 +633,7 @@ static int nv17_tv_create_resources(stru
 	struct drm_device *dev = encoder->dev;
 	struct drm_mode_config *conf = &dev->mode_config;
 	struct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);
-	struct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;
+	struct dcb_output *dcb = nouveau_encoder(encoder)->dcb;
 	int num_tv_norms = dcb->tvconf.has_component_output ? NUM_TV_NORMS :
 							NUM_LD_TV_NORMS;
 	int i;
@@ -789,7 +789,7 @@ static struct drm_encoder_funcs nv17_tv_
 };
 
 int
-nv17_tv_create(struct drm_connector *connector, struct dcb_entry *entry)
+nv17_tv_create(struct drm_connector *connector, struct dcb_output *entry)
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_encoder *encoder;
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv50_dac.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv50_dac.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv50_dac.c
@@ -224,10 +224,10 @@ nv50_dac_mode_set(struct drm_encoder *en
 		mode_ctl |= NV50_EVO_DAC_MODE_CTRL_CRTC0;
 
 	/* Lacking a working tv-out, this is not a 100% sure. */
-	if (nv_encoder->dcb->type == OUTPUT_ANALOG)
+	if (nv_encoder->dcb->type == DCB_OUTPUT_ANALOG)
 		mode_ctl |= 0x40;
 	else
-	if (nv_encoder->dcb->type == OUTPUT_TV)
+	if (nv_encoder->dcb->type == DCB_OUTPUT_TV)
 		mode_ctl |= 0x100;
 
 	if (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC)
@@ -286,7 +286,7 @@ static const struct drm_encoder_funcs nv
 };
 
 int
-nv50_dac_create(struct drm_connector *connector, struct dcb_entry *entry)
+nv50_dac_create(struct drm_connector *connector, struct dcb_output *entry)
 {
 	struct nouveau_encoder *nv_encoder;
 	struct drm_encoder *encoder;
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv50_display.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv50_display.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv50_display.c
@@ -74,53 +74,9 @@ nv50_display_active_crtcs(struct drm_dev
 	return mask & 3;
 }
 
-static int
-evo_icmd(struct drm_device *dev, int ch, u32 mthd, u32 data)
-{
-	int ret = 0;
-	nv_mask(dev, 0x610300 + (ch * 0x08), 0x00000001, 0x00000001);
-	nv_wr32(dev, 0x610304 + (ch * 0x08), data);
-	nv_wr32(dev, 0x610300 + (ch * 0x08), 0x80000001 | mthd);
-	if (!nv_wait(dev, 0x610300 + (ch * 0x08), 0x80000000, 0x00000000))
-		ret = -EBUSY;
-	if (ret || (nouveau_reg_debug & NOUVEAU_REG_DEBUG_EVO))
-		NV_INFO(dev, "EvoPIO: %d 0x%04x 0x%08x\n", ch, mthd, data);
-	nv_mask(dev, 0x610300 + (ch * 0x08), 0x00000001, 0x00000000);
-	return ret;
-}
-
 int
 nv50_display_early_init(struct drm_device *dev)
 {
-	u32 ctrl = nv_rd32(dev, 0x610200);
-	int i;
-
-	/* check if master evo channel is already active, a good a sign as any
-	 * that the display engine is in a weird state (hibernate/kexec), if
-	 * it is, do our best to reset the display engine...
-	 */
-	if ((ctrl & 0x00000003) == 0x00000003) {
-		NV_INFO(dev, "PDISP: EVO(0) 0x%08x, resetting...\n", ctrl);
-
-		/* deactivate both heads first, PDISP will disappear forever
-		 * (well, until you power cycle) on some boards as soon as
-		 * PMC_ENABLE is hit unless they are..
-		 */
-		for (i = 0; i < 2; i++) {
-			evo_icmd(dev, 0, 0x0880 + (i * 0x400), 0x05000000);
-			evo_icmd(dev, 0, 0x089c + (i * 0x400), 0);
-			evo_icmd(dev, 0, 0x0840 + (i * 0x400), 0);
-			evo_icmd(dev, 0, 0x0844 + (i * 0x400), 0);
-			evo_icmd(dev, 0, 0x085c + (i * 0x400), 0);
-			evo_icmd(dev, 0, 0x0874 + (i * 0x400), 0);
-		}
-		evo_icmd(dev, 0, 0x0080, 0);
-
-		/* reset PDISP */
-		nv_mask(dev, 0x000200, 0x40000000, 0x00000000);
-		nv_mask(dev, 0x000200, 0x40000000, 0x40000000);
-	}
-
 	return 0;
 }
 
@@ -367,7 +323,7 @@ nv50_display_create(struct drm_device *d
 
 	/* We setup the encoders from the BIOS table */
 	for (i = 0 ; i < dcb->entries; i++) {
-		struct dcb_entry *entry = &dcb->entry[i];
+		struct dcb_output *entry = &dcb->entry[i];
 
 		if (entry->location != DCB_LOC_ON_CHIP) {
 			NV_WARN(dev, "Off-chip encoder %d/%d unsupported\n",
@@ -380,12 +336,12 @@ nv50_display_create(struct drm_device *d
 			continue;
 
 		switch (entry->type) {
-		case OUTPUT_TMDS:
-		case OUTPUT_LVDS:
-		case OUTPUT_DP:
+		case DCB_OUTPUT_TMDS:
+		case DCB_OUTPUT_LVDS:
+		case DCB_OUTPUT_DP:
 			nv50_sor_create(connector, entry);
 			break;
-		case OUTPUT_ANALOG:
+		case DCB_OUTPUT_ANALOG:
 			nv50_dac_create(connector, entry);
 			break;
 		default:
@@ -555,7 +511,7 @@ nv50_display_flip_next(struct drm_crtc *
 }
 
 static u16
-nv50_display_script_select(struct drm_device *dev, struct dcb_entry *dcb,
+nv50_display_script_select(struct drm_device *dev, struct dcb_output *dcb,
 			   u32 mc, int pxclk)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
@@ -576,7 +532,7 @@ nv50_display_script_select(struct drm_de
 
 	or = ffs(dcb->or) - 1;
 	switch (dcb->type) {
-	case OUTPUT_LVDS:
+	case DCB_OUTPUT_LVDS:
 		script = (mc >> 8) & 0xf;
 		if (bios->fp_no_ddc) {
 			if (bios->fp.dual_link)
@@ -617,7 +573,7 @@ nv50_display_script_select(struct drm_de
 			script = nouveau_uscript_lvds;
 		}
 		break;
-	case OUTPUT_TMDS:
+	case DCB_OUTPUT_TMDS:
 		script = (mc >> 8) & 0xf;
 		if (pxclk >= 165000)
 			script |= 0x0100;
@@ -629,10 +585,10 @@ nv50_display_script_select(struct drm_de
 			script = nouveau_uscript_tmds;
 		}
 		break;
-	case OUTPUT_DP:
+	case DCB_OUTPUT_DP:
 		script = (mc >> 8) & 0xf;
 		break;
-	case OUTPUT_ANALOG:
+	case DCB_OUTPUT_ANALOG:
 		script = 0xff;
 		break;
 	default:
@@ -691,7 +647,7 @@ nv50_display_unk10_handler(struct drm_de
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nv50_display *disp = nv50_display(dev);
 	u32 unk30 = nv_rd32(dev, 0x610030), mc;
-	int i, crtc, or = 0, type = OUTPUT_ANY;
+	int i, crtc, or = 0, type = DCB_OUTPUT_ANY;
 
 	NV_DEBUG_KMS(dev, "0x610030: 0x%08x\n", unk30);
 	disp->irq.dcb = NULL;
@@ -711,15 +667,15 @@ nv50_display_unk10_handler(struct drm_de
 		goto ack;
 
 	/* Find which encoder was connected to the CRTC */
-	for (i = 0; type == OUTPUT_ANY && i < 3; i++) {
+	for (i = 0; type == DCB_OUTPUT_ANY && i < 3; i++) {
 		mc = nv_rd32(dev, NV50_PDISPLAY_DAC_MODE_CTRL_C(i));
 		NV_DEBUG_KMS(dev, "DAC-%d mc: 0x%08x\n", i, mc);
 		if (!(mc & (1 << crtc)))
 			continue;
 
 		switch ((mc & 0x00000f00) >> 8) {
-		case 0: type = OUTPUT_ANALOG; break;
-		case 1: type = OUTPUT_TV; break;
+		case 0: type = DCB_OUTPUT_ANALOG; break;
+		case 1: type = DCB_OUTPUT_TV; break;
 		default:
 			NV_ERROR(dev, "invalid mc, DAC-%d: 0x%08x\n", i, mc);
 			goto ack;
@@ -728,7 +684,7 @@ nv50_display_unk10_handler(struct drm_de
 		or = i;
 	}
 
-	for (i = 0; type == OUTPUT_ANY && i < nv50_sor_nr(dev); i++) {
+	for (i = 0; type == DCB_OUTPUT_ANY && i < nv50_sor_nr(dev); i++) {
 		if (dev_priv->chipset  < 0x90 ||
 		    dev_priv->chipset == 0x92 ||
 		    dev_priv->chipset == 0xa0)
@@ -741,12 +697,12 @@ nv50_display_unk10_handler(struct drm_de
 			continue;
 
 		switch ((mc & 0x00000f00) >> 8) {
-		case 0: type = OUTPUT_LVDS; break;
-		case 1: type = OUTPUT_TMDS; break;
-		case 2: type = OUTPUT_TMDS; break;
-		case 5: type = OUTPUT_TMDS; break;
-		case 8: type = OUTPUT_DP; break;
-		case 9: type = OUTPUT_DP; break;
+		case 0: type = DCB_OUTPUT_LVDS; break;
+		case 1: type = DCB_OUTPUT_TMDS; break;
+		case 2: type = DCB_OUTPUT_TMDS; break;
+		case 5: type = DCB_OUTPUT_TMDS; break;
+		case 8: type = DCB_OUTPUT_DP; break;
+		case 9: type = DCB_OUTPUT_DP; break;
 		default:
 			NV_ERROR(dev, "invalid mc, SOR-%d: 0x%08x\n", i, mc);
 			goto ack;
@@ -756,12 +712,12 @@ nv50_display_unk10_handler(struct drm_de
 	}
 
 	/* There was no encoder to disable */
-	if (type == OUTPUT_ANY)
+	if (type == DCB_OUTPUT_ANY)
 		goto ack;
 
 	/* Disable the encoder */
 	for (i = 0; i < dev_priv->vbios.dcb.entries; i++) {
-		struct dcb_entry *dcb = &dev_priv->vbios.dcb.entry[i];
+		struct dcb_output *dcb = &dev_priv->vbios.dcb.entry[i];
 
 		if (dcb->type == type && (dcb->or & (1 << or))) {
 			nouveau_bios_run_display_table(dev, 0, -1, dcb, -1);
@@ -782,8 +738,8 @@ nv50_display_unk20_handler(struct drm_de
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nv50_display *disp = nv50_display(dev);
 	u32 unk30 = nv_rd32(dev, 0x610030), tmp, pclk, script, mc = 0;
-	struct dcb_entry *dcb;
-	int i, crtc, or = 0, type = OUTPUT_ANY;
+	struct dcb_output *dcb;
+	int i, crtc, or = 0, type = DCB_OUTPUT_ANY;
 
 	NV_DEBUG_KMS(dev, "0x610030: 0x%08x\n", unk30);
 	dcb = disp->irq.dcb;
@@ -812,15 +768,15 @@ nv50_display_unk20_handler(struct drm_de
 	pclk  = nv_rd32(dev, NV50_PDISPLAY_CRTC_P(crtc, CLOCK)) & 0x003fffff;
 
 	/* Find which encoder is connected to the CRTC */
-	for (i = 0; type == OUTPUT_ANY && i < 3; i++) {
+	for (i = 0; type == DCB_OUTPUT_ANY && i < 3; i++) {
 		mc = nv_rd32(dev, NV50_PDISPLAY_DAC_MODE_CTRL_P(i));
 		NV_DEBUG_KMS(dev, "DAC-%d mc: 0x%08x\n", i, mc);
 		if (!(mc & (1 << crtc)))
 			continue;
 
 		switch ((mc & 0x00000f00) >> 8) {
-		case 0: type = OUTPUT_ANALOG; break;
-		case 1: type = OUTPUT_TV; break;
+		case 0: type = DCB_OUTPUT_ANALOG; break;
+		case 1: type = DCB_OUTPUT_TV; break;
 		default:
 			NV_ERROR(dev, "invalid mc, DAC-%d: 0x%08x\n", i, mc);
 			goto ack;
@@ -829,7 +785,7 @@ nv50_display_unk20_handler(struct drm_de
 		or = i;
 	}
 
-	for (i = 0; type == OUTPUT_ANY && i < nv50_sor_nr(dev); i++) {
+	for (i = 0; type == DCB_OUTPUT_ANY && i < nv50_sor_nr(dev); i++) {
 		if (dev_priv->chipset  < 0x90 ||
 		    dev_priv->chipset == 0x92 ||
 		    dev_priv->chipset == 0xa0)
@@ -842,12 +798,12 @@ nv50_display_unk20_handler(struct drm_de
 			continue;
 
 		switch ((mc & 0x00000f00) >> 8) {
-		case 0: type = OUTPUT_LVDS; break;
-		case 1: type = OUTPUT_TMDS; break;
-		case 2: type = OUTPUT_TMDS; break;
-		case 5: type = OUTPUT_TMDS; break;
-		case 8: type = OUTPUT_DP; break;
-		case 9: type = OUTPUT_DP; break;
+		case 0: type = DCB_OUTPUT_LVDS; break;
+		case 1: type = DCB_OUTPUT_TMDS; break;
+		case 2: type = DCB_OUTPUT_TMDS; break;
+		case 5: type = DCB_OUTPUT_TMDS; break;
+		case 8: type = DCB_OUTPUT_DP; break;
+		case 9: type = DCB_OUTPUT_DP; break;
 		default:
 			NV_ERROR(dev, "invalid mc, SOR-%d: 0x%08x\n", i, mc);
 			goto ack;
@@ -856,7 +812,7 @@ nv50_display_unk20_handler(struct drm_de
 		or = i;
 	}
 
-	if (type == OUTPUT_ANY)
+	if (type == DCB_OUTPUT_ANY)
 		goto ack;
 
 	/* Enable the encoder */
@@ -874,7 +830,7 @@ nv50_display_unk20_handler(struct drm_de
 	script = nv50_display_script_select(dev, dcb, mc, pclk);
 	nouveau_bios_run_display_table(dev, script, pclk, dcb, -1);
 
-	if (type == OUTPUT_DP) {
+	if (type == DCB_OUTPUT_DP) {
 		int link = !(dcb->dpconf.sor.link & 1);
 		if ((mc & 0x000f0000) == 0x00020000)
 			nv50_sor_dp_calc_tu(dev, or, link, pclk, 18);
@@ -882,7 +838,7 @@ nv50_display_unk20_handler(struct drm_de
 			nv50_sor_dp_calc_tu(dev, or, link, pclk, 24);
 	}
 
-	if (dcb->type != OUTPUT_ANALOG) {
+	if (dcb->type != DCB_OUTPUT_ANALOG) {
 		tmp = nv_rd32(dev, NV50_PDISPLAY_SOR_CLK_CTRL2(or));
 		tmp &= ~0x00000f0f;
 		if (script & 0x0100)
@@ -910,19 +866,19 @@ ack:
  * programmed for DisplayPort.
  */
 static void
-nv50_display_unk40_dp_set_tmds(struct drm_device *dev, struct dcb_entry *dcb)
+nv50_display_unk40_dp_set_tmds(struct drm_device *dev, struct dcb_output *dcb)
 {
 	int or = ffs(dcb->or) - 1, link = !(dcb->dpconf.sor.link & 1);
 	struct drm_encoder *encoder;
 	u32 tmp;
 
-	if (dcb->type != OUTPUT_TMDS)
+	if (dcb->type != DCB_OUTPUT_TMDS)
 		return;
 
 	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 		struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
 
-		if (nv_encoder->dcb->type == OUTPUT_DP &&
+		if (nv_encoder->dcb->type == DCB_OUTPUT_DP &&
 		    nv_encoder->dcb->or & (1 << or)) {
 			tmp  = nv_rd32(dev, NV50_SOR_DP_CTRL(or, link));
 			tmp &= ~NV50_SOR_DP_CTRL_ENABLED;
@@ -936,7 +892,7 @@ static void
 nv50_display_unk40_handler(struct drm_device *dev)
 {
 	struct nv50_display *disp = nv50_display(dev);
-	struct dcb_entry *dcb = disp->irq.dcb;
+	struct dcb_output *dcb = disp->irq.dcb;
 	u16 script = disp->irq.script;
 	u32 unk30 = nv_rd32(dev, 0x610030), pclk = disp->irq.pclk;
 
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv50_display.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv50_display.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv50_display.h
@@ -52,7 +52,7 @@ struct nv50_display {
 
 	struct tasklet_struct tasklet;
 	struct {
-		struct dcb_entry *dcb;
+		struct dcb_output *dcb;
 		u16 script;
 		u32 pclk;
 	} irq;
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv50_sor.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nv50_sor.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nv50_sor.c
@@ -37,7 +37,7 @@
 #include "nv50_display.h"
 
 static u32
-nv50_sor_dp_lane_map(struct drm_device *dev, struct dcb_entry *dcb, u8 lane)
+nv50_sor_dp_lane_map(struct drm_device *dev, struct dcb_output *dcb, u8 lane)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	static const u8 nvaf[] = { 24, 16, 8, 0 }; /* thanks, apple.. */
@@ -48,14 +48,14 @@ nv50_sor_dp_lane_map(struct drm_device *
 }
 
 static void
-nv50_sor_dp_train_set(struct drm_device *dev, struct dcb_entry *dcb, u8 pattern)
+nv50_sor_dp_train_set(struct drm_device *dev, struct dcb_output *dcb, u8 pattern)
 {
 	u32 or = ffs(dcb->or) - 1, link = !(dcb->sorconf.link & 1);
 	nv_mask(dev, NV50_SOR_DP_CTRL(or, link), 0x0f000000, pattern << 24);
 }
 
 static void
-nv50_sor_dp_train_adj(struct drm_device *dev, struct dcb_entry *dcb,
+nv50_sor_dp_train_adj(struct drm_device *dev, struct dcb_output *dcb,
 		      u8 lane, u8 swing, u8 preem)
 {
 	u32 or = ffs(dcb->or) - 1, link = !(dcb->sorconf.link & 1);
@@ -82,7 +82,7 @@ nv50_sor_dp_train_adj(struct drm_device
 }
 
 static void
-nv50_sor_dp_link_set(struct drm_device *dev, struct dcb_entry *dcb, int crtc,
+nv50_sor_dp_link_set(struct drm_device *dev, struct dcb_output *dcb, int crtc,
 		     int link_nr, u32 link_bw, bool enhframe)
 {
 	u32 or = ffs(dcb->or) - 1, link = !(dcb->sorconf.link & 1);
@@ -269,9 +269,9 @@ nv50_sor_dpms(struct drm_encoder *encode
 		struct nouveau_encoder *nvenc = nouveau_encoder(enc);
 
 		if (nvenc == nv_encoder ||
-		    (nvenc->dcb->type != OUTPUT_TMDS &&
-		     nvenc->dcb->type != OUTPUT_LVDS &&
-		     nvenc->dcb->type != OUTPUT_DP) ||
+		    (nvenc->dcb->type != DCB_OUTPUT_TMDS &&
+		     nvenc->dcb->type != DCB_OUTPUT_LVDS &&
+		     nvenc->dcb->type != DCB_OUTPUT_DP) ||
 		    nvenc->dcb->or != nv_encoder->dcb->or)
 			continue;
 
@@ -303,7 +303,7 @@ nv50_sor_dpms(struct drm_encoder *encode
 			 nv_rd32(dev, NV50_PDISPLAY_SOR_DPMS_STATE(or)));
 	}
 
-	if (nv_encoder->dcb->type == OUTPUT_DP) {
+	if (nv_encoder->dcb->type == DCB_OUTPUT_DP) {
 		struct dp_train_func func = {
 			.link_set = nv50_sor_dp_link_set,
 			.train_set = nv50_sor_dp_train_set,
@@ -354,7 +354,7 @@ nv50_sor_prepare(struct drm_encoder *enc
 {
 	struct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);
 	nv50_sor_disconnect(encoder);
-	if (nv_encoder->dcb->type == OUTPUT_DP) {
+	if (nv_encoder->dcb->type == DCB_OUTPUT_DP) {
 		/* avoid race between link training and supervisor intr */
 		nv50_display_sync(encoder->dev);
 	}
@@ -382,7 +382,7 @@ nv50_sor_mode_set(struct drm_encoder *en
 	nv_encoder->crtc = encoder->crtc;
 
 	switch (nv_encoder->dcb->type) {
-	case OUTPUT_TMDS:
+	case DCB_OUTPUT_TMDS:
 		if (nv_encoder->dcb->sorconf.link & 1) {
 			if (mode->clock < 165000)
 				mode_ctl = 0x0100;
@@ -393,7 +393,7 @@ nv50_sor_mode_set(struct drm_encoder *en
 
 		nouveau_hdmi_mode_set(encoder, mode);
 		break;
-	case OUTPUT_DP:
+	case DCB_OUTPUT_DP:
 		nv_connector = nouveau_encoder_connector_get(nv_encoder);
 		if (nv_connector && nv_connector->base.display_info.bpc == 6) {
 			nv_encoder->dp.datarate = mode->clock * 18 / 8;
@@ -474,7 +474,7 @@ static const struct drm_encoder_funcs nv
 };
 
 int
-nv50_sor_create(struct drm_connector *connector, struct dcb_entry *entry)
+nv50_sor_create(struct drm_connector *connector, struct dcb_output *entry)
 {
 	struct nouveau_encoder *nv_encoder = NULL;
 	struct drm_device *dev = connector->dev;
@@ -484,11 +484,11 @@ nv50_sor_create(struct drm_connector *co
 	NV_DEBUG_KMS(dev, "\n");
 
 	switch (entry->type) {
-	case OUTPUT_TMDS:
-	case OUTPUT_DP:
+	case DCB_OUTPUT_TMDS:
+	case DCB_OUTPUT_DP:
 		type = DRM_MODE_ENCODER_TMDS;
 		break;
-	case OUTPUT_LVDS:
+	case DCB_OUTPUT_LVDS:
 		type = DRM_MODE_ENCODER_LVDS;
 		break;
 	default:
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nvd0_display.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nvd0_display.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nvd0_display.c
@@ -1063,7 +1063,7 @@ static const struct drm_encoder_funcs nv
 };
 
 static int
-nvd0_dac_create(struct drm_connector *connector, struct dcb_entry *dcbe)
+nvd0_dac_create(struct drm_connector *connector, struct dcb_output *dcbe)
 {
 	struct drm_device *dev = connector->dev;
 	struct nouveau_encoder *nv_encoder;
@@ -1191,14 +1191,14 @@ nvd0_hdmi_disconnect(struct drm_encoder
  * SOR
  *****************************************************************************/
 static inline u32
-nvd0_sor_dp_lane_map(struct drm_device *dev, struct dcb_entry *dcb, u8 lane)
+nvd0_sor_dp_lane_map(struct drm_device *dev, struct dcb_output *dcb, u8 lane)
 {
 	static const u8 nvd0[] = { 16, 8, 0, 24 };
 	return nvd0[lane];
 }
 
 static void
-nvd0_sor_dp_train_set(struct drm_device *dev, struct dcb_entry *dcb, u8 pattern)
+nvd0_sor_dp_train_set(struct drm_device *dev, struct dcb_output *dcb, u8 pattern)
 {
 	const u32 or = ffs(dcb->or) - 1, link = !(dcb->sorconf.link & 1);
 	const u32 loff = (or * 0x800) + (link * 0x80);
@@ -1206,7 +1206,7 @@ nvd0_sor_dp_train_set(struct drm_device
 }
 
 static void
-nvd0_sor_dp_train_adj(struct drm_device *dev, struct dcb_entry *dcb,
+nvd0_sor_dp_train_adj(struct drm_device *dev, struct dcb_output *dcb,
 		      u8 lane, u8 swing, u8 preem)
 {
 	const u32 or = ffs(dcb->or) - 1, link = !(dcb->sorconf.link & 1);
@@ -1247,7 +1247,7 @@ nvd0_sor_dp_train_adj(struct drm_device
 }
 
 static void
-nvd0_sor_dp_link_set(struct drm_device *dev, struct dcb_entry *dcb, int crtc,
+nvd0_sor_dp_link_set(struct drm_device *dev, struct dcb_output *dcb, int crtc,
 		     int link_nr, u32 link_bw, bool enhframe)
 {
 	const u32 or = ffs(dcb->or) - 1, link = !(dcb->sorconf.link & 1);
@@ -1290,7 +1290,7 @@ nvd0_sor_dp_link_set(struct drm_device *
 }
 
 static void
-nvd0_sor_dp_link_get(struct drm_device *dev, struct dcb_entry *dcb,
+nvd0_sor_dp_link_get(struct drm_device *dev, struct dcb_output *dcb,
 		     u32 *link_nr, u32 *link_bw)
 {
 	const u32 or = ffs(dcb->or) - 1, link = !(dcb->sorconf.link & 1);
@@ -1308,7 +1308,7 @@ nvd0_sor_dp_link_get(struct drm_device *
 }
 
 static void
-nvd0_sor_dp_calc_tu(struct drm_device *dev, struct dcb_entry *dcb,
+nvd0_sor_dp_calc_tu(struct drm_device *dev, struct dcb_output *dcb,
 		    u32 crtc, u32 datarate)
 {
 	const u32 symbol = 100000;
@@ -1366,7 +1366,7 @@ nvd0_sor_dpms(struct drm_encoder *encode
 	nv_wait(dev, 0x61c004 + (or * 0x0800), 0x80000000, 0x00000000);
 	nv_wait(dev, 0x61c030 + (or * 0x0800), 0x10000000, 0x00000000);
 
-	if (nv_encoder->dcb->type == OUTPUT_DP) {
+	if (nv_encoder->dcb->type == DCB_OUTPUT_DP) {
 		struct dp_train_func func = {
 			.link_set = nvd0_sor_dp_link_set,
 			.train_set = nvd0_sor_dp_train_set,
@@ -1427,7 +1427,7 @@ static void
 nvd0_sor_prepare(struct drm_encoder *encoder)
 {
 	nvd0_sor_disconnect(encoder);
-	if (nouveau_encoder(encoder)->dcb->type == OUTPUT_DP)
+	if (nouveau_encoder(encoder)->dcb->type == DCB_OUTPUT_DP)
 		evo_sync(encoder->dev, EVO_MASTER);
 }
 
@@ -1462,7 +1462,7 @@ nvd0_sor_mode_set(struct drm_encoder *en
 
 	nv_connector = nouveau_encoder_connector_get(nv_encoder);
 	switch (nv_encoder->dcb->type) {
-	case OUTPUT_TMDS:
+	case DCB_OUTPUT_TMDS:
 		if (nv_encoder->dcb->sorconf.link & 1) {
 			if (mode->clock < 165000)
 				mode_ctrl |= 0x00000100;
@@ -1478,7 +1478,7 @@ nvd0_sor_mode_set(struct drm_encoder *en
 
 		nvd0_hdmi_mode_set(encoder, mode);
 		break;
-	case OUTPUT_LVDS:
+	case DCB_OUTPUT_LVDS:
 		or_config = (mode_ctrl & 0x00000f00) >> 8;
 		if (bios->fp_no_ddc) {
 			if (bios->fp.dual_link)
@@ -1507,7 +1507,7 @@ nvd0_sor_mode_set(struct drm_encoder *en
 
 		}
 		break;
-	case OUTPUT_DP:
+	case DCB_OUTPUT_DP:
 		if (nv_connector->base.display_info.bpc == 6) {
 			nv_encoder->dp.datarate = mode->clock * 18 / 8;
 			syncs |= 0x00000002 << 6;
@@ -1530,7 +1530,7 @@ nvd0_sor_mode_set(struct drm_encoder *en
 
 	nvd0_sor_dpms(encoder, DRM_MODE_DPMS_ON);
 
-	if (nv_encoder->dcb->type == OUTPUT_DP) {
+	if (nv_encoder->dcb->type == DCB_OUTPUT_DP) {
 		nvd0_sor_dp_calc_tu(dev, nv_encoder->dcb, nv_crtc->index,
 					 nv_encoder->dp.datarate);
 	}
@@ -1571,7 +1571,7 @@ static const struct drm_encoder_funcs nv
 };
 
 static int
-nvd0_sor_create(struct drm_connector *connector, struct dcb_entry *dcbe)
+nvd0_sor_create(struct drm_connector *connector, struct dcb_output *dcbe)
 {
 	struct drm_device *dev = connector->dev;
 	struct nouveau_encoder *nv_encoder;
@@ -1597,23 +1597,23 @@ nvd0_sor_create(struct drm_connector *co
 /******************************************************************************
  * IRQ
  *****************************************************************************/
-static struct dcb_entry *
+static struct dcb_output *
 lookup_dcb(struct drm_device *dev, int id, u32 mc)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	int type, or, i, link = -1;
 
 	if (id < 4) {
-		type = OUTPUT_ANALOG;
+		type = DCB_OUTPUT_ANALOG;
 		or   = id;
 	} else {
 		switch (mc & 0x00000f00) {
-		case 0x00000000: link = 0; type = OUTPUT_LVDS; break;
-		case 0x00000100: link = 0; type = OUTPUT_TMDS; break;
-		case 0x00000200: link = 1; type = OUTPUT_TMDS; break;
-		case 0x00000500: link = 0; type = OUTPUT_TMDS; break;
-		case 0x00000800: link = 0; type = OUTPUT_DP; break;
-		case 0x00000900: link = 1; type = OUTPUT_DP; break;
+		case 0x00000000: link = 0; type = DCB_OUTPUT_LVDS; break;
+		case 0x00000100: link = 0; type = DCB_OUTPUT_TMDS; break;
+		case 0x00000200: link = 1; type = DCB_OUTPUT_TMDS; break;
+		case 0x00000500: link = 0; type = DCB_OUTPUT_TMDS; break;
+		case 0x00000800: link = 0; type = DCB_OUTPUT_DP; break;
+		case 0x00000900: link = 1; type = DCB_OUTPUT_DP; break;
 		default:
 			NV_ERROR(dev, "PDISP: unknown SOR mc 0x%08x\n", mc);
 			return NULL;
@@ -1623,7 +1623,7 @@ lookup_dcb(struct drm_device *dev, int i
 	}
 
 	for (i = 0; i < dev_priv->vbios.dcb.entries; i++) {
-		struct dcb_entry *dcb = &dev_priv->vbios.dcb.entry[i];
+		struct dcb_output *dcb = &dev_priv->vbios.dcb.entry[i];
 		if (dcb->type == type && (dcb->or & (1 << or)) &&
 		    (link < 0 || link == !(dcb->sorconf.link & 1)))
 			return dcb;
@@ -1636,7 +1636,7 @@ lookup_dcb(struct drm_device *dev, int i
 static void
 nvd0_display_unk1_handler(struct drm_device *dev, u32 crtc, u32 mask)
 {
-	struct dcb_entry *dcb;
+	struct dcb_output *dcb;
 	int i;
 
 	for (i = 0; mask && i < 8; i++) {
@@ -1659,7 +1659,7 @@ nvd0_display_unk1_handler(struct drm_dev
 static void
 nvd0_display_unk2_handler(struct drm_device *dev, u32 crtc, u32 mask)
 {
-	struct dcb_entry *dcb;
+	struct dcb_output *dcb;
 	u32 or, tmp, pclk;
 	int i;
 
@@ -1697,12 +1697,12 @@ nvd0_display_unk2_handler(struct drm_dev
 
 		nv_wr32(dev, 0x612200 + (crtc * 0x800), 0x00000000);
 		switch (dcb->type) {
-		case OUTPUT_ANALOG:
+		case DCB_OUTPUT_ANALOG:
 			nv_wr32(dev, 0x612280 + (or * 0x800), 0x00000000);
 			break;
-		case OUTPUT_TMDS:
-		case OUTPUT_LVDS:
-		case OUTPUT_DP:
+		case DCB_OUTPUT_TMDS:
+		case DCB_OUTPUT_LVDS:
+		case DCB_OUTPUT_DP:
 			if (cfg & 0x00000100)
 				tmp = 0x00000101;
 			else
@@ -1725,7 +1725,7 @@ nvd0_display_unk2_handler(struct drm_dev
 static void
 nvd0_display_unk4_handler(struct drm_device *dev, u32 crtc, u32 mask)
 {
-	struct dcb_entry *dcb;
+	struct dcb_output *dcb;
 	int pclk, i;
 
 	pclk = nv_rd32(dev, 0x660450 + (crtc * 0x300)) / 1000;
@@ -1972,7 +1972,7 @@ nvd0_display_create(struct drm_device *d
 	struct drm_connector *connector, *tmp;
 	struct pci_dev *pdev = dev->pdev;
 	struct nvd0_display *disp;
-	struct dcb_entry *dcbe;
+	struct dcb_output *dcbe;
 	int crtcs, ret, i;
 
 	disp = kzalloc(sizeof(*disp), GFP_KERNEL);
@@ -2001,12 +2001,12 @@ nvd0_display_create(struct drm_device *d
 		}
 
 		switch (dcbe->type) {
-		case OUTPUT_TMDS:
-		case OUTPUT_LVDS:
-		case OUTPUT_DP:
+		case DCB_OUTPUT_TMDS:
+		case DCB_OUTPUT_LVDS:
+		case DCB_OUTPUT_DP:
 			nvd0_sor_create(connector, dcbe);
 			break;
-		case OUTPUT_ANALOG:
+		case DCB_OUTPUT_ANALOG:
 			nvd0_dac_create(connector, dcbe);
 			break;
 		default:
