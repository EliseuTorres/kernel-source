From 26ec685ff9d9c16525d8ec4c97e52fcdb187b302 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Fri, 11 May 2012 07:51:17 +0200
Subject: vga_switcheroo: Introduce struct vga_switcheroo_client_ops
Git-commit: 26ec685ff9d9c16525d8ec4c97e52fcdb187b302
Patch-mainline: v3.5-rc1

This changes the API as a clean-up.  Instead of passing multiple
function pointers at each time, introduce a new struct holding the
whole callback functions and pass it to the registration.

The same struct will be used for the upcoming audio client
registration, too.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/i915/i915_dma.c         |   11 +++++++----
 drivers/gpu/drm/nouveau/nouveau_state.c |   10 +++++++---
 drivers/gpu/drm/radeon/radeon_device.c  |   10 ++++++----
 drivers/gpu/vga/vga_switcheroo.c        |   22 ++++++++--------------
 include/linux/vga_switcheroo.h          |   13 +++++++------
 5 files changed, 35 insertions(+), 31 deletions(-)

Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/i915/i915_dma.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/i915/i915_dma.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/i915/i915_dma.c
@@ -1271,6 +1271,12 @@ static bool i915_switcheroo_can_switch(s
 	return can_switch;
 }
 
+static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
+	.set_gpu_state = i915_switcheroo_set_state,
+	.reprobe = NULL,
+	.can_switch = i915_switcheroo_can_switch,
+};
+
 static int i915_load_modeset_init(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
@@ -1293,10 +1299,7 @@ static int i915_load_modeset_init(struct
 
 	intel_register_dsm_handler();
 
-	ret = vga_switcheroo_register_client(dev->pdev,
-					     i915_switcheroo_set_state,
-					     NULL,
-					     i915_switcheroo_can_switch);
+	ret = vga_switcheroo_register_client(dev->pdev, &i915_switcheroo_ops);
 	if (ret)
 		goto cleanup_vga_client;
 
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_state.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_state.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_state.c
@@ -662,6 +662,12 @@ error:
 	return ret;
 }
 
+static const struct vga_switcheroo_client_ops nouveau_switcheroo_ops = {
+	.set_gpu_state = nouveau_switcheroo_set_state,
+	.reprobe = nouveau_switcheroo_reprobe,
+	.can_switch = nouveau_switcheroo_can_switch,
+};
+
 int
 nouveau_card_init(struct drm_device *dev)
 {
@@ -670,9 +676,7 @@ nouveau_card_init(struct drm_device *dev
 	int ret, e = 0;
 
 	vga_client_register(dev->pdev, dev, NULL, nouveau_vga_set_decode);
-	vga_switcheroo_register_client(dev->pdev, nouveau_switcheroo_set_state,
-				       nouveau_switcheroo_reprobe,
-				       nouveau_switcheroo_can_switch);
+	vga_switcheroo_register_client(dev->pdev, &nouveau_switcheroo_ops);
 
 	/* Initialise internal driver API hooks */
 	ret = nouveau_init_engine_ptrs(dev);
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/radeon/radeon_device.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/radeon/radeon_device.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/radeon/radeon_device.c
@@ -697,6 +697,11 @@ static bool radeon_switcheroo_can_switch
 	return can_switch;
 }
 
+static const struct vga_switcheroo_client_ops radeon_switcheroo_ops = {
+	.set_gpu_state = radeon_switcheroo_set_state,
+	.reprobe = NULL,
+	.can_switch = radeon_switcheroo_can_switch,
+};
 
 int radeon_device_init(struct radeon_device *rdev,
 		       struct drm_device *ddev,
@@ -809,10 +814,7 @@ int radeon_device_init(struct radeon_dev
 	/* this will fail for cards that aren't VGA class devices, just
 	 * ignore it */
 	vga_client_register(rdev->pdev, rdev, NULL, radeon_vga_set_decode);
-	vga_switcheroo_register_client(rdev->pdev,
-				       radeon_switcheroo_set_state,
-				       NULL,
-				       radeon_switcheroo_can_switch);
+	vga_switcheroo_register_client(rdev->pdev, &radeon_switcheroo_ops);
 
 	r = radeon_init(rdev);
 	if (r)
Index: linux-3.0-SLE11-SP3/drivers/gpu/vga/vga_switcheroo.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/vga/vga_switcheroo.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/vga/vga_switcheroo.c
@@ -32,9 +32,7 @@ struct vga_switcheroo_client {
 	struct pci_dev *pdev;
 	struct fb_info *fb_info;
 	int pwr_state;
-	void (*set_gpu_state)(struct pci_dev *pdev, enum vga_switcheroo_state);
-	void (*reprobe)(struct pci_dev *pdev);
-	bool (*can_switch)(struct pci_dev *pdev);
+	const struct vga_switcheroo_client_ops *ops;
 	int id;
 	bool active;
 };
@@ -103,9 +101,7 @@ static void vga_switcheroo_enable(void)
 }
 
 int vga_switcheroo_register_client(struct pci_dev *pdev,
-				   void (*set_gpu_state)(struct pci_dev *pdev, enum vga_switcheroo_state),
-				   void (*reprobe)(struct pci_dev *pdev),
-				   bool (*can_switch)(struct pci_dev *pdev))
+				   const struct vga_switcheroo_client_ops *ops)
 {
 	int index;
 
@@ -118,9 +114,7 @@ int vga_switcheroo_register_client(struc
 
 	vgasr_priv.clients[index].pwr_state = VGA_SWITCHEROO_ON;
 	vgasr_priv.clients[index].pdev = pdev;
-	vgasr_priv.clients[index].set_gpu_state = set_gpu_state;
-	vgasr_priv.clients[index].reprobe = reprobe;
-	vgasr_priv.clients[index].can_switch = can_switch;
+	vgasr_priv.clients[index].ops = ops;
 	vgasr_priv.clients[index].id = -1;
 	if (pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW)
 		vgasr_priv.clients[index].active = true;
@@ -197,7 +191,7 @@ static int vga_switchon(struct vga_switc
 	if (vgasr_priv.handler->power_state)
 		vgasr_priv.handler->power_state(client->id, VGA_SWITCHEROO_ON);
 	/* call the driver callback to turn on device */
-	client->set_gpu_state(client->pdev, VGA_SWITCHEROO_ON);
+	client->ops->set_gpu_state(client->pdev, VGA_SWITCHEROO_ON);
 	client->pwr_state = VGA_SWITCHEROO_ON;
 	return 0;
 }
@@ -205,7 +199,7 @@ static int vga_switchon(struct vga_switc
 static int vga_switchoff(struct vga_switcheroo_client *client)
 {
 	/* call the driver callback to turn off device */
-	client->set_gpu_state(client->pdev, VGA_SWITCHEROO_OFF);
+	client->ops->set_gpu_state(client->pdev, VGA_SWITCHEROO_OFF);
 	if (vgasr_priv.handler->power_state)
 		vgasr_priv.handler->power_state(client->id, VGA_SWITCHEROO_OFF);
 	client->pwr_state = VGA_SWITCHEROO_OFF;
@@ -264,8 +258,8 @@ static int vga_switchto_stage2(struct vg
 	if (ret)
 		return ret;
 
-	if (new_client->reprobe)
-		new_client->reprobe(new_client->pdev);
+	if (new_client->ops->reprobe)
+		new_client->ops->reprobe(new_client->pdev);
 
 	if (active->pwr_state == VGA_SWITCHEROO_ON)
 		vga_switchoff(active);
@@ -369,7 +363,7 @@ vga_switcheroo_debugfs_write(struct file
 	/* okay we want a switch - test if devices are willing to switch */
 	can_switch = true;
 	for (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {
-		can_switch = vgasr_priv.clients[i].can_switch(vgasr_priv.clients[i].pdev);
+		can_switch = vgasr_priv.clients[i].ops->can_switch(vgasr_priv.clients[i].pdev);
 		if (can_switch == false) {
 			printk(KERN_ERR "vga_switcheroo: client %d refused switch\n", i);
 			break;
@@ -467,7 +461,7 @@ int vga_switcheroo_process_delayed_switc
 	for (i = 0; i < VGA_SWITCHEROO_MAX_CLIENTS; i++) {
 		if (vgasr_priv.clients[i].id == vgasr_priv.delayed_client_id)
 			client = &vgasr_priv.clients[i];
-		can_switch = vgasr_priv.clients[i].can_switch(vgasr_priv.clients[i].pdev);
+		can_switch = vgasr_priv.clients[i].ops->can_switch(vgasr_priv.clients[i].pdev);
 		if (can_switch == false) {
 			printk(KERN_ERR "vga_switcheroo: client %d refused switch\n", i);
 			break;
Index: linux-3.0-SLE11-SP3/include/linux/vga_switcheroo.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/include/linux/vga_switcheroo.h
+++ linux-3.0-SLE11-SP3/include/linux/vga_switcheroo.h
@@ -28,13 +28,16 @@ struct vga_switcheroo_handler {
 	int (*get_client_id)(struct pci_dev *pdev);
 };
 
+struct vga_switcheroo_client_ops {
+	void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state);
+	void (*reprobe)(struct pci_dev *dev);
+	bool (*can_switch)(struct pci_dev *dev);
+};
 
 #if defined(CONFIG_VGA_SWITCHEROO)
 void vga_switcheroo_unregister_client(struct pci_dev *dev);
 int vga_switcheroo_register_client(struct pci_dev *dev,
-				   void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state),
-				   void (*reprobe)(struct pci_dev *dev),
-				   bool (*can_switch)(struct pci_dev *dev));
+				   const struct vga_switcheroo_client_ops *ops);
 
 void vga_switcheroo_client_fb_set(struct pci_dev *dev,
 				  struct fb_info *info);
@@ -48,9 +51,7 @@ int vga_switcheroo_process_delayed_switc
 
 static inline void vga_switcheroo_unregister_client(struct pci_dev *dev) {}
 static inline int vga_switcheroo_register_client(struct pci_dev *dev,
-					  void (*set_gpu_state)(struct pci_dev *dev, enum vga_switcheroo_state),
-					  void (*reprobe)(struct pci_dev *dev),
-					  bool (*can_switch)(struct pci_dev *dev)) { return 0; }
+		const struct vga_switcheroo_client_ops *ops) { return 0; }
 static inline void vga_switcheroo_client_fb_set(struct pci_dev *dev, struct fb_info *info) {}
 static inline int vga_switcheroo_register_handler(struct vga_switcheroo_handler *handler) { return 0; }
 static inline void vga_switcheroo_unregister_handler(void) {}
