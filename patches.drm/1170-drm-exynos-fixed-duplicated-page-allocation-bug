From 61db75d83ca2ac7d46b72fe94b253bbe277bb178 Mon Sep 17 00:00:00 2001
From: Inki Dae <inki.dae@samsung.com>
Date: Tue, 3 Apr 2012 21:49:15 +0900
Subject: drm/exynos: fixed duplicated page allocation bug.
Git-commit: 61db75d83ca2ac7d46b72fe94b253bbe277bb178
Patch-mainline: v3.4-rc3

this patch fixes that buf->pages is allocated two times when it allocates
physically continuous memory region and removes unnecessary codes.

Signed-off-by: Inki Dae <inki.dae@samsung.com>
Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/exynos/exynos_drm_buf.c |   34 ++++++++----------------------
 1 files changed, 9 insertions(+), 25 deletions(-)

diff --git a/drivers/gpu/drm/exynos/exynos_drm_buf.c b/drivers/gpu/drm/exynos/exynos_drm_buf.c
index 52d42cd..de8d209 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_buf.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_buf.c
@@ -34,7 +34,7 @@
 static int lowlevel_buffer_allocate(struct drm_device *dev,
 		unsigned int flags, struct exynos_drm_gem_buf *buf)
 {
-	dma_addr_t start_addr, end_addr;
+	dma_addr_t start_addr;
 	unsigned int npages, page_size, i = 0;
 	struct scatterlist *sgl;
 	int ret = 0;
@@ -76,26 +76,13 @@ static int lowlevel_buffer_allocate(struct drm_device *dev,
 		return -ENOMEM;
 	}
 
-		buf->kvaddr = dma_alloc_writecombine(dev->dev, buf->size,
-				&buf->dma_addr, GFP_KERNEL);
-		if (!buf->kvaddr) {
-			DRM_ERROR("failed to allocate buffer.\n");
-			ret = -ENOMEM;
-			goto err1;
-		}
-
-		start_addr = buf->dma_addr;
-		end_addr = buf->dma_addr + buf->size;
-
-		buf->pages = kzalloc(sizeof(struct page) * npages, GFP_KERNEL);
-		if (!buf->pages) {
-			DRM_ERROR("failed to allocate pages.\n");
-			ret = -ENOMEM;
-			goto err2;
-		}
-
-	start_addr = buf->dma_addr;
-	end_addr = buf->dma_addr + buf->size;
+	buf->kvaddr = dma_alloc_writecombine(dev->dev, buf->size,
+			&buf->dma_addr, GFP_KERNEL);
+	if (!buf->kvaddr) {
+		DRM_ERROR("failed to allocate buffer.\n");
+		ret = -ENOMEM;
+		goto err1;
+	}
 
 	buf->pages = kzalloc(sizeof(struct page) * npages, GFP_KERNEL);
 	if (!buf->pages) {
@@ -105,20 +92,17 @@ static int lowlevel_buffer_allocate(struct drm_device *dev,
 	}
 
 	sgl = buf->sgt->sgl;
+	start_addr = buf->dma_addr;
 
 	while (i < npages) {
 		buf->pages[i] = phys_to_page(start_addr);
 		sg_set_page(sgl, buf->pages[i], page_size, 0);
 		sg_dma_address(sgl) = start_addr;
 		start_addr += page_size;
-		if (end_addr - start_addr < page_size)
-			break;
 		sgl = sg_next(sgl);
 		i++;
 	}
 
-	buf->pages[i] = phys_to_page(start_addr);
-
 	DRM_DEBUG_KMS("vaddr(0x%lx), dma_addr(0x%lx), size(0x%lx)\n",
 			(unsigned long)buf->kvaddr,
 			(unsigned long)buf->dma_addr,

