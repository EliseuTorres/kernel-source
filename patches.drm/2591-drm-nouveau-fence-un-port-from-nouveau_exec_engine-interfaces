From e193b1d42c390bf1bff7fa02a5a1202b98e75601 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Thu, 19 Jul 2012 10:51:42 +1000
Subject: drm/nouveau/fence: un-port from nouveau_exec_engine interfaces
Git-commit: e193b1d42c390bf1bff7fa02a5a1202b98e75601
Patch-mainline: v3.7-rc3

Still the same code, but not an "engine" anymore.  The fence code is more of
a policy decision rather than exposing mechanisms, so it's not appropriate
to port it to the new engine subsystem.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/nouveau/nouveau_channel.c |   10 +++-
 drivers/gpu/drm/nouveau/nouveau_drv.c     |   11 +++++
 drivers/gpu/drm/nouveau/nouveau_drv.h     |    4 +-
 drivers/gpu/drm/nouveau/nouveau_fence.c   |   15 ++++---
 drivers/gpu/drm/nouveau/nouveau_fence.h   |   14 ++++--
 drivers/gpu/drm/nouveau/nv04_fence.c      |   42 ++++++-----------
 drivers/gpu/drm/nouveau/nv10_fence.c      |   48 +++++++------------
 drivers/gpu/drm/nouveau/nv84_fence.c      |   48 +++++++------------
 drivers/gpu/drm/nouveau/nvc0_fence.c      |   70 ++++++++++++++--------------
 9 files changed, 124 insertions(+), 138 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/nouveau_channel.c b/drivers/gpu/drm/nouveau/nouveau_channel.c
index fd4d951..285fde8 100644
--- a/drivers/gpu/drm/nouveau/nouveau_channel.c
+++ b/drivers/gpu/drm/nouveau/nouveau_channel.c
@@ -124,9 +124,9 @@ nouveau_channel_alloc(struct drm_device *dev, struct nouveau_channel **chan_ret,
 		      struct drm_file *file_priv,
 		      uint32_t vram_handle, uint32_t gart_handle)
 {
-	struct nouveau_exec_engine *fence = nv_engine(dev, NVOBJ_ENGINE_FENCE);
-	struct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);
+	struct nouveau_fence_priv *fence = dev_priv->fence.func;
 	struct nouveau_fpriv *fpriv = nouveau_fpriv(file_priv);
 	struct nouveau_channel *chan;
 	unsigned long flags;
@@ -234,7 +234,7 @@ nouveau_channel_alloc(struct drm_device *dev, struct nouveau_channel **chan_ret,
 
 	FIRE_RING(chan);
 
-	ret = fence->context_new(chan, NVOBJ_ENGINE_FENCE);
+	ret = fence->context_new(chan);
 	if (ret) {
 		nouveau_channel_put(&chan);
 		return ret;
@@ -289,6 +289,7 @@ nouveau_channel_put_unlocked(struct nouveau_channel **pchan)
 	struct nouveau_channel *chan = *pchan;
 	struct drm_device *dev = chan->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_fence_priv *fence = dev_priv->fence.func;
 	unsigned long flags;
 	int i;
 
@@ -311,6 +312,9 @@ nouveau_channel_put_unlocked(struct nouveau_channel **pchan)
 			dev_priv->eng[i]->context_del(chan, i);
 	}
 
+	if (chan->fence)
+		fence->context_del(chan);
+
 	/* aside from its resources, the channel should now be dead,
 	 * remove it from the channel list
 	 */
diff --git a/drivers/gpu/drm/nouveau/nouveau_drv.c b/drivers/gpu/drm/nouveau/nouveau_drv.c
index 4b90f12..db150d9 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drv.c
+++ b/drivers/gpu/drm/nouveau/nouveau_drv.c
@@ -33,6 +33,7 @@
 #include "nouveau_hw.h"
 #include "nouveau_fb.h"
 #include "nouveau_fbcon.h"
+#include "nouveau_fence.h"
 #include "nouveau_pm.h"
 #include <engine/fifo.h>
 #include "nv50_display.h"
@@ -149,6 +150,7 @@ nouveau_pci_suspend(struct pci_dev *pdev, pm_message_t pm_state)
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);
+	struct nouveau_fence_priv *fence = dev_priv->fence.func;
 	struct nouveau_channel *chan;
 	struct drm_crtc *crtc;
 	int ret, i, e;
@@ -188,6 +190,11 @@ nouveau_pci_suspend(struct pci_dev *pdev, pm_message_t pm_state)
 			nouveau_channel_idle(chan);
 	}
 
+	if (fence->suspend) {
+		if (!fence->suspend(dev))
+			return -ENOMEM;
+	}
+
 	for (e = NVOBJ_ENGINE_NR - 1; e >= 0; e--) {
 		if (!dev_priv->eng[e])
 			continue;
@@ -216,6 +223,7 @@ nouveau_pci_resume(struct pci_dev *pdev)
 	struct drm_device *dev = pci_get_drvdata(pdev);
 	struct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_fence_priv *fence = dev_priv->fence.func;
 	struct nouveau_engine *engine = &dev_priv->engine;
 	struct drm_crtc *crtc;
 	int ret, i;
@@ -234,6 +242,9 @@ nouveau_pci_resume(struct pci_dev *pdev)
 			dev_priv->eng[i]->init(dev, i);
 	}
 
+	if (fence->resume)
+		fence->resume(dev);
+
 	nouveau_irq_postinstall(dev);
 
 	/* Re-write SKIPS, they'll have been lost over the suspend */
diff --git a/drivers/gpu/drm/nouveau/nouveau_drv.h b/drivers/gpu/drm/nouveau/nouveau_drv.h
index 290b7c2..42ea8ad 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ b/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -133,7 +133,6 @@ enum nouveau_flags {
 #define NVOBJ_ENGINE_BSP	6
 #define NVOBJ_ENGINE_VP		7
 #define NVOBJ_ENGINE_FIFO	14
-#define NVOBJ_ENGINE_FENCE	15
 #define NVOBJ_ENGINE_NR		16
 #define NVOBJ_ENGINE_DISPLAY	(NVOBJ_ENGINE_NR + 0) /*XXX*/
 
@@ -189,6 +188,7 @@ struct nouveau_channel {
 
 	/* Execution engine contexts */
 	void *engctx[NVOBJ_ENGINE_NR];
+	void *fence;
 
 	/* NV50 VM */
 	struct nouveau_vm     *vm;
@@ -448,6 +448,7 @@ struct drm_nouveau_private {
 	u32 crystal;
 
 	struct nouveau_exec_engine *eng[NVOBJ_ENGINE_NR];
+
 	struct list_head classes;
 
 	struct nouveau_bo *vga_ram;
@@ -467,6 +468,7 @@ struct drm_nouveau_private {
 	} ttm;
 
 	struct {
+		void *func;
 		spinlock_t lock;
 		struct drm_mm heap;
 		struct nouveau_bo *bo;
diff --git a/drivers/gpu/drm/nouveau/nouveau_fence.c b/drivers/gpu/drm/nouveau/nouveau_fence.c
index a91d6e8..9775458 100644
--- a/drivers/gpu/drm/nouveau/nouveau_fence.c
+++ b/drivers/gpu/drm/nouveau/nouveau_fence.c
@@ -62,8 +62,9 @@ void
 nouveau_fence_update(struct nouveau_channel *chan)
 {
 	struct drm_device *dev = chan->dev;
-	struct nouveau_fence_priv *priv = nv_engine(dev, NVOBJ_ENGINE_FENCE);
-	struct nouveau_fence_chan *fctx = chan->engctx[NVOBJ_ENGINE_FENCE];
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_fence_priv *priv = dev_priv->fence.func;
+	struct nouveau_fence_chan *fctx = chan->fence;
 	struct nouveau_fence *fence, *fnext;
 
 	spin_lock(&fctx->lock);
@@ -84,8 +85,9 @@ int
 nouveau_fence_emit(struct nouveau_fence *fence, struct nouveau_channel *chan)
 {
 	struct drm_device *dev = chan->dev;
-	struct nouveau_fence_priv *priv = nv_engine(dev, NVOBJ_ENGINE_FENCE);
-	struct nouveau_fence_chan *fctx = chan->engctx[NVOBJ_ENGINE_FENCE];
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_fence_priv *priv = dev_priv->fence.func;
+	struct nouveau_fence_chan *fctx = chan->fence;
 	int ret;
 
 	fence->channel  = chan;
@@ -148,7 +150,8 @@ int
 nouveau_fence_sync(struct nouveau_fence *fence, struct nouveau_channel *chan)
 {
 	struct drm_device *dev = chan->dev;
-	struct nouveau_fence_priv *priv = nv_engine(dev, NVOBJ_ENGINE_FENCE);
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nouveau_fence_priv *priv = dev_priv->fence.func;
 	struct nouveau_channel *prev;
 	int ret = 0;
 
@@ -193,7 +196,7 @@ nouveau_fence_new(struct nouveau_channel *chan, struct nouveau_fence **pfence)
 	struct nouveau_fence *fence;
 	int ret = 0;
 
-	if (unlikely(!chan->engctx[NVOBJ_ENGINE_FENCE]))
+	if (unlikely(!chan->fence))
 		return -ENODEV;
 
 	fence = kzalloc(sizeof(*fence), GFP_KERNEL);
diff --git a/drivers/gpu/drm/nouveau/nouveau_fence.h b/drivers/gpu/drm/nouveau/nouveau_fence.h
index 82ba733..690f465 100644
--- a/drivers/gpu/drm/nouveau/nouveau_fence.h
+++ b/drivers/gpu/drm/nouveau/nouveau_fence.h
@@ -32,11 +32,15 @@ struct nouveau_fence_chan {
 };
 
 struct nouveau_fence_priv {
-	struct nouveau_exec_engine engine;
-	int (*emit)(struct nouveau_fence *);
-	int (*sync)(struct nouveau_fence *, struct nouveau_channel *,
-		    struct nouveau_channel *);
-	u32 (*read)(struct nouveau_channel *);
+	void (*dtor)(struct drm_device *);
+	bool (*suspend)(struct drm_device *);
+	void (*resume)(struct drm_device *);
+	int  (*context_new)(struct nouveau_channel *);
+	void (*context_del)(struct nouveau_channel *);
+	int  (*emit)(struct nouveau_fence *);
+	int  (*sync)(struct nouveau_fence *, struct nouveau_channel *,
+		     struct nouveau_channel *);
+	u32  (*read)(struct nouveau_channel *);
 };
 
 void nouveau_fence_context_new(struct nouveau_fence_chan *);
diff --git a/drivers/gpu/drm/nouveau/nv04_fence.c b/drivers/gpu/drm/nouveau/nv04_fence.c
index 78d851f..1b45a4f 100644
--- a/drivers/gpu/drm/nouveau/nv04_fence.c
+++ b/drivers/gpu/drm/nouveau/nv04_fence.c
@@ -60,7 +60,7 @@ nv04_fence_sync(struct nouveau_fence *fence,
 int
 nv04_fence_mthd(struct nouveau_channel *chan, u32 class, u32 mthd, u32 data)
 {
-	struct nv04_fence_chan *fctx = chan->engctx[NVOBJ_ENGINE_FENCE];
+	struct nv04_fence_chan *fctx = chan->fence;
 	atomic_set(&fctx->sequence, data);
 	return 0;
 }
@@ -68,51 +68,39 @@ nv04_fence_mthd(struct nouveau_channel *chan, u32 class, u32 mthd, u32 data)
 static u32
 nv04_fence_read(struct nouveau_channel *chan)
 {
-	struct nv04_fence_chan *fctx = chan->engctx[NVOBJ_ENGINE_FENCE];
+	struct nv04_fence_chan *fctx = chan->fence;
 	return atomic_read(&fctx->sequence);
 }
 
 static void
-nv04_fence_context_del(struct nouveau_channel *chan, int engine)
+nv04_fence_context_del(struct nouveau_channel *chan)
 {
-	struct nv04_fence_chan *fctx = chan->engctx[engine];
+	struct nv04_fence_chan *fctx = chan->fence;
 	nouveau_fence_context_del(&fctx->base);
-	chan->engctx[engine] = NULL;
+	chan->fence = NULL;
 	kfree(fctx);
 }
 
 static int
-nv04_fence_context_new(struct nouveau_channel *chan, int engine)
+nv04_fence_context_new(struct nouveau_channel *chan)
 {
 	struct nv04_fence_chan *fctx = kzalloc(sizeof(*fctx), GFP_KERNEL);
 	if (fctx) {
 		nouveau_fence_context_new(&fctx->base);
 		atomic_set(&fctx->sequence, 0);
-		chan->engctx[engine] = fctx;
+		chan->fence = fctx;
 		return 0;
 	}
 	return -ENOMEM;
 }
 
-static int
-nv04_fence_fini(struct drm_device *dev, int engine, bool suspend)
-{
-	return 0;
-}
-
-static int
-nv04_fence_init(struct drm_device *dev, int engine)
-{
-	return 0;
-}
-
 static void
-nv04_fence_destroy(struct drm_device *dev, int engine)
+nv04_fence_destroy(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nv04_fence_priv *priv = nv_engine(dev, engine);
+	struct nv04_fence_priv *priv = dev_priv->fence.func;
 
-	dev_priv->eng[engine] = NULL;
+	dev_priv->fence.func = NULL;
 	kfree(priv);
 }
 
@@ -127,14 +115,12 @@ nv04_fence_create(struct drm_device *dev)
 	if (!priv)
 		return -ENOMEM;
 
-	priv->base.engine.destroy = nv04_fence_destroy;
-	priv->base.engine.init = nv04_fence_init;
-	priv->base.engine.fini = nv04_fence_fini;
-	priv->base.engine.context_new = nv04_fence_context_new;
-	priv->base.engine.context_del = nv04_fence_context_del;
+	priv->base.dtor = nv04_fence_destroy;
+	priv->base.context_new = nv04_fence_context_new;
+	priv->base.context_del = nv04_fence_context_del;
 	priv->base.emit = nv04_fence_emit;
 	priv->base.sync = nv04_fence_sync;
 	priv->base.read = nv04_fence_read;
-	dev_priv->eng[NVOBJ_ENGINE_FENCE] = &priv->base.engine;
+	dev_priv->fence.func = &priv->base;
 	return ret;
 }
diff --git a/drivers/gpu/drm/nouveau/nv10_fence.c b/drivers/gpu/drm/nouveau/nv10_fence.c
index 8ff9fba..4dac16a 100644
--- a/drivers/gpu/drm/nouveau/nv10_fence.c
+++ b/drivers/gpu/drm/nouveau/nv10_fence.c
@@ -64,7 +64,8 @@ static int
 nv17_fence_sync(struct nouveau_fence *fence,
 		struct nouveau_channel *prev, struct nouveau_channel *chan)
 {
-	struct nv10_fence_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_FENCE);
+	struct drm_nouveau_private *dev_priv = chan->dev->dev_private;
+	struct nv10_fence_priv *priv = dev_priv->fence.func;
 	u32 value;
 	int ret;
 
@@ -106,23 +107,24 @@ nv10_fence_read(struct nouveau_channel *chan)
 }
 
 static void
-nv10_fence_context_del(struct nouveau_channel *chan, int engine)
+nv10_fence_context_del(struct nouveau_channel *chan)
 {
-	struct nv10_fence_chan *fctx = chan->engctx[engine];
+	struct nv10_fence_chan *fctx = chan->fence;
 	nouveau_fence_context_del(&fctx->base);
-	chan->engctx[engine] = NULL;
+	chan->fence = NULL;
 	kfree(fctx);
 }
 
 static int
-nv10_fence_context_new(struct nouveau_channel *chan, int engine)
+nv10_fence_context_new(struct nouveau_channel *chan)
 {
-	struct nv10_fence_priv *priv = nv_engine(chan->dev, engine);
+	struct drm_nouveau_private *dev_priv = chan->dev->dev_private;
+	struct nv10_fence_priv *priv = dev_priv->fence.func;
 	struct nv10_fence_chan *fctx;
 	struct nouveau_gpuobj *obj;
 	int ret = 0;
 
-	fctx = chan->engctx[engine] = kzalloc(sizeof(*fctx), GFP_KERNEL);
+	fctx = chan->fence = kzalloc(sizeof(*fctx), GFP_KERNEL);
 	if (!fctx)
 		return -ENOMEM;
 
@@ -142,30 +144,18 @@ nv10_fence_context_new(struct nouveau_channel *chan, int engine)
 	}
 
 	if (ret)
-		nv10_fence_context_del(chan, engine);
+		nv10_fence_context_del(chan);
 	return ret;
 }
 
-static int
-nv10_fence_fini(struct drm_device *dev, int engine, bool suspend)
-{
-	return 0;
-}
-
-static int
-nv10_fence_init(struct drm_device *dev, int engine)
-{
-	return 0;
-}
-
 static void
-nv10_fence_destroy(struct drm_device *dev, int engine)
+nv10_fence_destroy(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nv10_fence_priv *priv = nv_engine(dev, engine);
+	struct nv10_fence_priv *priv = dev_priv->fence.func;
 
 	nouveau_bo_ref(NULL, &priv->bo);
-	dev_priv->eng[engine] = NULL;
+	dev_priv->fence.func = NULL;
 	kfree(priv);
 }
 
@@ -180,15 +170,13 @@ nv10_fence_create(struct drm_device *dev)
 	if (!priv)
 		return -ENOMEM;
 
-	priv->base.engine.destroy = nv10_fence_destroy;
-	priv->base.engine.init = nv10_fence_init;
-	priv->base.engine.fini = nv10_fence_fini;
-	priv->base.engine.context_new = nv10_fence_context_new;
-	priv->base.engine.context_del = nv10_fence_context_del;
+	priv->base.dtor = nv10_fence_destroy;
+	priv->base.context_new = nv10_fence_context_new;
+	priv->base.context_del = nv10_fence_context_del;
 	priv->base.emit = nv10_fence_emit;
 	priv->base.read = nv10_fence_read;
 	priv->base.sync = nv10_fence_sync;
-	dev_priv->eng[NVOBJ_ENGINE_FENCE] = &priv->base.engine;
+	dev_priv->fence.func = &priv->base;
 	spin_lock_init(&priv->lock);
 
 	if (dev_priv->chipset >= 0x17) {
@@ -209,6 +197,6 @@ nv10_fence_create(struct drm_device *dev)
 	}
 
 	if (ret)
-		nv10_fence_destroy(dev, NVOBJ_ENGINE_FENCE);
+		nv10_fence_destroy(dev);
 	return ret;
 }
diff --git a/drivers/gpu/drm/nouveau/nv84_fence.c b/drivers/gpu/drm/nouveau/nv84_fence.c
index 721716a..a1812ca 100644
--- a/drivers/gpu/drm/nouveau/nv84_fence.c
+++ b/drivers/gpu/drm/nouveau/nv84_fence.c
@@ -78,28 +78,30 @@ nv84_fence_sync(struct nouveau_fence *fence,
 static u32
 nv84_fence_read(struct nouveau_channel *chan)
 {
-	struct nv84_fence_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_FENCE);
+	struct drm_nouveau_private *dev_priv = chan->dev->dev_private;
+	struct nv84_fence_priv *priv = dev_priv->fence.func;
 	return nv_ro32(priv->mem, chan->id * 16);
 }
 
 static void
-nv84_fence_context_del(struct nouveau_channel *chan, int engine)
+nv84_fence_context_del(struct nouveau_channel *chan)
 {
-	struct nv84_fence_chan *fctx = chan->engctx[engine];
+	struct nv84_fence_chan *fctx = chan->fence;
 	nouveau_fence_context_del(&fctx->base);
-	chan->engctx[engine] = NULL;
+	chan->fence = NULL;
 	kfree(fctx);
 }
 
 static int
-nv84_fence_context_new(struct nouveau_channel *chan, int engine)
+nv84_fence_context_new(struct nouveau_channel *chan)
 {
-	struct nv84_fence_priv *priv = nv_engine(chan->dev, engine);
+	struct drm_nouveau_private *dev_priv = chan->dev->dev_private;
+	struct nv84_fence_priv *priv = dev_priv->fence.func;
 	struct nv84_fence_chan *fctx;
 	struct nouveau_gpuobj *obj;
 	int ret;
 
-	fctx = chan->engctx[engine] = kzalloc(sizeof(*fctx), GFP_KERNEL);
+	fctx = chan->fence = kzalloc(sizeof(*fctx), GFP_KERNEL);
 	if (!fctx)
 		return -ENOMEM;
 
@@ -116,30 +118,18 @@ nv84_fence_context_new(struct nouveau_channel *chan, int engine)
 	}
 
 	if (ret)
-		nv84_fence_context_del(chan, engine);
+		nv84_fence_context_del(chan);
 	return ret;
 }
 
-static int
-nv84_fence_fini(struct drm_device *dev, int engine, bool suspend)
-{
-	return 0;
-}
-
-static int
-nv84_fence_init(struct drm_device *dev, int engine)
-{
-	return 0;
-}
-
 static void
-nv84_fence_destroy(struct drm_device *dev, int engine)
+nv84_fence_destroy(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nv84_fence_priv *priv = nv_engine(dev, engine);
+	struct nv84_fence_priv *priv = dev_priv->fence.func;
 
 	nouveau_gpuobj_ref(NULL, &priv->mem);
-	dev_priv->eng[engine] = NULL;
+	dev_priv->fence.func = NULL;
 	kfree(priv);
 }
 
@@ -155,15 +145,13 @@ nv84_fence_create(struct drm_device *dev)
 	if (!priv)
 		return -ENOMEM;
 
-	priv->base.engine.destroy = nv84_fence_destroy;
-	priv->base.engine.init = nv84_fence_init;
-	priv->base.engine.fini = nv84_fence_fini;
-	priv->base.engine.context_new = nv84_fence_context_new;
-	priv->base.engine.context_del = nv84_fence_context_del;
+	priv->base.dtor = nv84_fence_destroy;
+	priv->base.context_new = nv84_fence_context_new;
+	priv->base.context_del = nv84_fence_context_del;
 	priv->base.emit = nv84_fence_emit;
 	priv->base.sync = nv84_fence_sync;
 	priv->base.read = nv84_fence_read;
-	dev_priv->eng[NVOBJ_ENGINE_FENCE] = &priv->base.engine;
+	dev_priv->fence.func = priv;
 
 	ret = nouveau_gpuobj_new(dev, NULL, 16 * pfifo->channels,
 				 0x1000, 0, &priv->mem);
@@ -172,6 +160,6 @@ nv84_fence_create(struct drm_device *dev)
 
 out:
 	if (ret)
-		nv84_fence_destroy(dev, NVOBJ_ENGINE_FENCE);
+		nv84_fence_destroy(dev);
 	return ret;
 }
diff --git a/drivers/gpu/drm/nouveau/nvc0_fence.c b/drivers/gpu/drm/nouveau/nvc0_fence.c
index 79bb31e..d53ae32 100644
--- a/drivers/gpu/drm/nouveau/nvc0_fence.c
+++ b/drivers/gpu/drm/nouveau/nvc0_fence.c
@@ -44,7 +44,7 @@ static int
 nvc0_fence_emit(struct nouveau_fence *fence)
 {
 	struct nouveau_channel *chan = fence->channel;
-	struct nvc0_fence_chan *fctx = chan->engctx[NVOBJ_ENGINE_FENCE];
+	struct nvc0_fence_chan *fctx = chan->fence;
 	u64 addr = fctx->vma.offset + chan->id * 16;
 	int ret;
 
@@ -65,7 +65,7 @@ static int
 nvc0_fence_sync(struct nouveau_fence *fence,
 		struct nouveau_channel *prev, struct nouveau_channel *chan)
 {
-	struct nvc0_fence_chan *fctx = chan->engctx[NVOBJ_ENGINE_FENCE];
+	struct nvc0_fence_chan *fctx = chan->fence;
 	u64 addr = fctx->vma.offset + prev->id * 16;
 	int ret;
 
@@ -86,30 +86,33 @@ nvc0_fence_sync(struct nouveau_fence *fence,
 static u32
 nvc0_fence_read(struct nouveau_channel *chan)
 {
-	struct nvc0_fence_priv *priv = nv_engine(chan->dev, NVOBJ_ENGINE_FENCE);
+	struct drm_nouveau_private *dev_priv = chan->dev->dev_private;
+	struct nvc0_fence_priv *priv = dev_priv->fence.func;
 	return nouveau_bo_rd32(priv->bo, chan->id * 16/4);
 }
 
 static void
-nvc0_fence_context_del(struct nouveau_channel *chan, int engine)
+nvc0_fence_context_del(struct nouveau_channel *chan)
 {
-	struct nvc0_fence_priv *priv = nv_engine(chan->dev, engine);
-	struct nvc0_fence_chan *fctx = chan->engctx[engine];
+	struct drm_nouveau_private *dev_priv = chan->dev->dev_private;
+	struct nvc0_fence_priv *priv = dev_priv->fence.func;
+	struct nvc0_fence_chan *fctx = chan->fence;
 
 	nouveau_bo_vma_del(priv->bo, &fctx->vma);
 	nouveau_fence_context_del(&fctx->base);
-	chan->engctx[engine] = NULL;
+	chan->fence = NULL;
 	kfree(fctx);
 }
 
 static int
-nvc0_fence_context_new(struct nouveau_channel *chan, int engine)
+nvc0_fence_context_new(struct nouveau_channel *chan)
 {
-	struct nvc0_fence_priv *priv = nv_engine(chan->dev, engine);
+	struct drm_nouveau_private *dev_priv = chan->dev->dev_private;
+	struct nvc0_fence_priv *priv = dev_priv->fence.func;
 	struct nvc0_fence_chan *fctx;
 	int ret;
 
-	fctx = chan->engctx[engine] = kzalloc(sizeof(*fctx), GFP_KERNEL);
+	fctx = chan->fence = kzalloc(sizeof(*fctx), GFP_KERNEL);
 	if (!fctx)
 		return -ENOMEM;
 
@@ -117,36 +120,35 @@ nvc0_fence_context_new(struct nouveau_channel *chan, int engine)
 
 	ret = nouveau_bo_vma_add(priv->bo, chan->vm, &fctx->vma);
 	if (ret)
-		nvc0_fence_context_del(chan, engine);
+		nvc0_fence_context_del(chan);
 
 	nouveau_bo_wr32(priv->bo, chan->id * 16/4, 0x00000000);
 	return ret;
 }
 
-static int
-nvc0_fence_fini(struct drm_device *dev, int engine, bool suspend)
+static bool
+nvc0_fence_suspend(struct drm_device *dev)
 {
 	struct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);
-	struct nvc0_fence_priv *priv = nv_engine(dev, engine);
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nvc0_fence_priv *priv = dev_priv->fence.func;
 	int i;
 
-	if (suspend) {
-		priv->suspend = vmalloc(pfifo->channels * sizeof(u32));
-		if (!priv->suspend)
-			return -ENOMEM;
-
+	priv->suspend = vmalloc(pfifo->channels * sizeof(u32));
+	if (priv->suspend) {
 		for (i = 0; i < pfifo->channels; i++)
 			priv->suspend[i] = nouveau_bo_rd32(priv->bo, i);
 	}
 
-	return 0;
+	return priv->suspend != NULL;
 }
 
-static int
-nvc0_fence_init(struct drm_device *dev, int engine)
+static void
+nvc0_fence_resume(struct drm_device *dev)
 {
 	struct nouveau_fifo_priv *pfifo = nv_engine(dev, NVOBJ_ENGINE_FIFO);
-	struct nvc0_fence_priv *priv = nv_engine(dev, engine);
+	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nvc0_fence_priv *priv = dev_priv->fence.func;
 	int i;
 
 	if (priv->suspend) {
@@ -155,19 +157,17 @@ nvc0_fence_init(struct drm_device *dev, int engine)
 		vfree(priv->suspend);
 		priv->suspend = NULL;
 	}
-
-	return 0;
 }
 
 static void
-nvc0_fence_destroy(struct drm_device *dev, int engine)
+nvc0_fence_destroy(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nvc0_fence_priv *priv = nv_engine(dev, engine);
+	struct nvc0_fence_priv *priv = dev_priv->fence.func;
 
 	nouveau_bo_unmap(priv->bo);
 	nouveau_bo_ref(NULL, &priv->bo);
-	dev_priv->eng[engine] = NULL;
+	dev_priv->fence.func = NULL;
 	kfree(priv);
 }
 
@@ -183,15 +183,15 @@ nvc0_fence_create(struct drm_device *dev)
 	if (!priv)
 		return -ENOMEM;
 
-	priv->base.engine.destroy = nvc0_fence_destroy;
-	priv->base.engine.init = nvc0_fence_init;
-	priv->base.engine.fini = nvc0_fence_fini;
-	priv->base.engine.context_new = nvc0_fence_context_new;
-	priv->base.engine.context_del = nvc0_fence_context_del;
+	priv->base.dtor = nvc0_fence_destroy;
+	priv->base.suspend = nvc0_fence_suspend;
+	priv->base.resume = nvc0_fence_resume;
+	priv->base.context_new = nvc0_fence_context_new;
+	priv->base.context_del = nvc0_fence_context_del;
 	priv->base.emit = nvc0_fence_emit;
 	priv->base.sync = nvc0_fence_sync;
 	priv->base.read = nvc0_fence_read;
-	dev_priv->eng[NVOBJ_ENGINE_FENCE] = &priv->base.engine;
+	dev_priv->fence.func = priv;
 
 	ret = nouveau_bo_new(dev, 16 * pfifo->channels, 0, TTM_PL_FLAG_VRAM,
 			     0, 0, NULL, &priv->bo);
@@ -204,6 +204,6 @@ nvc0_fence_create(struct drm_device *dev)
 	}
 
 	if (ret)
-		nvc0_fence_destroy(dev, NVOBJ_ENGINE_FENCE);
+		nvc0_fence_destroy(dev);
 	return ret;
 }

