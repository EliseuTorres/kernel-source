From fd89cf878967666ff394cd4c8e29269e3977cd31 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
Date: Thu, 24 Dec 2009 03:28:33 +0100
Patch-mainline: 2.6.34
References: fate#310916
Git-commit: a0eb38eb8637a81bb7770d34036e498d2ba63a26
Subject: [PATCH 0410/2588] drm/radeon/kms: get_power_state early, not when
 processing IRQ
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit a0eb38eb8637a81bb7770d34036e498d2ba63a26)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/radeon/radeon_pm.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index f500c8d..1cecd73 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
@@ -273,6 +273,7 @@ void radeon_pm_compute_clocks(struct radeon_device *rdev)
 
 			rdev->pm.state = PM_STATE_PAUSED;
 			rdev->pm.planned_action = PM_ACTION_UPCLOCK;
+			radeon_get_power_state(rdev, rdev->pm.planned_action);
 			rdev->pm.vblank_callback = true;
 
 			mutex_unlock(&rdev->pm.mutex);
@@ -292,6 +293,7 @@ void radeon_pm_compute_clocks(struct radeon_device *rdev)
 		if (rdev->pm.state == PM_STATE_MINIMUM) {
 			rdev->pm.state = PM_STATE_ACTIVE;
 			rdev->pm.planned_action = PM_ACTION_UPCLOCK;
+			radeon_get_power_state(rdev, rdev->pm.planned_action);
 			radeon_pm_set_clocks_locked(rdev);
 
 			queue_delayed_work(rdev->wq, &rdev->pm.idle_work,
@@ -312,6 +314,7 @@ void radeon_pm_compute_clocks(struct radeon_device *rdev)
 
 			rdev->pm.state = PM_STATE_MINIMUM;
 			rdev->pm.planned_action = PM_ACTION_MINIMUM;
+			radeon_get_power_state(rdev, rdev->pm.planned_action);
 			radeon_pm_set_clocks_locked(rdev);
 		}
 
@@ -324,18 +327,14 @@ static void radeon_pm_set_clocks_locked(struct radeon_device *rdev)
 	/*radeon_fence_wait_last(rdev);*/
 	switch (rdev->pm.planned_action) {
 	case PM_ACTION_UPCLOCK:
-		radeon_get_power_state(rdev, PM_ACTION_UPCLOCK);
 		rdev->pm.downclocked = false;
 		break;
 	case PM_ACTION_DOWNCLOCK:
-		radeon_get_power_state(rdev, PM_ACTION_DOWNCLOCK);
 		rdev->pm.downclocked = true;
 		break;
 	case PM_ACTION_MINIMUM:
-		radeon_get_power_state(rdev, PM_ACTION_MINIMUM);
 		break;
 	case PM_ACTION_NONE:
-		radeon_get_power_state(rdev, PM_ACTION_NONE);
 		DRM_ERROR("%s: PM_ACTION_NONE\n", __func__);
 		break;
 	}
@@ -427,6 +426,7 @@ static void radeon_pm_idle_work_handler(struct work_struct *work)
 				rdev->pm.req_vblank |= (1 << 1);
 				drm_vblank_get(rdev->ddev, 1);
 			}
+			radeon_get_power_state(rdev, rdev->pm.planned_action);
 			rdev->pm.vblank_callback = true;
 		}
 	}
-- 
1.7.6

