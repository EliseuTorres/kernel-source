From 0c49caf2994b713e2e44588339412ea441fb54b6 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Sat, 5 Feb 2011 10:15:37 +0000
Patch-mainline: 2.6.39
References: fate#310916
Git-commit: 60c8bdf64a80ebb0132172ea97bd54d7c7d36611
Subject: [PATCH 2254/2588] Revert "drm/i915: Use PM QoS to prevent C-State
 starvation of gen3 GPU"

Using PM latency request turns out to be very fragile and only works for
some systems, depending upon the ACPI implementation. However, I've
stumbled across a promising bit in INSTPM: "Interrupt-Based AGPBUSY#".

This reverts commit b0b544cd37c060e261afb2cf486296983fcb56da.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit 60c8bdf64a80ebb0132172ea97bd54d7c7d36611)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_drv.h |    5 -----
 drivers/gpu/drm/i915/i915_irq.c |   33 ---------------------------------
 2 files changed, 0 insertions(+), 38 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index e668617..b62b7be 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -35,7 +35,6 @@
 #include "intel_ringbuffer.h"
 #include <linux/io-mapping.h>
 #include <linux/i2c.h>
-#include <linux/pm_qos_params.h>
 #include <drm/intel-gtt.h>
 
 /* General customization:
@@ -309,10 +308,6 @@ typedef struct drm_i915_private {
 	int vblank_pipe;
 	int num_pipe;
 
-	atomic_t vblank_enabled;
-	struct pm_qos_request_list vblank_pm_qos;
-	struct work_struct vblank_work;
-
 	/* For hangcheck timer */
 #define DRM_I915_HANGCHECK_PERIOD 1500 /* in ms */
 	struct timer_list hangcheck_timer;
diff --git a/drivers/gpu/drm/i915/i915_irq.c b/drivers/gpu/drm/i915/i915_irq.c
index be36fea1..d179547 100644
--- a/drivers/gpu/drm/i915/i915_irq.c
+++ b/drivers/gpu/drm/i915/i915_irq.c
@@ -1333,22 +1333,6 @@ int i915_irq_wait(struct drm_device *dev, void *data,
 	return i915_wait_irq(dev, irqwait->irq_seq);
 }
 
-static void i915_vblank_work_func(struct work_struct *work)
-{
-	drm_i915_private_t *dev_priv =
-		container_of(work, drm_i915_private_t, vblank_work);
-
-	if (atomic_read(&dev_priv->vblank_enabled)) {
-		if (!dev_priv->vblank_pm_qos.pm_qos_class)
-			pm_qos_add_request(&dev_priv->vblank_pm_qos,
-					   PM_QOS_CPU_DMA_LATENCY,
-					   15); //>=20 won't work
-	} else {
-		if (dev_priv->vblank_pm_qos.pm_qos_class)
-			pm_qos_remove_request(&dev_priv->vblank_pm_qos);
-	}
-}
-
 /* Called from drm generic code, passed 'crtc' which
  * we use as a pipe index
  */
@@ -1371,16 +1355,6 @@ int i915_enable_vblank(struct drm_device *dev, int pipe)
 		i915_enable_pipestat(dev_priv, pipe,
 				     PIPE_VBLANK_INTERRUPT_ENABLE);
 	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
-
-	/* gen3 platforms have an issue with vsync interrupts not reaching
-	 * cpu during deep c-state sleep (>C1), so we need to install a
-	 * PM QoS handle to prevent C-state starvation of the GPU.
-	 */
-	if (dev_priv->info->gen == 3 && !dev_priv->info->is_g33) {
-		atomic_inc(&dev_priv->vblank_enabled);
-		queue_work(dev_priv->wq, &dev_priv->vblank_work);
-	}
-
 	return 0;
 }
 
@@ -1392,11 +1366,6 @@ void i915_disable_vblank(struct drm_device *dev, int pipe)
 	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
 	unsigned long irqflags;
 
-	if (dev_priv->info->gen == 3 && !dev_priv->info->is_g33) {
-		atomic_dec(&dev_priv->vblank_enabled);
-		queue_work(dev_priv->wq, &dev_priv->vblank_work);
-	}
-
 	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
 	if (HAS_PCH_SPLIT(dev))
 		ironlake_disable_display_irq(dev_priv, (pipe == 0) ?
@@ -1675,11 +1644,9 @@ void i915_driver_irq_preinstall(struct drm_device * dev)
 	int pipe;
 
 	atomic_set(&dev_priv->irq_received, 0);
-	atomic_set(&dev_priv->vblank_enabled, 0);
 
 	INIT_WORK(&dev_priv->hotplug_work, i915_hotplug_work_func);
 	INIT_WORK(&dev_priv->error_work, i915_error_work_func);
-	INIT_WORK(&dev_priv->vblank_work, i915_vblank_work_func);
 
 	if (HAS_PCH_SPLIT(dev)) {
 		ironlake_irq_preinstall(dev);
-- 
1.7.6

