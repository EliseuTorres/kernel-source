From 80f39dac4ce7a24b681075d500a3780419ac4562 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Sun, 31 Oct 2010 08:49:47 +0000
Patch-mainline: 2.6.38
References: fate#310916
Git-commit: 5eac3ab45955b32f3a9d89e633918c4d6f133dfa
Subject: [PATCH 1831/2588] drm/i915: Evict just the purgeable GTT entries on
 the first pass

Take two passes to evict everything whilst searching for sufficient free
space to bind the batchbuffer. After searching for sufficient free space
using LRU eviction, evict everything that is purgeable and try again.
Only then if there is insufficient free space (or the GTT is too badly
fragmented) evict everything from the aperture and try one last time.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit 5eac3ab45955b32f3a9d89e633918c4d6f133dfa)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_drv.h       |    4 +-
 drivers/gpu/drm/i915/i915_gem.c       |   19 ++++++++-------
 drivers/gpu/drm/i915/i915_gem_evict.c |   40 ++++++++++----------------------
 3 files changed, 25 insertions(+), 38 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index a48d65b..65101de 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1075,8 +1075,8 @@ void i915_gem_release(struct drm_device * dev, struct drm_file *file_priv);
 /* i915_gem_evict.c */
 int i915_gem_evict_something(struct drm_device *dev, int min_size,
 			     unsigned alignment, bool mappable);
-int i915_gem_evict_everything(struct drm_device *dev);
-int i915_gem_evict_inactive(struct drm_device *dev);
+int i915_gem_evict_everything(struct drm_device *dev, bool purgeable_only);
+int i915_gem_evict_inactive(struct drm_device *dev, bool purgeable_only);
 
 /* i915_gem_tiling.c */
 void i915_gem_detect_bit_6_swizzle(struct drm_device *dev);
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index f256c65..2c9d27a 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -3574,7 +3574,8 @@ i915_gem_execbuffer_reserve(struct drm_device *dev,
 	int ret, i, retry;
 
 	/* attempt to pin all of the buffers into the GTT */
-	for (retry = 0; retry < 2; retry++) {
+	retry = 0;
+	do {
 		ret = 0;
 		for (i = 0; i < count; i++) {
 			struct drm_i915_gem_exec_object2 *entry = &exec_list[i];
@@ -3622,18 +3623,18 @@ i915_gem_execbuffer_reserve(struct drm_device *dev,
 		while (i--)
 			i915_gem_object_unpin(object_list[i]);
 
-		if (ret == 0)
-			break;
-
-		if (ret != -ENOSPC || retry)
+		if (ret != -ENOSPC || retry > 1)
 			return ret;
 
-		ret = i915_gem_evict_everything(dev);
+		/* First attempt, just clear anything that is purgeable.
+		 * Second attempt, clear the entire GTT.
+		 */
+		ret = i915_gem_evict_everything(dev, retry == 0);
 		if (ret)
 			return ret;
-	}
 
-	return 0;
+		retry++;
+	} while (1);
 }
 
 static int
@@ -4689,7 +4690,7 @@ i915_gem_idle(struct drm_device *dev)
 
 	/* Under UMS, be paranoid and evict. */
 	if (!drm_core_check_feature(dev, DRIVER_MODESET)) {
-		ret = i915_gem_evict_inactive(dev);
+		ret = i915_gem_evict_inactive(dev, false);
 		if (ret) {
 			mutex_unlock(&dev->struct_mutex);
 			return ret;
diff --git a/drivers/gpu/drm/i915/i915_gem_evict.c b/drivers/gpu/drm/i915/i915_gem_evict.c
index 3018572..3f6f336 100644
--- a/drivers/gpu/drm/i915/i915_gem_evict.c
+++ b/drivers/gpu/drm/i915/i915_gem_evict.c
@@ -42,7 +42,7 @@ mark_free(struct drm_i915_gem_object *obj_priv,
 
 int
 i915_gem_evict_something(struct drm_device *dev, int min_size,
-	 		 unsigned alignment, bool mappable)
+			 unsigned alignment, bool mappable)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	struct list_head eviction_list, unwind_list;
@@ -54,7 +54,7 @@ i915_gem_evict_something(struct drm_device *dev, int min_size,
 	/* Re-check for free space after retiring requests */
 	if (mappable) {
 		if (drm_mm_search_free_in_range(&dev_priv->mm.gtt_space,
-				  		min_size, alignment, 0,
+						min_size, alignment, 0,
 						dev_priv->mm.gtt_mappable_end,
 						0))
 			return 0;
@@ -171,7 +171,7 @@ found:
 }
 
 int
-i915_gem_evict_everything(struct drm_device *dev)
+i915_gem_evict_everything(struct drm_device *dev, bool purgeable_only)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
 	int ret;
@@ -190,36 +190,22 @@ i915_gem_evict_everything(struct drm_device *dev)
 
 	BUG_ON(!list_empty(&dev_priv->mm.flushing_list));
 
-	ret = i915_gem_evict_inactive(dev);
-	if (ret)
-		return ret;
-
-	lists_empty = (list_empty(&dev_priv->mm.inactive_list) &&
-		       list_empty(&dev_priv->mm.flushing_list) &&
-		       list_empty(&dev_priv->mm.active_list));
-	BUG_ON(!lists_empty);
-
-	return 0;
+	return i915_gem_evict_inactive(dev, purgeable_only);
 }
 
 /** Unbinds all inactive objects. */
 int
-i915_gem_evict_inactive(struct drm_device *dev)
+i915_gem_evict_inactive(struct drm_device *dev, bool purgeable_only)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
-
-	while (!list_empty(&dev_priv->mm.inactive_list)) {
-		struct drm_gem_object *obj;
-		int ret;
-
-		obj = &list_first_entry(&dev_priv->mm.inactive_list,
-					struct drm_i915_gem_object,
-					mm_list)->base;
-
-		ret = i915_gem_object_unbind(obj);
-		if (ret != 0) {
-			DRM_ERROR("Error unbinding object: %d\n", ret);
-			return ret;
+	struct drm_i915_gem_object *obj, *next;
+
+	list_for_each_entry_safe(obj, next,
+				 &dev_priv->mm.inactive_list, mm_list) {
+		if (!purgeable_only || obj->madv != I915_MADV_WILLNEED) {
+			int ret = i915_gem_object_unbind(&obj->base);
+			if (ret)
+				return ret;
 		}
 	}
 
-- 
1.7.6

