From 586c55f6ade73f8672d1eaf598237a6f49b28443 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Mon, 9 Jul 2012 14:14:48 +1000
Subject: drm/nouveau: have non-core mmio accesses go through device object
Git-commit: 586c55f6ade73f8672d1eaf598237a6f49b28443
Patch-mainline: v3.7-rc3

Adds an extra layer of indirection to each register access, but it's not
too bad, and will also go away as pieces are ported.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/nouveau/Makefile         |    2 +-
 drivers/gpu/drm/nouveau/nouveau_compat.c |   40 ++++++++++
 drivers/gpu/drm/nouveau/nouveau_compat.h |   10 +++
 drivers/gpu/drm/nouveau/nouveau_drv.h    |   38 ++--------
 drivers/gpu/drm/nouveau/nouveau_state.c  |  118 +++++++++++-------------------
 5 files changed, 99 insertions(+), 109 deletions(-)

Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/Makefile
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/Makefile
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/Makefile
@@ -80,7 +80,7 @@ nouveau-y += core/engine/mpeg/nv50.o
 nouveau-y += core/engine/ppp/nv98.o
 nouveau-y += core/engine/vp/nv84.o
 
-nouveau-y += nouveau_drm.o \
+nouveau-y += nouveau_drm.o nouveau_compat.o \
 	     nouveau_drv.o nouveau_state.o nouveau_channel.o nouveau_mem.o \
              nouveau_gpuobj.o nouveau_irq.o nouveau_notifier.o \
              nouveau_sgdma.o nouveau_dma.o nouveau_util.o \
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_compat.c
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_compat.c
@@ -0,0 +1,40 @@
+#include "nouveau_drm.h"
+#include "nouveau_compat.h"
+
+void *nouveau_newpriv(struct drm_device *);
+
+u8
+_nv_rd08(struct drm_device *dev, u32 reg)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	return nv_ro08(drm->device, reg);
+}
+
+void
+_nv_wr08(struct drm_device *dev, u32 reg, u8 val)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	nv_wo08(drm->device, reg, val);
+}
+
+u32
+_nv_rd32(struct drm_device *dev, u32 reg)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	return nv_ro32(drm->device, reg);
+}
+
+void
+_nv_wr32(struct drm_device *dev, u32 reg, u32 val)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	nv_wo32(drm->device, reg, val);
+}
+
+u32
+_nv_mask(struct drm_device *dev, u32 reg, u32 mask, u32 val)
+{
+	u32 tmp = _nv_rd32(dev, reg);
+	_nv_wr32(dev, reg, (tmp & ~mask) | val);
+	return tmp;
+}
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_compat.h
===================================================================
--- /dev/null
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_compat.h
@@ -0,0 +1,10 @@
+#ifndef __NOUVEAU_COMPAT_H__
+#define __NOUVEAU_COMPAT_H__
+
+u8   _nv_rd08(struct drm_device *, u32);
+void _nv_wr08(struct drm_device *, u32, u8);
+u32  _nv_rd32(struct drm_device *, u32);
+void _nv_wr32(struct drm_device *, u32, u32);
+u32  _nv_mask(struct drm_device *, u32, u32, u32);
+
+#endif
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.h
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -673,8 +673,6 @@ struct drm_nouveau_private {
 	int flags;
 	u32 crystal;
 
-	void __iomem *mmio;
-
 	spinlock_t ramin_lock;
 	void __iomem *ramin;
 	u32 ramin_size;
@@ -1428,36 +1426,12 @@ static inline void nvchan_wr32(struct no
 }
 
 /* register access */
-static inline u32 nv_rd32(struct drm_device *dev, unsigned reg)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	return ioread32_native(dev_priv->mmio + reg);
-}
-
-static inline void nv_wr32(struct drm_device *dev, unsigned reg, u32 val)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	iowrite32_native(val, dev_priv->mmio + reg);
-}
-
-static inline u32 nv_mask(struct drm_device *dev, u32 reg, u32 mask, u32 val)
-{
-	u32 tmp = nv_rd32(dev, reg);
-	nv_wr32(dev, reg, (tmp & ~mask) | val);
-	return tmp;
-}
-
-static inline u8 nv_rd08(struct drm_device *dev, unsigned reg)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	return ioread8(dev_priv->mmio + reg);
-}
-
-static inline void nv_wr08(struct drm_device *dev, unsigned reg, u8 val)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	iowrite8(val, dev_priv->mmio + reg);
-}
+#include "nouveau_compat.h"
+#define nv_rd08 _nv_rd08
+#define nv_wr08 _nv_wr08
+#define nv_rd32 _nv_rd32
+#define nv_wr32 _nv_wr32
+#define nv_mask _nv_mask
 
 #define nv_wait(dev, reg, mask, val) \
 	nouveau_wait_eq(dev, 2000000000ULL, (reg), (mask), (val))
Index: linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_state.c
===================================================================
--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/nouveau/nouveau_state.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/nouveau/nouveau_state.c
@@ -1035,7 +1035,6 @@ nouveau_newpriv(struct drm_device *dev)
 int nouveau_load(struct drm_device *dev, unsigned long flags)
 {
 	struct drm_nouveau_private *dev_priv;
-	unsigned long long offset, length;
 	uint32_t reg0 = ~0, strap;
 	int ret;
 
@@ -1053,58 +1052,45 @@ int nouveau_load(struct drm_device *dev,
 	NV_DEBUG(dev, "vendor: 0x%X device: 0x%X class: 0x%X\n",
 		 dev->pci_vendor, dev->pci_device, dev->pdev->class);
 
-	/* first up, map the start of mmio and determine the chipset */
-	dev_priv->mmio = ioremap(pci_resource_start(dev->pdev, 0), PAGE_SIZE);
-	if (dev_priv->mmio) {
-#ifdef __BIG_ENDIAN
-		/* put the card into big-endian mode if it's not */
-		if (nv_rd32(dev, NV03_PMC_BOOT_1) != 0x01000001)
-			nv_wr32(dev, NV03_PMC_BOOT_1, 0x01000001);
-		DRM_MEMORYBARRIER();
-#endif
-
-		/* determine chipset and derive architecture from it */
-		reg0 = nv_rd32(dev, NV03_PMC_BOOT_0);
-		if ((reg0 & 0x0f000000) > 0) {
-			dev_priv->chipset = (reg0 & 0xff00000) >> 20;
-			switch (dev_priv->chipset & 0xf0) {
-			case 0x10:
-			case 0x20:
-			case 0x30:
-				dev_priv->card_type = dev_priv->chipset & 0xf0;
-				break;
-			case 0x40:
-			case 0x60:
-				dev_priv->card_type = NV_40;
-				break;
-			case 0x50:
-			case 0x80:
-			case 0x90:
-			case 0xa0:
-				dev_priv->card_type = NV_50;
-				break;
-			case 0xc0:
-				dev_priv->card_type = NV_C0;
-				break;
-			case 0xd0:
-				dev_priv->card_type = NV_D0;
-				break;
-			case 0xe0:
-				dev_priv->card_type = NV_E0;
-				break;
-			default:
-				break;
-			}
-		} else
-		if ((reg0 & 0xff00fff0) == 0x20004000) {
-			if (reg0 & 0x00f00000)
-				dev_priv->chipset = 0x05;
-			else
-				dev_priv->chipset = 0x04;
-			dev_priv->card_type = NV_04;
+	/* determine chipset and derive architecture from it */
+	reg0 = nv_rd32(dev, NV03_PMC_BOOT_0);
+	if ((reg0 & 0x0f000000) > 0) {
+		dev_priv->chipset = (reg0 & 0xff00000) >> 20;
+		switch (dev_priv->chipset & 0xf0) {
+		case 0x10:
+		case 0x20:
+		case 0x30:
+			dev_priv->card_type = dev_priv->chipset & 0xf0;
+			break;
+		case 0x40:
+		case 0x60:
+			dev_priv->card_type = NV_40;
+			break;
+		case 0x50:
+		case 0x80:
+		case 0x90:
+		case 0xa0:
+			dev_priv->card_type = NV_50;
+			break;
+		case 0xc0:
+			dev_priv->card_type = NV_C0;
+			break;
+		case 0xd0:
+			dev_priv->card_type = NV_D0;
+			break;
+		case 0xe0:
+			dev_priv->card_type = NV_E0;
+			break;
+		default:
+			break;
 		}
-
-		iounmap(dev_priv->mmio);
+	} else
+	if ((reg0 & 0xff00fff0) == 0x20004000) {
+		if (reg0 & 0x00f00000)
+			dev_priv->chipset = 0x05;
+		else
+			dev_priv->chipset = 0x04;
+		dev_priv->card_type = NV_04;
 	}
 
 	if (!dev_priv->card_type) {
@@ -1116,21 +1102,6 @@ int nouveau_load(struct drm_device *dev,
 	NV_INFO(dev, "Detected an NV%02x generation card (0x%08x)\n",
 		     dev_priv->card_type, reg0);
 
-	/* map the mmio regs, limiting the amount to preserve vmap space */
-	offset = pci_resource_start(dev->pdev, 0);
-	length = pci_resource_len(dev->pdev, 0);
-	if (dev_priv->card_type < NV_E0)
-		length = min(length, (unsigned long long)0x00800000);
-
-	dev_priv->mmio = ioremap(offset, length);
-	if (!dev_priv->mmio) {
-		NV_ERROR(dev, "Unable to initialize the mmio mapping. "
-			 "Please report your setup to " DRIVER_EMAIL "\n");
-		ret = -EINVAL;
-		goto err_priv;
-	}
-	NV_DEBUG(dev, "regs mapped ok at 0x%llx\n", offset);
-
 	/* determine frequency of timing crystal */
 	strap = nv_rd32(dev, 0x101000);
 	if ( dev_priv->chipset < 0x17 ||
@@ -1170,7 +1141,7 @@ int nouveau_load(struct drm_device *dev,
 
 	ret = nouveau_remove_conflicting_drivers(dev);
 	if (ret)
-		goto err_mmio;
+		goto err_priv;
 
 	/* Map PRAMIN BAR, or on older cards, the aperture within BAR0 */
 	if (dev_priv->card_type >= NV_40) {
@@ -1185,16 +1156,16 @@ int nouveau_load(struct drm_device *dev,
 		if (!dev_priv->ramin) {
 			NV_ERROR(dev, "Failed to map PRAMIN BAR\n");
 			ret = -ENOMEM;
-			goto err_mmio;
+			goto err_priv;
 		}
 	} else {
 		dev_priv->ramin_size = 1 * 1024 * 1024;
-		dev_priv->ramin = ioremap(offset + NV_RAMIN,
+		dev_priv->ramin = ioremap(pci_resource_start(dev->pdev, 0),
 					  dev_priv->ramin_size);
 		if (!dev_priv->ramin) {
 			NV_ERROR(dev, "Failed to map BAR0 PRAMIN.\n");
 			ret = -ENOMEM;
-			goto err_mmio;
+			goto err_priv;
 		}
 	}
 
@@ -1215,8 +1186,6 @@ int nouveau_load(struct drm_device *dev,
 
 err_ramin:
 	iounmap(dev_priv->ramin);
-err_mmio:
-	iounmap(dev_priv->mmio);
 err_priv:
 	dev->dev_private = dev_priv->newpriv;
 	kfree(dev_priv);
@@ -1235,7 +1204,6 @@ int nouveau_unload(struct drm_device *de
 
 	nouveau_card_takedown(dev);
 
-	iounmap(dev_priv->mmio);
 	iounmap(dev_priv->ramin);
 
 	dev->dev_private = dev_priv->newpriv;
