From f31f03fa59b856a5f7d1b4c1e31ec20b03a507f4 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Sat, 25 Sep 2010 11:22:51 +0100
Patch-mainline: 2.6.37
References: fate#310916
Git-commit: 76c1dec1979d9b552aab9600eb898ccec394fbbc
Subject: [PATCH 1491/2588] drm/i915: Make the mutex_lock interruptible on
 ioctl paths

... and combine it with the wedged completion handler.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit 76c1dec1979d9b552aab9600eb898ccec394fbbc)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_gem.c |  126 ++++++++++++++++++++++++++-------------
 1 files changed, 84 insertions(+), 42 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 8ea024f..a067bfa 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -91,6 +91,26 @@ i915_gem_check_is_wedged(struct drm_device *dev)
 	return -EIO;
 }
 
+static int i915_mutex_lock_interruptible(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret;
+
+	ret = i915_gem_check_is_wedged(dev);
+	if (ret)
+		return ret;
+
+	ret = mutex_lock_interruptible(&dev->struct_mutex);
+	if (ret)
+		return ret;
+
+	if (atomic_read(&dev_priv->mm.wedged)) {
+		mutex_unlock(&dev->struct_mutex);
+		return -EAGAIN;
+	}
+
+	return 0;
+}
 
 static inline bool
 i915_gem_object_is_inactive(struct drm_i915_gem_object *obj_priv)
@@ -297,7 +317,9 @@ i915_gem_shmem_pread_fast(struct drm_device *dev, struct drm_gem_object *obj,
 	user_data = (char __user *) (uintptr_t) args->data_ptr;
 	remain = args->size;
 
-	mutex_lock(&dev->struct_mutex);
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret)
+		return ret;
 
 	ret = i915_gem_object_get_pages(obj, 0);
 	if (ret != 0)
@@ -416,7 +438,9 @@ i915_gem_shmem_pread_slow(struct drm_device *dev, struct drm_gem_object *obj,
 
 	do_bit17_swizzling = i915_gem_object_needs_bit17_swizzle(obj);
 
-	mutex_lock(&dev->struct_mutex);
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret)
+		goto fail_put_user_pages;
 
 	ret = i915_gem_object_get_pages_or_evict(obj);
 	if (ret)
@@ -616,8 +640,10 @@ i915_gem_gtt_pwrite_fast(struct drm_device *dev, struct drm_gem_object *obj,
 	user_data = (char __user *) (uintptr_t) args->data_ptr;
 	remain = args->size;
 
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret)
+		return ret;
 
-	mutex_lock(&dev->struct_mutex);
 	ret = i915_gem_object_pin(obj, 0);
 	if (ret) {
 		mutex_unlock(&dev->struct_mutex);
@@ -712,7 +738,10 @@ i915_gem_gtt_pwrite_slow(struct drm_device *dev, struct drm_gem_object *obj,
 		goto out_unpin_pages;
 	}
 
-	mutex_lock(&dev->struct_mutex);
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret)
+		goto out_unpin_pages;
+
 	ret = i915_gem_object_pin(obj, 0);
 	if (ret)
 		goto out_unlock;
@@ -786,7 +815,9 @@ i915_gem_shmem_pwrite_fast(struct drm_device *dev, struct drm_gem_object *obj,
 	user_data = (char __user *) (uintptr_t) args->data_ptr;
 	remain = args->size;
 
-	mutex_lock(&dev->struct_mutex);
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret)
+		return ret;
 
 	ret = i915_gem_object_get_pages(obj, 0);
 	if (ret != 0)
@@ -882,7 +913,9 @@ i915_gem_shmem_pwrite_slow(struct drm_device *dev, struct drm_gem_object *obj,
 
 	do_bit17_swizzling = i915_gem_object_needs_bit17_swizzle(obj);
 
-	mutex_lock(&dev->struct_mutex);
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret)
+		goto fail_put_user_pages;
 
 	ret = i915_gem_object_get_pages_or_evict(obj);
 	if (ret)
@@ -1053,7 +1086,11 @@ i915_gem_set_domain_ioctl(struct drm_device *dev, void *data,
 		return -ENOENT;
 	obj_priv = to_intel_bo(obj);
 
-	mutex_lock(&dev->struct_mutex);
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret) {
+		drm_gem_object_unreference_unlocked(obj);
+		return ret;
+	}
 
 	intel_mark_busy(dev, obj);
 
@@ -1108,11 +1145,14 @@ i915_gem_sw_finish_ioctl(struct drm_device *dev, void *data,
 	if (!(dev->driver->driver_features & DRIVER_GEM))
 		return -ENODEV;
 
-	mutex_lock(&dev->struct_mutex);
 	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
-	if (obj == NULL) {
-		mutex_unlock(&dev->struct_mutex);
+	if (obj == NULL)
 		return -ENOENT;
+
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret) {
+		drm_gem_object_unreference_unlocked(obj);
+		return ret;
 	}
 
 #if WATCH_BUF
@@ -1427,7 +1467,11 @@ i915_gem_mmap_gtt_ioctl(struct drm_device *dev, void *data,
 	if (obj == NULL)
 		return -ENOENT;
 
-	mutex_lock(&dev->struct_mutex);
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret) {
+		drm_gem_object_unreference_unlocked(obj);
+		return ret;
+	}
 
 	obj_priv = to_intel_bo(obj);
 
@@ -3671,16 +3715,12 @@ i915_gem_do_execbuffer(struct drm_device *dev, void *data,
 	if (ret != 0)
 		goto pre_mutex_err;
 
-	mutex_lock(&dev->struct_mutex);
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret)
+		goto pre_mutex_err;
 
 	i915_verify_inactive(dev, __FILE__, __LINE__);
 
-	if (atomic_read(&dev_priv->mm.wedged)) {
-		mutex_unlock(&dev->struct_mutex);
-		ret = -EAGAIN;
-		goto pre_mutex_err;
-	}
-
 	if (dev_priv->mm.suspended) {
 		mutex_unlock(&dev->struct_mutex);
 		ret = -EBUSY;
@@ -4164,21 +4204,20 @@ i915_gem_pin_ioctl(struct drm_device *dev, void *data,
 	struct drm_i915_gem_object *obj_priv;
 	int ret;
 
-	ret = i915_gem_check_is_wedged(dev);
-	if (ret)
-		return ret;
-
-	mutex_lock(&dev->struct_mutex);
-
 	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
 	if (obj == NULL) {
 		DRM_ERROR("Bad handle in i915_gem_pin_ioctl(): %d\n",
 			  args->handle);
-		mutex_unlock(&dev->struct_mutex);
 		return -ENOENT;
 	}
 	obj_priv = to_intel_bo(obj);
 
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret) {
+		drm_gem_object_unreference_unlocked(obj);
+		return ret;
+	}
+
 	if (obj_priv->madv != I915_MADV_WILLNEED) {
 		DRM_ERROR("Attempting to pin a purgeable buffer\n");
 		drm_gem_object_unreference(obj);
@@ -4223,18 +4262,23 @@ i915_gem_unpin_ioctl(struct drm_device *dev, void *data,
 	struct drm_i915_gem_pin *args = data;
 	struct drm_gem_object *obj;
 	struct drm_i915_gem_object *obj_priv;
-
-	mutex_lock(&dev->struct_mutex);
+	int ret;
 
 	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
 	if (obj == NULL) {
 		DRM_ERROR("Bad handle in i915_gem_unpin_ioctl(): %d\n",
 			  args->handle);
-		mutex_unlock(&dev->struct_mutex);
 		return -ENOENT;
 	}
 
 	obj_priv = to_intel_bo(obj);
+
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret) {
+		drm_gem_object_unreference_unlocked(obj);
+		return ret;
+	}
+
 	if (obj_priv->pin_filp != file_priv) {
 		DRM_ERROR("Not pinned by caller in i915_gem_pin_ioctl(): %d\n",
 			  args->handle);
@@ -4257,16 +4301,11 @@ int
 i915_gem_busy_ioctl(struct drm_device *dev, void *data,
 		    struct drm_file *file_priv)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_i915_gem_busy *args = data;
 	struct drm_gem_object *obj;
 	struct drm_i915_gem_object *obj_priv;
 	int ret;
 
-	ret = i915_gem_check_is_wedged(dev);
-	if (ret)
-		return ret;
-
 	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
 	if (obj == NULL) {
 		DRM_ERROR("Bad handle in i915_gem_busy_ioctl(): %d\n",
@@ -4274,11 +4313,10 @@ i915_gem_busy_ioctl(struct drm_device *dev, void *data,
 		return -ENOENT;
 	}
 
-	mutex_lock(&dev->struct_mutex);
-
-	if (atomic_read(&dev_priv->mm.wedged)) {
-		ret = -EAGAIN;
-		goto unlock;
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret) {
+		drm_gem_object_unreference_unlocked(obj);
+		return ret;
 	}
 
 	/* Count all active objects as busy, even if they are currently not used
@@ -4309,10 +4347,9 @@ i915_gem_busy_ioctl(struct drm_device *dev, void *data,
 		args->busy = obj_priv->active;
 	}
 
-unlock:
 	drm_gem_object_unreference(obj);
 	mutex_unlock(&dev->struct_mutex);
-	return ret;
+	return 0;
 }
 
 int
@@ -4329,6 +4366,7 @@ i915_gem_madvise_ioctl(struct drm_device *dev, void *data,
 	struct drm_i915_gem_madvise *args = data;
 	struct drm_gem_object *obj;
 	struct drm_i915_gem_object *obj_priv;
+	int ret;
 
 	switch (args->madv) {
 	case I915_MADV_DONTNEED:
@@ -4344,10 +4382,14 @@ i915_gem_madvise_ioctl(struct drm_device *dev, void *data,
 			  args->handle);
 		return -ENOENT;
 	}
-
-	mutex_lock(&dev->struct_mutex);
 	obj_priv = to_intel_bo(obj);
 
+	ret = i915_mutex_lock_interruptible(dev);
+	if (ret) {
+		drm_gem_object_unreference_unlocked(obj);
+		return ret;
+	}
+
 	if (obj_priv->pin_count) {
 		drm_gem_object_unreference(obj);
 		mutex_unlock(&dev->struct_mutex);
-- 
1.7.6

