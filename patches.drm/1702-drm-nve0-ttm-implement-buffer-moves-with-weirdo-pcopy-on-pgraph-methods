From c6b7e89582bdb028e1b1763197ff24c77a43e1b0 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Tue, 20 Mar 2012 14:36:04 +1000
Subject: drm/nve0/ttm: implement buffer moves with weirdo pcopy-on-pgraph
 methods
Git-commit: c6b7e89582bdb028e1b1763197ff24c77a43e1b0
Patch-mainline: v3.5-rc1

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/nouveau/nouveau_bo.c    |   24 ++++++++++++++++++++++++
 drivers/gpu/drm/nouveau/nouveau_dma.h   |    1 +
 drivers/gpu/drm/nouveau/nouveau_state.c |   14 ++++++++++++++
 3 files changed, 39 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/nouveau_bo.c b/drivers/gpu/drm/nouveau/nouveau_bo.c
index 4435e11..1da4031 100644
--- a/drivers/gpu/drm/nouveau/nouveau_bo.c
+++ b/drivers/gpu/drm/nouveau/nouveau_bo.c
@@ -489,6 +489,27 @@ nouveau_bo_move_accel_cleanup(struct nouveau_channel *chan,
 }
 
 static int
+nve0_bo_move_copy(struct nouveau_channel *chan, struct ttm_buffer_object *bo,
+		  struct ttm_mem_reg *old_mem, struct ttm_mem_reg *new_mem)
+{
+	struct nouveau_mem *node = old_mem->mm_node;
+	int ret = RING_SPACE(chan, 10);
+	if (ret == 0) {
+		BEGIN_NVC0(chan, 2, NvSubCopy, 0x0400, 8);
+		OUT_RING  (chan, upper_32_bits(node->vma[0].offset));
+		OUT_RING  (chan, lower_32_bits(node->vma[0].offset));
+		OUT_RING  (chan, upper_32_bits(node->vma[1].offset));
+		OUT_RING  (chan, lower_32_bits(node->vma[1].offset));
+		OUT_RING  (chan, PAGE_SIZE);
+		OUT_RING  (chan, PAGE_SIZE);
+		OUT_RING  (chan, PAGE_SIZE);
+		OUT_RING  (chan, new_mem->num_pages);
+		BEGIN_NVC0(chan, 8, NvSubCopy, 0x0300, 0x0386);
+	}
+	return ret;
+}
+
+static int
 nvc0_bo_move_m2mf(struct nouveau_channel *chan, struct ttm_buffer_object *bo,
 		  struct ttm_mem_reg *old_mem, struct ttm_mem_reg *new_mem)
 {
@@ -727,7 +748,10 @@ nouveau_bo_move_m2mf(struct ttm_buffer_object *bo, int evict, bool intr,
 	if (dev_priv->card_type < NV_C0)
 		ret = nv50_bo_move_m2mf(chan, bo, &bo->mem, new_mem);
 	else
+	if (dev_priv->card_type < NV_E0)
 		ret = nvc0_bo_move_m2mf(chan, bo, &bo->mem, new_mem);
+	else
+		ret = nve0_bo_move_copy(chan, bo, &bo->mem, new_mem);
 	if (ret == 0) {
 		ret = nouveau_bo_move_accel_cleanup(chan, nvbo, evict,
 						    no_wait_reserve,
diff --git a/drivers/gpu/drm/nouveau/nouveau_dma.h b/drivers/gpu/drm/nouveau/nouveau_dma.h
index 47896c4..f776b6a 100644
--- a/drivers/gpu/drm/nouveau/nouveau_dma.h
+++ b/drivers/gpu/drm/nouveau/nouveau_dma.h
@@ -53,6 +53,7 @@ enum {
 	NvSubCtxSurf2D  = 2,
 	NvSub2D		= 3,
 	NvSubGdiRect    = 3,
+	NvSubCopy	= 4,
 	NvSubImageBlit  = 4
 };
 
diff --git a/drivers/gpu/drm/nouveau/nouveau_state.c b/drivers/gpu/drm/nouveau/nouveau_state.c
index 2dd7187..78fb2cb 100644
--- a/drivers/gpu/drm/nouveau/nouveau_state.c
+++ b/drivers/gpu/drm/nouveau/nouveau_state.c
@@ -657,6 +657,20 @@ nouveau_card_channel_init(struct drm_device *dev)
 
 		BEGIN_NVC0(chan, 2, NvSubM2MF, 0x0000, 1);
 		OUT_RING  (chan, 0x00009039);
+	} else
+	if (dev_priv->card_type <= NV_E0) {
+		/* not used, but created to get a graph context */
+		ret = nouveau_gpuobj_gr_new(chan, 0xa040, 0xa040);
+		if (ret)
+			goto error;
+
+		/* bind strange copy engine to subchannel 4 (fixed...) */
+		ret = RING_SPACE(chan, 2);
+		if (ret)
+			goto error;
+
+		BEGIN_NVC0(chan, 2, NvSubCopy, 0x0000, 1);
+		OUT_RING  (chan, 0x0000a0b5);
 	}
 
 	FIRE_RING (chan);

