From b37a6b9ad002a6c123a6924668dfef5c5fb0b700 Mon Sep 17 00:00:00 2001
From: Thomas Hellstrom <thellstrom@vmware.com>
Date: Tue, 4 Oct 2011 20:13:28 +0200
Subject: vmwgfx: minor dmabuf utilities cleanup
Git-commit: b37a6b9ad002a6c123a6924668dfef5c5fb0b700
Patch-mainline: v3.2-rc1

Add / fix some function comments.
Don't move out an fbdev framebuffer when unused. Just unpin.
Only have a single function that computes a SVGAGuestPtr from the buffer's
current placement, and make it more versatile by accepting a
struct ttm_buffer_object

Signed-off-by: Thomas Hellstrom <thellstrom@vmware.com>
Reviewed-by: Jakob Bornecrantz <jakob@vmware.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c  |   86 +++++++++++++------------------
 drivers/gpu/drm/vmwgfx/vmwgfx_drv.h     |    9 +---
 drivers/gpu/drm/vmwgfx/vmwgfx_fb.c      |    3 +-
 drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c |   10 ++--
 drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c    |    2 +-
 5 files changed, 45 insertions(+), 65 deletions(-)

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c
index 5668ad9..7f744a8 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_dmabuf.c
@@ -32,10 +32,16 @@
 
 
 /**
- * Validate a buffer to placement.
+ * vmw_dmabuf_to_placement - Validate a buffer to placement.
  *
- * May only be called by the current master as this function takes the
- * its lock in write mode.
+ * @dev_priv:  Driver private.
+ * @buf:  DMA buffer to move.
+ * @pin:  Pin buffer if true.
+ * @interruptible:  Use interruptible wait.
+ *
+ * May only be called by the current master since it assumes that the
+ * master lock is the current master's lock.
+ * This function takes the master's lock in write mode.
  *
  * Returns
  *  -ERESTARTSYS if interrupted by a signal.
@@ -67,10 +73,11 @@ err:
 }
 
 /**
- * Move a buffer to vram or gmr.
+ * vmw_dmabuf_to_vram_or_gmr - Move a buffer to vram or gmr.
  *
- * May only be called by the current master as this function takes the
- * its lock in write mode.
+ * May only be called by the current master since it assumes that the
+ * master lock is the current master's lock.
+ * This function takes the master's lock in write mode.
  *
  * @dev_priv:  Driver private.
  * @buf:  DMA buffer to move.
@@ -134,10 +141,11 @@ err:
 }
 
 /**
- * Move a buffer to vram.
+ * vmw_dmabuf_to_vram - Move a buffer to vram.
  *
- * May only be called by the current master as this function takes the
- * its lock in write mode.
+ * May only be called by the current master since it assumes that the
+ * master lock is the current master's lock.
+ * This function takes the master's lock in write mode.
  *
  * @dev_priv:  Driver private.
  * @buf:  DMA buffer to move.
@@ -164,10 +172,11 @@ int vmw_dmabuf_to_vram(struct vmw_private *dev_priv,
 }
 
 /**
- * Move a buffer to start of vram.
+ * vmw_dmabuf_to_start_of_vram - Move a buffer to start of vram.
  *
- * May only be called by the current master as this function takes the
- * its lock in write mode.
+ * May only be called by the current master since it assumes that the
+ * master lock is the current master's lock.
+ * This function takes the master's lock in write mode.
  *
  * @dev_priv:  Driver private.
  * @buf:  DMA buffer to move.
@@ -219,11 +228,13 @@ err_unlock:
 	return ret;
 }
 
+
 /**
- * Unpin the buffer given buffer, does not move the buffer.
+ * vmw_dmabuf_upin - Unpin the buffer given buffer, does not move the buffer.
  *
- * May only be called by the current master as this function takes the
- * its lock in write mode.
+ * May only be called by the current master since it assumes that the
+ * master lock is the current master's lock.
+ * This function takes the master's lock in write mode.
  *
  * @dev_priv:  Driver private.
  * @buf:  DMA buffer to unpin.
@@ -246,47 +257,22 @@ int vmw_dmabuf_unpin(struct vmw_private *dev_priv,
 				       interruptible);
 }
 
+
 /**
- * Move a buffer to system memory, does not pin the buffer.
- *
- * May only be called by the current master as this function takes the
- * its lock in write mode.
- *
- * @dev_priv:  Driver private.
- * @buf:  DMA buffer to move.
- * @interruptible:  Use interruptible wait.
+ * vmw_bo_get_guest_ptr - Get the guest ptr representing the current placement
+ * of a buffer.
  *
- * Returns
- * -ERESTARTSYS if interrupted by a signal.
+ * @bo: Pointer to a struct ttm_buffer_object. Must be pinned or reserved.
+ * @ptr: SVGAGuestPtr returning the result.
  */
-int vmw_dmabuf_to_system(struct vmw_private *dev_priv,
-			 struct vmw_dma_buffer *buf,
-			 bool interruptible)
-{
-	return vmw_dmabuf_to_placement(dev_priv, buf,
-				       &vmw_sys_placement,
-				       interruptible);
-}
-
-void vmw_dmabuf_get_id_offset(struct vmw_dma_buffer *buf,
-			      uint32_t *gmrId, uint32_t *offset)
-{
-	if (buf->base.mem.mem_type == TTM_PL_VRAM) {
-		*gmrId = SVGA_GMR_FRAMEBUFFER;
-		*offset = buf->base.offset;
-	} else {
-		*gmrId = buf->base.mem.start;
-		*offset = 0;
-	}
-}
-
-void vmw_dmabuf_get_guest_ptr(struct vmw_dma_buffer *buf, SVGAGuestPtr *ptr)
+void vmw_bo_get_guest_ptr(const struct ttm_buffer_object *bo,
+			  SVGAGuestPtr *ptr)
 {
-	if (buf->base.mem.mem_type == TTM_PL_VRAM) {
+	if (bo->mem.mem_type == TTM_PL_VRAM) {
 		ptr->gmrId = SVGA_GMR_FRAMEBUFFER;
-		ptr->offset = buf->base.offset;
+		ptr->offset = bo->offset;
 	} else {
-		ptr->gmrId = buf->base.mem.start;
+		ptr->gmrId = bo->mem.start;
 		ptr->offset = 0;
 	}
 }
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
index fc0e3bc..b22b96a 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
@@ -416,13 +416,8 @@ extern int vmw_dmabuf_to_start_of_vram(struct vmw_private *vmw_priv,
 extern int vmw_dmabuf_unpin(struct vmw_private *vmw_priv,
 			    struct vmw_dma_buffer *bo,
 			    bool interruptible);
-extern int vmw_dmabuf_to_system(struct vmw_private *vmw_priv,
-				struct vmw_dma_buffer *bo,
-				bool interruptible);
-extern void vmw_dmabuf_get_id_offset(struct vmw_dma_buffer *buf,
-				     uint32_t *gmrId, uint32_t *offset);
-extern void vmw_dmabuf_get_guest_ptr(struct vmw_dma_buffer *buf,
-				     SVGAGuestPtr *ptr);
+extern void vmw_bo_get_guest_ptr(const struct ttm_buffer_object *buf,
+				 SVGAGuestPtr *ptr);
 
 /**
  * Misc Ioctl functionality - vmwgfx_ioctl.c
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c b/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c
index 191f1b2..070797b 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_fb.c
@@ -613,8 +613,7 @@ int vmw_fb_off(struct vmw_private *vmw_priv)
 	par->bo_ptr = NULL;
 	ttm_bo_kunmap(&par->map);
 
-	/* move this to system instead of just unpinning it */
-	vmw_dmabuf_to_system(vmw_priv, par->vmw_bo, false);
+	vmw_dmabuf_unpin(vmw_priv, par->vmw_bo, false);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c b/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
index 29481e1..14399ee 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c
@@ -99,9 +99,9 @@ static int vmw_overlay_send_put(struct vmw_private *dev_priv,
 {
 	struct vmw_escape_video_flush *flush;
 	size_t fifo_size;
-	uint32_t gmrId, offset;
 	bool have_so = dev_priv->sou_priv ? true : false;
 	int i, num_items;
+	SVGAGuestPtr ptr;
 
 	struct {
 		struct vmw_escape_header escape;
@@ -141,12 +141,12 @@ static int vmw_overlay_send_put(struct vmw_private *dev_priv,
 	for (i = 0; i < num_items; i++)
 		items[i].registerId = i;
 
-	vmw_dmabuf_get_id_offset(buf, &gmrId, &offset);
-	offset += arg->offset;
+	vmw_bo_get_guest_ptr(&buf->base, &ptr);
+	ptr.offset += arg->offset;
 
 	items[SVGA_VIDEO_ENABLED].value     = true;
 	items[SVGA_VIDEO_FLAGS].value       = arg->flags;
-	items[SVGA_VIDEO_DATA_OFFSET].value = offset;
+	items[SVGA_VIDEO_DATA_OFFSET].value = ptr.offset;
 	items[SVGA_VIDEO_FORMAT].value      = arg->format;
 	items[SVGA_VIDEO_COLORKEY].value    = arg->color_key;
 	items[SVGA_VIDEO_SIZE].value        = arg->size;
@@ -164,7 +164,7 @@ static int vmw_overlay_send_put(struct vmw_private *dev_priv,
 	items[SVGA_VIDEO_PITCH_2].value     = arg->pitch[1];
 	items[SVGA_VIDEO_PITCH_3].value     = arg->pitch[2];
 	if (have_so) {
-		items[SVGA_VIDEO_DATA_GMRID].value    = gmrId;
+		items[SVGA_VIDEO_DATA_GMRID].value    = ptr.gmrId;
 		items[SVGA_VIDEO_DST_SCREEN_ID].value = SVGA_ID_INVALID;
 	}
 
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c b/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c
index e74b8e3..347e406 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c
@@ -168,7 +168,7 @@ static int vmw_sou_fifo_create(struct vmw_private *dev_priv,
 	cmd->obj.root.y = y;
 
 	/* Ok to assume that buffer is pinned in vram */
-	vmw_dmabuf_get_guest_ptr(sou->buffer, &cmd->obj.backingStore.ptr);
+	vmw_bo_get_guest_ptr(&sou->buffer->base, &cmd->obj.backingStore.ptr);
 	cmd->obj.backingStore.pitch = mode->hdisplay * 4;
 
 	vmw_fifo_commit(dev_priv, fifo_size);

