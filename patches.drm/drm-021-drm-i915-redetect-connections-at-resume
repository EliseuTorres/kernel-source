From: Takashi Iwai <tiwai@suse.de>
Subject: [PATCH] drm/i915: re-detect connections at resume
Patch-mainline: Submitted
References: 

When the connection status was changed after S3/S4 (before resume),
the driver still keeps the old modesets after resume.  Then when the
connection is restored again to the original state (e.g. plugging a
VGA again), it gets hotplug notification and tries to switch to the
wrong fb as if it were active.

This patch adds a call to re-probe the connections on resume to
make the connection status sane.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/i915_drv.c |    2 ++
 drivers/gpu/drm/i915/i915_drv.h |    1 +
 drivers/gpu/drm/i915/i915_irq.c |   13 +++++++++----
 3 files changed, 12 insertions(+), 4 deletions(-)

--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -437,6 +437,8 @@
 		drm_mode_config_reset(dev);
 		drm_irq_install(dev);
 
+		i915_handle_hotplug(dev);
+
 		/* Resume the modeset for every activated CRTC */
 		drm_helper_resume_force_mode(dev);
 
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1031,6 +1031,7 @@
 			 struct drm_file *file_priv);
 extern int i915_irq_wait(struct drm_device *dev, void *data,
 			 struct drm_file *file_priv);
+extern void i915_handle_hotplug(struct drm_device *dev);
 
 extern void intel_irq_init(struct drm_device *dev);
 
--- a/drivers/gpu/drm/i915/i915_irq.c
+++ b/drivers/gpu/drm/i915/i915_irq.c
@@ -298,11 +298,8 @@
 /*
  * Handle hotplug events outside the interrupt handler proper.
  */
-static void i915_hotplug_work_func(struct work_struct *work)
+void i915_handle_hotplug(struct drm_device *dev)
 {
-	drm_i915_private_t *dev_priv = container_of(work, drm_i915_private_t,
-						    hotplug_work);
-	struct drm_device *dev = dev_priv->dev;
 	struct drm_mode_config *mode_config = &dev->mode_config;
 	struct intel_encoder *encoder;
 
@@ -316,6 +313,14 @@
 	drm_helper_hpd_irq_event(dev);
 }
 
+static void i915_hotplug_work_func(struct work_struct *work)
+{
+	drm_i915_private_t *dev_priv = container_of(work, drm_i915_private_t,
+						    hotplug_work);
+	struct drm_device *dev = dev_priv->dev;
+	i915_handle_hotplug(dev);
+}
+
 static void i915_handle_rps_change(struct drm_device *dev)
 {
 	drm_i915_private_t *dev_priv = dev->dev_private;
