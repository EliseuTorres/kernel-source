From b45e4e40a734c6635202b82aa9434d26a7303bb9 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Sun, 8 Aug 2010 11:53:53 +0100
Patch-mainline: 2.6.37
References: fate#310916
Git-commit: 4b60e5cb707aa1d44fd01680296a2caf45dd6fae
Subject: [PATCH 1333/2588] drm/i915: Clear scanline waits after disabling the
 pipe.

If we disable the pipe and the GPU is currently waiting on a scanline
WAIT_FOR_EVENT, the GPU will hang. Fortunately, there is a magic bit
which we can write on i915+ to break this wait after disabling the
pipe.

References:

  Bug 29252 - [Arrandale] Hung WAIT_FOR_EVENT when running rss-glx-skyrocket
  https://bugs.freedesktop.org/show_bug.cgi?id=29252

  Bug 28964 - [i965gm] GPU infinite MI_WAIT_FOR_EVENT while watching video in Totem
  https://bugs.freedesktop.org/show_bug.cgi?id=28964

and many others.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
(cherry picked from commit 4b60e5cb707aa1d44fd01680296a2caf45dd6fae)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_reg.h      |    2 ++
 drivers/gpu/drm/i915/intel_display.c |   31 +++++++++++++++++++++++++++++--
 2 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
index 2fa37f8..9559779 100644
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@ -295,6 +295,8 @@
 #define   RING_VALID_MASK	0x00000001
 #define   RING_VALID		0x00000001
 #define   RING_INVALID		0x00000000
+#define   RING_WAIT_I8XX	(1<<0) /* gen2, PRBx_HEAD */
+#define   RING_WAIT		(1<<11) /* gen3+, PRBx_CTL */
 #define PRB1_TAIL	0x02040 /* 915+ only */
 #define PRB1_HEAD	0x02044 /* 915+ only */
 #define PRB1_START	0x02048 /* 915+ only */
diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 8b67231..5a7f9d7 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -2361,6 +2361,26 @@ static void i9xx_crtc_dpms(struct drm_crtc *crtc, int mode)
 	}
 }
 
+/*
+ * When we disable a pipe, we need to clear any pending scanline wait events
+ * to avoid hanging the ring, which we assume we are waiting on.
+ */
+static void intel_clear_scanline_wait(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	u32 tmp;
+
+	if (IS_GEN2(dev))
+		/* Can't break the hang on i8xx */
+		return;
+
+	tmp = I915_READ(PRB0_CTL);
+	if (tmp & RING_WAIT) {
+		I915_WRITE(PRB0_CTL, tmp);
+		POSTING_READ(PRB0_CTL);
+	}
+}
+
 /**
  * Sets the power management mode of the pipe and plane.
  */
@@ -2383,7 +2403,8 @@ static void intel_crtc_dpms(struct drm_crtc *crtc, int mode)
 	 * with multiple pipes prior to enabling to new pipe.
 	 *
 	 * When switching off the display, make sure the cursor is
-	 * properly hidden prior to disabling the pipe.
+	 * properly hidden and there are no pending waits prior to
+	 * disabling the pipe.
 	 */
 	if (mode == DRM_MODE_DPMS_ON)
 		intel_update_watermarks(dev);
@@ -2394,8 +2415,14 @@ static void intel_crtc_dpms(struct drm_crtc *crtc, int mode)
 
 	if (mode == DRM_MODE_DPMS_ON)
 		intel_crtc_update_cursor(crtc);
-	else
+	else {
+		/* XXX Note that this is not a complete solution, but a hack
+		 * to avoid the most frequently hit hang.
+		 */
+		intel_clear_scanline_wait(dev);
+
 		intel_update_watermarks(dev);
+	}
 
 	if (!dev->primary->master)
 		return;
-- 
1.7.6

