From 20b46e59dd102665ce7168baa215e5b1ee66b69b Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Thu, 26 Jul 2012 11:16:14 +0200
Subject: drm/i915: Only set the down rps limit when at the loweset frequency
Git-commit: 20b46e59dd102665ce7168baa215e5b1ee66b69b
Patch-mainline: v3.7-rc1

The power docs say that when the gt leaves rc6, it is in the lowest
frequency and only about 25 usec later will switch to the frequency
selected in GEN6_RPNSWREQ. If the downclock limit expires in that
window and the down limit is set to the lowest possible frequency, the
hw will not send the down interrupt. Which leads to a too high gpu
clock and wasted power.

Chris Wilson already worked on this with

commit 7b9e0ae6da0a7eaf2680a1a788f08df123724f3b
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Apr 28 08:56:39 2012 +0100

    drm/i915: Always update RPS interrupts thresholds along with
    frequency

but got the logic inverted: The current code set the down limit as
long as we haven't reached it. Instead of only once with reached the
lowest frequency.

Note that we can't always set the downclock limit to 0, because
otherwise the hw will keep on bugging us with downclock request irqs
once the lowest level is reached.

For similar reasons also always set the upclock limit, otherwise the
hw might poke us again with interrupts.

v2: Chris Wilson noticed that the limit reg is also computed in
sanitize_pm. To avoid duplication, extract the code into a common
function.

Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/i915/intel_pm.c |   39 +++++++++++++++++++++++----------------
 1 files changed, 23 insertions(+), 16 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c
index 85d1b1c..e8727da 100644
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@ -2267,21 +2267,33 @@ static void ironlake_disable_drps(struct drm_device *dev)
 
 }
 
-void gen6_set_rps(struct drm_device *dev, u8 val)
+static u32 gen6_rps_limits(struct drm_i915_private *dev_priv, u8 val)
 {
-	struct drm_i915_private *dev_priv = dev->dev_private;
 	u32 limits;
 
 	limits = 0;
 	if (val >= dev_priv->max_delay)
 		val = dev_priv->max_delay;
-	else
-		limits |= dev_priv->max_delay << 24;
+	limits |= dev_priv->max_delay << 24;
 
-	if (val <= dev_priv->min_delay)
+	/* Only set the down limit when we've reached the lowest level to avoid
+	 * getting more interrupts, otherwise leave this clear. This prevents a
+	 * race in the hw when coming out of rc6: There's a tiny window where
+	 * the hw runs at the minimal clock before selecting the desired
+	 * frequency, if the down threshold expires in that window we will not
+	 * receive a down interrupt. */
+	if (val <= dev_priv->min_delay) {
 		val = dev_priv->min_delay;
-	else
 		limits |= dev_priv->min_delay << 16;
+	}
+
+	return limits;
+}
+
+void gen6_set_rps(struct drm_device *dev, u8 val)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	u32 limits = gen6_rps_limits(dev_priv, val);
 
 	if (val == dev_priv->cur_delay)
 		return;
@@ -3741,25 +3753,20 @@ void intel_init_clock_gating(struct drm_device *dev)
 static void gen6_sanitize_pm(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
-	u32 limits, delay, old;
+	u32 limits, current_limits;
 
 	gen6_gt_force_wake_get(dev_priv);
 
-	old = limits = I915_READ(GEN6_RP_INTERRUPT_LIMITS);
+	current_limits = I915_READ(GEN6_RP_INTERRUPT_LIMITS);
 	/* Make sure we continue to get interrupts
 	 * until we hit the minimum or maximum frequencies.
 	 */
-	limits &= ~(0x3f << 16 | 0x3f << 24);
-	delay = dev_priv->cur_delay;
-	if (delay < dev_priv->max_delay)
-		limits |= (dev_priv->max_delay & 0x3f) << 24;
-	if (delay > dev_priv->min_delay)
-		limits |= (dev_priv->min_delay & 0x3f) << 16;
+	limits = gen6_rps_limits(dev_priv, dev_priv->cur_delay);
 
-	if (old != limits) {
+	if (current_limits != limits) {
 		/* Note that the known failure case is to read back 0. */
 		DRM_DEBUG_DRIVER("Power management discrepancy: GEN6_RP_INTERRUPT_LIMITS "
-				 "expected %08x, was %08x\n", limits, old);
+				 "expected %08x, was %08x\n", limits, current_limits);
 		I915_WRITE(GEN6_RP_INTERRUPT_LIMITS, limits);
 	}
 

