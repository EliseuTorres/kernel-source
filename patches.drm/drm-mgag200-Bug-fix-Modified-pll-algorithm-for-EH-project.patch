From: Julia Lemire <jlemire@matrox.com>
Date: Mon Mar 18 10:17:47 2013 -0400
Subject: drm/mgag200: Bug fix: Modified pll algorithm for EH project
Patch-Mainline: Upstream/v3.9-rc4
Git-commit: 260b3f1291a75a580d22ce8bfb1499c617272716

References: bnc#841654
Signed-off-by: Egbert Eich <eich@suse.com>

While testing the mgag200 kms driver on the HP ProLiant Gen8, a
bug was seen.  Once the bootloader would load the selected kernel,
the screen would go black.  At first it was assumed that the
mgag200 kms driver was hanging.  But after setting up the grub
serial output, it was seen that the driver was being loaded
properly.  After trying serval monitors, one finaly displayed
the message "Frequency Out of Range".  By comparing the kms pll
algorithm with the previous mgag200 xorg driver pll algorithm,
discrepencies were found.  Once the kms pll algorithm was
modified, the expected pll values were produced.  This fix was
tested on several monitors of varying native resolutions.

Signed-off-by: Julia Lemire <jlemire@matrox.com>
Cc: stable@vger.kernel.org
Signed-off-by: Dave Airlie <airlied@redhat.com>
---
 drivers/gpu/drm/mgag200/mgag200_mode.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

--- linux-3.0-SLE11-SP3.orig/drivers/gpu/drm/mgag200/mgag200_mode.c
+++ linux-3.0-SLE11-SP3/drivers/gpu/drm/mgag200/mgag200_mode.c
@@ -405,19 +405,19 @@ static int mga_g200eh_set_plls(struct mg
 	m = n = p = 0;
 	vcomax = 800000;
 	vcomin = 400000;
-	pllreffreq = 3333;
+	pllreffreq = 33333;
 
 	delta = 0xffffffff;
 	permitteddelta = clock * 5 / 1000;
 
-	for (testp = 16; testp > 0; testp--) {
+	for (testp = 16; testp > 0; testp >>= 1) {
 		if (clock * testp > vcomax)
 			continue;
 		if (clock * testp < vcomin)
 			continue;
 
 		for (testm = 1; testm < 33; testm++) {
-			for (testn = 1; testn < 257; testn++) {
+			for (testn = 17; testn < 257; testn++) {
 				computed = (pllreffreq * testn) /
 					(testm * testp);
 				if (computed > clock)
@@ -427,11 +427,11 @@ static int mga_g200eh_set_plls(struct mg
 				if (tmpdelta < delta) {
 					delta = tmpdelta;
 					n = testn - 1;
-					m = (testm - 1) | ((n >> 1) & 0x80);
+					m = (testm - 1);
 					p = testp - 1;
 				}
 				if ((clock * testp) >= 600000)
-					p |= 80;
+					p |= 0x80;
 			}
 		}
 	}
