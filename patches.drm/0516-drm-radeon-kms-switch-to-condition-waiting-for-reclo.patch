From 27fa660c27a37118e66a94c0c9a355f25be723de Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <zajec5@gmail.com>
Date: Tue, 2 Mar 2010 22:06:51 +0100
Patch-mainline: 2.6.34
References: fate#310916
Git-commit: 839461d3b0e3082eb382f17a3e3899372f28649a
Subject: [PATCH 0516/2588] drm/radeon/kms: switch to condition waiting for
 reclocking
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We tried to implement interruptible waiting with timeout (it was broken
anyway) which was not a good idea as explained by Andrew. It's possible
to avoid using additional variable but actually it inroduces using more
complex in-kernel tools. So simply add one variable for condition.

Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 839461d3b0e3082eb382f17a3e3899372f28649a)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/radeon/r100.c      |    8 +++---
 drivers/gpu/drm/radeon/r600.c      |    8 +++---
 drivers/gpu/drm/radeon/radeon.h    |    1 +
 drivers/gpu/drm/radeon/radeon_pm.c |   39 ++++++++++++++++++++++-------------
 drivers/gpu/drm/radeon/rs600.c     |    8 +++---
 5 files changed, 37 insertions(+), 27 deletions(-)

diff --git a/drivers/gpu/drm/radeon/r100.c b/drivers/gpu/drm/radeon/r100.c
index 2ec135f..7f09f0c 100644
--- a/drivers/gpu/drm/radeon/r100.c
+++ b/drivers/gpu/drm/radeon/r100.c
@@ -313,13 +313,13 @@ int r100_irq_process(struct radeon_device *rdev)
 		/* Vertical blank interrupts */
 		if (status & RADEON_CRTC_VBLANK_STAT) {
 			drm_handle_vblank(rdev->ddev, 0);
-			if (rdev->pm.vblank_callback)
-				queue_work(rdev->wq, &rdev->pm.reclock_work);
+			rdev->pm.vblank_sync = true;
+			wake_up(&rdev->irq.vblank_queue);
 		}
 		if (status & RADEON_CRTC2_VBLANK_STAT) {
 			drm_handle_vblank(rdev->ddev, 1);
-			if (rdev->pm.vblank_callback)
-				queue_work(rdev->wq, &rdev->pm.reclock_work);
+			rdev->pm.vblank_sync = true;
+			wake_up(&rdev->irq.vblank_queue);
 		}
 		if (status & RADEON_FP_DETECT_STAT) {
 			queue_hotplug = true;
diff --git a/drivers/gpu/drm/radeon/r600.c b/drivers/gpu/drm/radeon/r600.c
index cf76e55..3df4583 100644
--- a/drivers/gpu/drm/radeon/r600.c
+++ b/drivers/gpu/drm/radeon/r600.c
@@ -2766,8 +2766,8 @@ restart_ih:
 			case 0: /* D1 vblank */
 				if (disp_int & LB_D1_VBLANK_INTERRUPT) {
 					drm_handle_vblank(rdev->ddev, 0);
-					if (rdev->pm.vblank_callback)
-						queue_work(rdev->wq, &rdev->pm.reclock_work);
+					rdev->pm.vblank_sync = true;
+					wake_up(&rdev->irq.vblank_queue);
 					disp_int &= ~LB_D1_VBLANK_INTERRUPT;
 					DRM_DEBUG("IH: D1 vblank\n");
 				}
@@ -2788,8 +2788,8 @@ restart_ih:
 			case 0: /* D2 vblank */
 				if (disp_int & LB_D2_VBLANK_INTERRUPT) {
 					drm_handle_vblank(rdev->ddev, 1);
-					if (rdev->pm.vblank_callback)
-						queue_work(rdev->wq, &rdev->pm.reclock_work);
+					rdev->pm.vblank_sync = true;
+					wake_up(&rdev->irq.vblank_queue);
 					disp_int &= ~LB_D2_VBLANK_INTERRUPT;
 					DRM_DEBUG("IH: D2 vblank\n");
 				}
diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h
index 4b95d47..c57b46e 100644
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
@@ -689,6 +689,7 @@ struct radeon_pm {
 	bool			vblank_callback;
 	int			active_crtcs;
 	int			req_vblank;
+	bool			vblank_sync;
 	fixed20_12		max_bandwidth;
 	fixed20_12		igp_sideport_mclk;
 	fixed20_12		igp_system_mclk;
diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index bd99c81..5cab7ac 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
@@ -360,21 +360,30 @@ static void radeon_pm_set_clocks_locked(struct radeon_device *rdev)
 
 static void radeon_pm_set_clocks(struct radeon_device *rdev)
 {
-	mutex_lock(&rdev->pm.mutex);
-	/* new VBLANK irq may come before handling previous one */
-	if (rdev->pm.vblank_callback) {
-		mutex_lock(&rdev->cp.mutex);
-		if (rdev->pm.req_vblank & (1 << 0)) {
-			rdev->pm.req_vblank &= ~(1 << 0);
-			drm_vblank_put(rdev->ddev, 0);
-		}
-		if (rdev->pm.req_vblank & (1 << 1)) {
-			rdev->pm.req_vblank &= ~(1 << 1);
-			drm_vblank_put(rdev->ddev, 1);
-		}
-		rdev->pm.vblank_callback = false;
-		radeon_pm_set_clocks_locked(rdev);
-		mutex_unlock(&rdev->cp.mutex);
+	radeon_get_power_state(rdev, rdev->pm.planned_action);
+	mutex_lock(&rdev->cp.mutex);
+
+	if (rdev->pm.active_crtcs & (1 << 0)) {
+		rdev->pm.req_vblank |= (1 << 0);
+		drm_vblank_get(rdev->ddev, 0);
+	}
+	if (rdev->pm.active_crtcs & (1 << 1)) {
+		rdev->pm.req_vblank |= (1 << 1);
+		drm_vblank_get(rdev->ddev, 1);
+	}
+	if (rdev->pm.active_crtcs) {
+		rdev->pm.vblank_sync = false;
+		wait_event_timeout(
+			rdev->irq.vblank_queue, rdev->pm.vblank_sync,
+			msecs_to_jiffies(RADEON_WAIT_VBLANK_TIMEOUT));
+	}
+	if (rdev->pm.req_vblank & (1 << 0)) {
+		rdev->pm.req_vblank &= ~(1 << 0);
+		drm_vblank_put(rdev->ddev, 0);
+	}
+	if (rdev->pm.req_vblank & (1 << 1)) {
+		rdev->pm.req_vblank &= ~(1 << 1);
+		drm_vblank_put(rdev->ddev, 1);
 	}
 	mutex_unlock(&rdev->pm.mutex);
 }
diff --git a/drivers/gpu/drm/radeon/rs600.c b/drivers/gpu/drm/radeon/rs600.c
index 58583b3..0683685 100644
--- a/drivers/gpu/drm/radeon/rs600.c
+++ b/drivers/gpu/drm/radeon/rs600.c
@@ -392,13 +392,13 @@ int rs600_irq_process(struct radeon_device *rdev)
 		/* Vertical blank interrupts */
 		if (G_007EDC_LB_D1_VBLANK_INTERRUPT(r500_disp_int)) {
 			drm_handle_vblank(rdev->ddev, 0);
-			if (rdev->pm.vblank_callback)
-				queue_work(rdev->wq, &rdev->pm.reclock_work);
+			rdev->pm.vblank_sync = true;
+			wake_up(&rdev->irq.vblank_queue);
 		}
 		if (G_007EDC_LB_D2_VBLANK_INTERRUPT(r500_disp_int)) {
 			drm_handle_vblank(rdev->ddev, 1);
-			if (rdev->pm.vblank_callback)
-				queue_work(rdev->wq, &rdev->pm.reclock_work);
+			rdev->pm.vblank_sync = true;
+			wake_up(&rdev->irq.vblank_queue);
 		}
 		if (G_007EDC_DC_HOT_PLUG_DETECT1_INTERRUPT(r500_disp_int)) {
 			queue_hotplug = true;
-- 
1.7.6

