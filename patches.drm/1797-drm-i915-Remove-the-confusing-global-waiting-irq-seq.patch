From 73db127a51b346c96232ba8283753b33297c5db9 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Wed, 27 Oct 2010 15:27:33 +0100
Patch-mainline: 2.6.38
References: fate#310916
Git-commit: b2223497b44a4701d1be873d1e9453d7f720043b
Subject: [PATCH 1797/2588] drm/i915: Remove the confusing global waiting/irq
 seqno

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit b2223497b44a4701d1be873d1e9453d7f720043b)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_debugfs.c     |   44 +++++++++++++-----------------
 drivers/gpu/drm/i915/i915_drv.h         |   10 -------
 drivers/gpu/drm/i915/i915_gem.c         |    4 +-
 drivers/gpu/drm/i915/i915_irq.c         |    6 ++--
 drivers/gpu/drm/i915/intel_ringbuffer.h |    4 +-
 5 files changed, 26 insertions(+), 42 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
index fa7c671..819266f 100644
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@ -319,6 +319,19 @@ static int i915_gem_request_info(struct seq_file *m, void *data)
 	return 0;
 }
 
+static void i915_ring_seqno_info(struct seq_file *m,
+				 struct intel_ring_buffer *ring)
+{
+	if (ring->get_seqno) {
+		seq_printf(m, "Current sequence (%s): %d\n",
+			   ring->name, ring->get_seqno(ring));
+		seq_printf(m, "Waiter sequence (%s):  %d\n",
+			   ring->name, ring->waiting_seqno);
+		seq_printf(m, "IRQ sequence (%s):     %d\n",
+			   ring->name, ring->irq_seqno);
+	}
+}
+
 static int i915_gem_seqno_info(struct seq_file *m, void *data)
 {
 	struct drm_info_node *node = (struct drm_info_node *) m->private;
@@ -330,15 +343,9 @@ static int i915_gem_seqno_info(struct seq_file *m, void *data)
 	if (ret)
 		return ret;
 
-	if (dev_priv->render_ring.status_page.page_addr != NULL) {
-		seq_printf(m, "Current sequence: %d\n",
-			   dev_priv->render_ring.get_seqno(&dev_priv->render_ring));
-	} else {
-		seq_printf(m, "Current sequence: hws uninitialized\n");
-	}
-	seq_printf(m, "Waiter sequence:  %d\n",
-			dev_priv->mm.waiting_gem_seqno);
-	seq_printf(m, "IRQ sequence:     %d\n", dev_priv->mm.irq_gem_seqno);
+	i915_ring_seqno_info(m, &dev_priv->render_ring);
+	i915_ring_seqno_info(m, &dev_priv->bsd_ring);
+	i915_ring_seqno_info(m, &dev_priv->blt_ring);
 
 	mutex_unlock(&dev->struct_mutex);
 
@@ -390,22 +397,9 @@ static int i915_interrupt_info(struct seq_file *m, void *data)
 	}
 	seq_printf(m, "Interrupts received: %d\n",
 		   atomic_read(&dev_priv->irq_received));
-	if (dev_priv->render_ring.get_seqno) {
-		seq_printf(m, "Current sequence (render):    %d\n",
-			   dev_priv->render_ring.get_seqno(&dev_priv->render_ring));
-	}
-	if (dev_priv->bsd_ring.get_seqno) {
-		seq_printf(m, "Current sequence (BSD):    %d\n",
-			   dev_priv->bsd_ring.get_seqno(&dev_priv->bsd_ring));
-	}
-	if (dev_priv->blt_ring.get_seqno) {
-		seq_printf(m, "Current sequence (BLT):    %d\n",
-			   dev_priv->blt_ring.get_seqno(&dev_priv->blt_ring));
-	}
-	seq_printf(m, "Waiter sequence:     %d\n",
-		   dev_priv->mm.waiting_gem_seqno);
-	seq_printf(m, "IRQ sequence:        %d\n",
-		   dev_priv->mm.irq_gem_seqno);
+	i915_ring_seqno_info(m, &dev_priv->render_ring);
+	i915_ring_seqno_info(m, &dev_priv->bsd_ring);
+	i915_ring_seqno_info(m, &dev_priv->blt_ring);
 	mutex_unlock(&dev->struct_mutex);
 
 	return 0;
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index eb067c1..4531e1b 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -609,16 +609,6 @@ typedef struct drm_i915_private {
 		struct delayed_work retire_work;
 
 		/**
-		 * Waiting sequence number, if any
-		 */
-		uint32_t waiting_gem_seqno;
-
-		/**
-		 * Last seq seen at irq time
-		 */
-		uint32_t irq_gem_seqno;
-
-		/**
 		 * Flag if the X Server, and thus DRM, is not currently in
 		 * control of the device.
 		 *
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 5ec6251..31a4ada 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -1974,7 +1974,7 @@ i915_do_wait_request(struct drm_device *dev, uint32_t seqno,
 
 		trace_i915_gem_request_wait_begin(dev, seqno);
 
-		ring->waiting_gem_seqno = seqno;
+		ring->waiting_seqno = seqno;
 		ring->user_irq_get(ring);
 		if (interruptible)
 			ret = wait_event_interruptible(ring->irq_queue,
@@ -1986,7 +1986,7 @@ i915_do_wait_request(struct drm_device *dev, uint32_t seqno,
 				|| atomic_read(&dev_priv->mm.wedged));
 
 		ring->user_irq_put(ring);
-		ring->waiting_gem_seqno = 0;
+		ring->waiting_seqno = 0;
 
 		trace_i915_gem_request_wait_end(dev, seqno);
 	}
diff --git a/drivers/gpu/drm/i915/i915_irq.c b/drivers/gpu/drm/i915/i915_irq.c
index 5ea0cf1..49c7944 100644
--- a/drivers/gpu/drm/i915/i915_irq.c
+++ b/drivers/gpu/drm/i915/i915_irq.c
@@ -298,7 +298,7 @@ static void notify_ring(struct drm_device *dev,
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	u32 seqno = ring->get_seqno(ring);
-	ring->irq_gem_seqno = seqno;
+	ring->irq_seqno = seqno;
 	trace_i915_gem_request_complete(dev, seqno);
 	wake_up_all(&ring->irq_queue);
 	dev_priv->hangcheck_count = 0;
@@ -1320,10 +1320,10 @@ static bool i915_hangcheck_ring_idle(struct intel_ring_buffer *ring, bool *err)
 	if (list_empty(&ring->request_list) ||
 	    i915_seqno_passed(ring->get_seqno(ring), ring_last_seqno(ring))) {
 		/* Issue a wake-up to catch stuck h/w. */
-		if (ring->waiting_gem_seqno && waitqueue_active(&ring->irq_queue)) {
+		if (ring->waiting_seqno && waitqueue_active(&ring->irq_queue)) {
 			DRM_ERROR("Hangcheck timer elapsed... %s idle [waiting on %d, at %d], missed IRQ?\n",
 				  ring->name,
-				  ring->waiting_gem_seqno,
+				  ring->waiting_seqno,
 				  ring->get_seqno(ring));
 			wake_up_all(&ring->irq_queue);
 			*err = true;
diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.h b/drivers/gpu/drm/i915/intel_ringbuffer.h
index 1bbaf88..05aa122 100644
--- a/drivers/gpu/drm/i915/intel_ringbuffer.h
+++ b/drivers/gpu/drm/i915/intel_ringbuffer.h
@@ -36,8 +36,8 @@ struct  intel_ring_buffer {
 	int		size;
 	struct intel_hw_status_page status_page;
 
-	u32		irq_gem_seqno;		/* last seq seem at irq time */
-	u32		waiting_gem_seqno;
+	u32		irq_seqno;		/* last seq seem at irq time */
+	u32		waiting_seqno;
 	int		user_irq_refcount;
 	void		(*user_irq_get)(struct intel_ring_buffer *ring);
 	void		(*user_irq_put)(struct intel_ring_buffer *ring);
-- 
1.7.6

