From 8d9fb5882a8f8be9957958a3badfefc7608bc784 Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Sun, 29 Aug 2010 17:29:50 +0200
Patch-mainline: 2.6.37
References: fate#310916
Git-commit: 73800422a30e9b8b6e0e49c27af9e9d196e52fd9
Subject: [PATCH 1356/2588] intel-gtt: consolidate i830 setup

Slighlty reordered sequence was necessary. Also don't set
agp_bridge->gatt_bus_addr anymore. Only used by generic agp helper
functions, hence unnecessary for the intel fake agp driver.

Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit 73800422a30e9b8b6e0e49c27af9e9d196e52fd9)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/char/agp/intel-gtt.c |   83 +++++++++++++++++++++++++-----------------
 1 files changed, 49 insertions(+), 34 deletions(-)

diff --git a/drivers/char/agp/intel-gtt.c b/drivers/char/agp/intel-gtt.c
index 73082ef..fd977aa 100644
--- a/drivers/char/agp/intel-gtt.c
+++ b/drivers/char/agp/intel-gtt.c
@@ -86,6 +86,8 @@ struct intel_gtt_driver {
 	unsigned int is_g33 : 1;
 	unsigned int is_pineview : 1;
 	unsigned int is_ironlake : 1;
+	/* Chipset specific GTT setup */
+	int (*setup)(void);
 };
 
 static struct _intel_private {
@@ -95,6 +97,7 @@ static struct _intel_private {
 	struct pci_dev *bridge_dev;
 	u8 __iomem *registers;
 	phys_addr_t gtt_bus_addr;
+	phys_addr_t gma_bus_addr;
 	u32 __iomem *gtt;		/* I915G */
 	int num_dcache_entries;
 	union {
@@ -893,38 +896,60 @@ static void intel_i830_chipset_flush(struct agp_bridge_data *bridge)
 		printk(KERN_ERR "Timed out waiting for cache flush.\n");
 }
 
-/* The intel i830 automatically initializes the agp aperture during POST.
- * Use the memory already set aside for in the GTT.
- */
-static int intel_i830_create_gatt_table(struct agp_bridge_data *bridge)
+static void intel_enable_gtt(void)
 {
-	int page_order, ret;
-	struct aper_size_info_fixed *size;
-	int num_entries;
-	u32 temp;
+	u32 ptetbl_addr, gma_addr;
+	u16 gmch_ctrl;
 
-	size = agp_bridge->current_size;
-	page_order = size->page_order;
-	num_entries = size->num_entries;
-	agp_bridge->gatt_table_real = NULL;
+	ptetbl_addr = readl(intel_private.registers+I810_PGETBL_CTL) & 0xfffff000;
 
-	pci_read_config_dword(intel_private.pcidev, I810_MMADDR, &temp);
-	temp &= 0xfff80000;
+	pci_read_config_dword(intel_private.pcidev, I810_GMADDR, &gma_addr);
+	intel_private.gma_bus_addr = (gma_addr & PCI_BASE_ADDRESS_MEM_MASK);
 
-	intel_private.registers = ioremap(temp, KB(64));
+	pci_read_config_word(intel_private.bridge_dev, I830_GMCH_CTRL, &gmch_ctrl);
+	gmch_ctrl |= I830_GMCH_ENABLED;
+	pci_write_config_word(intel_private.bridge_dev, I830_GMCH_CTRL, gmch_ctrl);
+
+	writel(ptetbl_addr|I810_PGETBL_ENABLED, intel_private.registers+I810_PGETBL_CTL);
+	readl(intel_private.registers+I810_PGETBL_CTL);	/* PCI Posting. */
+}
+
+static int i830_setup(void)
+{
+	u32 reg_addr;
+
+	pci_read_config_dword(intel_private.pcidev, I810_MMADDR, &reg_addr);
+	reg_addr &= 0xfff80000;
+
+	intel_private.registers = ioremap(reg_addr, KB(64));
 	if (!intel_private.registers)
 		return -ENOMEM;
 
-	intel_private.gtt_bus_addr = temp + I810_PTE_BASE;
-	temp = readl(intel_private.registers+I810_PGETBL_CTL) & 0xfffff000;
+	intel_private.gtt_bus_addr = reg_addr + I810_PTE_BASE;
+
+	intel_i830_setup_flush();
+
+	return 0;
+}
+
+/* The intel i830 automatically initializes the agp aperture during POST.
+ * Use the memory already set aside for in the GTT.
+ */
+static int intel_i830_create_gatt_table(struct agp_bridge_data *bridge)
+{
+	int ret;
+
+	ret = intel_private.driver->setup();
+	if (ret != 0)
+		return ret;
 
 	ret = intel_gtt_init();
 	if (ret != 0)
 		return ret;
 
+	agp_bridge->gatt_table_real = NULL;
 	agp_bridge->gatt_table = NULL;
-
-	agp_bridge->gatt_bus_addr = temp;
+	agp_bridge->gatt_bus_addr = 0;
 
 	return 0;
 }
@@ -939,25 +964,15 @@ static int intel_fake_agp_free_gatt_table(struct agp_bridge_data *bridge)
 
 static int intel_i830_configure(void)
 {
-	struct aper_size_info_fixed *current_size;
-	u32 temp;
-	u16 gmch_ctrl;
 	int i;
 
-	current_size = A_SIZE_FIX(agp_bridge->current_size);
-
-	pci_read_config_dword(intel_private.pcidev, I810_GMADDR, &temp);
-	agp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);
-
-	pci_read_config_word(intel_private.bridge_dev, I830_GMCH_CTRL, &gmch_ctrl);
-	gmch_ctrl |= I830_GMCH_ENABLED;
-	pci_write_config_word(intel_private.bridge_dev, I830_GMCH_CTRL, gmch_ctrl);
+	intel_enable_gtt();
 
-	writel(agp_bridge->gatt_bus_addr|I810_PGETBL_ENABLED, intel_private.registers+I810_PGETBL_CTL);
-	readl(intel_private.registers+I810_PGETBL_CTL);	/* PCI Posting. */
+	agp_bridge->gart_bus_addr = intel_private.gma_bus_addr;
 
 	if (agp_bridge->driver->needs_scratch_page) {
-		for (i = intel_private.base.gtt_stolen_entries; i < current_size->num_entries; i++) {
+		for (i = intel_private.base.gtt_stolen_entries;
+				i < intel_private.base.gtt_total_entries; i++) {
 			writel(agp_bridge->scratch_page, intel_private.gtt+i);
 		}
 		readl(intel_private.gtt+i-1);	/* PCI Posting. */
@@ -965,7 +980,6 @@ static int intel_i830_configure(void)
 
 	global_cache_flush();
 
-	intel_i830_setup_flush();
 	return 0;
 }
 
@@ -1584,6 +1598,7 @@ static const struct agp_bridge_driver intel_g33_driver = {
 
 static const struct intel_gtt_driver i8xx_gtt_driver = {
 	.gen = 2,
+	.setup = i830_setup,
 };
 static const struct intel_gtt_driver i915_gtt_driver = {
 	.gen = 3,
-- 
1.7.6

