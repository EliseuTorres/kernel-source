From 70ee6f1cd6911098ddd4c11ee21b69dbe51fb3f9 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Fri, 13 Jul 2012 16:49:49 +1000
Subject: drm/nv04-nv40/fifo: remove use of nouveau_gpuobj_new_fake()
Git-commit: 70ee6f1cd6911098ddd4c11ee21b69dbe51fb3f9
Patch-mainline: v3.7-rc3

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/nouveau/core/engine/fifo/nv04.c |   37 +++++++++-------------
 drivers/gpu/drm/nouveau/core/engine/fifo/nv10.c |   29 +++++++-----------
 drivers/gpu/drm/nouveau/core/engine/fifo/nv17.c |   26 +++++++---------
 drivers/gpu/drm/nouveau/core/engine/fifo/nv40.c |   31 ++++++++-----------
 4 files changed, 50 insertions(+), 73 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/core/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/core/engine/fifo/nv04.c
index d7857b7..ba76cf0 100644
--- a/drivers/gpu/drm/nouveau/core/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/core/engine/fifo/nv04.c
@@ -61,7 +61,7 @@ struct nv04_fifo_priv {
 
 struct nv04_fifo_chan {
 	struct nouveau_fifo_chan base;
-	struct nouveau_gpuobj *ramfc;
+	u32 ramfc;
 };
 
 bool
@@ -107,6 +107,8 @@ nv04_fifo_context_new(struct nouveau_channel *chan, int engine)
 	if (!fctx)
 		return -ENOMEM;
 
+	fctx->ramfc = chan->id * 32;
+
 	/* map channel control registers */
 	chan->user = ioremap(pci_resource_start(dev->pdev, 0) +
 			     NV03_USER(chan->id), PAGE_SIZE);
@@ -116,25 +118,16 @@ nv04_fifo_context_new(struct nouveau_channel *chan, int engine)
 	}
 
 	/* initialise default fifo context */
-	ret = nouveau_gpuobj_new_fake(dev, priv->ramfc->pinst +
-				      chan->id * 32, ~0, 32,
-				      NVOBJ_FLAG_ZERO_FREE, &fctx->ramfc);
-	if (ret)
-		goto error;
-
-	nv_wo32(fctx->ramfc, 0x00, chan->pushbuf_base);
-	nv_wo32(fctx->ramfc, 0x04, chan->pushbuf_base);
-	nv_wo32(fctx->ramfc, 0x08, chan->pushbuf->pinst >> 4);
-	nv_wo32(fctx->ramfc, 0x0c, 0x00000000);
-	nv_wo32(fctx->ramfc, 0x10, NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
-				   NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x00, chan->pushbuf_base);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x04, chan->pushbuf_base);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x08, chan->pushbuf->pinst >> 4);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x10,
+			     NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
+			     NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
 #ifdef __BIG_ENDIAN
-				   NV_PFIFO_CACHE1_BIG_ENDIAN |
+			     NV_PFIFO_CACHE1_BIG_ENDIAN |
 #endif
-				   NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
-	nv_wo32(fctx->ramfc, 0x14, 0x00000000);
-	nv_wo32(fctx->ramfc, 0x18, 0x00000000);
-	nv_wo32(fctx->ramfc, 0x1c, 0x00000000);
+			     NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
 
 	/* enable dma mode on the channel */
 	spin_lock_irqsave(&dev_priv->context_switch_lock, flags);
@@ -172,6 +165,7 @@ nv04_fifo_context_del(struct nouveau_channel *chan, int engine)
 		do {
 			u32 mask = ((1ULL << c->bits) - 1) << c->regs;
 			nv_mask(dev, c->regp, mask, 0x00000000);
+			nv_wo32(priv->ramfc, fctx->ramfc + c->ctxp, 0x00000000);
 		} while ((++c)->bits);
 
 		nv_wr32(dev, NV03_PFIFO_CACHE1_GET, 0);
@@ -187,7 +181,6 @@ nv04_fifo_context_del(struct nouveau_channel *chan, int engine)
 	spin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);
 
 	/* clean up */
-	nouveau_gpuobj_ref(NULL, &fctx->ramfc);
 	nouveau_gpuobj_ref(NULL, &chan->ramfc); /*XXX: nv40 */
 	if (chan->user) {
 		iounmap(chan->user);
@@ -250,14 +243,14 @@ nv04_fifo_fini(struct drm_device *dev, int engine, bool suspend)
 	chan = dev_priv->channels.ptr[chid];
 	if (suspend && chid != priv->base.channels && chan) {
 		struct nv04_fifo_chan *fctx = chan->engctx[engine];
-		struct nouveau_gpuobj *ctx = fctx->ramfc;
+		struct nouveau_gpuobj *ctx = priv->ramfc;
 		struct ramfc_desc *c = priv->ramfc_desc;
 		do {
 			u32 rm = ((1ULL << c->bits) - 1) << c->regs;
 			u32 cm = ((1ULL << c->bits) - 1) << c->ctxs;
 			u32 rv = (nv_rd32(dev, c->regp) &  rm) >> c->regs;
-			u32 cv = (nv_ro32(ctx, c->ctxp) & ~cm);
-			nv_wo32(ctx, c->ctxp, cv | (rv << c->ctxs));
+			u32 cv = (nv_ro32(ctx, c->ctxp + fctx->ramfc) & ~cm);
+			nv_wo32(ctx, c->ctxp + fctx->ramfc, cv | (rv << c->ctxs));
 		} while ((++c)->bits);
 	}
 
diff --git a/drivers/gpu/drm/nouveau/core/engine/fifo/nv10.c b/drivers/gpu/drm/nouveau/core/engine/fifo/nv10.c
index 9c1083a..0da287c 100644
--- a/drivers/gpu/drm/nouveau/core/engine/fifo/nv10.c
+++ b/drivers/gpu/drm/nouveau/core/engine/fifo/nv10.c
@@ -61,7 +61,7 @@ struct nv10_fifo_priv {
 
 struct nv10_fifo_chan {
 	struct nouveau_fifo_chan base;
-	struct nouveau_gpuobj *ramfc;
+	u32 ramfc;
 };
 
 static int
@@ -78,6 +78,8 @@ nv10_fifo_context_new(struct nouveau_channel *chan, int engine)
 	if (!fctx)
 		return -ENOMEM;
 
+	fctx->ramfc = chan->id * 32;
+
 	/* map channel control registers */
 	chan->user = ioremap(pci_resource_start(dev->pdev, 0) +
 			     NV03_USER(chan->id), PAGE_SIZE);
@@ -87,25 +89,16 @@ nv10_fifo_context_new(struct nouveau_channel *chan, int engine)
 	}
 
 	/* initialise default fifo context */
-	ret = nouveau_gpuobj_new_fake(dev, priv->ramfc->pinst +
-				      chan->id * 32, ~0, 32,
-				      NVOBJ_FLAG_ZERO_FREE, &fctx->ramfc);
-	if (ret)
-		goto error;
-
-	nv_wo32(fctx->ramfc, 0x00, chan->pushbuf_base);
-	nv_wo32(fctx->ramfc, 0x04, chan->pushbuf_base);
-	nv_wo32(fctx->ramfc, 0x08, 0x00000000);
-	nv_wo32(fctx->ramfc, 0x0c, chan->pushbuf->pinst >> 4);
-	nv_wo32(fctx->ramfc, 0x10, 0x00000000);
-	nv_wo32(fctx->ramfc, 0x14, NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
-				   NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x00, chan->pushbuf_base);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x04, chan->pushbuf_base);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x0c, chan->pushbuf->pinst >> 4);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x14,
+			     NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
+			     NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
 #ifdef __BIG_ENDIAN
-				   NV_PFIFO_CACHE1_BIG_ENDIAN |
+			     NV_PFIFO_CACHE1_BIG_ENDIAN |
 #endif
-				   NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
-	nv_wo32(fctx->ramfc, 0x18, 0x00000000);
-	nv_wo32(fctx->ramfc, 0x1c, 0x00000000);
+			     NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
 
 	/* enable dma mode on the channel */
 	spin_lock_irqsave(&dev_priv->context_switch_lock, flags);
diff --git a/drivers/gpu/drm/nouveau/core/engine/fifo/nv17.c b/drivers/gpu/drm/nouveau/core/engine/fifo/nv17.c
index 4bf4efa..99b88e0 100644
--- a/drivers/gpu/drm/nouveau/core/engine/fifo/nv17.c
+++ b/drivers/gpu/drm/nouveau/core/engine/fifo/nv17.c
@@ -66,7 +66,7 @@ struct nv17_fifo_priv {
 
 struct nv17_fifo_chan {
 	struct nouveau_fifo_chan base;
-	struct nouveau_gpuobj *ramfc;
+	u32 ramfc;
 };
 
 static int
@@ -83,6 +83,8 @@ nv17_fifo_context_new(struct nouveau_channel *chan, int engine)
 	if (!fctx)
 		return -ENOMEM;
 
+	fctx->ramfc = chan->id * 64;
+
 	/* map channel control registers */
 	chan->user = ioremap(pci_resource_start(dev->pdev, 0) +
 			     NV03_USER(chan->id), PAGE_SIZE);
@@ -92,22 +94,16 @@ nv17_fifo_context_new(struct nouveau_channel *chan, int engine)
 	}
 
 	/* initialise default fifo context */
-	ret = nouveau_gpuobj_new_fake(dev, priv->ramfc->pinst +
-				      chan->id * 64, ~0, 64,
-				      NVOBJ_FLAG_ZERO_ALLOC |
-				      NVOBJ_FLAG_ZERO_FREE, &fctx->ramfc);
-	if (ret)
-		goto error;
-
-	nv_wo32(fctx->ramfc, 0x00, chan->pushbuf_base);
-	nv_wo32(fctx->ramfc, 0x04, chan->pushbuf_base);
-	nv_wo32(fctx->ramfc, 0x0c, chan->pushbuf->pinst >> 4);
-	nv_wo32(fctx->ramfc, 0x14, NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
-				   NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x00, chan->pushbuf_base);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x04, chan->pushbuf_base);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x0c, chan->pushbuf->pinst >> 4);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x14,
+			     NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
+			     NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
 #ifdef __BIG_ENDIAN
-				   NV_PFIFO_CACHE1_BIG_ENDIAN |
+			     NV_PFIFO_CACHE1_BIG_ENDIAN |
 #endif
-				   NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
+			     NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
 
 	/* enable dma mode on the channel */
 	spin_lock_irqsave(&dev_priv->context_switch_lock, flags);
diff --git a/drivers/gpu/drm/nouveau/core/engine/fifo/nv40.c b/drivers/gpu/drm/nouveau/core/engine/fifo/nv40.c
index e42498f..df53b9f 100644
--- a/drivers/gpu/drm/nouveau/core/engine/fifo/nv40.c
+++ b/drivers/gpu/drm/nouveau/core/engine/fifo/nv40.c
@@ -74,7 +74,7 @@ struct nv40_fifo_priv {
 
 struct nv40_fifo_chan {
 	struct nouveau_fifo_chan base;
-	struct nouveau_gpuobj *ramfc;
+	u32 ramfc;
 };
 
 static int
@@ -91,6 +91,8 @@ nv40_fifo_context_new(struct nouveau_channel *chan, int engine)
 	if (!fctx)
 		return -ENOMEM;
 
+	fctx->ramfc = chan->id * 128;
+
 	/* map channel control registers */
 	chan->user = ioremap(pci_resource_start(dev->pdev, 0) +
 			     NV03_USER(chan->id), PAGE_SIZE);
@@ -100,24 +102,17 @@ nv40_fifo_context_new(struct nouveau_channel *chan, int engine)
 	}
 
 	/* initialise default fifo context */
-	ret = nouveau_gpuobj_new_fake(dev, priv->ramfc->pinst +
-				      chan->id * 128, ~0, 128,
-				      NVOBJ_FLAG_ZERO_ALLOC |
-				      NVOBJ_FLAG_ZERO_FREE, &fctx->ramfc);
-	if (ret)
-		goto error;
-
-	nv_wo32(fctx->ramfc, 0x00, chan->pushbuf_base);
-	nv_wo32(fctx->ramfc, 0x04, chan->pushbuf_base);
-	nv_wo32(fctx->ramfc, 0x0c, chan->pushbuf->pinst >> 4);
-	nv_wo32(fctx->ramfc, 0x18, 0x30000000 |
-				   NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
-				   NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x00, chan->pushbuf_base);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x04, chan->pushbuf_base);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x0c, chan->pushbuf->pinst >> 4);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x18, 0x30000000 |
+			     NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES |
+			     NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES |
 #ifdef __BIG_ENDIAN
-				   NV_PFIFO_CACHE1_BIG_ENDIAN |
+			     NV_PFIFO_CACHE1_BIG_ENDIAN |
 #endif
-				   NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
-	nv_wo32(fctx->ramfc, 0x3c, 0x0001ffff);
+			     NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8);
+	nv_wo32(priv->ramfc, fctx->ramfc + 0x3c, 0x0001ffff);
 
 	/* enable dma mode on the channel */
 	spin_lock_irqsave(&dev_priv->context_switch_lock, flags);
@@ -125,7 +120,7 @@ nv40_fifo_context_new(struct nouveau_channel *chan, int engine)
 	spin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);
 
 	/*XXX: remove this later, need fifo engine context commit hook */
-	nouveau_gpuobj_ref(fctx->ramfc, &chan->ramfc);
+	nouveau_gpuobj_ref(priv->ramfc, &chan->ramfc);
 
 error:
 	if (ret)

