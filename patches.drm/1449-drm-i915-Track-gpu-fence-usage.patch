From 491c8d4124ce14a9dc289e9d69ec3c6a7f221c25 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Mon, 20 Sep 2010 11:40:50 +0100
Patch-mainline: 2.6.37
References: fate#310916
Git-commit: 53640e1d07fb7dd5d14300dd94f4718eca33348e
Subject: [PATCH 1449/2588] drm/i915: Track gpu fence usage

Track if the gpu requires the fence for the execution of a batch buffer
and so only wait upon the retirement of the object's last rendering
seqno if the fence is in use by the GPU.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit 53640e1d07fb7dd5d14300dd94f4718eca33348e)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_drv.h |    1 +
 drivers/gpu/drm/i915/i915_gem.c |   11 +++++++++--
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index 790ffec..6e22be4 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -128,6 +128,7 @@ struct drm_i915_master_private {
 struct drm_i915_fence_reg {
 	struct drm_gem_object *obj;
 	struct list_head lru_list;
+	bool gpu;
 };
 
 struct sdvo_device_mapping {
diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index 9275554..4a93388 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -2462,7 +2462,9 @@ i915_gem_object_put_fence_reg(struct drm_gem_object *obj,
 			      bool interruptible)
 {
 	struct drm_device *dev = obj->dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_i915_gem_object *obj_priv = to_intel_bo(obj);
+	struct drm_i915_fence_reg *reg;
 
 	if (obj_priv->fence_reg == I915_FENCE_REG_NONE)
 		return 0;
@@ -2477,7 +2479,8 @@ i915_gem_object_put_fence_reg(struct drm_gem_object *obj,
 	 * therefore we must wait for any outstanding access to complete
 	 * before clearing the fence.
 	 */
-	if (INTEL_INFO(dev)->gen < 4) {
+	reg = &dev_priv->fence_regs[obj_priv->fence_reg];
+	if (reg->gpu) {
 		int ret;
 
 		ret = i915_gem_object_flush_gpu_write_domain(obj, true);
@@ -2487,6 +2490,8 @@ i915_gem_object_put_fence_reg(struct drm_gem_object *obj,
 		ret = i915_gem_object_wait_rendering(obj, interruptible);
 		if (ret)
 			return ret;
+
+		reg->gpu = false;
 	}
 
 	i915_gem_object_flush_gtt_write_domain(obj);
@@ -3181,11 +3186,13 @@ i915_gem_object_pin_and_relocate(struct drm_gem_object *obj,
 	 * properly handle blits to/from tiled surfaces.
 	 */
 	if (need_fence) {
-		ret = i915_gem_object_get_fence_reg(obj, false);
+		ret = i915_gem_object_get_fence_reg(obj, true);
 		if (ret != 0) {
 			i915_gem_object_unpin(obj);
 			return ret;
 		}
+
+		dev_priv->fence_regs[obj_priv->fence_reg].gpu = true;
 	}
 
 	entry->offset = obj_priv->gtt_offset;
-- 
1.7.6

