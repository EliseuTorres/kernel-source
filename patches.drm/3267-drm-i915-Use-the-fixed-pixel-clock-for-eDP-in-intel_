From: Takashi Iwai <tiwai@suse.de>
Date: Tue, 12 Mar 2013 15:47:16 +0100
Subject: [PATCH 2/2] drm/i915: Use the fixed pixel clock for eDP in intel_dp_set_m_n()
Git-commit: 9d1a455b0ca1c2c956b4d9ab212864a8695270f1
Patch-mainline: 3.9-rc4
References: bnc#807362

The eDP output on HP Z1 is still broken when X is started even after
fixing the infinite link-train loop.  The regression was introduced in
3.6 kernel for cleaning up the mode clock handling code in intel_dp.c.

In the past, the clock of the reference mode was modified in
intel_dp_mode_fixup() in the case of eDP fixed clock, and this clock was
used for calculating in intel_dp_set_m_n().  This override was removed,
thus the wrong mode clock is used for the calculation, resulting in a
psychedelic smoking output in the end.

This patch corrects the clock to be used in the place.

Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/intel_dp.c |   10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -803,6 +803,7 @@ intel_dp_set_m_n(struct drm_crtc *crtc,
 	struct intel_link_m_n m_n;
 	int pipe = intel_crtc->pipe;
 	enum transcoder cpu_transcoder = intel_crtc->cpu_transcoder;
+	int pixel_clock = mode->clock;
 
 	/*
 	 * Find the lane count in the intel_encoder private
@@ -810,6 +811,13 @@ intel_dp_set_m_n(struct drm_crtc *crtc,
 	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
 		intel_dp = enc_to_intel_dp(&intel_encoder->base);
 
+		if (intel_encoder->type == INTEL_OUTPUT_EDP) {
+			struct drm_display_mode *fixed_mode =
+				intel_dp->attached_connector->panel.fixed_mode;
+			if (fixed_mode)
+				pixel_clock = fixed_mode->clock;
+		}
+
 		if (intel_encoder->type == INTEL_OUTPUT_DISPLAYPORT ||
 		    intel_encoder->type == INTEL_OUTPUT_EDP)
 		{
@@ -824,7 +832,7 @@ intel_dp_set_m_n(struct drm_crtc *crtc,
 	 * set up for 8-bits of R/G/B, or 3 bytes total.
 	 */
 	intel_link_compute_m_n(intel_crtc->bpp, lane_count,
-			       mode->clock, adjusted_mode->clock, &m_n);
+			       pixel_clock, adjusted_mode->clock, &m_n);
 
 	if (IS_HASWELL(dev)) {
 		I915_WRITE(PIPE_DATA_M1(cpu_transcoder),
