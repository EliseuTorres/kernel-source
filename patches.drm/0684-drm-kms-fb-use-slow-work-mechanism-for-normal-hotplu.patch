From 36f5e1ad9782134563b59f8a80dee02ed3797d68 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Tue, 30 Mar 2010 05:34:18 +0000
Patch-mainline: 2.6.35
References: fate#310916
Git-commit: 4abe35204af82a018ca3ce6db4102aa09719698e
Subject: [PATCH 0684/2588] drm/kms/fb: use slow work mechanism for normal
 hotplug also.

a) slow work is always used now for any fbcon hotplug, as its not
   a fast task and is more suited to being ran under slow work.

b) attempt to not do any fbdev changes when X is running as we'll
   just mess it up. This hooks set_par to hopefully do the changes
   once X hands control to fbdev.

This also adds the nouveau/intel hotplug support.

Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 4abe35204af82a018ca3ce6db4102aa09719698e)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/drm_fb_helper.c    |  207 +++++++++++++++++++++--------------
 drivers/gpu/drm/i915/i915_irq.c    |    1 +
 drivers/gpu/drm/i915/intel_drv.h   |    2 +
 drivers/gpu/drm/i915/intel_fb.c    |   42 ++++----
 drivers/gpu/drm/radeon/radeon_fb.c |   74 ++++++-------
 include/drm/drm_fb_helper.h        |   47 +++++----
 6 files changed, 208 insertions(+), 165 deletions(-)

diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c
index 241ff96..f259e23 100644
--- a/drivers/gpu/drm/drm_fb_helper.c
+++ b/drivers/gpu/drm/drm_fb_helper.c
@@ -42,6 +42,8 @@ MODULE_LICENSE("GPL and additional rights");
 
 static LIST_HEAD(kernel_fb_helper_list);
 
+static struct slow_work_ops output_status_change_ops;
+
 /* simple single crtc case helper function */
 int drm_fb_helper_single_add_all_connectors(struct drm_fb_helper *fb_helper)
 {
@@ -421,54 +423,81 @@ static void drm_fb_helper_crtc_free(struct drm_fb_helper *helper)
 	kfree(helper->crtc_info);
 }
 
-int drm_fb_helper_init_crtc_count(struct drm_device *dev,
-				  struct drm_fb_helper *helper,
-				  int crtc_count, int max_conn_count)
+int drm_fb_helper_init(struct drm_device *dev,
+		       struct drm_fb_helper *fb_helper,
+		       int crtc_count, int max_conn_count,
+		       bool polled)
 {
 	struct drm_crtc *crtc;
 	int ret = 0;
 	int i;
 
-	INIT_LIST_HEAD(&helper->kernel_fb_list);
-	helper->dev = dev;
-	helper->crtc_info = kcalloc(crtc_count, sizeof(struct drm_fb_helper_crtc), GFP_KERNEL);
-	if (!helper->crtc_info)
+	fb_helper->dev = dev;
+	fb_helper->poll_enabled = polled;
+
+	slow_work_register_user(THIS_MODULE);
+	delayed_slow_work_init(&fb_helper->output_status_change_slow_work,
+			       &output_status_change_ops);
+
+	INIT_LIST_HEAD(&fb_helper->kernel_fb_list);
+
+	fb_helper->crtc_info = kcalloc(crtc_count, sizeof(struct drm_fb_helper_crtc), GFP_KERNEL);
+	if (!fb_helper->crtc_info)
 		return -ENOMEM;
-	helper->crtc_count = crtc_count;
 
-	helper->connector_info = kcalloc(dev->mode_config.num_connector, sizeof(struct drm_fb_helper_connector *), GFP_KERNEL);
-	if (!helper->connector_info) {
-		kfree(helper->crtc_info);
+	fb_helper->crtc_count = crtc_count;
+	fb_helper->connector_info = kcalloc(dev->mode_config.num_connector, sizeof(struct drm_fb_helper_connector *), GFP_KERNEL);
+	if (!fb_helper->connector_info) {
+		kfree(fb_helper->crtc_info);
 		return -ENOMEM;
 	}
-	helper->connector_count = 0;
+	fb_helper->connector_count = 0;
 
 	for (i = 0; i < crtc_count; i++) {
-		helper->crtc_info[i].mode_set.connectors =
+		fb_helper->crtc_info[i].mode_set.connectors =
 			kcalloc(max_conn_count,
 				sizeof(struct drm_connector *),
 				GFP_KERNEL);
 
-		if (!helper->crtc_info[i].mode_set.connectors) {
+		if (!fb_helper->crtc_info[i].mode_set.connectors) {
 			ret = -ENOMEM;
 			goto out_free;
 		}
-		helper->crtc_info[i].mode_set.num_connectors = 0;
+		fb_helper->crtc_info[i].mode_set.num_connectors = 0;
 	}
 
 	i = 0;
 	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
-		helper->crtc_info[i].crtc_id = crtc->base.id;
-		helper->crtc_info[i].mode_set.crtc = crtc;
+		fb_helper->crtc_info[i].crtc_id = crtc->base.id;
+		fb_helper->crtc_info[i].mode_set.crtc = crtc;
 		i++;
 	}
-	helper->conn_limit = max_conn_count;
+	fb_helper->conn_limit = max_conn_count;
 	return 0;
 out_free:
-	drm_fb_helper_crtc_free(helper);
+	drm_fb_helper_crtc_free(fb_helper);
 	return -ENOMEM;
 }
-EXPORT_SYMBOL(drm_fb_helper_init_crtc_count);
+EXPORT_SYMBOL(drm_fb_helper_init);
+
+void drm_fb_helper_fini(struct drm_fb_helper *fb_helper)
+{
+	if (!list_empty(&fb_helper->kernel_fb_list)) {
+		list_del(&fb_helper->kernel_fb_list);
+		if (list_empty(&kernel_fb_helper_list)) {
+			printk(KERN_INFO "unregistered panic notifier\n");
+			atomic_notifier_chain_unregister(&panic_notifier_list,
+							 &paniced);
+			unregister_sysrq_key('v', &sysrq_drm_fb_helper_restore_op);
+		}
+	}
+
+	drm_fb_helper_crtc_free(fb_helper);
+
+	delayed_slow_work_cancel(&fb_helper->output_status_change_slow_work);
+	slow_work_unregister_user(THIS_MODULE);
+}
+EXPORT_SYMBOL(drm_fb_helper_fini);
 
 static int setcolreg(struct drm_crtc *crtc, u16 red, u16 green,
 		     u16 blue, u16 regno, struct fb_info *info)
@@ -711,6 +740,11 @@ int drm_fb_helper_set_par(struct fb_info *info)
 		}
 	}
 	mutex_unlock(&dev->mode_config.mutex);
+
+	if (fb_helper->delayed_hotplug) {
+		fb_helper->delayed_hotplug = false;
+		delayed_slow_work_enqueue(&fb_helper->output_status_change_slow_work, 0);
+	}
 	return 0;
 }
 EXPORT_SYMBOL(drm_fb_helper_set_par);
@@ -752,7 +786,7 @@ int drm_fb_helper_single_fb_probe(struct drm_fb_helper *fb_helper,
 {
 	int new_fb = 0;
 	int crtc_count = 0;
-	int ret, i;
+	int i;
 	struct fb_info *info;
 	struct drm_fb_helper_surface_size sizes;
 	int gamma_size = 0;
@@ -828,7 +862,7 @@ int drm_fb_helper_single_fb_probe(struct drm_fb_helper *fb_helper,
 	}
 
 	/* push down into drivers */
-	new_fb = (*fb_helper->fb_probe)(fb_helper, &sizes);
+	new_fb = (*fb_helper->funcs->fb_probe)(fb_helper, &sizes);
 	if (new_fb < 0)
 		return new_fb;
 
@@ -841,11 +875,7 @@ int drm_fb_helper_single_fb_probe(struct drm_fb_helper *fb_helper,
 
 	if (new_fb) {
 		info->var.pixclock = 0;
-		ret = fb_alloc_cmap(&info->cmap, gamma_size, 0);
-		if (ret)
-			return ret;
 		if (register_framebuffer(info) < 0) {
-			fb_dealloc_cmap(&info->cmap);
 			return -EINVAL;
 		}
 
@@ -871,23 +901,6 @@ int drm_fb_helper_single_fb_probe(struct drm_fb_helper *fb_helper,
 }
 EXPORT_SYMBOL(drm_fb_helper_single_fb_probe);
 
-void drm_fb_helper_free(struct drm_fb_helper *helper)
-{
-	if (!list_empty(&helper->kernel_fb_list)) {
-		list_del(&helper->kernel_fb_list);
-		if (list_empty(&kernel_fb_helper_list)) {
-			printk(KERN_INFO "unregistered panic notifier\n");
-			atomic_notifier_chain_unregister(&panic_notifier_list,
-							 &paniced);
-			unregister_sysrq_key('v', &sysrq_drm_fb_helper_restore_op);
-		}
-	}
-	drm_fb_helper_crtc_free(helper);
-	if (helper->fbdev->cmap.len)
-		fb_dealloc_cmap(&helper->fbdev->cmap);
-}
-EXPORT_SYMBOL(drm_fb_helper_free);
-
 void drm_fb_helper_fill_fix(struct fb_info *info, uint32_t pitch,
 			    uint32_t depth)
 {
@@ -1292,7 +1305,7 @@ static void drm_setup_crtcs(struct drm_fb_helper *fb_helper)
  * RETURNS:
  * Zero if everything went ok, nonzero otherwise.
  */
-bool drm_fb_helper_initial_config(struct drm_fb_helper *fb_helper)
+bool drm_fb_helper_initial_config(struct drm_fb_helper *fb_helper, int bpp_sel)
 {
 	struct drm_device *dev = fb_helper->dev;
 	int count = 0;
@@ -1305,13 +1318,12 @@ bool drm_fb_helper_initial_config(struct drm_fb_helper *fb_helper)
 	count = drm_fb_helper_probe_connector_modes(fb_helper,
 						    dev->mode_config.max_width,
 						    dev->mode_config.max_height);
-
 	/*
 	 * we shouldn't end up with no modes here.
 	 */
 	if (count == 0) {
 		if (fb_helper->poll_enabled) {
-			delayed_slow_work_enqueue(&fb_helper->output_poll_slow_work,
+			delayed_slow_work_enqueue(&fb_helper->output_status_change_slow_work,
 						  5*HZ);
 			printk(KERN_INFO "No connectors reported connected with modes - started polling\n");
 		} else
@@ -1319,85 +1331,114 @@ bool drm_fb_helper_initial_config(struct drm_fb_helper *fb_helper)
 	}
 	drm_setup_crtcs(fb_helper);
 
-	return 0;
+	return drm_fb_helper_single_fb_probe(fb_helper, bpp_sel);
 }
 EXPORT_SYMBOL(drm_fb_helper_initial_config);
 
-bool drm_helper_fb_hotplug_event(struct drm_fb_helper *fb_helper,
-				 u32 max_width, u32 max_height, bool polled)
+/* we got a hotplug irq - need to update fbcon */
+void drm_helper_fb_hpd_irq_event(struct drm_fb_helper *fb_helper)
+{
+	/* if we don't have the fbdev registered yet do nothing */
+	if (!fb_helper->fbdev)
+		return;
+
+	/* schedule a slow work asap */
+	delayed_slow_work_enqueue(&fb_helper->output_status_change_slow_work, 0);
+}
+EXPORT_SYMBOL(drm_helper_fb_hpd_irq_event);
+
+bool drm_helper_fb_hotplug_event(struct drm_fb_helper *fb_helper, bool polled)
 {
 	int count = 0;
 	int ret;
+	u32 max_width, max_height, bpp_sel;
+
+	if (!fb_helper->fb)
+		return false;
 	DRM_DEBUG_KMS("\n");
 
+	max_width = fb_helper->fb->width;
+	max_height = fb_helper->fb->height;
+	bpp_sel = fb_helper->fb->bits_per_pixel;
+
 	count = drm_fb_helper_probe_connector_modes(fb_helper, max_width,
 						    max_height);
 	if (fb_helper->poll_enabled && !polled) {
 		if (count) {
-			delayed_slow_work_cancel(&fb_helper->output_poll_slow_work);
+			delayed_slow_work_cancel(&fb_helper->output_status_change_slow_work);
 		} else {
-			ret = delayed_slow_work_enqueue(&fb_helper->output_poll_slow_work, 5*HZ);
+			ret = delayed_slow_work_enqueue(&fb_helper->output_status_change_slow_work, 5*HZ);
 		}
 	}
 	drm_setup_crtcs(fb_helper);
 
-	return true;
+	return drm_fb_helper_single_fb_probe(fb_helper, bpp_sel);
 }
 EXPORT_SYMBOL(drm_helper_fb_hotplug_event);
 
-static void output_poll_execute(struct slow_work *work)
+/*
+ * delayed work queue execution function
+ * - check if fbdev is actually in use on the gpu
+ *   - if not set delayed flag and repoll if necessary
+ * - check for connector status change
+ * - repoll if 0 modes found
+ *- call driver output status changed notifier
+ */
+static void output_status_change_execute(struct slow_work *work)
 {
 	struct delayed_slow_work *delayed_work = container_of(work, struct delayed_slow_work, work);
-	struct drm_fb_helper *fb_helper = container_of(delayed_work, struct drm_fb_helper, output_poll_slow_work);
-	struct drm_device *dev = fb_helper->dev;
+	struct drm_fb_helper *fb_helper = container_of(delayed_work, struct drm_fb_helper, output_status_change_slow_work);
 	struct drm_connector *connector;
 	enum drm_connector_status old_status, status;
-	bool repoll = true, changed = false;
+	bool repoll, changed = false;
 	int ret;
+	int i;
+	bool bound = false, crtcs_bound = false;
+	struct drm_crtc *crtc;
 
-	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+	repoll = fb_helper->poll_enabled;
+
+	/* first of all check the fbcon framebuffer is actually bound to any crtc */
+	/* take into account that no crtc at all maybe bound */
+	list_for_each_entry(crtc, &fb_helper->dev->mode_config.crtc_list, head) {
+		if (crtc->fb)
+			crtcs_bound = true;
+		if (crtc->fb == fb_helper->fb)
+			bound = true;
+	}
+
+	if (bound == false && crtcs_bound) {
+		fb_helper->delayed_hotplug = true;
+		goto requeue;
+	}
+
+	for (i = 0; i < fb_helper->connector_count; i++) {
+		connector = fb_helper->connector_info[i]->connector;
 		old_status = connector->status;
 		status = connector->funcs->detect(connector);
 		if (old_status != status) {
 			changed = true;
-			/* something changed */
 		}
-		if (status == connector_status_connected) {
+		if (status == connector_status_connected && repoll) {
 			DRM_DEBUG("%s is connected - stop polling\n", drm_get_connector_name(connector));
 			repoll = false;
 		}
 	}
 
+	if (changed) {
+		if (fb_helper->funcs->fb_output_status_changed)
+			fb_helper->funcs->fb_output_status_changed(fb_helper);
+	}
+
+requeue:
 	if (repoll) {
 		ret = delayed_slow_work_enqueue(delayed_work, 5*HZ);
 		if (ret)
 			DRM_ERROR("delayed enqueue failed %d\n", ret);
 	}
-
-	if (changed) {
-		if (fb_helper->fb_poll_changed)
-			fb_helper->fb_poll_changed(fb_helper);
-	}
 }
 
-struct slow_work_ops output_poll_ops = {
-	.execute = output_poll_execute,
+static struct slow_work_ops output_status_change_ops = {
+	.execute = output_status_change_execute,
 };
 
-void drm_fb_helper_poll_init(struct drm_fb_helper *fb_helper)
-{
-	int ret;
-
-	ret = slow_work_register_user(THIS_MODULE);
-
-	delayed_slow_work_init(&fb_helper->output_poll_slow_work, &output_poll_ops);
-	fb_helper->poll_enabled = true;
-}
-EXPORT_SYMBOL(drm_fb_helper_poll_init);
-
-void drm_fb_helper_poll_fini(struct drm_fb_helper *fb_helper)
-{
-	delayed_slow_work_cancel(&fb_helper->output_poll_slow_work);
-	slow_work_unregister_user(THIS_MODULE);
-}
-EXPORT_SYMBOL(drm_fb_helper_poll_fini);
diff --git a/drivers/gpu/drm/i915/i915_irq.c b/drivers/gpu/drm/i915/i915_irq.c
index 518393f..de5ea91 100644
--- a/drivers/gpu/drm/i915/i915_irq.c
+++ b/drivers/gpu/drm/i915/i915_irq.c
@@ -271,6 +271,7 @@ static void i915_hotplug_work_func(struct work_struct *work)
 		}
 	}
 	/* Just fire off a uevent and let userspace tell us what to do */
+	intelfb_hotplug(dev, false);
 	drm_sysfs_hotplug_event(dev);
 }
 
diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h
index 6dd374f..3230e8d 100644
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -234,4 +234,6 @@ extern int intel_overlay_put_image(struct drm_device *dev, void *data,
 				   struct drm_file *file_priv);
 extern int intel_overlay_attrs(struct drm_device *dev, void *data,
 			       struct drm_file *file_priv);
+
+void intelfb_hotplug(struct drm_device *dev, bool polled);
 #endif /* __INTEL_DRV_H__ */
diff --git a/drivers/gpu/drm/i915/intel_fb.c b/drivers/gpu/drm/i915/intel_fb.c
index 931b058..1373fbf 100644
--- a/drivers/gpu/drm/i915/intel_fb.c
+++ b/drivers/gpu/drm/i915/intel_fb.c
@@ -64,12 +64,6 @@ static struct fb_ops intelfb_ops = {
 	.fb_setcmap = drm_fb_helper_setcmap,
 };
 
-static struct drm_fb_helper_funcs intel_fb_helper_funcs = {
-	.gamma_set = intel_crtc_fb_gamma_set,
-	.gamma_get = intel_crtc_fb_gamma_get,
-};
-
-
 static int intelfb_create(struct intel_fbdev *ifbdev,
 			  struct drm_fb_helper_surface_size *sizes)
 {
@@ -128,7 +122,6 @@ static int intelfb_create(struct intel_fbdev *ifbdev,
 
 	ifbdev->helper.fb = fb;
 	ifbdev->helper.fbdev = info;
-	ifbdev->helper.funcs = &intel_fb_helper_funcs;
 
 	strcpy(info->fix.id, "inteldrmfb");
 
@@ -153,6 +146,12 @@ static int intelfb_create(struct intel_fbdev *ifbdev,
 		ret = -ENOSPC;
 		goto out_unpin;
 	}
+
+	ret = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (ret) {
+		ret = -ENOMEM;
+		goto out_unpin;
+	}
 	info->screen_size = size;
 
 //	memset(info->screen_base, 0, size);
@@ -204,15 +203,18 @@ static int intel_fb_find_or_create_single(struct drm_fb_helper *helper,
 	return new_fb;
 }
 
-static int intelfb_probe(struct intel_fbdev *ifbdev)
+void intelfb_hotplug(struct drm_device *dev, bool polled)
 {
-	int ret;
-
-	DRM_DEBUG_KMS("\n");
-	ret = drm_fb_helper_single_fb_probe(&ifbdev->helper, 32);
-	return ret;
+	drm_i915_private_t *dev_priv = dev->dev_private;
+	drm_helper_fb_hpd_irq_event(&dev_priv->fbdev->helper);
 }
 
+static struct drm_fb_helper_funcs intel_fb_helper_funcs = {
+	.gamma_set = intel_crtc_fb_gamma_set,
+	.gamma_get = intel_crtc_fb_gamma_get,
+	.fb_probe = intel_fb_find_or_create_single,
+};
+
 int intel_fbdev_destroy(struct drm_device *dev,
 			struct intel_fbdev *ifbdev)
 {
@@ -223,10 +225,12 @@ int intel_fbdev_destroy(struct drm_device *dev,
 		info = ifbdev->helper.fbdev;
 		unregister_framebuffer(info);
 		iounmap(info->screen_base);
+		if (info->cmap.len)
+			fb_dealloc_cmap(&info->cmap);
 		framebuffer_release(info);
 	}
 
-	drm_fb_helper_free(&ifbdev->helper);
+	drm_fb_helper_fini(&ifbdev->helper);
 
 	drm_framebuffer_cleanup(&ifb->base);
 	if (ifb->obj)
@@ -245,13 +249,13 @@ int intel_fbdev_init(struct drm_device *dev)
 		return -ENOMEM;
 
 	dev_priv->fbdev = ifbdev;
+	ifbdev->helper.funcs = &intel_fb_helper_funcs;
+
+	drm_fb_helper_init(dev, &ifbdev->helper, 2,
+			   INTELFB_CONN_LIMIT, false);
 
-	drm_fb_helper_init_crtc_count(dev, &ifbdev->helper, 2,
-				      INTELFB_CONN_LIMIT);
 	drm_fb_helper_single_add_all_connectors(&ifbdev->helper);
-	ifbdev->helper.fb_probe = intel_fb_find_or_create_single;
-	drm_fb_helper_initial_config(&ifbdev->helper);
-	intelfb_probe(ifbdev);
+	drm_fb_helper_initial_config(&ifbdev->helper, 32);
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/radeon/radeon_fb.c b/drivers/gpu/drm/radeon/radeon_fb.c
index 6d3509f..2a6ac7d 100644
--- a/drivers/gpu/drm/radeon/radeon_fb.c
+++ b/drivers/gpu/drm/radeon/radeon_fb.c
@@ -87,11 +87,6 @@ static int radeon_align_pitch(struct radeon_device *rdev, int width, int bpp, bo
 	return aligned;
 }
 
-static struct drm_fb_helper_funcs radeon_fb_helper_funcs = {
-	.gamma_set = radeon_crtc_fb_gamma_set,
-	.gamma_get = radeon_crtc_fb_gamma_get,
-};
-
 static void radeonfb_destroy_pinned_object(struct drm_gem_object *gobj)
 {
 	struct radeon_bo *rbo = gobj->driver_private;
@@ -223,7 +218,6 @@ static int radeonfb_create(struct radeon_fbdev *rfbdev,
 	/* setup helper */
 	rfbdev->helper.fb = fb;
 	rfbdev->helper.fbdev = info;
-	rfbdev->helper.funcs = &radeon_fb_helper_funcs;
 
 	memset_io(rbo->kptr, 0x0, radeon_bo_size(rbo));
 
@@ -253,10 +247,18 @@ static int radeonfb_create(struct radeon_fbdev *rfbdev,
 	info->pixmap.access_align = 32;
 	info->pixmap.flags = FB_PIXMAP_SYSTEM;
 	info->pixmap.scan_align = 1;
+
 	if (info->screen_base == NULL) {
 		ret = -ENOSPC;
 		goto out_unref;
 	}
+
+	ret = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (ret) {
+		ret = -ENOMEM;
+		goto out_unref;
+	}
+
 	DRM_INFO("fb mappable at 0x%lX\n",  info->fix.smem_start);
 	DRM_INFO("vram apper at 0x%lX\n",  (unsigned long)rdev->mc.aper_base);
 	DRM_INFO("size %lu\n", (unsigned long)radeon_bo_size(rbo));
@@ -310,33 +312,16 @@ int radeon_parse_options(char *options)
 	return 0;
 }
 
-static int radeonfb_probe(struct radeon_fbdev *rfbdev)
-{
-	struct radeon_device *rdev = rfbdev->rdev;
-	int bpp_sel = 32;
-
-	/* select 8 bpp console on RN50 or 16MB cards */
-	if (ASIC_IS_RN50(rdev) || rdev->mc.real_vram_size <= (32*1024*1024))
-		bpp_sel = 8;
-
-	return drm_fb_helper_single_fb_probe(&rfbdev->helper, bpp_sel);
-}
-
 void radeonfb_hotplug(struct drm_device *dev, bool polled)
 {
 	struct radeon_device *rdev = dev->dev_private;
-	int max_width, max_height;
-
-	max_width = rdev->mode_info.rfbdev->rfb.base.width;
-	max_height = rdev->mode_info.rfbdev->rfb.base.height;
-	drm_helper_fb_hotplug_event(&rdev->mode_info.rfbdev->helper, max_width, max_height, polled);
 
-	radeonfb_probe(rdev->mode_info.rfbdev);
+	drm_helper_fb_hpd_irq_event(&rdev->mode_info.rfbdev->helper);
 }
 
-static void radeon_fb_poll_changed(struct drm_fb_helper *fb_helper)
+static void radeon_fb_output_status_changed(struct drm_fb_helper *fb_helper)
 {
-	radeonfb_hotplug(fb_helper->dev, true);
+	drm_helper_fb_hotplug_event(fb_helper, true);
 }
 
 static int radeon_fbdev_destroy(struct drm_device *dev, struct radeon_fbdev *rfbdev)
@@ -348,7 +333,10 @@ static int radeon_fbdev_destroy(struct drm_device *dev, struct radeon_fbdev *rfb
 
 	if (rfbdev->helper.fbdev) {
 		info = rfbdev->helper.fbdev;
+
 		unregister_framebuffer(info);
+		if (info->cmap.len)
+			fb_dealloc_cmap(&info->cmap);
 		framebuffer_release(info);
 	}
 
@@ -362,16 +350,27 @@ static int radeon_fbdev_destroy(struct drm_device *dev, struct radeon_fbdev *rfb
 		}
 		drm_gem_object_unreference_unlocked(rfb->obj);
 	}
-	drm_fb_helper_free(&rfbdev->helper);
+	drm_fb_helper_fini(&rfbdev->helper);
 	drm_framebuffer_cleanup(&rfb->base);
 
 	return 0;
 }
-MODULE_LICENSE("GPL");
+
+static struct drm_fb_helper_funcs radeon_fb_helper_funcs = {
+	.gamma_set = radeon_crtc_fb_gamma_set,
+	.gamma_get = radeon_crtc_fb_gamma_get,
+	.fb_probe = radeon_fb_find_or_create_single,
+	.fb_output_status_changed = radeon_fb_output_status_changed,
+};
 
 int radeon_fbdev_init(struct radeon_device *rdev)
 {
 	struct radeon_fbdev *rfbdev;
+	int bpp_sel = 32;
+
+	/* select 8 bpp console on RN50 or 16MB cards */
+	if (ASIC_IS_RN50(rdev) || rdev->mc.real_vram_size <= (32*1024*1024))
+		bpp_sel = 8;
 
 	rfbdev = kzalloc(sizeof(struct radeon_fbdev), GFP_KERNEL);
 	if (!rfbdev)
@@ -379,20 +378,13 @@ int radeon_fbdev_init(struct radeon_device *rdev)
 
 	rfbdev->rdev = rdev;
 	rdev->mode_info.rfbdev = rfbdev;
+	rfbdev->helper.funcs = &radeon_fb_helper_funcs;
 
-	drm_fb_helper_init_crtc_count(rdev->ddev, &rfbdev->helper,
-				      rdev->num_crtc,
-				      RADEONFB_CONN_LIMIT);
-	rfbdev->helper.fb_probe = radeon_fb_find_or_create_single;
-
+	drm_fb_helper_init(rdev->ddev, &rfbdev->helper,
+			   rdev->num_crtc,
+			   RADEONFB_CONN_LIMIT, true);
 	drm_fb_helper_single_add_all_connectors(&rfbdev->helper);
-
-	rfbdev->helper.fb_poll_changed = radeon_fb_poll_changed;
-	drm_fb_helper_poll_init(&rfbdev->helper);
-
-	drm_fb_helper_initial_config(&rfbdev->helper);
-	radeonfb_probe(rfbdev);
-
+	drm_fb_helper_initial_config(&rfbdev->helper, bpp_sel);
 	return 0;
 
 }
@@ -402,7 +394,6 @@ void radeon_fbdev_fini(struct radeon_device *rdev)
 	if (!rdev->mode_info.rfbdev)
 		return;
 
-	drm_fb_helper_poll_fini(&rdev->mode_info.rfbdev->helper);
 	radeon_fbdev_destroy(rdev->ddev, rdev->mode_info.rfbdev);
 	kfree(rdev->mode_info.rfbdev);
 	rdev->mode_info.rfbdev = NULL;
@@ -429,4 +420,3 @@ bool radeon_fbdev_robj_is_fb(struct radeon_device *rdev, struct radeon_bo *robj)
 		return true;
 	return false;
 }
-
diff --git a/include/drm/drm_fb_helper.h b/include/drm/drm_fb_helper.h
index a073d73..9b55a94 100644
--- a/include/drm/drm_fb_helper.h
+++ b/include/drm/drm_fb_helper.h
@@ -32,20 +32,14 @@
 
 #include <linux/slow-work.h>
 
+struct drm_fb_helper;
+
 struct drm_fb_helper_crtc {
 	uint32_t crtc_id;
 	struct drm_mode_set mode_set;
 	struct drm_display_mode *desired_mode;
 };
 
-
-struct drm_fb_helper_funcs {
-	void (*gamma_set)(struct drm_crtc *crtc, u16 red, u16 green,
-			  u16 blue, int regno);
-	void (*gamma_get)(struct drm_crtc *crtc, u16 *red, u16 *green,
-			  u16 *blue, int regno);
-};
-
 /* mode specified on the command line */
 struct drm_fb_helper_cmdline_mode {
 	bool specified;
@@ -69,6 +63,19 @@ struct drm_fb_helper_surface_size {
 	u32 surface_depth;
 };
 
+struct drm_fb_helper_funcs {
+	void (*gamma_set)(struct drm_crtc *crtc, u16 red, u16 green,
+			  u16 blue, int regno);
+	void (*gamma_get)(struct drm_crtc *crtc, u16 *red, u16 *green,
+			  u16 *blue, int regno);
+
+	int (*fb_probe)(struct drm_fb_helper *helper,
+			struct drm_fb_helper_surface_size *sizes);
+
+	void (*fb_output_status_changed)(struct drm_fb_helper *helper);
+
+};
+
 struct drm_fb_helper_connector {
 	struct drm_fb_helper_cmdline_mode cmdline_mode;
 	struct drm_connector *connector;
@@ -88,21 +95,20 @@ struct drm_fb_helper {
 	u32 pseudo_palette[17];
 	struct list_head kernel_fb_list;
 
-	struct delayed_slow_work output_poll_slow_work;
+	struct delayed_slow_work output_status_change_slow_work;
 	bool poll_enabled;
-	int (*fb_probe)(struct drm_fb_helper *helper,
-			struct drm_fb_helper_surface_size *sizes);
-
-	void (*fb_poll_changed)(struct drm_fb_helper *helper);
+	/* we got a hotplug but fbdev wasn't running the console
+	   delay until next set_par */
+	bool delayed_hotplug;
 };
 
 int drm_fb_helper_single_fb_probe(struct drm_fb_helper *helper,
 				  int preferred_bpp);
 
-int drm_fb_helper_init_crtc_count(struct drm_device *dev,
-				  struct drm_fb_helper *helper, int crtc_count,
-				  int max_conn);
-void drm_fb_helper_free(struct drm_fb_helper *helper);
+int drm_fb_helper_init(struct drm_device *dev,
+		       struct drm_fb_helper *helper, int crtc_count,
+		       int max_conn, bool polled);
+void drm_fb_helper_fini(struct drm_fb_helper *helper);
 int drm_fb_helper_blank(int blank, struct fb_info *info);
 int drm_fb_helper_pan_display(struct fb_var_screeninfo *var,
 			      struct fb_info *info);
@@ -125,10 +131,9 @@ void drm_fb_helper_fill_fix(struct fb_info *info, uint32_t pitch,
 int drm_fb_helper_setcmap(struct fb_cmap *cmap, struct fb_info *info);
 
 bool drm_helper_fb_hotplug_event(struct drm_fb_helper *fb_helper,
-				 u32 max_width, u32 max_height, bool polled);
-bool drm_fb_helper_initial_config(struct drm_fb_helper *fb_helper);
+				 bool polled);
+bool drm_fb_helper_initial_config(struct drm_fb_helper *fb_helper, int bpp_sel);
 int drm_fb_helper_single_add_all_connectors(struct drm_fb_helper *fb_helper);
 
-void drm_fb_helper_poll_init(struct drm_fb_helper *fb_helper);
-void drm_fb_helper_poll_fini(struct drm_fb_helper *fb_helper);
+void drm_helper_fb_hpd_irq_event(struct drm_fb_helper *fb_helper);
 #endif
-- 
1.7.6

