From 5787640db6ae722aeadb394d480c7ca21b603e34 Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Fri, 13 Jul 2012 16:42:14 +1000
Subject: drm/nv04-nv40/instmem: remove use of nouveau_gpuobj_new_fake()
Git-commit: 5787640db6ae722aeadb394d480c7ca21b603e34
Patch-mainline: v3.7-rc3

These type of fake objects will not be supported for much longer.

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/nouveau/core/engine/fifo/nv04.c    |   17 +++-
 drivers/gpu/drm/nouveau/core/engine/fifo/nv10.c    |   10 ++-
 drivers/gpu/drm/nouveau/core/engine/fifo/nv17.c    |   14 +++-
 drivers/gpu/drm/nouveau/core/engine/fifo/nv40.c    |   14 +++-
 drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c |   73 +++++++---------
 drivers/gpu/drm/nouveau/core/subdev/instmem/nv40.c |   92 ++++++++++----------
 drivers/gpu/drm/nouveau/nouveau_drv.h              |    2 -
 7 files changed, 122 insertions(+), 100 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/core/engine/fifo/nv04.c b/drivers/gpu/drm/nouveau/core/engine/fifo/nv04.c
index bc38087..d7857b7 100644
--- a/drivers/gpu/drm/nouveau/core/engine/fifo/nv04.c
+++ b/drivers/gpu/drm/nouveau/core/engine/fifo/nv04.c
@@ -32,6 +32,8 @@
 #include <core/ramht.h>
 #include "nouveau_software.h"
 
+#include <core/subdev/instmem/nv04.h>
+
 static struct ramfc_desc {
 	unsigned bits:6;
 	unsigned ctxs:5;
@@ -53,6 +55,8 @@ static struct ramfc_desc {
 struct nv04_fifo_priv {
 	struct nouveau_fifo_priv base;
 	struct ramfc_desc *ramfc_desc;
+	struct nouveau_gpuobj *ramro;
+	struct nouveau_gpuobj *ramfc;
 };
 
 struct nv04_fifo_chan {
@@ -112,7 +116,7 @@ nv04_fifo_context_new(struct nouveau_channel *chan, int engine)
 	}
 
 	/* initialise default fifo context */
-	ret = nouveau_gpuobj_new_fake(dev, dev_priv->ramfc->pinst +
+	ret = nouveau_gpuobj_new_fake(dev, priv->ramfc->pinst +
 				      chan->id * 32, ~0, 32,
 				      NVOBJ_FLAG_ZERO_FREE, &fctx->ramfc);
 	if (ret)
@@ -207,8 +211,8 @@ nv04_fifo_init(struct drm_device *dev, int engine)
 	nv_wr32(dev, NV03_PFIFO_RAMHT, (0x03 << 24) /* search 128 */ |
 				       ((dev_priv->ramht->bits - 9) << 16) |
 				       (dev_priv->ramht->gpuobj->pinst >> 8));
-	nv_wr32(dev, NV03_PFIFO_RAMRO, dev_priv->ramro->pinst >> 8);
-	nv_wr32(dev, NV03_PFIFO_RAMFC, dev_priv->ramfc->pinst >> 8);
+	nv_wr32(dev, NV03_PFIFO_RAMRO, priv->ramro->pinst >> 8);
+	nv_wr32(dev, NV03_PFIFO_RAMFC, priv->ramfc->pinst >> 8);
 
 	nv_wr32(dev, NV03_PFIFO_CACHE1_PUSH1, priv->base.channels);
 
@@ -478,6 +482,9 @@ nv04_fifo_destroy(struct drm_device *dev, int engine)
 
 	nouveau_irq_unregister(dev, 8);
 
+	nouveau_gpuobj_ref(NULL, &priv->ramfc);
+	nouveau_gpuobj_ref(NULL, &priv->ramro);
+
 	dev_priv->eng[engine] = NULL;
 	kfree(priv);
 }
@@ -486,12 +493,16 @@ int
 nv04_fifo_create(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nv04_instmem_priv *imem = dev_priv->engine.instmem.priv;
 	struct nv04_fifo_priv *priv;
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
+	nouveau_gpuobj_ref(imem->ramro, &priv->ramro);
+	nouveau_gpuobj_ref(imem->ramfc, &priv->ramfc);
+
 	priv->base.base.destroy = nv04_fifo_destroy;
 	priv->base.base.init = nv04_fifo_init;
 	priv->base.base.fini = nv04_fifo_fini;
diff --git a/drivers/gpu/drm/nouveau/core/engine/fifo/nv10.c b/drivers/gpu/drm/nouveau/core/engine/fifo/nv10.c
index 9058c31..9c1083a 100644
--- a/drivers/gpu/drm/nouveau/core/engine/fifo/nv10.c
+++ b/drivers/gpu/drm/nouveau/core/engine/fifo/nv10.c
@@ -31,6 +31,8 @@
 #include "nouveau_util.h"
 #include <core/ramht.h>
 
+#include <core/subdev/instmem/nv04.h>
+
 static struct ramfc_desc {
 	unsigned bits:6;
 	unsigned ctxs:5;
@@ -53,6 +55,8 @@ static struct ramfc_desc {
 struct nv10_fifo_priv {
 	struct nouveau_fifo_priv base;
 	struct ramfc_desc *ramfc_desc;
+	struct nouveau_gpuobj *ramro;
+	struct nouveau_gpuobj *ramfc;
 };
 
 struct nv10_fifo_chan {
@@ -83,7 +87,7 @@ nv10_fifo_context_new(struct nouveau_channel *chan, int engine)
 	}
 
 	/* initialise default fifo context */
-	ret = nouveau_gpuobj_new_fake(dev, dev_priv->ramfc->pinst +
+	ret = nouveau_gpuobj_new_fake(dev, priv->ramfc->pinst +
 				      chan->id * 32, ~0, 32,
 				      NVOBJ_FLAG_ZERO_FREE, &fctx->ramfc);
 	if (ret)
@@ -118,12 +122,16 @@ int
 nv10_fifo_create(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nv04_instmem_priv *imem = dev_priv->engine.instmem.priv;
 	struct nv10_fifo_priv *priv;
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
+	nouveau_gpuobj_ref(imem->ramro, &priv->ramro);
+	nouveau_gpuobj_ref(imem->ramfc, &priv->ramfc);
+
 	priv->base.base.destroy = nv04_fifo_destroy;
 	priv->base.base.init = nv04_fifo_init;
 	priv->base.base.fini = nv04_fifo_fini;
diff --git a/drivers/gpu/drm/nouveau/core/engine/fifo/nv17.c b/drivers/gpu/drm/nouveau/core/engine/fifo/nv17.c
index c514364..4bf4efa 100644
--- a/drivers/gpu/drm/nouveau/core/engine/fifo/nv17.c
+++ b/drivers/gpu/drm/nouveau/core/engine/fifo/nv17.c
@@ -31,6 +31,8 @@
 #include "nouveau_util.h"
 #include <core/ramht.h>
 
+#include <core/subdev/instmem/nv04.h>
+
 static struct ramfc_desc {
 	unsigned bits:6;
 	unsigned ctxs:5;
@@ -58,6 +60,8 @@ static struct ramfc_desc {
 struct nv17_fifo_priv {
 	struct nouveau_fifo_priv base;
 	struct ramfc_desc *ramfc_desc;
+	struct nouveau_gpuobj *ramro;
+	struct nouveau_gpuobj *ramfc;
 };
 
 struct nv17_fifo_chan {
@@ -88,7 +92,7 @@ nv17_fifo_context_new(struct nouveau_channel *chan, int engine)
 	}
 
 	/* initialise default fifo context */
-	ret = nouveau_gpuobj_new_fake(dev, dev_priv->ramfc->pinst +
+	ret = nouveau_gpuobj_new_fake(dev, priv->ramfc->pinst +
 				      chan->id * 64, ~0, 64,
 				      NVOBJ_FLAG_ZERO_ALLOC |
 				      NVOBJ_FLAG_ZERO_FREE, &fctx->ramfc);
@@ -132,9 +136,9 @@ nv17_fifo_init(struct drm_device *dev, int engine)
 	nv_wr32(dev, NV03_PFIFO_RAMHT, (0x03 << 24) /* search 128 */ |
 				       ((dev_priv->ramht->bits - 9) << 16) |
 				       (dev_priv->ramht->gpuobj->pinst >> 8));
-	nv_wr32(dev, NV03_PFIFO_RAMRO, dev_priv->ramro->pinst >> 8);
+	nv_wr32(dev, NV03_PFIFO_RAMRO, priv->ramro->pinst >> 8);
 	nv_wr32(dev, NV03_PFIFO_RAMFC, 0x00010000 |
-				       dev_priv->ramfc->pinst >> 8);
+				       priv->ramfc->pinst >> 8);
 
 	nv_wr32(dev, NV03_PFIFO_CACHE1_PUSH1, priv->base.channels);
 
@@ -157,12 +161,16 @@ int
 nv17_fifo_create(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nv04_instmem_priv *imem = dev_priv->engine.instmem.priv;
 	struct nv17_fifo_priv *priv;
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
+	nouveau_gpuobj_ref(imem->ramro, &priv->ramro);
+	nouveau_gpuobj_ref(imem->ramfc, &priv->ramfc);
+
 	priv->base.base.destroy = nv04_fifo_destroy;
 	priv->base.base.init = nv17_fifo_init;
 	priv->base.base.fini = nv04_fifo_fini;
diff --git a/drivers/gpu/drm/nouveau/core/engine/fifo/nv40.c b/drivers/gpu/drm/nouveau/core/engine/fifo/nv40.c
index 23ae459..e42498f 100644
--- a/drivers/gpu/drm/nouveau/core/engine/fifo/nv40.c
+++ b/drivers/gpu/drm/nouveau/core/engine/fifo/nv40.c
@@ -31,6 +31,8 @@
 #include "nouveau_util.h"
 #include <core/ramht.h>
 
+#include <core/subdev/instmem/nv04.h>
+
 static struct ramfc_desc {
 	unsigned bits:6;
 	unsigned ctxs:5;
@@ -66,6 +68,8 @@ static struct ramfc_desc {
 struct nv40_fifo_priv {
 	struct nouveau_fifo_priv base;
 	struct ramfc_desc *ramfc_desc;
+	struct nouveau_gpuobj *ramro;
+	struct nouveau_gpuobj *ramfc;
 };
 
 struct nv40_fifo_chan {
@@ -96,7 +100,7 @@ nv40_fifo_context_new(struct nouveau_channel *chan, int engine)
 	}
 
 	/* initialise default fifo context */
-	ret = nouveau_gpuobj_new_fake(dev, dev_priv->ramfc->pinst +
+	ret = nouveau_gpuobj_new_fake(dev, priv->ramfc->pinst +
 				      chan->id * 128, ~0, 128,
 				      NVOBJ_FLAG_ZERO_ALLOC |
 				      NVOBJ_FLAG_ZERO_FREE, &fctx->ramfc);
@@ -146,7 +150,7 @@ nv40_fifo_init(struct drm_device *dev, int engine)
 	nv_wr32(dev, NV03_PFIFO_RAMHT, (0x03 << 24) /* search 128 */ |
 				       ((dev_priv->ramht->bits - 9) << 16) |
 				       (dev_priv->ramht->gpuobj->pinst >> 8));
-	nv_wr32(dev, NV03_PFIFO_RAMRO, dev_priv->ramro->pinst >> 8);
+	nv_wr32(dev, NV03_PFIFO_RAMRO, priv->ramro->pinst >> 8);
 
 	switch (dev_priv->chipset) {
 	case 0x47:
@@ -164,7 +168,7 @@ nv40_fifo_init(struct drm_device *dev, int engine)
 	default:
 		nv_wr32(dev, 0x002230, 0x00000000);
 		nv_wr32(dev, 0x002220, ((nvfb_vram_size(dev) - 512 * 1024 +
-					 dev_priv->ramfc->pinst) >> 16) |
+					 priv->ramfc->pinst) >> 16) |
 				       0x00030000);
 		break;
 	}
@@ -190,12 +194,16 @@ int
 nv40_fifo_create(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nv04_instmem_priv *imem = dev_priv->engine.instmem.priv;
 	struct nv40_fifo_priv *priv;
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
+	nouveau_gpuobj_ref(imem->ramro, &priv->ramro);
+	nouveau_gpuobj_ref(imem->ramfc, &priv->ramfc);
+
 	priv->base.base.destroy = nv04_fifo_destroy;
 	priv->base.base.init = nv40_fifo_init;
 	priv->base.base.fini = nv04_fifo_fini;
diff --git a/drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c b/drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
index 8265ca8..46b6963 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/instmem/nv04.c
@@ -5,67 +5,53 @@
 #include <engine/fifo.h>
 #include <core/ramht.h>
 
-/* returns the size of fifo context */
-static int
-nouveau_fifo_ctx_size(struct drm_device *dev)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-
-	if (dev_priv->chipset >= 0x17)
-		return 64 * 32;
-	else
-	if (dev_priv->chipset >= 0x10)
-		return 32 * 32;
+#include "nv04.h"
 
-	return 32 * 16;
-}
-
-int nv04_instmem_init(struct drm_device *dev)
+int
+nv04_instmem_init(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpuobj *ramht = NULL;
-	u32 offset, length;
+	struct nv04_instmem_priv *priv;
 	int ret;
 
-	/* RAMIN always available */
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	dev_priv->engine.instmem.priv = priv;
+
+	/* PRAMIN aperture maps over the end of vram, reserve the space */
 	dev_priv->ramin_available = true;
 	dev_priv->ramin_rsvd_vram = 512 * 1024;
 
-	/* Setup shared RAMHT */
-	ret = nouveau_gpuobj_new_fake(dev, 0x10000, ~0, 4096,
-				      NVOBJ_FLAG_ZERO_ALLOC, &ramht);
+	ret = drm_mm_init(&dev_priv->ramin_heap, 0, dev_priv->ramin_rsvd_vram);
 	if (ret)
 		return ret;
 
-	ret = nouveau_ramht_new(dev, ramht, &dev_priv->ramht);
-	nouveau_gpuobj_ref(NULL, &ramht);
+	/* 0x00000-0x10000: reserve for probable vbios image */
+	ret = nouveau_gpuobj_new(dev, NULL, 0x10000, 0, 0, &priv->vbios);
 	if (ret)
 		return ret;
 
-	/* And RAMRO */
-	ret = nouveau_gpuobj_new_fake(dev, 0x11200, ~0, 512,
-				      NVOBJ_FLAG_ZERO_ALLOC, &dev_priv->ramro);
+	/* 0x10000-0x18000: reserve for RAMHT */
+	ret = nouveau_gpuobj_new(dev, NULL, 0x08000, 0, NVOBJ_FLAG_ZERO_ALLOC,
+				&priv->ramht);
 	if (ret)
 		return ret;
 
-	/* And RAMFC */
-	length = nouveau_fifo_ctx_size(dev);
-	offset = 0x11400;
-
-	ret = nouveau_gpuobj_new_fake(dev, offset, ~0, length,
-				      NVOBJ_FLAG_ZERO_ALLOC, &dev_priv->ramfc);
+	/* 0x18000-0x18200: reserve for RAMRO */
+	ret = nouveau_gpuobj_new(dev, NULL, 0x00200, 0, 0, &priv->ramro);
 	if (ret)
 		return ret;
 
-	/* Only allow space after RAMFC to be used for object allocation */
-	offset += length;
+	/* 0x18200-0x18a00: reserve for RAMFC (enough for 32 nv30 channels) */
+	ret = nouveau_gpuobj_new(dev, NULL, 0x00800, 0, NVOBJ_FLAG_ZERO_ALLOC,
+				&priv->ramfc);
+	if (ret)
+		return ret;
 
-	ret = drm_mm_init(&dev_priv->ramin_heap, offset,
-			  dev_priv->ramin_rsvd_vram - offset);
-	if (ret) {
-		NV_ERROR(dev, "Failed to init RAMIN heap: %d\n", ret);
+	ret = nouveau_ramht_new(dev, priv->ramht, &dev_priv->ramht);
+	if (ret)
 		return ret;
-	}
 
 	return 0;
 }
@@ -74,13 +60,18 @@ void
 nv04_instmem_takedown(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nv04_instmem_priv *priv = dev_priv->engine.instmem.priv;
 
 	nouveau_ramht_ref(NULL, &dev_priv->ramht, NULL);
-	nouveau_gpuobj_ref(NULL, &dev_priv->ramro);
-	nouveau_gpuobj_ref(NULL, &dev_priv->ramfc);
+	nouveau_gpuobj_ref(NULL, &priv->ramfc);
+	nouveau_gpuobj_ref(NULL, &priv->ramro);
+	nouveau_gpuobj_ref(NULL, &priv->ramht);
 
 	if (drm_mm_initialized(&dev_priv->ramin_heap))
 		drm_mm_takedown(&dev_priv->ramin_heap);
+
+	kfree(priv);
+	dev_priv->engine.instmem.priv = NULL;
 }
 
 int
diff --git a/drivers/gpu/drm/nouveau/core/subdev/instmem/nv40.c b/drivers/gpu/drm/nouveau/core/subdev/instmem/nv40.c
index 91abf0b..7c938ae 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/instmem/nv40.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/instmem/nv40.c
@@ -5,84 +5,77 @@
 #include <engine/fifo.h>
 #include <core/ramht.h>
 
-/* returns the size of fifo context */
-static int
-nouveau_fifo_ctx_size(struct drm_device *dev)
-{
-	return 128 * 32;
-}
+#include "nv04.h"
 
 int nv40_instmem_init(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpuobj *ramht = NULL;
-	u32 offset, length, vs, rsvd;
+	struct nv04_instmem_priv *priv;
+	u32 vs, rsvd;
 	int ret;
 
-	/* RAMIN always available */
-	dev_priv->ramin_available = true;
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	dev_priv->engine.instmem.priv = priv;
 
-	/* Reserve space at end of VRAM for PRAMIN */
-	/* estimate grctx size, the magics come from nv40_grctx.c */
+	/* PRAMIN aperture maps over the end of vram, reserve enough space
+	 * to fit graphics contexts for every channel, the magics come
+	 * from engine/graph/nv40.c
+	 */
 	vs = hweight8((nv_rd32(dev, 0x001540) & 0x0000ff00) >> 8);
 	if      (dev_priv->chipset == 0x40) rsvd = 0x6aa0 * vs;
 	else if (dev_priv->chipset  < 0x43) rsvd = 0x4f00 * vs;
 	else if (nv44_graph_class(dev))	    rsvd = 0x4980 * vs;
 	else				    rsvd = 0x4a40 * vs;
 	rsvd += 16 * 1024;
-	rsvd *= 32; /* per-channel */
-
-	rsvd += 512 * 1024; /* pci(e)gart table */
-	rsvd += 512 * 1024; /* object storage */
-
+	rsvd *= 32;		/* per-channel */
+	rsvd += 512 * 1024;	/* pci(e)gart table */
+	rsvd += 512 * 1024;	/* object storage */
 	dev_priv->ramin_rsvd_vram = round_up(rsvd, 4096);
+	dev_priv->ramin_available = true;
 
-	/* Setup shared RAMHT */
-	ret = nouveau_gpuobj_new_fake(dev, 0x10000, ~0, 4096,
-				      NVOBJ_FLAG_ZERO_ALLOC, &ramht);
+	ret = drm_mm_init(&dev_priv->ramin_heap, 0, dev_priv->ramin_rsvd_vram);
 	if (ret)
 		return ret;
 
-	ret = nouveau_ramht_new(dev, ramht, &dev_priv->ramht);
-	nouveau_gpuobj_ref(NULL, &ramht);
+	/* 0x00000-0x10000: reserve for probable vbios image */
+	ret = nouveau_gpuobj_new(dev, NULL, 0x10000, 0, 0, &priv->vbios);
 	if (ret)
 		return ret;
 
-	/* And RAMRO */
-	ret = nouveau_gpuobj_new_fake(dev, 0x11200, ~0, 512,
-				      NVOBJ_FLAG_ZERO_ALLOC, &dev_priv->ramro);
+	/* 0x10000-0x18000: reserve for RAMHT */
+	ret = nouveau_gpuobj_new(dev, NULL, 0x08000, 0, NVOBJ_FLAG_ZERO_ALLOC,
+				&priv->ramht);
 	if (ret)
 		return ret;
 
-	/* And RAMFC */
-	length = nouveau_fifo_ctx_size(dev);
-	offset = 0x20000;
-
-	ret = nouveau_gpuobj_new_fake(dev, offset, ~0, length,
-				      NVOBJ_FLAG_ZERO_ALLOC, &dev_priv->ramfc);
+	/* 0x18000-0x18200: reserve for RAMRO
+	 * 0x18200-0x20000: padding
+	 */
+	ret = nouveau_gpuobj_new(dev, NULL, 0x08000, 0, 0, &priv->ramro);
 	if (ret)
 		return ret;
 
-	/* Only allow space after RAMFC to be used for object allocation */
-	offset += length;
-
-	/* It appears RAMRO (or something?) is controlled by 0x2220/0x2230
-	 * on certain NV4x chipsets as well as RAMFC.  When 0x2230 == 0
-	 * ("new style" control) the upper 16-bits of 0x2220 points at this
-	 * other mysterious table that's clobbering important things.
+	/* 0x20000-0x21000: reserve for RAMFC
+	 * 0x21000-0x40000: padding + some unknown stuff (see below)
+	 *
+	 * It appears something is controlled by 0x2220/0x2230 on certain
+	 * NV4x chipsets as well as RAMFC.  When 0x2230 == 0 ("new style"
+	 * control) the upper 16-bits of 0x2220 points at this other
+	 * mysterious table that's clobbering important things.
 	 *
 	 * We're now pointing this at RAMIN+0x30000 to avoid RAMFC getting
 	 * smashed to pieces on us, so reserve 0x30000-0x40000 too..
 	 */
-	if (offset < 0x40000)
-		offset = 0x40000;
+	ret = nouveau_gpuobj_new(dev, NULL, 0x20000, 0, NVOBJ_FLAG_ZERO_ALLOC,
+				&priv->ramfc);
+	if (ret)
+		return ret;
 
-	ret = drm_mm_init(&dev_priv->ramin_heap, offset,
-			  dev_priv->ramin_rsvd_vram - offset);
-	if (ret) {
-		NV_ERROR(dev, "Failed to init RAMIN heap: %d\n", ret);
+	ret = nouveau_ramht_new(dev, priv->ramht, &dev_priv->ramht);
+	if (ret)
 		return ret;
-	}
 
 	return 0;
 }
@@ -91,13 +84,18 @@ void
 nv40_instmem_takedown(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nv04_instmem_priv *priv = dev_priv->engine.instmem.priv;
 
 	nouveau_ramht_ref(NULL, &dev_priv->ramht, NULL);
-	nouveau_gpuobj_ref(NULL, &dev_priv->ramro);
-	nouveau_gpuobj_ref(NULL, &dev_priv->ramfc);
+	nouveau_gpuobj_ref(NULL, &priv->ramfc);
+	nouveau_gpuobj_ref(NULL, &priv->ramro);
+	nouveau_gpuobj_ref(NULL, &priv->ramht);
 
 	if (drm_mm_initialized(&dev_priv->ramin_heap))
 		drm_mm_takedown(&dev_priv->ramin_heap);
+
+	kfree(priv);
+	dev_priv->engine.instmem.priv = NULL;
 }
 
 int
diff --git a/drivers/gpu/drm/nouveau/nouveau_drv.h b/drivers/gpu/drm/nouveau/nouveau_drv.h
index ca88403..bfca468 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ b/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -649,8 +649,6 @@ struct drm_nouveau_private {
 
 	/* RAMIN configuration, RAMFC, RAMHT and RAMRO offsets */
 	struct nouveau_ramht  *ramht;
-	struct nouveau_gpuobj *ramfc;
-	struct nouveau_gpuobj *ramro;
 
 	uint32_t ramin_rsvd_vram;
 

