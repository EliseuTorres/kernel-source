From 6c4c86f51c985a146ff7185abff102fc535f6fa8 Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Mon, 10 Sep 2012 21:58:30 +0200
Subject: drm/i915: correctly update crtc->x/y in set_base
Git-commit: 6c4c86f51c985a146ff7185abff102fc535f6fa8
Patch-mainline: v3.7-rc1

While reworking the modeset sequence, this got lost in

commit 25c5b2665fe4cc5a93edd29b62e7c05c15dddd26
Author: Daniel Vetter <daniel.vetter@ffwll.ch>
Date:   Sun Jul 8 22:08:04 2012 +0200

    drm/i915: implement new set_mode code flow

I've noticed this because some Xorg versions seem to set up a new mode
with every crtc at (0,0) and then pan to the right multi-monitor
setup. And since some hacks of mine added more calls to mode_set using
the stored crtc->x/y my multi-screen setup blew up.

Reviewed-by: Jesse Barnes <jbarnes@virtuousgeek.org>
Signed-Off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/i915/intel_display.c |   10 ++++++----
 1 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index e061acd..5576b7c 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -2246,6 +2246,8 @@ intel_pipe_set_base(struct drm_crtc *crtc, int x, int y,
 
 	old_fb = crtc->fb;
 	crtc->fb = fb;
+	crtc->x = x;
+	crtc->y = y;
 
 	if (old_fb) {
 		intel_wait_for_vblank(dev, intel_crtc->pipe);
@@ -7020,11 +7022,11 @@ bool intel_set_mode(struct drm_crtc *crtc,
 			dev_priv->display.crtc_disable(&intel_crtc->base);
 	}
 
-	if (modeset_pipes) {
+	/* crtc->mode is already used by the ->mode_set callbacks, hence we need
+	 * to set it here already despite that we pass it down the callchain.
+	 */
+	if (modeset_pipes)
 		crtc->mode = *mode;
-		crtc->x = x;
-		crtc->y = y;
-	}
 
 	/* Only after disabling all output pipelines that will be changed can we
 	 * update the the output configuration. */

