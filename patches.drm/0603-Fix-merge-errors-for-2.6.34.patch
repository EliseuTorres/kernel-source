From e1b3d46715b3add40485747d7569261ab824cb2d Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Wed, 3 Aug 2011 15:52:21 +0200
Patch-mainline: Never
References: fate#310916
Subject: [PATCH 0603/2588] Fix merge errors for 2.6.34

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_dma.c            |    2 +
 drivers/gpu/drm/i915/i915_suspend.c        |    6 ++--
 drivers/gpu/drm/i915/intel_dp.c            |    6 ++--
 drivers/gpu/drm/i915/intel_lvds.c          |   40 --------------------
 drivers/gpu/drm/radeon/atombios.h          |   12 ++++---
 drivers/gpu/drm/radeon/atombios_dp.c       |    8 +++--
 drivers/gpu/drm/radeon/radeon.h            |    6 ++--
 drivers/gpu/drm/radeon/radeon_connectors.c |    6 ++-
 drivers/gpu/drm/radeon/radeon_device.c     |    1 +
 drivers/gpu/drm/radeon/radeon_pm.c         |   55 +++++-----------------------
 drivers/gpu/drm/radeon/radeon_ring.c       |    2 +-
 include/drm/drmP.h                         |    1 +
 12 files changed, 40 insertions(+), 105 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_dma.c b/drivers/gpu/drm/i915/i915_dma.c
index dff2204..6e78554 100644
--- a/drivers/gpu/drm/i915/i915_dma.c
+++ b/drivers/gpu/drm/i915/i915_dma.c
@@ -35,6 +35,8 @@
 #include "i915_drv.h"
 #include "i915_trace.h"
 #include <linux/vgaarb.h>
+#include <linux/acpi.h>
+#include <linux/pnp.h>
 #include <linux/vga_switcheroo.h>
 #include <linux/slab.h>
 
diff --git a/drivers/gpu/drm/i915/i915_suspend.c b/drivers/gpu/drm/i915/i915_suspend.c
index c761c96..ac0d1a7 100644
--- a/drivers/gpu/drm/i915/i915_suspend.c
+++ b/drivers/gpu/drm/i915/i915_suspend.c
@@ -239,7 +239,7 @@ static void i915_save_modeset_reg(struct drm_device *dev)
 	if (drm_core_check_feature(dev, DRIVER_MODESET))
 		return;
 
-	if (IS_IGDNG(dev)) {
+	if (IS_IRONLAKE(dev)) {
 		dev_priv->savePCH_DREF_CONTROL = I915_READ(PCH_DREF_CONTROL);
 		dev_priv->saveDISP_ARB_CTL = I915_READ(DISP_ARB_CTL);
 	}
@@ -385,7 +385,7 @@ static void i915_restore_modeset_reg(struct drm_device *dev)
 		fpb1_reg = FPB1;
 	}
 
-	if (IS_IGDNG(dev)) {
+	if (IS_IRONLAKE(dev)) {
 		I915_WRITE(PCH_DREF_CONTROL, dev_priv->savePCH_DREF_CONTROL);
 		I915_WRITE(DISP_ARB_CTL, dev_priv->saveDISP_ARB_CTL);
 	}
@@ -467,7 +467,7 @@ static void i915_restore_modeset_reg(struct drm_device *dev)
 	/* Actually enable it */
 	I915_WRITE(dpll_b_reg, dev_priv->saveDPLL_B);
 	DRM_UDELAY(150);
-	if (IS_I965G(dev) && !IS_IGDNG(dev))
+	if (IS_I965G(dev) && !IS_IRONLAKE(dev))
 		I915_WRITE(DPLL_B_MD, dev_priv->saveDPLL_B_MD);
 	DRM_UDELAY(150);
 
diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
index 986e9f3..77e40cf 100644
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -441,7 +441,7 @@ intel_dp_i2c_aux_ch(struct i2c_adapter *adapter, int mode,
 				msg, msg_bytes,
 				reply, reply_bytes);
 		if (ret < 0) {
-			DRM_DEBUG("aux_ch failed %d\n", ret);
+			DRM_DEBUG_KMS("aux_ch failed %d\n", ret);
 			return ret;
 		}
 		switch (reply[0] & AUX_I2C_REPLY_MASK) {
@@ -451,10 +451,10 @@ intel_dp_i2c_aux_ch(struct i2c_adapter *adapter, int mode,
 			}
 			return reply_bytes - 1;
 		case AUX_I2C_REPLY_NACK:
-			DRM_DEBUG("aux_ch nack\n");
+			DRM_DEBUG_KMS("aux_ch nack\n");
 			return -EREMOTEIO;
 		case AUX_I2C_REPLY_DEFER:
-			DRM_DEBUG("aux_ch defer\n");
+			DRM_DEBUG_KMS("aux_ch defer\n");
 			udelay(100);
 			break;
 		default:
diff --git a/drivers/gpu/drm/i915/intel_lvds.c b/drivers/gpu/drm/i915/intel_lvds.c
index ba7746a..1183b42 100644
--- a/drivers/gpu/drm/i915/intel_lvds.c
+++ b/drivers/gpu/drm/i915/intel_lvds.c
@@ -888,46 +888,6 @@ static const struct dmi_system_id intel_no_lvds[] = {
 	{ }	/* terminating entry */
 };
 
-/*
- * Enumerate the child dev array parsed from VBT to check whether
- * the LVDS is present.
- * If it is present, return 1.
- * If it is not present, return false.
- * If no child dev is parsed from VBT, it assumes that the LVDS is present.
- * Note: The addin_offset should also be checked for LVDS panel.
- * Only when it is non-zero, it is assumed that it is present.
- */
-static int lvds_is_present_in_vbt(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	struct child_device_config *p_child;
-	int i, ret;
-
-	if (!dev_priv->child_dev_num)
-		return 1;
-
-	ret = 0;
-	for (i = 0; i < dev_priv->child_dev_num; i++) {
-		p_child = dev_priv->child_dev + i;
-		/*
-		 * If the device type is not LFP, continue.
-		 * If the device type is 0x22, it is also regarded as LFP.
-		 */
-		if (p_child->device_type != DEVICE_TYPE_INT_LFP &&
-			p_child->device_type != DEVICE_TYPE_LFP)
-			continue;
-
-		/* The addin_offset should be checked. Only when it is
-		 * non-zero, it is regarded as present.
-		 */
-		if (p_child->addin_offset) {
-			ret = 1;
-			break;
-		}
-	}
-	return ret;
-}
-
 /**
  * intel_find_lvds_downclock - find the reduced downclock for LVDS in EDID
  * @dev: drm device
diff --git a/drivers/gpu/drm/radeon/atombios.h b/drivers/gpu/drm/radeon/atombios.h
index e3869b6..27e2c71 100644
--- a/drivers/gpu/drm/radeon/atombios.h
+++ b/drivers/gpu/drm/radeon/atombios.h
@@ -2794,11 +2794,13 @@ typedef struct  _ATOM_LCD_RTS_RECORD
   UCHAR     ucRTSValue;
 }ATOM_LCD_RTS_RECORD;
 
-/* !! If the record below exits, it shoud always be the first record for easy use in command table!!! */
-typedef struct _ATOM_LCD_MODE_CONTROL_CAP {
-	UCHAR ucRecordType;
-	USHORT usLCDCap;
-} ATOM_LCD_MODE_CONTROL_CAP;
+//!! If the record below exits, it shoud always be the first record for easy use in command table!!! 
+// The record below is only used when LVDS_Info is present. From ATOM_LVDS_INFO_V12, use ucLCDPanel_SpecialHandlingCap instead.
+typedef struct  _ATOM_LCD_MODE_CONTROL_CAP
+{
+  UCHAR     ucRecordType;
+  USHORT    usLCDCap;
+}ATOM_LCD_MODE_CONTROL_CAP;
 
 #define LCD_MODE_CAP_BL_OFF                   1
 #define LCD_MODE_CAP_CRTC_OFF                 2
diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c
index f53294e..28b31c6 100644
--- a/drivers/gpu/drm/radeon/atombios_dp.c
+++ b/drivers/gpu/drm/radeon/atombios_dp.c
@@ -355,10 +355,12 @@ retry:
 
 	atom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);
 
-	if (args.v1.ucReplyStatus) {
-		DRM_DEBUG("failed to get auxch %02x%02x %02x %02x 0x%02x %02x\n",
+	if (args.v1.ucReplyStatus && !args.v1.ucDataOutLen) {
+		if (args.v1.ucReplyStatus == 0x20 && retry_count++ < 10)
+			goto retry;
+		DRM_DEBUG("failed to get auxch %02x%02x %02x %02x 0x%02x %02x after %d retries\n",
 			  req_bytes[1], req_bytes[0], req_bytes[2], req_bytes[3],
-			  chan->rec.i2c_id, args.v1.ucReplyStatus);
+			  chan->rec.i2c_id, args.v1.ucReplyStatus, retry_count);
 		return false;
 	}
 
diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h
index 9470647..034218c 100644
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
@@ -372,6 +372,7 @@ struct radeon_irq {
 	bool		sw_int;
 	/* FIXME: use a define max crtc rather than hardcode it */
 	bool		crtc_vblank_int[2];
+	wait_queue_head_t	vblank_queue;
 	/* FIXME: use defines for max hpd/dacs */
 	bool            hpd[6];
 	spinlock_t sw_lock;
@@ -403,7 +404,6 @@ struct radeon_ib {
 struct radeon_ib_pool {
 	struct mutex		mutex;
 	struct radeon_bo	*robj;
-	struct list_head	scheduled_ibs;
 	struct list_head	bogus_ib;
 	struct radeon_ib	ibs[RADEON_IB_POOL_SIZE];
 	bool			ready;
@@ -683,13 +683,11 @@ struct radeon_power_state {
 
 struct radeon_pm {
 	struct mutex		mutex;
-	struct work_struct	reclock_work;
 	struct delayed_work	idle_work;
 	enum radeon_pm_state	state;
 	enum radeon_pm_action	planned_action;
 	unsigned long		action_timeout;
 	bool 			downclocked;
-	bool			vblank_callback;
 	int			active_crtcs;
 	int			req_vblank;
 	bool			vblank_sync;
@@ -1196,6 +1194,8 @@ extern void radeon_legacy_set_clock_gating(struct radeon_device *rdev, int enabl
 extern void radeon_atom_set_clock_gating(struct radeon_device *rdev, int enable);
 extern void radeon_ttm_placement_from_domain(struct radeon_bo *rbo, u32 domain);
 extern bool radeon_ttm_bo_is_radeon_bo(struct ttm_buffer_object *bo);
+extern void radeon_vram_location(struct radeon_device *rdev, struct radeon_mc *mc, u64 base);
+extern void radeon_gtt_location(struct radeon_device *rdev, struct radeon_mc *mc);
 extern int radeon_resume_kms(struct drm_device *dev);
 extern int radeon_suspend_kms(struct drm_device *dev, pm_message_t state);
 
diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c
index e487131..4559a53 100644
--- a/drivers/gpu/drm/radeon/radeon_connectors.c
+++ b/drivers/gpu/drm/radeon/radeon_connectors.c
@@ -594,7 +594,8 @@ static enum drm_connector_status radeon_vga_detect(struct drm_connector *connect
 	if (!encoder)
 		ret = connector_status_disconnected;
 
-	dret = radeon_ddc_probe(radeon_connector);
+	if (radeon_connector->ddc_bus)
+		dret = radeon_ddc_probe(radeon_connector);
 	if (dret) {
 		if (radeon_connector->edid) {
 			kfree(radeon_connector->edid);
@@ -745,7 +746,8 @@ static enum drm_connector_status radeon_dvi_detect(struct drm_connector *connect
 	enum drm_connector_status ret = connector_status_disconnected;
 	bool dret = false;
 
-	dret = radeon_ddc_probe(radeon_connector);
+	if (radeon_connector->ddc_bus)
+		dret = radeon_ddc_probe(radeon_connector);
 	if (dret) {
 		if (radeon_connector->edid) {
 			kfree(radeon_connector->edid);
diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c
index 689cf4d..2c73d7f 100644
--- a/drivers/gpu/drm/radeon/radeon_device.c
+++ b/drivers/gpu/drm/radeon/radeon_device.c
@@ -601,6 +601,7 @@ int radeon_device_init(struct radeon_device *rdev,
 	mutex_init(&rdev->pm.mutex);
 	rwlock_init(&rdev->fence_drv.lock);
 	INIT_LIST_HEAD(&rdev->gem.objects);
+	init_waitqueue_head(&rdev->irq.vblank_queue);
 
 	/* setup workqueue */
 	rdev->wq = create_workqueue("radeon");
diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index d589370..a4b5749 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
@@ -26,11 +26,11 @@
 
 #define RADEON_IDLE_LOOP_MS 100
 #define RADEON_RECLOCK_DELAY_MS 200
+#define RADEON_WAIT_VBLANK_TIMEOUT 200
 
 static bool radeon_pm_debug_check_in_vbl(struct radeon_device *rdev, bool finish);
 static void radeon_pm_set_clocks_locked(struct radeon_device *rdev);
 static void radeon_pm_set_clocks(struct radeon_device *rdev);
-static void radeon_pm_reclock_work_handler(struct work_struct *work);
 static void radeon_pm_idle_work_handler(struct work_struct *work);
 static int radeon_debugfs_pm_init(struct radeon_device *rdev);
 
@@ -232,7 +232,6 @@ int radeon_pm_init(struct radeon_device *rdev)
 	rdev->pm.state = PM_STATE_DISABLED;
 	rdev->pm.planned_action = PM_ACTION_NONE;
 	rdev->pm.downclocked = false;
-	rdev->pm.vblank_callback = false;
 
 	if (rdev->bios) {
 		if (rdev->is_atom_bios)
@@ -246,7 +245,6 @@ int radeon_pm_init(struct radeon_device *rdev)
 		DRM_ERROR("Failed to register debugfs file for PM!\n");
 	}
 
-	INIT_WORK(&rdev->pm.reclock_work, radeon_pm_reclock_work_handler);
 	INIT_DELAYED_WORK(&rdev->pm.idle_work, radeon_pm_idle_work_handler);
 
 	if (radeon_dynpm != -1 && radeon_dynpm) {
@@ -291,26 +289,14 @@ void radeon_pm_compute_clocks(struct radeon_device *rdev)
 
 	if (count > 1) {
 		if (rdev->pm.state == PM_STATE_ACTIVE) {
-			wait_queue_head_t wait;
-			init_waitqueue_head(&wait);
-
 			cancel_delayed_work(&rdev->pm.idle_work);
 
 			rdev->pm.state = PM_STATE_PAUSED;
 			rdev->pm.planned_action = PM_ACTION_UPCLOCK;
-			radeon_get_power_state(rdev, rdev->pm.planned_action);
-			rdev->pm.vblank_callback = true;
-
-			mutex_unlock(&rdev->pm.mutex);
-
-			wait_event_timeout(wait, !rdev->pm.downclocked,
-				msecs_to_jiffies(300));
-			if (!rdev->pm.downclocked)
+			if (rdev->pm.downclocked)
 				radeon_pm_set_clocks(rdev);
 
 			DRM_DEBUG("radeon: dynamic power management deactivated\n");
-		} else {
-			mutex_unlock(&rdev->pm.mutex);
 		}
 	} else if (count == 1) {
 		/* TODO: Increase clocks if needed for current mode */
@@ -318,8 +304,7 @@ void radeon_pm_compute_clocks(struct radeon_device *rdev)
 		if (rdev->pm.state == PM_STATE_MINIMUM) {
 			rdev->pm.state = PM_STATE_ACTIVE;
 			rdev->pm.planned_action = PM_ACTION_UPCLOCK;
-			radeon_get_power_state(rdev, rdev->pm.planned_action);
-			radeon_pm_set_clocks_locked(rdev);
+			radeon_pm_set_clocks(rdev);
 
 			queue_delayed_work(rdev->wq, &rdev->pm.idle_work,
 				msecs_to_jiffies(RADEON_IDLE_LOOP_MS));
@@ -330,8 +315,6 @@ void radeon_pm_compute_clocks(struct radeon_device *rdev)
 				msecs_to_jiffies(RADEON_IDLE_LOOP_MS));
 			DRM_DEBUG("radeon: dynamic power management activated\n");
 		}
-
-		mutex_unlock(&rdev->pm.mutex);
 	}
 	else { /* count == 0 */
 		if (rdev->pm.state != PM_STATE_MINIMUM) {
@@ -339,12 +322,11 @@ void radeon_pm_compute_clocks(struct radeon_device *rdev)
 
 			rdev->pm.state = PM_STATE_MINIMUM;
 			rdev->pm.planned_action = PM_ACTION_MINIMUM;
-			radeon_get_power_state(rdev, rdev->pm.planned_action);
-			radeon_pm_set_clocks_locked(rdev);
+			radeon_pm_set_clocks(rdev);
 		}
-
-		mutex_unlock(&rdev->pm.mutex);
 	}
+
+	mutex_unlock(&rdev->pm.mutex);
 }
 
 static bool radeon_pm_debug_check_in_vbl(struct radeon_device *rdev, bool finish)
@@ -412,15 +394,8 @@ static void radeon_pm_set_clocks(struct radeon_device *rdev)
 		rdev->pm.req_vblank &= ~(1 << 1);
 		drm_vblank_put(rdev->ddev, 1);
 	}
-	mutex_unlock(&rdev->pm.mutex);
-}
 
-static void radeon_pm_reclock_work_handler(struct work_struct *work)
-{
-	struct radeon_device *rdev;
-	rdev = container_of(work, struct radeon_device,
-				pm.reclock_work);
-	radeon_pm_set_clocks(rdev);
+	mutex_unlock(&rdev->cp.mutex);
 }
 
 static void radeon_pm_idle_work_handler(struct work_struct *work)
@@ -430,8 +405,7 @@ static void radeon_pm_idle_work_handler(struct work_struct *work)
 				pm.idle_work.work);
 
 	mutex_lock(&rdev->pm.mutex);
-	if (rdev->pm.state == PM_STATE_ACTIVE &&
-		!rdev->pm.vblank_callback) {
+	if (rdev->pm.state == PM_STATE_ACTIVE) {
 		unsigned long irq_flags;
 		int not_processed = 0;
 
@@ -469,17 +443,8 @@ static void radeon_pm_idle_work_handler(struct work_struct *work)
 		}
 
 		if (rdev->pm.planned_action != PM_ACTION_NONE &&
-			jiffies > rdev->pm.action_timeout) {
-			if (rdev->pm.active_crtcs & (1 << 0)) {
-				rdev->pm.req_vblank |= (1 << 0);
-				drm_vblank_get(rdev->ddev, 0);
-			}
-			if (rdev->pm.active_crtcs & (1 << 1)) {
-				rdev->pm.req_vblank |= (1 << 1);
-				drm_vblank_get(rdev->ddev, 1);
-			}
-			radeon_get_power_state(rdev, rdev->pm.planned_action);
-			rdev->pm.vblank_callback = true;
+		    jiffies > rdev->pm.action_timeout) {
+			radeon_pm_set_clocks(rdev);
 		}
 	}
 	mutex_unlock(&rdev->pm.mutex);
diff --git a/drivers/gpu/drm/radeon/radeon_ring.c b/drivers/gpu/drm/radeon/radeon_ring.c
index d1388ae..f6e1e8d 100644
--- a/drivers/gpu/drm/radeon/radeon_ring.c
+++ b/drivers/gpu/drm/radeon/radeon_ring.c
@@ -225,7 +225,7 @@ void radeon_ib_pool_fini(struct radeon_device *rdev)
 	}
 	mutex_lock(&rdev->ib_pool.mutex);
 	radeon_ib_bogus_cleanup(rdev);
-	bitmap_zero(rdev->ib_pool.alloc_bm, RADEON_IB_POOL_SIZE);
+
 	if (rdev->ib_pool.robj) {
 		r = radeon_bo_reserve(rdev->ib_pool.robj, false);
 		if (likely(r == 0)) {
diff --git a/include/drm/drmP.h b/include/drm/drmP.h
index 3e76738..b447a35 100644
--- a/include/drm/drmP.h
+++ b/include/drm/drmP.h
@@ -55,6 +55,7 @@
 #include <linux/mm.h>
 #include <linux/cdev.h>
 #include <linux/mutex.h>
+#include <linux/slab.h>
 #if defined(__alpha__) || defined(__powerpc__)
 #include <asm/pgtable.h>	/* For pte_wrprotect */
 #endif
-- 
1.7.6

