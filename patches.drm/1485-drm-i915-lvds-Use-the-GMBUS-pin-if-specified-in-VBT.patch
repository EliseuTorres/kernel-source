From 2746f3d93f9f7bb0f4b4c1b407218dfc9be952f2 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Fri, 24 Sep 2010 01:15:02 +0100
Patch-mainline: 2.6.37
References: fate#310916
Git-commit: 270eea0fd71ae95654606ff7448f195fa22d12c5
Subject: [PATCH 1485/2588] drm/i915/lvds: Use the GMBUS pin if specified in
 VBT

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit 270eea0fd71ae95654606ff7448f195fa22d12c5)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/intel_lvds.c |   21 +++++++++++++--------
 1 files changed, 13 insertions(+), 8 deletions(-)

diff --git a/drivers/gpu/drm/i915/intel_lvds.c b/drivers/gpu/drm/i915/intel_lvds.c
index 6703a20..cf12321 100644
--- a/drivers/gpu/drm/i915/intel_lvds.c
+++ b/drivers/gpu/drm/i915/intel_lvds.c
@@ -787,7 +787,8 @@ static void intel_find_lvds_downclock(struct drm_device *dev,
  * If it is not present, return false.
  * If no child dev is parsed from VBT, it assumes that the LVDS is present.
  */
-static bool lvds_is_present_in_vbt(struct drm_device *dev)
+static bool lvds_is_present_in_vbt(struct drm_device *dev,
+				   u8 *i2c_pin)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	int i;
@@ -806,6 +807,9 @@ static bool lvds_is_present_in_vbt(struct drm_device *dev)
 		    child->device_type != DEVICE_TYPE_LFP)
 			continue;
 
+		if (child->i2c_pin)
+		    *i2c_pin = child->i2c_pin;
+
 		/* However, we cannot trust the BIOS writers to populate
 		 * the VBT correctly.  Since LVDS requires additional
 		 * information from AIM blocks, a non-zero addin offset is
@@ -826,7 +830,7 @@ static bool lvds_is_present_in_vbt(struct drm_device *dev)
 	return false;
 }
 
-static bool intel_lvds_ddc_probe(struct drm_device *dev)
+static bool intel_lvds_ddc_probe(struct drm_device *dev, u8 pin)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	u8 buf = 0;
@@ -838,7 +842,7 @@ static bool intel_lvds_ddc_probe(struct drm_device *dev)
 			.buf = &buf,
 		},
 	};
-	struct i2c_adapter *i2c = &dev_priv->gmbus[GMBUS_PORT_PANEL].adapter;
+	struct i2c_adapter *i2c = &dev_priv->gmbus[pin].adapter;
 	return i2c_transfer(i2c, msgs, 1) == 1;
 }
 
@@ -860,13 +864,15 @@ void intel_lvds_init(struct drm_device *dev)
 	struct drm_display_mode *scan; /* *modes, *bios_mode; */
 	struct drm_crtc *crtc;
 	u32 lvds;
-	int pipe, gpio = GPIOC;
+	int pipe;
+	u8 pin;
 
 	/* Skip init on machines we know falsely report LVDS */
 	if (dmi_check_system(intel_no_lvds))
 		return;
 
-	if (!lvds_is_present_in_vbt(dev)) {
+	pin = GMBUS_PORT_PANEL;
+	if (!lvds_is_present_in_vbt(dev, &pin)) {
 		DRM_DEBUG_KMS("LVDS is not present in VBT\n");
 		return;
 	}
@@ -878,10 +884,9 @@ void intel_lvds_init(struct drm_device *dev)
 			DRM_DEBUG_KMS("disable LVDS for eDP support\n");
 			return;
 		}
-		gpio = PCH_GPIOC;
 	}
 
-	if (!intel_lvds_ddc_probe(dev)) {
+	if (!intel_lvds_ddc_probe(dev, pin)) {
 		DRM_DEBUG_KMS("LVDS did not respond to DDC probe\n");
 		return;
 	}
@@ -946,7 +951,7 @@ void intel_lvds_init(struct drm_device *dev)
 	 * preferred mode is the right one.
 	 */
 	intel_lvds->edid = drm_get_edid(connector,
-					&dev_priv->gmbus[GMBUS_PORT_PANEL].adapter);
+					&dev_priv->gmbus[pin].adapter);
 
 	if (!intel_lvds->edid) {
 		/* Didn't get an EDID, so
-- 
1.7.6

