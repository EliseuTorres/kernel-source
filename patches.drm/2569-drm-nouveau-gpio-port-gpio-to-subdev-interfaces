From e0996aea4c349ba302b63203b7d5cab6034dbdca Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Tue, 10 Jul 2012 12:20:17 +1000
Subject: drm/nouveau/gpio: port gpio to subdev interfaces
Git-commit: e0996aea4c349ba302b63203b7d5cab6034dbdca
Patch-mainline: v3.7-rc3

v2: Ben Skeggs <bskeggs@redhat.com>
- rebase on top of v3.6-rc6 with gpio reset patch integrated already

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/nouveau/Makefile                   |    3 +
 .../gpu/drm/nouveau/core/include/subdev/bios/dcb.h |   19 ++
 .../drm/nouveau/core/include/subdev/bios/gpio.h    |   26 ++
 drivers/gpu/drm/nouveau/core/include/subdev/gpio.h |  113 ++++----
 drivers/gpu/drm/nouveau/core/os.h                  |    1 +
 drivers/gpu/drm/nouveau/core/subdev/bios/dcb.c     |  135 ++++++++
 drivers/gpu/drm/nouveau/core/subdev/bios/gpio.c    |  114 +++++++
 drivers/gpu/drm/nouveau/core/subdev/device/nv10.c  |    9 +
 drivers/gpu/drm/nouveau/core/subdev/device/nv20.c  |    5 +
 drivers/gpu/drm/nouveau/core/subdev/device/nv30.c  |    6 +
 drivers/gpu/drm/nouveau/core/subdev/device/nv40.c  |   17 +
 drivers/gpu/drm/nouveau/core/subdev/device/nv50.c  |   15 +
 drivers/gpu/drm/nouveau/core/subdev/device/nvc0.c  |    9 +
 drivers/gpu/drm/nouveau/core/subdev/device/nve0.c  |    3 +
 drivers/gpu/drm/nouveau/core/subdev/gpio/base.c    |  329 ++++++--------------
 drivers/gpu/drm/nouveau/core/subdev/gpio/nv10.c    |  116 +++++--
 drivers/gpu/drm/nouveau/core/subdev/gpio/nv50.c    |  179 +++++++----
 drivers/gpu/drm/nouveau/core/subdev/gpio/nvd0.c    |  104 ++++++
 drivers/gpu/drm/nouveau/core/subdev/i2c/base.c     |    2 +-
 drivers/gpu/drm/nouveau/nouveau_bios.c             |   17 +-
 drivers/gpu/drm/nouveau/nouveau_bios.h             |   15 +-
 drivers/gpu/drm/nouveau/nouveau_compat.c           |   80 +++++
 drivers/gpu/drm/nouveau/nouveau_compat.h           |   11 +
 drivers/gpu/drm/nouveau/nouveau_connector.c        |    3 +-
 drivers/gpu/drm/nouveau/nouveau_display.c          |    3 +-
 drivers/gpu/drm/nouveau/nouveau_dp.c               |    1 -
 drivers/gpu/drm/nouveau/nouveau_drv.h              |   27 --
 drivers/gpu/drm/nouveau/nouveau_mxm.c              |    4 +-
 drivers/gpu/drm/nouveau/nouveau_pm.c               |   17 +-
 drivers/gpu/drm/nouveau/nouveau_state.c            |   42 +---
 drivers/gpu/drm/nouveau/nouveau_volt.c             |    5 +-
 drivers/gpu/drm/nouveau/nv04_dac.c                 |    3 +-
 drivers/gpu/drm/nouveau/nv17_tv.c                  |    3 +-
 33 files changed, 933 insertions(+), 503 deletions(-)

diff --git a/drivers/gpu/drm/nouveau/Makefile b/drivers/gpu/drm/nouveau/Makefile
index d10ec93..414b2e8 100644
--- a/drivers/gpu/drm/nouveau/Makefile
+++ b/drivers/gpu/drm/nouveau/Makefile
@@ -20,6 +20,8 @@ nouveau-y += core/core/subdev.o
 
 nouveau-y += core/subdev/bios/base.o
 nouveau-y += core/subdev/bios/bit.o
+nouveau-y += core/subdev/bios/dcb.o
+nouveau-y += core/subdev/bios/gpio.o
 nouveau-y += core/subdev/device/base.o
 nouveau-y += core/subdev/device/nv04.o
 nouveau-y += core/subdev/device/nv10.o
@@ -41,6 +43,7 @@ nouveau-y += core/subdev/fb/nvc0_vram.o
 nouveau-y += core/subdev/gpio/base.o
 nouveau-y += core/subdev/gpio/nv10.o
 nouveau-y += core/subdev/gpio/nv50.o
+nouveau-y += core/subdev/gpio/nvd0.o
 nouveau-y += core/subdev/i2c/base.o
 nouveau-y += core/subdev/instmem/nv04.o
 nouveau-y += core/subdev/instmem/nv50.o
diff --git a/drivers/gpu/drm/nouveau/core/include/subdev/bios/dcb.h b/drivers/gpu/drm/nouveau/core/include/subdev/bios/dcb.h
new file mode 100644
index 0000000..7000dcf
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/core/include/subdev/bios/dcb.h
@@ -0,0 +1,19 @@
+#ifndef __NVBIOS_DCB_H__
+#define __NVBIOS_DCB_H__
+
+enum dcb_output_type {
+	DCB_OUTPUT_ANALOG	= 0x0,
+	DCB_OUTPUT_TV		= 0x1,
+	DCB_OUTPUT_TMDS		= 0x2,
+	DCB_OUTPUT_LVDS		= 0x3,
+	DCB_OUTPUT_DP		= 0x4,
+	DCB_OUTPUT_EOL		= 0xe,
+	DCB_OUTPUT_UNUSED	= 0xf,
+};
+
+u16 dcb_table(struct nouveau_bios *, u8 *ver, u8 *hdr, u8 *ent, u8 *len);
+u16 dcb_outp(struct nouveau_bios *, u8 idx, u8 *ver, u8 *len);
+int dcb_outp_foreach(struct nouveau_bios *, void *data, int (*exec)
+		     (struct nouveau_bios *, void *, int index, u16 entry));
+
+#endif
diff --git a/drivers/gpu/drm/nouveau/core/include/subdev/bios/gpio.h b/drivers/gpu/drm/nouveau/core/include/subdev/bios/gpio.h
new file mode 100644
index 0000000..e9789cf
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/core/include/subdev/bios/gpio.h
@@ -0,0 +1,26 @@
+#ifndef __NVBIOS_GPIO_H__
+#define __NVBIOS_GPIO_H__
+
+struct nouveau_bios;
+
+enum dcb_gpio_func_name {
+	DCB_GPIO_PANEL_POWER = 0x01,
+	DCB_GPIO_TVDAC0 = 0x0c,
+	DCB_GPIO_TVDAC1 = 0x2d,
+	DCB_GPIO_PWM_FAN = 0x09,
+	DCB_GPIO_FAN_SENSE = 0x3d,
+	DCB_GPIO_UNUSED = 0xff
+};
+
+struct dcb_gpio_func {
+	u8 func;
+	u8 line;
+	u8 log[2];
+};
+
+u16 dcb_gpio_table(struct nouveau_bios *);
+u16 dcb_gpio_entry(struct nouveau_bios *, int idx, int ent, u8 *ver);
+int dcb_gpio_parse(struct nouveau_bios *, int idx, u8 func, u8 line,
+		   struct dcb_gpio_func *);
+
+#endif
diff --git a/drivers/gpu/drm/nouveau/core/include/subdev/gpio.h b/drivers/gpu/drm/nouveau/core/include/subdev/gpio.h
index 64c5cb0..9ea2b12 100644
--- a/drivers/gpu/drm/nouveau/core/include/subdev/gpio.h
+++ b/drivers/gpu/drm/nouveau/core/include/subdev/gpio.h
@@ -1,71 +1,64 @@
-/*
- * Copyright 2011 Red Hat Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- */
-
 #ifndef __NOUVEAU_GPIO_H__
 #define __NOUVEAU_GPIO_H__
 
-struct gpio_func {
-	u8 func;
-	u8 line;
-	u8 log[2];
-};
+#include <core/subdev.h>
+#include <core/device.h>
 
-/* nouveau_gpio.c */
-int  nouveau_gpio_create(struct drm_device *);
-void nouveau_gpio_destroy(struct drm_device *);
-int  nouveau_gpio_init(struct drm_device *);
-void nouveau_gpio_fini(struct drm_device *);
-void nouveau_gpio_reset(struct drm_device *);
-int  nouveau_gpio_drive(struct drm_device *, int idx, int line,
-			int dir, int out);
-int  nouveau_gpio_sense(struct drm_device *, int idx, int line);
-int  nouveau_gpio_find(struct drm_device *, int idx, u8 tag, u8 line,
-		       struct gpio_func *);
-int  nouveau_gpio_set(struct drm_device *, int idx, u8 tag, u8 line, int state);
-int  nouveau_gpio_get(struct drm_device *, int idx, u8 tag, u8 line);
-int  nouveau_gpio_irq(struct drm_device *, int idx, u8 tag, u8 line, bool on);
-void nouveau_gpio_isr(struct drm_device *, int idx, u32 mask);
-int  nouveau_gpio_isr_add(struct drm_device *, int idx, u8 tag, u8 line,
-			  void (*)(void *, int state), void *data);
-void nouveau_gpio_isr_del(struct drm_device *, int idx, u8 tag, u8 line,
-			  void (*)(void *, int state), void *data);
+#include <subdev/bios.h>
+#include <subdev/bios/gpio.h>
 
-static inline bool
-nouveau_gpio_func_valid(struct drm_device *dev, u8 tag)
-{
-	struct gpio_func func;
-	return (nouveau_gpio_find(dev, 0, tag, 0xff, &func)) == 0;
-}
+struct nouveau_gpio {
+	struct nouveau_subdev base;
 
-static inline int
-nouveau_gpio_func_set(struct drm_device *dev, u8 tag, int state)
-{
-	return nouveau_gpio_set(dev, 0, tag, 0xff, state);
-}
+	/* hardware interfaces */
+	void (*reset)(struct nouveau_gpio *);
+	int  (*drive)(struct nouveau_gpio *, int line, int dir, int out);
+	int  (*sense)(struct nouveau_gpio *, int line);
+	void (*irq_enable)(struct nouveau_gpio *, int line, bool);
+
+	/* software interfaces */
+	int  (*find)(struct nouveau_gpio *, int idx, u8 tag, u8 line,
+		     struct dcb_gpio_func *);
+	int  (*set)(struct nouveau_gpio *, int idx, u8 tag, u8 line, int state);
+	int  (*get)(struct nouveau_gpio *, int idx, u8 tag, u8 line);
+	int  (*irq)(struct nouveau_gpio *, int idx, u8 tag, u8 line, bool on);
 
-static inline int
-nouveau_gpio_func_get(struct drm_device *dev, u8 tag)
+	/* interrupt handling */
+	struct list_head isr;
+	spinlock_t lock;
+
+	void (*isr_run)(struct nouveau_gpio *, int idx, u32 mask);
+	int  (*isr_add)(struct nouveau_gpio *, int idx, u8 tag, u8 line,
+			void (*)(void *, int state), void *data);
+	void (*isr_del)(struct nouveau_gpio *, int idx, u8 tag, u8 line,
+			void (*)(void *, int state), void *data);
+};
+
+static inline struct nouveau_gpio *
+nouveau_gpio(void *obj)
 {
-	return nouveau_gpio_get(dev, 0, tag, 0xff);
+	return (void *)nv_device(obj)->subdev[NVDEV_SUBDEV_GPIO];
 }
 
+#define nouveau_gpio_create(p,e,o,d)                                           \
+	nouveau_gpio_create_((p), (e), (o), sizeof(**d), (void **)d)
+#define nouveau_gpio_destroy(p)                                                \
+	nouveau_subdev_destroy(&(p)->base)
+#define nouveau_gpio_fini(p,s)                                                 \
+	nouveau_subdev_fini(&(p)->base, (s))
+
+int nouveau_gpio_create_(struct nouveau_object *, struct nouveau_object *,
+			 struct nouveau_oclass *, int, void **);
+int nouveau_gpio_init(struct nouveau_gpio *);
+
+extern struct nouveau_oclass nv10_gpio_oclass;
+extern struct nouveau_oclass nv50_gpio_oclass;
+extern struct nouveau_oclass nvd0_gpio_oclass;
+
+void nv50_gpio_dtor(struct nouveau_object *);
+int  nv50_gpio_init(struct nouveau_object *);
+int  nv50_gpio_fini(struct nouveau_object *, bool);
+void nv50_gpio_intr(struct nouveau_subdev *);
+void nv50_gpio_irq_enable(struct nouveau_gpio *, int line, bool);
+
 #endif
diff --git a/drivers/gpu/drm/nouveau/core/os.h b/drivers/gpu/drm/nouveau/core/os.h
index 76bdb0e..661b037 100644
--- a/drivers/gpu/drm/nouveau/core/os.h
+++ b/drivers/gpu/drm/nouveau/core/os.h
@@ -15,6 +15,7 @@
 #include <linux/io-mapping.h>
 #include <linux/vmalloc.h>
 #include <linux/acpi.h>
+#include <linux/dmi.h>
 
 #include <asm/unaligned.h>
 
diff --git a/drivers/gpu/drm/nouveau/core/subdev/bios/dcb.c b/drivers/gpu/drm/nouveau/core/subdev/bios/dcb.c
new file mode 100644
index 0000000..9ed6e72
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/core/subdev/bios/dcb.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include "core/device.h"
+
+#include "subdev/bios.h"
+#include "subdev/bios/dcb.h"
+
+u16
+dcb_table(struct nouveau_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len)
+{
+	struct nouveau_device *device = nv_device(bios);
+	u16 dcb = 0x0000;
+
+	if (device->card_type > NV_04)
+		dcb = nv_ro16(bios, 0x36);
+	if (!dcb) {
+		nv_warn(bios, "DCB table not found\n");
+		return dcb;
+	}
+
+	*ver = nv_ro08(bios, dcb);
+
+	if (*ver >= 0x41) {
+		nv_warn(bios, "DCB *ver 0x%02x unknown\n", *ver);
+		return 0x0000;
+	} else
+	if (*ver >= 0x30) {
+		if (nv_ro32(bios, dcb + 6) == 0x4edcbdcb) {
+			*hdr = nv_ro08(bios, dcb + 1);
+			*cnt = nv_ro08(bios, dcb + 2);
+			*len = nv_ro08(bios, dcb + 3);
+			return dcb;
+		}
+	} else
+	if (*ver >= 0x20) {
+		if (nv_ro32(bios, dcb + 4) == 0x4edcbdcb) {
+			u16 i2c = nv_ro16(bios, dcb + 2);
+			*hdr = 8;
+			*cnt = (i2c - dcb) / 8;
+			*len = 8;
+			return dcb;
+		}
+	} else
+	if (*ver >= 0x15) {
+		if (!nv_strncmp(bios, dcb - 7, 7, "DEV_REC")) {
+			u16 i2c = nv_ro16(bios, dcb + 2);
+			*hdr = 4;
+			*cnt = (i2c - dcb) / 10;
+			*len = 10;
+			return dcb;
+		}
+	} else {
+		/*
+		 * v1.4 (some NV15/16, NV11+) seems the same as v1.5, but
+		 * always has the same single (crt) entry, even when tv-out
+		 * present, so the conclusion is this version cannot really
+		 * be used.
+		 *
+		 * v1.2 tables (some NV6/10, and NV15+) normally have the
+		 * same 5 entries, which are not specific to the card and so
+		 * no use.
+		 *
+		 * v1.2 does have an I2C table that read_dcb_i2c_table can
+		 * handle, but cards exist (nv11 in #14821) with a bad i2c
+		 * table pointer, so use the indices parsed in
+		 * parse_bmp_structure.
+		 *
+		 * v1.1 (NV5+, maybe some NV4) is entirely unhelpful
+		 */
+		nv_warn(bios, "DCB contains no useful data\n");
+		return 0x0000;
+	}
+
+	nv_warn(bios, "DCB header validation failed\n");
+	return 0x0000;
+}
+
+u16
+dcb_outp(struct nouveau_bios *bios, u8 idx, u8 *ver, u8 *len)
+{
+	u8  hdr, cnt;
+	u16 dcb = dcb_table(bios, ver, &hdr, &cnt, len);
+	if (dcb && idx < cnt)
+		return dcb + hdr + (idx * *len);
+	return 0x0000;
+}
+
+int
+dcb_outp_foreach(struct nouveau_bios *bios, void *data,
+		 int (*exec)(struct nouveau_bios *, void *, int, u16))
+{
+	int ret, idx = -1;
+	u8  ver, len;
+	u16 outp;
+
+	while ((outp = dcb_outp(bios, ++idx, &ver, &len))) {
+		if (nv_ro32(bios, outp) == 0x00000000)
+			break; /* seen on an NV11 with DCB v1.5 */
+		if (nv_ro32(bios, outp) == 0xffffffff)
+			break; /* seen on an NV17 with DCB v2.0 */
+
+		if (nv_ro08(bios, outp) == DCB_OUTPUT_UNUSED)
+			continue;
+		if (nv_ro08(bios, outp) == DCB_OUTPUT_EOL)
+			break;
+
+		ret = exec(bios, data, idx, outp);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/nouveau/core/subdev/bios/gpio.c b/drivers/gpu/drm/nouveau/core/subdev/bios/gpio.c
new file mode 100644
index 0000000..718267d
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/core/subdev/bios/gpio.c
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <subdev/bios.h>
+#include <subdev/bios/dcb.h>
+#include <subdev/bios/gpio.h>
+
+u16
+dcb_gpio_table(struct nouveau_bios *bios)
+{
+	u8  ver, hdr, cnt, len;
+	u16 dcb = dcb_table(bios, &ver, &hdr, &cnt, &len);
+	if (dcb) {
+		if (ver >= 0x30 && hdr >= 0x0c)
+			return nv_ro16(bios, dcb + 0x0a);
+		if (ver >= 0x22 && nv_ro08(bios, dcb - 1) >= 0x13)
+			return nv_ro16(bios, dcb - 0x0f);
+	}
+	return 0x0000;
+}
+
+u16
+dcb_gpio_entry(struct nouveau_bios *bios, int idx, int ent, u8 *ver)
+{
+	u16 gpio = dcb_gpio_table(bios);
+	if (gpio) {
+		*ver = nv_ro08(bios, gpio);
+		if (*ver < 0x30 && ent < nv_ro08(bios, gpio + 2))
+			return gpio + 3 + (ent * nv_ro08(bios, gpio + 1));
+		else if (ent < nv_ro08(bios, gpio + 2))
+			return gpio + nv_ro08(bios, gpio + 1) +
+			       (ent * nv_ro08(bios, gpio + 3));
+	}
+	return 0x0000;
+}
+
+int
+dcb_gpio_parse(struct nouveau_bios *bios, int idx, u8 func, u8 line,
+	       struct dcb_gpio_func *gpio)
+{
+	u8  ver, hdr, cnt, len;
+	u16 entry;
+	int i = -1;
+
+	while ((entry = dcb_gpio_entry(bios, idx, ++i, &ver))) {
+		if (ver < 0x40) {
+			u16 data = nv_ro16(bios, entry);
+			*gpio = (struct dcb_gpio_func) {
+				.line = (data & 0x001f) >> 0,
+				.func = (data & 0x07e0) >> 5,
+				.log[0] = (data & 0x1800) >> 11,
+				.log[1] = (data & 0x6000) >> 13,
+			};
+		} else
+		if (ver < 0x41) {
+			u32 data = nv_ro32(bios, entry);
+			*gpio = (struct dcb_gpio_func) {
+				.line = (data & 0x0000001f) >> 0,
+				.func = (data & 0x0000ff00) >> 8,
+				.log[0] = (data & 0x18000000) >> 27,
+				.log[1] = (data & 0x60000000) >> 29,
+			};
+		} else {
+			u32 data = nv_ro32(bios, entry + 0);
+			u8 data1 = nv_ro32(bios, entry + 4);
+			*gpio = (struct dcb_gpio_func) {
+				.line = (data & 0x0000003f) >> 0,
+				.func = (data & 0x0000ff00) >> 8,
+				.log[0] = (data1 & 0x30) >> 4,
+				.log[1] = (data1 & 0xc0) >> 6,
+			};
+		}
+
+		if ((line == 0xff || line == gpio->line) &&
+		    (func == 0xff || func == gpio->func))
+			return 0;
+	}
+
+	/* DCB 2.2, fixed TVDAC GPIO data */
+	if ((entry = dcb_table(bios, &ver, &hdr, &cnt, &len)) && ver >= 0x22) {
+		if (func == DCB_GPIO_TVDAC0) {
+			*gpio = (struct dcb_gpio_func) {
+				.func = DCB_GPIO_TVDAC0,
+				.line = nv_ro08(bios, entry - 4) >> 4,
+				.log[0] = !!(nv_ro08(bios, entry - 5) & 2),
+				.log[1] =  !(nv_ro08(bios, entry - 5) & 2),
+			};
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
diff --git a/drivers/gpu/drm/nouveau/core/subdev/device/nv10.c b/drivers/gpu/drm/nouveau/core/subdev/device/nv10.c
index f9e4288..c0c40cd 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/device/nv10.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/device/nv10.c
@@ -24,6 +24,7 @@
 
 #include <subdev/device.h>
 #include <subdev/bios.h>
+#include <subdev/gpio.h>
 
 int
 nv10_identify(struct nouveau_device *device)
@@ -31,27 +32,35 @@ nv10_identify(struct nouveau_device *device)
 	switch (device->chipset) {
 	case 0x10:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x15:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x16:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x1a:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x11:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x17:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x1f:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x18:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Celsius chipset\n");
diff --git a/drivers/gpu/drm/nouveau/core/subdev/device/nv20.c b/drivers/gpu/drm/nouveau/core/subdev/device/nv20.c
index b5dfb7e..1215e3f 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/device/nv20.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/device/nv20.c
@@ -24,6 +24,7 @@
 
 #include <subdev/device.h>
 #include <subdev/bios.h>
+#include <subdev/gpio.h>
 
 int
 nv20_identify(struct nouveau_device *device)
@@ -31,15 +32,19 @@ nv20_identify(struct nouveau_device *device)
 	switch (device->chipset) {
 	case 0x20:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x25:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x28:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x2a:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Kelvin chipset\n");
diff --git a/drivers/gpu/drm/nouveau/core/subdev/device/nv30.c b/drivers/gpu/drm/nouveau/core/subdev/device/nv30.c
index b2e50e3..43eb94e 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/device/nv30.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/device/nv30.c
@@ -24,6 +24,7 @@
 
 #include <subdev/device.h>
 #include <subdev/bios.h>
+#include <subdev/gpio.h>
 
 int
 nv30_identify(struct nouveau_device *device)
@@ -31,18 +32,23 @@ nv30_identify(struct nouveau_device *device)
 	switch (device->chipset) {
 	case 0x30:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x35:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x31:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x36:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x34:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Rankine chipset\n");
diff --git a/drivers/gpu/drm/nouveau/core/subdev/device/nv40.c b/drivers/gpu/drm/nouveau/core/subdev/device/nv40.c
index 4a3e3a8..7c10a3c 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/device/nv40.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/device/nv40.c
@@ -24,6 +24,7 @@
 
 #include <subdev/device.h>
 #include <subdev/bios.h>
+#include <subdev/gpio.h>
 
 int
 nv40_identify(struct nouveau_device *device)
@@ -31,51 +32,67 @@ nv40_identify(struct nouveau_device *device)
 	switch (device->chipset) {
 	case 0x40:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x41:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x42:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x43:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x45:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x47:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x49:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x4b:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x44:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x46:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x4a:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x4c:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x4e:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x63:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x67:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	case 0x68:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv10_gpio_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Curie chipset\n");
diff --git a/drivers/gpu/drm/nouveau/core/subdev/device/nv50.c b/drivers/gpu/drm/nouveau/core/subdev/device/nv50.c
index 018c711..581dcf1 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/device/nv50.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/device/nv50.c
@@ -24,6 +24,7 @@
 
 #include <subdev/device.h>
 #include <subdev/bios.h>
+#include <subdev/gpio.h>
 
 int
 nv50_identify(struct nouveau_device *device)
@@ -31,45 +32,59 @@ nv50_identify(struct nouveau_device *device)
 	switch (device->chipset) {
 	case 0x50:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0x84:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0x86:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0x92:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0x94:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0x96:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0x98:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xa0:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xaa:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xac:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xa3:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xa5:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xa8:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xaf:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Tesla chipset\n");
diff --git a/drivers/gpu/drm/nouveau/core/subdev/device/nvc0.c b/drivers/gpu/drm/nouveau/core/subdev/device/nvc0.c
index 0e81277..df31111 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/device/nvc0.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/device/nvc0.c
@@ -24,6 +24,7 @@
 
 #include <subdev/device.h>
 #include <subdev/bios.h>
+#include <subdev/gpio.h>
 
 int
 nvc0_identify(struct nouveau_device *device)
@@ -31,27 +32,35 @@ nvc0_identify(struct nouveau_device *device)
 	switch (device->chipset) {
 	case 0xc0:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xc4:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xc3:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xce:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xcf:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xc1:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xc8:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nv50_gpio_oclass;
 		break;
 	case 0xd9:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nvd0_gpio_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Fermi chipset\n");
diff --git a/drivers/gpu/drm/nouveau/core/subdev/device/nve0.c b/drivers/gpu/drm/nouveau/core/subdev/device/nve0.c
index 15cae43..d321cb4 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/device/nve0.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/device/nve0.c
@@ -24,6 +24,7 @@
 
 #include <subdev/device.h>
 #include <subdev/bios.h>
+#include <subdev/gpio.h>
 
 int
 nve0_identify(struct nouveau_device *device)
@@ -31,9 +32,11 @@ nve0_identify(struct nouveau_device *device)
 	switch (device->chipset) {
 	case 0xe4:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nvd0_gpio_oclass;
 		break;
 	case 0xe7:
 		device->oclass[NVDEV_SUBDEV_VBIOS  ] = &nouveau_bios_oclass;
+		device->oclass[NVDEV_SUBDEV_GPIO   ] = &nvd0_gpio_oclass;
 		break;
 	default:
 		nv_fatal(device, "unknown Kepler chipset\n");
diff --git a/drivers/gpu/drm/nouveau/core/subdev/gpio/base.c b/drivers/gpu/drm/nouveau/core/subdev/gpio/base.c
index 2c48309..abb135f 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/gpio/base.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/gpio/base.c
@@ -22,114 +22,37 @@
  * Authors: Ben Skeggs
  */
 
-#include "drmP.h"
-#include "nouveau_drv.h"
-#include <subdev/i2c.h>
 #include <subdev/gpio.h>
+#include <subdev/bios.h>
+#include <subdev/bios/gpio.h>
 
-static u8 *
-dcb_gpio_table(struct drm_device *dev)
+static int
+nouveau_gpio_drive(struct nouveau_gpio *gpio,
+		   int idx, int line, int dir, int out)
 {
-	u8 *dcb = dcb_table(dev);
-	if (dcb) {
-		if (dcb[0] >= 0x30 && dcb[1] >= 0x0c)
-			return ROMPTR(dev, dcb[0x0a]);
-		if (dcb[0] >= 0x22 && dcb[-1] >= 0x13)
-			return ROMPTR(dev, dcb[-15]);
-	}
-	return NULL;
-}
-
-static u8 *
-dcb_gpio_entry(struct drm_device *dev, int idx, int ent, u8 *version)
-{
-	u8 *table = dcb_gpio_table(dev);
-	if (table) {
-		*version = table[0];
-		if (*version < 0x30 && ent < table[2])
-			return table + 3 + (ent * table[1]);
-		else if (ent < table[2])
-			return table + table[1] + (ent * table[3]);
-	}
-	return NULL;
+	return gpio->drive ? gpio->drive(gpio, line, dir, out) : -ENODEV;
 }
 
-int
-nouveau_gpio_drive(struct drm_device *dev, int idx, int line, int dir, int out)
+static int
+nouveau_gpio_sense(struct nouveau_gpio *gpio, int idx, int line)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
-
-	return pgpio->drive ? pgpio->drive(dev, line, dir, out) : -ENODEV;
+	return gpio->sense ? gpio->sense(gpio, line) : -ENODEV;
 }
 
-int
-nouveau_gpio_sense(struct drm_device *dev, int idx, int line)
+static int
+nouveau_gpio_find(struct nouveau_gpio *gpio, int idx, u8 tag, u8 line,
+		  struct dcb_gpio_func *func)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
-
-	return pgpio->sense ? pgpio->sense(dev, line) : -ENODEV;
-}
-
-int
-nouveau_gpio_find(struct drm_device *dev, int idx, u8 func, u8 line,
-		  struct gpio_func *gpio)
-{
-	u8 *table, *entry, version;
-	int i = -1;
-
-	if (line == 0xff && func == 0xff)
+	if (line == 0xff && tag == 0xff)
 		return -EINVAL;
 
-	while ((entry = dcb_gpio_entry(dev, idx, ++i, &version))) {
-		if (version < 0x40) {
-			u16 data = ROM16(entry[0]);
-			*gpio = (struct gpio_func) {
-				.line = (data & 0x001f) >> 0,
-				.func = (data & 0x07e0) >> 5,
-				.log[0] = (data & 0x1800) >> 11,
-				.log[1] = (data & 0x6000) >> 13,
-			};
-		} else
-		if (version < 0x41) {
-			*gpio = (struct gpio_func) {
-				.line = entry[0] & 0x1f,
-				.func = entry[1],
-				.log[0] = (entry[3] & 0x18) >> 3,
-				.log[1] = (entry[3] & 0x60) >> 5,
-			};
-		} else {
-			*gpio = (struct gpio_func) {
-				.line = entry[0] & 0x3f,
-				.func = entry[1],
-				.log[0] = (entry[4] & 0x30) >> 4,
-				.log[1] = (entry[4] & 0xc0) >> 6,
-			};
-		}
-
-		if ((line == 0xff || line == gpio->line) &&
-		    (func == 0xff || func == gpio->func))
-			return 0;
-	}
-
-	/* DCB 2.2, fixed TVDAC GPIO data */
-	if ((table = dcb_table(dev)) && table[0] >= 0x22) {
-		if (func == DCB_GPIO_TVDAC0) {
-			*gpio = (struct gpio_func) {
-				.func = DCB_GPIO_TVDAC0,
-				.line = table[-4] >> 4,
-				.log[0] = !!(table[-5] & 2),
-				.log[1] =  !(table[-5] & 2),
-			};
-			return 0;
-		}
-	}
+	if (!dcb_gpio_parse(nouveau_bios(gpio), idx, tag, line, func))
+		return 0;
 
 	/* Apple iMac G4 NV18 */
-	if (nv_match_device(dev, 0x0189, 0x10de, 0x0010)) {
-		if (func == DCB_GPIO_TVDAC0) {
-			*gpio = (struct gpio_func) {
+	if (nv_device_match(nv_object(gpio), 0x0189, 0x10de, 0x0010)) {
+		if (tag == DCB_GPIO_TVDAC0) {
+			*func = (struct dcb_gpio_func) {
 				.func = DCB_GPIO_TVDAC0,
 				.line = 4,
 				.log[0] = 0,
@@ -142,50 +65,48 @@ nouveau_gpio_find(struct drm_device *dev, int idx, u8 func, u8 line,
 	return -EINVAL;
 }
 
-int
-nouveau_gpio_set(struct drm_device *dev, int idx, u8 tag, u8 line, int state)
+static int
+nouveau_gpio_set(struct nouveau_gpio *gpio, int idx, u8 tag, u8 line, int state)
 {
-	struct gpio_func gpio;
+	struct dcb_gpio_func func;
 	int ret;
 
-	ret = nouveau_gpio_find(dev, idx, tag, line, &gpio);
+	ret = nouveau_gpio_find(gpio, idx, tag, line, &func);
 	if (ret == 0) {
-		int dir = !!(gpio.log[state] & 0x02);
-		int out = !!(gpio.log[state] & 0x01);
-		ret = nouveau_gpio_drive(dev, idx, gpio.line, dir, out);
+		int dir = !!(func.log[state] & 0x02);
+		int out = !!(func.log[state] & 0x01);
+		ret = nouveau_gpio_drive(gpio, idx, func.line, dir, out);
 	}
 
 	return ret;
 }
 
-int
-nouveau_gpio_get(struct drm_device *dev, int idx, u8 tag, u8 line)
+static int
+nouveau_gpio_get(struct nouveau_gpio *gpio, int idx, u8 tag, u8 line)
 {
-	struct gpio_func gpio;
+	struct dcb_gpio_func func;
 	int ret;
 
-	ret = nouveau_gpio_find(dev, idx, tag, line, &gpio);
+	ret = nouveau_gpio_find(gpio, idx, tag, line, &func);
 	if (ret == 0) {
-		ret = nouveau_gpio_sense(dev, idx, gpio.line);
+		ret = nouveau_gpio_sense(gpio, idx, func.line);
 		if (ret >= 0)
-			ret = (ret == (gpio.log[1] & 1));
+			ret = (ret == (func.log[1] & 1));
 	}
 
 	return ret;
 }
 
-int
-nouveau_gpio_irq(struct drm_device *dev, int idx, u8 tag, u8 line, bool on)
+static int
+nouveau_gpio_irq(struct nouveau_gpio *gpio, int idx, u8 tag, u8 line, bool on)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
-	struct gpio_func gpio;
+	struct dcb_gpio_func func;
 	int ret;
 
-	ret = nouveau_gpio_find(dev, idx, tag, line, &gpio);
+	ret = nouveau_gpio_find(gpio, idx, tag, line, &func);
 	if (ret == 0) {
-		if (idx == 0 && pgpio->irq_enable)
-			pgpio->irq_enable(dev, gpio.line, on);
+		if (idx == 0 && gpio->irq_enable)
+			gpio->irq_enable(gpio, func.line, on);
 		else
 			ret = -ENODEV;
 	}
@@ -194,11 +115,11 @@ nouveau_gpio_irq(struct drm_device *dev, int idx, u8 tag, u8 line, bool on)
 }
 
 struct gpio_isr {
-	struct drm_device *dev;
+	struct nouveau_gpio *gpio;
 	struct list_head head;
 	struct work_struct work;
 	int idx;
-	struct gpio_func func;
+	struct dcb_gpio_func func;
 	void (*handler)(void *, int);
 	void *data;
 	bool inhibit;
@@ -208,33 +129,30 @@ static void
 nouveau_gpio_isr_bh(struct work_struct *work)
 {
 	struct gpio_isr *isr = container_of(work, struct gpio_isr, work);
-	struct drm_device *dev = isr->dev;
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
+	struct nouveau_gpio *gpio = isr->gpio;
 	unsigned long flags;
 	int state;
 
-	state = nouveau_gpio_get(dev, isr->idx, isr->func.func, isr->func.line);
+	state = nouveau_gpio_get(gpio, isr->idx, isr->func.func,
+						 isr->func.line);
 	if (state >= 0)
 		isr->handler(isr->data, state);
 
-	spin_lock_irqsave(&pgpio->lock, flags);
+	spin_lock_irqsave(&gpio->lock, flags);
 	isr->inhibit = false;
-	spin_unlock_irqrestore(&pgpio->lock, flags);
+	spin_unlock_irqrestore(&gpio->lock, flags);
 }
 
-void
-nouveau_gpio_isr(struct drm_device *dev, int idx, u32 line_mask)
+static void
+nouveau_gpio_isr_run(struct nouveau_gpio *gpio, int idx, u32 line_mask)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
 	struct gpio_isr *isr;
 
 	if (idx != 0)
 		return;
 
-	spin_lock(&pgpio->lock);
-	list_for_each_entry(isr, &pgpio->isr, head) {
+	spin_lock(&gpio->lock);
+	list_for_each_entry(isr, &gpio->isr, head) {
 		if (line_mask & (1 << isr->func.line)) {
 			if (isr->inhibit)
 				continue;
@@ -242,15 +160,13 @@ nouveau_gpio_isr(struct drm_device *dev, int idx, u32 line_mask)
 			schedule_work(&isr->work);
 		}
 	}
-	spin_unlock(&pgpio->lock);
+	spin_unlock(&gpio->lock);
 }
 
-int
-nouveau_gpio_isr_add(struct drm_device *dev, int idx, u8 tag, u8 line,
+static int
+nouveau_gpio_isr_add(struct nouveau_gpio *gpio, int idx, u8 tag, u8 line,
 		     void (*handler)(void *, int), void *data)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
 	struct gpio_isr *isr;
 	unsigned long flags;
 	int ret;
@@ -259,47 +175,45 @@ nouveau_gpio_isr_add(struct drm_device *dev, int idx, u8 tag, u8 line,
 	if (!isr)
 		return -ENOMEM;
 
-	ret = nouveau_gpio_find(dev, idx, tag, line, &isr->func);
+	ret = nouveau_gpio_find(gpio, idx, tag, line, &isr->func);
 	if (ret) {
 		kfree(isr);
 		return ret;
 	}
 
 	INIT_WORK(&isr->work, nouveau_gpio_isr_bh);
-	isr->dev = dev;
+	isr->gpio = gpio;
 	isr->handler = handler;
 	isr->data = data;
 	isr->idx = idx;
 
-	spin_lock_irqsave(&pgpio->lock, flags);
-	list_add(&isr->head, &pgpio->isr);
-	spin_unlock_irqrestore(&pgpio->lock, flags);
+	spin_lock_irqsave(&gpio->lock, flags);
+	list_add(&isr->head, &gpio->isr);
+	spin_unlock_irqrestore(&gpio->lock, flags);
 	return 0;
 }
 
-void
-nouveau_gpio_isr_del(struct drm_device *dev, int idx, u8 tag, u8 line,
+static void
+nouveau_gpio_isr_del(struct nouveau_gpio *gpio, int idx, u8 tag, u8 line,
 		     void (*handler)(void *, int), void *data)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
 	struct gpio_isr *isr, *tmp;
-	struct gpio_func func;
+	struct dcb_gpio_func func;
 	unsigned long flags;
 	LIST_HEAD(tofree);
 	int ret;
 
-	ret = nouveau_gpio_find(dev, idx, tag, line, &func);
+	ret = nouveau_gpio_find(gpio, idx, tag, line, &func);
 	if (ret == 0) {
-		spin_lock_irqsave(&pgpio->lock, flags);
-		list_for_each_entry_safe(isr, tmp, &pgpio->isr, head) {
+		spin_lock_irqsave(&gpio->lock, flags);
+		list_for_each_entry_safe(isr, tmp, &gpio->isr, head) {
 			if (memcmp(&isr->func, &func, sizeof(func)) ||
 			    isr->idx != idx ||
 			    isr->handler != handler || isr->data != data)
 				continue;
-			list_move(&isr->head, &tofree);
+			list_move_tail(&isr->head, &tofree);
 		}
-		spin_unlock_irqrestore(&pgpio->lock, flags);
+		spin_unlock_irqrestore(&gpio->lock, flags);
 
 		list_for_each_entry_safe(isr, tmp, &tofree, head) {
 			flush_work_sync(&isr->work);
@@ -309,92 +223,49 @@ nouveau_gpio_isr_del(struct drm_device *dev, int idx, u8 tag, u8 line,
 }
 
 int
-nouveau_gpio_create(struct drm_device *dev)
+nouveau_gpio_create_(struct nouveau_object *parent,
+		     struct nouveau_object *engine,
+		     struct nouveau_oclass *oclass, int length, void **pobject)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
+	struct nouveau_gpio *gpio;
+	int ret;
 
-	INIT_LIST_HEAD(&pgpio->isr);
-	spin_lock_init(&pgpio->lock);
+	ret = nouveau_subdev_create_(parent, engine, oclass, 0, "GPIO", "gpio",
+				     length, pobject);
+	gpio = *pobject;
+	if (ret)
+		return ret;
 
-	return nouveau_gpio_init(dev);
+	gpio->find = nouveau_gpio_find;
+	gpio->set  = nouveau_gpio_set;
+	gpio->get  = nouveau_gpio_get;
+	gpio->irq  = nouveau_gpio_irq;
+	gpio->isr_run = nouveau_gpio_isr_run;
+	gpio->isr_add = nouveau_gpio_isr_add;
+	gpio->isr_del = nouveau_gpio_isr_del;
+	INIT_LIST_HEAD(&gpio->isr);
+	spin_lock_init(&gpio->lock);
+	return 0;
 }
 
-void
-nouveau_gpio_destroy(struct drm_device *dev)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
-
-	nouveau_gpio_fini(dev);
-	BUG_ON(!list_empty(&pgpio->isr));
-}
+static struct dmi_system_id gpio_reset_ids[] = {
+	{
+		.ident = "Apple Macbook 10,1",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro10,1"),
+		}
+	},
+	{ }
+};
 
 int
-nouveau_gpio_init(struct drm_device *dev)
+nouveau_gpio_init(struct nouveau_gpio *gpio)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
-	int ret = 0;
-
-	if (pgpio->init)
-		ret = pgpio->init(dev);
-
-	return ret;
-}
-
-void
-nouveau_gpio_fini(struct drm_device *dev)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
-
-	if (pgpio->fini)
-		pgpio->fini(dev);
-}
-
-void
-nouveau_gpio_reset(struct drm_device *dev)
-{
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-	u8 *entry, version;
-	int ent = -1;
-
-	while ((entry = dcb_gpio_entry(dev, 0, ++ent, &version))) {
-		u8 func = 0xff, line, defs, unk0, unk1;
-		if (version >= 0x41) {
-			defs = !!(entry[0] & 0x80);
-			line = entry[0] & 0x3f;
-			func = entry[1];
-			unk0 = entry[2];
-			unk1 = entry[3] & 0x1f;
-		} else
-		if (version >= 0x40) {
-			line = entry[0] & 0x1f;
-			func = entry[1];
-			defs = !!(entry[3] & 0x01);
-			unk0 = !!(entry[3] & 0x02);
-			unk1 = !!(entry[3] & 0x04);
-		} else {
-			break;
-		}
-
-		if (func == 0xff)
-			continue;
-
-		nouveau_gpio_func_set(dev, func, defs);
-
-		if (dev_priv->card_type >= NV_D0) {
-			nv_mask(dev, 0x00d610 + (line * 4), 0xff, unk0);
-			if (unk1--)
-				nv_mask(dev, 0x00d740 + (unk1 * 4), 0xff, line);
-		} else
-		if (dev_priv->card_type >= NV_50) {
-			static const u32 regs[] = { 0xe100, 0xe28c };
-			u32 val = (unk1 << 16) | unk0;
-			u32 reg = regs[line >> 4]; line &= 0x0f;
-
-			nv_mask(dev, reg, 0x00010001 << line, val << line);
-		}
+	int ret = nouveau_subdev_init(&gpio->base);
+	if (ret == 0 && gpio->reset) {
+		if (dmi_check_system(gpio_reset_ids))
+			gpio->reset(gpio);
 	}
+	return ret;
 }
diff --git a/drivers/gpu/drm/nouveau/core/subdev/gpio/nv10.c b/drivers/gpu/drm/nouveau/core/subdev/gpio/nv10.c
index 42e600f..168d16a 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/gpio/nv10.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/gpio/nv10.c
@@ -24,100 +24,146 @@
  *
  */
 
-#include "drmP.h"
-#include "nouveau_drv.h"
-#include "nouveau_hw.h"
 #include <subdev/gpio.h>
 
-int
-nv10_gpio_sense(struct drm_device *dev, int line)
+struct nv10_gpio_priv {
+	struct nouveau_gpio base;
+};
+
+static int
+nv10_gpio_sense(struct nouveau_gpio *gpio, int line)
 {
 	if (line < 2) {
 		line = line * 16;
-		line = NVReadCRTC(dev, 0, NV_PCRTC_GPIO) >> line;
+		line = nv_rd32(gpio, 0x600818) >> line;
 		return !!(line & 0x0100);
 	} else
 	if (line < 10) {
 		line = (line - 2) * 4;
-		line = NVReadCRTC(dev, 0, NV_PCRTC_GPIO_EXT) >> line;
+		line = nv_rd32(gpio, 0x60081c) >> line;
 		return !!(line & 0x04);
 	} else
 	if (line < 14) {
 		line = (line - 10) * 4;
-		line = NVReadCRTC(dev, 0, NV_PCRTC_850) >> line;
+		line = nv_rd32(gpio, 0x600850) >> line;
 		return !!(line & 0x04);
 	}
 
 	return -EINVAL;
 }
 
-int
-nv10_gpio_drive(struct drm_device *dev, int line, int dir, int out)
+static int
+nv10_gpio_drive(struct nouveau_gpio *gpio, int line, int dir, int out)
 {
 	u32 reg, mask, data;
 
 	if (line < 2) {
 		line = line * 16;
-		reg  = NV_PCRTC_GPIO;
+		reg  = 0x600818;
 		mask = 0x00000011;
 		data = (dir << 4) | out;
 	} else
 	if (line < 10) {
 		line = (line - 2) * 4;
-		reg  = NV_PCRTC_GPIO_EXT;
+		reg  = 0x60081c;
 		mask = 0x00000003;
 		data = (dir << 1) | out;
 	} else
 	if (line < 14) {
 		line = (line - 10) * 4;
-		reg  = NV_PCRTC_850;
+		reg  = 0x600850;
 		mask = 0x00000003;
 		data = (dir << 1) | out;
 	} else {
 		return -EINVAL;
 	}
 
-	mask = NVReadCRTC(dev, 0, reg) & ~(mask << line);
-	NVWriteCRTC(dev, 0, reg, mask | (data << line));
+	nv_mask(gpio, reg, mask << line, data << line);
 	return 0;
 }
 
-void
-nv10_gpio_irq_enable(struct drm_device *dev, int line, bool on)
+static void
+nv10_gpio_irq_enable(struct nouveau_gpio *gpio, int line, bool on)
 {
 	u32 mask = 0x00010001 << line;
 
-	nv_wr32(dev, 0x001104, mask);
-	nv_mask(dev, 0x001144, mask, on ? mask : 0);
+	nv_wr32(gpio, 0x001104, mask);
+	nv_mask(gpio, 0x001144, mask, on ? mask : 0);
 }
 
 static void
-nv10_gpio_isr(struct drm_device *dev)
+nv10_gpio_intr(struct nouveau_subdev *subdev)
 {
-	u32 intr = nv_rd32(dev, 0x1104);
+	struct nv10_gpio_priv *priv = (void *)subdev;
+	u32 intr = nv_rd32(priv, 0x001104);
 	u32 hi = (intr & 0x0000ffff) >> 0;
 	u32 lo = (intr & 0xffff0000) >> 16;
 
-	nouveau_gpio_isr(dev, 0, hi | lo);
+	priv->base.isr_run(&priv->base, 0, hi | lo);
 
-	nv_wr32(dev, 0x001104, intr);
+	nv_wr32(priv, 0x001104, intr);
 }
 
-int
-nv10_gpio_init(struct drm_device *dev)
+static int
+nv10_gpio_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
 {
-	nv_wr32(dev, 0x001140, 0x00000000);
-	nv_wr32(dev, 0x001100, 0xffffffff);
-	nv_wr32(dev, 0x001144, 0x00000000);
-	nv_wr32(dev, 0x001104, 0xffffffff);
-	nouveau_irq_register(dev, 28, nv10_gpio_isr); /* PBUS */
+	struct nv10_gpio_priv *priv;
+	int ret;
+
+	ret = nouveau_gpio_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	priv->base.drive = nv10_gpio_drive;
+	priv->base.sense = nv10_gpio_sense;
+	priv->base.irq_enable = nv10_gpio_irq_enable;
+	nv_subdev(priv)->intr = nv10_gpio_intr;
 	return 0;
 }
 
-void
-nv10_gpio_fini(struct drm_device *dev)
+static void
+nv10_gpio_dtor(struct nouveau_object *object)
 {
-	nv_wr32(dev, 0x001140, 0x00000000);
-	nv_wr32(dev, 0x001144, 0x00000000);
-	nouveau_irq_unregister(dev, 28);
+	struct nv10_gpio_priv *priv = (void *)object;
+	nouveau_gpio_destroy(&priv->base);
 }
+
+static int
+nv10_gpio_init(struct nouveau_object *object)
+{
+	struct nv10_gpio_priv *priv = (void *)object;
+	int ret;
+
+	ret = nouveau_gpio_init(&priv->base);
+	if (ret)
+		return ret;
+
+	nv_wr32(priv, 0x001140, 0x00000000);
+	nv_wr32(priv, 0x001100, 0xffffffff);
+	nv_wr32(priv, 0x001144, 0x00000000);
+	nv_wr32(priv, 0x001104, 0xffffffff);
+	return 0;
+}
+
+static int
+nv10_gpio_fini(struct nouveau_object *object, bool suspend)
+{
+	struct nv10_gpio_priv *priv = (void *)object;
+	nv_wr32(priv, 0x001140, 0x00000000);
+	nv_wr32(priv, 0x001144, 0x00000000);
+	return nouveau_gpio_fini(&priv->base, suspend);
+}
+
+struct nouveau_oclass
+nv10_gpio_oclass = {
+	.handle = NV_SUBDEV(GPIO, 0x10),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv10_gpio_ctor,
+		.dtor = nv10_gpio_dtor,
+		.init = nv10_gpio_init,
+		.fini = nv10_gpio_fini,
+	},
+};
diff --git a/drivers/gpu/drm/nouveau/core/subdev/gpio/nv50.c b/drivers/gpu/drm/nouveau/core/subdev/gpio/nv50.c
index 48509b0..f3502c9 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/gpio/nv50.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/gpio/nv50.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2010 Red Hat Inc.
+ * Copyright 2012 Red Hat Inc.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
@@ -22,18 +22,45 @@
  * Authors: Ben Skeggs
  */
 
-#include <linux/dmi.h>
-#include "drmP.h"
-#include "nouveau_drv.h"
-#include "nouveau_hw.h"
 #include <subdev/gpio.h>
 
-#include "nv50_display.h"
+struct nv50_gpio_priv {
+	struct nouveau_gpio base;
+};
+
+static void
+nv50_gpio_reset(struct nouveau_gpio *gpio)
+{
+	struct nouveau_bios *bios = nouveau_bios(gpio);
+	struct nv50_gpio_priv *priv = (void *)gpio;
+	u16 entry;
+	u8 ver;
+	int ent = -1;
+
+	while ((entry = dcb_gpio_entry(bios, 0, ++ent, &ver))) {
+		static const u32 regs[] = { 0xe100, 0xe28c };
+		u32 data = nv_ro32(bios, entry);
+		u8  line =   (data & 0x0000001f);
+		u8  func =   (data & 0x0000ff00) >> 8;
+		u8  defs = !!(data & 0x01000000);
+		u8  unk0 = !!(data & 0x02000000);
+		u8  unk1 = !!(data & 0x04000000);
+		u32 val = (unk1 << 16) | unk0;
+		u32 reg = regs[line >> 4]; line &= 0x0f;
+
+		if (func == 0xff)
+			continue;
+
+		gpio->set(gpio, 0, func, line, defs);
+
+		nv_mask(priv, reg, 0x00010001 << line, val << line);
+	}
+}
 
 static int
 nv50_gpio_location(int line, u32 *reg, u32 *shift)
 {
-	const uint32_t nv50_gpio_reg[4] = { 0xe104, 0xe108, 0xe280, 0xe284 };
+	const u32 nv50_gpio_reg[4] = { 0xe104, 0xe108, 0xe280, 0xe284 };
 
 	if (line >= 32)
 		return -EINVAL;
@@ -43,113 +70,125 @@ nv50_gpio_location(int line, u32 *reg, u32 *shift)
 	return 0;
 }
 
-int
-nv50_gpio_drive(struct drm_device *dev, int line, int dir, int out)
+static int
+nv50_gpio_drive(struct nouveau_gpio *gpio, int line, int dir, int out)
 {
 	u32 reg, shift;
 
 	if (nv50_gpio_location(line, &reg, &shift))
 		return -EINVAL;
 
-	nv_mask(dev, reg, 7 << shift, (((dir ^ 1) << 1) | out) << shift);
+	nv_mask(gpio, reg, 7 << shift, (((dir ^ 1) << 1) | out) << shift);
 	return 0;
 }
 
-int
-nv50_gpio_sense(struct drm_device *dev, int line)
+static int
+nv50_gpio_sense(struct nouveau_gpio *gpio, int line)
 {
 	u32 reg, shift;
 
 	if (nv50_gpio_location(line, &reg, &shift))
 		return -EINVAL;
 
-	return !!(nv_rd32(dev, reg) & (4 << shift));
+	return !!(nv_rd32(gpio, reg) & (4 << shift));
 }
 
 void
-nv50_gpio_irq_enable(struct drm_device *dev, int line, bool on)
+nv50_gpio_irq_enable(struct nouveau_gpio *gpio, int line, bool on)
 {
 	u32 reg  = line < 16 ? 0xe050 : 0xe070;
 	u32 mask = 0x00010001 << (line & 0xf);
 
-	nv_wr32(dev, reg + 4, mask);
-	nv_mask(dev, reg + 0, mask, on ? mask : 0);
+	nv_wr32(gpio, reg + 4, mask);
+	nv_mask(gpio, reg + 0, mask, on ? mask : 0);
 }
 
-int
-nvd0_gpio_drive(struct drm_device *dev, int line, int dir, int out)
-{
-	u32 data = ((dir ^ 1) << 13) | (out << 12);
-	nv_mask(dev, 0x00d610 + (line * 4), 0x00003000, data);
-	nv_mask(dev, 0x00d604, 0x00000001, 0x00000001); /* update? */
-	return 0;
-}
-
-int
-nvd0_gpio_sense(struct drm_device *dev, int line)
-{
-	return !!(nv_rd32(dev, 0x00d610 + (line * 4)) & 0x00004000);
-}
-
-static void
-nv50_gpio_isr(struct drm_device *dev)
+void
+nv50_gpio_intr(struct nouveau_subdev *subdev)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nv50_gpio_priv *priv = (void *)subdev;
 	u32 intr0, intr1 = 0;
 	u32 hi, lo;
 
-	intr0 = nv_rd32(dev, 0xe054) & nv_rd32(dev, 0xe050);
-	if (dev_priv->chipset >= 0x90)
-		intr1 = nv_rd32(dev, 0xe074) & nv_rd32(dev, 0xe070);
+	intr0 = nv_rd32(priv, 0xe054) & nv_rd32(priv, 0xe050);
+	if (nv_device(priv)->chipset >= 0x90)
+		intr1 = nv_rd32(priv, 0xe074) & nv_rd32(priv, 0xe070);
 
 	hi = (intr0 & 0x0000ffff) | (intr1 << 16);
 	lo = (intr0 >> 16) | (intr1 & 0xffff0000);
-	nouveau_gpio_isr(dev, 0, hi | lo);
+	priv->base.isr_run(&priv->base, 0, hi | lo);
 
-	nv_wr32(dev, 0xe054, intr0);
-	if (dev_priv->chipset >= 0x90)
-		nv_wr32(dev, 0xe074, intr1);
+	nv_wr32(priv, 0xe054, intr0);
+	if (nv_device(priv)->chipset >= 0x90)
+		nv_wr32(priv, 0xe074, intr1);
 }
 
-static struct dmi_system_id gpio_reset_ids[] = {
-	{
-		.ident = "Apple Macbook 10,1",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro10,1"),
-		}
-	},
-	{ }
-};
+static int
+nv50_gpio_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
+{
+	struct nv50_gpio_priv *priv;
+	int ret;
+
+	ret = nouveau_gpio_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	priv->base.reset = nv50_gpio_reset;
+	priv->base.drive = nv50_gpio_drive;
+	priv->base.sense = nv50_gpio_sense;
+	priv->base.irq_enable = nv50_gpio_irq_enable;
+	nv_subdev(priv)->intr = nv50_gpio_intr;
+	return 0;
+}
+
+void
+nv50_gpio_dtor(struct nouveau_object *object)
+{
+	struct nv50_gpio_priv *priv = (void *)object;
+	nouveau_gpio_destroy(&priv->base);
+}
 
 int
-nv50_gpio_init(struct drm_device *dev)
+nv50_gpio_init(struct nouveau_object *object)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
+	struct nv50_gpio_priv *priv = (void *)object;
+	int ret;
 
-	/* initialise gpios and routing to vbios defaults */
-	if (dmi_check_system(gpio_reset_ids))
-		nouveau_gpio_reset(dev);
+	ret = nouveau_gpio_init(&priv->base);
+	if (ret)
+		return ret;
 
 	/* disable, and ack any pending gpio interrupts */
-	nv_wr32(dev, 0xe050, 0x00000000);
-	nv_wr32(dev, 0xe054, 0xffffffff);
-	if (dev_priv->chipset >= 0x90) {
-		nv_wr32(dev, 0xe070, 0x00000000);
-		nv_wr32(dev, 0xe074, 0xffffffff);
+	nv_wr32(priv, 0xe050, 0x00000000);
+	nv_wr32(priv, 0xe054, 0xffffffff);
+	if (nv_device(priv)->chipset >= 0x90) {
+		nv_wr32(priv, 0xe070, 0x00000000);
+		nv_wr32(priv, 0xe074, 0xffffffff);
 	}
 
-	nouveau_irq_register(dev, 21, nv50_gpio_isr);
 	return 0;
 }
 
-void
-nv50_gpio_fini(struct drm_device *dev)
+int
+nv50_gpio_fini(struct nouveau_object *object, bool suspend)
 {
-	struct drm_nouveau_private *dev_priv = dev->dev_private;
-
-	nv_wr32(dev, 0xe050, 0x00000000);
-	if (dev_priv->chipset >= 0x90)
-		nv_wr32(dev, 0xe070, 0x00000000);
-	nouveau_irq_unregister(dev, 21);
+	struct nv50_gpio_priv *priv = (void *)object;
+	nv_wr32(priv, 0xe050, 0x00000000);
+	if (nv_device(priv)->chipset >= 0x90)
+		nv_wr32(priv, 0xe070, 0x00000000);
+	return nouveau_gpio_fini(&priv->base, suspend);
 }
+
+struct nouveau_oclass
+nv50_gpio_oclass = {
+	.handle = NV_SUBDEV(GPIO, 0x50),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nv50_gpio_ctor,
+		.dtor = nv50_gpio_dtor,
+		.init = nv50_gpio_init,
+		.fini = nv50_gpio_fini,
+	},
+};
diff --git a/drivers/gpu/drm/nouveau/core/subdev/gpio/nvd0.c b/drivers/gpu/drm/nouveau/core/subdev/gpio/nvd0.c
new file mode 100644
index 0000000..8d18fca
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/core/subdev/gpio/nvd0.c
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <subdev/gpio.h>
+
+struct nvd0_gpio_priv {
+	struct nouveau_gpio base;
+};
+
+static void
+nvd0_gpio_reset(struct nouveau_gpio *gpio)
+{
+	struct nouveau_bios *bios = nouveau_bios(gpio);
+	struct nvd0_gpio_priv *priv = (void *)gpio;
+	u16 entry;
+	u8 ver;
+	int ent = -1;
+
+	while ((entry = dcb_gpio_entry(bios, 0, ++ent, &ver))) {
+		u32 data = nv_ro32(bios, entry);
+		u8  line =   (data & 0x0000003f);
+		u8  defs = !!(data & 0x00000080);
+		u8  func =   (data & 0x0000ff00) >> 8;
+		u8  unk0 =   (data & 0x00ff0000) >> 16;
+		u8  unk1 =   (data & 0x1f000000) >> 24;
+
+		if (func == 0xff)
+			continue;
+
+		gpio->set(gpio, 0, func, line, defs);
+
+		nv_mask(priv, 0x00d610 + (line * 4), 0xff, unk0);
+		if (unk1--)
+			nv_mask(priv, 0x00d740 + (unk1 * 4), 0xff, line);
+	}
+}
+
+static int
+nvd0_gpio_drive(struct nouveau_gpio *gpio, int line, int dir, int out)
+{
+	u32 data = ((dir ^ 1) << 13) | (out << 12);
+	nv_mask(gpio, 0x00d610 + (line * 4), 0x00003000, data);
+	nv_mask(gpio, 0x00d604, 0x00000001, 0x00000001); /* update? */
+	return 0;
+}
+
+static int
+nvd0_gpio_sense(struct nouveau_gpio *gpio, int line)
+{
+	return !!(nv_rd32(gpio, 0x00d610 + (line * 4)) & 0x00004000);
+}
+
+static int
+nvd0_gpio_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
+{
+	struct nvd0_gpio_priv *priv;
+	int ret;
+
+	ret = nouveau_gpio_create(parent, engine, oclass, &priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	priv->base.reset = nvd0_gpio_reset;
+	priv->base.drive = nvd0_gpio_drive;
+	priv->base.sense = nvd0_gpio_sense;
+	priv->base.irq_enable = nv50_gpio_irq_enable;
+	nv_subdev(priv)->intr = nv50_gpio_intr;
+	return 0;
+}
+
+struct nouveau_oclass
+nvd0_gpio_oclass = {
+	.handle = NV_SUBDEV(GPIO, 0xd0),
+	.ofuncs = &(struct nouveau_ofuncs) {
+		.ctor = nvd0_gpio_ctor,
+		.dtor = nv50_gpio_dtor,
+		.init = nv50_gpio_init,
+		.fini = nv50_gpio_fini,
+	},
+};
diff --git a/drivers/gpu/drm/nouveau/core/subdev/i2c/base.c b/drivers/gpu/drm/nouveau/core/subdev/i2c/base.c
index 71e9361..740e399 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/i2c/base.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/i2c/base.c
@@ -118,7 +118,7 @@ static const uint32_t nv50_i2c_port[] = {
 static u8 *
 i2c_table(struct drm_device *dev, u8 *version)
 {
-	u8 *dcb = dcb_table(dev), *i2c = NULL;
+	u8 *dcb = olddcb_table(dev), *i2c = NULL;
 	if (dcb) {
 		if (dcb[0] >= 0x15)
 			i2c = ROMPTR(dev, dcb[2]);
diff --git a/drivers/gpu/drm/nouveau/nouveau_bios.c b/drivers/gpu/drm/nouveau/nouveau_bios.c
index f869853..4f0d9bd 100644
--- a/drivers/gpu/drm/nouveau/nouveau_bios.c
+++ b/drivers/gpu/drm/nouveau/nouveau_bios.c
@@ -27,7 +27,6 @@
 #include "nouveau_drv.h"
 #include "nouveau_hw.h"
 #include "nouveau_encoder.h"
-#include <subdev/gpio.h>
 
 #include <linux/io-mapping.h>
 #include <linux/firmware.h>
@@ -5384,7 +5383,7 @@ static uint16_t findstr(uint8_t *data, int n, const uint8_t *str, int len)
 }
 
 void *
-dcb_table(struct drm_device *dev)
+olddcb_table(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	u8 *dcb = NULL;
@@ -5438,9 +5437,9 @@ dcb_table(struct drm_device *dev)
 }
 
 void *
-dcb_outp(struct drm_device *dev, u8 idx)
+olddcb_outp(struct drm_device *dev, u8 idx)
 {
-	u8 *dcb = dcb_table(dev);
+	u8 *dcb = olddcb_table(dev);
 	if (dcb && dcb[0] >= 0x30) {
 		if (idx < dcb[2])
 			return dcb + dcb[1] + (idx * dcb[3]);
@@ -5462,12 +5461,12 @@ dcb_outp(struct drm_device *dev, u8 idx)
 }
 
 int
-dcb_outp_foreach(struct drm_device *dev, void *data,
+olddcb_outp_foreach(struct drm_device *dev, void *data,
 		 int (*exec)(struct drm_device *, void *, int idx, u8 *outp))
 {
 	int ret, idx = -1;
 	u8 *outp = NULL;
-	while ((outp = dcb_outp(dev, ++idx))) {
+	while ((outp = olddcb_outp(dev, ++idx))) {
 		if (ROM32(outp[0]) == 0x00000000)
 			break; /* seen on an NV11 with DCB v1.5 */
 		if (ROM32(outp[0]) == 0xffffffff)
@@ -5489,7 +5488,7 @@ dcb_outp_foreach(struct drm_device *dev, void *data,
 u8 *
 dcb_conntab(struct drm_device *dev)
 {
-	u8 *dcb = dcb_table(dev);
+	u8 *dcb = olddcb_table(dev);
 	if (dcb && dcb[0] >= 0x30 && dcb[1] >= 0x16) {
 		u8 *conntab = ROMPTR(dev, dcb[0x14]);
 		if (conntab && conntab[0] >= 0x30 && conntab[0] <= 0x40)
@@ -5982,7 +5981,7 @@ parse_dcb_table(struct drm_device *dev, struct nvbios *bios)
 	u8 *dcbt, *conn;
 	int idx;
 
-	dcbt = dcb_table(dev);
+	dcbt = olddcb_table(dev);
 	if (!dcbt) {
 		/* handle pre-DCB boards */
 		if (bios->type == NVBIOS_BMP) {
@@ -5996,7 +5995,7 @@ parse_dcb_table(struct drm_device *dev, struct nvbios *bios)
 	NV_TRACE(dev, "DCB version %d.%d\n", dcbt[0] >> 4, dcbt[0] & 0xf);
 
 	dcb->version = dcbt[0];
-	dcb_outp_foreach(dev, NULL, parse_dcb_entry);
+	olddcb_outp_foreach(dev, NULL, parse_dcb_entry);
 
 	/*
 	 * apart for v2.1+ not being known for requiring merging, this
diff --git a/drivers/gpu/drm/nouveau/nouveau_bios.h b/drivers/gpu/drm/nouveau/nouveau_bios.h
index b42aa31..b4529a0 100644
--- a/drivers/gpu/drm/nouveau/nouveau_bios.h
+++ b/drivers/gpu/drm/nouveau/nouveau_bios.h
@@ -53,15 +53,6 @@ struct bit_entry {
 
 int bit_table(struct drm_device *, u8 id, struct bit_entry *);
 
-enum dcb_gpio_tag {
-	DCB_GPIO_PANEL_POWER = 0x01,
-	DCB_GPIO_TVDAC0 = 0x0c,
-	DCB_GPIO_TVDAC1 = 0x2d,
-	DCB_GPIO_PWM_FAN = 0x09,
-	DCB_GPIO_FAN_SENSE = 0x3d,
-	DCB_GPIO_UNUSED = 0xff
-};
-
 enum dcb_connector_type {
 	DCB_CONNECTOR_VGA = 0x00,
 	DCB_CONNECTOR_TV_0 = 0x10,
@@ -302,9 +293,9 @@ struct nvbios {
 	} legacy;
 };
 
-void *dcb_table(struct drm_device *);
-void *dcb_outp(struct drm_device *, u8 idx);
-int dcb_outp_foreach(struct drm_device *, void *data,
+void *olddcb_table(struct drm_device *);
+void *olddcb_outp(struct drm_device *, u8 idx);
+int olddcb_outp_foreach(struct drm_device *, void *data,
 		     int (*)(struct drm_device *, void *, int idx, u8 *outp));
 u8 *dcb_conntab(struct drm_device *);
 u8 *dcb_conn(struct drm_device *, u8 idx);
diff --git a/drivers/gpu/drm/nouveau/nouveau_compat.c b/drivers/gpu/drm/nouveau/nouveau_compat.c
index ca871d6..81fc849 100644
--- a/drivers/gpu/drm/nouveau/nouveau_compat.c
+++ b/drivers/gpu/drm/nouveau/nouveau_compat.c
@@ -2,6 +2,7 @@
 #include "nouveau_compat.h"
 
 #include <subdev/bios.h>
+#include <subdev/gpio.h>
 
 void *nouveau_newpriv(struct drm_device *);
 
@@ -50,3 +51,82 @@ _nv_bios(struct drm_device *dev, u8 **data, u32 *size)
 	*size = bios->size;
 	return true;
 }
+
+void
+nouveau_gpio_reset(struct drm_device *dev)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_gpio *gpio = nouveau_gpio(drm->device);
+	gpio->reset(gpio);
+}
+
+int
+nouveau_gpio_find(struct drm_device *dev, int idx, u8 tag, u8 line,
+		  struct dcb_gpio_func *func)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_gpio *gpio = nouveau_gpio(drm->device);
+
+	return gpio->find(gpio, idx, tag, line, func);
+}
+
+bool
+nouveau_gpio_func_valid(struct drm_device *dev, u8 tag)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_gpio *gpio = nouveau_gpio(drm->device);
+	struct dcb_gpio_func func;
+
+	return gpio->find(gpio, 0, tag, 0xff, &func) == 0;
+}
+
+int
+nouveau_gpio_func_set(struct drm_device *dev, u8 tag, int state)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_gpio *gpio = nouveau_gpio(drm->device);
+	if (gpio && gpio->get)
+		return gpio->set(gpio, 0, tag, 0xff, state);
+	return -ENODEV;
+}
+
+int
+nouveau_gpio_func_get(struct drm_device *dev, u8 tag)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_gpio *gpio = nouveau_gpio(drm->device);
+	if (gpio && gpio->get)
+		return gpio->get(gpio, 0, tag, 0xff);
+	return -ENODEV;
+}
+
+int
+nouveau_gpio_irq(struct drm_device *dev, int idx, u8 tag, u8 line, bool on)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_gpio *gpio = nouveau_gpio(drm->device);
+	if (gpio && gpio->irq)
+		return gpio->irq(gpio, idx, tag, line, on);
+	return -ENODEV;
+}
+
+int
+nouveau_gpio_isr_add(struct drm_device *dev, int idx, u8 tag, u8 line,
+		     void (*exec)(void *, int state), void *data)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_gpio *gpio = nouveau_gpio(drm->device);
+	if (gpio && gpio->isr_add)
+		return gpio->isr_add(gpio, idx, tag, line, exec, data);
+	return -ENODEV;
+}
+
+void
+nouveau_gpio_isr_del(struct drm_device *dev, int idx, u8 tag, u8 line,
+		     void (*exec)(void *, int state), void *data)
+{
+	struct nouveau_drm *drm = nouveau_newpriv(dev);
+	struct nouveau_gpio *gpio = nouveau_gpio(drm->device);
+	if (gpio && gpio->isr_del)
+		gpio->isr_del(gpio, idx, tag, line, exec, data);
+}
diff --git a/drivers/gpu/drm/nouveau/nouveau_compat.h b/drivers/gpu/drm/nouveau/nouveau_compat.h
index d1ce3bc..f1143c3 100644
--- a/drivers/gpu/drm/nouveau/nouveau_compat.h
+++ b/drivers/gpu/drm/nouveau/nouveau_compat.h
@@ -9,4 +9,15 @@ u32  _nv_mask(struct drm_device *, u32, u32, u32);
 
 bool _nv_bios(struct drm_device *, u8 **, u32 *);
 
+struct dcb_gpio_func;
+void nouveau_gpio_reset(struct drm_device *);
+int  nouveau_gpio_find(struct drm_device *, int, u8, u8, struct dcb_gpio_func *);
+bool nouveau_gpio_func_valid(struct drm_device *, u8 tag);
+int  nouveau_gpio_func_set(struct drm_device *, u8 tag, int state);
+int  nouveau_gpio_func_get(struct drm_device *, u8 tag);
+int  nouveau_gpio_irq(struct drm_device *, int idx, u8 tag, u8 line, bool on);
+int  nouveau_gpio_isr_add(struct drm_device *, int idx, u8 tag, u8 line,
+			  void (*)(void *, int state), void *data);
+void nouveau_gpio_isr_del(struct drm_device *, int idx, u8 tag, u8 line,
+			  void (*)(void *, int state), void *data);
 #endif
diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.c b/drivers/gpu/drm/nouveau/nouveau_connector.c
index d6eabd9..cbf8348 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.c
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.c
@@ -35,9 +35,10 @@
 #include "nouveau_encoder.h"
 #include "nouveau_crtc.h"
 #include "nouveau_connector.h"
-#include <subdev/gpio.h>
 #include "nouveau_hw.h"
 
+#include <subdev/bios/gpio.h>
+
 static void nouveau_connector_hotplug(void *, int);
 
 struct nouveau_encoder *
diff --git a/drivers/gpu/drm/nouveau/nouveau_display.c b/drivers/gpu/drm/nouveau/nouveau_display.c
index d6051e0..44835c4 100644
--- a/drivers/gpu/drm/nouveau/nouveau_display.c
+++ b/drivers/gpu/drm/nouveau/nouveau_display.c
@@ -34,10 +34,11 @@
 #include "nouveau_dma.h"
 #include "nouveau_connector.h"
 #include "nouveau_software.h"
-#include <subdev/gpio.h>
 #include "nouveau_fence.h"
 #include "nv50_display.h"
 
+#include <subdev/bios/gpio.h>
+
 static void
 nouveau_user_framebuffer_destroy(struct drm_framebuffer *drm_fb)
 {
diff --git a/drivers/gpu/drm/nouveau/nouveau_dp.c b/drivers/gpu/drm/nouveau/nouveau_dp.c
index 67b3225..63c0e82 100644
--- a/drivers/gpu/drm/nouveau/nouveau_dp.c
+++ b/drivers/gpu/drm/nouveau/nouveau_dp.c
@@ -29,7 +29,6 @@
 #include "nouveau_connector.h"
 #include "nouveau_encoder.h"
 #include "nouveau_crtc.h"
-#include <subdev/gpio.h>
 
 /******************************************************************************
  * aux channel util functions
diff --git a/drivers/gpu/drm/nouveau/nouveau_drv.h b/drivers/gpu/drm/nouveau/nouveau_drv.h
index 581a950..afe9787 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ b/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -366,16 +366,6 @@ struct nouveau_display_engine {
 	struct drm_property *color_vibrance_property;
 };
 
-struct nouveau_gpio_engine {
-	spinlock_t lock;
-	struct list_head isr;
-	int (*init)(struct drm_device *);
-	void (*fini)(struct drm_device *);
-	int (*drive)(struct drm_device *, int line, int dir, int out);
-	int (*sense)(struct drm_device *, int line);
-	void (*irq_enable)(struct drm_device *, int line, bool);
-};
-
 struct nouveau_pm_voltage_level {
 	u32 voltage; /* microvolts */
 	u8  vid;
@@ -555,7 +545,6 @@ struct nouveau_engine {
 	struct nouveau_timer_engine   timer;
 	struct nouveau_fb_engine      fb;
 	struct nouveau_display_engine display;
-	struct nouveau_gpio_engine    gpio;
 	struct nouveau_pm_engine      pm;
 	struct nouveau_vram_engine    vram;
 };
@@ -1376,22 +1365,6 @@ int nouveau_display_dumb_map_offset(struct drm_file *, struct drm_device *,
 int nouveau_display_dumb_destroy(struct drm_file *, struct drm_device *,
 				 uint32_t handle);
 
-/* nv10_gpio.c */
-int nv10_gpio_init(struct drm_device *dev);
-void nv10_gpio_fini(struct drm_device *dev);
-int nv10_gpio_drive(struct drm_device *dev, int line, int dir, int out);
-int nv10_gpio_sense(struct drm_device *dev, int line);
-void nv10_gpio_irq_enable(struct drm_device *, int line, bool on);
-
-/* nv50_gpio.c */
-int nv50_gpio_init(struct drm_device *dev);
-void nv50_gpio_fini(struct drm_device *dev);
-int nv50_gpio_drive(struct drm_device *dev, int line, int dir, int out);
-int nv50_gpio_sense(struct drm_device *dev, int line);
-void nv50_gpio_irq_enable(struct drm_device *, int line, bool on);
-int nvd0_gpio_drive(struct drm_device *dev, int line, int dir, int out);
-int nvd0_gpio_sense(struct drm_device *dev, int line);
-
 /* nv50_calc.c */
 int nv50_calc_pll(struct drm_device *, struct pll_lims *, int clk,
 		  int *N1, int *M1, int *N2, int *M2, int *P);
diff --git a/drivers/gpu/drm/nouveau/nouveau_mxm.c b/drivers/gpu/drm/nouveau/nouveau_mxm.c
index 07d0d1e..b2b326b 100644
--- a/drivers/gpu/drm/nouveau/nouveau_mxm.c
+++ b/drivers/gpu/drm/nouveau/nouveau_mxm.c
@@ -460,13 +460,13 @@ mxm_show_unmatched(struct drm_device *dev, u8 *data, void *info)
 static void
 mxm_dcb_sanitise(struct drm_device *dev)
 {
-	u8 *dcb = dcb_table(dev);
+	u8 *dcb = olddcb_table(dev);
 	if (!dcb || dcb[0] != 0x40) {
 		MXM_DBG(dev, "unsupported DCB version\n");
 		return;
 	}
 
-	dcb_outp_foreach(dev, NULL, mxm_dcb_sanitise_entry);
+	olddcb_outp_foreach(dev, NULL, mxm_dcb_sanitise_entry);
 	mxms_foreach(dev, 0x01, mxm_show_unmatched, NULL);
 }
 
diff --git a/drivers/gpu/drm/nouveau/nouveau_pm.c b/drivers/gpu/drm/nouveau/nouveau_pm.c
index dc34664..fd74cbf 100644
--- a/drivers/gpu/drm/nouveau/nouveau_pm.c
+++ b/drivers/gpu/drm/nouveau/nouveau_pm.c
@@ -26,7 +26,7 @@
 
 #include "nouveau_drv.h"
 #include "nouveau_pm.h"
-#include <subdev/gpio.h>
+#include <subdev/bios/gpio.h>
 
 #ifdef CONFIG_ACPI
 #include <linux/acpi.h>
@@ -40,7 +40,7 @@ nouveau_pwmfan_get(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_pm_engine *pm = &dev_priv->engine.pm;
-	struct gpio_func gpio;
+	struct dcb_gpio_func gpio;
 	u32 divs, duty;
 	int ret;
 
@@ -68,7 +68,7 @@ nouveau_pwmfan_set(struct drm_device *dev, int percent)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_pm_engine *pm = &dev_priv->engine.pm;
-	struct gpio_func gpio;
+	struct dcb_gpio_func gpio;
 	u32 divs, duty;
 	int ret;
 
@@ -555,24 +555,21 @@ nouveau_hwmon_show_fan0_input(struct device *d, struct device_attribute *attr,
 	struct drm_device *dev = dev_get_drvdata(d);
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_timer_engine *ptimer = &dev_priv->engine.timer;
-	struct gpio_func gpio;
 	u32 cycles, cur, prev;
 	u64 start;
-	int ret;
 
-	ret = nouveau_gpio_find(dev, 0, DCB_GPIO_FAN_SENSE, 0xff, &gpio);
-	if (ret)
-		return ret;
+	if (!nouveau_gpio_func_valid(dev, DCB_GPIO_FAN_SENSE))
+		return -ENODEV;
 
 	/* Monitor the GPIO input 0x3b for 250ms.
 	 * When the fan spins, it changes the value of GPIO FAN_SENSE.
 	 * We get 4 changes (0 -> 1 -> 0 -> 1 -> [...]) per complete rotation.
 	 */
 	start = ptimer->read(dev);
-	prev = nouveau_gpio_sense(dev, 0, gpio.line);
+	prev = nouveau_gpio_func_get(dev, DCB_GPIO_FAN_SENSE);
 	cycles = 0;
 	do {
-		cur = nouveau_gpio_sense(dev, 0, gpio.line);
+		cur = nouveau_gpio_func_get(dev, DCB_GPIO_FAN_SENSE);
 		if (prev != cur) {
 			cycles++;
 			prev = cur;
diff --git a/drivers/gpu/drm/nouveau/nouveau_state.c b/drivers/gpu/drm/nouveau/nouveau_state.c
index 85cb5f9..84e0379 100644
--- a/drivers/gpu/drm/nouveau/nouveau_state.c
+++ b/drivers/gpu/drm/nouveau/nouveau_state.c
@@ -37,7 +37,6 @@
 #include "nouveau_agp.h"
 #include "nouveau_fbcon.h"
 #include <core/ramht.h>
-#include <subdev/gpio.h>
 #include "nouveau_pm.h"
 #include "nv50_display.h"
 #include <engine/fifo.h>
@@ -109,8 +108,6 @@ static int nouveau_init_engine_ptrs(struct drm_device *dev)
 		engine->display.destroy		= nv04_display_destroy;
 		engine->display.init		= nv04_display_init;
 		engine->display.fini		= nv04_display_fini;
-		engine->gpio.drive		= nv10_gpio_drive;
-		engine->gpio.sense		= nv10_gpio_sense;
 		engine->pm.clocks_get		= nv04_pm_clocks_get;
 		engine->pm.clocks_pre		= nv04_pm_clocks_pre;
 		engine->pm.clocks_set		= nv04_pm_clocks_set;
@@ -148,8 +145,6 @@ static int nouveau_init_engine_ptrs(struct drm_device *dev)
 		engine->display.destroy		= nv04_display_destroy;
 		engine->display.init		= nv04_display_init;
 		engine->display.fini		= nv04_display_fini;
-		engine->gpio.drive		= nv10_gpio_drive;
-		engine->gpio.sense		= nv10_gpio_sense;
 		engine->pm.clocks_get		= nv04_pm_clocks_get;
 		engine->pm.clocks_pre		= nv04_pm_clocks_pre;
 		engine->pm.clocks_set		= nv04_pm_clocks_set;
@@ -183,8 +178,6 @@ static int nouveau_init_engine_ptrs(struct drm_device *dev)
 		engine->display.destroy		= nv04_display_destroy;
 		engine->display.init		= nv04_display_init;
 		engine->display.fini		= nv04_display_fini;
-		engine->gpio.drive		= nv10_gpio_drive;
-		engine->gpio.sense		= nv10_gpio_sense;
 		engine->pm.clocks_get		= nv04_pm_clocks_get;
 		engine->pm.clocks_pre		= nv04_pm_clocks_pre;
 		engine->pm.clocks_set		= nv04_pm_clocks_set;
@@ -221,11 +214,6 @@ static int nouveau_init_engine_ptrs(struct drm_device *dev)
 		engine->display.destroy		= nv04_display_destroy;
 		engine->display.init		= nv04_display_init;
 		engine->display.fini		= nv04_display_fini;
-		engine->gpio.init		= nv10_gpio_init;
-		engine->gpio.fini		= nv10_gpio_fini;
-		engine->gpio.drive		= nv10_gpio_drive;
-		engine->gpio.sense		= nv10_gpio_sense;
-		engine->gpio.irq_enable		= nv10_gpio_irq_enable;
 		engine->pm.clocks_get		= nv40_pm_clocks_get;
 		engine->pm.clocks_pre		= nv40_pm_clocks_pre;
 		engine->pm.clocks_set		= nv40_pm_clocks_set;
@@ -267,11 +255,6 @@ static int nouveau_init_engine_ptrs(struct drm_device *dev)
 		engine->display.destroy		= nv50_display_destroy;
 		engine->display.init		= nv50_display_init;
 		engine->display.fini		= nv50_display_fini;
-		engine->gpio.init		= nv50_gpio_init;
-		engine->gpio.fini		= nv50_gpio_fini;
-		engine->gpio.drive		= nv50_gpio_drive;
-		engine->gpio.sense		= nv50_gpio_sense;
-		engine->gpio.irq_enable		= nv50_gpio_irq_enable;
 		switch (dev_priv->chipset) {
 		case 0x84:
 		case 0x86:
@@ -330,11 +313,6 @@ static int nouveau_init_engine_ptrs(struct drm_device *dev)
 		engine->display.destroy		= nv50_display_destroy;
 		engine->display.init		= nv50_display_init;
 		engine->display.fini		= nv50_display_fini;
-		engine->gpio.init		= nv50_gpio_init;
-		engine->gpio.fini		= nv50_gpio_fini;
-		engine->gpio.drive		= nv50_gpio_drive;
-		engine->gpio.sense		= nv50_gpio_sense;
-		engine->gpio.irq_enable		= nv50_gpio_irq_enable;
 		engine->vram.init		= nvc0_vram_init;
 		engine->vram.takedown		= nv50_vram_fini;
 		engine->vram.get		= nvc0_vram_new;
@@ -372,11 +350,6 @@ static int nouveau_init_engine_ptrs(struct drm_device *dev)
 		engine->display.destroy		= nvd0_display_destroy;
 		engine->display.init		= nvd0_display_init;
 		engine->display.fini		= nvd0_display_fini;
-		engine->gpio.init		= nv50_gpio_init;
-		engine->gpio.fini		= nv50_gpio_fini;
-		engine->gpio.drive		= nvd0_gpio_drive;
-		engine->gpio.sense		= nvd0_gpio_sense;
-		engine->gpio.irq_enable		= nv50_gpio_irq_enable;
 		engine->vram.init		= nvc0_vram_init;
 		engine->vram.takedown		= nv50_vram_fini;
 		engine->vram.get		= nvc0_vram_new;
@@ -412,11 +385,6 @@ static int nouveau_init_engine_ptrs(struct drm_device *dev)
 		engine->display.destroy		= nvd0_display_destroy;
 		engine->display.init		= nvd0_display_init;
 		engine->display.fini		= nvd0_display_fini;
-		engine->gpio.init		= nv50_gpio_init;
-		engine->gpio.fini		= nv50_gpio_fini;
-		engine->gpio.drive		= nvd0_gpio_drive;
-		engine->gpio.sense		= nvd0_gpio_sense;
-		engine->gpio.irq_enable		= nv50_gpio_irq_enable;
 		engine->vram.init		= nvc0_vram_init;
 		engine->vram.takedown		= nv50_vram_fini;
 		engine->vram.get		= nvc0_vram_new;
@@ -588,14 +556,9 @@ nouveau_card_init(struct drm_device *dev)
 	if (ret)
 		goto out_fb;
 
-	/* PGPIO */
-	ret = nouveau_gpio_create(dev);
-	if (ret)
-		goto out_vram;
-
 	ret = nouveau_gpuobj_init(dev);
 	if (ret)
-		goto out_gpio;
+		goto out_vram;
 
 	ret = engine->instmem.init(dev);
 	if (ret)
@@ -830,8 +793,6 @@ out_instmem:
 	engine->instmem.takedown(dev);
 out_gpuobj:
 	nouveau_gpuobj_takedown(dev);
-out_gpio:
-	nouveau_gpio_destroy(dev);
 out_vram:
 	engine->vram.takedown(dev);
 out_fb:
@@ -890,7 +851,6 @@ static void nouveau_card_takedown(struct drm_device *dev)
 	engine->instmem.takedown(dev);
 	nouveau_gpuobj_takedown(dev);
 
-	nouveau_gpio_destroy(dev);
 	engine->vram.takedown(dev);
 	engine->fb.takedown(dev);
 	engine->timer.takedown(dev);
diff --git a/drivers/gpu/drm/nouveau/nouveau_volt.c b/drivers/gpu/drm/nouveau/nouveau_volt.c
index 9e34b57..da3222c 100644
--- a/drivers/gpu/drm/nouveau/nouveau_volt.c
+++ b/drivers/gpu/drm/nouveau/nouveau_volt.c
@@ -26,9 +26,10 @@
 
 #include "nouveau_drv.h"
 #include "nouveau_pm.h"
-#include <subdev/gpio.h>
 
-static const enum dcb_gpio_tag vidtag[] = { 0x04, 0x05, 0x06, 0x1a, 0x73 };
+#include <subdev/bios/gpio.h>
+
+static const enum dcb_gpio_func_name vidtag[] = { 0x04, 0x05, 0x06, 0x1a, 0x73 };
 static int nr_vidtag = sizeof(vidtag) / sizeof(vidtag[0]);
 
 int
diff --git a/drivers/gpu/drm/nouveau/nv04_dac.c b/drivers/gpu/drm/nouveau/nv04_dac.c
index da091a1..54deb27 100644
--- a/drivers/gpu/drm/nouveau/nv04_dac.c
+++ b/drivers/gpu/drm/nouveau/nv04_dac.c
@@ -32,9 +32,10 @@
 #include "nouveau_connector.h"
 #include "nouveau_crtc.h"
 #include "nouveau_hw.h"
-#include <subdev/gpio.h>
 #include "nvreg.h"
 
+#include <subdev/bios/gpio.h>
+
 int nv04_dac_output_offset(struct drm_encoder *encoder)
 {
 	struct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;
diff --git a/drivers/gpu/drm/nouveau/nv17_tv.c b/drivers/gpu/drm/nouveau/nv17_tv.c
index 65f7c45..a66a348 100644
--- a/drivers/gpu/drm/nouveau/nv17_tv.c
+++ b/drivers/gpu/drm/nouveau/nv17_tv.c
@@ -30,10 +30,11 @@
 #include "nouveau_encoder.h"
 #include "nouveau_connector.h"
 #include "nouveau_crtc.h"
-#include <subdev/gpio.h>
 #include "nouveau_hw.h"
 #include "nv17_tv.h"
 
+#include <subdev/bios/gpio.h>
+
 static uint32_t nv42_tv_sample_load(struct drm_encoder *encoder)
 {
 	struct drm_device *dev = encoder->dev;

