From 851a6bd99edda0094def3b0b81bb1c7c0e886e65 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Christian=20K=C3=B6nig?= <deathsimple@vodafone.de>
Date: Mon, 24 Oct 2011 15:05:29 +0200
Subject: drm/radeon: fix a spelling mistake
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 851a6bd99edda0094def3b0b81bb1c7c0e886e65
Patch-mainline: v3.3-rc1

Better fix it before this obvious typo spreads even more.

Signed-off-by: Christian KÃ¶nig <deathsimple@vodafone.de>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Reviewed-by: Jerome Glisse <jglisse@redhat.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---
 drivers/gpu/drm/radeon/radeon.h       |    4 +-
 drivers/gpu/drm/radeon/radeon_fence.c |   34 ++++++++++++++++----------------
 drivers/gpu/drm/radeon/radeon_pm.c    |    4 +-
 drivers/gpu/drm/radeon/radeon_ring.c  |    2 +-
 4 files changed, 22 insertions(+), 22 deletions(-)

diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h
index 5993614..33f3be3 100644
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
@@ -199,7 +199,7 @@ struct radeon_fence_driver {
 	wait_queue_head_t		queue;
 	rwlock_t			lock;
 	struct list_head		created;
-	struct list_head		emited;
+	struct list_head		emitted;
 	struct list_head		signaled;
 	bool				initialized;
 };
@@ -210,7 +210,7 @@ struct radeon_fence {
 	struct list_head		list;
 	/* protected by radeon_fence.lock */
 	uint32_t			seq;
-	bool				emited;
+	bool				emitted;
 	bool				signaled;
 };
 
diff --git a/drivers/gpu/drm/radeon/radeon_fence.c b/drivers/gpu/drm/radeon/radeon_fence.c
index 76ec0e9..7027766e 100644
--- a/drivers/gpu/drm/radeon/radeon_fence.c
+++ b/drivers/gpu/drm/radeon/radeon_fence.c
@@ -74,7 +74,7 @@ int radeon_fence_emit(struct radeon_device *rdev, struct radeon_fence *fence)
 	unsigned long irq_flags;
 
 	write_lock_irqsave(&rdev->fence_drv.lock, irq_flags);
-	if (fence->emited) {
+	if (fence->emitted) {
 		write_unlock_irqrestore(&rdev->fence_drv.lock, irq_flags);
 		return 0;
 	}
@@ -88,8 +88,8 @@ int radeon_fence_emit(struct radeon_device *rdev, struct radeon_fence *fence)
 		radeon_fence_ring_emit(rdev, fence);
 
 	trace_radeon_fence_emit(rdev->ddev, fence->seq);
-	fence->emited = true;
-	list_move_tail(&fence->list, &rdev->fence_drv.emited);
+	fence->emitted = true;
+	list_move_tail(&fence->list, &rdev->fence_drv.emitted);
 	write_unlock_irqrestore(&rdev->fence_drv.lock, irq_flags);
 	return 0;
 }
@@ -129,7 +129,7 @@ static bool radeon_fence_poll_locked(struct radeon_device *rdev)
 		return false;
 	}
 	n = NULL;
-	list_for_each(i, &rdev->fence_drv.emited) {
+	list_for_each(i, &rdev->fence_drv.emitted) {
 		fence = list_entry(i, struct radeon_fence, list);
 		if (fence->seq == seq) {
 			n = i;
@@ -145,7 +145,7 @@ static bool radeon_fence_poll_locked(struct radeon_device *rdev)
 			fence = list_entry(i, struct radeon_fence, list);
 			fence->signaled = true;
 			i = n;
-		} while (i != &rdev->fence_drv.emited);
+		} while (i != &rdev->fence_drv.emitted);
 		wake = true;
 	}
 	return wake;
@@ -159,7 +159,7 @@ static void radeon_fence_destroy(struct kref *kref)
 	fence = container_of(kref, struct radeon_fence, kref);
 	write_lock_irqsave(&fence->rdev->fence_drv.lock, irq_flags);
 	list_del(&fence->list);
-	fence->emited = false;
+	fence->emitted = false;
 	write_unlock_irqrestore(&fence->rdev->fence_drv.lock, irq_flags);
 	kfree(fence);
 }
@@ -174,7 +174,7 @@ int radeon_fence_create(struct radeon_device *rdev, struct radeon_fence **fence)
 	}
 	kref_init(&((*fence)->kref));
 	(*fence)->rdev = rdev;
-	(*fence)->emited = false;
+	(*fence)->emitted = false;
 	(*fence)->signaled = false;
 	(*fence)->seq = 0;
 	INIT_LIST_HEAD(&(*fence)->list);
@@ -203,8 +203,8 @@ bool radeon_fence_signaled(struct radeon_fence *fence)
 	if (fence->rdev->shutdown) {
 		signaled = true;
 	}
-	if (!fence->emited) {
-		WARN(1, "Querying an unemited fence : %p !\n", fence);
+	if (!fence->emitted) {
+		WARN(1, "Querying an unemitted fence : %p !\n", fence);
 		signaled = true;
 	}
 	if (!signaled) {
@@ -295,11 +295,11 @@ int radeon_fence_wait_next(struct radeon_device *rdev)
 		return 0;
 	}
 	write_lock_irqsave(&rdev->fence_drv.lock, irq_flags);
-	if (list_empty(&rdev->fence_drv.emited)) {
+	if (list_empty(&rdev->fence_drv.emitted)) {
 		write_unlock_irqrestore(&rdev->fence_drv.lock, irq_flags);
 		return 0;
 	}
-	fence = list_entry(rdev->fence_drv.emited.next,
+	fence = list_entry(rdev->fence_drv.emitted.next,
 			   struct radeon_fence, list);
 	radeon_fence_ref(fence);
 	write_unlock_irqrestore(&rdev->fence_drv.lock, irq_flags);
@@ -318,11 +318,11 @@ int radeon_fence_wait_last(struct radeon_device *rdev)
 		return 0;
 	}
 	write_lock_irqsave(&rdev->fence_drv.lock, irq_flags);
-	if (list_empty(&rdev->fence_drv.emited)) {
+	if (list_empty(&rdev->fence_drv.emitted)) {
 		write_unlock_irqrestore(&rdev->fence_drv.lock, irq_flags);
 		return 0;
 	}
-	fence = list_entry(rdev->fence_drv.emited.prev,
+	fence = list_entry(rdev->fence_drv.emitted.prev,
 			   struct radeon_fence, list);
 	radeon_fence_ref(fence);
 	write_unlock_irqrestore(&rdev->fence_drv.lock, irq_flags);
@@ -375,7 +375,7 @@ int radeon_fence_driver_init(struct radeon_device *rdev)
 	radeon_fence_write(rdev, 0);
 	atomic_set(&rdev->fence_drv.seq, 0);
 	INIT_LIST_HEAD(&rdev->fence_drv.created);
-	INIT_LIST_HEAD(&rdev->fence_drv.emited);
+	INIT_LIST_HEAD(&rdev->fence_drv.emitted);
 	INIT_LIST_HEAD(&rdev->fence_drv.signaled);
 	init_waitqueue_head(&rdev->fence_drv.queue);
 	rdev->fence_drv.initialized = true;
@@ -413,10 +413,10 @@ static int radeon_debugfs_fence_info(struct seq_file *m, void *data)
 
 	seq_printf(m, "Last signaled fence 0x%08X\n",
 		   radeon_fence_read(rdev));
-	if (!list_empty(&rdev->fence_drv.emited)) {
-		   fence = list_entry(rdev->fence_drv.emited.prev,
+	if (!list_empty(&rdev->fence_drv.emitted)) {
+		   fence = list_entry(rdev->fence_drv.emitted.prev,
 				      struct radeon_fence, list);
-		   seq_printf(m, "Last emited fence %p with 0x%08X\n",
+		   seq_printf(m, "Last emitted fence %p with 0x%08X\n",
 			      fence,  fence->seq);
 	}
 	return 0;
diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index 78a665b..1fb8467 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
@@ -799,9 +799,9 @@ static void radeon_dynpm_idle_work_handler(struct work_struct *work)
 		int not_processed = 0;
 
 		read_lock_irqsave(&rdev->fence_drv.lock, irq_flags);
-		if (!list_empty(&rdev->fence_drv.emited)) {
+		if (!list_empty(&rdev->fence_drv.emitted)) {
 			struct list_head *ptr;
-			list_for_each(ptr, &rdev->fence_drv.emited) {
+			list_for_each(ptr, &rdev->fence_drv.emitted) {
 				/* count up to 3, that's enought info */
 				if (++not_processed >= 3)
 					break;
diff --git a/drivers/gpu/drm/radeon/radeon_ring.c b/drivers/gpu/drm/radeon/radeon_ring.c
index 49d5820..f3d7d22 100644
--- a/drivers/gpu/drm/radeon/radeon_ring.c
+++ b/drivers/gpu/drm/radeon/radeon_ring.c
@@ -169,7 +169,7 @@ void radeon_ib_free(struct radeon_device *rdev, struct radeon_ib **ib)
 	if (tmp == NULL) {
 		return;
 	}
-	if (!tmp->fence->emited)
+	if (!tmp->fence->emitted)
 		radeon_fence_unref(&tmp->fence);
 	mutex_lock(&rdev->ib_pool.mutex);
 	tmp->free = true;

