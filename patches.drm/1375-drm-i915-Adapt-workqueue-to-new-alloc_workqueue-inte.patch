From 7e6666190a419e6168f0c87ef5de415ec4aec518 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Thu, 9 Sep 2010 12:46:34 +0100
Patch-mainline: 2.6.37
References: fate#310916
Git-commit: e642abbf303741b245375b2e3f8f00e900d462dc
Subject: [PATCH 1375/2588] drm/i915: Adapt workqueue to new alloc_workqueue
 interface

create_singlethreaded_workqueue() is being phased out for a new
concurrency managed task infrastructure.

Adapt our workqueue constructor to explicitly create a domain that only
allows the execution of a single task at any time. All the tasks are
expected to require the dev->struct_mutex, so would block concurrency of
other tasks if we allow more than a single i915 task to be run at once.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit e642abbf303741b245375b2e3f8f00e900d462dc)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_dma.c |   17 ++++++++++++++++-
 1 files changed, 16 insertions(+), 1 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_dma.c b/drivers/gpu/drm/i915/i915_dma.c
index ddef396..7594035 100644
--- a/drivers/gpu/drm/i915/i915_dma.c
+++ b/drivers/gpu/drm/i915/i915_dma.c
@@ -1951,7 +1951,22 @@ int i915_driver_load(struct drm_device *dev, unsigned long flags)
 	prealloc_size = dev_priv->mm.gtt->gtt_stolen_entries << PAGE_SHIFT;
 	agp_size = dev_priv->mm.gtt->gtt_mappable_entries << PAGE_SHIFT;
 
-	dev_priv->wq = create_singlethread_workqueue("i915");
+	/* The i915 workqueue is primarily used for batched retirement of
+	 * requests (and thus managing bo) once the task has been completed
+	 * by the GPU. i915_gem_retire_requests() is called directly when we
+	 * need high-priority retirement, such as waiting for an explicit
+	 * bo.
+	 *
+	 * It is also used for periodic low-priority events, such as
+	 * idle-timers and hangcheck.
+	 *
+	 * All tasks on the workqueue are expected to acquire the dev mutex
+	 * so there is no point in running more than one instance of the
+	 * workqueue at any time: max_active = 1 and NON_REENTRANT.
+	 */
+	dev_priv->wq = alloc_workqueue("i915",
+				       WQ_UNBOUND | WQ_NON_REENTRANT,
+				       1);
 	if (dev_priv->wq == NULL) {
 		DRM_ERROR("Failed to create our workqueue.\n");
 		ret = -ENOMEM;
-- 
1.7.6

