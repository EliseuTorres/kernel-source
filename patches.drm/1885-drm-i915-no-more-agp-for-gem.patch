From a029be5f2909866c5e713f63d43740a3aeef0f6e Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Sat, 6 Nov 2010 12:12:35 +0100
Patch-mainline: 2.6.38
References: fate#310916
Git-commit: 185cbcb304ba4dee55e39593fd86dcd7813f62ec
Subject: [PATCH 1885/2588] drm/i915: no more agp for gem

Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit 185cbcb304ba4dee55e39593fd86dcd7813f62ec)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_drv.h     |    9 +++--
 drivers/gpu/drm/i915/i915_gem_gtt.c |   63 ++++++++++++++++++++++++----------
 2 files changed, 50 insertions(+), 22 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index b3bfab9..dc371d9 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -791,12 +791,15 @@ struct drm_i915_gem_object {
 	unsigned int fault_mappable : 1;
 	unsigned int pin_mappable : 1;
 
-	/** AGP memory structure for our GTT binding. */
-	DRM_AGP_MEM *agp_mem;
-
 	struct page **pages;
 
 	/**
+	 * DMAR support
+	 */
+	struct scatterlist *sg_list;
+	int num_sg;
+
+	/**
 	 * Current offset of the object in GTT space.
 	 *
 	 * This is the same as gtt_space->start
diff --git a/drivers/gpu/drm/i915/i915_gem_gtt.c b/drivers/gpu/drm/i915/i915_gem_gtt.c
index f78c15f..0b34a1a 100644
--- a/drivers/gpu/drm/i915/i915_gem_gtt.c
+++ b/drivers/gpu/drm/i915/i915_gem_gtt.c
@@ -33,15 +33,24 @@ void i915_gem_restore_gtt_mappings(struct drm_device *dev)
 {
 	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_i915_gem_object *obj_priv;
-	int ret;
 
 	list_for_each_entry(obj_priv,
 			    &dev_priv->mm.gtt_list,
 			    gtt_list) {
-		/* Hack to force agp to reinsert buffer object. */
-		obj_priv->agp_mem->is_bound = false;
-		ret = agp_bind_memory(obj_priv->agp_mem, obj_priv->gtt_space->start / PAGE_SIZE);
-		BUG_ON(ret != 0);
+		if (dev_priv->mm.gtt->needs_dmar) {
+			BUG_ON(!obj_priv->sg_list);
+
+			intel_gtt_insert_sg_entries(obj_priv->sg_list,
+						    obj_priv->num_sg,
+						    obj_priv->gtt_space->start
+							>> PAGE_SHIFT,
+						    obj_priv->agp_type);
+		} else
+			intel_gtt_insert_pages(obj_priv->gtt_space->start
+						   >> PAGE_SHIFT,
+					       obj_priv->base.size >> PAGE_SHIFT,
+					       obj_priv->pages,
+					       obj_priv->agp_type);
 	}
 
 	/* Be paranoid and flush the chipset cache. */
@@ -51,27 +60,43 @@ void i915_gem_restore_gtt_mappings(struct drm_device *dev)
 int i915_gem_gtt_bind_object(struct drm_gem_object *obj)
 {
 	struct drm_device *dev = obj->dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_i915_gem_object *obj_priv = to_intel_bo(obj);
+	int ret;
 
-	/* Create an AGP memory structure pointing at our pages, and bind it
-	 * into the GTT.
-	 */
-	obj_priv->agp_mem = drm_agp_bind_pages(dev,
-					       obj_priv->pages,
-					       obj->size >> PAGE_SHIFT,
-					       obj_priv->gtt_space->start,
-					       obj_priv->agp_type);
+	if (dev_priv->mm.gtt->needs_dmar) {
+		ret = intel_gtt_map_memory(obj_priv->pages,
+					   obj->size >> PAGE_SHIFT,
+					   &obj_priv->sg_list,
+					   &obj_priv->num_sg);
+		if (ret != 0)
+			return ret;
+
+		intel_gtt_insert_sg_entries(obj_priv->sg_list, obj_priv->num_sg,
+					    obj_priv->gtt_space->start
+						>> PAGE_SHIFT,
+					    obj_priv->agp_type);
+	} else
+		intel_gtt_insert_pages(obj_priv->gtt_space->start >> PAGE_SHIFT,
+				       obj->size >> PAGE_SHIFT,
+				       obj_priv->pages,
+				       obj_priv->agp_type);
 
-	if (obj_priv->agp_mem)
-		return 0;
-	else
-		return -ENOMEM;
+	return 0;
 }
 
 void i915_gem_gtt_unbind_object(struct drm_gem_object *obj)
 {
+	struct drm_device *dev = obj->dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
 	struct drm_i915_gem_object *obj_priv = to_intel_bo(obj);
 
-	drm_unbind_agp(obj_priv->agp_mem);
-	drm_free_agp(obj_priv->agp_mem, obj->size / PAGE_SIZE);
+	if (dev_priv->mm.gtt->needs_dmar) {
+		intel_gtt_unmap_memory(obj_priv->sg_list, obj_priv->num_sg);
+		obj_priv->sg_list = NULL;
+		obj_priv->num_sg = 0;
+	}
+
+	intel_gtt_clear_range(obj_priv->gtt_space->start >> PAGE_SHIFT,
+			      obj->size >> PAGE_SHIFT);
 }
-- 
1.7.6

