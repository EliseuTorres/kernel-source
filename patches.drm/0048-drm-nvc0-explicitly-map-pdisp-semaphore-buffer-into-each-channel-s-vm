From 3d483d575bfba52eae04bf2575239642c26c355a Mon Sep 17 00:00:00 2001
From: Ben Skeggs <bskeggs@redhat.com>
Date: Tue, 7 Jun 2011 15:43:31 +1000
Subject: drm/nvc0: explicitly map PDISP semaphore buffer into each channel's vm
Git-commit: 3d483d575bfba52eae04bf2575239642c26c355a
Patch-mainline: v3.1-rc1

Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
Acked-by: Michal Srb <msrb@suse.com>
---

 drivers/gpu/drm/nouveau/nouveau_drv.h    |    1 +
 drivers/gpu/drm/nouveau/nouveau_object.c |   16 ++++++++++++++++
 drivers/gpu/drm/nouveau/nv50_display.c   |    4 ++--
 3 files changed, 19 insertions(+), 2 deletions(-)

--- a/drivers/gpu/drm/nouveau/nouveau_drv.h
+++ b/drivers/gpu/drm/nouveau/nouveau_drv.h
@@ -293,6 +293,7 @@ struct nouveau_channel {
 
 	uint32_t sw_subchannel[8];
 
+	struct nouveau_vma dispc_vma[2];
 	struct {
 		struct nouveau_gpuobj *vblsem;
 		uint32_t vblsem_head;

--- a/drivers/gpu/drm/nouveau/nouveau_object.c
+++ b/drivers/gpu/drm/nouveau/nouveau_object.c
@@ -717,6 +717,17 @@ nouveau_gpuobj_channel_init(struct nouveau_channel *chan,
 		nv_wo32(chan->ramin, 0x0204, upper_32_bits(vpgd->obj->vinst));
 		nv_wo32(chan->ramin, 0x0208, 0xffffffff);
 		nv_wo32(chan->ramin, 0x020c, 0x000000ff);
+
+		for (i = 0; i < 2; i++) {
+			struct nv50_display_crtc *dispc =
+				&nv50_display(dev)->crtc[i];
+
+			ret = nouveau_bo_vma_add(dispc->sem.bo, chan->vm,
+						 &chan->dispc_vma[i]);
+			if (ret)
+				return ret;
+		}
+
 		return 0;
 	}
 
@@ -841,9 +852,14 @@ void
 nouveau_gpuobj_channel_takedown(struct nouveau_channel *chan)
 {
 	struct drm_device *dev = chan->dev;
+	int i;
 
 	NV_DEBUG(dev, "ch%d\n", chan->id);
 
+	for (i = 0; i < 2; i++) {
+		struct nv50_display_crtc *dispc = &nv50_display(dev)->crtc[i];
+		nouveau_bo_vma_del(dispc->sem.bo, &chan->dispc_vma[i]);
+	}
 	nouveau_vm_ref(NULL, &chan->vm, chan->vm_pd);
 	nouveau_gpuobj_ref(NULL, &chan->vm_pd);
 

--- a/drivers/gpu/drm/nouveau/nv50_display.c
+++ b/drivers/gpu/drm/nouveau/nv50_display.c
@@ -415,8 +415,6 @@ nv50_display_flip_next(struct drm_crtc *crtc, struct drm_framebuffer *fb,
 
 	/* synchronise with the rendering channel, if necessary */
 	if (likely(chan)) {
-		u64 offset = dispc->sem.bo->vma.offset + dispc->sem.offset;
-
 		ret = RING_SPACE(chan, 10);
 		if (ret) {
 			WIND_RING(evo);
@@ -438,6 +436,8 @@ nv50_display_flip_next(struct drm_crtc *crtc, struct drm_framebuffer *fb,
 			else
 				OUT_RING  (chan, chan->vram_handle);
 		} else {
+			u64 offset = chan->dispc_vma[nv_crtc->index].offset;
+			offset += dispc->sem.offset;
 			BEGIN_NVC0(chan, 2, NvSubM2MF, 0x0010, 4);
 			OUT_RING  (chan, upper_32_bits(offset));
 			OUT_RING  (chan, lower_32_bits(offset));


