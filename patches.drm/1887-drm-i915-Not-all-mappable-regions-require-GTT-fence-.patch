From c2adb470aafbfa8a1e0b0f20091a27b52e812539 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 9 Nov 2010 11:47:32 +0000
Patch-mainline: 2.6.38
References: fate#310916
Git-commit: 92b88aeb1ad67417c002fdd77409771ca7e5433a
Subject: [PATCH 1887/2588] drm/i915: Not all mappable regions require GTT
 fence regions

Combining map_and_fenceable revealed a bug in
i915_gem_object_gtt_size() in that it always computed the appropriate
fence size for the object regardless of tiling state which caused us to
over-allocate linear buffers when binding to the GTT.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit 92b88aeb1ad67417c002fdd77409771ca7e5433a)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/i915/i915_gem.c |   53 ++++++++++++++++----------------------
 1 files changed, 22 insertions(+), 31 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index e99bc2f..c033e66 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -41,9 +41,6 @@ struct change_domains {
 	uint32_t flush_rings;
 };
 
-static uint32_t i915_gem_get_gtt_alignment(struct drm_i915_gem_object *obj);
-static uint32_t i915_gem_get_gtt_size(struct drm_i915_gem_object *obj);
-
 static int i915_gem_object_flush_gpu_write_domain(struct drm_i915_gem_object *obj,
 						  bool pipelined);
 static void i915_gem_object_flush_gtt_write_domain(struct drm_i915_gem_object *obj);
@@ -1460,6 +1457,28 @@ i915_gem_free_mmap_offset(struct drm_i915_gem_object *obj)
 	list->map = NULL;
 }
 
+static uint32_t
+i915_gem_get_gtt_size(struct drm_i915_gem_object *obj)
+{
+	struct drm_device *dev = obj->base.dev;
+	uint32_t size;
+
+	if (INTEL_INFO(dev)->gen >= 4 ||
+	    obj->tiling_mode == I915_TILING_NONE)
+		return obj->base.size;
+
+	/* Previous chips need a power-of-two fence region when tiling */
+	if (INTEL_INFO(dev)->gen == 3)
+		size = 1024*1024;
+	else
+		size = 512*1024;
+
+	while (size < obj->base.size)
+		size <<= 1;
+
+	return size;
+}
+
 /**
  * i915_gem_get_gtt_alignment - return required GTT alignment for an object
  * @obj: object to check
@@ -1522,34 +1541,6 @@ i915_gem_get_unfenced_gtt_alignment(struct drm_i915_gem_object *obj)
 	return tile_height * obj->stride * 2;
 }
 
-static uint32_t
-i915_gem_get_gtt_size(struct drm_i915_gem_object *obj)
-{
-	struct drm_device *dev = obj->base.dev;
-	uint32_t size;
-
-	/*
-	 * Minimum alignment is 4k (GTT page size), but might be greater
-	 * if a fence register is needed for the object.
-	 */
-	if (INTEL_INFO(dev)->gen >= 4)
-		return obj->base.size;
-
-	/*
-	 * Previous chips need to be aligned to the size of the smallest
-	 * fence register that can contain the object.
-	 */
-	if (INTEL_INFO(dev)->gen == 3)
-		size = 1024*1024;
-	else
-		size = 512*1024;
-
-	while (size < obj->base.size)
-		size <<= 1;
-
-	return size;
-}
-
 /**
  * i915_gem_mmap_gtt_ioctl - prepare an object for GTT mmap'ing
  * @dev: DRM device
-- 
1.7.6

