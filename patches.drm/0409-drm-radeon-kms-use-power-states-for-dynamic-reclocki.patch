From e67f934d526f06e8ca128c1ec626ed1e794d5e06 Mon Sep 17 00:00:00 2001
From: Alex Deucher <alexdeucher@gmail.com>
Date: Wed, 23 Dec 2009 14:39:36 -0500
Patch-mainline: 2.6.34
References: fate#310916
Git-commit: 530079a8f3f35828a80ba4981c1be902982363e7
Subject: [PATCH 0409/2588] drm/radeon/kms: use power states for dynamic
 reclocking

Signed-off-by: Alex Deucher <alexdeucher@gmail.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 530079a8f3f35828a80ba4981c1be902982363e7)

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 drivers/gpu/drm/radeon/radeon.h    |    4 ----
 drivers/gpu/drm/radeon/radeon_pm.c |   31 ++++++++++++++-----------------
 2 files changed, 14 insertions(+), 21 deletions(-)

diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h
index 8e04608..df4f929 100644
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
@@ -667,10 +667,6 @@ struct radeon_pm {
 	bool			vblank_callback;
 	int			active_crtcs;
 	int			req_vblank;
-	uint32_t		min_gpu_engine_clock;
-	uint32_t		min_gpu_memory_clock;
-	uint32_t		min_mode_engine_clock;
-	uint32_t		min_mode_memory_clock;
 	fixed20_12		max_bandwidth;
 	fixed20_12		igp_sideport_mclk;
 	fixed20_12		igp_system_mclk;
diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index 87d2776..f500c8d 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
@@ -26,7 +26,6 @@
 #define RADEON_IDLE_LOOP_MS 100
 #define RADEON_RECLOCK_DELAY_MS 200
 
-static void radeon_pm_check_limits(struct radeon_device *rdev);
 static void radeon_pm_set_clocks_locked(struct radeon_device *rdev);
 static void radeon_pm_set_clocks(struct radeon_device *rdev);
 static void radeon_pm_reclock_work_handler(struct work_struct *work);
@@ -186,12 +185,21 @@ static void radeon_get_power_state(struct radeon_device *rdev,
 			radeon_pick_clock_mode(rdev, rdev->pm.requested_power_state, POWER_MODE_TYPE_HIGH);
 		break;
 	}
+	DRM_INFO("Requested: e: %d m: %d p: %d\n",
+		 rdev->pm.requested_power_state->requested_clock_mode->sclk,
+		 rdev->pm.requested_power_state->requested_clock_mode->mclk,
+		 rdev->pm.requested_power_state->non_clock_info.pcie_lanes);
 }
 
 static void radeon_set_power_state(struct radeon_device *rdev)
 {
 	if (rdev->pm.requested_power_state == rdev->pm.current_power_state)
 		return;
+
+	DRM_INFO("Setting: e: %d m: %d p: %d\n",
+		 rdev->pm.requested_power_state->requested_clock_mode->sclk,
+		 rdev->pm.requested_power_state->requested_clock_mode->mclk,
+		 rdev->pm.requested_power_state->non_clock_info.pcie_lanes);
 	/* set pcie lanes */
 	/* set voltage */
 	/* set engine clock */
@@ -216,8 +224,6 @@ int radeon_pm_init(struct radeon_device *rdev)
 		radeon_print_power_mode_info(rdev);
 	}
 
-	radeon_pm_check_limits(rdev);
-
 	if (radeon_debugfs_pm_init(rdev)) {
 		DRM_ERROR("Failed to register debugfs file for PM!\n");
 	}
@@ -235,12 +241,6 @@ int radeon_pm_init(struct radeon_device *rdev)
 	return 0;
 }
 
-static void radeon_pm_check_limits(struct radeon_device *rdev)
-{
-	rdev->pm.min_gpu_engine_clock = rdev->clock.default_sclk - 5000;
-	rdev->pm.min_gpu_memory_clock = rdev->clock.default_mclk - 5000;
-}
-
 void radeon_pm_compute_clocks(struct radeon_device *rdev)
 {
 	struct drm_device *ddev = rdev->ddev;
@@ -287,8 +287,6 @@ void radeon_pm_compute_clocks(struct radeon_device *rdev)
 			mutex_unlock(&rdev->pm.mutex);
 		}
 	} else if (count == 1) {
-		rdev->pm.min_mode_engine_clock = rdev->pm.min_gpu_engine_clock;
-		rdev->pm.min_mode_memory_clock = rdev->pm.min_gpu_memory_clock;
 		/* TODO: Increase clocks if needed for current mode */
 
 		if (rdev->pm.state == PM_STATE_MINIMUM) {
@@ -326,23 +324,22 @@ static void radeon_pm_set_clocks_locked(struct radeon_device *rdev)
 	/*radeon_fence_wait_last(rdev);*/
 	switch (rdev->pm.planned_action) {
 	case PM_ACTION_UPCLOCK:
-		radeon_set_engine_clock(rdev, rdev->clock.default_sclk);
+		radeon_get_power_state(rdev, PM_ACTION_UPCLOCK);
 		rdev->pm.downclocked = false;
 		break;
 	case PM_ACTION_DOWNCLOCK:
-		radeon_set_engine_clock(rdev,
-			rdev->pm.min_mode_engine_clock);
+		radeon_get_power_state(rdev, PM_ACTION_DOWNCLOCK);
 		rdev->pm.downclocked = true;
 		break;
 	case PM_ACTION_MINIMUM:
-		radeon_set_engine_clock(rdev,
-			rdev->pm.min_gpu_engine_clock);
+		radeon_get_power_state(rdev, PM_ACTION_MINIMUM);
 		break;
 	case PM_ACTION_NONE:
+		radeon_get_power_state(rdev, PM_ACTION_NONE);
 		DRM_ERROR("%s: PM_ACTION_NONE\n", __func__);
 		break;
 	}
-
+	radeon_set_power_state(rdev);
 	rdev->pm.planned_action = PM_ACTION_NONE;
 }
 
-- 
1.7.6

