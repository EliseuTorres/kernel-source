From: Jiri Slaby <jslaby@suse.cz>
Date: Mon, 12 Mar 2012 15:14:40 +0100
Subject: Revert "i387: fix x86-64 preemption-unsafe user stack save/restore"
Patch-mainline: never

This reverts commit c3cb6440304a2f9afd240bd860860d4a4955d409.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 arch/x86/include/asm/i387.h |   42 ------------------------------------------
 arch/x86/kernel/traps.c     |    1 +
 arch/x86/kernel/xsave.c     |   10 +++++++---
 3 files changed, 8 insertions(+), 45 deletions(-)

diff --git a/arch/x86/include/asm/i387.h b/arch/x86/include/asm/i387.h
index 6e87fa4..262bea9 100644
--- a/arch/x86/include/asm/i387.h
+++ b/arch/x86/include/asm/i387.h
@@ -400,48 +400,6 @@ static inline void irq_ts_restore(int TS_state)
 }
 
 /*
- * The question "does this thread have fpu access?"
- * is slightly racy, since preemption could come in
- * and revoke it immediately after the test.
- *
- * However, even in that very unlikely scenario,
- * we can just assume we have FPU access - typically
- * to save the FP state - we'll just take a #NM
- * fault and get the FPU access back.
- *
- * The actual user_fpu_begin/end() functions
- * need to be preemption-safe, though.
- *
- * NOTE! user_fpu_end() must be used only after you
- * have saved the FP state, and user_fpu_begin() must
- * be used only immediately before restoring it.
- * These functions do not do any save/restore on
- * their own.
- */
-static inline int user_has_fpu(void)
-{
-	return current_thread_info()->status & TS_USEDFPU;
-}
-
-static inline void user_fpu_end(void)
-{
-	preempt_disable();
-	current_thread_info()->status &= ~TS_USEDFPU;
-	stts();
-	preempt_enable();
-}
-
-static inline void user_fpu_begin(void)
-{
-	preempt_disable();
-	if (!user_has_fpu()) {
-		clts();
-		current_thread_info()->status |= TS_USEDFPU;
-	}
-	preempt_enable();
-}
-
-/*
  * These disable preemption on their own and are safe
  */
 static inline void save_init_fpu(struct task_struct *tsk)
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index 5878de3..15903de 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -777,6 +777,7 @@ EXPORT_SYMBOL_GPL(math_state_restore);
 dotraplinkage void __kprobes
 do_device_not_available(struct pt_regs *regs, long error_code)
 {
+	WARN_ON_ONCE(!user_mode_vm(regs));
 #ifdef CONFIG_MATH_EMULATION
 	if (read_cr0() & X86_CR0_EM) {
 		struct math_emu_info info = { };
diff --git a/arch/x86/kernel/xsave.c b/arch/x86/kernel/xsave.c
index 86f1f09..a391134 100644
--- a/arch/x86/kernel/xsave.c
+++ b/arch/x86/kernel/xsave.c
@@ -168,7 +168,7 @@ int save_i387_xstate(void __user *buf)
 	if (!used_math())
 		return 0;
 
-	if (user_has_fpu()) {
+	if (task_thread_info(tsk)->status & TS_USEDFPU) {
 		if (use_xsave())
 			err = xsave_user(buf);
 		else
@@ -176,7 +176,8 @@ int save_i387_xstate(void __user *buf)
 
 		if (err)
 			return err;
-		user_fpu_end();
+		task_thread_info(tsk)->status &= ~TS_USEDFPU;
+		stts();
 	} else {
 		sanitize_i387_state(tsk);
 		if (__copy_to_user(buf, &tsk->thread.fpu.state->fxsave,
@@ -291,7 +292,10 @@ int restore_i387_xstate(void __user *buf)
 			return err;
 	}
 
-	user_fpu_begin();
+	if (!(task_thread_info(current)->status & TS_USEDFPU)) {
+		clts();
+		task_thread_info(current)->status |= TS_USEDFPU;
+	}
 	if (use_xsave())
 		err = restore_user_xstate(buf);
 	else
-- 
1.7.9.2

