From 2a17fdedf48e71417f505f3143d83623475f5b2c Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@suse.de>
Date: Fri, 20 Aug 2010 11:16:50 -0700
Subject: Revert "mm: keep a guard page below a grow-down stack segment"

This reverts commit 7e281afe24330aeea86113ac241eabdac8ba2311.

Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 mm/memory.c |   23 -----------------------
 1 files changed, 0 insertions(+), 23 deletions(-)

diff --git a/mm/memory.c b/mm/memory.c
index 92ef198..348e206 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2630,26 +2630,6 @@ out_release:
 }
 
 /*
- * This is like a special single-page "expand_downwards()",
- * except we must first make sure that 'address-PAGE_SIZE'
- * doesn't hit another vma.
- *
- * The "find_vma()" will do the right thing even if we wrap
- */
-static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)
-{
-	address &= PAGE_MASK;
-	if ((vma->vm_flags & VM_GROWSDOWN) && address == vma->vm_start) {
-		address -= PAGE_SIZE;
-		if (find_vma(vma->vm_mm, address) != vma)
-			return -ENOMEM;
-
-		expand_stack(vma, address);
-	}
-	return 0;
-}
-
-/*
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
  * We return with mmap_sem still held, but pte unmapped and unlocked.
@@ -2662,9 +2642,6 @@ static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,
 	spinlock_t *ptl;
 	pte_t entry;
 
-	if (check_stack_guard_page(vma, address) < 0)
-		return VM_FAULT_SIGBUS;
-
 	if (!(flags & FAULT_FLAG_WRITE)) {
 		entry = pte_mkspecial(pfn_pte(my_zero_pfn(address),
 						vma->vm_page_prot));
-- 
1.7.1

