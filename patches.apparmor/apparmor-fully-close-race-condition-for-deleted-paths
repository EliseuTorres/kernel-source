From john.johansen@canonical.com  Tue Nov 17 12:03:14 2009
From: John Johansen <john.johansen@canonical.com>
Date: Tue, 17 Nov 2009 07:33:47 +0000 (-0800)
Subject: AppArmor: Fully close race condition for deleted paths
Git-commit: 3dc2836574f209e7de447c1451f0c1c326cacadf
Git-Repo: git://kernel.ubuntu.com/jj/apparmor-mainline.git AppArmor-2.4

Fully close race condition for deleted paths

The previous patch allowing stripping of deleted didn't close off the
race condition, which can occur under the following circumstances.

1.  The undeleted path must end in " (deleted).
2.  d_namespace_path and unlink race such that when __d_path is
    called the path is not deleted, but the test for deleted after
    __d_path sees the path as deleted.

    This results in d_namespace path stripping off the trailing
    " (deleted) which is a valid part of the path and not, the
    string appended by d_path.

Signed-off-by: John Johansen <john.johansen@canonical.com>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---

 security/apparmor/path.c |   31 ++++++++++++++++++++++---------
 1 file changed, 22 insertions(+), 9 deletions(-)

diff --git a/security/apparmor/path.c b/security/apparmor/path.c
index 2c14e1d..a48b5f4 100644
--- a/security/apparmor/path.c
+++ b/security/apparmor/path.c
@@ -88,6 +88,7 @@ int d_namespace_path(struct path *path, char *buf, int buflen, char **name)
 {
 	struct path root, tmp, ns_root = { };
 	char *res;
+	int deleted;
 	int error = 0;
 
 	read_lock(&current->fs->lock);
@@ -101,8 +102,12 @@ int d_namespace_path(struct path *path, char *buf, int buflen, char **name)
 		ns_root.dentry = dget(ns_root.mnt->mnt_root);
 	spin_unlock(&vfsmount_lock);
 	spin_lock(&dcache_lock);
-	tmp = ns_root;
-	res = __d_path(path, &tmp, buf, buflen);
+
+	do {
+		tmp = ns_root;
+		deleted = d_unlinked(path->dentry);
+		res = __d_path(path, &tmp, buf, buflen);
+	} while (deleted != d_unlinked(path->dentry));
 
 	*name = res;
 	/* handle error conditions - and still allow a partial path to
@@ -110,8 +115,21 @@ int d_namespace_path(struct path *path, char *buf, int buflen, char **name)
 	if (IS_ERR(res)) {
 		error = PTR_ERR(res);
 		*name = buf;
-	} else if (d_unhashed(path->dentry) && !path->dentry->d_inode) {
-		/* On some filesystems, newly allocated dentries appear
+	} else if (deleted) {
+		/* The stripping of (deleted) is a hack that could be removed
+		 * with an updated __d_path
+		 */
+
+		/* Currently 2 cases fall into here.  Fixing the mediation
+		 * of deleted files for things like trunc.
+		 * And the newly allocated dentry case.  The first case
+		 * means we strip deleted for everything so the new
+		 * dentry test case is commented out below.
+		 */
+		buf[buflen - 11] = 0;	/* - (len(" (deleted)") +\0) */
+
+		/* if (!path->dentry->d_inode) {
+		 * On some filesystems, newly allocated dentries appear
 		 * to the security_path hooks as a deleted
 		 * dentry except without an inode allocated.
 		 *
@@ -120,11 +138,6 @@ int d_namespace_path(struct path *path, char *buf, int buflen, char **name)
 		 * is guarenteed to be added in this case, so just
 		 * strip it.
 		 */
-		buf[buflen - 11] = 0;	/* - (len(" (deleted)") +\0) */
-	} else if (d_unhashed(path->dentry) && (buf + buflen) - res > 11 &&
-		   strcmp(buf + buflen - 11, " (deleted)") == 0) {
-		/* For now allow mediation of deleted paths */
-		buf[buflen - 11] = 0;	/* - (len(" (deleted)") +\0) */
 	} else if (!IS_ROOT(path->dentry) && d_unhashed(path->dentry)) {
 		error = -ENOENT;
 #if 0

