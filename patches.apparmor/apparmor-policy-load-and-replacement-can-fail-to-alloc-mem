From john.johansen@canonical.com  Tue Nov 17 12:03:14 2009
From: John Johansen <john.johansen@canonical.com>
Date: Sat, 31 Oct 2009 07:29:14 +0000 (-0700)
Subject: AppArmor: Policy load and replacement can fail to alloc mem
Git-commit: 1ab7b3e6235ae47dfc5ba403c4bc3a664b6f8d8e
Git-Repo: git://kernel.ubuntu.com/jj/apparmor-mainline.git AppArmor-2.4

AppArmor: Policy load and replacement can fail to alloc mem

BugLink: http://bugs.launchpad.net/bugs/458299

AppArmor dfas can under some circumstances be rather large reaching
allocations of greater than 128K for a single table.  While this is
not common this can result in memory allocation asking for page allocations
with an order of 5 or more, which will fail if memory has become fragemented.

This can cause replacement of profiles to fail.  Since profile
setup and replacement is a rare event try falling back to vmalloc if kmalloc
fails.

Signed-off-by: John Johansen <john.johansen@canonical.com>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---

 security/apparmor/match.c |   20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/security/apparmor/match.c b/security/apparmor/match.c
index a22d106..1a50309 100644
--- a/security/apparmor/match.c
+++ b/security/apparmor/match.c
@@ -12,9 +12,11 @@
  * License.
  */
 
+#include <linux/errno.h>
 #include <linux/kernel.h>
+#include <linux/mm.h>
 #include <linux/slab.h>
-#include <linux/errno.h>
+#include <linux/vmalloc.h>
 
 /* TODO: remove !!!! */
 // #include <linux/fs.h>
@@ -23,6 +25,14 @@
 #include "include/match.h"
 #include "include/file.h"
 
+static void free_table(struct table_header *table)
+{
+	if (is_vmalloc_addr(table))
+		vfree(table);
+	else
+		kfree(table);
+}
+
 static struct table_header *unpack_table(void *blob, size_t bsize)
 {
 	struct table_header *table = NULL;
@@ -46,6 +56,8 @@ static struct table_header *unpack_table(void *blob, size_t bsize)
 		goto out;
 
 	table = kmalloc(tsize, GFP_KERNEL);
+	if (!table)
+		table = vmalloc(tsize);
 	if (table) {
 		*table = th;
 		if (th.td_flags == YYTD_DATA8)
@@ -110,7 +122,7 @@ int unpack_dfa(struct aa_dfa *dfa, void *blob, size_t size)
 				goto fail;
 			break;
 		default:
-			kfree(table);
+			free_table(table);
 			goto fail;
 		}
 
@@ -122,7 +134,7 @@ int unpack_dfa(struct aa_dfa *dfa, void *blob, size_t size)
 
 fail:
 	for (i = 0; i < ARRAY_SIZE(dfa->tables); i++) {
-		kfree(dfa->tables[i]);
+		free_table(dfa->tables[i]);
 		dfa->tables[i] = NULL;
 	}
 	return error;
@@ -207,7 +219,7 @@ void aa_match_free(struct aa_dfa *dfa)
 		int i;
 
 		for (i = 0; i < ARRAY_SIZE(dfa->tables); i++)
-			kfree(dfa->tables[i]);
+			free_table(dfa->tables[i]);
 	}
 	kfree(dfa);
 }

