From john.johansen@canonical.com  Tue Nov 17 11:13:50 2009
From: John Johansen <john.johansen@canonical.com>
Date: Wed, 26 Aug 2009 21:33:48 +0000 (-0700)
Subject: AppArmor: Fix profile attachment for regexp based profile names
Git-commit: 65b8e01962b45fecf622e01096a588fce29e973f
Git-Repo: git://kernel.ubuntu.com/jj/apparmor-mainline.git AppArmor-2.4

AppArmor: Fix profile attachment for regexp based profile names

BugLink: http://bugs.launchpad.net/bugs/419308

Part a & b
Fix profile attachment for profiles that specify an xmatch dfa.  Just testing
if the state > DFA_START is not sufficient to determine if the state is an
accepting state, as there are transition states that are not accept states.
Instead test for the MAY_EXEC permission which is set for valid matches.

Part c & d of lp #419308:
The attachment semantics for px, cx are currently wrong.  They do correct
attachment for profiles with names that are exact matches but the
attachment fails for profiles names that contain regular expressions.

eg. Given the following profiles

/bin/** { } and /bin/foo { }

an unconfined process correctly attaches to either profile but for a
confined process with x transition rules.
  /bin/foo px,   # correctly attaches
  /bin/bar px,   # does not attach to /bin/** as it should.

Use the system attachment function, instead of searching for the profile.

Signed-off-by: John Johansen <john.johansen@canonical.com>
Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
Acked-by: Jeff Mahoney <jeffm@suse.com>

---
 security/apparmor/domain.c         |   10 ++++++++--
 security/apparmor/include/policy.h |    2 +-
 security/apparmor/policy.c         |   16 +++++++++-------
 3 files changed, 18 insertions(+), 10 deletions(-)

--- a/security/apparmor/domain.c
+++ b/security/apparmor/domain.c
@@ -157,7 +157,12 @@ static struct aa_profile *x_to_profile(s
 		/* fail exec unless ix || ux fallback - handled by caller */
 		return ERR_PTR(-EACCES);
 	case AA_X_NAME:
-		break;
+		if (xindex & AA_X_CHILD)
+			new_profile = aa_sys_find_attach(&profile->base, name);
+		else
+			new_profile = aa_sys_find_attach(&ns->base, name);
+
+		goto out;
 	case AA_X_TABLE:
 		if (index > profile->file.trans.size) {
 			AA_ERROR("Invalid named transition\n");
@@ -203,6 +208,7 @@ static struct aa_profile *x_to_profile(s
 		aa_put_namespace(new_ns);
 	}
 
+out:
 	if (!new_profile)
 		return ERR_PTR(-ENOENT);
 
@@ -251,7 +257,7 @@ int apparmor_bprm_set_creds(struct linux
 
 	if (!profile) {
 		/* unconfined task - attach profile if one matches */
-		new_profile = aa_sys_find_attach(ns, sa.name);
+		new_profile = aa_sys_find_attach(&ns->base, sa.name);
 		if (!new_profile)
 			goto cleanup;
 		goto apply;
--- a/security/apparmor/include/policy.h
+++ b/security/apparmor/include/policy.h
@@ -249,7 +249,7 @@ struct aa_profile *aa_find_profile_by_fq
 					     const char *name);
 struct aa_profile *aa_match_profile(struct aa_namespace *ns, const char *name);
 struct aa_profile *aa_profile_newest(struct aa_profile *profile);
-struct aa_profile *aa_sys_find_attach(struct aa_namespace *ns,
+struct aa_profile *aa_sys_find_attach(struct aa_policy_common *base,
 				      const char *name);
 void __aa_add_profile(struct aa_policy_common *common,
 		      struct aa_profile *profile);
--- a/security/apparmor/policy.c
+++ b/security/apparmor/policy.c
@@ -670,8 +670,9 @@ static struct aa_profile *__aa_attach_ma
 		if (profile->xmatch && profile->xmatch_len > len) {
 			unsigned int state = aa_dfa_match(profile->xmatch,
 							  DFA_START, name);
-			/* any accepting state means a valid match */
-			if (state > DFA_START) {
+			u16 perm = dfa_user_allow(profile->xmatch, state);
+			/* any accepting state means a valid match. */
+			if (perm & MAY_EXEC) {
 				candidate = profile;
 				len = profile->xmatch_len;
 			}
@@ -685,16 +686,17 @@ static struct aa_profile *__aa_attach_ma
 
 /**
  * aa_sys_find_attach - do attachment search for sys unconfined processes
- * @ns: the namespace to search
+ * @base: the base to search
  * name: the executable name to match against
  */
-struct aa_profile *aa_sys_find_attach(struct aa_namespace *ns, const char *name)
+struct aa_profile *aa_sys_find_attach(struct aa_policy_common *base,
+				      const char *name)
 {
 	struct aa_profile *profile;
 
-	read_lock(&ns->base.lock);
-	profile = aa_get_profile(__aa_attach_match(name, &ns->base.profiles));
-	read_unlock(&ns->base.lock);
+	read_lock(&base->lock);
+	profile = aa_get_profile(__aa_attach_match(name, &base->profiles));
+	read_unlock(&base->lock);
 
 	return profile;
 }
