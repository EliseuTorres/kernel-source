From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Subject: s390/mm: handle asce-type exceptions as normal page fault
Patch-mainline: v3.13-rc2
Git-commit: 127581b64b432804948535d49847b36366b9ff64
References: bnc#878059, LTC#110271

Description:  kernel: correct tlb flush on page table upgrade
Symptom:      Unexpected program crashes, random data corruption.
Problem:      The update of a page-table from 2 to 3, or 3 to 4 levels
              will create a new top level page-table for the virtual
              address space. The address-space-control element (ASCE)
              for the virtual address space will be replaced by an ASCE
              with the new top level page-table. Translation-lookaside
              buffer (TLB) entries created for the virtual address space
              are associated to the ASCE that has been in use when the
              TLB entries have been created. The page-table upgrade code
              misses a TLB flush for the TLB entries associated to the
              old ASCE. If the memory of the old top level page-table is
              used by a new process as its top level page-table the
              stale TLB entries cause incorrect virtual address
              translations.
Solution:     Flush the TLB entries associated to the old ASCE on
              page-table upgrade.
Reproduction: Run a program in a loop that forces the memory management
              to create a 4-level page table and exists shortly after.
              Eventually an instance of the program will reuse a top
              level page-table which has stale TLB entries associated
              to it.

Upstream-Description:

              s390/mm: handle asce-type exceptions as normal page fault

              Git commit 9e34f2686bb088b211b6cac8772e1f644c6180f8
              "s390/mm,tlb: tlb flush on page table upgrade fixup" removed the
              exception handler for the asce-type exception. This is incorrect
              as the user-copy with MVCOS can cause asce-type exceptions in
              the kernel if a user pointer is too large. Those need to be
              handled with do_no_context to branch to the fixup in the
              user-copy code.

              The simplest fix for this problem is to call do_dat_exception for
              asce-type excpetions, as there is no vma for the address the code
              will handle the exception correctly.

              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/kernel/pgm_check.S |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/arch/s390/kernel/pgm_check.S
+++ b/arch/s390/kernel/pgm_check.S
@@ -78,7 +78,7 @@ PGM_CHECK_DEFAULT			/* 34 */
 PGM_CHECK_DEFAULT			/* 35 */
 PGM_CHECK_DEFAULT			/* 36 */
 PGM_CHECK_DEFAULT			/* 37 */
-PGM_CHECK_DEFAULT			/* 38 */
+PGM_CHECK_64BIT(do_dat_exception)	/* 38 */
 PGM_CHECK_64BIT(do_dat_exception)	/* 39 */
 PGM_CHECK_64BIT(do_dat_exception)	/* 3a */
 PGM_CHECK_64BIT(do_dat_exception)	/* 3b */
