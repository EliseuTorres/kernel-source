From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: zfcp: support for T10 DIF / DIX
Description: Report the capabilities for the Scsi_Host,
              enable data division support,
              map the protection data when issuing I/O requests, and
              handle the new error codes.
              Also add the fsf data_direction field to the hba trace,
              it is useful information for debugging in that area.
Patch-mainline: yes
References: bnc#708635

              This patch contains the following upstream patches:
              683229845f1780b10041ee7a1043fc8f10061455
              dcc18f48a2f1a44c5e8848f30d0cf53a8066c62a
              ef3eb71d8ba4fd9d48c5f9310bc9d90ca00323b4
              175b79f0632544d62aae72e5496c14e3e3ff2ae7

Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
Signed-off-by: James Bottomley <James.Bottomley@suse.de>
Signed-off-by: Felix Beck <felix.beck@de.ibm.com>
Signed-off-by: Jens Axboe <axboe@carl.home.kernel.dk>
Acked-by: Torsten Duwe <duwe@suse.de>

--- a/arch/s390/include/asm/qdio.h
+++ b/arch/s390/include/asm/qdio.h
@@ -84,6 +84,9 @@ struct qdr {
 
 #define QIB_AC_OUTBOUND_PCI_SUPPORTED	0x40
 #define QIB_RFLAGS_ENABLE_QEBSM		0x80
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+#define QIB_RFLAGS_ENABLE_DATA_DIV	0x02
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
 /**
  * struct qib - queue information block (QIB)
@@ -334,6 +337,11 @@ struct qdio_outbuf_state {
 
 #define CHSC_AC3_FORMAT2_CQ_AVAILABLE	0x8000
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+#define CHSC_AC2_DATA_DIV_AVAILABLE	0x0010
+#define CHSC_AC2_DATA_DIV_ENABLED	0x0002
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 struct qdio_ssqd_desc {
 	u8 flags;
 	u8:8;
@@ -386,6 +394,9 @@ typedef void qdio_handler_t(struct ccw_d
  * @adapter_name: name for the adapter
  * @qib_param_field_format: format for qib_parm_field
  * @qib_param_field: pointer to 128 bytes or NULL, if no param field
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+ * @qib_rflags: rflags to set
+#endif
  * @input_slib_elements: pointer to no_input_qs * 128 words of data or NULL
  * @output_slib_elements: pointer to no_output_qs * 128 words of data or NULL
  * @no_input_qs: number of input queues
@@ -405,6 +416,9 @@ struct qdio_initialize {
 	unsigned char adapter_name[8];
 	unsigned int qib_param_field_format;
 	unsigned char *qib_param_field;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	unsigned char qib_rflags;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	unsigned long *input_slib_elements;
 	unsigned long *output_slib_elements;
 	unsigned int no_input_qs;
--- a/drivers/s390/cio/qdio_setup.c
+++ b/drivers/s390/cio/qdio_setup.c
@@ -411,6 +411,10 @@ static void setup_qib(struct qdio_irq *i
 	if (qebsm_possible())
 		irq_ptr->qib.rflags |= QIB_RFLAGS_ENABLE_QEBSM;
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	irq_ptr->qib.rflags |= init_data->qib_rflags;
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	irq_ptr->qib.qfmt = init_data->q_format;
 	if (init_data->no_input_qs)
 		irq_ptr->qib.isliba =
--- a/drivers/s390/scsi/zfcp_aux.c
+++ b/drivers/s390/scsi/zfcp_aux.c
@@ -578,6 +578,12 @@ int zfcp_adapter_enqueue(struct ccw_devi
 
 	atomic_clear_mask(ZFCP_STATUS_COMMON_REMOVE, &adapter->status);
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	/* report size limit per scatter-gather segment */
+	adapter->dma_parms.max_segment_size = ZFCP_QDIO_SBALE_LEN;
+	adapter->ccw_device->dev.dma_parms = &adapter->dma_parms;
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	if (!zfcp_adapter_scsi_register(adapter))
 		return 0;
 
--- a/drivers/s390/scsi/zfcp_dbf.c
+++ b/drivers/s390/scsi/zfcp_dbf.c
@@ -153,6 +153,10 @@ void _zfcp_dbf_hba_fsf_response(const ch
 		if (scsi_cmnd) {
 			response->u.fcp.cmnd = (unsigned long)scsi_cmnd;
 			response->u.fcp.serial = scsi_cmnd->serial_number;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+			response->u.fcp.data_dir =
+				qtcb->bottom.io.data_direction;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 		}
 		break;
 
@@ -325,6 +329,9 @@ static void zfcp_dbf_hba_view_response(c
 	case FSF_QTCB_FCP_CMND:
 		if (r->fsf_req_status & ZFCP_STATUS_FSFREQ_TASK_MANAGEMENT)
 			break;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+		zfcp_dbf_out(p, "data_direction", "0x%04x", r->u.fcp.data_dir);
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 		zfcp_dbf_out(p, "scsi_cmnd", "0x%0Lx", r->u.fcp.cmnd);
 		zfcp_dbf_out(p, "scsi_serial", "0x%016Lx", r->u.fcp.serial);
 		p += sprintf(*p, "\n");
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -108,6 +108,9 @@ struct zfcp_dbf_hba_record_response {
 		struct {
 			u64 cmnd;
 			u64 serial;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+			u32 data_dir;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 		} fcp;
 		struct {
 			u64 wwpn;
--- a/drivers/s390/scsi/zfcp_def.h
+++ b/drivers/s390/scsi/zfcp_def.h
@@ -25,6 +25,9 @@
 #include <scsi/fc/fc_fs.h>
 #include <scsi/fc/fc_gs.h>
 #include <scsi/scsi.h>
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+#include <scsi/scsi_eh.h>
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 #include <scsi/scsi_tcq.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
@@ -63,6 +66,10 @@
         /* max. number of (data buffer) SBALEs in largest SBAL chain
            multiplied with number of sectors per 4k block */
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+#define ZFCP_QDIO_SBALE_LEN	PAGE_SIZE
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 /********************* FSF SPECIFIC DEFINES *********************************/
 
 /* ATTENTION: value must not be used by hardware */
@@ -222,6 +229,9 @@ struct zfcp_ls_adisc {
 #define ZFCP_STATUS_ADAPTER_HOST_CON_INIT	0x00000010
 #define ZFCP_STATUS_ADAPTER_ERP_PENDING		0x00000100
 #define ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED	0x00000200
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+#define ZFCP_STATUS_ADAPTER_DATA_DIV_ENABLED	0x00000400
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
 /* FC-PH/FC-GS well-known address identifiers for generic services */
 #define ZFCP_DID_WKA				0xFFFFF0
@@ -501,6 +511,9 @@ struct zfcp_adapter {
 	struct work_struct	scan_work;
 	struct service_level	service_level;
 	struct workqueue_struct	*work_queue;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	struct device_dma_parameters dma_parms;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 };
 
 struct zfcp_port {
--- a/drivers/s390/scsi/zfcp_ext.h
+++ b/drivers/s390/scsi/zfcp_ext.h
@@ -163,6 +163,10 @@ extern void zfcp_scsi_schedule_rport_blo
 extern void zfcp_scsi_schedule_rports_block(struct zfcp_adapter *);
 extern void zfcp_scsi_scan(struct zfcp_unit *);
 extern void zfcp_scsi_scan_work(struct work_struct *);
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+extern void zfcp_scsi_set_prot(struct zfcp_adapter *);
+extern void zfcp_scsi_dif_sense_error(struct scsi_cmnd *, int);
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
 /* zfcp_sysfs.c */
 extern struct attribute_group zfcp_sysfs_unit_attrs;
--- a/drivers/s390/scsi/zfcp_fsf.c
+++ b/drivers/s390/scsi/zfcp_fsf.c
@@ -523,6 +523,10 @@ static int zfcp_fsf_exchange_config_eval
 		return -EIO;
 	}
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	zfcp_scsi_set_prot(adapter);
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	return 0;
 }
 
@@ -1021,6 +1025,23 @@ static int zfcp_fsf_one_sbal(struct scat
 	return sg_is_last(sg) && sg->length <= PAGE_SIZE;
 }
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+/**
+ * zfcp_qdio_set_sbale_last - set last entry flag in current sbale
+ * @qdio: pointer to struct zfcp_qdio
+ * @q_req: pointer to struct zfcp_queue_req
+ */
+static inline
+void zfcp_qdio_set_sbale_last(struct zfcp_qdio *qdio,
+			      struct zfcp_queue_req *q_req)
+{
+	struct qdio_buffer_element *sbale;
+
+	sbale = zfcp_qdio_sbale_curr(qdio, q_req);
+	sbale->flags |= SBAL_FLAGS_LAST_ENTRY;
+}
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 static int zfcp_fsf_setup_ct_els_sbals(struct zfcp_fsf_req *req,
 				       struct scatterlist *sg_req,
 				       struct scatterlist *sg_resp,
@@ -1051,6 +1072,9 @@ static int zfcp_fsf_setup_ct_els_sbals(s
 					sg_req, max_sbals);
 	if (bytes <= 0)
 		return -EIO;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	zfcp_qdio_set_sbale_last(adapter->qdio, &req->queue_req);
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	req->qtcb->bottom.support.req_buf_length = bytes;
 	req->queue_req.sbale_curr = ZFCP_LAST_SBALE_PER_SBAL;
 
@@ -1060,6 +1084,9 @@ static int zfcp_fsf_setup_ct_els_sbals(s
 	req->qtcb->bottom.support.resp_buf_length = bytes;
 	if (bytes <= 0)
 		return -EIO;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	zfcp_qdio_set_sbale_last(adapter->qdio, &req->queue_req);
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
 	return 0;
 }
@@ -2116,9 +2143,17 @@ static void zfcp_fsf_req_latency(struct
 	lat_inf = &req->qtcb->prefix.prot_status_qual.latency_info;
 
 	switch (req->qtcb->bottom.io.data_direction) {
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	case FSF_DATADIR_DIF_READ_STRIP:
+	case FSF_DATADIR_DIF_READ_CONVERT:
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	case FSF_DATADIR_READ:
 		lat = &unit->latencies.read;
 		break;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	case FSF_DATADIR_DIF_WRITE_INSERT:
+	case FSF_DATADIR_DIF_WRITE_CONVERT:
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	case FSF_DATADIR_WRITE:
 		lat = &unit->latencies.write;
 		break;
@@ -2188,6 +2223,24 @@ static void zfcp_fsf_send_fcp_command_ta
 		goto skip_fsfstatus;
 	}
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	switch (req->qtcb->header.fsf_status) {
+	case FSF_INCONSISTENT_PROT_DATA:
+	case FSF_INVALID_PROT_PARM:
+		set_host_byte(scpnt, DID_ERROR);
+		goto skip_fsfstatus;
+	case FSF_BLOCK_GUARD_CHECK_FAILURE:
+		zfcp_scsi_dif_sense_error(scpnt, 0x1);
+		goto skip_fsfstatus;
+	case FSF_APP_TAG_CHECK_FAILURE:
+		zfcp_scsi_dif_sense_error(scpnt, 0x2);
+		goto skip_fsfstatus;
+	case FSF_REF_TAG_CHECK_FAILURE:
+		zfcp_scsi_dif_sense_error(scpnt, 0x3);
+		goto skip_fsfstatus;
+	}
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	set_msg_byte(scpnt, COMMAND_COMPLETE);
 
 	scpnt->result |= fcp_rsp_iu->scsi_status;
@@ -2344,6 +2397,67 @@ static void zfcp_set_fcp_dl(struct fcp_c
 	*fcp_dl_ptr = fcp_dl;
 }
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+/**
+ * zfcp_qdio_set_data_div - set data division count
+ * @qdio: pointer to struct zfcp_qdio
+ * @q_req: The current zfcp_queue_req
+ * @count: The data division count
+ */
+static inline
+void zfcp_qdio_set_data_div(struct zfcp_qdio *qdio,
+			    struct zfcp_queue_req *q_req, u32 count)
+{
+	struct qdio_buffer_element *sbale;
+
+	sbale = &qdio->req_q.sbal[q_req->sbal_first]->element[0];
+	sbale->length = count;
+}
+
+static int zfcp_fsf_set_data_dir(struct scsi_cmnd *scsi_cmnd, u32 *data_dir,
+				 struct fcp_cmnd_iu *fcp_cmnd_iu,
+				 unsigned int *sbtype)
+{
+	switch (scsi_get_prot_op(scsi_cmnd)) {
+	case SCSI_PROT_NORMAL:
+		switch (scsi_cmnd->sc_data_direction) {
+		case DMA_NONE:
+			*data_dir = FSF_DATADIR_CMND;
+			break;
+		case DMA_FROM_DEVICE:
+			*data_dir = FSF_DATADIR_READ;
+			fcp_cmnd_iu->rddata = 1;
+			break;
+		case DMA_TO_DEVICE:
+			*data_dir = FSF_DATADIR_WRITE;
+			*sbtype = SBAL_FLAGS0_TYPE_WRITE;
+			fcp_cmnd_iu->wddata = 1;
+			break;
+		case DMA_BIDIRECTIONAL:
+			return -EINVAL;
+		}
+		break;
+
+	case SCSI_PROT_READ_STRIP:
+		*data_dir = FSF_DATADIR_DIF_READ_STRIP;
+		break;
+	case SCSI_PROT_WRITE_INSERT:
+		*data_dir = FSF_DATADIR_DIF_WRITE_INSERT;
+		break;
+	case SCSI_PROT_READ_PASS:
+		*data_dir = FSF_DATADIR_DIF_READ_CONVERT;
+		break;
+	case SCSI_PROT_WRITE_PASS:
+		*data_dir = FSF_DATADIR_DIF_WRITE_CONVERT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
+
 /**
  * zfcp_fsf_send_fcp_command_task - initiate an FCP command (for a SCSI command)
  * @unit: unit where command is sent to
@@ -2355,9 +2469,16 @@ int zfcp_fsf_send_fcp_command_task(struc
 	struct zfcp_fsf_req *req;
 	struct fcp_cmnd_iu *fcp_cmnd_iu;
 	unsigned int sbtype = SBAL_FLAGS0_TYPE_READ;
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	int real_bytes, retval = -EIO;
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+	int real_bytes, retval = -EIO, dix_bytes = 0;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	struct zfcp_adapter *adapter = unit->port->adapter;
 	struct zfcp_qdio *qdio = adapter->qdio;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	struct fsf_qtcb_bottom_io *io;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
 	if (unlikely(!(atomic_read(&unit->status) &
 		       ZFCP_STATUS_COMMON_UNBLOCKED)))
@@ -2377,6 +2498,11 @@ int zfcp_fsf_send_fcp_command_task(struc
 		goto out;
 	}
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	scsi_cmnd->host_scribble = (unsigned char *) req->req_id;
+
+	io = &req->qtcb->bottom.io;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	req->status |= ZFCP_STATUS_FSFREQ_CLEANUP;
 	zfcp_unit_get(unit);
 	req->unit = unit;
@@ -2384,12 +2510,28 @@ int zfcp_fsf_send_fcp_command_task(struc
 	req->handler = zfcp_fsf_send_fcp_command_handler;
 	req->qtcb->header.lun_handle = unit->handle;
 	req->qtcb->header.port_handle = unit->port->handle;
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	req->qtcb->bottom.io.service_class = FSF_CLASS_3;
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+	io->service_class = FSF_CLASS_3;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	scsi_cmnd->host_scribble = (unsigned char *) req->req_id;
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+	if (scsi_get_prot_op(scsi_cmnd) != SCSI_PROT_NORMAL) {
+		io->data_block_length = scsi_cmnd->device->sector_size;
+		io->ref_tag_value = scsi_get_lba(scsi_cmnd) & 0xFFFFFFFF;
+	}
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	fcp_cmnd_iu = (struct fcp_cmnd_iu *) &(req->qtcb->bottom.io.fcp_cmnd);
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+	fcp_cmnd_iu = (struct fcp_cmnd_iu *) &(io->fcp_cmnd);
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	fcp_cmnd_iu->fcp_lun = unit->fcp_lun;
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	/*
 	 * set depending on data direction:
 	 *      data direction bits in SBALE (SB Type)
@@ -2410,8 +2552,15 @@ int zfcp_fsf_send_fcp_command_task(struc
 		fcp_cmnd_iu->wddata = 1;
 		break;
 	case DMA_BIDIRECTIONAL:
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+
+	if (!zfcp_fsf_set_data_dir(scsi_cmnd, &io->data_direction, fcp_cmnd_iu,
+				   &sbtype))
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 		goto failed_scsi_cmnd;
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	}
+#endif /* ! CONFIG_ZFCP_FOO_INTEGRITY */
 
 	if (likely((scsi_cmnd->device->simple_tags) ||
 		   ((atomic_read(&unit->status) & ZFCP_STATUS_UNIT_READONLY) &&
@@ -2426,13 +2575,34 @@ int zfcp_fsf_send_fcp_command_task(struc
 
 	memcpy(fcp_cmnd_iu->fcp_cdb, scsi_cmnd->cmnd, scsi_cmnd->cmd_len);
 
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	req->qtcb->bottom.io.fcp_cmnd_length = sizeof(struct fcp_cmnd_iu) +
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+	io->fcp_cmnd_length = sizeof(struct fcp_cmnd_iu) +
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 		fcp_cmnd_iu->add_fcp_cdb_length + sizeof(u32);
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	if (scsi_prot_sg_count(scsi_cmnd)) {
+		zfcp_qdio_set_data_div(qdio, &req->queue_req,
+				       scsi_prot_sg_count(scsi_cmnd));
+		dix_bytes = zfcp_qdio_sbals_from_sg(qdio, &req->queue_req,
+						    sbtype,
+						    scsi_prot_sglist(scsi_cmnd),
+						    FSF_MAX_SBALS_PER_REQ);
+		io->prot_data_length = dix_bytes;
+	}
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	real_bytes = zfcp_qdio_sbals_from_sg(qdio, &req->queue_req, sbtype,
 					     scsi_sglist(scsi_cmnd),
 					     FSF_MAX_SBALS_PER_REQ);
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	if (unlikely(real_bytes < 0)) {
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+
+	if (unlikely(real_bytes < 0) || unlikely(dix_bytes < 0)) {
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 		if (req->queue_req.sbal_number >= FSF_MAX_SBALS_PER_REQ) {
 			dev_err(&adapter->ccw_device->dev,
 				"Oversize data package, unit 0x%016Lx "
@@ -2445,8 +2615,17 @@ int zfcp_fsf_send_fcp_command_task(struc
 		goto failed_scsi_cmnd;
 	}
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	if (scsi_get_prot_type(scsi_cmnd) == SCSI_PROT_DIF_TYPE1)
+		real_bytes += real_bytes / scsi_cmnd->device->sector_size * 8;
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	zfcp_set_fcp_dl(fcp_cmnd_iu, real_bytes);
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	zfcp_qdio_set_sbale_last(adapter->qdio, &req->queue_req);
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	retval = zfcp_fsf_req_send(req);
 	if (unlikely(retval))
 		goto failed_scsi_cmnd;
@@ -2579,6 +2758,9 @@ struct zfcp_fsf_req *zfcp_fsf_control_fi
 		zfcp_fsf_req_free(req);
 		goto out;
 	}
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	zfcp_qdio_set_sbale_last(adapter->qdio, &req->queue_req);
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
 	zfcp_fsf_start_timer(req, ZFCP_FSF_REQUEST_TIMEOUT);
 	retval = zfcp_fsf_req_send(req);
--- a/drivers/s390/scsi/zfcp_fsf.h
+++ b/drivers/s390/scsi/zfcp_fsf.h
@@ -79,11 +79,20 @@
 #define FSF_REQUEST_SIZE_TOO_LARGE		0x00000061
 #define FSF_RESPONSE_SIZE_TOO_LARGE		0x00000062
 #define FSF_SBAL_MISMATCH			0x00000063
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+#define FSF_INCONSISTENT_PROT_DATA		0x00000070
+#define FSF_INVALID_PROT_PARM			0x00000071
+#define FSF_BLOCK_GUARD_CHECK_FAILURE		0x00000081
+#define FSF_APP_TAG_CHECK_FAILURE		0x00000082
+#define FSF_REF_TAG_CHECK_FAILURE		0x00000083
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 #define FSF_ADAPTER_STATUS_AVAILABLE		0x000000AD
 #define FSF_UNKNOWN_COMMAND			0x000000E2
 #define FSF_UNKNOWN_OP_SUBTYPE                  0x000000E3
 #define FSF_INVALID_COMMAND_OPTION              0x000000E5
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 /* #define FSF_ERROR                             0x000000FF  */
+#endif /* ! CONFIG_ZFCP_FOO_INTEGRITY */
 
 #define FSF_PROT_STATUS_QUAL_SIZE		16
 #define FSF_STATUS_QUALIFIER_SIZE		16
@@ -146,6 +155,15 @@
 #define FSF_DATADIR_WRITE			0x00000001
 #define FSF_DATADIR_READ			0x00000002
 #define FSF_DATADIR_CMND			0x00000004
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+#define FSF_DATADIR_DIF_WRITE_INSERT		0x00000009
+#define FSF_DATADIR_DIF_READ_STRIP		0x0000000a
+#define FSF_DATADIR_DIF_WRITE_CONVERT		0x0000000b
+#define FSF_DATADIR_DIF_READ_CONVERT		0X0000000c
+
+/* data protection control flags */
+#define FSF_APP_TAG_CHECK_ENABLE		0x10
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
 /* fc service class */
 #define FSF_CLASS_3				0x00000003
@@ -164,6 +182,10 @@
 #define FSF_FEATURE_ELS_CT_CHAINED_SBALS	0x00000020
 #define FSF_FEATURE_UPDATE_ALERT		0x00000100
 #define FSF_FEATURE_MEASUREMENT_DATA		0x00000200
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+#define FSF_FEATURE_DIF_PROT_TYPE1		0x00010000
+#define FSF_FEATURE_DIX_PROT_TCPIP		0x00020000
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
 /* host connection features */
 #define FSF_FEATURE_NPIV_MODE			0x00000001
@@ -332,9 +354,22 @@ struct fsf_plogi {
 struct fsf_qtcb_bottom_io {
 	u32 data_direction;
 	u32 service_class;
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	u8  res1[8];
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+	u8  res1;
+	u8  data_prot_flags;
+	u16 app_tag_value;
+	u32 ref_tag_value;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	u32 fcp_cmnd_length;
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	u8  res2[12];
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+	u32 data_block_length;
+	u32 prot_data_length;
+	u8  res2[4];
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	u8  fcp_cmnd[FSF_FCP_CMND_SIZE];
 	u8  fcp_rsp[FSF_FCP_RSP_SIZE];
 	u8  res3[64];
--- a/drivers/s390/scsi/zfcp_qdio.c
+++ b/drivers/s390/scsi/zfcp_qdio.c
@@ -237,6 +237,7 @@ static void zfcp_qdio_undo_sbals(struct
 	zfcp_qdio_zero_sbals(sbal, first, count);
 }
 
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 static int zfcp_qdio_fill_sbals(struct zfcp_qdio *qdio,
 				struct zfcp_queue_req *q_req,
 				unsigned int sbtype, void *start_addr,
@@ -266,6 +267,7 @@ static int zfcp_qdio_fill_sbals(struct z
 	return 0;
 }
 
+#endif /* ! CONFIG_ZFCP_FOO_INTEGRITY */
 /**
  * zfcp_qdio_sbals_from_sg - fill SBALs from scatter-gather list
  * @fsf_req: request to be processed
@@ -280,7 +282,11 @@ int zfcp_qdio_sbals_from_sg(struct zfcp_
 			    int max_sbals)
 {
 	struct qdio_buffer_element *sbale;
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	int retval, bytes = 0;
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+	int bytes = 0;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
 	/* figure out last allowed SBAL */
 	zfcp_qdio_sbal_limit(qdio, q_req, max_sbals);
@@ -290,17 +296,32 @@ int zfcp_qdio_sbals_from_sg(struct zfcp_
 	sbale->flags |= sbtype;
 
 	for (; sg; sg = sg_next(sg)) {
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 		retval = zfcp_qdio_fill_sbals(qdio, q_req, sbtype,
 					      sg_virt(sg), sg->length);
 		if (retval < 0)
 			return retval;
+#else /* CONFIG_ZFCP_FOO_INTEGRITY */
+		sbale = zfcp_qdio_sbale_next(qdio, q_req, sbtype);
+		if (!sbale) {
+			atomic_inc(&qdio->req_q_full);
+			zfcp_qdio_undo_sbals(qdio, q_req);
+			return -EINVAL;
+		}
+
+		sbale->addr = sg_virt(sg);
+		sbale->length = sg->length;
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 		bytes += sg->length;
 	}
 
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 	/* assume that no other SBALEs are to follow in the same SBAL */
 	sbale = zfcp_qdio_sbale_curr(qdio, q_req);
 	sbale->flags |= SBAL_FLAGS_LAST_ENTRY;
 
+#endif /* ! CONFIG_ZFCP_FOO_INTEGRITY */
 	return bytes;
 }
 
@@ -343,6 +364,9 @@ static void zfcp_qdio_setup_init_data(st
 	id->q_format = QDIO_ZFCP_QFMT;
 	memcpy(id->adapter_name, dev_name(&id->cdev->dev), 8);
 	ASCEBC(id->adapter_name, 8);
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	id->qib_rflags = QIB_RFLAGS_ENABLE_DATA_DIV;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	id->no_input_qs = 1;
 	id->no_output_qs = 1;
 	id->input_handler = zfcp_qdio_int_resp;
@@ -352,8 +376,13 @@ static void zfcp_qdio_setup_init_data(st
 		    QDIO_OUTBOUND_0COPY_SBALS | QDIO_USE_OUTBOUND_PCIS;
 	id->input_sbal_addr_array = (void **) (qdio->resp_q.sbal);
 	id->output_sbal_addr_array = (void **) (qdio->req_q.sbal);
+#ifndef CONFIG_ZFCP_FOO_INTEGRITY
 
+#endif /* ! CONFIG_ZFCP_FOO_INTEGRITY */
 }
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 /**
  * zfcp_qdio_allocate - allocate queue memory and initialize QDIO data
  * @adapter: pointer to struct zfcp_adapter
@@ -419,6 +448,9 @@ int zfcp_qdio_open(struct zfcp_qdio *qdi
 	struct qdio_buffer_element *sbale;
 	struct qdio_initialize init_data;
 	struct ccw_device *cdev = qdio->adapter->ccw_device;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+	struct qdio_ssqd_desc ssqd;
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 	int cc;
 
 	if (atomic_read(&qdio->adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP)
@@ -431,6 +463,15 @@ int zfcp_qdio_open(struct zfcp_qdio *qdi
 
 	if (qdio_establish(&init_data))
 		goto failed_establish;
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+
+	if (qdio_get_ssqd_desc(init_data.cdev, &ssqd))
+		goto failed_qdio;
+
+	if (ssqd.qdioac2 & CHSC_AC2_DATA_DIV_ENABLED)
+		atomic_set_mask(ZFCP_STATUS_ADAPTER_DATA_DIV_ENABLED,
+				&qdio->adapter->status);
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 
 	if (qdio_activate(cdev))
 		goto failed_qdio;
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -29,6 +29,15 @@ char *zfcp_get_fcp_sns_info_ptr(struct f
 	return fcp_sns_info_ptr;
 }
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+static bool enable_dif;
+
+#if defined(CONFIG_ZFCP_DIF) || defined(CONFIG_ZFCP_DIF_MODULE)
+module_param_named(dif, enable_dif, bool, 0600);
+MODULE_PARM_DESC(dif, "Enable DIF/DIX data integrity support");
+#endif
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth)
 {
 	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
@@ -674,6 +683,54 @@ static int zfcp_execute_fc_job(struct fc
 	}
 }
 
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+/**
+ * zfcp_scsi_set_prot - Configure DIF/DIX support in scsi_host
+ * @adapter: The adapter where to configure DIF/DIX for the SCSI host
+ */
+void zfcp_scsi_set_prot(struct zfcp_adapter *adapter)
+{
+	unsigned int mask = 0;
+	unsigned int data_div;
+	struct Scsi_Host *shost = adapter->scsi_host;
+
+	data_div = atomic_read(&adapter->status) &
+		   ZFCP_STATUS_ADAPTER_DATA_DIV_ENABLED;
+
+	if (enable_dif &&
+	    adapter->adapter_features & FSF_FEATURE_DIF_PROT_TYPE1)
+		mask |= SHOST_DIF_TYPE1_PROTECTION;
+
+	if (enable_dif && data_div &&
+	    adapter->adapter_features & FSF_FEATURE_DIX_PROT_TCPIP) {
+		mask |= SHOST_DIX_TYPE1_PROTECTION;
+		scsi_host_set_guard(shost, SHOST_DIX_GUARD_IP);
+		shost->sg_prot_tablesize = ZFCP_MAX_SBALES_PER_REQ / 2;
+		shost->sg_tablesize = ZFCP_MAX_SBALES_PER_REQ / 2;
+		shost->max_sectors = ZFCP_MAX_SBALES_PER_REQ * 8 / 2;
+	}
+
+	scsi_host_set_prot(shost, mask);
+}
+
+/**
+ * zfcp_scsi_dif_sense_error - Report DIF/DIX error as driver sense error
+ * @scmd: The SCSI command to report the error for
+ * @ascq: The ASCQ to put in the sense buffer
+ *
+ * See the error handling in sd_done for the sense codes used here.
+ * Set DID_SOFT_ERROR to retry the request, if possible.
+ */
+void zfcp_scsi_dif_sense_error(struct scsi_cmnd *scmd, int ascq)
+{
+	scsi_build_sense_buffer(1, scmd->sense_buffer,
+				ILLEGAL_REQUEST, 0x10, ascq);
+	set_driver_byte(scmd, DRIVER_SENSE);
+	scmd->result |= SAM_STAT_CHECK_CONDITION;
+	set_host_byte(scmd, DID_SOFT_ERROR);
+}
+
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,
@@ -725,6 +782,9 @@ struct zfcp_data zfcp_data = {
 		.use_clustering		 = 1,
 		.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
 		.max_sectors		 = (ZFCP_MAX_SBALES_PER_REQ * 8),
+#ifdef CONFIG_ZFCP_FOO_INTEGRITY
+		.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
+#endif /* CONFIG_ZFCP_FOO_INTEGRITY */
 		.shost_attrs		 = zfcp_sysfs_shost_attrs,
 	},
 };
--- a/drivers/scsi/Kconfig
+++ b/drivers/scsi/Kconfig
@@ -1863,6 +1863,10 @@ config ZFCP
           called zfcp. If you want to compile it as a module, say M here
           and read <file:Documentation/kbuild/modules.txt>.
 
+config ZFCP_DIF
+	tristate "T10 DIF/DIX support for the zfcp driver"
+	depends on ZFCP
+
 config SCSI_PMCRAID
 	tristate "PMC SIERRA Linux MaxRAID adapter support"
 	depends on PCI && SCSI
