From 3018d7b954d148e982aa3257321d354e75c74531 Mon Sep 17 00:00:00 2001
From: Jesse Larrew <jlarrew@linux.vnet.ibm.com>
Date: Tue, 26 Jul 2011 22:44:30 +0000
Subject: [PATCH] time: Normalize xtime after rounding.
Patch-mainline: pending, see below.
References: bnc#685226

Its possible after rounding for xtime to be technically
invalid (where the tv_nsec component is greater then a second
worth of nanoseconds).

Most vsyscall implementations normalize the timespec, so it
usually doesn't matter if xtime is non-normalized.

However, it  is really better to normalize xtime before sharing
it with the arch specific vsyscall code, so this patch pulls a
chunk of code already upstream to normalize xtime after doing
the rounding.

Fair warning: The change is from upstream and should be safe,
but I have not been able to test it myself against 2.6.32.

Signed-off-by: John Stultz <johnstul@us.ibm.com>
Signed-off-by: Jesse Larrew <jlarrew@linux.vnet.ibm.com>
Acked-by: Torsten Duwe <duwe@suse.de>

---
 arch/powerpc/kernel/time.c |   14 ++++++++++----
 1 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/arch/powerpc/kernel/time.c b/arch/powerpc/kernel/time.c
index 308eb66..dfd7bad 100644
--- a/arch/powerpc/kernel/time.c
+++ b/arch/powerpc/kernel/time.c
@@ -869,10 +869,16 @@ void update_vsyscall(struct timespec *wall_time, struct clocksource *clock,
 {
 	u64 t2x, stamp_xsec;
 	u32 frac_sec;
+	struct timespec wt = *wall_time;
 
 	if (clock != &clocksource_timebase)
 		return;
 
+	while (wt.tv_nsec >=NSEC_PER_SEC) {
+		wt.tv_nsec -= NSEC_PER_SEC;
+		wt.tv_sec++;
+	}
+
 	/* Make userspace gettimeofday spin until we're done. */
 	++vdso_data->tb_update_count;
 	smp_mb();
@@ -874,14 +880,13 @@ void update_vsyscall(struct timespec *wa
 	/* XXX this assumes clock->shift == 22 */
 	/* 4611686018 ~= 2^(20+64-22) / 1e9 */
 	t2x = (u64) mult * 4611686018ULL;
-	stamp_xsec = (u64) wall_time->tv_nsec * XSEC_PER_SEC;
+	stamp_xsec = (u64) wt.tv_nsec * XSEC_PER_SEC;
 	do_div(stamp_xsec, 1000000000);
-	stamp_xsec += (u64) wall_time->tv_sec * XSEC_PER_SEC;
+	stamp_xsec += (u64) wt.tv_sec * XSEC_PER_SEC;
 
-	BUG_ON(wall_time->tv_nsec >= NSEC_PER_SEC);
 	/* this is tv_nsec / 1e9 as a 0.32 fraction */
-	frac_sec = ((u64) wall_time->tv_nsec * 18446744073ULL) >> 32;
-	update_gtod(clock->cycle_last, stamp_xsec, t2x, wall_time, frac_sec);
+	frac_sec = ((u64) wt.tv_nsec * 18446744073ULL) >> 32;
+	update_gtod(clock->cycle_last, stamp_xsec, t2x, &wt, frac_sec);
 }
 
 void update_vsyscall_tz(void)
