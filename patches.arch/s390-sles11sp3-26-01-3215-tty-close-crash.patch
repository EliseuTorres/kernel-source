From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Subject: kernel: 3215 tty close crash
Patch-mainline: not yet
Git-commit: -
References: bnc#915209, LTC#120873

Description:  kernel: 3215 tty close crash
Symptom:      Kernel oops caused by a NULL pointer during 3215 tty close.
Problem:      The 3215 tty shutdown function tty3215_close first sets the
              tty pointer to NULL and then stops the tty wakeup tasklet.
              The raw3215_wakeup function checks the tty pointer for NULL
              but does not have a barrier between the check and the call
              to tty_wakeup. This opens a small race window where the
              tty3215_close function can clear the tty pointer and
              tty_wakeup is called with a NULL pointer.
Solution:     Reorder the code in tty3215_close to first kill the tasklet
              and then set the tty pointer to NULL. Add a barrier to
              raw3215_wakeup to stop the compiler from reading raw->tty
              twice and add an additional check to test tty->closing.
Reproduction: While running without a login on the 3215 tty, repeatedly
              open the tty, print some text and immediately close the tty
              again.

Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
--- a/drivers/s390/char/con3215.c
+++ b/drivers/s390/char/con3215.c
@@ -342,8 +342,12 @@ static inline void raw3215_try_io(struct
 static void raw3215_wakeup(unsigned long data)
 {
 	struct raw3215_info *raw = (struct raw3215_info *) data;
-	if (raw->tty)
-		tty_wakeup(raw->tty);
+	struct tty_struct *tty;
+
+	tty = raw->tty;
+	barrier();
+	if (tty && !tty->closing)
+		tty_wakeup(tty);
 }
 
 /*
@@ -976,8 +980,8 @@ static void tty3215_close(struct tty_str
 	tty->closing = 1;
 	/* Shutdown the terminal */
 	raw3215_shutdown(raw);
-	raw->tty = NULL;
 	tasklet_kill(&raw->tlet);
+	raw->tty = NULL;
 	tty->closing = 0;
 }
 
