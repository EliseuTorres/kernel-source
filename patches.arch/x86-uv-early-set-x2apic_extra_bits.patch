From: Jack Steiner <steiner@sgi.com>
Subject: x86 / UV: Fix uv_acpi_madt_oem_check()
References: bnc#658829
Patch-mainline: v2.6.38-rc1
Git-commit: d8850ba425d9823d3184bd52f065899dac4689f9

UV systems can be partitioned into multiple independent SSIs.
Large partitioned systems may have extra bits in the node_id register.
These bits are used when the total memory on all SSIs exceeds 16TB.
These extra bits need to be ignored when calculating
x2apic_extra_bits.

Signed-off-by: Jack Steiner <steiner@sgi.com>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---
 arch/x86/kernel/apic/x2apic_uv_x.c |   14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

Index: linux-2.6.32-SLE11-SP1/arch/x86/kernel/apic/x2apic_uv_x.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/kernel/apic/x2apic_uv_x.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/kernel/apic/x2apic_uv_x.c
@@ -72,15 +72,19 @@ static int uv_is_untracked_pat_range(u64
 	return is_ISA_range(start, end) || is_GRU_range(start, end);
 }
 
-static int __init early_get_nodeid(void)
+static int __init early_get_pnodeid(void)
 {
 	union uvh_node_id_u node_id;
+	union uvh_si_addr_map_config_u m_n_config;
+	int pnode;
 
 	/* Currently, all blades have same revision number */
 	node_id.v = uv_early_read_mmr(UVH_NODE_ID);
+	m_n_config.v = uv_early_read_mmr(UVH_SI_ADDR_MAP_CONFIG);
 	uv_min_hub_revision_id = node_id.s.revision;
 
-	return node_id.s.node_id;
+	pnode = (node_id.s.node_id >> 1) & ((1 << m_n_config.s.n_skt) - 1);
+	return pnode;
 }
 
 /*
@@ -108,10 +112,10 @@ static void __init early_get_apic_pnode_
 
 static int __init uv_acpi_madt_oem_check(char *oem_id, char *oem_table_id)
 {
-	int nodeid;
+	int pnodeid;
 
 	if (!strcmp(oem_id, "SGI")) {
-		nodeid = early_get_nodeid();
+		pnodeid = early_get_pnodeid();
 		early_get_apic_pnode_shift();
 		x86_platform.is_untracked_pat_range =  uv_is_untracked_pat_range;
 		x86_platform.nmi_init = uv_nmi_init;
@@ -122,7 +126,7 @@ static int __init uv_acpi_madt_oem_check
 			uv_system_type = UV_X2APIC;
 		else if (!strcmp(oem_table_id, "UVH")) {
 			__get_cpu_var(x2apic_extra_bits) =
-				nodeid << (uvh_apicid.s.pnode_shift - 1);
+				pnodeid << uvh_apicid.s.pnode_shift;
 			uv_system_type = UV_NON_UNIQUE_APIC;
 			uv_set_apicid_hibit();
 			return 1;


