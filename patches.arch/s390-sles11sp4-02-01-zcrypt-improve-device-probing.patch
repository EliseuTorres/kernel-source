From: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
Subject: zcrypt: Early hwrng request prevent crypto devices to get online
Patch-mainline: v3.16-rc7
Git-commit: 666e68e0dde826ae146b980099f1719f74fa968c
References: bnc#923450,LTC#122974

Description:  zcrypt: Early hwrng request prevent crypto devices to get online
Symptom:      When one of the crypto adapters is configured as cca coprocessor,
              the device registration process chain will be interrupted by the
              rng request. Potentially other configured crypto devices fail to
              register and do not appear online.
Problem:      A new common code feature (seed kernel entropy with hwrng) was
              introduced to seed the kernel entropy by using hardware devices.
              In case a hardware random number generator is available, e.g.
              cca-coprocessor adapter (CEX3C, CEX4C or CEX5C) this device will
              be requested immediately (at registration time) to generate 
              random numbers. 
              This rng request comes in a very early stage. At this point in
              time the registration process is not fully completed and the
              hardware crypto device is not yet ready to service requests.
Solution:     Change the zcrypt device registration process that early 
              requests can be serviced.
Reproduction: Load the ap device driver on a system that have at least one cca
              coprocessor adapter configured. Check if all defined crypto 
              adapters are online by using lszcrypt.

Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/crypto/ap_bus.c |    9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@ -933,10 +933,15 @@ static int ap_device_probe(struct device
 	int rc;
 
 	ap_dev->drv = ap_drv;
+
+	spin_lock_bh(&ap_device_list_lock);
+	list_add(&ap_dev->list, &ap_device_list);
+	spin_unlock_bh(&ap_device_list_lock);
+
 	rc = ap_drv->probe ? ap_drv->probe(ap_dev) : -ENODEV;
-	if (!rc) {
+	if (rc) {
 		spin_lock_bh(&ap_device_list_lock);
-		list_add(&ap_dev->list, &ap_device_list);
+		list_del_init(&ap_dev->list);
 		spin_unlock_bh(&ap_device_list_lock);
 	}
 	return rc;
