From: Mike Wolf <mjw@linux.vnet.ibm.com>
Subject: powerpc/ptrace: Remove BUG_ON when full register set not available
Patch-mainline: torvalds/linux-2.6.git;a=commitdiff;h=a71f5d5d279375205009a4be56a3cf6682921292
References: bnc#682941

    
    In some cases during a threaded core dump not all the threads will have
    a full register set. This happens when the signal causing the core dump
    races with a thread exiting.  The race happens when the exiting thread
    has entered the kernel for the last time before the signal arrives, but
    doesn't get far enough through the exit code to avoid being included
    in the core dump.
    
    So we get a thread included in the core dump which is never going to go
    out to userspace again and only has a partial register set recorded
    
    Normally we would catch each thread as it is about to go into userspace
    and capture the full register set then.
    
    However, this exiting thread is never going to go out to userspace
    again, so we have no way to capture its full register set.  It doesn't
    really matter, though, as this is a thread which is effectively
    already dead.
    
    So instead of hitting a BUG() in this case (a really bad choice of
    action in the first place), we use a poison value for the register
    values.
    
    [BenH]: Some cosmetic/stylistic changes and fix build on ppc32
    
Signed-off-by: Mike Wolf <mjw@linux.vnet.ibm.com>
Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Acked-by: Torsten Duwe <duwe@suse.de>

diff -Naur linux-2.6.32.orig/arch/powerpc/include/asm/ptrace.h linux-2.6.32/arch/powerpc/include/asm/ptrace.h
--- linux-2.6.32.orig/arch/powerpc/include/asm/ptrace.h	2011-03-25 20:42:24.000000000 -0500
+++ linux-2.6.32/arch/powerpc/include/asm/ptrace.h	2011-03-25 21:20:54.000000000 -0500
@@ -122,8 +122,10 @@
 #endif /* ! __powerpc64__ */
 #define TRAP(regs)		((regs)->trap & ~0xF)
 #ifdef __powerpc64__
+#define NV_REG_POISON		0xdeadbeefdeadbeefUL
 #define CHECK_FULL_REGS(regs)	BUG_ON(regs->trap & 1)
 #else
+#define NV_REG_POISON		0xdeadbeef
 #define CHECK_FULL_REGS(regs)						      \
 do {									      \
 	if ((regs)->trap & 1)						      \
diff -Naur linux-2.6.32.orig/arch/powerpc/kernel/ptrace.c linux-2.6.32/arch/powerpc/kernel/ptrace.c
--- linux-2.6.32.orig/arch/powerpc/kernel/ptrace.c	2011-03-25 20:42:25.000000000 -0500
+++ linux-2.6.32/arch/powerpc/kernel/ptrace.c	2011-03-25 21:20:54.000000000 -0500
@@ -124,12 +124,16 @@
 		   unsigned int pos, unsigned int count,
 		   void *kbuf, void __user *ubuf)
 {
-	int ret;
+	int i, ret;
 
 	if (target->thread.regs == NULL)
 		return -EIO;
 
-	CHECK_FULL_REGS(target->thread.regs);
+	if (!FULL_REGS(target->thread.regs)) {
+		/* We have a partial register set.  Fill 14-31 with bogus values */
+		for (i = 14; i < 32; i++)
+			target->thread.regs->gpr[i] = NV_REG_POISON;
+	}
 
 	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
 				  target->thread.regs,
@@ -536,11 +540,16 @@
 	compat_ulong_t *k = kbuf;
 	compat_ulong_t __user *u = ubuf;
 	compat_ulong_t reg;
+	int i;
 
 	if (target->thread.regs == NULL)
 		return -EIO;
 
-	CHECK_FULL_REGS(target->thread.regs);
+	if (!FULL_REGS(target->thread.regs)) {
+		/* We have a partial register set.  Fill 14-31 with bogus values */
+		for (i = 14; i < 32; i++)
+			target->thread.regs->gpr[i] = NV_REG_POISON; 
+	}
 
 	pos /= sizeof(reg);
 	count /= sizeof(reg);
