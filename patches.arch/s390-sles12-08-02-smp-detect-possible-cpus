From: Heiko Carstens <heiko.carstens@de.ibm.com>
Subject: s390/smp: limit number of cpus in possible cpu mask
Git-commit: cf813db0b448b45b454f0983329c3c7b007f9ab7
Patch-mainline: v3.15-rc1
References: bnc#881529, LTC#111065

 s390/smp: limit number of cpus in possible cpu mask

Limit the number of bits to the maximum number of cpus a machine
can have.
possible_cpu_mask typically will have more bits set than a machine
may physically have. This results in wasted memory during per-cpu
memory allocations, if the possible mask contains more cpus than
physically possible for a given configuration.

Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: Torsten Duwe <duwe@suse.de>

Index: linux-3.12-SLE12/arch/s390/include/asm/sclp.h
===================================================================
--- linux-3.12-SLE12.orig/arch/s390/include/asm/sclp.h
+++ linux-3.12-SLE12/arch/s390/include/asm/sclp.h
@@ -47,6 +47,7 @@ int sclp_cpu_deconfigure(u8 cpu);
 void sclp_facilities_detect(void);
 unsigned long long sclp_get_rnmax(void);
 unsigned long long sclp_get_rzm(void);
+unsigned int sclp_get_max_cpu(void);
 int sclp_sdias_blk_count(void);
 int sclp_sdias_copy(void *dest, int blk_num, int nr_blks);
 int sclp_chp_configure(struct chp_id chpid);
Index: linux-3.12-SLE12/arch/s390/kernel/smp.c
===================================================================
--- linux-3.12-SLE12.orig/arch/s390/kernel/smp.c
+++ linux-3.12-SLE12/arch/s390/kernel/smp.c
@@ -782,11 +782,11 @@ void __noreturn cpu_die(void)
 
 void __init smp_fill_possible_mask(void)
 {
-	unsigned int possible, cpu;
+	unsigned int possible, sclp, cpu;
 
-	possible = setup_possible_cpus;
-	if (!possible)
-		possible = MACHINE_IS_VM ? 64 : nr_cpu_ids;
+	sclp = sclp_get_max_cpu() ?: nr_cpu_ids;
+	possible = setup_possible_cpus ?: nr_cpu_ids;
+	possible = min(possible, sclp);
 	for (cpu = 0; cpu < possible && cpu < nr_cpu_ids; cpu++)
 		set_cpu_possible(cpu, true);
 }
Index: linux-3.12-SLE12/drivers/s390/char/sclp_cmd.c
===================================================================
--- linux-3.12-SLE12.orig/drivers/s390/char/sclp_cmd.c
+++ linux-3.12-SLE12/drivers/s390/char/sclp_cmd.c
@@ -35,7 +35,9 @@ struct read_info_sccb {
 	struct	sccb_header header;	/* 0-7 */
 	u16	rnmax;			/* 8-9 */
 	u8	rnsize;			/* 10 */
-	u8	_reserved0[24 - 11];	/* 11-15 */
+	u8	_reserved0[16 - 11];	/* 11-15 */
+	u16	ncpurl;			/* 16-17 */
+	u8	_reserved7[24 - 18];	/* 18-23 */
 	u8	loadparm[8];		/* 24-31 */
 	u8	_reserved1[48 - 32];	/* 32-47 */
 	u64	facilities;		/* 48-55 */
@@ -47,12 +49,15 @@ struct read_info_sccb {
 	u8	_reserved4[100 - 92];	/* 92-99 */
 	u32	rnsize2;		/* 100-103 */
 	u64	rnmax2;			/* 104-111 */
-	u8	_reserved5[4096 - 112];	/* 112-4095 */
+	u8	_reserved5[120 - 112];	/* 112-119 */
+	u16	hcpua;			/* 120-121 */
+	u8	_reserved6[4096 - 122];	/* 122-4095 */
 } __attribute__((packed, aligned(PAGE_SIZE)));
 
 static struct init_sccb __initdata early_event_mask_sccb __aligned(PAGE_SIZE);
 static struct read_info_sccb __initdata early_read_info_sccb;
 static int __initdata early_read_info_sccb_valid;
+static unsigned int sclp_max_cpu;
 
 u64 sclp_facilities;
 static u8 sclp_fac84;
@@ -136,6 +141,15 @@ void __init sclp_facilities_detect(void)
 	rzm = sccb->rnsize ? sccb->rnsize : sccb->rnsize2;
 	rzm <<= 20;
 
+	if (!sccb->hcpua) {
+		if (MACHINE_IS_VM)
+			sclp_max_cpu = 64;
+		else
+			sclp_max_cpu = sccb->ncpurl;
+	} else {
+		sclp_max_cpu = sccb->hcpua + 1;
+	}
+
 	sclp_event_mask_early();
 }
 
@@ -173,6 +187,11 @@ unsigned long long sclp_get_rzm(void)
 	return rzm;
 }
 
+unsigned int sclp_get_max_cpu(void)
+{
+	return sclp_max_cpu;
+}
+
 /*
  * This function will be called after sclp_facilities_detect(), which gets
  * called from early.c code. Therefore the sccb should have valid contents.
