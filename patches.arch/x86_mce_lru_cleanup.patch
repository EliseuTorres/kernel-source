From: Andi Kleen <andi@firstfloor.org>
Subject: HWPOISON: Undefine lru define after table to avoid namespace conflict
References: fate#307738
Patch-Mainline: In Andi's mce subtree queued for 2.6.33 inclusion
Commit-ID: ac5f573ffd10e22e988c3e309a17a4721fdbe100

Signed-off-by: Thomas Renninger <trenn@suse.de>

Free the "lru" identifier after the lookup table so that we can
use page->lru again.

Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/mm/memory-failure.c b/mm/memory-failure.c
index dacc641..6f388a7 100644
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@ -597,6 +597,8 @@ static struct page_state {
 	{ 0,		0,		"unknown page state",	me_unknown },
 };
 
+#undef lru
+
 static void action_result(unsigned long pfn, char *msg, int result)
 {
 	struct page *page = NULL;
@@ -769,7 +771,7 @@ int __memory_failure(unsigned long pfn, int trapno, int ref)
 	 */
 	if (!PageLRU(p))
 		lru_add_drain_all();
-	lru_flag = p->flags & lru;
+	lru_flag = p->flags & (1UL << PG_lru);
 	if (isolate_lru_page(p)) {
 		action_result(pfn, "non LRU", IGNORED);
 		put_page(p);
@@ -793,7 +795,7 @@ int __memory_failure(unsigned long pfn, int trapno, int ref)
 	/*
 	 * Torn down by someone else?
 	 */
-	if ((lru_flag & lru) && !PageSwapCache(p) && p->mapping == NULL) {
+	if (test_bit(PG_lru, &lru_flag) && !PageSwapCache(p) && p->mapping == NULL) {
 		action_result(pfn, "already truncated LRU", IGNORED);
 		res = 0;
 		goto out;
