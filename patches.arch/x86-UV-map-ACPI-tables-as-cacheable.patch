From: Jack Steiner <steiner@sgi.com>
Subject: x86 / UV: Map ACPI tables as cacheable
References: bnc#632974, FATE#306952
Patch-Mainline: No

The following patch affects ONLY UV systems. A variant of the patch
has been pushed upstream & is still being discussed. The final solution
be different from the following but will have the same affect on UV.

The upstream discussion starts with:
	http://marc.info/?l=linux-kernel&m=128206079905826&w=2
	http://marc.info/?t=127981233400001&r=1&w=2
	http://marc.info/?l=linux-acpi&m=127981216021823&w=2

Large SGI UV systems (3072p, 5TB) take a long time to boot. A significant
part of the boot time is scanning ACPI tables. ACPI tables on UV systems
are located in RAM memory that is physically attached to node 0.

User programs (ex., acpidump) read the ACPI tables by mapping them thru
/dev/mem.  Although mmap tries to map the tables as CACHED, there are
existing kernel UNCACHED mapping that conflict and the tables end up as
being mapped UNCACHED.  (See the call to track_pfn_vma_new() in
remap_pfn_range()).

Much of the access is to small fields (bytes (checksums), shorts, etc).
Late in boot, there is significant scanning of the ACPI tables that take
place from nodes other than zero. Since the tables are not cached, each
reference accesses physical memory that is attached to remote nodes. These
memory requests must cross the numalink interconnect which adds several
hundred nsec to each access. This slows the boot process.  Access from
node 0, although faster, is still very slow.

The following patch changes the kernel mapping for ACPI tables
to CACHED. This eliminates the page attibute conflict & allows users
to map the tables CACHEABLE. This significantly speeds up boot:

        38 minutes without the patch
        27 minutes with the patch
                ~30% improvement

Time to run ACPIDUMP on a large system:
        527 seconds without the patch
          8 seconds with the patch

Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---
 arch/x86/kernel/apic/x2apic_uv_x.c |    2 ++
 drivers/acpi/osl.c                 |   20 +++++++++++++++++---
 include/acpi/acpiosxf.h            |    5 +++++
 3 files changed, 24 insertions(+), 3 deletions(-)

Index: linux-2.6.32-SLE11-SP1/arch/x86/kernel/apic/x2apic_uv_x.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/kernel/apic/x2apic_uv_x.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/kernel/apic/x2apic_uv_x.c
@@ -22,6 +22,7 @@
 #include <linux/io.h>
 #include <linux/pci.h>
 #include <linux/kdebug.h>
+#include <acpi/acpi.h>
 #ifdef CONFIG_KDB
 #include <linux/kdb.h>
 #endif
@@ -81,6 +82,7 @@ static int __init uv_acpi_madt_oem_check
 		nodeid = early_get_nodeid();
 		x86_platform.is_untracked_pat_range =  uv_is_untracked_pat_range;
 		x86_platform.nmi_init = uv_nmi_init;
+		acpi_set_iomap_cacheable();
 		if (!strcmp(oem_table_id, "UVL"))
 			uv_system_type = UV_LEGACY_APIC;
 		else if (!strcmp(oem_table_id, "UVX"))
Index: linux-2.6.32-SLE11-SP1/drivers/acpi/osl.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/drivers/acpi/osl.c
+++ linux-2.6.32-SLE11-SP1/drivers/acpi/osl.c
@@ -81,6 +81,7 @@ static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
 static struct workqueue_struct *kacpi_notify_wq;
 static struct workqueue_struct *kacpi_hotplug_wq;
+static int acpi_iomap_cacheable;
 
 struct acpi_res_list {
 	resource_size_t start;
@@ -191,6 +192,11 @@ acpi_status __init acpi_os_initialize(vo
 	return AE_OK;
 }
 
+void acpi_set_iomap_cacheable(void)
+{
+	acpi_iomap_cacheable = 1;
+}
+
 static void bind_to_cpu0(struct work_struct *work)
 {
 	set_cpus_allowed_ptr(current, cpumask_of(0));
@@ -293,12 +299,20 @@ acpi_os_map_memory(acpi_physical_address
 		printk(KERN_ERR PREFIX "Cannot map memory that high\n");
 		return NULL;
 	}
-	if (acpi_gbl_permanent_mmap)
+	if (acpi_gbl_permanent_mmap) {
 		/*
 		* ioremap checks to ensure this is in reserved space
 		*/
-		return ioremap((unsigned long)phys, size);
-	else
+#ifdef CONFIG_X86_64
+		if (acpi_iomap_cacheable &&
+				(e820_all_mapped(phys, phys + size, E820_RAM) ||
+				e820_all_mapped(phys, phys + size, E820_ACPI) ||
+				e820_all_mapped(phys, phys + size, E820_NVS)))
+			return ioremap_cache((unsigned long)phys, size);
+		else
+#endif
+			return ioremap((unsigned long)phys, size);
+	} else
 		return __acpi_map_table((unsigned long)phys, size);
 }
 EXPORT_SYMBOL_GPL(acpi_os_map_memory);
Index: linux-2.6.32-SLE11-SP1/include/acpi/acpiosxf.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/acpi/acpiosxf.h
+++ linux-2.6.32-SLE11-SP1/include/acpi/acpiosxf.h
@@ -96,6 +96,11 @@ acpi_os_table_override(struct acpi_table
 		       struct acpi_table_header **new_table);
 
 /*
+ * Map acpi tables as WB - (UV only)
+ */
+void acpi_set_iomap_cacheable(void);
+
+/*
  * Spinlock primitives
  */
 acpi_status acpi_os_create_lock(acpi_spinlock * out_handle);
