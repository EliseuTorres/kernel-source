From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: zfcp: Do not wait for SBALs on stopped queue
References: bnc#607890,LTC#64249
Patch-mainline: Yes

Symptom:     Reading the FC host statistics on an offline FCP
             subchannel results in a 5 seconds wait.
Problem:     When issuing a non-I/O request, zfcp waits for up to 
             5 seconds for a free SBAL on the request queue. Only
             after getting a free SBAL or the 5 seconds expire,
             the waiting process continues.
Solution:    Also exit the wait when the request queue is not active.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/scsi/zfcp_fsf.c  |   13 +++++++------
 drivers/s390/scsi/zfcp_qdio.c |    2 ++
 2 files changed, 9 insertions(+), 6 deletions(-)

--- a/drivers/s390/scsi/zfcp_fsf.c	2010-05-20 16:03:51.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_fsf.c	2010-05-20 16:08:10.000000000 +0200
@@ -640,7 +640,8 @@ static int zfcp_fsf_sbal_check(struct zf
 	struct zfcp_qdio_queue *req_q = &qdio->req_q;
 
 	spin_lock_bh(&qdio->req_q_lock);
-	if (atomic_read(&req_q->count))
+	if (atomic_read(&req_q->count) ||
+	    !(atomic_read(&qdio->adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP))
 		return 1;
 	spin_unlock_bh(&qdio->req_q_lock);
 	return 0;
@@ -654,8 +655,13 @@ static int zfcp_fsf_req_sbal_get(struct 
 	spin_unlock_bh(&qdio->req_q_lock);
 	ret = wait_event_interruptible_timeout(qdio->req_q_wq,
 			       zfcp_fsf_sbal_check(qdio), 5 * HZ);
+
+	if (!(atomic_read(&qdio->adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP))
+		return -EIO;
+
 	if (ret > 0)
 		return 0;
+
 	if (!ret) {
 		atomic_inc(&qdio->req_q_full);
 		/* assume hanging outbound queue, try queue recovery */
@@ -753,11 +759,6 @@ static struct zfcp_fsf_req *zfcp_fsf_req
 		sbale[1].length = sizeof(struct fsf_qtcb);
 	}
 
-	if (!(atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP)) {
-		zfcp_fsf_req_free(req);
-		return ERR_PTR(-EIO);
-	}
-
 	return req;
 }
 
--- a/drivers/s390/scsi/zfcp_qdio.c	2010-05-20 16:03:51.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_qdio.c	2010-05-20 16:03:52.000000000 +0200
@@ -392,6 +392,8 @@ void zfcp_qdio_close(struct zfcp_qdio *q
 	atomic_clear_mask(ZFCP_STATUS_ADAPTER_QDIOUP, &qdio->adapter->status);
 	spin_unlock_bh(&qdio->req_q_lock);
 
+	wake_up(&qdio->req_q_wq);
+
 	qdio_shutdown(qdio->adapter->ccw_device,
 		      QDIO_FLAG_CLEANUP_USING_CLEAR);
 
