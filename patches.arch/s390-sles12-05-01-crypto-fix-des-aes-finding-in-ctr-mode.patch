From: Harald Freudenberger <freude@linux.vnet.ibm.com>
Subject: crypto: s390 - fix aes,des ctr mode concurrency finding
Patch-mainline: not yet
Git-commit: -
References: bnc#877098, LTC#110078

Description:  crypto: s390 - fix aes,des ctr mode concurrency finding
Symptom:      Possible data corruption with concurrent use of s390 des, 3des
              or aes in ctr mode.
Problem:      In concurrent situations the s390 ctr algorithms use one
              memory page for ctr processing. If this page is in use by the
              first process/thread the second invocation uses a fallback
              code path. At the end of this fallback path the updated iv
              value is not in all cases copied back to be available for the
              next operation.
              This only happens on concurrent use of the same tfm struct
              and when the fallback path is invoced.
Solution:     Very small codechange which makes sure the iv value is
              copied back to the tfm struct after operation in the fallback
              code path.
Reproduction: Concurrent use of s390 des, 3des or ares ctr mode, eg. via
              multithreaded testcase on top of the af_alg kernel crypto
              interface.

Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/crypto/aes_s390.c |    3 +++
 arch/s390/crypto/des_s390.c |    3 +++
 2 files changed, 6 insertions(+)

--- a/arch/s390/crypto/aes_s390.c
+++ b/arch/s390/crypto/aes_s390.c
@@ -818,6 +818,9 @@ static int ctr_aes_crypt(struct blkciphe
 		else
 			memcpy(walk->iv, ctrptr, AES_BLOCK_SIZE);
 		spin_unlock(&ctrblk_lock);
+	} else {
+		if (!nbytes)
+			memcpy(walk->iv, ctrptr, AES_BLOCK_SIZE);
 	}
 	/*
 	 * final block may be < AES_BLOCK_SIZE, copy only nbytes
--- a/arch/s390/crypto/des_s390.c
+++ b/arch/s390/crypto/des_s390.c
@@ -429,6 +429,9 @@ static int ctr_desall_crypt(struct blkci
 		else
 			memcpy(walk->iv, ctrptr, DES_BLOCK_SIZE);
 		spin_unlock(&ctrblk_lock);
+	} else {
+		if (!nbytes)
+			memcpy(walk->iv, ctrptr, DES_BLOCK_SIZE);
 	}
 	/* final block may be < DES_BLOCK_SIZE, copy only nbytes */
 	if (nbytes) {
