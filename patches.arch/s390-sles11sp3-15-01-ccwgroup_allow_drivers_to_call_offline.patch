Subject: [PATCH] [FEAT NET1213] qeth: Support VEPA mode
From: Stefan Raspl <raspl@linux.vnet.ibm.com>
Patch-mainline: v3.8-rc1
Git-commit: 683c3dcef439f969b2c7fd09b60144cb4e2155a5
References: bnc#794532,FATE#314595

Summary:     qeth: Support VEPA mode
Description: The existing port isolation mode 'forward' will now verify that
             the adjacent switch port supports the required reflective relay
             (RR) mode. This patch adds the required error handling for the
             cases where enabling port isolation mode 'forward' can now fail.
             Furthermore, once established, we never fall back from one of the
             port isolation modes to a non-isolated mode without further user-
             interaction. This includes cases where the isolation mode was
             enabled successfully, but ceases to work e.g. due to configuration
             changes at the switch port.
             Finally, configuring an isolation mode with the device being
             offline will make onlining the device fail permanently upon errors
             encountered until either errors are resolved or the isolation mode
             is changed by the user to a different mode.

Signed-off-by: Stefan Raspl <raspl@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
--- a/arch/s390/include/asm/ccwgroup.h
+++ b/arch/s390/include/asm/ccwgroup.h
@@ -61,6 +61,9 @@ extern void ccwgroup_driver_unregister (
 int ccwgroup_create_dev(struct device *root, struct ccwgroup_driver *gdrv,
 			int num_devices, const char *buf);
 
+int ccwgroup_set_online(struct ccwgroup_device *gdev);
+int ccwgroup_set_offline(struct ccwgroup_device *gdev);
+
 extern int ccwgroup_probe_ccwdev(struct ccw_device *cdev);
 extern void ccwgroup_remove_ccwdev(struct ccw_device *cdev);
 
--- a/drivers/s390/cio/ccwgroup.c
+++ b/drivers/s390/cio/ccwgroup.c
@@ -65,7 +65,16 @@ static void __ccwgroup_remove_cdev_refs(
 	}
 }
 
-static int ccwgroup_set_online(struct ccwgroup_device *gdev)
+/**
+ * ccwgroup_set_online() - enable a ccwgroup device
+ * @gdev: target ccwgroup device
+ *
+ * This function calls the driver's set_online() function and -if successfull-
+ * changes the state to CCWGROUP_ONLINE.
+ * Returns:
+ *   %0 on success and a negative error value on failure.
+ */
+int ccwgroup_set_online(struct ccwgroup_device *gdev)
 {
 	struct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);
 	int ret = 0;
@@ -84,8 +93,18 @@ out:
 	atomic_set(&gdev->onoff, 0);
 	return ret;
 }
+EXPORT_SYMBOL(ccwgroup_set_online);
 
-static int ccwgroup_set_offline(struct ccwgroup_device *gdev)
+/**
+ * ccwgroup_set_offline() - disable a ccwgroup device
+ * @gdev: target ccwgroup device
+ *
+ * This function calls the driver's set_offline() function and -if successfull-
+ * changes the state to CCWGROUP_OFFLINE.
+ * Returns:
+ *   %0 on success and a negative error value on failure.
+ */
+int ccwgroup_set_offline(struct ccwgroup_device *gdev)
 {
 	struct ccwgroup_driver *gdrv = to_ccwgroupdrv(gdev->dev.driver);
 	int ret = 0;
@@ -104,6 +123,7 @@ out:
 	atomic_set(&gdev->onoff, 0);
 	return ret;
 }
+EXPORT_SYMBOL(ccwgroup_set_offline);
 
 static ssize_t ccwgroup_online_store(struct device *dev,
 				     struct device_attribute *attr,
