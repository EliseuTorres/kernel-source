From: Philippe Bergheaud <felix@linux.vnet.ibm.com>
Subject: powerpc/crashdump : fix page frame number check in copy_oldmem_page
Git-commit: f5295bd8ea8a65dc5eac608b151386314cb978f1
Patch-mainline: git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc.git
References: bnc#865994 fate#315275, LTC#104787
X-Patchwork-Id: 323688

Summary:     SLES 12 - Additional POWER LE kernel patches for SLES 12 Beta2
Description: Add little-endian support for POWER8.

Upstream-Description:

    In copy_oldmem_page, the current check using max_pfn and min_low_pfn to
    decide if the page is backed or not, is not valid when the memory layout is
    not continuous.
    
    This happens when running as a QEMU/KVM guest, where RTAS is mapped higher
    in the memory. In that case max_pfn points to the end of RTAS, and a hole
    between the end of the kdump kernel and RTAS is not backed by PTEs. As a
    consequence, the kdump kernel is crashing in copy_oldmem_page when accessing
    in a direct way the pages in that hole.
    
    This fix relies on the memblock's service memblock_is_region_memory to
    check if the read page is part or not of the directly accessible memory.
    
Signed-off-by: Laurent Dufour <ldufour@linux.vnet.ibm.com>
    Tested-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>

Signed-off-by: Philippe Bergheaud <felix@linux.vnet.ibm.com>
Acked-by: Torsten Duwe <duwe@suse.de>
---
arch/powerpc/kernel/crash_dump.c |    8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/kernel/crash_dump.c b/arch/powerpc/kernel/crash_dump.c
index 11c1d06..7a13f37 100644
--- a/arch/powerpc/kernel/crash_dump.c
+++ b/arch/powerpc/kernel/crash_dump.c
@@ -98,17 +98,19 @@ ssize_t copy_oldmem_page(unsigned long pfn, char *buf,
 			size_t csize, unsigned long offset, int userbuf)
 {
 	void  *vaddr;
+	phys_addr_t paddr;
 
 	if (!csize)
 		return 0;
 
 	csize = min_t(size_t, csize, PAGE_SIZE);
+	paddr = pfn << PAGE_SHIFT;
 
-	if ((min_low_pfn < pfn) && (pfn < max_pfn)) {
-		vaddr = __va(pfn << PAGE_SHIFT);
+	if (memblock_is_region_memory(paddr, csize)) {
+		vaddr = __va(paddr);
 		csize = copy_oldmem_vaddr(vaddr, buf, csize, offset, userbuf);
 	} else {
-		vaddr = __ioremap(pfn << PAGE_SHIFT, PAGE_SIZE, 0);
+		vaddr = __ioremap(paddr, PAGE_SIZE, 0);
 		csize = copy_oldmem_vaddr(vaddr, buf, csize, offset, userbuf);
 		iounmap(vaddr);
 	}
