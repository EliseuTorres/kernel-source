From d8d21f8c7c464999c837894d5f583f756e26e79c Mon Sep 17 00:00:00 2001
From: Feng Kan <fkan@apm.com>
Date: Thu, 28 Aug 2014 12:00:05 +0530
Subject: [PATCH 22/38] irqchip: gic: preserve gic V2 bypass bits in cpu ctrl
 register
Git-commit: 3228950621d92f0f212378f95a6998ef3a1be0bb
Patch-mainline: v3.18-rc1
References: bnc#902632

This change is made to preserve the GIC v2 bypass bits in the
GIC_CPU_CTRL register (also known as the GICC_CTLR register in spec).
This code will preserve all bits configured by the bootloader regarding
v2 bypass group bits. In the X-Gene platform, the bypass functionality
is not used and bypass bits should not be changed by the kernel gic
code as it could lead to incorrect behavior.

Signed-off-by: Vinayak Kale <vkale@apm.com>
Signed-off-by: Feng Kan <fkan@apm.com>
Reviewed-by: Anup Patel <apatel@apm.com>
Signed-off-by: Alexander Graf <agraf@suse.de>

---
 drivers/irqchip/irq-gic.c       | 24 +++++++++++++++++++++---
 include/linux/irqchip/arm-gic.h |  3 +++
 2 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c
index 7c131cf..cfee5b6 100644
--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@ -378,6 +378,20 @@ static u8 gic_get_cpumask(struct gic_chip_data *gic)
	return mask;
 }

+static void gic_cpu_if_up(void)
+{
+	void __iomem *cpu_base = gic_data_cpu_base(&gic_data[0]);
+	u32 bypass;
+
+	/*
+	 * Preserve bypass disable bits to be written back later
+	 */
+	bypass = readl(cpu_base + GIC_CPU_CTRL);
+	bypass &= GICC_CTRL_DIS_BYPASS_MASK;
+
+	writel_relaxed(bypass | GICC_CTRL_ENABLE, cpu_base + GIC_CPU_CTRL);
+}
+
 static void __init gic_dist_init(struct gic_chip_data *gic)
 {
	unsigned int i;
@@ -454,13 +468,17 @@ static void gic_cpu_init(struct gic_chip_data *gic)
		writel_relaxed(0xa0a0a0a0, dist_base + GIC_DIST_PRI + i * 4 / 4);

	writel_relaxed(0xf0, base + GIC_CPU_PRIMASK);
-	writel_relaxed(1, base + GIC_CPU_CTRL);
+	gic_cpu_if_up();
 }

 void gic_cpu_if_down(void)
 {
	void __iomem *cpu_base = gic_data_cpu_base(&gic_data[0]);
-	writel_relaxed(0, cpu_base + GIC_CPU_CTRL);
+	u32 val;
+
+	val = readl(cpu_base + GIC_CPU_CTRL);
+	val &= ~GICC_CTRL_ENABLE;
+	writel_relaxed(val, cpu_base + GIC_CPU_CTRL);
 }

 #ifdef CONFIG_CPU_PM
@@ -595,7 +613,7 @@ static void gic_cpu_restore(unsigned int gic_nr)
		writel_relaxed(0xa0a0a0a0, dist_base + GIC_DIST_PRI + i * 4);

	writel_relaxed(0xf0, cpu_base + GIC_CPU_PRIMASK);
-	writel_relaxed(1, cpu_base + GIC_CPU_CTRL);
+	gic_cpu_if_up();
 }

 static int gic_notifier(struct notifier_block *self, unsigned long cmd,	void *v)
diff --git a/include/linux/irqchip/arm-gic.h b/include/linux/irqchip/arm-gic.h
index 45e2d8c..cc2977c 100644
--- a/include/linux/irqchip/arm-gic.h
+++ b/include/linux/irqchip/arm-gic.h
@@ -21,6 +21,9 @@
 #define GIC_CPU_ACTIVEPRIO		0xd0
 #define GIC_CPU_IDENT			0xfc

+#define GICC_CTRL_ENABLE		0x1
+#define GICC_CTRL_DIS_BYPASS_MASK	0x1e0
+
 #define GICC_IAR_INT_ID_MASK		0x3ff

 #define GIC_DIST_CTRL			0x000
--
2.1.0
