From: Alok N Kataria <akataria@vmware.com>
Date: Thu, 17 Jan 2013 15:44:42 -0800
Subject: x86/apic: Allow x2apic without IR on VMware platform
Git-commit: 4cca6ea04d31c22a7d0436949c072b27bde41f86
Patch-mainline: v3.9-rc1
References: FATE#314895, bsc#801138

This patch updates x2apic initializaition code to allow x2apic
on VMware platform even without interrupt remapping support.
The hypervisor_x2apic_available hook was added in x2apic
initialization code and used by KVM and XEN, before this.
I have also cleaned up that code to export this hook through the
hypervisor_x86 structure.

Compile tested for KVM and XEN configs, this patch doesn't have
any functional effect on those two platforms.

On VMware platform, verified that x2apic is used in physical
mode on products that support this.

Signed-off-by: Alok N Kataria <akataria@vmware.com>
Reviewed-by: Doug Covelli <dcovelli@vmware.com>
Reviewed-by: Dan Hecht <dhecht@vmware.com>
Acked-by: H. Peter Anvin <hpa@zytor.com>
Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Cc: Jeremy Fitzhardinge <jeremy@goop.org>
Cc: Avi Kivity <avi@redhat.com>
Link: http://lkml.kernel.org/r/1358466282.423.60.camel@akataria-dtop.eng.vmware.com
Signed-off-by: Ingo Molnar <mingo@kernel.org>
Acked-by: Borislav Petkov <bp@suse.de>
---
 arch/x86/include/asm/hypervisor.h | 13 ++++---------
 arch/x86/kernel/cpu/hypervisor.c  |  7 +++++++
 arch/x86/kernel/cpu/vmware.c      | 13 +++++++++++++
 arch/x86/kernel/kvm.c             |  1 +
 arch/x86/xen/enlighten.c          |  1 +
 5 files changed, 26 insertions(+), 9 deletions(-)

Index: current/arch/x86/include/asm/hypervisor.h
===================================================================
--- current.orig/arch/x86/include/asm/hypervisor.h	2014-11-17 22:39:55.828292747 +0100
+++ current/arch/x86/include/asm/hypervisor.h	2014-11-17 22:40:26.004292693 +0100
@@ -25,6 +25,7 @@
 
 extern void init_hypervisor(struct cpuinfo_x86 *c);
 extern void init_hypervisor_platform(void);
+extern bool hypervisor_x2apic_available(void);
 
 /*
  * x86 hypervisor information
@@ -41,6 +42,9 @@ struct hypervisor_x86 {
 
 	/* Platform setup (run once per boot) */
 	void		(*init_platform)(void);
+
+	/* X2APIC detection (run once per boot) */
+	bool		(*x2apic_available)(void);
 };
 
 extern const struct hypervisor_x86 *x86_hyper;
@@ -51,13 +55,4 @@ extern const struct hypervisor_x86 x86_h
 extern const struct hypervisor_x86 x86_hyper_xen_hvm;
 extern const struct hypervisor_x86 x86_hyper_kvm;
 
-static inline bool hypervisor_x2apic_available(void)
-{
-	if (kvm_para_available())
-		return true;
-	if (xen_x2apic_para_available())
-		return true;
-	return false;
-}
-
 #endif
Index: current/arch/x86/kernel/cpu/hypervisor.c
===================================================================
--- current.orig/arch/x86/kernel/cpu/hypervisor.c	2014-11-17 22:39:55.828292747 +0100
+++ current/arch/x86/kernel/cpu/hypervisor.c	2014-11-17 22:39:57.340292744 +0100
@@ -77,3 +77,10 @@ void __init init_hypervisor_platform(voi
 	if (x86_hyper->init_platform)
 		x86_hyper->init_platform();
 }
+
+bool __init hypervisor_x2apic_available(void)
+{
+	return x86_hyper                   &&
+	       x86_hyper->x2apic_available &&
+	       x86_hyper->x2apic_available();
+}
Index: current/arch/x86/kernel/cpu/vmware.c
===================================================================
--- current.orig/arch/x86/kernel/cpu/vmware.c	2014-11-17 22:39:55.828292747 +0100
+++ current/arch/x86/kernel/cpu/vmware.c	2014-11-17 22:39:57.340292744 +0100
@@ -33,6 +33,9 @@
 
 #define VMWARE_PORT_CMD_GETVERSION	10
 #define VMWARE_PORT_CMD_GETHZ		45
+#define VMWARE_PORT_CMD_GETVCPU_INFO	68
+#define VMWARE_PORT_CMD_LEGACY_X2APIC	3
+#define VMWARE_PORT_CMD_VCPU_RESERVED	31
 
 #define VMWARE_PORT(cmd, eax, ebx, ecx, edx)				\
 	__asm__("inl (%%dx)" :						\
@@ -125,10 +128,20 @@ static void __cpuinit vmware_set_cpu_fea
 	set_cpu_cap(c, X86_FEATURE_TSC_RELIABLE);
 }
 
+/* Checks if hypervisor supports x2apic without VT-D interrupt remapping. */
+static bool __init vmware_legacy_x2apic_available(void)
+{
+	uint32_t eax, ebx, ecx, edx;
+	VMWARE_PORT(GETVCPU_INFO, eax, ebx, ecx, edx);
+	return (eax & (1 << VMWARE_PORT_CMD_VCPU_RESERVED)) == 0 &&
+	       (eax & (1 << VMWARE_PORT_CMD_LEGACY_X2APIC)) != 0;
+}
+
 const __refconst struct hypervisor_x86 x86_hyper_vmware = {
 	.name			= "VMware",
 	.detect			= vmware_platform,
 	.set_cpu_features	= vmware_set_cpu_features,
 	.init_platform		= vmware_platform_setup,
+	.x2apic_available	= vmware_legacy_x2apic_available,
 };
 EXPORT_SYMBOL(x86_hyper_vmware);
Index: current/arch/x86/kernel/kvm.c
===================================================================
--- current.orig/arch/x86/kernel/kvm.c	2014-11-17 22:39:55.828292747 +0100
+++ current/arch/x86/kernel/kvm.c	2014-11-17 22:39:57.340292744 +0100
@@ -580,5 +580,6 @@ static bool __init kvm_detect(void)
 const struct hypervisor_x86 x86_hyper_kvm __refconst = {
 	.name			= "KVM",
 	.detect			= kvm_detect,
+	.x2apic_available	= kvm_para_available,
 };
 EXPORT_SYMBOL_GPL(x86_hyper_kvm);
Index: current/arch/x86/xen/enlighten.c
===================================================================
--- current.orig/arch/x86/xen/enlighten.c	2014-11-17 22:39:55.828292747 +0100
+++ current/arch/x86/xen/enlighten.c	2014-11-17 22:39:57.340292744 +0100
@@ -1444,6 +1444,7 @@ const struct hypervisor_x86 x86_hyper_xe
 	.name			= "Xen HVM",
 	.detect			= xen_hvm_platform,
 	.init_platform		= xen_hvm_guest_init,
+	.x2apic_available	= xen_x2apic_para_available,
 };
 EXPORT_SYMBOL(x86_hyper_xen_hvm);
 #endif
