From: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Subject: fully support pcie multi-function adapters using pcie bridges/switches
Patch-mainline: 2.6.33
References: bnc#706882

Mainline commits: bb209c8287d2d55ec4a67e3933346e0a3ee0da76,
	 94afc008e1e6fbadfac0b75fcf193b6d7074b2f1,
	 26b4a0ca46985ae9586c194f7859f3838b1230f8

Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Acked-by: Torsten Duwe <duwe@suse.de>

 arch/powerpc/kernel/pci_of_scan.c |   10 ++++++++++
 drivers/pci/probe.c               |    4 ++--
 include/linux/pci.h               |    4 ++++
 3 files changed, 16 insertions(+), 2 deletions(-)

diff -rup linux-2.6.32-SLE11-SP2.orig/arch/powerpc/kernel/pci_of_scan.c linux-2.6.32-SLE11-SP2/arch/powerpc/kernel/pci_of_scan.c
--- linux-2.6.32-SLE11-SP2.orig/arch/powerpc/kernel/pci_of_scan.c	2009-12-03 04:51:21.000000000 +0100
+++ linux-2.6.32-SLE11-SP2/arch/powerpc/kernel/pci_of_scan.c	2011-07-25 16:23:24.228474024 +0200
@@ -123,6 +123,7 @@ struct pci_dev *of_create_pci_dev(struct
 {
 	struct pci_dev *dev;
 	const char *type;
+	struct pci_slot *slot;
 
 	dev = alloc_pci_dev();
 	if (!dev)
@@ -140,6 +141,11 @@ struct pci_dev *of_create_pci_dev(struct
 	dev->devfn = devfn;
 	dev->multifunction = 0;		/* maybe a lie? */
 	dev->needs_freset = 0;		/* pcie fundamental reset required */
+	set_pcie_port_type(dev);
+
+	list_for_each_entry(slot, &dev->bus->slots, list)
+		if (PCI_SLOT(dev->devfn) == slot->number)
+			dev->slot = slot;
 
 	dev->vendor = get_int_prop(node, "vendor-id", 0xffff);
 	dev->device = get_int_prop(node, "device-id", 0xffff);
@@ -160,10 +166,14 @@ struct pci_dev *of_create_pci_dev(struct
 	dev->error_state = pci_channel_io_normal;
 	dev->dma_mask = 0xffffffff;
 
+	/* Early fixups, before probing the BARs */
+	pci_fixup_device(pci_fixup_early, dev);
+
 	if (!strcmp(type, "pci") || !strcmp(type, "pciex")) {
 		/* a PCI-PCI bridge */
 		dev->hdr_type = PCI_HEADER_TYPE_BRIDGE;
 		dev->rom_base_reg = PCI_ROM_ADDRESS1;
+		set_pcie_hotplug_bridge(dev);
 	} else if (!strcmp(type, "cardbus")) {
 		dev->hdr_type = PCI_HEADER_TYPE_CARDBUS;
 	} else {
diff -rup linux-2.6.32-SLE11-SP2.orig/drivers/pci/probe.c linux-2.6.32-SLE11-SP2/drivers/pci/probe.c
--- linux-2.6.32-SLE11-SP2.orig/drivers/pci/probe.c	2011-07-25 16:11:48.010582773 +0200
+++ linux-2.6.32-SLE11-SP2/drivers/pci/probe.c	2011-07-25 16:23:24.232474057 +0200
@@ -725,7 +725,7 @@ static void pci_read_irq(struct pci_dev
 	dev->irq = irq;
 }
 
-static void set_pcie_port_type(struct pci_dev *pdev)
+void set_pcie_port_type(struct pci_dev *pdev)
 {
 	int pos;
 	u16 reg16;
@@ -739,7 +739,7 @@ static void set_pcie_port_type(struct pc
 	pdev->pcie_type = (reg16 & PCI_EXP_FLAGS_TYPE) >> 4;
 }
 
-static void set_pcie_hotplug_bridge(struct pci_dev *pdev)
+void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 {
 	int pos;
 	u16 reg16;
diff -rup linux-2.6.32-SLE11-SP2.orig/include/linux/pci.h linux-2.6.32-SLE11-SP2/include/linux/pci.h
--- linux-2.6.32-SLE11-SP2.orig/include/linux/pci.h	2011-07-25 16:11:46.426568776 +0200
+++ linux-2.6.32-SLE11-SP2/include/linux/pci.h	2011-07-25 16:23:24.236474090 +0200
@@ -794,6 +794,10 @@ int pci_enable_ltr(struct pci_dev *dev);
 void pci_disable_ltr(struct pci_dev *dev);
 int pci_set_ltr(struct pci_dev *dev, int snoop_lat_ns, int nosnoop_lat_ns);
 
+/* For use by arch with custom probe code */
+void set_pcie_port_type(struct pci_dev *pdev);
+void set_pcie_hotplug_bridge(struct pci_dev *pdev);
+
 /* Functions for PCI Hotplug drivers to use */
 int pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap);
 #ifdef CONFIG_HOTPLUG
