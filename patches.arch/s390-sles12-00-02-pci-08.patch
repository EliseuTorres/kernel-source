From: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Subject: s390/pci: prevent inadvertently triggered bus scans
Patch-mainline: v3.14-rc1
Git-commit: aa3b7c296732b4351dfdbfe70be6b38a0882be14
References: fate#315311, LTC#92765

Summary:     s390: add pci support
Description: Add pci support for System z.

Upstream-Description:

             s390/pci: prevent inadvertently triggered bus scans

             Initialization and scanning of the pci bus is omitted on older
             machines without pci support or if pci=off was specified. Remember
             the fact that we ran without pci support and prevent further bus
             scans during resume from hibernate or after receiving hotplug
             notifications.

             Reported-by: Stefan Haberland <stefan.haberland@de.ibm.com>
             Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
             Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>


Signed-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/pci.h |    1 +
 arch/s390/pci/pci.c         |   10 +++++++++-
 arch/s390/pci/pci_event.c   |   18 ++++++++++++++----
 3 files changed, 24 insertions(+), 5 deletions(-)

--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@ -144,6 +144,7 @@ int clp_disable_fh(struct zpci_dev *);
 void zpci_event_error(void *);
 void zpci_event_availability(void *);
 void zpci_rescan(void);
+bool zpci_is_enabled(void);
 #else /* CONFIG_PCI */
 static inline void zpci_event_error(void *e) {}
 static inline void zpci_event_availability(void *e) {}
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -920,6 +920,7 @@ static void zpci_mem_exit(void)
 }
 
 static unsigned int s390_pci_probe;
+static unsigned int s390_pci_initialized;
 
 char * __init pcibios_setup(char *str)
 {
@@ -930,6 +931,11 @@ char * __init pcibios_setup(char *str)
 	return str;
 }
 
+bool zpci_is_enabled(void)
+{
+	return s390_pci_initialized;
+}
+
 static int __init pci_base_init(void)
 {
 	int rc;
@@ -961,6 +967,7 @@ static int __init pci_base_init(void)
 	if (rc)
 		goto out_find;
 
+	s390_pci_initialized = 1;
 	return 0;
 
 out_find:
@@ -978,5 +985,6 @@ subsys_initcall_sync(pci_base_init);
 
 void zpci_rescan(void)
 {
-	clp_rescan_pci_devices_simple();
+	if (zpci_is_enabled())
+		clp_rescan_pci_devices_simple();
 }
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@ -43,9 +43,8 @@ struct zpci_ccdf_avail {
 	u16 pec;			/* PCI event code */
 } __packed;
 
-void zpci_event_error(void *data)
+static void __zpci_event_error(struct zpci_ccdf_err *ccdf)
 {
-	struct zpci_ccdf_err *ccdf = data;
 	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
 
 	zpci_err("error CCDF:\n");
@@ -58,9 +57,14 @@ void zpci_event_error(void *data)
 	       pci_name(zdev->pdev), ccdf->pec, ccdf->fid);
 }
 
-void zpci_event_availability(void *data)
+void zpci_event_error(void *data)
+{
+	if (zpci_is_enabled())
+		__zpci_event_error(data);
+}
+
+static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 {
-	struct zpci_ccdf_avail *ccdf = data;
 	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
 	struct pci_dev *pdev = zdev ? zdev->pdev : NULL;
 	int ret;
@@ -115,3 +119,9 @@ void zpci_event_availability(void *data)
 		break;
 	}
 }
+
+void zpci_event_availability(void *data)
+{
+	if (zpci_is_enabled())
+		__zpci_event_availability(data);
+}
