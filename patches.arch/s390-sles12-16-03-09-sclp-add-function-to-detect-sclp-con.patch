From: Michael Holzheu <holzheu@linux.vnet.ibm.com>
Subject: s390/sclp_early: Add function to detect sclp console capabilities
Patch-mainline: v3.14-rc1
Git-commit: 52733e0152dad719ed6374b56fd1c33e784e44b3
References: bnc#917125, LTC#122429

Description:  s390/sclp: Determine HSA size dynamically for zfcpdump
Symptom:      For future s390 machines that potentially use more than
              the current 32 MiB HSA for zfcpdump, the memory in kernel
              dumps in the range [32 MiB, HSA size] will contain invalid data.
Problem:      Currently the first 32 MiB (hardcoded) are copied from HSA and
              everything above is copied from real memory (which
              potentially will be overwritten by the firmware).
Solution:     Determine current HSA size dynamically via SCLP in "early.c"
              and copy everything that is contained in HSA.
              To be prepared for upcoming sclp commits, also pull various
              upstream commits to have a solid base for future sclp related
              backports.
Reproduction: -

Upstream-Description:

              s390/sclp_early: Add function to detect sclp console capabilities

              Add SCLP console detect functions to encapsulate detection of SCLP console
              capabilities, for example, VT220 support.  Reuse the sclp_send/receive masks
              that were stored by the most recent sclp_set_event_mask() call to prevent
              unnecessary SCLP calls.

              Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
              Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
              Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/sclp.h   |    4 +--
 drivers/s390/char/sclp_early.c |   46 ++++++++++++++++++++++++++---------------
 2 files changed, 32 insertions(+), 18 deletions(-)

--- a/arch/s390/include/asm/sclp.h
+++ b/arch/s390/include/asm/sclp.h
@@ -52,8 +52,8 @@ int sclp_chp_configure(struct chp_id chp
 int sclp_chp_deconfigure(struct chp_id chpid);
 int sclp_chp_read_info(struct sclp_chp_info *info);
 void sclp_get_ipl_info(struct sclp_ipl_info *info);
-bool sclp_has_linemode(void);
-bool sclp_has_vt220(void);
+bool __init sclp_has_linemode(void);
+bool __init sclp_has_vt220(void);
 int sclp_pci_configure(u32 fid);
 int sclp_pci_deconfigure(u32 fid);
 int memcpy_hsa(void *dest, unsigned long src, size_t count, int mode);
--- a/drivers/s390/char/sclp_early.c
+++ b/drivers/s390/char/sclp_early.c
@@ -36,6 +36,8 @@ struct read_info_sccb {
 } __packed __aligned(PAGE_SIZE);
 
 static char sccb_early[PAGE_SIZE] __aligned(PAGE_SIZE) __initdata;
+static unsigned int sclp_con_has_vt220 __initdata;
+static unsigned int sclp_con_has_linemode __initdata;
 static unsigned long sclp_hsa_size;
 static struct sclp_ipl_info sclp_ipl_info;
 
@@ -109,26 +111,12 @@ static void __init sclp_facilities_detec
 
 bool __init sclp_has_linemode(void)
 {
-	struct init_sccb *sccb = (void *) &sccb_early;
-
-	if (sccb->header.response_code != 0x20)
-		return 0;
-	if (!(sccb->sclp_send_mask & (EVTYP_OPCMD_MASK | EVTYP_PMSGCMD_MASK)))
-		return 0;
-	if (!(sccb->sclp_receive_mask & (EVTYP_MSG_MASK | EVTYP_PMSGCMD_MASK)))
-		return 0;
-	return 1;
+	return !!sclp_con_has_linemode;
 }
 
 bool __init sclp_has_vt220(void)
 {
-	struct init_sccb *sccb = (void *) &sccb_early;
-
-	if (sccb->header.response_code != 0x20)
-		return 0;
-	if (sccb->sclp_send_mask & EVTYP_VT220MSG_MASK)
-		return 1;
-	return 0;
+	return !!sclp_con_has_vt220;
 }
 
 unsigned long long sclp_get_rnmax(void)
@@ -240,11 +228,37 @@ out:
 	sclp_hsa_size = size;
 }
 
+static unsigned int __init sclp_con_check_linemode(struct init_sccb *sccb)
+{
+	if (!(sccb->sclp_send_mask & (EVTYP_OPCMD_MASK | EVTYP_PMSGCMD_MASK)))
+		return 0;
+	if (!(sccb->sclp_receive_mask & (EVTYP_MSG_MASK | EVTYP_PMSGCMD_MASK)))
+		return 0;
+	return 1;
+}
+
+static void __init sclp_console_detect(struct init_sccb *sccb)
+{
+	if (sccb->header.response_code != 0x20)
+		return;
+
+	if (sccb->sclp_send_mask & EVTYP_VT220MSG_MASK)
+		sclp_con_has_vt220 = 1;
+
+	if (sclp_con_check_linemode(sccb))
+		sclp_con_has_linemode = 1;
+}
+
 void __init sclp_early_detect(void)
 {
 	void *sccb = &sccb_early;
 
 	sclp_facilities_detect(sccb);
 	sclp_hsa_size_detect(sccb);
+
+	/* Turn off SCLP event notifications.  Also save remote masks in the
+	 * sccb.  These are sufficient to detect sclp console capabilities.
+	 */
 	sclp_set_event_mask(sccb, 0, 0);
+	sclp_console_detect(sccb);
 }
