From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: qeth: avoid loop if ipa command response is missing
References: bnc#617464,LTC#66115
Patch-mainline: Yes

Symptom:     endless loop in qeth_send_control_data
Problem:     If qeth issues an ipa command, but for some reasons the
             response never comes back, qeth reaches a timeout. In this
             case the irq_pending flag of the write channel is not reset,
             and the command buffer is not reinitialized.
Solution:    Reset the irq_pending flag of the write channel in timeout
             handling code, clear the command buffer, clear the list of
             scheduled ipa commands and trigger a recovery. This avoids
             endless looping in case of ipa command timeout.

Acked-by: John Jolly <jjolly@suse.de>

---

 drivers/s390/net/qeth_core.h      |    1 +
 drivers/s390/net/qeth_core_main.c |   15 +++++++++++++++
 2 files changed, 16 insertions(+)

Index: linux-sles11sp1/drivers/s390/net/qeth_core.h
===================================================================
--- linux-sles11sp1.orig/drivers/s390/net/qeth_core.h
+++ linux-sles11sp1/drivers/s390/net/qeth_core.h
@@ -735,6 +735,7 @@ struct qeth_card {
 	struct qeth_qdio_info qdio;
 	struct qeth_perf_stats perf_stats;
 	int use_hard_stop;
+	int read_or_write_problem;
 	struct qeth_osn_info osn_info;
 	struct qeth_discipline discipline;
 	atomic_t force_alloc_skb;
Index: linux-sles11sp1/drivers/s390/net/qeth_core_main.c
===================================================================
--- linux-sles11sp1.orig/drivers/s390/net/qeth_core_main.c
+++ linux-sles11sp1/drivers/s390/net/qeth_core_main.c
@@ -295,6 +295,7 @@ static int qeth_issue_next_read(struct q
 		QETH_DBF_MESSAGE(2, "%s error in starting next read ccw! "
 			"rc=%i\n", dev_name(&card->gdev->dev), rc);
 		atomic_set(&card->read.irq_pending, 0);
+		card->read_or_write_problem = 1;
 		qeth_schedule_recovery(card);
 		wake_up(&card->wait_q);
 	}
@@ -415,6 +416,7 @@ void qeth_clear_ipacmd_list(struct qeth_
 		qeth_put_reply(reply);
 	}
 	spin_unlock_irqrestore(&card->lock, flags);
+	atomic_set(&card->write.irq_pending, 0);
 }
 EXPORT_SYMBOL_GPL(qeth_clear_ipacmd_list);
 
@@ -1091,6 +1093,7 @@ static int qeth_setup_card(struct qeth_c
 	card->state = CARD_STATE_DOWN;
 	card->lan_online = 0;
 	card->use_hard_stop = 0;
+	card->read_or_write_problem = 0;
 	card->dev = NULL;
 	spin_lock_init(&card->vlanlock);
 	spin_lock_init(&card->mclock);
@@ -1667,6 +1670,10 @@ int qeth_send_control_data(struct qeth_c
 
 	QETH_DBF_TEXT(TRACE, 2, "sendctl");
 
+	if (card->read_or_write_problem) {
+		qeth_release_buffer(iob->channel, iob);
+		return -EIO;
+	}
 	reply = qeth_alloc_reply(card);
 	if (!reply) {
 		return -ENOMEM;
@@ -1738,6 +1745,9 @@ time_err:
 	spin_unlock_irqrestore(&reply->card->lock, flags);
 	reply->rc = -ETIME;
 	atomic_inc(&reply->received);
+	atomic_set(&card->write.irq_pending, 0);
+	qeth_release_buffer(iob->channel, iob);
+	card->write.buf_no = (card->write.buf_no + 1) % QETH_CMD_BUFFER_NO;
 	wake_up(&reply->wait_q);
 	rc = reply->rc;
 	qeth_put_reply(reply);
@@ -2476,6 +2486,10 @@ int qeth_send_ipa_cmd(struct qeth_card *
 	qeth_prepare_ipa_cmd(card, iob, prot_type);
 	rc = qeth_send_control_data(card, IPA_CMD_LENGTH,
 						iob, reply_cb, reply_param);
+	if (rc == -ETIME) {
+		qeth_clear_ipacmd_list(card);
+		qeth_schedule_recovery(card);
+	}
 	return rc;
 }
 EXPORT_SYMBOL_GPL(qeth_send_ipa_cmd);
@@ -3911,6 +3925,7 @@ retry:
 		else
 			goto retry;
 	}
+	card->read_or_write_problem = 0;
 	rc = qeth_mpc_initialize(card);
 	if (rc) {
 		QETH_DBF_TEXT_(SETUP, 2, "5err%d", rc);
