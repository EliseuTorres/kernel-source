From: Michael Ellerman <mpe@ellerman.id.au>
Subject: powerpc/xmon: Don't signal we've entered until we're finished printing
Git-commit: d2b496e5e1fa7a6796534e435440eb9d3ed184dd
Patch-mainline: 3.14-rc3
References: bnc#872696 

    Currently we set our cpu's bit in cpus_in_xmon, and then we take the
    output lock and print the exception information.
    
    This can race with the master cpu entering the command loop and printing
    the backtrace. The result is that the backtrace gets garbled with
    another cpu's exception print out.
    
    Fix it by delaying the set of cpus_in_xmon until we are finished
    printing.
    
Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Acked-by: Torsten Duwe <duwe@suse.de>

 arch/powerpc/xmon/xmon.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)
diff --git a/arch/powerpc/xmon/xmon.c b/arch/powerpc/xmon/xmon.c
index d712b23..b079098 100644
--- a/arch/powerpc/xmon/xmon.c
+++ b/arch/powerpc/xmon/xmon.c
@@ -404,7 +404,6 @@ static int xmon_core(struct pt_regs *regs, int fromipi)
 	}
 
 	xmon_fault_jmp[cpu] = recurse_jmp;
-	cpumask_set_cpu(cpu, &cpus_in_xmon);
 
 	bp = NULL;
 	if ((regs->msr & (MSR_IR|MSR_PR|MSR_64BIT)) == (MSR_IR|MSR_64BIT))
@@ -426,6 +425,8 @@ static int xmon_core(struct pt_regs *regs, int fromipi)
 		release_output_lock();
 	}
 
+	cpumask_set_cpu(cpu, &cpus_in_xmon);
+
  waiting:
 	secondary = 1;
 	while (secondary && !xmon_gate) {
