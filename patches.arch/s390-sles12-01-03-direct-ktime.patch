From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Subject: kernel: incorrect clockevent timeouts
Patch-mainline: v3.13-rc2
Git-commit: 8adbf78ec4839c1dc4ff20c9a1f332a7bc99e6e6
References: bnc#860346,LTC#100340

Description:  kernel: incorrect clockevent timeouts
Symptom:      High CPU consumption, incorrect timeout durations.
Problem:      The direct ktime interface for the clockevent device is
              based on the assumption that the difference between the
              Linux internal ktime and the hardware clock is reflected
              in the wall_to_monotonic offset. But the time correction
              due to NTP drifting is not included in wall_to_monotonic.
              If the NTP drift is slowing done Linux internal clock
              interrupt loops can occur, if the internal clock is
              accelerated clock events are recognized too late.
Solution:     Disable the CLOCK_EVT_FEAT_KTIME clockevent option.
Reproduction: Inject small time correction via NTP and run a program
              to stress timer events.
Upstream-ID:  -
Problem-ID:   100340

Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/kernel/time.c |   19 ++++---------------
 1 file changed, 4 insertions(+), 15 deletions(-)

--- a/arch/s390/kernel/time.c
+++ b/arch/s390/kernel/time.c
@@ -108,20 +108,10 @@ static void fixup_clock_comparator(unsig
 	set_clock_comparator(S390_lowcore.clock_comparator);
 }
 
-static int s390_next_ktime(ktime_t expires,
+static int s390_next_event(unsigned long delta,
 			   struct clock_event_device *evt)
 {
-	struct timespec ts;
-	u64 nsecs;
-
-	ts.tv_sec = ts.tv_nsec = 0;
-	monotonic_to_bootbased(&ts);
-	nsecs = ktime_to_ns(ktime_add(timespec_to_ktime(ts), expires));
-	do_div(nsecs, 125);
-	S390_lowcore.clock_comparator = sched_clock_base_cc + (nsecs << 9);
-	/* Program the maximum value if we have an overflow (== year 2042) */
-	if (unlikely(S390_lowcore.clock_comparator < sched_clock_base_cc))
-		S390_lowcore.clock_comparator = -1ULL;
+	S390_lowcore.clock_comparator = get_tod_clock() + delta;
 	set_clock_comparator(S390_lowcore.clock_comparator);
 	return 0;
 }
@@ -146,15 +136,14 @@ void init_cpu_timer(void)
 	cpu = smp_processor_id();
 	cd = &per_cpu(comparators, cpu);
 	cd->name		= "comparator";
-	cd->features		= CLOCK_EVT_FEAT_ONESHOT |
-				  CLOCK_EVT_FEAT_KTIME;
+	cd->features		= CLOCK_EVT_FEAT_ONESHOT;
 	cd->mult		= 16777;
 	cd->shift		= 12;
 	cd->min_delta_ns	= 1;
 	cd->max_delta_ns	= LONG_MAX;
 	cd->rating		= 400;
 	cd->cpumask		= cpumask_of(cpu);
-	cd->set_next_ktime	= s390_next_ktime;
+	cd->set_next_event	= s390_next_event;
 	cd->set_mode		= s390_set_mode;
 
 	clockevents_register_device(cd);
