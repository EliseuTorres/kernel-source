From: Raymund Will <rw@suse.de>
Subject: x86, efi: Merge contiguous early reservations
Patch-mainline: N/A
References: bnc#655434, bnc#681242

Some firmware implementations deliver an insane amount (>140) of tiny
snippets of EFI_BOOT_SERVICES_CODE and DATA, which are individually
preserved by commit 916f676f8dc016103f983c7ec54c18ecdbb6e349.

Unfortunately SLE11SP2 kernels do not have the memblock interface yet,
and worse, e820.c provides only 20 (or 32 or so) entries for early
reservations.

This patch works around this mess, by merging all contigous regions
of EFI_BOOT_SERVICES_{CODE,DATA} into one reservation, which brings
the number down to 29-35 on said machine.

Signed-off-by: Raymund Will <rw@suse.de>

---
 arch/x86/platform/efi/efi.c |   48 ++++++++++++++++++++++++++++++++++++------------
 1 file changed, 36 insertions(+), 12 deletions(-)

--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@ -304,31 +304,55 @@ static void __init print_efi_memmap(void
 }
 #endif  /*  EFI_DEBUG  */
 
+static int __init efi_early_reservable(u64 start, u64 size) {
+	/* Only reserve where possible:
+	 * - Not within any already allocated areas
+	 * - Not over any memory area (really needed, if above?)
+	 * - Not within any part of the kernel
+	 * - Not the bios reserved area
+	 */
+	if ((start+size >= virt_to_phys(_text)
+			&& start <= virt_to_phys(_end)) ||
+		!e820_all_mapped(start, start+size, E820_RAM) ||
+		!check_early(start, start+size-1))
+		return 0;
+	return 1;
+}
+
 void __init efi_reserve_boot_services(void)
 {
 	void *p;
 
 	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
 		efi_memory_desc_t *md = p;
+		void *n = p + memmap.desc_size;
 		u64 start = md->phys_addr;
 		u64 size = md->num_pages << EFI_PAGE_SHIFT;
 
 		if (md->type != EFI_BOOT_SERVICES_CODE &&
 		    md->type != EFI_BOOT_SERVICES_DATA)
 			continue;
-		/* Only reserve where possible:
-		 * - Not within any already allocated areas
-		 * - Not over any memory area (really needed, if above?)
-		 * - Not within any part of the kernel
-		 * - Not the bios reserved area
-		*/
-		if ((start+size >= virt_to_phys(_text)
-				&& start <= virt_to_phys(_end)) ||
-			!e820_all_mapped(start, start+size, E820_RAM) ||
-			check_early(start, start+size)) {
-			/* Could not reserve, skip it */
+
+		/* Merge contiguous regions to avoid overflowing
+		 * MAX_EARLY_RES (max observed has been >140!)
+		 */
+		while (n < memmap.map_end) {
+			efi_memory_desc_t *nd = n;
+			u64 n_size = size + (nd->num_pages << EFI_PAGE_SHIFT);
+			if ((nd->type != EFI_BOOT_SERVICES_CODE &&
+				nd->type != EFI_BOOT_SERVICES_DATA) ||
+			    nd->phys_addr != (start + size) ||
+			    !efi_early_reservable(start, n_size))
+				break;
+			size = n_size;
+			p = nd;
+			n += memmap.desc_size;
+		}
+
+		if (!efi_early_reservable(start, size)) {
+			/* Reserve will fail, skip it */
 			md->num_pages = 0;
-			memblock_dbg(PFX "Could not reserve boot range "
+			memblock_dbg(PFX "Skip reserving boot range "
 					"[0x%010llx-0x%010llx]\n",
 						start, start+size-1);
 		} else
