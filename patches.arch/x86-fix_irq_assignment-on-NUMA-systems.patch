From: Jack Steiner <steiner@sgi.com>
Subject: x86: Fix irq vector assignment on large NUMA systems
References: bnc#622727, FATE#306952
Patch-Mainline: Not yet

Try to assign irq vectors to cpus on the correct node & fall back to global
assignment only if node-local fails. This reduces the chances of
using all of the interrupt vectors of a single cpu.

Note: this is a fix for a problem we saw on systems with a large
number of IOHs.  The IOHs are distributed across 10's of nodes.

Early in boot, the IO infrastructure assigns interrupts for the DMA engines.
Currently, all interrupts are targeted to cpu 0. This uses all interrupt
vectors on cpu 0. Later, some drivers try to create irqs targeted to
cpu 0. The assignment fails because all vectors are assigned.

Signed-off-by: Jack Steiner <steiner@sgi.com>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---

 arch/x86/kernel/apic/io_apic.c |    6 ++++++
 1 file changed, 6 insertions(+)

Index: linux-2.6.32-SLE11-SP1/arch/x86/kernel/apic/io_apic.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/kernel/apic/io_apic.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/kernel/apic/io_apic.c
@@ -3259,6 +3259,12 @@ unsigned int create_irq_nr(unsigned int 
 		desc_new = move_irq_desc(desc_new, node);
 		cfg_new = desc_new->chip_data;
 
+#ifdef CONFIG_NUMA
+		if (node >= 0 && __assign_irq_vector(new, cfg_new, node_to_cpumask_map[node]) == 0) {
+			irq = new;
+			break;
+		}
+#endif
 		if (__assign_irq_vector(new, cfg_new, apic->target_cpus()) == 0)
 			irq = new;
 		break;
