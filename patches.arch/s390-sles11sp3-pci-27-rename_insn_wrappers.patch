From: Sebastian Ott <sebott@linux.vnet.ibm.com>
Subject: s390/pci: rename instruction wrappers
Patch-mainline: v3.10-rc1
Git-commit: b2a9e87d2ce8fb2d0ce08ee49168805975c622da
References: bnc#848335,FATE#83037,LTC#94737

Use distinct (and hopefully sane) names for the pci instruction
wrappers.

Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/pci_insn.h |   12 ++++++------
 arch/s390/include/asm/pci_io.h   |   10 +++++-----
 arch/s390/pci/pci.c              |   12 ++++++------
 arch/s390/pci/pci_dma.c          |    5 +++--
 arch/s390/pci/pci_insn.c         |   18 +++++++++---------
 5 files changed, 29 insertions(+), 28 deletions(-)

--- a/arch/s390/include/asm/pci_insn.h
+++ b/arch/s390/include/asm/pci_insn.h
@@ -79,11 +79,11 @@ struct zpci_fib {
 } __packed;
 
 
-int mpcifc_instr(u64 req, struct zpci_fib *fib);
-int rpcit_instr(u64 fn, u64 addr, u64 range);
-void sic_instr(u16 ctl, char *unused, u8 isc);
-int pcilg_instr(u64 *data, u64 req, u64 offset);
-int pcistg_instr(u64 data, u64 req, u64 offset);
-int pcistb_instr(const u64 *data, u64 req, u64 offset);
+int s390pci_mod_fc(u64 req, struct zpci_fib *fib);
+int s390pci_refresh_trans(u64 fn, u64 addr, u64 range);
+int s390pci_load(u64 *data, u64 req, u64 offset);
+int s390pci_store(u64 data, u64 req, u64 offset);
+int s390pci_store_block(const u64 *data, u64 req, u64 offset);
+void set_irq_ctrl(u16 ctl, char *unused, u8 isc);
 
 #endif
--- a/arch/s390/include/asm/pci_io.h
+++ b/arch/s390/include/asm/pci_io.h
@@ -36,7 +36,7 @@ static inline RETTYPE zpci_read_##RETTYP
 	u64 data;								\
 	int rc;									\
 										\
-	rc = pcilg_instr(&data, req, ZPCI_OFFSET(addr));			\
+	rc = s390pci_load(&data, req, ZPCI_OFFSET(addr));			\
 	if (rc)									\
 		data = -1ULL;							\
 	return (RETTYPE) data;							\
@@ -50,7 +50,7 @@ static inline void zpci_write_##VALTYPE(
 	u64 req = ZPCI_CREATE_REQ(entry->fh, entry->bar, LENGTH);		\
 	u64 data = (VALTYPE) val;						\
 										\
-	pcistg_instr(data, req, ZPCI_OFFSET(addr));				\
+	s390pci_store(data, req, ZPCI_OFFSET(addr));				\
 }
 
 zpci_read(8, u64)
@@ -83,7 +83,7 @@ static inline int zpci_write_single(u64
 		val = 0;		/* let FW report error */
 		break;
 	}
-	return pcistg_instr(val, req, offset);
+	return s390pci_store(val, req, offset);
 }
 
 static inline int zpci_read_single(u64 req, u64 *dst, u64 offset, u8 len)
@@ -91,7 +91,7 @@ static inline int zpci_read_single(u64 r
 	u64 data;
 	u8 cc;
 
-	cc = pcilg_instr(&data,	 req, offset);
+	cc = s390pci_load(&data, req, offset);
 	switch (len) {
 	case 1:
 		*((u8 *) dst) = (u8) data;
@@ -111,7 +111,7 @@ static inline int zpci_read_single(u64 r
 
 static inline int zpci_write_block(u64 req, const u64 *data, u64 offset)
 {
-	return pcistb_instr(data, req, offset);
+	return s390pci_store_block(data, req, offset);
 }
 
 static inline u8 zpci_get_max_write_size(u64 src, u64 dst, int len, int max)
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -174,7 +174,7 @@ static int zpci_register_airq(struct zpc
 	fib->aisb = (u64) bucket->aisb + aisb / 8;
 	fib->aisbo = aisb & ZPCI_MSI_MASK;
 
-	rc = mpcifc_instr(req, fib);
+	rc = s390pci_mod_fc(req, fib);
 	pr_debug("%s mpcifc returned noi: %d\n", __func__, fib->noi);
 
 	free_page((unsigned long) fib);
@@ -204,7 +204,7 @@ static int mod_pci(struct zpci_dev *zdev
 	fib->iota = args->iota;
 	fib->fmb_addr = args->fmb_addr;
 
-	rc = mpcifc_instr(req, fib);
+	rc = s390pci_mod_fc(req, fib);
 	free_page((unsigned long) fib);
 	return rc;
 }
@@ -278,7 +278,7 @@ static int zpci_cfg_load(struct zpci_dev
 	u64 data;
 	int rc;
 
-	rc = pcilg_instr(&data, req, offset);
+	rc = s390pci_load(&data, req, offset);
 	data = data << ((8 - len) * 8);
 	data = le64_to_cpu(data);
 	if (!rc)
@@ -296,7 +296,7 @@ static int zpci_cfg_store(struct zpci_de
 
 	data = cpu_to_le64(data);
 	data = data >> ((8 - len) * 8);
-	rc = pcistg_instr(data, req, offset);
+	rc = s390pci_store(data, req, offset);
 	return rc;
 }
 
@@ -468,7 +468,7 @@ scan:
 	}
 
 	/* enable interrupts again */
-	sic_instr(SIC_IRQ_MODE_SINGLE, NULL, PCI_ISC);
+	set_irq_ctrl(SIC_IRQ_MODE_SINGLE, NULL, PCI_ISC);
 
 	/* check again to not lose initiative */
 	rmb();
@@ -784,7 +784,7 @@ static int __init zpci_irq_init(void)
 	spin_lock_init(&bucket->lock);
 	/* set summary to 1 to be called every time for the ISC */
 	*zpci_irq_si = 1;
-	sic_instr(SIC_IRQ_MODE_SINGLE, NULL, PCI_ISC);
+	set_irq_ctrl(SIC_IRQ_MODE_SINGLE, NULL, PCI_ISC);
 	return 0;
 
 out_ai:
--- a/arch/s390/pci/pci_dma.c
+++ b/arch/s390/pci/pci_dma.c
@@ -168,8 +168,9 @@ static int dma_update_trans(struct zpci_
 		 * needs to be redone!
 		 */
 		goto no_refresh;
-	rc = rpcit_instr((u64) zdev->fh << 32, start_dma_addr,
-			  nr_pages * PAGE_SIZE);
+
+	rc = s390pci_refresh_trans((u64) zdev->fh << 32, start_dma_addr,
+				   nr_pages * PAGE_SIZE);
 
 no_refresh:
 	spin_unlock_irqrestore(&zdev->dma_table_lock, irq_flags);
--- a/arch/s390/pci/pci_insn.c
+++ b/arch/s390/pci/pci_insn.c
@@ -26,7 +26,7 @@ static inline u8 __mpcifc(u64 req, struc
 	return cc;
 }
 
-int mpcifc_instr(u64 req, struct zpci_fib *fib)
+int s390pci_mod_fc(u64 req, struct zpci_fib *fib)
 {
 	u8 cc, status;
 
@@ -60,7 +60,7 @@ static inline u8 __rpcit(u64 fn, u64 add
 	return cc;
 }
 
-int rpcit_instr(u64 fn, u64 addr, u64 range)
+int s390pci_refresh_trans(u64 fn, u64 addr, u64 range)
 {
 	u8 cc, status;
 
@@ -77,7 +77,7 @@ int rpcit_instr(u64 fn, u64 addr, u64 ra
 }
 
 /* Set Interruption Controls */
-void sic_instr(u16 ctl, char *unused, u8 isc)
+void set_irq_ctrl(u16 ctl, char *unused, u8 isc)
 {
 	asm volatile (
 		"	.insn	rsy,0xeb00000000d1,%[ctl],%[isc],%[u]\n"
@@ -104,7 +104,7 @@ static inline u8 __pcilg(u64 *data, u64
 	return cc;
 }
 
-int pcilg_instr(u64 *data, u64 req, u64 offset)
+int s390pci_load(u64 *data, u64 req, u64 offset)
 {
 	u8 cc, status;
 
@@ -123,7 +123,7 @@ int pcilg_instr(u64 *data, u64 req, u64
 	}
 	return (cc) ? -EIO : 0;
 }
-EXPORT_SYMBOL_GPL(pcilg_instr);
+EXPORT_SYMBOL_GPL(s390pci_load);
 
 /* PCI Store */
 static inline u8 __pcistg(u64 data, u64 req, u64 offset, u8 *status)
@@ -143,7 +143,7 @@ static inline u8 __pcistg(u64 data, u64
 	return cc;
 }
 
-int pcistg_instr(u64 data, u64 req, u64 offset)
+int s390pci_store(u64 data, u64 req, u64 offset)
 {
 	u8 cc, status;
 
@@ -158,7 +158,7 @@ int pcistg_instr(u64 data, u64 req, u64
 			__func__, cc, status, req, offset);
 	return (cc) ? -EIO : 0;
 }
-EXPORT_SYMBOL_GPL(pcistg_instr);
+EXPORT_SYMBOL_GPL(s390pci_store);
 
 /* PCI Store Block */
 static inline u8 __pcistb(const u64 *data, u64 req, u64 offset, u8 *status)
@@ -176,7 +176,7 @@ static inline u8 __pcistb(const u64 *dat
 	return cc;
 }
 
-int pcistb_instr(const u64 *data, u64 req, u64 offset)
+int s390pci_store_block(const u64 *data, u64 req, u64 offset)
 {
 	u8 cc, status;
 
@@ -191,4 +191,4 @@ int pcistb_instr(const u64 *data, u64 re
 			    __func__, cc, status, req, offset);
 	return (cc) ? -EIO : 0;
 }
-EXPORT_SYMBOL_GPL(pcistb_instr);
+EXPORT_SYMBOL_GPL(s390pci_store_block);
