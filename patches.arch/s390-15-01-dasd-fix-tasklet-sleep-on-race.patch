From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: dasd: fix race between tasklet and dasd_sleep_on
References: bnc#602852,LTC#63146
Patch-mainline: Yes

Symptom:     Panic when calling the callback function of an cqr.
Problem:     The various dasd_sleep_on functions use a global wait
             queue when waiting for a cqr. The wait condition checks
             the status and devlist fields of the cqr to determine if
             it is safe to continue. This evaluation may return true,
             although the tasklet has not finished processing of the
             cqr and the callback function has not been called yet.
             When the callback is finally called, the data in the cqr
             may already be invalid.
Solution:    The sleep_on wait condition needs a safe way to determine
             if the tasklet has finished processing. Use the
             callback_data field of the cqr to store a token, which is
             set by the callback function itself.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/block/dasd.c |   19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -37,6 +37,9 @@
  */
 #define DASD_CHANQ_MAX_SIZE 4
 
+#define DASD_SLEEPON_START_TAG  (void *) 1
+#define DASD_SLEEPON_END_TAG    (void *) 2
+
 /*
  * SECTION: exported variables of dasd.c
  */
@@ -1457,7 +1460,10 @@ void dasd_add_request_tail(struct dasd_c
  */
 static void dasd_wakeup_cb(struct dasd_ccw_req *cqr, void *data)
 {
-	wake_up((wait_queue_head_t *) data);
+	spin_lock_irq(get_ccwdev_lock(cqr->startdev->cdev));
+	cqr->callback_data = DASD_SLEEPON_END_TAG;
+	spin_unlock_irq(get_ccwdev_lock(cqr->startdev->cdev));
+	wake_up(&generic_waitq);
 }
 
 static inline int _wait_for_wakeup(struct dasd_ccw_req *cqr)
@@ -1467,10 +1473,7 @@ static inline int _wait_for_wakeup(struc
 
 	device = cqr->startdev;
 	spin_lock_irq(get_ccwdev_lock(device->cdev));
-	rc = ((cqr->status == DASD_CQR_DONE ||
-	       cqr->status == DASD_CQR_NEED_ERP ||
-	       cqr->status == DASD_CQR_TERMINATED) &&
-	      list_empty(&cqr->devlist));
+	rc = (cqr->callback_data == DASD_SLEEPON_END_TAG);
 	spin_unlock_irq(get_ccwdev_lock(device->cdev));
 	return rc;
 }
@@ -1487,7 +1490,7 @@ int dasd_sleep_on(struct dasd_ccw_req *c
 	device = cqr->startdev;
 
 	cqr->callback = dasd_wakeup_cb;
-	cqr->callback_data = (void *) &generic_waitq;
+	cqr->callback_data = DASD_SLEEPON_START_TAG;
 	dasd_add_request_tail(cqr);
 	wait_event(generic_waitq, _wait_for_wakeup(cqr));
 
@@ -1511,7 +1514,7 @@ int dasd_sleep_on_interruptible(struct d
 
 	device = cqr->startdev;
 	cqr->callback = dasd_wakeup_cb;
-	cqr->callback_data = (void *) &generic_waitq;
+	cqr->callback_data = DASD_SLEEPON_START_TAG;
 	dasd_add_request_tail(cqr);
 	rc = wait_event_interruptible(generic_waitq, _wait_for_wakeup(cqr));
 	if (rc == -ERESTARTSYS) {
@@ -1560,7 +1563,7 @@ int dasd_sleep_on_immediatly(struct dasd
 	}
 
 	cqr->callback = dasd_wakeup_cb;
-	cqr->callback_data = (void *) &generic_waitq;
+	cqr->callback_data = DASD_SLEEPON_START_TAG;
 	cqr->status = DASD_CQR_QUEUED;
 	list_add(&cqr->devlist, &device->ccw_queue);
 
