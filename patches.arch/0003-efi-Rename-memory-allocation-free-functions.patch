From 40e4530a00b7d52332fe9a1361388fda8e5260da Mon Sep 17 00:00:00 2001
From: Roy Franz <roy.franz@linaro.org>
Date: Sun, 22 Sep 2013 15:45:29 -0700
Subject: [PATCH] efi: Rename memory allocation/free functions

Git-commit: 40e4530a00b7d52332fe9a1361388fda8e5260da
Patch-mainline: v3.13-rc1
Reference: bnc#876046
Target: sle12

Rename them to be more similar, as low_free() could be used to free
memory allocated by both high_alloc() and low_alloc().
high_alloc() -> efi_high_alloc()
low_alloc()  -> efi_low_alloc()
low_free()   -> efi_free()

Signed-off-by: Roy Franz <roy.franz@linaro.org>
Acked-by: Mark Salter <msalter@redhat.com>
Reviewed-by: Grant Likely <grant.likely@linaro.org>
Signed-off-by: Matt Fleming <matt.fleming@intel.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>

---
 arch/x86/boot/compressed/eboot.c       |   19 ++++++++++---------
 drivers/firmware/efi/efi-stub-helper.c |   14 +++++++-------
 2 files changed, 17 insertions(+), 16 deletions(-)

Index: linux-3.12-SLE12/arch/x86/boot/compressed/eboot.c
===================================================================
--- linux-3.12-SLE12.orig/arch/x86/boot/compressed/eboot.c
+++ linux-3.12-SLE12/arch/x86/boot/compressed/eboot.c
@@ -489,7 +489,8 @@ struct boot_params *make_boot_params(voi
 		return NULL;
 	}
 
-	status = low_alloc(sys_table, 0x4000, 1, (unsigned long *)&boot_params);
+	status = efi_low_alloc(sys_table, 0x4000, 1,
+			       (unsigned long *)&boot_params);
 	if (status != EFI_SUCCESS) {
 		efi_printk(sys_table, "Failed to alloc lowmem for boot params\n");
 		return NULL;
@@ -535,7 +536,7 @@ struct boot_params *make_boot_params(voi
 
 			options_size++;	/* NUL termination */
 
-			status = low_alloc(sys_table, options_size, 1,
+			status = efi_low_alloc(sys_table, options_size, 1,
 					   &cmdline);
 			if (status != EFI_SUCCESS) {
 				efi_printk(sys_table, "Failed to alloc mem for cmdline\n");
@@ -569,9 +570,9 @@ struct boot_params *make_boot_params(voi
 	return boot_params;
 fail2:
 	if (options_size)
-		low_free(sys_table, options_size, hdr->cmd_line_ptr);
+		efi_free(sys_table, options_size, hdr->cmd_line_ptr);
 fail:
-	low_free(sys_table, 0x4000, (unsigned long)boot_params);
+	efi_free(sys_table, 0x4000, (unsigned long)boot_params);
 	return NULL;
 }
 
@@ -594,7 +595,7 @@ static efi_status_t exit_boot(struct boo
 again:
 	size += sizeof(*mem_map) * 2;
 	_size = size;
-	status = low_alloc(sys_table, size, 1, (unsigned long *)&mem_map);
+	status = efi_low_alloc(sys_table, size, 1, (unsigned long *)&mem_map);
 	if (status != EFI_SUCCESS)
 		return status;
 
@@ -602,7 +603,7 @@ get_map:
 	status = efi_call_phys5(sys_table->boottime->get_memory_map, &size,
 				mem_map, &key, &desc_size, &desc_version);
 	if (status == EFI_BUFFER_TOO_SMALL) {
-		low_free(sys_table, _size, (unsigned long)mem_map);
+		efi_free(sys_table, _size, (unsigned long)mem_map);
 		goto again;
 	}
 
@@ -704,7 +705,7 @@ get_map:
 	return EFI_SUCCESS;
 
 free_mem_map:
-	low_free(sys_table, _size, (unsigned long)mem_map);
+	efi_free(sys_table, _size, (unsigned long)mem_map);
 	return status;
 }
 
@@ -727,7 +728,7 @@ static efi_status_t relocate_kernel(stru
 				EFI_ALLOCATE_ADDRESS, EFI_LOADER_DATA,
 				nr_pages, &start);
 	if (status != EFI_SUCCESS) {
-		status = low_alloc(sys_table, hdr->init_size,
+		status = efi_low_alloc(sys_table, hdr->init_size,
 				   hdr->kernel_alignment, &start);
 		if (status != EFI_SUCCESS)
 			efi_printk(sys_table, "Failed to alloc mem for kernel\n");
@@ -779,7 +780,7 @@ struct boot_params *efi_main(void *handl
 	}
 
 	gdt->size = 0x800;
-	status = low_alloc(sys_table, gdt->size, 8,
+	status = efi_low_alloc(sys_table, gdt->size, 8,
 			   (unsigned long *)&gdt->address);
 	if (status != EFI_SUCCESS) {
 		efi_printk(sys_table, "Failed to alloc mem for gdt\n");
Index: linux-3.12-SLE12/drivers/firmware/efi/efi-stub-helper.c
===================================================================
--- linux-3.12-SLE12.orig/drivers/firmware/efi/efi-stub-helper.c
+++ linux-3.12-SLE12/drivers/firmware/efi/efi-stub-helper.c
@@ -86,7 +86,7 @@ fail:
 /*
  * Allocate at the highest possible address that is not above 'max'.
  */
-static efi_status_t high_alloc(efi_system_table_t *sys_table_arg,
+static efi_status_t efi_high_alloc(efi_system_table_t *sys_table_arg,
 			       unsigned long size, unsigned long align,
 			       unsigned long *addr, unsigned long max)
 {
@@ -165,8 +165,8 @@ fail:
 /*
  * Allocate at the lowest possible address.
  */
-static efi_status_t low_alloc(efi_system_table_t *sys_table_arg,
-		unsigned long size, unsigned long align,
+static efi_status_t efi_low_alloc(efi_system_table_t *sys_table_arg,
+			      unsigned long size, unsigned long align,
 			      unsigned long *addr)
 {
 	unsigned long map_size, desc_size;
@@ -226,7 +226,7 @@ fail:
 	return status;
 }
 
-static void low_free(efi_system_table_t *sys_table_arg, unsigned long size,
+static void efi_free(efi_system_table_t *sys_table_arg, unsigned long size,
 		     unsigned long addr)
 {
 	unsigned long nr_pages;
@@ -407,8 +407,8 @@ grow:
 		 * addresses in memory, so allocate enough memory for
 		 * all the initrd's.
 		 */
-		status = high_alloc(sys_table_arg, initrd_total, 0x1000,
-				   &initrd_addr, hdr->initrd_addr_max);
+		status = efi_high_alloc(sys_table_arg, initrd_total, 0x1000,
+				    &initrd_addr, hdr->initrd_addr_max);
 		if (status != EFI_SUCCESS) {
 			efi_printk(sys_table_arg, "Failed to alloc highmem for initrds\n");
 			goto close_handles;
@@ -456,7 +456,7 @@ grow:
 	return status;
 
 free_initrd_total:
-	low_free(sys_table_arg, initrd_total, initrd_addr);
+	efi_free(sys_table_arg, initrd_total, initrd_addr);
 
 close_handles:
 	for (k = j; k < i; k++)
