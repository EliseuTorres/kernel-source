From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: zfcp: Register SCSI devices after fc_remote_port_add
References: bnc#617464,LTC#65797
Patch-mainline: Yes

Symptom:     After a remote port failure, SCSI device files are
             missing.
Problem:     When the ELS ADISC returns, it schedules a call to
             fc_remote_port_add, but it does not trigger the
             registration of SCSI devices. If this is the last
             recovery after a remote port failure and the SCSI devices
             have been deleted from the dev_loss_tmo, the step to
             reregister the SCSI devices is missing.
Solution:    Change the registration of SCSI devices to be triggered
             after the fc_remote_port_add call. For the initial inquiry
             command to succeed the unit must also be open. If the
             unit reopen is still pending, the inquiry command to the
             LUN will be deferred with DID_IMM_RETRY, so there is no
             harm from this approach.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/scsi/zfcp_aux.c   |    2 +-
 drivers/s390/scsi/zfcp_erp.c   |    6 ------
 drivers/s390/scsi/zfcp_ext.h   |    3 ++-
 drivers/s390/scsi/zfcp_scsi.c  |   37 +++++++++++++++++++++++++++++--------
 drivers/s390/scsi/zfcp_sysfs.c |    2 +-
 5 files changed, 33 insertions(+), 17 deletions(-)

--- a/drivers/s390/scsi/zfcp_aux.c	2010-07-06 10:17:02.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_aux.c	2010-07-06 10:31:00.000000000 +0200
@@ -304,7 +304,7 @@ struct zfcp_unit *zfcp_unit_enqueue(stru
 
 	atomic_set(&unit->refcount, 0);
 	init_waitqueue_head(&unit->remove_wq);
-	INIT_WORK(&unit->scsi_work, zfcp_scsi_scan);
+	INIT_WORK(&unit->scsi_work, zfcp_scsi_scan_work);
 
 	unit->port = port;
 	unit->fcp_lun = fcp_lun;
--- a/drivers/s390/scsi/zfcp_erp.c	2010-07-06 10:16:58.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_erp.c	2010-07-06 10:31:00.000000000 +0200
@@ -1169,12 +1169,6 @@ static void zfcp_erp_action_cleanup(stru
 
 	switch (act->action) {
 	case ZFCP_ERP_ACTION_REOPEN_UNIT:
-		if ((result == ZFCP_ERP_SUCCEEDED) && !unit->device) {
-			zfcp_unit_get(unit);
-			if (scsi_queue_work(unit->port->adapter->scsi_host,
-					    &unit->scsi_work) <= 0)
-				zfcp_unit_put(unit);
-		}
 		zfcp_unit_put(unit);
 		break;
 
--- a/drivers/s390/scsi/zfcp_ext.h	2010-07-06 10:17:02.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_ext.h	2010-07-06 10:31:00.000000000 +0200
@@ -160,7 +160,8 @@ extern void zfcp_scsi_rport_work(struct 
 extern void zfcp_scsi_schedule_rport_register(struct zfcp_port *);
 extern void zfcp_scsi_schedule_rport_block(struct zfcp_port *);
 extern void zfcp_scsi_schedule_rports_block(struct zfcp_adapter *);
-extern void zfcp_scsi_scan(struct work_struct *);
+extern void zfcp_scsi_scan(struct zfcp_unit *);
+extern void zfcp_scsi_scan_work(struct work_struct *);
 
 /* zfcp_sysfs.c */
 extern struct attribute_group zfcp_sysfs_unit_attrs;
--- a/drivers/s390/scsi/zfcp_scsi.c	2010-07-06 10:17:03.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_scsi.c	2010-07-06 10:31:00.000000000 +0200
@@ -537,6 +537,20 @@ static void zfcp_scsi_terminate_rport_io
 	}
 }
 
+static void zfcp_scsi_queue_unit_register(struct zfcp_port *port)
+{
+	struct zfcp_unit *unit;
+
+	read_lock_irq(&zfcp_data.config_lock);
+	list_for_each_entry(unit, &port->unit_list_head, list) {
+		zfcp_unit_get(unit);
+		if (scsi_queue_work(port->adapter->scsi_host,
+				    &unit->scsi_work) <= 0)
+			zfcp_unit_put(unit);
+	}
+	read_unlock_irq(&zfcp_data.config_lock);
+}
+
 static void zfcp_scsi_rport_register(struct zfcp_port *port)
 {
 	struct fc_rport_identifiers ids;
@@ -562,6 +576,8 @@ static void zfcp_scsi_rport_register(str
 	rport->supported_classes = port->supported_classes;
 	port->rport = rport;
 	port->starget_id = rport->scsi_target_id;
+
+	zfcp_scsi_queue_unit_register(port);
 }
 
 static void zfcp_scsi_rport_block(struct zfcp_port *port)
@@ -621,21 +637,26 @@ void zfcp_scsi_rport_work(struct work_st
 	zfcp_port_put(port);
 }
 
-
-void zfcp_scsi_scan(struct work_struct *work)
+/**
+ * zfcp_scsi_scan - Register LUN with SCSI midlayer
+ * @unit: The LUN/unit to register
+ */
+void zfcp_scsi_scan(struct zfcp_unit *unit)
 {
-	struct zfcp_unit *unit = container_of(work, struct zfcp_unit,
-					      scsi_work);
-	struct fc_rport *rport;
-
-	flush_work(&unit->port->rport_work);
-	rport = unit->port->rport;
+	struct fc_rport *rport = unit->port->rport;
 
 	if (rport && rport->port_state == FC_PORTSTATE_ONLINE)
 		scsi_scan_target(&rport->dev, 0, rport->scsi_target_id,
 				 scsilun_to_int((struct scsi_lun *)
 						&unit->fcp_lun), 0);
+}
+
+void zfcp_scsi_scan_work(struct work_struct *work)
+{
+	struct zfcp_unit *unit = container_of(work, struct zfcp_unit,
+					      scsi_work);
 
+	zfcp_scsi_scan(unit);
 	zfcp_unit_put(unit);
 }
 
--- a/drivers/s390/scsi/zfcp_sysfs.c	2010-07-06 10:17:03.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_sysfs.c	2010-07-06 10:31:00.000000000 +0200
@@ -226,7 +226,7 @@ static ssize_t zfcp_sysfs_unit_add_store
 
 	zfcp_erp_unit_reopen(unit, 0, "syuas_1", NULL);
 	zfcp_erp_wait(unit->port->adapter);
-	flush_work(&unit->scsi_work);
+	zfcp_scsi_scan(unit);
 	zfcp_unit_put(unit);
 
 	return (ssize_t) count;
