From: Sebastian Ott <sebott@linux.vnet.ibm.com>
Subject: s390/pci: implement pcibios_remove_bus
Patch-mainline: v3.13-rc1
Git-commit: 7d594322b2e65f7e44e82474d17b2d549e22087c
References: FATE#83037, LTC#94737

Implement pcibios_remove_bus to free arch specific data when a pci
bus is deregistered. While at it remove a useless kzalloc/kfree
wrapper.

Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/pci.h |    2 -
 arch/s390/pci/pci.c         |   61 ++++++++++++++++++++++----------------------
 arch/s390/pci/pci_clp.c     |    8 ++---
 3 files changed, 35 insertions(+), 36 deletions(-)

--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@ -138,12 +138,10 @@ static inline bool zdev_enabled(struct z
   Prototypes
 ----------------------------------------------------------------------------- */
 /* Base stuff */
-struct zpci_dev *zpci_alloc_device(void);
 int zpci_create_device(struct zpci_dev *);
 int zpci_enable_device(struct zpci_dev *);
 int zpci_disable_device(struct zpci_dev *);
 void zpci_stop_device(struct zpci_dev *);
-void zpci_free_device(struct zpci_dev *);
 int zpci_register_ioat(struct zpci_dev *, u8, u64, u64, u64);
 int zpci_unregister_ioat(struct zpci_dev *, u8);
 
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -577,20 +577,6 @@ static void zpci_unmap_resources(struct
 	}
 }
 
-struct zpci_dev *zpci_alloc_device(void)
-{
-	struct zpci_dev *zdev;
-
-	/* Alloc memory for our private pci device data */
-	zdev = kzalloc(sizeof(*zdev), GFP_KERNEL);
-	return zdev ? : ERR_PTR(-ENOMEM);
-}
-
-void zpci_free_device(struct zpci_dev *zdev)
-{
-	kfree(zdev);
-}
-
 int pcibios_add_platform_entries(struct pci_dev *pdev)
 {
 	return zpci_sysfs_add_device(&pdev->dev);
@@ -929,22 +915,6 @@ struct dev_pm_ops pcibios_pm_ops = {
 };
 #endif /* CONFIG_HIBERNATE_CALLBACKS */
 
-static int __devinit zpci_scan_bus(struct zpci_dev *zdev)
-{
-	int ret;
-
-	zdev->bus = pci_scan_bus_parented(NULL, ZPCI_BUS_NR, &pci_root_ops, zdev);
-	if (!zdev->bus)
-		return -EIO;
-
-	ret = zpci_setup_bus_resources(zdev);
-	if (ret)
-		return ret;
-
-	pci_bus_add_devices(zdev->bus);
-	return 0;
-}
-
 static int zpci_alloc_domain(struct zpci_dev *zdev)
 {
 	spin_lock(&zpci_domain_lock);
@@ -965,6 +935,37 @@ static void zpci_free_domain(struct zpci
 	spin_unlock(&zpci_domain_lock);
 }
 
+void pcibios_remove_bus(struct pci_bus *bus)
+{
+	struct zpci_dev *zdev = get_zdev_by_bus(bus);
+
+	zpci_exit_slot(zdev);
+	zpci_cleanup_bus_resources(zdev);
+	zpci_free_domain(zdev);
+
+	spin_lock(&zpci_list_lock);
+	list_del(&zdev->entry);
+	spin_unlock(&zpci_list_lock);
+
+	kfree(zdev);
+}
+
+static int __devinit zpci_scan_bus(struct zpci_dev *zdev)
+{
+	int ret;
+
+	zdev->bus = pci_scan_bus_parented(NULL, ZPCI_BUS_NR, &pci_root_ops, zdev);
+	if (!zdev->bus)
+		return -EIO;
+
+	ret = zpci_setup_bus_resources(zdev);
+	if (ret)
+		return ret;
+
+	pci_bus_add_devices(zdev->bus);
+	return 0;
+}
+
 int zpci_enable_device(struct zpci_dev *zdev)
 {
 	int rc;
--- a/arch/s390/pci/pci_clp.c
+++ b/arch/s390/pci/pci_clp.c
@@ -155,9 +155,9 @@ int __devinit clp_add_pci_device(u32 fid
 	int rc;
 
 	zpci_dbg(3, "add fid:%x, fh:%x, c:%d\n", fid, fh, configured);
-	zdev = zpci_alloc_device();
-	if (IS_ERR(zdev))
-		return PTR_ERR(zdev);
+	zdev = kzalloc(sizeof(*zdev), GFP_KERNEL);
+	if (!zdev)
+		return -ENOMEM;
 
 	zdev->fh = fh;
 	zdev->fid = fid;
@@ -178,7 +178,7 @@ int __devinit clp_add_pci_device(u32 fid
 	return 0;
 
 error:
-	zpci_free_device(zdev);
+	kfree(zdev);
 	return rc;
 }
 
