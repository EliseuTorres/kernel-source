From: SGI (tee@sgi.com, steiner@sgi.com, rja@sgi.com)
Subject: UV: determine revision id of the node controller chip
Patch-mainline: 7a1110e861b2666ac09f5708d6fbe71d18ce64bb, 1d2c867c941d635e53e8ad7bf37d060bb5b25ec5
References: bnc#575396

Add function for determining the revision id of the SGI UV
node controller chip (HUB). This function is needed in a subsequent patch.

Signed-off-by: Jack Steiner <steiner@sgi.com>
Acked-by: Jiri Kosina <jkosina@suse.cz>

---
 arch/x86/include/asm/uv/uv_hub.h   |   12 ++++++++++++
 arch/x86/kernel/apic/x2apic_uv_x.c |   12 +++++++++++-
 2 files changed, 23 insertions(+), 1 deletion(-)

Index: linux/arch/x86/include/asm/uv/uv_hub.h
===================================================================
--- linux.orig/arch/x86/include/asm/uv/uv_hub.h	2010-01-18 15:32:12.000000000 -0600
+++ linux/arch/x86/include/asm/uv/uv_hub.h	2010-01-19 14:39:30.000000000 -0600
@@ -495,5 +495,17 @@ static inline void uv_hub_send_ipi(int p
 	uv_write_global_mmr64(pnode, UVH_IPI_INT, val);
 }
 
+/*
+ * Get the minimum revision number of the hub chips within the partition.
+ *     1 - initial rev 1.0 silicon
+ *     2 - rev 2.0 production silicon
+ */
+static inline int uv_get_min_hub_revision_id(void)
+{
+	extern int uv_min_hub_revision_id;
+
+	return uv_min_hub_revision_id;
+}
+
 #endif /* CONFIG_X86_64 */
 #endif /* _ASM_X86_UV_UV_HUB_H */
Index: linux/arch/x86/kernel/apic/x2apic_uv_x.c
===================================================================
--- linux.orig/arch/x86/kernel/apic/x2apic_uv_x.c	2010-01-19 14:30:44.000000000 -0600
+++ linux/arch/x86/kernel/apic/x2apic_uv_x.c	2010-01-19 14:40:23.000000000 -0600
@@ -36,6 +36,9 @@ DEFINE_PER_CPU(int, x2apic_extra_bits);
 
 static enum uv_system_type uv_system_type;
 static u64 gru_start_paddr, gru_end_paddr;
+int uv_min_hub_revision_id;
+EXPORT_SYMBOL_GPL(uv_min_hub_revision_id);
+
 
 static int is_GRU_range(u64 start, u64 end)
 {
@@ -55,12 +58,19 @@ static int early_get_nodeid(void)
 	mmr = early_ioremap(UV_LOCAL_MMR_BASE | UVH_NODE_ID, sizeof(*mmr));
 	node_id.v = *mmr;
 	early_iounmap(mmr, sizeof(*mmr));
+
+	/* Currently, all blades have same revision number */
+	uv_min_hub_revision_id = node_id.s.revision;
+
 	return node_id.s.node_id;
 }
 
 static int __init uv_acpi_madt_oem_check(char *oem_id, char *oem_table_id)
 {
+	int nodeid;
+
 	if (!strcmp(oem_id, "SGI")) {
+		nodeid = early_get_nodeid();
 		x86_platform.is_untracked_pat_range =  uv_is_untracked_pat_range;
 		if (!strcmp(oem_table_id, "UVL"))
 			uv_system_type = UV_LEGACY_APIC;
@@ -68,7 +78,7 @@ static int __init uv_acpi_madt_oem_check
 			uv_system_type = UV_X2APIC;
 		else if (!strcmp(oem_table_id, "UVH")) {
 			__get_cpu_var(x2apic_extra_bits) =
-				early_get_nodeid() << (UV_APIC_PNODE_SHIFT - 1);
+				nodeid << (UV_APIC_PNODE_SHIFT - 1);
 			uv_system_type = UV_NON_UNIQUE_APIC;
 			return 1;
 		}
