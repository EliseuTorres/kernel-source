From: geraldsc@de.ibm.com
Subject: af_iucv: offer new getsockopt SO_MSGSIZE
Patch-mainline: yes
References: bnc#744795

Symptom: socket program cannot determine maximum size of a message
Problem: AF_IUCV sockets with HS transport are bound to a certain
             HiperSockets interface, which is defined with one out of
             four possible frame / mtu sizes. The maximum message size
             to send depends on this mtu size, but an AF_IUCV socket
             program does not have an option to determine this maximum
             message size in advance.
Solution: Introduce a new getsockopt option called SO_MSGSIZE.

Signed-off-by: Gerald Schaefer <geraldsc@de.ibm.com>
Acked-by: Torsten Duwe <duwe@suse.de>

---
 include/net/iucv/af_iucv.h |    1 +
 net/iucv/af_iucv.c         |   10 +++++++++-
 2 files changed, 10 insertions(+), 1 deletion(-)

--- a/include/net/iucv/af_iucv.h
+++ b/include/net/iucv/af_iucv.h
@@ -132,6 +132,7 @@ struct iucv_sock {
 /* iucv socket options (SOL_IUCV) */
 #define SO_IPRMDATA_MSG	0x0080		/* send/recv IPRM_DATA msgs */
 #define SO_MSGLIMIT	0x1000		/* get/set IUCV MSGLIMIT */
+#define SO_MSGSIZE      0x0800		/* get maximum msgsize */
 
 /* iucv related control messages (scm) */
 #define SCM_IUCV_TRGCLS	0x0001		/* target class control message */
--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@ -1655,7 +1655,8 @@ static int iucv_sock_getsockopt(struct s
 {
 	struct sock *sk = sock->sk;
 	struct iucv_sock *iucv = iucv_sk(sk);
-	int val, len;
+	unsigned int val;
+	int len;
 
 	if (level != SOL_IUCV)
 		return -ENOPROTOOPT;
@@ -1678,6 +1679,13 @@ static int iucv_sock_getsockopt(struct s
 					   : iucv->msglimit;	/* default */
 		release_sock(sk);
 		break;
+	case SO_MSGSIZE:
+		if (sk->sk_state == IUCV_OPEN)
+			return -EBADFD;
+		val = (iucv->hs_dev) ? iucv->hs_dev->mtu -
+				sizeof(struct af_iucv_trans_hdr) - ETH_HLEN :
+				0x7fffffff;
+		break;
 	default:
 		return -ENOPROTOOPT;
 	}
