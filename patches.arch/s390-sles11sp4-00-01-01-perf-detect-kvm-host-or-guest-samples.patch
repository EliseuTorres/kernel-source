From: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Subject: KVM: s390,perf: Detect if perf samples belong to KVM host or guest
Patch-mainline: v3.11-rc1
Git-commit: b764bb1c50c279b95a486d338418f7fda74fff71
References: bnc#900899, FATE#317698, LTC#110510

Summary:     s390/perf: add support for the CPU-measurement sampling facility
Description: Use the CPU-measurement sampling facility to obtain performance
             data for Linux in LPAR mode.  You can use the perf tool on Linux
             to access the hardware sample data of the CPU-measurement
             sampling facility.

Upstream-Description:

             KVM: s390,perf: Detect if perf samples belong to KVM host or guest

             This patch is based on an original patch of David Hildenbrand.

             The perf core implementation calls architecture specific code in order
             to ask for specific information for a particular sample:

             perf_instruction_pointer()
             When perf core code asks for the instruction pointer, architecture
             specific code must detect if a KVM guest was running when the sample
             was taken. A sample can be associated with a  KVM guest when the PSW
             supervisor state bit is set and the PSW instruction pointer part
             contains the address of 'sie_exit'.
             A KVM guest's instruction pointer information is then retrieved via
             gpsw entry pointed to by the sie control-block.

             perf_misc_flags()
             perf code code calls this function in order to associate the kernel
             vs. user state infomation with a particular sample. Architecture
             specific code must also first detectif a KVM guest was running
             at the time the sample was taken.

             Signed-off-by: Heinz Graalfs <graalfs@linux.vnet.ibm.com>
             Reviewed-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
             Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
             Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
             Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>


Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/kvm_host.h   |    1 
 arch/s390/include/asm/perf_event.h |   10 +++++++
 arch/s390/kernel/entry64.S         |    1 
 arch/s390/kernel/perf_event.c      |   52 +++++++++++++++++++++++++++++++++++++
 arch/s390/kernel/s390_ksyms.c      |    1 
 5 files changed, 65 insertions(+)

--- a/arch/s390/include/asm/kvm_host.h
+++ b/arch/s390/include/asm/kvm_host.h
@@ -263,4 +263,5 @@ struct kvm_arch{
 };
 
 extern int sie64a(struct kvm_s390_sie_block *, u64 *);
+extern char sie_exit;
 #endif
--- a/arch/s390/include/asm/perf_event.h
+++ b/arch/s390/include/asm/perf_event.h
@@ -15,3 +15,13 @@
 /* Per-CPU flags for PMU states */
 #define PMU_F_RESERVED			0x1000
 #define PMU_F_ENABLED			0x2000
+
+#ifdef CONFIG_64BIT
+
+/* Perf callbacks */
+struct pt_regs;
+extern unsigned long perf_instruction_pointer(struct pt_regs *regs);
+extern unsigned long perf_misc_flags(struct pt_regs *regs);
+#define perf_misc_flags(regs) perf_misc_flags(regs)
+
+#endif /* CONFIG_64BIT */
--- a/arch/s390/kernel/entry64.S
+++ b/arch/s390/kernel/entry64.S
@@ -1104,6 +1104,7 @@ sie_loop:
 sie_done:
 	SPP	__LC_CMF_HPP			# set host id
 	lg	%r14,__LC_THREAD_INFO		# pointer thread_info struct
+	.globl sie_exit
 sie_exit:
 	ni	__TI_flags+6(%r14),255-(_TIF_SIE>>8)
 	lg	%r14,__SF_EMPTY+8(%r15)		# load guest register save area
--- a/arch/s390/kernel/perf_event.c
+++ b/arch/s390/kernel/perf_event.c
@@ -13,6 +13,7 @@
 
 #include <linux/kernel.h>
 #include <linux/perf_event.h>
+#include <linux/kvm_host.h>
 #include <linux/percpu.h>
 #include <linux/module.h>
 #include <asm/system.h>
@@ -40,6 +41,57 @@ int perf_num_counters(void)
 }
 EXPORT_SYMBOL(perf_num_counters);
 
+static struct kvm_s390_sie_block *sie_block(struct pt_regs *regs)
+{
+	struct stack_frame *stack = (struct stack_frame *) regs->gprs[15];
+
+	if (!stack)
+		return NULL;
+
+	return (struct kvm_s390_sie_block *) stack->empty1[0];
+}
+
+static bool is_in_guest(struct pt_regs *regs)
+{
+	unsigned long ip = instruction_pointer(regs);
+
+	if (user_mode(regs))
+		return false;
+
+	return ip == (unsigned long) &sie_exit;
+}
+
+static unsigned long guest_is_user_mode(struct pt_regs *regs)
+{
+	return sie_block(regs)->gpsw.mask & PSW_MASK_PSTATE;
+}
+
+static unsigned long instruction_pointer_guest(struct pt_regs *regs)
+{
+	return sie_block(regs)->gpsw.addr & PSW_ADDR_INSN;
+}
+
+unsigned long perf_instruction_pointer(struct pt_regs *regs)
+{
+	return is_in_guest(regs) ? instruction_pointer_guest(regs)
+				 : instruction_pointer(regs);
+}
+
+static unsigned long perf_misc_guest_flags(struct pt_regs *regs)
+{
+	return guest_is_user_mode(regs) ? PERF_RECORD_MISC_GUEST_USER
+					: PERF_RECORD_MISC_GUEST_KERNEL;
+}
+
+unsigned long perf_misc_flags(struct pt_regs *regs)
+{
+	if (is_in_guest(regs))
+		return perf_misc_guest_flags(regs);
+
+	return user_mode(regs) ? PERF_RECORD_MISC_USER
+			       : PERF_RECORD_MISC_KERNEL;
+}
+
 void perf_event_print_debug(void)
 {
 	struct cpumf_ctr_info cf_info;
--- a/arch/s390/kernel/s390_ksyms.c
+++ b/arch/s390/kernel/s390_ksyms.c
@@ -7,4 +7,5 @@ EXPORT_SYMBOL(_mcount);
 #endif
 #if defined(CONFIG_KVM) || defined(CONFIG_KVM_MODULE)
 EXPORT_SYMBOL(sie64a);
+EXPORT_SYMBOL(sie_exit);
 #endif
