Subject: kernel: fix get_user_pages_fast() page table walk
From: Heiko Carstens <heiko.carstens@de.ibm.com>
Patch-mainline: Submitted
References: bnc#786976,LTC#86307

Symptom:      Addressing exception (Oops) within the get_user_pages_fast()
              function. The kernel may hang afterwards.
Problem:      When walking the page table of a process by using the
              get_user_pages_fast() code there is no check if the to be
              translated address is within the limits the page tables of the
              process can map. Together with the feature that the page table
              walk code is able to handle both three and four level page tables
              this can lead to invalid offsets.
              Subsequently the page table walk code will dereference more or
              less random addresses and can cause an addressing exception.
Solution:     Check if the to be translated address is within the limits the
              page tables of the process can map before walking them.
Reproduction: -

Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/mm/gup.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/arch/s390/mm/gup.c
+++ b/arch/s390/mm/gup.c
@@ -183,7 +183,7 @@ int get_user_pages_fast(unsigned long st
 	addr = start;
 	len = (unsigned long) nr_pages << PAGE_SHIFT;
 	end = start + len;
-	if (end < start)
+	if ((end < start) || (end > TASK_SIZE))
 		goto slow_irqon;
 
 	/*
