From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Subject: s390: PCI stub functions
Patch-mainline: no
Git-commit: -
References: bnc#802343, FATE#83037, ltc#83040

Define empty PCI arch primitives to be able to compile PCI code.
The PCI code will do nothing, the pci_base_init function returns
ENODEV to prevent initialization.

Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/Kbuild                    |    1 
 arch/s390/Kconfig                   |   59 +++++++++++++++++--
 arch/s390/include/asm/dma-mapping.h |   65 +++++++++++++++++++++
 arch/s390/include/asm/dma.h         |   17 ++++-
 arch/s390/include/asm/hw_irq.h      |   28 +++++++++
 arch/s390/include/asm/io.h          |   55 +++++++++++++++++-
 arch/s390/include/asm/irq.h         |   10 +++
 arch/s390/include/asm/pci.h         |   36 ++++++++++--
 arch/s390/pci/Makefile              |    5 +
 arch/s390/pci/pci.c                 |  107 ++++++++++++++++++++++++++++++++++++
 10 files changed, 367 insertions(+), 16 deletions(-)

--- a/arch/s390/Kbuild
+++ b/arch/s390/Kbuild
@@ -4,3 +4,4 @@ obj-y += crypto/
 obj-y += appldata/
 obj-y += hypfs/
 obj-y += kvm/
+obj-$(CONFIG_PCI) += pci/
--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@ -40,12 +40,6 @@ config GENERIC_BUG
 config GENERIC_BUG_RELATIVE_POINTERS
 	def_bool y
 
-config NO_IOMEM
-	def_bool y
-
-config NO_DMA
-	def_bool y
-
 config ARCH_DMA_ADDR_T_64BIT
 	def_bool 64BIT
 
@@ -61,6 +55,12 @@ config VIRT_CPU_ACCOUNTING
 config ARCH_SUPPORTS_DEBUG_PAGEALLOC
 	def_bool y
 
+config NO_IOPORT
+	def_bool y
+
+config PCI_QUIRKS
+	def_bool n
+
 config S390
 	def_bool y
 	select USE_GENERIC_SMP_HELPERS if SMP
@@ -390,6 +390,53 @@ config QDIO
 
 	  If unsure, say Y.
 
+menuconfig PCI
+	bool "PCI support"
+	default n
+	depends on 64BIT
+	select ARCH_SUPPORTS_MSI
+	select PCI_MSI
+	help
+	  Enable PCI support.
+
+if PCI
+
+config PCI_NR_FUNCTIONS
+	int "Maximum number of PCI functions (1-4096)"
+	range 1 4096
+	default "64"
+	help
+	  This allows you to specify the maximum number of PCI functions which
+	  this kernel will support.
+
+source "drivers/pci/Kconfig"
+source "drivers/pci/pcie/Kconfig"
+source "drivers/pci/hotplug/Kconfig"
+
+endif  # PCI
+
+config PCI_DOMAINS
+       def_bool PCI
+
+config HAS_IOMEM
+       def_bool PCI
+
+config IOMMU_HELPER
+       def_bool PCI
+
+config HAS_DMA
+       def_bool PCI
+       select HAVE_DMA_API_DEBUG
+
+config NEED_SG_DMA_LENGTH
+       def_bool PCI
+
+config HAVE_DMA_ATTRS
+       def_bool PCI
+
+config NEED_DMA_MAP_STATE
+       def_bool PCI
+
 config CHSC_SCH
 	def_tristate m
 	prompt "Support for CHSC subchannels"
--- /dev/null
+++ b/arch/s390/include/asm/dma-mapping.h
@@ -0,0 +1,65 @@
+#ifndef _ASM_S390_DMA_MAPPING_H
+#define _ASM_S390_DMA_MAPPING_H
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-attrs.h>
+#include <linux/dma-debug.h>
+#include <linux/io.h>
+
+#define DMA_ERROR_CODE		(~(dma_addr_t) 0x0)
+
+static inline struct dma_map_ops *get_dma_ops(struct device *dev)
+{
+	return NULL;
+}
+
+static inline int dma_set_mask(struct device *dev, u64 mask)
+{
+	return 0;
+}
+
+static inline int dma_is_consistent(struct device *dev, dma_addr_t dma_handle)
+{
+	return 1;
+}
+
+static inline void dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+				  enum dma_data_direction direction)
+{
+}
+
+#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
+#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
+
+#include <asm-generic/dma-mapping-common.h>
+
+static inline int dma_supported(struct device *dev, u64 mask)
+{
+	return 0;
+}
+
+static inline bool dma_capable(struct device *dev, dma_addr_t addr, size_t size)
+{
+	return 0;
+}
+
+static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+{
+	return 0;
+}
+
+static inline void *dma_alloc_coherent(struct device *dev, size_t size,
+				       dma_addr_t *dma_handle, gfp_t flag)
+{
+	return NULL;
+}
+
+static inline void dma_free_coherent(struct device *dev, size_t size,
+				     void *cpu_addr, dma_addr_t dma_handle)
+{
+}
+
+#endif /* _ASM_S390_DMA_MAPPING_H */
--- a/arch/s390/include/asm/dma.h
+++ b/arch/s390/include/asm/dma.h
@@ -4,13 +4,22 @@
  *  S390 version
  */
 
-#ifndef _ASM_DMA_H
-#define _ASM_DMA_H
+#ifndef _ASM_S390_DMA_H
+#define _ASM_S390_DMA_H
 
 #include <asm/io.h>		/* need byte IO */
 
+/*
+ * MAX_DMA_ADDRESS is ambiguous because on s390 its completely unrelated
+ * to DMA. It _is_ used for the s390 memory zone split at 2GB caused
+ * by the 31 bit heritage.
+ */
 #define MAX_DMA_ADDRESS         0x80000000
 
-#define free_dma(x)	do { } while (0)
+#ifdef CONFIG_PCI
+extern int isa_dma_bridge_buggy;
+#else
+#define isa_dma_bridge_buggy	(0)
+#endif
 
-#endif /* _ASM_DMA_H */
+#endif /* _ASM_S390_DMA_H */
--- /dev/null
+++ b/arch/s390/include/asm/hw_irq.h
@@ -0,0 +1,28 @@
+#ifndef _HW_IRQ_H
+#define _HW_IRQ_H
+
+#include <linux/msi.h>
+#include <linux/pci.h>
+
+static inline struct msi_desc *irq_get_msi_desc(unsigned int irq)
+{
+	return NULL;
+}
+
+static inline struct msi_desc *irq_data_get_msi(struct irq_data *d)
+{
+	return NULL;
+}
+
+/* Must be called with msi map lock held */
+static inline int irq_set_msi_desc(unsigned int irq, struct msi_desc *msi)
+{
+	return -EINVAL;
+}
+
+static inline int irq_has_action(unsigned int irq)
+{
+	return 0;
+}
+
+#endif
--- a/arch/s390/include/asm/io.h
+++ b/arch/s390/include/asm/io.h
@@ -13,10 +13,9 @@
 
 #ifdef __KERNEL__
 
+#include <linux/kernel.h>
 #include <asm/page.h>
 
-#define IO_SPACE_LIMIT 0xffffffff
-
 /*
  * Change virtual addresses to physical addresses and vv.
  * These are pretty trivial
@@ -32,6 +31,7 @@ static inline unsigned long virt_to_phys
 		 : "=a" (real_address) : "a" (address) : "cc");
         return real_address;
 }
+#define virt_to_phys virt_to_phys
 
 static inline void * phys_to_virt(unsigned long address)
 {
@@ -46,6 +46,57 @@ void unxlate_dev_mem_ptr(phys_addr_t phy
  */
 #define xlate_dev_kmem_ptr(p)	p
 
+#define IO_SPACE_LIMIT 0
+
+#ifdef CONFIG_PCI
+
+#define ioremap_nocache(addr, size)	ioremap(addr,size)
+#define ioremap_wc(addr, size)		ioremap(addr,size)
+
+/* TODO: s390 cannot support io_remap_pfn_range... */
+#define io_remap_pfn_range(vma, vaddr, pfn, size, prot) 	       \
+	remap_pfn_range(vma, vaddr, pfn, size, prot)
+
+static inline void __iomem *ioremap(unsigned long offset, unsigned long size)
+{
+	return (void __iomem *) offset;
+}
+
+static inline void iounmap(volatile void __iomem *addr)
+{
+}
+
+/*
+ * s390 needs a private implementation of pci_iomap since ioremap with its
+ * offset parameter isn't sufficient. That's because BAR spaces are not
+ * disjunctive on s390 so we need the bar parameter of pci_iomap to find
+ * the corresponding device and create the mapping cookie.
+ */
+#define pci_iomap pci_iomap
+#define pci_iounmap pci_iounmap
+
+#define memcpy_fromio(dst, src, count)	do { } while (0)
+#define memcpy_toio(dst, src, count)	do { } while (0)
+#define memset_io(dst, val, count)	do { } while (0)
+
+#define __raw_readb(addr)	(0)
+#define __raw_readw(addr)	(0)
+#define __raw_readl(addr)	(0)
+#define __raw_readq(addr)	(0)
+#define __raw_writeb(addr,val)	do { } while (0)
+#define __raw_writew(addr,val)	do { } while (0)
+#define __raw_writel(addr,val)	do { } while (0)
+#define __raw_writeq(addr,val)	do { } while (0)
+
+#define readb_relaxed	readb
+#define readw_relaxed	readw
+#define readl_relaxed	readl
+#define readq_relaxed	readq
+
+#endif /* CONFIG_PCI */
+
+#include <asm-generic/io.h>
+
 #endif /* __KERNEL__ */
 
 #endif
--- a/arch/s390/include/asm/irq.h
+++ b/arch/s390/include/asm/irq.h
@@ -44,4 +44,14 @@ void service_subclass_irq_unregister(voi
 void measurement_alert_subclass_register(void);
 void measurement_alert_subclass_unregister(void);
 
+#ifdef CONFIG_LOCKDEP
+#  define disable_irq_nosync_lockdep(irq)	disable_irq_nosync(irq)
+#  define disable_irq_nosync_lockdep_irqsave(irq, flags) \
+						disable_irq_nosync(irq)
+#  define disable_irq_lockdep(irq)		disable_irq(irq)
+#  define enable_irq_lockdep(irq)		enable_irq(irq)
+#  define enable_irq_lockdep_irqrestore(irq, flags) \
+						enable_irq(irq)
+#endif
+
 #endif /* _ASM_IRQ_H */
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@ -1,10 +1,38 @@
 #ifndef __ASM_S390_PCI_H
 #define __ASM_S390_PCI_H
 
-/* S/390 systems don't have a PCI bus. This file is just here because some stupid .c code
- * includes it even if CONFIG_PCI is not set.
- */
+/* must be set before including asm-generic/pci.h */
 #define PCI_DMA_BUS_IS_PHYS (0)
+/* must be set before including pci_clp.h */
+#define PCI_BAR_COUNT	6
 
-#endif /* __ASM_S390_PCI_H */
+#include <asm-generic/pci.h>
+#include <asm-generic/pci-dma-compat.h>
 
+#define PCIBIOS_MIN_IO		0x1000
+#define PCIBIOS_MIN_MEM		0x10000000
+
+#define pcibios_assign_all_busses()	(0)
+
+#define pcibios_set_master(pdev)	do { } while (0)
+#define pcibios_fixup_bus(bus)		do { } while (0)
+#define pcibios_setup(str)		(NULL)
+
+void __iomem *pci_iomap(struct pci_dev *, int, unsigned long);
+void pci_iounmap(struct pci_dev *, void __iomem *);
+int pci_domain_nr(struct pci_bus *);
+int pci_proc_domain(struct pci_bus *);
+
+/* MSI arch hooks */
+#define arch_setup_msi_irqs(dev,nvec,flags)	(-ENODEV)
+#define arch_teardown_msi_irqs(dev)		do { } while (0)
+
+struct msi_map {
+	unsigned long irq;
+	struct msi_desc *msi;
+	struct hlist_node msi_chain;
+};
+
+extern unsigned int pci_probe;
+
+#endif
--- /dev/null
+++ b/arch/s390/pci/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the s390 PCI subsystem.
+#
+
+obj-$(CONFIG_PCI)	+= pci.o
--- /dev/null
+++ b/arch/s390/pci/pci.c
@@ -0,0 +1,107 @@
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/seq_file.h>
+#include <linux/pci.h>
+#include <linux/msi.h>
+
+int pcibios_enable_device(struct pci_dev *pdev, int mask)
+{
+	return -ENXIO;
+}
+
+void pcibios_disable_device(struct pci_dev *pdev)
+{
+}
+
+resource_size_t pcibios_align_resource(void *data, const struct resource *res,
+				       resource_size_t size,
+				       resource_size_t align)
+{
+	return 0;
+}
+
+int pci_domain_nr(struct pci_bus *bus)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pci_domain_nr);
+
+int pci_proc_domain(struct pci_bus *bus)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pci_proc_domain);
+
+void synchronize_irq(unsigned int irq)
+{
+}
+EXPORT_SYMBOL_GPL(synchronize_irq);
+
+void enable_irq(unsigned int irq)
+{
+}
+EXPORT_SYMBOL_GPL(enable_irq);
+
+void disable_irq(unsigned int irq)
+{
+}
+EXPORT_SYMBOL_GPL(disable_irq);
+
+void disable_irq_nosync(unsigned int irq)
+{
+}
+EXPORT_SYMBOL_GPL(disable_irq_nosync);
+
+unsigned long probe_irq_on(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(probe_irq_on);
+
+int probe_irq_off(unsigned long val)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(probe_irq_off);
+
+unsigned int probe_irq_mask(unsigned long val)
+{
+	return val;
+}
+EXPORT_SYMBOL_GPL(probe_irq_mask);
+
+void __iomem *pci_iomap(struct pci_dev *pdev, int bar, unsigned long max)
+{
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(pci_iomap);
+
+void pci_iounmap(struct pci_dev *pdev, void __iomem *addr)
+{
+}
+EXPORT_SYMBOL_GPL(pci_iounmap);
+
+int request_irq(unsigned int irq, irq_handler_t handler,
+                unsigned long irqflags, const char *devname, void *dev_id)
+{
+        return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(request_irq);
+
+void free_irq(unsigned int irq, void *dev_id)
+{
+}
+EXPORT_SYMBOL_GPL(free_irq);
+
+unsigned int pci_probe = 1;
+EXPORT_SYMBOL_GPL(pci_probe);
+
+static int __init pci_base_init(void)
+{
+	return -ENODEV;
+}
+subsys_initcall(pci_base_init);
