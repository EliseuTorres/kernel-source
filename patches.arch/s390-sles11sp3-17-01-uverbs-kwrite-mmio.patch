From: Alexey Ishchuk <alexey_ishchuk@ru.ibm.com>
Subject: [PATCH] [FEAT NET1222] ib_uverbs: Allow explicit mmio trigger.
Patch-mainline: no
Git-commit: -
References: FATE#83366, ltc#83367

Summary:     ib_uverbs: Allow explicit mmio trigger.
Description: Infiniband device users can trigger an explicit mmio
             via a the new function ssize_t ib_uverbs_kwrite_mmio().

Signed-off-by: Alexey Ishchuk <alexey_ishchuk@ru.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/infiniband/core/uverbs.h      |    2 -
 drivers/infiniband/core/uverbs_cmd.c  |   42 +++++++++++++++++++++++++
 drivers/infiniband/core/uverbs_main.c |    1 
 drivers/infiniband/hw/mlx4/main.c     |   57 +++++++++++++++++++++++++++++++++-
 drivers/infiniband/hw/mlx4/mlx4_ib.h  |    8 ++++
 include/rdma/ib_user_verbs.h          |   12 +++++++
 include/rdma/ib_verbs.h               |    6 +++
 7 files changed, 126 insertions(+), 2 deletions(-)

--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@ -215,6 +215,6 @@ IB_UVERBS_DECLARE_CMD(modify_xrc_rcv_qp)
 IB_UVERBS_DECLARE_CMD(query_xrc_rcv_qp);
 IB_UVERBS_DECLARE_CMD(reg_xrc_rcv_qp);
 IB_UVERBS_DECLARE_CMD(unreg_xrc_rcv_qp);
-
+IB_UVERBS_DECLARE_CMD(kwrite_mmio);
 
 #endif /* UVERBS_H */
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@ -1460,6 +1460,48 @@ ssize_t ib_uverbs_destroy_qp(struct ib_u
 	return in_len;
 }
 
+ssize_t ib_uverbs_kwrite_mmio(struct ib_uverbs_file *file,
+			       const char __user *buf,
+			       int in_len,
+			       int out_len)
+{
+	struct ib_uverbs_kwrite_mmio	cmd;
+	ssize_t				ret = -EINVAL;
+
+	if (copy_from_user(&cmd, buf, sizeof(cmd)))
+		return -EFAULT;
+
+	if (in_len < sizeof(cmd))
+		return -EINVAL;
+
+	if (file->device->ib_dev->kwrite_mmio32 == NULL ||
+	    file->device->ib_dev->kwrite_mmio64 == NULL) {
+		dev_alert(file->device->dev,
+			"The verb %s is not supported by the driver.\n",
+			"IB_USER_VERBS_CMD_KWRITE_MMIO");
+		return -ENOSYS;
+	}
+
+	mutex_lock(&file->mutex);
+	switch (cmd.data_length) {
+	case 4:
+		ret = file->device->ib_dev->kwrite_mmio32(file->ucontext,
+							cmd.offset,
+							cmd.value.data32);
+		break;
+	case 8:
+		ret = file->device->ib_dev->kwrite_mmio64(file->ucontext,
+							cmd.offset,
+							cmd.value.data64);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	mutex_unlock(&file->mutex);
+
+	return ret;
+}
+
 ssize_t ib_uverbs_post_send(struct ib_uverbs_file *file,
 			    const char __user *buf, int in_len,
 			    int out_len)
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@ -116,6 +116,7 @@ static ssize_t (*uverbs_cmd_table[])(str
 	[IB_USER_VERBS_CMD_QUERY_XRC_RCV_QP]	= ib_uverbs_query_xrc_rcv_qp,
 	[IB_USER_VERBS_CMD_REG_XRC_RCV_QP]	= ib_uverbs_reg_xrc_rcv_qp,
 	[IB_USER_VERBS_CMD_UNREG_XRC_RCV_QP]	= ib_uverbs_unreg_xrc_rcv_qp,
+	[IB_USER_VERBS_CMD_KWRITE_MMIO]		= ib_uverbs_kwrite_mmio,
 };
 
 static void ib_uverbs_add_one(struct ib_device *device);
--- a/drivers/infiniband/hw/mlx4/main.c
+++ b/drivers/infiniband/hw/mlx4/main.c
@@ -591,6 +591,14 @@ static struct ib_ucontext *mlx4_ib_alloc
 		kfree(context);
 		return ERR_PTR(err);
 	}
+	context->uar_mmap =
+		ioremap((phys_addr_t) context->uar.pfn << PAGE_SHIFT,
+			PAGE_SIZE);
+	if (!context->uar_mmap) {
+		mlx4_uar_free(to_mdev(ibdev)->dev, &context->uar);
+		kfree(context);
+		return ERR_PTR(-ENOMEM);
+	}
 
 	INIT_LIST_HEAD(&context->db_page_list);
 	mutex_init(&context->db_page_mutex);
@@ -601,6 +609,7 @@ static struct ib_ucontext *mlx4_ib_alloc
 		err = ib_copy_to_udata(udata, &resp, sizeof(resp));
 
 	if (err) {
+		iounmap(context->uar_mmap);
 		mlx4_uar_free(to_mdev(ibdev)->dev, &context->uar);
 		kfree(context);
 		return ERR_PTR(-EFAULT);
@@ -613,6 +622,7 @@ static int mlx4_ib_dealloc_ucontext(stru
 {
 	struct mlx4_ib_ucontext *context = to_mucontext(ibcontext);
 
+	iounmap(context->uar_mmap);
 	mlx4_uar_free(to_mdev(ibcontext->device)->dev, &context->uar);
 	kfree(context);
 
@@ -647,6 +657,48 @@ static int mlx4_ib_mmap(struct ib_uconte
 	return 0;
 }
 
+int mlx4_ib_kwrite_mmio32(struct ib_ucontext *ibcontext, u64 offset, u32 value)
+{
+	struct mlx4_ib_ucontext *ctx = to_mucontext(ibcontext);
+
+	if ((offset + sizeof(value)) >= PAGE_SIZE)
+		return -EINVAL;
+
+	if (ctx->uar_mmap) {
+		wmb();
+		writel(value, ctx->uar_mmap + offset);
+		mmiowb();
+	} else
+		return -ENOMEM;
+
+	return 0;
+}
+
+int mlx4_ib_kwrite_mmio64(struct ib_ucontext *ibcontext, u64 offset, u64 value)
+{
+	struct mlx4_ib_ucontext *ctx = to_mucontext(ibcontext);
+
+	if ((offset + sizeof(value)) >= PAGE_SIZE)
+		return -EINVAL;
+
+	if (ctx->uar_mmap) {
+#ifdef CONFIG_64BIT
+		wmb();
+		writeq(value, ctx->uar_mmap + offset);
+#else
+		u64 buf = cpu_to_le64(value);
+
+		wmb();
+		__raw_writel(((u32 *)&buf)[0], ctx->uar_mmap + offset);
+		__raw_writel(((u32 *)&buf)[1], ctx->uar_mmap + offset + 4);
+#endif
+		mmiowb();
+	} else
+		return -ENOMEM;
+
+	return 0;
+}
+
 static struct ib_pd *mlx4_ib_alloc_pd(struct ib_device *ibdev,
 				      struct ib_ucontext *context,
 				      struct ib_udata *udata)
@@ -1404,7 +1456,8 @@ static void *mlx4_ib_add(struct mlx4_dev
 		(1ull << IB_USER_VERBS_CMD_CREATE_SRQ)		|
 		(1ull << IB_USER_VERBS_CMD_MODIFY_SRQ)		|
 		(1ull << IB_USER_VERBS_CMD_QUERY_SRQ)		|
-		(1ull << IB_USER_VERBS_CMD_DESTROY_SRQ);
+		(1ull << IB_USER_VERBS_CMD_DESTROY_SRQ)         |
+		(1ull << IB_USER_VERBS_CMD_KWRITE_MMIO);
 
 	ibdev->ib_dev.query_device	= mlx4_ib_query_device;
 	ibdev->ib_dev.query_port	= mlx4_ib_query_port;
@@ -1447,6 +1500,8 @@ static void *mlx4_ib_add(struct mlx4_dev
 	ibdev->ib_dev.attach_mcast	= mlx4_ib_mcg_attach;
 	ibdev->ib_dev.detach_mcast	= mlx4_ib_mcg_detach;
 	ibdev->ib_dev.process_mad	= mlx4_ib_process_mad;
+	ibdev->ib_dev.kwrite_mmio32	= mlx4_ib_kwrite_mmio32;
+	ibdev->ib_dev.kwrite_mmio64	= mlx4_ib_kwrite_mmio64;
 
 	if (!mlx4_is_slave(ibdev->dev)) {
 		ibdev->ib_dev.alloc_fmr		= mlx4_ib_fmr_alloc;
--- a/drivers/infiniband/hw/mlx4/mlx4_ib.h
+++ b/drivers/infiniband/hw/mlx4/mlx4_ib.h
@@ -73,6 +73,7 @@ struct mlx4_ib_ucontext {
 	struct mlx4_uar		uar;
 	struct list_head	db_page_list;
 	struct mutex		db_page_mutex;
+	void __iomem		*uar_mmap;
 };
 
 struct mlx4_ib_pd {
@@ -745,4 +746,11 @@ void mlx4_ib_device_unregister_sysfs(str
 __be64 mlx4_ib_gen_node_guid(void);
 
 
+int mlx4_ib_kwrite_mmio32(struct ib_ucontext *ibcontext,
+				u64 offset,
+				u32 value);
+int mlx4_ib_kwrite_mmio64(struct ib_ucontext *ibcontext,
+				u64 offset,
+				u64 value);
+
 #endif /* MLX4_IB_H */
--- a/include/rdma/ib_user_verbs.h
+++ b/include/rdma/ib_user_verbs.h
@@ -90,6 +90,7 @@ enum {
 	IB_USER_VERBS_CMD_QUERY_XRC_RCV_QP,
 	IB_USER_VERBS_CMD_REG_XRC_RCV_QP,
 	IB_USER_VERBS_CMD_UNREG_XRC_RCV_QP,
+	IB_USER_VERBS_CMD_KWRITE_MMIO,
 };
 
 /*
@@ -797,5 +798,16 @@ struct ib_uverbs_unreg_xrc_rcv_qp {
 	__u64 driver_data[0];
 };
 
+union ib_uverbs_kwrite_mmio_data {
+	__u32 data32;
+	__u64 data64;
+};
+
+struct ib_uverbs_kwrite_mmio {
+	__u64  offset;
+	__u8   data_length;
+	union ib_uverbs_kwrite_mmio_data value;
+};
+
 
 #endif /* IB_USER_VERBS_H */
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@ -1234,6 +1234,12 @@ struct ib_device {
 	int 			   (*unreg_xrc_rcv_qp)(struct ib_xrcd *xrcd,
 						       void *context,
 						       u32 qp_num);
+	int			(*kwrite_mmio32)(struct ib_ucontext *ibcontext,
+						u64 offset,
+						u32 value);
+	int			(*kwrite_mmio64)(struct ib_ucontext *ibcontext,
+						u64 offset,
+						u64 value);
 
 	struct ib_dma_mapping_ops   *dma_ops;
 
