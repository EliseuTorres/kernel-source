From: Mike Travis <travis@sgi.com>
Date: Wed Oct 2 10:14:19 2013 -0500
Subject: x86/UV: Add call to KGDB/KDB from NMI handler
Git-commit: e379ea82dd53a5cc8e3ac0b7899a8012006c712c
Patch-mainline: 3.13-rc1
References: bnc#888847
Signed-off-by: Tony Jones <tonyj@suse.de>

[SUSE: Changed to conform to linux-3.0 kernel interface for NMI/KDB]

This patch restores the capability to enter KDB (and KGDB) from the UV NMI
handler.  This is needed because the UV system console is not capable of
sending the 'break' signal to the serial console port.  It is also useful
when the kernel is hung in such a way that it isn't responding to normal
external I/O, so sending 'g' to sysreq-trigger does not work either.

Another benefit of the external NMI command is that all the cpus receive
the NMI signal at roughly the same time so they are more closely aligned
timewise.

It utilizes the newly added kgdb_nmicallin function to gain entry
to KGDB/KDB by the master.  The slaves still enter via the standard
kgdb_nmicallback function.  It also uses the new 'send_ready' pointer
to tell KGDB/KDB to signal the slaves when to proceed into the KGDB
slave loop.

It is enabled when the nmi action is set to "kdb" and the kernel is
built with CONFIG_KDB enabled.

Signed-off-by: Mike Travis <travis@sgi.com>
Reviewed-by: Dimitri Sivanich <sivanich@sgi.com>
Reviewed-by: Hedi Berriche <hedi@sgi.com>
---
 arch/x86/platform/uv/uv_nmi.c |   53 ++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 51 insertions(+), 2 deletions(-)

--- linux-3.0.orig/arch/x86/platform/uv/uv_nmi.c
+++ linux-3.0/arch/x86/platform/uv/uv_nmi.c
@@ -21,6 +21,7 @@
 
 #include <linux/cpu.h>
 #include <linux/delay.h>
+#include <linux/kdb.h>
 #include <linux/lkdb.h>
 #include <linux/kdebug.h>
 #include <linux/kexec.h>
@@ -34,6 +35,7 @@
 #include <asm/kdebug.h>
 #include <asm/local64.h>
 #include <asm/nmi.h>
+#include <asm/traps.h>
 #include <asm/uv/uv.h>
 #include <asm/uv/uv_hub.h>
 #include <asm/uv/uv_mmrs.h>
@@ -148,8 +150,9 @@ module_param_named(retry_count, uv_nmi_r
  *  "dump"	- dump process stack for each cpu
  *  "ips"	- dump IP info for each cpu
  *  "kdump"	- do crash dump
+ *  "kdb"	- enter KDB/KGDB (default)
  */
-static char uv_nmi_action[8] = "dump";
+static char uv_nmi_action[8] = "kdb";
 module_param_string(action, uv_nmi_action, sizeof(uv_nmi_action), 0644);
 
 static inline bool uv_nmi_action_is(const char *action)
@@ -535,6 +538,47 @@ static inline void uv_nmi_kdump(int cpu,
 }
 #endif /* !CONFIG_KEXEC */
 
+#ifdef CONFIG_KDB
+static int uv_call_kdb(int cpu, struct pt_regs *regs, int reason, int master)
+{
+	if (master) {
+		/* Indicate master has made it this far */
+		atomic_set(&uv_nmi_slave_continue, SLAVE_CONTINUE);
+
+		/* Call KDB as master */
+		(void)kdb(LKDB_REASON_NMI, reason, regs);
+	} else {
+		int sig;
+
+		do {
+			cpu_relax();
+			sig = atomic_read(&uv_nmi_slave_continue);
+		} while (!sig);
+
+		/* pause a moment for the master to be established in KDB */
+		if (sig == SLAVE_CONTINUE) {
+			int i;
+
+			for (i = 0; i < 100; i++)
+				cpu_relax();
+
+			/* call KDB as slave */
+			(void)kdb(LKDB_REASON_ENTER_SLAVE, reason, regs);
+		}
+	}
+	uv_nmi_sync_exit(master);
+	return 0;
+}
+
+#else /* !CONFIG_KDB */
+static inline int uv_call_kdb(int cpu, struct pt_regs *regs,
+				int reason, int master)
+{
+	pr_err("UV: NMI error: KDB is not enabled in this kernel\n");
+	ret = -1;
+}
+#endif /* !CONFIG_KDB */
+
 /*
  * UV NMI handler
  */
@@ -544,6 +588,7 @@ int uv_handle_nmi(unsigned int reason, s
 	int cpu = smp_processor_id();
 	int master = 0;
 	unsigned long flags;
+	int ret;
 
 	local_irq_save(flags);
 
@@ -563,8 +608,12 @@ int uv_handle_nmi(unsigned int reason, s
 	/* Pause as all cpus enter the NMI handler */
 	uv_nmi_wait(master);
 
+	/* Call KDB if enabled */
+	if (uv_nmi_action_is("kdb"))
+		ret = uv_call_kdb(cpu, regs, reason, master);
+
 	/* Dump state of each cpu */
-	if (uv_nmi_action_is("ips") || uv_nmi_action_is("dump"))
+	if (ret || uv_nmi_action_is("ips") || uv_nmi_action_is("dump"))
 		uv_nmi_dump_state(cpu, regs, master);
 
 	/* Clear per_cpu "in nmi" flag */
