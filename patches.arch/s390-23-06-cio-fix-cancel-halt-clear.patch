From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: cio: prevent kernel panic in I/O cancel function
References: bnc#643173,LTC#67990
Patch-mainline: Yes

Symptom:     A kernel panic occurs with the following text: "Can't stop
             I/O on subchannel" when a ccw device is set offline or removed.
Problem:     Linux function ccw_device_cancel_halt_clear is used to cancel an
             outstanding I/O function when a ccw device is set offline or
             removed. Depending on the state of the subchannel, the function
             performs different I/O commands multiple times. If all attempts
             to cancel the I/O failed, a kernel panic is triggered. When
             a CLEAR SUBCHANNEL function is active a the subchannel while the
             function is called the first time, a kernel panic is immediately
             triggered because of a missing initialization of the retry
             counter.
Solution:    Add initialization of the retry counter. Also remove the kernel
             panic when I/O could not be cancelled since this is a non-fatal
             malfunction.

Acked-by: John Jolly <jjolly@suse.de>
---

 drivers/s390/cio/device.c     |    1 +
 drivers/s390/cio/device_fsm.c |    9 +++++++--
 2 files changed, 8 insertions(+), 2 deletions(-)

--- a/drivers/s390/cio/device.c
+++ b/drivers/s390/cio/device.c
@@ -1182,6 +1182,7 @@ static void io_subchannel_quiesce(struct
 		cdev->handler(cdev, cdev->private->intparm, ERR_PTR(-EIO));
 	while (ret == -EBUSY) {
 		cdev->private->state = DEV_STATE_QUIESCE;
+		cdev->private->iretry = 255;
 		ret = ccw_device_cancel_halt_clear(cdev);
 		if (ret == -EBUSY) {
 			ccw_device_set_timeout(cdev, HZ/10);
--- a/drivers/s390/cio/device_fsm.c
+++ b/drivers/s390/cio/device_fsm.c
@@ -174,7 +174,10 @@ ccw_device_cancel_halt_clear(struct ccw_
 		ret = cio_clear (sch);
 		return (ret == 0) ? -EBUSY : ret;
 	}
-	panic("Can't stop i/o on subchannel.\n");
+	/* Function was unsuccessful */
+	CIO_MSG_EVENT(0, "0.%x.%04x: could not stop I/O\n",
+		      cdev->private->dev_id.ssid, cdev->private->dev_id.devno);
+	return -EIO;
 }
 
 void ccw_device_update_sense_data(struct ccw_device *cdev)
@@ -711,13 +714,14 @@ ccw_device_online_timeout(struct ccw_dev
 	int ret;
 
 	ccw_device_set_timeout(cdev, 0);
+	cdev->private->iretry = 255;
 	ret = ccw_device_cancel_halt_clear(cdev);
 	if (ret == -EBUSY) {
 		ccw_device_set_timeout(cdev, 3*HZ);
 		cdev->private->state = DEV_STATE_TIMEOUT_KILL;
 		return;
 	}
-	if (ret == -ENODEV)
+	if (ret)
 		dev_fsm_event(cdev, DEV_EVENT_NOTOPER);
 	else if (cdev->handler)
 		cdev->handler(cdev, cdev->private->intparm,
@@ -814,6 +818,7 @@ void ccw_device_kill_io(struct ccw_devic
 {
 	int ret;
 
+	cdev->private->iretry = 255;
 	ret = ccw_device_cancel_halt_clear(cdev);
 	if (ret == -EBUSY) {
 		ccw_device_set_timeout(cdev, 3*HZ);
