From: Maarten Lankhorst <m.b.lankhorst@gmail.com>
Subject: x86, efi: Do not reserve boot services regions within reserved areas
Date: Tue Jun 14 19:53:09 2011 +0200
Patch-mainline: 3.0-rc3
References: bnc#568848, bnc#655434, bnc#681242

commit 7d68dc3f1003a38948c55c803c32d1989dd49198

    x86, efi: Do not reserve boot services regions within reserved areas
    
    Commit 916f676f8dc started reserving boot service code since some systems
    require you to keep that code around until SetVirtualAddressMap is called.
    
    However, in some cases those areas will overlap with reserved regions.
    The proper medium-term fix is to fix the bootloader to prevent the
    conflicts from occurring by moving the kernel to a better position,
    but the kernel should check for this possibility, and only reserve regions
    which can be reserved.
    
    Signed-off-by: Maarten Lankhorst <m.b.lankhorst@gmail.com>
    Link: http://lkml.kernel.org/r/4DF7A005.1050407@gmail.com
    Acked-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

--

Backport from 3.0 skipping all 'memblock' changes and continuing to use
'reserve_early()' (accompanied by 'check_early()').

Signed-off-by: Raymund Will <rw@suse.de>

---
 arch/x86/kernel/efi.c |   27 +++++++++++++++++++++++----
 1 file changed, 23 insertions(+), 4 deletions(-)

--- a/arch/x86/kernel/efi.c
+++ b/arch/x86/kernel/efi.c
@@ -310,14 +310,29 @@ void __init efi_reserve_boot_services(vo
 
 	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
 		efi_memory_desc_t *md = p;
-		unsigned long long start = md->phys_addr;
-		unsigned long long size = md->num_pages << EFI_PAGE_SHIFT;
+		u64 start = md->phys_addr;
+		u64 size = md->num_pages << EFI_PAGE_SHIFT;
 
 		if (md->type != EFI_BOOT_SERVICES_CODE &&
 		    md->type != EFI_BOOT_SERVICES_DATA)
 			continue;
-
-		reserve_early(start, start + size, "EFI Boot");
+		/* Only reserve where possible:
+		 * - Not within any already allocated areas
+		 * - Not over any memory area (really needed, if above?)
+		 * - Not within any part of the kernel
+		 * - Not the bios reserved area
+		*/
+		if ((start+size >= virt_to_phys(_text)
+				&& start <= virt_to_phys(_end)) ||
+			!e820_all_mapped(start, start+size, E820_RAM) ||
+			check_early(start, start+size)) {
+			/* Could not reserve, skip it */
+			md->num_pages = 0;
+			printk(KERN_INFO PFX "Could not reserve boot range "
+					"[0x%010llx-0x%010llx]\n",
+						start, start+size-1);
+		} else
+			reserve_early(start, start+size, "EFI Boot");
 	}
 }
 
@@ -334,6 +349,10 @@ static void __init efi_free_boot_service
 		    md->type != EFI_BOOT_SERVICES_DATA)
 			continue;
 
+		/* Could not reserve boot area */
+		if (!size)
+			continue;
+
 		free_bootmem_late(start, size);
 	}
 }
