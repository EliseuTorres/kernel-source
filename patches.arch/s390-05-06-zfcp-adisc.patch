Subject: zfcp: Improve ELS ADISC handling
References: BNC#565612
From: Gerald Schaefer <geraldsc@de.ibm.com>
Patch-mainline: 2.6.33-rc1
Git-commit: ee744622c65cd66824e8dd1b9509e515c800de14

Symptom: When issuing a ELS ADISC to test the connection to a
             remote port, this could lead to a qdio error and adapter
             recovery.
Problem: The ELS ADISC data does not satisfy the hardware
             alignment requirements, leading to the error and
             recovery.
Solution: Introduce a kmem_cache for the ELS ADISC request data and
             use zfcp_cache_hw_align to align the data like other
             requests sent to the hardware.
Acked-by: John Jolly <jjolly@suse.de>

---

 drivers/s390/scsi/zfcp_aux.c |    7 +++++++
 drivers/s390/scsi/zfcp_def.h |    9 +++++++++
 drivers/s390/scsi/zfcp_fc.c  |   19 ++++++++-----------
 3 files changed, 24 insertions(+), 11 deletions(-)

--- a/drivers/s390/scsi/zfcp_aux.c	2009-12-07 14:54:19.000000000 +0100
+++ b/drivers/s390/scsi/zfcp_aux.c	2009-12-07 14:55:51.000000000 +0100
@@ -189,6 +189,11 @@ static int __init zfcp_module_init(void)
 	mutex_init(&zfcp_data.config_mutex);
 	rwlock_init(&zfcp_data.config_lock);
 
+	zfcp_data.adisc_cache = zfcp_cache_hw_align("zfcp_adisc",
+					sizeof(struct zfcp_els_adisc));
+	if (!zfcp_data.adisc_cache)
+		goto out_adisc_cache;
+
 	zfcp_data.scsi_transport_template =
 		fc_attach_transport(&zfcp_transport_functions);
 	if (!zfcp_data.scsi_transport_template)
@@ -216,6 +221,8 @@ out_ccw_register:
 out_misc:
 	fc_release_transport(zfcp_data.scsi_transport_template);
 out_transport:
+	kmem_cache_destroy(zfcp_data.adisc_cache);
+out_adisc_cache:
 	kmem_cache_destroy(zfcp_data.gid_pn_cache);
 out_gid_cache:
 	kmem_cache_destroy(zfcp_data.sr_buffer_cache);
--- a/drivers/s390/scsi/zfcp_def.h	2009-12-07 14:53:25.000000000 +0100
+++ b/drivers/s390/scsi/zfcp_def.h	2009-12-09 10:49:53.000000000 +0100
@@ -365,6 +365,14 @@ struct zfcp_send_els {
 	int status;
 };
 
+struct zfcp_els_adisc {
+	struct zfcp_send_els els;
+	struct scatterlist req;
+	struct scatterlist resp;
+	struct zfcp_ls_adisc ls_adisc;
+	struct zfcp_ls_adisc ls_adisc_acc;
+};
+
 struct zfcp_wka_port {
 	struct zfcp_adapter	*adapter;
 	wait_queue_head_t	completion_wq;
@@ -609,6 +617,7 @@ struct zfcp_data {
 	struct kmem_cache	*qtcb_cache;
 	struct kmem_cache	*sr_buffer_cache;
 	struct kmem_cache	*gid_pn_cache;
+	struct kmem_cache	*adisc_cache;
 };
 
 /********************** ZFCP SPECIFIC DEFINES ********************************/
--- a/drivers/s390/scsi/zfcp_fc.c	2009-12-07 14:54:19.000000000 +0100
+++ b/drivers/s390/scsi/zfcp_fc.c	2009-12-09 10:49:53.000000000 +0100
@@ -392,14 +392,6 @@ void zfcp_fc_plogi_evaluate(struct zfcp_
 		port->supported_classes |= FC_COS_CLASS4;
 }
 
-struct zfcp_els_adisc {
-	struct zfcp_send_els els;
-	struct scatterlist req;
-	struct scatterlist resp;
-	struct zfcp_ls_adisc ls_adisc;
-	struct zfcp_ls_adisc ls_adisc_acc;
-};
-
 static void zfcp_fc_adisc_handler(unsigned long data)
 {
 	struct zfcp_els_adisc *adisc = (struct zfcp_els_adisc *) data;
@@ -428,15 +420,16 @@ static void zfcp_fc_adisc_handler(unsign
  out:
 	atomic_clear_mask(ZFCP_STATUS_PORT_LINK_TEST, &port->status);
 	zfcp_port_put(port);
-	kfree(adisc);
+	kmem_cache_free(zfcp_data.adisc_cache, adisc);
 }
 
 static int zfcp_fc_adisc(struct zfcp_port *port)
 {
 	struct zfcp_els_adisc *adisc;
 	struct zfcp_adapter *adapter = port->adapter;
+	int ret;
 
-	adisc = kzalloc(sizeof(struct zfcp_els_adisc), GFP_ATOMIC);
+	adisc = kmem_cache_alloc(zfcp_data.adisc_cache, GFP_ATOMIC);
 	if (!adisc)
 		return -ENOMEM;
 
@@ -460,7 +453,11 @@ static int zfcp_fc_adisc(struct zfcp_por
 	adisc->ls_adisc.wwnn = fc_host_node_name(adapter->scsi_host);
 	adisc->ls_adisc.nport_id = fc_host_port_id(adapter->scsi_host);
 
-	return zfcp_fsf_send_els(&adisc->els);
+	ret = zfcp_fsf_send_els(&adisc->els);
+	if (ret)
+		kmem_cache_free(zfcp_data.adisc_cache, adisc);
+
+	return ret;
 }
 
 void zfcp_fc_link_test_work(struct work_struct *work)
