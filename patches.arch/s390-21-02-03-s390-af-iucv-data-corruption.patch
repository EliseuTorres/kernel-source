From: Ursula Braun <ursula.braun@de.ibm.com>
Subject: af_iucv: wrong mapping of sent and confirmed skbs
Patch-mainline: v3.15-rc7
Git-commit: f5738e2ef88070ef1372e6e718124d88e9abe4ac
References: bnc#878407, LTC#110452

Description:  af_iucv: wrong mapping of sent and confirmed skbs
Symptom:      data corruption with af_iucv socket programs
Problem:      When sending data through IUCV a MESSAGE COMPLETE
              interrupt signals that sent data memory can be freed or
              reused again. With commit
              f9c41a62bba3f3f7ef3541b2a025e3371bcbba97 the MESSAGE
              COMPLETE callback iucv_callback_txdone() identifies the
              wrong skb as being confirmed, which leads to data
              corruption.
Solution:     fix skb mapping check in iucv_callback_txdone().
Reproduction: run 3 sendmsg calls for an AF_IUCV socket and check
              data contents on the receiver side.

Upstream-Description:

              af_iucv: wrong mapping of sent and confirmed skbs

              When sending data through IUCV a MESSAGE COMPLETE interrupt
              signals that sent data memory can be freed or reused again.
              With commit f9c41a62bba3f3f7ef3541b2a025e3371bcbba97
              "af_iucv: fix recvmsg by replacing skb_pull() function" the
              MESSAGE COMPLETE callback iucv_callback_txdone() identifies
              the wrong skb as being confirmed, which leads to data corruption.
              This patch fixes the skb mapping logic in iucv_callback_txdone().

              Signed-off-by: Ursula Braun <ursula.braun@de.ibm.com>
              Signed-off-by: Frank Blaschka <frank.blaschka@de.ibm.com>
              Cc: <stable@vger.kernel.org>
              Signed-off-by: David S. Miller <davem@davemloft.net>


Signed-off-by: Ursula Braun <ursula.braun@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 net/iucv/af_iucv.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@ -1859,7 +1859,7 @@ static void iucv_callback_txdone(struct
 		spin_lock_irqsave(&list->lock, flags);
 
 		while (list_skb != (struct sk_buff *)list) {
-			if (msg->tag != IUCV_SKB_CB(list_skb)->tag) {
+			if (msg->tag == IUCV_SKB_CB(list_skb)->tag) {
 				this = list_skb;
 				break;
 			}
