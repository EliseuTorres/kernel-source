From: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Subject: powerpc: Fix kdump hang issue on p8 with relocation on exception enabled.
Git-commit: 429d2e8342954d337abe370d957e78291032d867
Patch-mainline: 3.14-rc3
References: bnc#863534 

    On p8 systems, with relocation on exception feature enabled we are seeing
    kdump kernel hang at interrupt vector 0xc*4400. The reason is, with this
    feature enabled, exception are raised with MMU (IR=DR=1) ON with the
    default offset of 0xc*4000. Since exception is raised in virtual mode it
    requires the vector region to be executable without which it fails to
    fetch and execute instruction at 0xc*4xxx. For default kernel since kernel
    is loaded at real 0, the htab mappings sets the entire kernel text region
    executable. But for relocatable kernel (e.g. kdump case) we only copy
    interrupt vectors down to real 0 and never marked that region as
    executable because in p7 and below we always get exception in real mode.
    
    This patch fixes this issue by marking htab mapping range as executable
    that overlaps with the interrupt vector region for relocatable kernel.
    
    Thanks to Ben who helped me to debug this issue and find the root cause.
    
Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Acked-by: Torsten Duwe <duwe@suse.de>

 arch/powerpc/include/asm/sections.h | 12 ++++++++++++
 arch/powerpc/mm/hash_utils_64.c     | 14 ++++++++++++++
 2 files changed, 26 insertions(+)
diff --git a/arch/powerpc/include/asm/sections.h b/arch/powerpc/include/asm/sections.h
index 4ee06fe..d0e784e 100644
--- a/arch/powerpc/include/asm/sections.h
+++ b/arch/powerpc/include/asm/sections.h
@@ -8,6 +8,7 @@
 
 #ifdef __powerpc64__
 
+extern char __start_interrupts[];
 extern char __end_interrupts[];
 
 extern char __prom_init_toc_start[];
@@ -21,6 +22,17 @@ static inline int in_kernel_text(unsigned long addr)
 	return 0;
 }
 
+static inline int overlaps_interrupt_vector_text(unsigned long start,
+							unsigned long end)
+{
+	unsigned long real_start, real_end;
+	real_start = __start_interrupts - _stext;
+	real_end = __end_interrupts - _stext;
+
+	return start < (unsigned long)__va(real_end) &&
+		(unsigned long)__va(real_start) < end;
+}
+
 static inline int overlaps_kernel_text(unsigned long start, unsigned long end)
 {
 	return start < (unsigned long)__init_end &&
diff --git a/arch/powerpc/mm/hash_utils_64.c b/arch/powerpc/mm/hash_utils_64.c
index de68812..d766d6e 100644
--- a/arch/powerpc/mm/hash_utils_64.c
+++ b/arch/powerpc/mm/hash_utils_64.c
@@ -207,6 +207,20 @@ int htab_bolt_mapping(unsigned long vstart, unsigned long vend,
 		if (overlaps_kernel_text(vaddr, vaddr + step))
 			tprot &= ~HPTE_R_N;
 
+		/*
+		 * If relocatable, check if it overlaps interrupt vectors that
+		 * are copied down to real 0. For relocatable kernel
+		 * (e.g. kdump case) we copy interrupt vectors down to real
+		 * address 0. Mark that region as executable. This is
+		 * because on p8 system with relocation on exception feature
+		 * enabled, exceptions are raised with MMU (IR=DR=1) ON. Hence
+		 * in order to execute the interrupt handlers in virtual
+		 * mode the vector region need to be marked as executable.
+		 */
+		if ((PHYSICAL_START > MEMORY_START) &&
+			overlaps_interrupt_vector_text(vaddr, vaddr + step))
+				tprot &= ~HPTE_R_N;
+
 		hash = hpt_hash(vpn, shift, ssize);
 		hpteg = ((hash & htab_hash_mask) * HPTES_PER_GROUP);
 
