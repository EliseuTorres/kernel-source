From: Sebastian Ott <sebott@linux.vnet.ibm.com>
Subject: s390/pci: update function handle after resume from hibernate
Patch-mainline: v3.12-rc1
Git-commit: 57b5918c33a0797930c3791fb602a8a9d46ef80c
References: bnc#848335,FATE#83037,LTC#94737

Function handles may change while the system was in hibernation
use list pci functions and update the function handles.

Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/pci.h |    4 ++++
 arch/s390/kernel/suspend.c  |    2 ++
 arch/s390/pci/pci.c         |   15 ++++++++++-----
 arch/s390/pci/pci_clp.c     |   29 +++++++++++++++++++++++++++++
 4 files changed, 45 insertions(+), 5 deletions(-)

--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@ -6,6 +6,7 @@
 /* must be set before including pci_clp.h */
 #define PCI_BAR_COUNT	6
 
+#include <linux/pci.h>
 #include <asm-generic/pci.h>
 #include <asm-generic/pci-dma-compat.h>
 #include <asm/pci_clp.h>
@@ -147,6 +148,7 @@ int zpci_unregister_ioat(struct zpci_dev
 /* CLP */
 int clp_scan_pci_devices(void);
 int clp_rescan_pci_devices(void);
+int clp_rescan_pci_devices_simple(void);
 int clp_add_pci_device(u32, u32, int);
 int clp_enable_fh(struct zpci_dev *, u8);
 int clp_disable_fh(struct zpci_dev *);
@@ -163,9 +165,11 @@ void zpci_msihash_exit(void);
 /* Error handling and recovery */
 void zpci_event_error(void *);
 void zpci_event_availability(void *);
+void zpci_rescan(void);
 #else /* CONFIG_PCI */
 static inline void zpci_event_error(void *e) {}
 static inline void zpci_event_availability(void *e) {}
+static inline void zpci_rescan(void) {}
 #endif /* CONFIG_PCI */
 
 #ifdef CONFIG_HOTPLUG_PCI_S390
--- a/arch/s390/kernel/suspend.c
+++ b/arch/s390/kernel/suspend.c
@@ -11,6 +11,7 @@
 #include <asm/system.h>
 #include <asm/ipl.h>
 #include <asm/cio.h>
+#include <asm/pci.h>
 
 unsigned long suspend_zero_pages;
 
@@ -102,4 +103,5 @@ void s390_early_resume(void)
 {
 	lgr_info_log();
 	channel_subsystem_reinit();
+	zpci_rescan();
 }
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -44,7 +44,7 @@
 
 /* list of all detected zpci devices */
 static LIST_HEAD(zpci_list);
-static DEFINE_MUTEX(zpci_list_lock);
+static DEFINE_SPINLOCK(zpci_list_lock);
 
 static DECLARE_BITMAP(zpci_domain, ZPCI_NR_DEVICES);
 static DEFINE_SPINLOCK(zpci_domain_lock);
@@ -99,14 +99,14 @@ struct zpci_dev *get_zdev_by_fid(u32 fid
 {
 	struct zpci_dev *tmp, *zdev = NULL;
 
-	mutex_lock(&zpci_list_lock);
+	spin_lock(&zpci_list_lock);
 	list_for_each_entry(tmp, &zpci_list, entry) {
 		if (tmp->fid == fid) {
 			zdev = tmp;
 			break;
 		}
 	}
-	mutex_unlock(&zpci_list_lock);
+	spin_unlock(&zpci_list_lock);
 	return zdev;
 }
 
@@ -973,9 +973,9 @@ int __devinit zpci_create_device(struct
 	if (rc)
 		goto out_disable;
 
-	mutex_lock(&zpci_list_lock);
+	spin_lock(&zpci_list_lock);
 	list_add_tail(&zdev->entry, &zpci_list);
-	mutex_unlock(&zpci_list_lock);
+	spin_unlock(&zpci_list_lock);
 
 	zpci_init_slot(zdev);
 
@@ -1104,3 +1104,8 @@ out_mem:
 	return rc;
 }
 subsys_initcall_sync(pci_base_init);
+
+void zpci_rescan(void)
+{
+	clp_rescan_pci_devices_simple();
+}
--- a/arch/s390/pci/pci_clp.c
+++ b/arch/s390/pci/pci_clp.c
@@ -319,6 +319,20 @@ static void __devinit __clp_rescan(struc
 	}
 }
 
+static void __clp_update(struct clp_fh_list_entry *entry)
+{
+	struct zpci_dev *zdev;
+
+	if (!entry->vendor_id)
+		return;
+
+	zdev = get_zdev_by_fid(entry->fid);
+	if (!zdev)
+		return;
+
+	zdev->fh = entry->fh;
+}
+
 int __devinit clp_scan_pci_devices(void)
 {
 	struct clp_req_rsp_list_pci *rrb;
@@ -347,4 +361,19 @@ int __devinit clp_rescan_pci_devices(voi
 
 	clp_free_block(rrb);
 	return rc;
+}
+
+int clp_rescan_pci_devices_simple(void)
+{
+	struct clp_req_rsp_list_pci *rrb;
+	int rc;
+
+	rrb = clp_alloc_block(GFP_NOWAIT);
+	if (!rrb)
+		return -ENOMEM;
+
+	rc = clp_list_pci(rrb, __clp_update);
+
+	clp_free_block(rrb);
+	return rc;
 }
