From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: qeth: improve recovery during resource shortage
Patch-mainline: not yet
References: bnc#737328,LTC#77239

Symptom:     The qeth recovery is not able to fix up the device.
             After that, a recovery is not possible anymore.
Problem:     If there is a system resource shortage during recovery,
             the driver can not start a recovery thread but does not
             clear recovery masks to allow recovery again.
Solution:    In case there are no system resources to run a recovery
             we have to clear recovery bitmasks so a further automatic
             or manual driven recovery can fix up the device.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/net/qeth_core_main.c |   11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -1329,6 +1329,7 @@ static int qeth_do_start_thread(struct q
 
 static void qeth_start_kernel_thread(struct work_struct *work)
 {
+	struct task_struct *ts;
 	struct qeth_card *card = container_of(work, struct qeth_card,
 					kernel_thread_starter);
 	QETH_CARD_TEXT(card , 2, "strthrd");
@@ -1336,9 +1337,15 @@ static void qeth_start_kernel_thread(str
 	if (card->read.state != CH_STATE_UP &&
 	    card->write.state != CH_STATE_UP)
 		return;
-	if (qeth_do_start_thread(card, QETH_RECOVER_THREAD))
-		kthread_run(card->discipline.recover, (void *) card,
+	if (qeth_do_start_thread(card, QETH_RECOVER_THREAD)) {
+		ts = kthread_run(card->discipline.recover, (void *)card,
 				"qeth_recover");
+		if (IS_ERR(ts)) {
+			qeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);
+			qeth_clear_thread_running_bit(card,
+				QETH_RECOVER_THREAD);
+		}
+	}
 }
 
 static int qeth_setup_card(struct qeth_card *card)
