From: Heiko Carstens <heiko.carstens@de.ibm.com>
Subject: kernel: lost IPIs on CPU hotplug
Patch-mainline: v3.10-rc5
Git-commit: 9acf73b7d06eaa3fbfbfafc9c835f8fe0d751eff
References: bnc#825048, LTC#94784

Description:  kernel: lost IPIs on CPU hotplug
Symptom:      System hangs after a cpu was brought offline.
Problem:      Inter processore interrupts (IPIs) might get lost when a
              cpu is brought offline.
              When stop_machine executes its state machine there is a
              race window for the state STOPMACHINE_DISABLE_IRQ where
              the to be brought offline cpu might already have irqs
              disabled but a different cpu still may have irqs enabled.

              If the enabled cpu receives an interrupt and as a result
              sends an IPI to the to be offlined cpu in its bottom halve
              context, the IPI won't be noticed before the cpu is offline.

              Therefore the IPI gets lost and the requested function
              doesn't get called which may lead to a hanging system.
Solution:     Check for enqueued but not yet received IPIs in
              __cpu_disable() and call the respective handlers before a
              cpu is marked offline.
Reproduction: -

Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/kernel/smp.c |   19 +++++++++++++------
 1 file changed, 13 insertions(+), 6 deletions(-)

--- a/arch/s390/kernel/smp.c
+++ b/arch/s390/kernel/smp.c
@@ -188,15 +188,10 @@ void smp_send_stop(void)
  * cpus are handled.
  */
 
-static void do_ext_call_interrupt(unsigned int ext_int_code,
-				  unsigned int param32, unsigned long param64)
+static void smp_handle_ext_call(void)
 {
 	unsigned long bits;
 
-	if ((ext_int_code &0xffff) == 0x1202)
-		kstat_cpu(smp_processor_id()).irqs[EXTINT_EXC]++;
-	else
-		kstat_cpu(smp_processor_id()).irqs[EXTINT_EMS]++;
 	/*
 	 * handle bit signal external calls
 	 */
@@ -215,6 +210,16 @@ static void do_ext_call_interrupt(unsign
 		generic_smp_call_function_single_interrupt();
 }
 
+static void do_ext_call_interrupt(unsigned int ext_int_code,
+				  unsigned int param32, unsigned long param64)
+{
+	if ((ext_int_code &0xffff) == 0x1202)
+		kstat_cpu(smp_processor_id()).irqs[EXTINT_EXC]++;
+	else
+		kstat_cpu(smp_processor_id()).irqs[EXTINT_EMS]++;
+	smp_handle_ext_call();
+}
+
 /*
  * Send an external call sigp to another cpu and return without waiting
  * for its completion.
@@ -688,6 +693,8 @@ int __cpu_disable(void)
 	struct ec_creg_mask_parms cr_parms;
 	int cpu = smp_processor_id();
 
+	/* Handle possible pending IPIs */
+	smp_handle_ext_call();
 	set_cpu_online(cpu, false);
 
 	/* Disable pfault pseudo page faults on this cpu. */
