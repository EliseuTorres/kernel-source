From: Andi Kleen <andi@firstfloor.org>
Subject: HWPOISON: Add a madvise() injector for soft page offlining
References: fate#307738
Patch-Mainline: In Andi's mce subtree queued for 2.6.33 inclusion
Commit-ID: c39617846e95aeca7413813e44abdb018c250238

Signed-off-by: Thomas Renninger <trenn@suse.de>

Process based injection is much easier to handle for test programs,
who can first bring a page into a specific state and then test.
So add a new MADV_SOFT_OFFLINE to soft offline a page, similar
to the existing hard offline injector.

TBD we have a small race window because the low level code cannot
handle raised reference counts.

Signed-off-by: Andi Kleen <ak@linux.intel.com>

diff --git a/include/asm-generic/mman-common.h b/include/asm-generic/mman-common.h
index 5ee13b2..40b9731 100644
--- a/include/asm-generic/mman-common.h
+++ b/include/asm-generic/mman-common.h
@@ -35,6 +35,7 @@
 #define MADV_DONTFORK	10		/* don't inherit across fork */
 #define MADV_DOFORK	11		/* do inherit across fork */
 #define MADV_HWPOISON	100		/* poison a page for testing */
+#define MADV_SOFT_OFFLINE 101		/* soft offline page for testing */
 
 #define MADV_MERGEABLE   12		/* KSM may merge identical pages */
 #define MADV_UNMERGEABLE 13		/* KSM may not merge identical pages */
diff --git a/mm/madvise.c b/mm/madvise.c
index 18970ae..4997ae6 100644
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@ -222,7 +222,7 @@ static long madvise_remove(struct vm_area_struct *vma,
 /*
  * Error injection support for memory error handling.
  */
-static int madvise_hwpoison(unsigned long start, unsigned long end)
+static int madvise_hwpoison(int bhv, unsigned long start, unsigned long end)
 {
 	int ret = 0;
 
@@ -234,6 +234,17 @@ static int madvise_hwpoison(unsigned long start, unsigned long end)
 						0, 0, &p, NULL);
 		if (ret != 1)
 			return ret;
+		if (bhv == MADV_SOFT_OFFLINE) {
+			printk(KERN_INFO "Soft offlining page %lx at %lx\n",
+				page_to_pfn(p), start);
+			put_page(p);
+			// race window here but sop cannot deal with the
+			// inced page count. would need to fix page migration
+			ret = soft_offline_page(p);
+			if (ret)
+				break;
+			continue;
+		}
 		printk(KERN_INFO "Injecting memory failure for page %lx at %lx\n",
 		       page_to_pfn(p), start);
 		/* Ignore return value for now */
@@ -334,8 +345,8 @@ SYSCALL_DEFINE3(madvise, unsigned long, start, size_t, len_in, int, behavior)
 	size_t len;
 
 #ifdef CONFIG_MEMORY_FAILURE
-	if (behavior == MADV_HWPOISON)
-		return madvise_hwpoison(start, start+len_in);
+	if (behavior == MADV_HWPOISON || behavior == MADV_SOFT_OFFLINE)
+		return madvise_hwpoison(behavior, start, start+len_in);
 #endif
 	if (!madvise_behavior_valid(behavior))
 		return error;
