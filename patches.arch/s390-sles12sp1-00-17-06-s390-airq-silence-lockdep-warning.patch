From: David Hildenbrand <dahi@linux.vnet.ibm.com>
Subject: s390/airq: silence lockdep warning
Patch-mainline: v3.16-rc2
Git-commit: 0eb69a0c584d0eaec6c2b6663e03184625c3517b
References: bsc#935410,FATE#318050,LTC#VS1256

Summary:     s390/virtio: Performance enhanced paravirtualized I/O drivers
Description: This feature enhances performance of the paravirtualized I/O
             drivers on s390 with focus on virtio and virtio-ccw.

Upstream-Description:

             s390/airq: silence lockdep warning

             airq_iv_(alloc|free) is called by some users with interrupts enabled
             and by some with interrupts disabled which leads to the following
             lockdep warning:

             [ INFO: possible irq lock inversion dependency detected ]
             3.14.0-15249-gbf29b7b-dirty #25 Not tainted
             ---------------------------------------------------------
             insmod/2108 just changed the state of lock:
              (&(&iv->lock)->rlock){+.....}, at: [<000000000046ee3e>] airq_iv_alloc+0x62/0x228
             but this lock was taken by another, HARDIRQ-READ-safe lock in the past:
              (&info->lock){.-.-..}

             and interrupts could create inverse lock ordering between them.

             other info that might help us debug this:
              Possible interrupt unsafe locking scenario:

                    CPU0                    CPU1
                    ----                    ----
               lock(&(&iv->lock)->rlock);
                                            local_irq_disable();
                                            lock(&info->lock);
                                            lock(&(&iv->lock)->rlock);
               <Interrupt>
                 lock(&info->lock);

              *** DEADLOCK ***

             Although this is a false alarm (since each airq user consistently
             calls these functions from the same context) fix this by ensuring
             that interrupts are disabled when the airq lock is held.

             Reported-by: Frank Blaschka <frank.blaschka@de.ibm.com>
             Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
             Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/cio/airq.c |   14 ++++++--------
 1 file changed, 6 insertions(+), 8 deletions(-)

--- a/drivers/s390/cio/airq.c
+++ b/drivers/s390/cio/airq.c
@@ -197,11 +197,11 @@ EXPORT_SYMBOL(airq_iv_release);
 unsigned long airq_iv_alloc(struct airq_iv *iv, unsigned long num)
 {
 	const unsigned long be_to_le = BITS_PER_LONG - 1;
-	unsigned long bit, i;
+	unsigned long bit, i, flags;
 
 	if (!iv->avail || num == 0)
 		return -1UL;
-	spin_lock(&iv->lock);
+	spin_lock_irqsave(&iv->lock, flags);
 	bit = find_first_bit_left(iv->avail, iv->bits);
 	while (bit + num <= iv->bits) {
 		for (i = 1; i < num; i++)
@@ -219,9 +219,8 @@ unsigned long airq_iv_alloc(struct airq_
 	}
 	if (bit + num > iv->bits)
 		bit = -1UL;
-	spin_unlock(&iv->lock);
+	spin_unlock_irqrestore(&iv->lock, flags);
 	return bit;
-
 }
 EXPORT_SYMBOL(airq_iv_alloc);
 
@@ -234,12 +233,11 @@ EXPORT_SYMBOL(airq_iv_alloc);
 void airq_iv_free(struct airq_iv *iv, unsigned long bit, unsigned long num)
 {
 	const unsigned long be_to_le = BITS_PER_LONG - 1;
-
-	unsigned long i;
+	unsigned long i, flags;
 
 	if (!iv->avail || num == 0)
 		return;
-	spin_lock(&iv->lock);
+	spin_lock_irqsave(&iv->lock, flags);
 	for (i = 0; i < num; i++) {
 		/* Clear (possibly left over) interrupt bit */
 		clear_bit((bit + i) ^ be_to_le, iv->vector);
@@ -251,7 +249,7 @@ void airq_iv_free(struct airq_iv *iv, un
 		while (iv->end > 0 && !test_bit((iv->end - 1) ^ be_to_le, iv->avail))
 			iv->end--;
 	}
-	spin_unlock(&iv->lock);
+	spin_unlock_irqrestore(&iv->lock, flags);
 }
 EXPORT_SYMBOL(airq_iv_free);
 
