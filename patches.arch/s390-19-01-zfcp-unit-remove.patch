From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: zfcp: Remove SCSI device during unit_remove
References: bnc#617464,LTC#65402
Patch-mainline: Yes

Symptom:     When issuing the commands to delete a SCSI device and
             then to remove the zfcp unit from a script, the zfcp unit
             remove can fail.
Problem:     The unit_remove will fail when the reference count of the
             unit is not zero. When the SCSI device exists, it holds a
             reference to the unit. The upstream commit
             d9a9cdfb078d755e648d53ec25b7370f84ee5729 changed the
             deletion of a SCSI to be run asynchronously from a workqueue.
             With this change, the actual removal of the SCSI device
             can run after the unit_remove in zfcp and the
             unit_remove will fail.
Solution:    Get a reference to the SCSI device from the unit_remove
             function and remove the SCSI device from this function.
             If the SCSI device has already been deleted earlier,
             unit_remove cannot get the reference and does nothing.
             If the removal of the SCSI device is running on two threads,
             this is protected by the scan_mutex and the second one will
             exit early.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/scsi/zfcp_def.h   |    1 +
 drivers/s390/scsi/zfcp_scsi.c  |    1 +
 drivers/s390/scsi/zfcp_sysfs.c |   19 +++++++++++++++----
 3 files changed, 17 insertions(+), 4 deletions(-)

--- a/drivers/s390/scsi/zfcp_def.h	2010-06-24 10:45:00.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_def.h	2010-06-24 10:45:02.000000000 +0200
@@ -524,6 +524,7 @@ struct zfcp_port {
 	struct work_struct     test_link_work;
 	struct work_struct     rport_work;
 	enum { RPORT_NONE, RPORT_ADD, RPORT_DEL }  rport_task;
+	unsigned int		starget_id;
 };
 
 struct zfcp_unit {
--- a/drivers/s390/scsi/zfcp_scsi.c	2010-06-24 10:45:00.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_scsi.c	2010-06-24 10:45:02.000000000 +0200
@@ -561,6 +561,7 @@ static void zfcp_scsi_rport_register(str
 	rport->maxframe_size = port->maxframe_size;
 	rport->supported_classes = port->supported_classes;
 	port->rport = rport;
+	port->starget_id = rport->scsi_target_id;
 }
 
 static void zfcp_scsi_rport_block(struct zfcp_port *port)
--- a/drivers/s390/scsi/zfcp_sysfs.c	2010-06-24 10:45:00.000000000 +0200
+++ b/drivers/s390/scsi/zfcp_sysfs.c	2010-06-24 10:45:02.000000000 +0200
@@ -241,6 +241,7 @@ static ssize_t zfcp_sysfs_unit_remove_st
 	struct zfcp_unit *unit;
 	u64 fcp_lun;
 	LIST_HEAD(unit_remove_lh);
+	struct scsi_device *sdev;
 
 	mutex_lock(&zfcp_data.config_mutex);
 	if (atomic_read(&port->status) & ZFCP_STATUS_COMMON_REMOVE) {
@@ -256,17 +257,28 @@ static ssize_t zfcp_sysfs_unit_remove_st
 	read_lock_irq(&zfcp_data.config_lock);
 	unit = zfcp_get_unit_by_lun(port, fcp_lun);
 	read_unlock_irq(&zfcp_data.config_lock);
-	if (!unit || atomic_read(&unit->refcount)) {
+	if (!unit) {
 		mutex_unlock(&zfcp_data.config_mutex);
 		return -ENXIO;
 	}
 	zfcp_unit_get(unit);
 	mutex_unlock(&zfcp_data.config_mutex);
 
-	/* wait for possible timeout during SCSI probe */
-	flush_work(&unit->scsi_work);
+	sdev = scsi_device_lookup(port->adapter->scsi_host, 0,
+				  port->starget_id,
+				  scsilun_to_int((struct scsi_lun *)&fcp_lun));
+	if (sdev) {
+		scsi_remove_device(sdev);
+		scsi_device_put(sdev);
+	}
 
 	mutex_lock(&zfcp_data.config_mutex);
+	zfcp_unit_put(unit);
+	if (atomic_read(&unit->refcount)) {
+		mutex_unlock(&zfcp_data.config_mutex);
+		return -ENXIO;
+	}
+
 	write_lock_irq(&zfcp_data.config_lock);
 	atomic_set_mask(ZFCP_STATUS_COMMON_REMOVE, &unit->status);
 	list_move(&unit->list, &unit_remove_lh);
@@ -275,7 +287,6 @@ static ssize_t zfcp_sysfs_unit_remove_st
 
 	zfcp_erp_unit_shutdown(unit, 0, "syurs_1", NULL);
 	zfcp_erp_wait(unit->port->adapter);
-	zfcp_unit_put(unit);
 	zfcp_unit_dequeue(unit);
 
 	return (ssize_t)count;
