References: bnc#700514, FATE#311650
Subject: IBM powerpc feature
Patch-mainline: v2.6.37-rc1
From: bugproxy@us.ibm.com
Git-commit: 0c26b6775f36ce447722e8752bc3a006ec832df3

[PATCH 08/21] ibmveth: Add optional flush of rx buffer

On some machines we can improve the bandwidth by ensuring rx buffers are
not in the cache. Add a module option that is disabled by default that flushes
rx buffers on insertion.

Signed-off-by: Anton Blanchard <anton@samba.org>
Signed-off-by: Santiago Leon <santil@linux.vnet.ibm.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Mainline commit: 0c26b6775f36ce447722e8752bc3a006ec832df3

Acked-by: Torsten Duwe <duwe@suse.de>

---
 ibmveth.c |   21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

Index: linux-2.6.32-SLE11-SP2/drivers/net/ibmveth.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/drivers/net/ibmveth.c
+++ linux-2.6.32-SLE11-SP2/drivers/net/ibmveth.c
@@ -123,6 +123,10 @@ module_param(rx_copybreak, uint, 0644);
 MODULE_PARM_DESC(rx_copybreak,
 	"Maximum size of packet that is copied to a new buffer on receive");
 
+static unsigned int rx_flush __read_mostly = 0;
+module_param(rx_flush, uint, 0644);
+MODULE_PARM_DESC(rx_flush, "Flush receive buffers before use");
+
 struct ibmveth_stat {
 	char name[ETH_GSTRING_LEN];
 	int offset;
@@ -233,6 +237,14 @@ static int ibmveth_alloc_buffer_pool(str
 	return 0;
 }
 
+static inline void ibmveth_flush_buffer(void *addr, unsigned long length)
+{
+	unsigned long offset;
+
+	for (offset = 0; offset < length; offset += SMP_CACHE_BYTES)
+		asm("dcbfl %0,%1" :: "b" (addr), "r" (offset));
+}
+
 /* replenish the buffers for a pool.  note that we don't need to
  * skb_reserve these since they are used for incoming...
  */
@@ -285,6 +297,12 @@ static void ibmveth_replenish_buffer_poo
 		desc.fields.flags_len = IBMVETH_BUF_VALID | pool->buff_size;
 		desc.fields.address = dma_addr;
 
+		if (rx_flush) {
+			unsigned int len = min(pool->buff_size,
+						adapter->netdev->mtu +
+						IBMVETH_BUFF_OH);
+			ibmveth_flush_buffer(skb->data, len);
+		}
 		lpar_rc = h_add_logical_lan_buffer(adapter->vdev->unit_address, desc.desc);
 
 		if (lpar_rc != H_SUCCESS)
@@ -1059,6 +1077,9 @@ static int ibmveth_poll(struct napi_stru
 				skb_copy_to_linear_data(new_skb,
 							skb->data + offset,
 							length);
+				if (rx_flush)
+					ibmveth_flush_buffer(skb->data,
+						length + offset);
 				skb = new_skb;
 				ibmveth_rxq_recycle_buffer(adapter);
 			} else {


