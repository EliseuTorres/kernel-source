From: Alexey Ishchuk <alexey_ishchuk@ru.ibm.com>
Subject: s390/kernel: add system calls for PCI memory access
Patch-mainline: v3.19-rc1
Git-commit: 4eafad7febd482092b331ea72c37274d745956be
References: FATE#318094, LTC#117845

Summary:     kernel: Add system calls for PCI MMIO memory access.
Description: Add two new system calls to allow user space programs
             to execute the PCI MMIO memory access privileged CPU
	     instructions on demand.

Upstream-Description:

             s390/kernel: add system calls for PCI memory access

             Add the new __NR_s390_pci_mmio_write and __NR_s390_pci_mmio_read
             system calls to allow user space applications to access device PCI I/O
             memory pages on s390x platform.

             [ Martin Schwidefsky: some code beautification ]

             Signed-off-by: Alexey Ishchuk <aishchuk@linux.vnet.ibm.com>
             Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Alexey Ishchuk <alexey_ishchuk@ru.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/unistd.h    |   13 +++-
 arch/s390/kernel/compat_wrapper.S |   14 ++++
 arch/s390/kernel/entry.h          |    2 
 arch/s390/kernel/syscalls.S       |   11 +++
 arch/s390/pci/Makefile            |    2 
 arch/s390/pci/pci_mmio.c          |  117 ++++++++++++++++++++++++++++++++++++++
 kernel/sys_ni.c                   |    2 
 7 files changed, 159 insertions(+), 2 deletions(-)

--- a/arch/s390/include/asm/unistd.h
+++ b/arch/s390/include/asm/unistd.h
@@ -280,7 +280,18 @@
 #define __NR_process_vm_readv	340
 #define __NR_process_vm_writev	341
 #define __NR_s390_runtime_instr 342
-#define NR_syscalls 343
+/* Number 343 is reserved for sys_kcmp */
+/* Number 344 is reserved for sys_finit_module */
+/* Number 345 is reserved for sys_sched_setattr */
+/* Number 346 is reserved for sys_sched_getattr */
+/* Number 347 is reserved for sys_renameat2 */
+/* Number 348 is reserved for sys_seccomp */
+/* Number 349 is reserved for sys_getrandom */
+/* Number 350 is reserved for sys_memfd_create */
+/* Number 351 is reserved for sys_bpf */
+#define __NR_s390_pci_mmio_write	352
+#define __NR_s390_pci_mmio_read		353
+#define NR_syscalls 354
 
 /* 
  * There are some system calls that are not present on 64 bit, some
--- a/arch/s390/kernel/compat_wrapper.S
+++ b/arch/s390/kernel/compat_wrapper.S
@@ -1938,3 +1938,17 @@ compat_sys_process_vm_writev_wrapper:
 	llgf	%r0,164(%r15)		# unsigned long
 	stg	%r0,160(%r15)
 	jg	compat_sys_process_vm_writev
+
+	.globl sys_s390_pci_mmio_write_wrapper
+sys_s390_pci_mmio_write_wrapper:
+	llgfr	%r2,%r2			# unsigned long
+	llgtr	%r3,%r3			# void __user *
+	llgfr	%r4,%r4			# size_t
+	jg	sys_s390_pci_mmio_write
+
+	.globl sys_s390_pci_mmio_read_wrapper
+sys_s390_pci_mmio_read_wrapper:
+	llgfr	%r2,%r2			# unsigned long
+	llgtr	%r3,%r3			# void __user *
+	llgfr	%r4,%r4			# size_t
+	jg	sys_s390_pci_mmio_read
--- a/arch/s390/kernel/entry.h
+++ b/arch/s390/kernel/entry.h
@@ -53,4 +53,6 @@ long sys_rt_sigreturn(void);
 long sys32_sigreturn(void);
 long sys32_rt_sigreturn(void);
 
+long sys_s390_pci_mmio_write(unsigned long, const void __user *, size_t);
+long sys_s390_pci_mmio_read(unsigned long, void __user *, size_t);
 #endif /* _ENTRY_H */
--- a/arch/s390/kernel/syscalls.S
+++ b/arch/s390/kernel/syscalls.S
@@ -351,3 +351,14 @@ SYSCALL(sys_setns,sys_setns,sys_setns_wr
 SYSCALL(sys_process_vm_readv,sys_process_vm_readv,compat_sys_process_vm_readv_wrapper) /* 340 */
 SYSCALL(sys_process_vm_writev,sys_process_vm_writev,compat_sys_process_vm_writev_wrapper)
 SYSCALL(sys_ni_syscall,sys_s390_runtime_instr,sys_s390_runtime_instr_wrapper)
+NI_SYSCALL					/* 343 sys_kcmp */
+NI_SYSCALL					/* 344 sys_finit_module */
+NI_SYSCALL					/* 345 sys_sched_setattr */
+NI_SYSCALL					/* 346 sys_sched_getattr */
+NI_SYSCALL					/* 347 sys_renameat2 */
+NI_SYSCALL					/* 348 sys_seccomp */
+NI_SYSCALL					/* 349 sys_getrandom */
+NI_SYSCALL					/* 350 sys_memfd_create */
+NI_SYSCALL					/* 351 sys_bpf */
+SYSCALL(sys_ni_syscall,sys_s390_pci_mmio_write,sys_s390_pci_mmio_write_wrapper)
+SYSCALL(sys_ni_syscall,sys_s390_pci_mmio_read,sys_s390_pci_mmio_read_wrapper)
--- a/arch/s390/pci/Makefile
+++ b/arch/s390/pci/Makefile
@@ -3,4 +3,4 @@
 #
 
 obj-$(CONFIG_PCI)	+= pci.o pci_dma.o pci_clp.o pci_msi.o pci_sysfs.o \
-			   pci_event.o pci_debug.o pci_insn.o
+			   pci_event.o pci_debug.o pci_insn.o pci_mmio.o
--- /dev/null
+++ b/arch/s390/pci/pci_mmio.c
@@ -0,0 +1,117 @@
+/*
+ * Access to PCI I/O memory from user space programs.
+ *
+ * Copyright IBM Corp. 2014
+ * Author(s): Alexey Ishchuk <aishchuk@linux.vnet.ibm.com>
+ */
+#include <linux/kernel.h>
+#include <linux/syscalls.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+
+static long get_pfn(unsigned long user_addr, unsigned long access,
+		    unsigned long *pfn)
+{
+	struct vm_area_struct *vma;
+	long ret;
+
+	down_read(&current->mm->mmap_sem);
+	ret = -EINVAL;
+	vma = find_vma(current->mm, user_addr);
+	if (!vma)
+		goto out;
+	ret = -EACCES;
+	if (!(vma->vm_flags & access))
+		goto out;
+	ret = follow_pfn(vma, user_addr, pfn);
+out:
+	up_read(&current->mm->mmap_sem);
+	return ret;
+}
+
+SYSCALL_DEFINE3(s390_pci_mmio_write, unsigned long, mmio_addr,
+		const void __user *, user_buffer, size_t, length)
+{
+	u8 local_buf[64];
+	void __iomem *io_addr;
+	void *buf;
+	unsigned long pfn;
+	long ret;
+
+	if (!zpci_is_enabled())
+		return -ENODEV;
+
+	if (length <= 0 || PAGE_SIZE - (mmio_addr & ~PAGE_MASK) < length)
+		return -EINVAL;
+	if (length > 64) {
+		buf = kmalloc(length, GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+	} else {
+		buf = local_buf;
+	}
+
+	ret = get_pfn(mmio_addr, VM_WRITE, &pfn);
+	if (ret)
+		goto out;
+	io_addr = (void *)((pfn << PAGE_SHIFT) | (mmio_addr & ~PAGE_MASK));
+
+	ret = -EFAULT;
+	if ((unsigned long)io_addr < ZPCI_IOMAP_ADDR_BASE)
+		goto out;
+
+	if (copy_from_user(buf, user_buffer, length))
+		goto out;
+
+	memcpy_toio(io_addr, buf, length);
+	ret = 0;
+out:
+	if (buf != local_buf)
+		kfree(buf);
+	return ret;
+}
+
+SYSCALL_DEFINE3(s390_pci_mmio_read, unsigned long, mmio_addr,
+		void __user *, user_buffer, size_t, length)
+{
+	u8 local_buf[64];
+	void __iomem *io_addr;
+	void *buf;
+	unsigned long pfn;
+	long ret;
+
+	if (!zpci_is_enabled())
+		return -ENODEV;
+
+	if (length <= 0 || PAGE_SIZE - (mmio_addr & ~PAGE_MASK) < length)
+		return -EINVAL;
+	if (length > 64) {
+		buf = kmalloc(length, GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+	} else {
+		buf = local_buf;
+	}
+
+	ret = get_pfn(mmio_addr, VM_READ, &pfn);
+	if (ret)
+		goto out;
+	io_addr = (void *)((pfn << PAGE_SHIFT) | (mmio_addr & ~PAGE_MASK));
+
+	ret = -EFAULT;
+	if ((unsigned long)io_addr < ZPCI_IOMAP_ADDR_BASE)
+		goto out;
+
+	memcpy_fromio(buf, io_addr, length);
+
+	if (copy_to_user(user_buffer, buf, length))
+		goto out;
+
+	ret = 0;
+out:
+	if (buf != local_buf)
+		kfree(buf);
+	return ret;
+}
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -160,6 +160,8 @@ cond_syscall(ppc_rtas);
 cond_syscall(sys_spu_run);
 cond_syscall(sys_spu_create);
 cond_syscall(sys_subpage_prot);
+cond_syscall(sys_s390_pci_mmio_read);
+cond_syscall(sys_s390_pci_mmio_write);
 
 /* mmu depending weak syscall entries */
 cond_syscall(sys_mprotect);
