From: Robin Holt <holt@sgi.com>
Subject: x86_64 / NUMA: Cacheline aliasing makes for_each_populated_zone extremely expensive -V2.
References: bnc#632975, FATE#306952
Patch-Mainline: No

While testing on a 256 node, 4096 cpus system, Jack Steiner noticed
that we would use between 0.08% average and 0.8% max of every second
in vmstat_update.  This could be tuned using sysctl's stat_interval,
but that was simply reducing the impact of the problem.

When I investigated, I noticed that all the zone_data[] structures are
allocated precisely at the beginning of the individual node's physical
memory.  By simply staggering based upon nodeid, I reduced the average
down to 0.0006% of every second.

With this patch, the max value did not change.  I believe that is a
combination of cacheline contention updating the zone's vmstat information
combined with round_jiffies_common spattering unrelated cpus onto the same
jiffie for their next update.  I will investigate those issues seperately.

Signed-off-by: Robin Holt <holt@sgi.com>
Signed-off-by: Jack Steiner <steiner@sgi.com>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>

 arch/x86/mm/numa_64.c |   12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

Index: linux-2.6.32-SLE11-SP1/arch/x86/mm/numa_64.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/mm/numa_64.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/mm/numa_64.c
@@ -187,6 +187,7 @@ setup_node_bootmem(int nodeid, unsigned 
 	unsigned long bootmap_start, nodedata_phys;
 	void *bootmap;
 	int nid;
+	unsigned long cache_alias_offset;
 
 	if (!end)
 		return;
@@ -206,9 +207,16 @@ setup_node_bootmem(int nodeid, unsigned 
 	start_pfn = start >> PAGE_SHIFT;
 	last_pfn = end >> PAGE_SHIFT;
 
-	node_data[nodeid] = early_node_mem(nodeid, start, end, pgdat_size,
+	/*
+	 * Allocate an extra cacheline per node to reduce cacheline
+	 * aliasing when scanning all node's node_data.
+	 */
+	cache_alias_offset = nodeid * SMP_CACHE_BYTES;
+	node_data[nodeid] = cache_alias_offset +
+			    early_node_mem(nodeid, start, end,
+					   pgdat_size + cache_alias_offset,
 					   SMP_CACHE_BYTES);
-	if (node_data[nodeid] == NULL)
+	if (node_data[nodeid] == (void *)cache_alias_offset)
 		return;
 	nodedata_phys = __pa(node_data[nodeid]);
 	printk(KERN_INFO "  NODE_DATA [%016lx - %016lx]\n", nodedata_phys,
