From: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
Subject: cpuidle/powerpc: Fix smt_snooze_delay functionality.
Git-commit: 8ea959a17fe6e27f7954dddad5b17b0e33f0d7ee
Patch-mainline: yes
References: fate#314019,bnc#795230

    smt_snooze_delay was designed to  delay idle loop's nap entry
    in the native idle code before it got  ported over to use as part of
    the cpuidle framework.

    A -ve value  assigned to smt_snooze_delay should result in
    busy looping, in other words disabling the entry to nap state.

    	- https://lists.ozlabs.org/pipermail/linuxppc-dev/2010-May/082450.html

    This particular functionality can be achieved currently by
    echo 1 > /sys/devices/system/cpu/cpu*/state1/disable
    but it is broken when one assigns -ve value to  the smt_snooze_delay
    variable either via sysfs entry or ppc64_cpu util.

    This patch aims to fix this, by disabling nap state when smt_snooze_delay
    variable is set to -ve value.

Signed-off-by: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Acked-by: Torsten Duwe <duwe@suse.de>
---

 arch/powerpc/include/asm/system.h               |    4 ++--
 arch/powerpc/kernel/sysfs.c                     |    2 +-
 arch/powerpc/platforms/pseries/processor_idle.c |   24 ++++++++++++++++-------
 3 files changed, 20 insertions(+), 10 deletions(-)


diff --git a/arch/powerpc/include/asm/system.h b/arch/powerpc/include/asm/system.h
index 6757b53..515e5e2 100644
--- a/arch/powerpc/include/asm/system.h
+++ b/arch/powerpc/include/asm/system.h
@@ -225,9 +225,9 @@ extern int powersave_nap;	/* set if nap mode can be used in idle loop */
 void cpu_idle_wait(void);
 
 #ifdef CONFIG_PSERIES_IDLE
-extern void update_smt_snooze_delay(int snooze);
+extern void update_smt_snooze_delay(int cpu, int residency);
 #else
-static inline void update_smt_snooze_delay(int snooze) {}
+extern void update_smt_snooze_delay(int cpu, int residency) {}
 #endif
 
 /*
diff --git a/arch/powerpc/kernel/sysfs.c b/arch/powerpc/kernel/sysfs.c
index fbb666f..dbbbeda 100644
--- a/arch/powerpc/kernel/sysfs.c
+++ b/arch/powerpc/kernel/sysfs.c
@@ -52,7 +52,7 @@ static ssize_t store_smt_snooze_delay(struct sys_device *dev,
 		return -EINVAL;
 
 	per_cpu(smt_snooze_delay, cpu->sysdev.id) = snooze;
-	update_smt_snooze_delay(snooze);
+	update_smt_snooze_delay(cpu->sysdev.id, snooze);
 
 	return count;
 }
diff --git a/arch/powerpc/platforms/pseries/processor_idle.c b/arch/powerpc/platforms/pseries/processor_idle.c
index b581daf..c42dfb9 100644
--- a/arch/powerpc/platforms/pseries/processor_idle.c
+++ b/arch/powerpc/platforms/pseries/processor_idle.c
@@ -33,13 +33,6 @@ static int max_idle_state = MAX_IDLE_STATE_COUNT - 1;
 static struct cpuidle_device __percpu *pseries_cpuidle_devices;
 static struct cpuidle_state *cpuidle_state_table;
 
-void update_smt_snooze_delay(int snooze)
-{
-	struct cpuidle_driver *drv = cpuidle_get_driver();
-	if (drv)
-		drv->states[0].target_residency = snooze;
-}
-
 static inline void idle_loop_prolog(unsigned long *in_purr, ktime_t *kt_before)
 {
 
@@ -173,6 +166,23 @@ static struct cpuidle_state shared_states[MAX_IDLE_STATE_COUNT] = {
 		.enter = &shared_cede_loop },
 };
 
+void update_smt_snooze_delay(int cpu, int residency)
+{
+	struct cpuidle_driver *drv = cpuidle_get_driver();
+	struct cpuidle_device *dev = per_cpu(cpuidle_devices, cpu);
+
+	if (cpuidle_state_table != dedicated_states)
+		return;
+
+	if (residency < 0) {
+		/* Disable the Nap state on that cpu */
+		if (dev)
+			dev->states_usage[1].disable = 1;
+	} else
+		if (drv)
+			drv->states[0].target_residency = residency;
+}
+
 static int pseries_cpuidle_add_cpu_notifier(struct notifier_block *n,
 			unsigned long action, void *hcpu)
 {
