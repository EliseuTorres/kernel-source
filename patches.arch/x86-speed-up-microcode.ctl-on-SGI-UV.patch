From: Dimitri Sivanich <sivanich@sgi.com>
Subject: x86: Speed up microcode.ctl on SGI UV
References: bnc#586364, FATE#306952
Patch-mainline: not yet

We've noticed that on large SGI UV system configurations, running
microcode.ctl can take very long periods of time.  This is due to
the large number of vmalloc/vfree calls made by the Intel
generic_load_microcode() logic.

By reusing allocated space, the following patch reduces the time
to run microcode.ctl on a 1024 cpu system from approximately 80
seconds down to 1 or 2 seconds.

Signed-off-by: Dimitri Sivanich <sivanich@sgi.com>
Acked-by: Dmitry Adamushko <dmitry.adamushko@gmail.com>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---

 arch/x86/kernel/microcode_intel.c |   22 ++++++++++++++++------
 1 file changed, 16 insertions(+), 6 deletions(-)

Index: linux-2.6.32-SLE11-SP1/arch/x86/kernel/microcode_intel.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/kernel/microcode_intel.c
+++ linux-2.6.32-SLE11-SP1/arch/x86/kernel/microcode_intel.c
@@ -348,10 +348,11 @@ static enum ucode_state generic_load_mic
 				int (*get_ucode_data)(void *, const void *, size_t))
 {
 	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
-	u8 *ucode_ptr = data, *new_mc = NULL, *mc;
+	u8 *ucode_ptr = data, *new_mc = NULL, *mc = NULL;
 	int new_rev = uci->cpu_sig.rev;
 	unsigned int leftover = size;
 	enum ucode_state state = UCODE_OK;
+	unsigned int curr_mc_size = 0;
 
 	while (leftover) {
 		struct microcode_header_intel mc_header;
@@ -367,9 +368,15 @@ static enum ucode_state generic_load_mic
 			break;
 		}
 
-		mc = vmalloc(mc_size);
-		if (!mc)
-			break;
+		/* For performance reasons, reuse mc area when possible */
+		if (!mc || mc_size > curr_mc_size) {
+			if (mc)
+				vfree(mc);
+			mc = vmalloc(mc_size);
+			if (!mc)
+				break;
+			curr_mc_size = mc_size;
+		}
 
 		if (get_ucode_data(mc, ucode_ptr, mc_size) ||
 		    microcode_sanity_check(mc) < 0) {
@@ -382,13 +389,16 @@ static enum ucode_state generic_load_mic
 				vfree(new_mc);
 			new_rev = mc_header.rev;
 			new_mc  = mc;
-		} else
-			vfree(mc);
+			mc = NULL;	/* trigger new vmalloc */
+		}
 
 		ucode_ptr += mc_size;
 		leftover  -= mc_size;
 	}
 
+	if (mc)
+		vfree(mc);
+
 	if (leftover) {
 		if (new_mc)
 			vfree(new_mc);
