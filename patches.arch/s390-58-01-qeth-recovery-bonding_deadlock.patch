Subject: qeth: fix deadlock between recovery and bonding driver
From: Stefan Raspl <raspl@linux.vnet.ibm.com>
Patch-mainline: Submitted
References: bnc#785100,LTC#85905

Symptom:      OSA interface hangs e.g. when used with the bonding driver
Problem:      The recovery thread, when failing, tears down the respective
              interface. To do so, it needs to obtain the rtnl lock first,
              as the interface configuration is changed.
              If another process tries to modify an interface setting at the
              same time, that process can obtain the rtnl lock first, but
              the respective callback in the qeth driver will block until
              recovery has completed - which cannot happen since the calling
              process already obtained it.
              In the case reported by the customer, the bonding driver
              acquired the rtnl lock to modify the card's MAC address, while
              the recovery failed at the same time due to removal of the
              card. Hence qeth_l2_set_mac_address (implicitly holding the
              rtnl lock) was waiting on qeth_l2_recover, which deadlocked
              when
              waiting on the rtnl lock.
Solution:     In the recovery thread, use rtnl_trylock() instead of
              rtnl_lock(). If the lock cannot be obtained, the interface
              will be left up, but the card state remains in
              CARD_STATE_RECOVER, which will prevent any further activities
              on the card.
Reproduction: Vary CHPID of one OSA card in a bonding setup offline while
              recovery is runnin. Note that you will need a lot of luck to
              hit the race condition.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/net/qeth_l2_main.c |   11 ++++++-----
 drivers/s390/net/qeth_l3_main.c |   11 ++++++-----
 2 files changed, 12 insertions(+), 10 deletions(-)

--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -1144,11 +1144,12 @@ static int qeth_l2_recover(void *ptr)
 		dev_info(&card->gdev->dev,
 			"Device successfully recovered!\n");
 	else {
-		rtnl_lock();
-		dev_close(card->dev);
-		rtnl_unlock();
-		dev_warn(&card->gdev->dev, "The qeth device driver "
-			"failed to recover an error on the device\n");
+		if (rtnl_trylock()) {
+			dev_close(card->dev);
+			rtnl_unlock();
+			dev_warn(&card->gdev->dev, "The qeth device driver "
+				"failed to recover an error on the device\n");
+		}
 	}
 	qeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);
 	qeth_clear_thread_running_bit(card, QETH_RECOVER_THREAD);
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -3581,11 +3581,12 @@ static int qeth_l3_recover(void *ptr)
 		dev_info(&card->gdev->dev,
 			"Device successfully recovered!\n");
 	else {
-		rtnl_lock();
-		dev_close(card->dev);
-		rtnl_unlock();
-		dev_warn(&card->gdev->dev, "The qeth device driver "
-			"failed to recover an error on the device\n");
+		if (rtnl_trylock()) {
+			dev_close(card->dev);
+			rtnl_unlock();
+			dev_warn(&card->gdev->dev, "The qeth device driver "
+				"failed to recover an error on the device\n");
+		}
 	}
 	qeth_clear_thread_start_bit(card, QETH_RECOVER_THREAD);
 	qeth_clear_thread_running_bit(card, QETH_RECOVER_THREAD);
