From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: cio: prevent purging of CCW devices in the online state
References: bnc#684472,LTC#71139
Patch-mainline: Yes

Symptom:     After the performance of the cio_ignore purge function
             (cio_ignore --purge or echo purge > /proc/cio_ignore), a device
             which is in the online state and on the cio_ignore blacklist is
             removed and no longer accessible.
Problem:     The cio_ignore purge function should only remove devices which
             are in the offline state and on the cio_ignore blacklist. If a
             purge function is performed, devices which are offline and on the
             blacklist are scheduled for removal. Due to missing checks in the
             set online function, such a device can still be set online.
             This can result in a situation where a device is set online and
             immediately afterwards removed.
Solution:    When users request that a device be set online which there is
             delayed work pending for this device, reject the request. Also
             ensure that no devices which are in the process of being set online
             are marked for removal during a purge operation.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/cio/device.c |   24 ++++++++++++++++++------
 1 file changed, 18 insertions(+), 6 deletions(-)

--- a/drivers/s390/cio/device.c
+++ b/drivers/s390/cio/device.c
@@ -546,15 +546,24 @@ static ssize_t online_store (struct devi
 	int force, ret;
 	unsigned long i;
 
-	if (!dev_fsm_final_state(cdev) &&
-	    cdev->private->state != DEV_STATE_DISCONNECTED)
-		return -EAGAIN;
+	/* Prevent conflict between multiple on-/offline processing requests. */
 	if (atomic_cmpxchg(&cdev->private->onoff, 0, 1) != 0)
 		return -EAGAIN;
+	/* Prevent conflict between internal I/Os and on-/offline processing. */
+	if (!dev_fsm_final_state(cdev) &&
+	    cdev->private->state != DEV_STATE_DISCONNECTED) {
+		ret = -EAGAIN;
+		goto out_onoff;
+	}
+	/* Prevent conflict between pending work and on-/offline processing.*/
+	if (work_pending(&cdev->private->todo_work)) {
+		ret = -EAGAIN;
+		goto out_onoff;
+	}
 
 	if (cdev->drv && !try_module_get(cdev->drv->owner)) {
-		atomic_set(&cdev->private->onoff, 0);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto out_onoff;
 	}
 	if (!strncmp(buf, "force\n", count)) {
 		force = 1;
@@ -579,6 +588,7 @@ static ssize_t online_store (struct devi
 out:
 	if (cdev->drv)
 		module_put(cdev->drv->owner);
+out_onoff:
 	atomic_set(&cdev->private->onoff, 0);
 	return (ret < 0) ? ret : count;
 }
@@ -1282,10 +1292,12 @@ static int purge_fn(struct device *dev,
 
 	spin_lock_irq(cdev->ccwlock);
 	if (is_blacklisted(id->ssid, id->devno) &&
-	    (cdev->private->state == DEV_STATE_OFFLINE)) {
+	    (cdev->private->state == DEV_STATE_OFFLINE) &&
+	    (atomic_cmpxchg(&cdev->private->onoff, 0, 1) == 0)) {
 		CIO_MSG_EVENT(3, "ccw: purging 0.%x.%04x\n", id->ssid,
 			      id->devno);
 		ccw_device_sched_todo(cdev, CDEV_TODO_UNREG);
+		atomic_set(&cdev->private->onoff, 0);
 	}
 	spin_unlock_irq(cdev->ccwlock);
 	/* Abort loop in case of pending signal. */
