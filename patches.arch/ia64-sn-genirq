From: Dimitri Sivanich <sivanich@sgi.com>
Date: 2011-11-02 18:58:28 UTC
Subject: [IA64] genirq fixup for SGI/SN
Patch-mainline: not yet
References: bnc#718160

This patch allows the system to boot and enables the console and at least some
hardware drivers, as well as some platform error handling.  Tested on 4 cpu
A450 with tigon3 ethernet and IOC disk.

This patch is most likely not complete and may not be updating it's areas of
coverage in the best way.  Extensive testing of SGI/SN IA64 (by Novell) will
need to be done prior to the SP2 release.

Acked-by: Raymund Will <rw@suse.de>

---
 arch/ia64/sn/kernel/huberror.c          |    2 ++
 arch/ia64/sn/kernel/irq.c               |    2 ++
 arch/ia64/sn/pci/pcibr/pcibr_provider.c |    1 +
 arch/ia64/sn/pci/tioca_provider.c       |    1 +
 arch/ia64/sn/pci/tioce_provider.c       |    1 +
 drivers/tty/serial/sn_console.c         |    1 +
 6 files changed, 8 insertions(+)

--- a/drivers/tty/serial/sn_console.c
+++ b/drivers/tty/serial/sn_console.c
@@ -742,6 +742,7 @@ static void __init sn_sal_switch_to_inte
 			spin_lock_irqsave(&port->sc_port.lock, flags);
 			port->sc_port.irq = SGI_UART_VECTOR;
 			port->sc_ops = &intr_ops;
+			irq_set_handler(port->sc_port.irq, handle_level_irq);
 
 			/* turn on receive interrupts */
 			ia64_sn_console_intr_enable(SAL_CONSOLE_INTR_RECV);
--- a/arch/ia64/sn/kernel/irq.c
+++ b/arch/ia64/sn/kernel/irq.c
@@ -363,6 +363,8 @@ void sn_irq_fixup(struct pci_dev *pci_de
 	spin_lock(&sn_irq_info_lock);
 	list_add_rcu(&sn_irq_info->list, sn_irq_lh[sn_irq_info->irq_irq]);
 	reserve_irq_vector(sn_irq_info->irq_irq);
+	if (sn_irq_info->irq_int_bit != -1)
+		irq_set_handler(sn_irq_info->irq_irq, handle_level_irq);
 	spin_unlock(&sn_irq_info_lock);
 
 	register_intr_pda(sn_irq_info);
--- a/arch/ia64/sn/kernel/huberror.c
+++ b/arch/ia64/sn/kernel/huberror.c
@@ -192,6 +192,7 @@ void hub_error_init(struct hubdev_info *
 		    hubdev_info);
 		return;
 	}
+	irq_set_handler(SGI_II_ERROR, handle_level_irq);
 	sn_set_err_irq_affinity(SGI_II_ERROR);
 }
 
@@ -213,6 +214,7 @@ void ice_error_init(struct hubdev_info *
                        hubdev_info);
 		return;
 	}
+	irq_set_handler(SGI_TIO_ERROR, handle_level_irq);
 	sn_set_err_irq_affinity(SGI_TIO_ERROR);
 }
 
--- a/arch/ia64/sn/pci/pcibr/pcibr_provider.c
+++ b/arch/ia64/sn/pci/pcibr/pcibr_provider.c
@@ -146,6 +146,7 @@ pcibr_bus_fixup(struct pcibus_bussoft *p
 		printk(KERN_WARNING
 		       "pcibr cannot allocate interrupt for error handler\n");
 	}
+	irq_set_handler(SGI_PCIASIC_ERROR, handle_level_irq);
 	sn_set_err_irq_affinity(SGI_PCIASIC_ERROR);
 
 	/* 
--- a/arch/ia64/sn/pci/tioca_provider.c
+++ b/arch/ia64/sn/pci/tioca_provider.c
@@ -648,6 +648,7 @@ tioca_bus_fixup(struct pcibus_bussoft *p
 		       __func__, SGI_TIOCA_ERROR,
 		       (int)tioca_common->ca_common.bs_persist_busnum);
 
+	irq_set_handler(SGI_TIOCA_ERROR, handle_level_irq);
 	sn_set_err_irq_affinity(SGI_TIOCA_ERROR);
 
 	/* Setup locality information */
--- a/arch/ia64/sn/pci/tioce_provider.c
+++ b/arch/ia64/sn/pci/tioce_provider.c
@@ -1037,6 +1037,7 @@ tioce_bus_fixup(struct pcibus_bussoft *p
 		       tioce_common->ce_pcibus.bs_persist_segment,
 		       tioce_common->ce_pcibus.bs_persist_busnum);
 
+	irq_set_handler(SGI_PCIASIC_ERROR, handle_level_irq);
 	sn_set_err_irq_affinity(SGI_PCIASIC_ERROR);
 	return tioce_common;
 }
