From: Gerald Schaefer <geraldsc@de.ibm.com>
Subject: ccwgroup: udev race condition
References: bnc#659101,LTC#68723
Patch-mainline: Yes

Symptom:     network device is not made available automatically
Problem:     race condition between udev rules and kernel while accessing
             a sysfs attribute
Solution:    Suppress uevents until after the creating driver had a chance
             to bind to the ccwgroup device (ccwgroup_create_from_string()
             is called by the driver that will bind to it).

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/cio/ccwgroup.c |   26 +++++++++++++++-----------
 1 file changed, 15 insertions(+), 11 deletions(-)

--- a/drivers/s390/cio/ccwgroup.c
+++ b/drivers/s390/cio/ccwgroup.c
@@ -285,25 +285,29 @@ int ccwgroup_create_from_string(struct d
 	}
 
 	dev_set_name(&gdev->dev, "%s", dev_name(&gdev->cdev[0]->dev));
-
+	dev_set_uevent_suppress(&gdev->dev, 1);
 	rc = device_add(&gdev->dev);
 	if (rc)
 		goto error;
+
 	get_device(&gdev->dev);
 	rc = device_create_file(&gdev->dev, &dev_attr_ungroup);
-
-	if (rc) {
-		device_unregister(&gdev->dev);
-		goto error;
-	}
+	if (rc)
+		goto error_unreg;
 
 	rc = __ccwgroup_create_symlinks(gdev);
-	if (!rc) {
-		mutex_unlock(&gdev->reg_mutex);
-		put_device(&gdev->dev);
-		return 0;
-	}
+	if (rc)
+		goto error_attr;
+
+	dev_set_uevent_suppress(&gdev->dev, 0);
+	kobject_uevent(&gdev->dev.kobj, KOBJ_ADD);
+	mutex_unlock(&gdev->reg_mutex);
+	put_device(&gdev->dev);
+	return 0;
+
+error_attr:
 	device_remove_file(&gdev->dev, &dev_attr_ungroup);
+error_unreg:
 	device_unregister(&gdev->dev);
 error:
 	for (i = 0; i < num_devices; i++)
