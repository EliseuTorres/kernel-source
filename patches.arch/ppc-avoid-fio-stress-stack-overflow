From: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Subject: powerpc/irq: Run softirqs off the top of the irq stack
Git-commit: 0366a1c70b89efed4f9d590216bb004a16effbed
Patch-mainline: yes
References: bnc#847319 

    Nowadays, irq_exit() calls __do_softirq() pretty much directly
    instead of calling do_softirq() which switches to the decicated
    softirq stack.
    
    This has lead to observed stack overflows on powerpc since we call
    irq_enter() and irq_exit() outside of the scope that switches to
    the irq stack.
    
    This fixes it by moving the stack switching up a level, making
    irq_enter() and irq_exit() run off the irq stack.
    
Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Acked-by: Torsten Duwe <duwe@suse.de>

diff -upr linux-3.0.93-0.8/arch/powerpc/include/asm/irq.h linux-3.0.93-0.8.patched/arch/powerpc/include/asm/irq.h
--- linux-3.0.93-0.8/arch/powerpc/include/asm/irq.h	2013-10-16 00:44:22.000000000 -0500
+++ linux-3.0.93-0.8.patched/arch/powerpc/include/asm/irq.h	2013-10-15 23:43:23.000000000 -0500
@@ -326,9 +326,9 @@ extern struct thread_info *softirq_ctx[N
 
 extern void irq_ctx_init(void);
 extern void call_do_softirq(struct thread_info *tp);
-extern int call_handle_irq(int irq, void *p1,
-			   struct thread_info *tp, void *func);
+extern void call_do_irq(struct pt_regs *regs, struct thread_info *tp);
 extern void do_IRQ(struct pt_regs *regs);
+extern void __do_irq(struct pt_regs *regs);
 
 #endif /* _ASM_IRQ_H */
 #endif /* __KERNEL__ */
diff -upr linux-3.0.93-0.8/arch/powerpc/kernel/irq.c linux-3.0.93-0.8.patched/arch/powerpc/kernel/irq.c
--- linux-3.0.93-0.8/arch/powerpc/kernel/irq.c	2013-10-16 00:44:22.000000000 -0500
+++ linux-3.0.93-0.8.patched/arch/powerpc/kernel/irq.c	2013-10-16 00:43:08.000000000 -0500
@@ -286,50 +286,6 @@ void migrate_irqs(void)
 }
 #endif
 
-static inline void handle_one_irq(unsigned int irq)
-{
-	struct thread_info *curtp, *irqtp;
-	unsigned long saved_sp_limit;
-	struct irq_desc *desc;
-
-	desc = irq_to_desc(irq);
-	if (!desc)
-		return;
-
-	/* Switch to the irq stack to handle this */
-	curtp = current_thread_info();
-	irqtp = hardirq_ctx[smp_processor_id()];
-
-	if (curtp == irqtp) {
-		/* We're already on the irq stack, just handle it */
-		desc->handle_irq(irq, desc);
-		return;
-	}
-
-	saved_sp_limit = current->thread.ksp_limit;
-
-	irqtp->task = curtp->task;
-	irqtp->flags = 0;
-
-	/* Copy the softirq bits in preempt_count so that the
-	 * softirq checks work in the hardirq context. */
-	irqtp->preempt_count = (irqtp->preempt_count & ~SOFTIRQ_MASK) |
-			       (curtp->preempt_count & SOFTIRQ_MASK);
-
-	current->thread.ksp_limit = (unsigned long)irqtp +
-		_ALIGN_UP(sizeof(struct thread_info), 16);
-
-	call_handle_irq(irq, desc, irqtp, desc->handle_irq);
-	current->thread.ksp_limit = saved_sp_limit;
-	irqtp->task = NULL;
-
-	/* Set any flag that may have been set on the
-	 * alternate stack
-	 */
-	if (irqtp->flags)
-		set_bits(irqtp->flags, &curtp->flags);
-}
-
 static inline void check_stack_overflow(void)
 {
 #ifdef CONFIG_DEBUG_STACKOVERFLOW
@@ -346,27 +302,26 @@ static inline void check_stack_overflow(
 #endif
 }
 
-void do_IRQ(struct pt_regs *regs)
+void __do_irq(struct pt_regs *regs)
 {
-	struct pt_regs *old_regs = set_irq_regs(regs);
+	struct irq_desc *desc;
 	unsigned int irq;
 
-	trace_irq_entry(regs);
-
 	irq_enter();
 
+	trace_irq_entry(regs);
+
 	check_stack_overflow();
 
 	irq = ppc_md.get_irq();
 
-	if (irq != NO_IRQ && irq != NO_IRQ_IGNORE)
-		handle_one_irq(irq);
-	else if (irq != NO_IRQ_IGNORE)
+	if (irq != NO_IRQ && irq != NO_IRQ_IGNORE) {
+		desc = irq_to_desc(irq);
+                if (likely(desc))
+                        desc->handle_irq(irq, desc);
+	} else if (irq != NO_IRQ_IGNORE)
 		__get_cpu_var(irq_stat).spurious_irqs++;
 
-	irq_exit();
-	set_irq_regs(old_regs);
-
 #ifdef CONFIG_PPC_ISERIES
 	if (firmware_has_feature(FW_FEATURE_ISERIES) &&
 			get_lppaca()->int_dword.fields.decr_int) {
@@ -377,6 +332,45 @@ void do_IRQ(struct pt_regs *regs)
 #endif
 
 	trace_irq_exit(regs);
+
+	irq_exit();
+}
+
+void do_IRQ(struct pt_regs *regs)
+{
+        struct pt_regs *old_regs = set_irq_regs(regs);
+        struct thread_info *curtp, *irqtp, *sirqtp;
+
+        /* Switch to the irq stack to handle this */
+        curtp = current_thread_info();
+        irqtp = hardirq_ctx[raw_smp_processor_id()];
+        sirqtp = softirq_ctx[raw_smp_processor_id()];
+
+        /* Already there ? */
+        if (unlikely(curtp == irqtp || curtp == sirqtp)) {
+                __do_irq(regs);
+                set_irq_regs(old_regs);
+                return;
+        }
+
+        /* Prepare the thread_info in the irq stack */
+        irqtp->task = curtp->task;
+        irqtp->flags = 0;
+
+        /* Copy the preempt_count so that the [soft]irq checks work. */
+        irqtp->preempt_count = curtp->preempt_count;
+
+        /* Switch stack and call */
+        call_do_irq(regs, irqtp);
+
+        /* Restore stack limit */
+        irqtp->task = NULL;
+
+        /* Copy back updates to the thread_info */
+        if (irqtp->flags)
+                set_bits(irqtp->flags, &curtp->flags);
+
+        set_irq_regs(old_regs);
 }
 
 void __init init_IRQ(void)
@@ -437,12 +431,10 @@ void irq_ctx_init(void)
 		memset((void *)softirq_ctx[i], 0, THREAD_SIZE);
 		tp = softirq_ctx[i];
 		tp->cpu = i;
-		tp->preempt_count = 0;
 
 		memset((void *)hardirq_ctx[i], 0, THREAD_SIZE);
 		tp = hardirq_ctx[i];
 		tp->cpu = i;
-		tp->preempt_count = HARDIRQ_OFFSET;
 	}
 }
 
diff -upr linux-3.0.93-0.8/arch/powerpc/kernel/misc_32.S linux-3.0.93-0.8.patched/arch/powerpc/kernel/misc_32.S
--- linux-3.0.93-0.8/arch/powerpc/kernel/misc_32.S	2013-10-16 00:44:22.000000000 -0500
+++ linux-3.0.93-0.8.patched/arch/powerpc/kernel/misc_32.S	2013-10-15 23:43:23.000000000 -0500
@@ -45,13 +45,12 @@ _GLOBAL(call_do_softirq)
 	mtlr	r0
 	blr
 
-_GLOBAL(call_handle_irq)
+_GLOBAL(call_do_irq)
 	mflr	r0
 	stw	r0,4(r1)
-	mtctr	r6
-	stwu	r1,THREAD_SIZE-STACK_FRAME_OVERHEAD(r5)
-	mr	r1,r5
-	bctrl
+	stwu	r1,THREAD_SIZE-STACK_FRAME_OVERHEAD(r4)
+	mr	r1,r4
+	bl	__do_irq
 	lwz	r1,0(r1)
 	lwz	r0,4(r1)
 	mtlr	r0
diff -upr linux-3.0.93-0.8/arch/powerpc/kernel/misc_64.S linux-3.0.93-0.8.patched/arch/powerpc/kernel/misc_64.S
--- linux-3.0.93-0.8/arch/powerpc/kernel/misc_64.S	2013-10-16 00:44:22.000000000 -0500
+++ linux-3.0.93-0.8.patched/arch/powerpc/kernel/misc_64.S	2013-10-15 23:43:23.000000000 -0500
@@ -40,14 +40,12 @@ _GLOBAL(call_do_softirq)
 	mtlr	r0
 	blr
 
-_GLOBAL(call_handle_irq)
-	ld	r8,0(r6)
+_GLOBAL(call_do_irq)
 	mflr	r0
 	std	r0,16(r1)
-	mtctr	r8
-	stdu	r1,THREAD_SIZE-STACK_FRAME_OVERHEAD(r5)
-	mr	r1,r5
-	bctrl
+	stdu	r1,THREAD_SIZE-STACK_FRAME_OVERHEAD(r4)
+	mr	r1,r4
+	bl	.__do_irq
 	ld	r1,0(r1)
 	ld	r0,16(r1)
 	mtlr	r0
