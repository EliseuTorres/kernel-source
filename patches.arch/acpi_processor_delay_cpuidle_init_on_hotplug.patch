From: trenn@suse.de
Subject: acpi processor hotplug: Delay most initialization to cpu online
References: fate#311831,bnc#703100
Patch-Mainline: no

When the CPU hotplug notification comes in via ACPI notify()
cpu_data of the core is not yet initialized.
This leads to errors in throttling and (if acpi_idle is used
as cpuidle driver) to not set up cpu idle subsystem.
-> Only bring up ACPI sysfs at that time
-> Initialize the rest (throttling, cpuidle,...) when a hotplugged
core is onlined the first time

Signed-off-by: Thomas Renninger <trenn@suse.de>

---
 drivers/acpi/processor_core.c |   58 ++++++++++++++++++++++++++++++++----------
 include/acpi/processor.h      |    1 
 2 files changed, 46 insertions(+), 13 deletions(-)

Index: linux-2.6.32-SLE11-SP2/drivers/acpi/processor_core.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/drivers/acpi/processor_core.c
+++ linux-2.6.32-SLE11-SP2/drivers/acpi/processor_core.c
@@ -86,7 +86,7 @@ static int acpi_processor_remove(struct
 static int acpi_processor_info_open_fs(struct inode *inode, struct file *file);
 #endif
 static void acpi_processor_notify(struct acpi_device *device, u32 event);
-static acpi_status acpi_processor_hotadd_init(acpi_handle handle, int *p_cpu);
+static acpi_status acpi_processor_hotadd_init(struct acpi_processor *pr);
 static int acpi_processor_handle_eject(struct acpi_processor *pr);
 
 
@@ -653,8 +653,7 @@ static int acpi_processor_get_info(struc
 	 *  they are physically not present.
 	 */
 	if (pr->id == -1) {
-		if (ACPI_FAILURE
-		    (acpi_processor_hotadd_init(pr->handle, &pr->id))) {
+		if (ACPI_FAILURE(acpi_processor_hotadd_init(pr))) {
 			return -ENODEV;
 		}
 	}
@@ -811,9 +810,26 @@ static int acpi_cpu_soft_notify(struct n
 	struct acpi_processor *pr = per_cpu(processors, cpu);
 
 	if (action == CPU_ONLINE && pr) {
-		acpi_processor_ppc_has_changed(pr);
-		acpi_processor_cst_has_changed(pr);
-		acpi_processor_tstate_has_changed(pr);
+		/* CPU got hotplugged and onlined the first time
+		 * Initialize missing things
+		 */
+		if (pr->flags.need_hotplug_init) {
+			struct cpuidle_driver *idle_driver = cpuidle_get_driver();
+
+			printk(KERN_INFO "Will online and init hotplugged "
+			       "CPU: %d\n", pr->id);
+			WARN(acpi_processor_start(pr), "Failed to start CPU:"
+				" %d\n", pr->id);
+			pr->flags.need_hotplug_init = 0;
+			if (idle_driver && !strcmp(idle_driver->name,
+						   "intel_idle")) {
+				intel_idle_cpu_init(pr->id);
+			}
+		} else {
+			acpi_processor_ppc_has_changed(pr);
+			acpi_processor_cst_has_changed(pr);
+			acpi_processor_tstate_has_changed(pr);
+		}
 	}
 	return NOTIFY_OK;
 }
@@ -876,6 +892,13 @@ static int __cpuinit acpi_processor_add(
 		result = -EFAULT;
 		goto err_remove_fs;
 	}
+	/*
+	 * Do not start hotplugged CPUs now, but when they
+	 * are onlined the first time
+	 */
+	if (pr->flags.need_hotplug_init)
+		return 0;
+
 	result = acpi_processor_start(pr);
  	if (result)
 		goto err_remove_sysfs;
@@ -1069,20 +1092,29 @@ processor_walk_namespace_cb(acpi_handle
 	return (AE_OK);
 }
 
-static acpi_status acpi_processor_hotadd_init(acpi_handle handle, int *p_cpu)
+static acpi_status acpi_processor_hotadd_init(struct acpi_processor *pr)
 {
-
-	if (!is_processor_present(handle)) {
+	if (!is_processor_present(pr->handle)) {
 		return AE_ERROR;
 	}
 
-	if (acpi_map_lsapic(handle, p_cpu))
+	if (acpi_map_lsapic(pr->handle, &pr->id))
 		return AE_ERROR;
 
-	if (arch_register_cpu(*p_cpu)) {
-		acpi_unmap_lsapic(*p_cpu);
+	if (arch_register_cpu(pr->id)) {
+		acpi_unmap_lsapic(pr->id);
 		return AE_ERROR;
 	}
+	/* CPU got hot-plugged, but cpu_data is not initialized yet
+	 * Set flag to delay cpu_idle/throttling initialization
+	 * in:
+	 * acpi_processor_add()
+	 *   acpi_processor_get_info()
+	 * and do it when the CPU gets online the first time
+	 * TBD: Cleanup above functions and try to do this more elegant.
+	 */
+	printk(KERN_INFO "CPU %d got hotplugged\n", pr->id);
+	pr->flags.need_hotplug_init = 1;
 
 	return AE_OK;
 }
@@ -1097,7 +1129,7 @@ static int acpi_processor_handle_eject(s
 	return (0);
 }
 #else
-static acpi_status acpi_processor_hotadd_init(acpi_handle handle, int *p_cpu)
+static acpi_status acpi_processor_hotadd_init(struct acpi_processor *pr)
 {
 	return AE_ERROR;
 }
Index: linux-2.6.32-SLE11-SP2/include/acpi/processor.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/include/acpi/processor.h
+++ linux-2.6.32-SLE11-SP2/include/acpi/processor.h
@@ -208,6 +208,7 @@ struct acpi_processor_flags {
 	u8 has_cst:1;
 	u8 power_setup_done:1;
 	u8 bm_rld_set:1;
+	u8 need_hotplug_init:1;
 };
 
 struct acpi_processor {
