From: trenn@suse.de
Subject: acpi processor hotplug: Delay most initialization to cpu online
References: fate#311831,bnc#703100
Patch-Mainline: no

When the CPU hotplug notification comes in via ACPI notify()
cpu_data of the core is not yet initialized.
This leads to errors in throttling and (if acpi_idle is used
as cpuidle driver) to not set up cpu idle subsystem.
-> Only bring up ACPI sysfs at that time
-> Initialize the rest (throttling, cpuidle,...) when a hotplugged
core is onlined the first time

Signed-off-by: Thomas Renninger <trenn@suse.de>

---
 drivers/acpi/processor_core.c |   37 ++++++++++++++++++++++++++++++++++---
 include/acpi/processor.h      |    1 +
 2 files changed, 35 insertions(+), 3 deletions(-)

Index: linux-2.6.32-SLE11-SP2/drivers/acpi/processor_core.c
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/drivers/acpi/processor_core.c
+++ linux-2.6.32-SLE11-SP2/drivers/acpi/processor_core.c
@@ -778,7 +778,11 @@ static void acpi_processor_notify(struct
 
 static int __cpuinit acpi_processor_start(struct acpi_processor *pr)
 {
+#ifndef CONFIG_XEN
 	struct acpi_device *device = per_cpu(processor_device_array, pr->id);
+#else
+	struct acpi_device *device = processor_device_array[pr->acpi_id];
+#endif
 	int result = 0;
 
 	/* _PDC call should be done before doing anything else (if reqd.). */
@@ -863,9 +867,26 @@ static int acpi_cpu_soft_notify(struct n
 	struct acpi_processor *pr = per_cpu(processors, cpu);
 
 	if (action == CPU_ONLINE && pr) {
-		acpi_processor_ppc_has_changed(pr);
-		acpi_processor_cst_has_changed(pr);
-		acpi_processor_tstate_has_changed(pr);
+		/* CPU got hotplugged and onlined the first time
+		 * Initialize missing things
+		 */
+		if (pr->flags.need_hotplug_init) {
+			struct cpuidle_driver *idle_driver = cpuidle_get_driver();
+
+			printk(KERN_INFO "Will online and init hotplugged "
+			       "CPU: %d\n", pr->id);
+			WARN(acpi_processor_start(pr), "Failed to start CPU:"
+				" %d\n", pr->id);
+			pr->flags.need_hotplug_init = 0;
+			if (idle_driver && !strcmp(idle_driver->name,
+						   "intel_idle")) {
+				intel_idle_cpu_init(pr->id);
+			}
+		} else {
+			acpi_processor_ppc_has_changed(pr);
+			acpi_processor_cst_has_changed(pr);
+			acpi_processor_tstate_has_changed(pr);
+		}
 	}
 	return NOTIFY_OK;
 }
@@ -1184,6 +1205,16 @@ static acpi_status acpi_processor_hotadd
 		acpi_unmap_lsapic(*p_cpu);
 		return AE_ERROR;
 	}
+	/* CPU got hot-plugged, but cpu_data is not initialized yet
+	 * Set flag to delay cpu_idle/throttling initialization
+	 * in:
+	 * acpi_processor_add()
+	 *   acpi_processor_get_info()
+	 * and do it when the CPU gets online the first time
+	 * TBD: Cleanup above functions and try to do this more elegant.
+	 */
+	printk(KERN_INFO "CPU %d got hotplugged\n", *p_cpu);
+	pr->flags.need_hotplug_init = 1;
 
 	return AE_OK;
 }
Index: linux-2.6.32-SLE11-SP2/include/acpi/processor.h
===================================================================
--- linux-2.6.32-SLE11-SP2.orig/include/acpi/processor.h
+++ linux-2.6.32-SLE11-SP2/include/acpi/processor.h
@@ -243,6 +243,7 @@ struct acpi_processor_flags {
 	u8 has_cst:1;
 	u8 power_setup_done:1;
 	u8 bm_rld_set:1;
+	u8 need_hotplug_init:1;
 };
 
 struct acpi_processor {
