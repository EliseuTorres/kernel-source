From: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Subject: s390/cpum_sf: Add flag to process full SDBs only
Patch-mainline: v3.14-rc1
Git-commit: d7528862cf035994972c2c6f42c927db78f2f3a2
References: bnc#900899, FATE#317698, LTC#110510

Summary:     s390/perf: add support for the CPU-measurement sampling facility
Description: Use the CPU-measurement sampling facility to obtain performance
             data for Linux in LPAR mode.  You can use the perf tool on Linux
             to access the hardware sample data of the CPU-measurement
             sampling facility.

Upstream-Description:

             s390/cpum_sf: Add flag to process full SDBs only

             Add the PERF_CPUM_SF_FULL_BLOCKS flag to process only sample-data-blocks that
             have the block-full-indicator bit set.  Sample-data-blocks that are partially
             filled are discarded.  Use this flag if the sampling buffer is likely to be
             shared among perf events that use different sampling modes.  In such
             environments, flushing sample-data-blocks that are not completely filled, might
             cause invalid-data-formats.

             Setting PERF_CPUM_SF_FULL_BLOCKS prevents potentially invalid sampling data to
             be processed but, in contrast, also discards valid samples in partially filled
             sample-data-blocks.  Note that sample-data-blocks might not become full for
             small sampling frequencies or for workload that is scheduled for tiny intervals.

             To sample with the PERF_CPUM_SF_FULL_BLOCKS flag, set the perf->attr.config1
             to 0x0004.  For example:

             	perf record -e cpum_sf/config=0xB000,config1=0x0004/

             Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
             Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/perf_event.h |    2 ++
 arch/s390/kernel/perf_cpum_sf.c    |   13 +++++++++++--
 2 files changed, 13 insertions(+), 2 deletions(-)

--- a/arch/s390/include/asm/perf_event.h
+++ b/arch/s390/include/asm/perf_event.h
@@ -42,6 +42,7 @@ struct perf_sf_sde_regs {
 #define PERF_CPUM_SF_DIAG_MODE		0x0002	  /* Diagnostic-sampling flag */
 #define PERF_CPUM_SF_MODE_MASK		(PERF_CPUM_SF_BASIC_MODE| \
 					 PERF_CPUM_SF_DIAG_MODE)
+#define PERF_CPUM_SF_FULL_BLOCKS	0x0004	  /* Process full SDBs only */
 
 #define REG_NONE		0
 #define REG_OVERFLOW		1
@@ -52,6 +53,7 @@ struct perf_sf_sde_regs {
 #define SAMPL_RATE(hwc)		((hwc)->event_base)
 #define SAMPL_FLAGS(hwc)	((hwc)->config_base)
 #define SAMPL_DIAG_MODE(hwc)	(SAMPL_FLAGS(hwc) & PERF_CPUM_SF_DIAG_MODE)
+#define SDB_FULL_BLOCKS(hwc)	(SAMPL_FLAGS(hwc) & PERF_CPUM_SF_FULL_BLOCKS)
 
 /* Structure for sampling data entries to be passed as perf raw sample data
  * to user space.  Note that raw sample data must be aligned and, thus, might
--- a/arch/s390/kernel/perf_cpum_sf.c
+++ b/arch/s390/kernel/perf_cpum_sf.c
@@ -732,6 +732,10 @@ static int __hw_perf_event_init(struct p
 		SAMPL_FLAGS(hwc) |= PERF_CPUM_SF_DIAG_MODE;
 	}
 
+	/* Check and set other sampling flags */
+	if (attr->config1 & PERF_CPUM_SF_FULL_BLOCKS)
+		SAMPL_FLAGS(hwc) |= PERF_CPUM_SF_FULL_BLOCKS;
+
 	/* The sampling information (si) contains information about the
 	 * min/max sampling intervals and the CPU speed.  So calculate the
 	 * correct sampling interval and avoid the whole period adjust
@@ -1206,8 +1210,10 @@ static void hw_collect_samples(struct pe
  * register of the specified perf event.
  *
  * Only full sample-data-blocks are processed.	Specify the flash_all flag
- * to also walk through partially filled sample-data-blocks.
- *
+ * to also walk through partially filled sample-data-blocks.  It is ignored
+ * if PERF_CPUM_SF_FULL_BLOCKS is set.	The PERF_CPUM_SF_FULL_BLOCKS flag
+ * enforces the processing of full sample-data-blocks only (trailer entries
+ * with the block-full-indicator bit set).
  */
 static void hw_perf_event_update(struct perf_event *event, int flush_all)
 {
@@ -1217,6 +1223,9 @@ static void hw_perf_event_update(struct
 	unsigned long long event_overflow, sampl_overflow, num_sdb, te_flags;
 	int done;
 
+	if (flush_all && SDB_FULL_BLOCKS(hwc))
+		flush_all = 0;
+
 	sdbt = (unsigned long *) TEAR_REG(hwc);
 	done = event_overflow = sampl_overflow = num_sdb = 0;
 	while (!done) {
