From: Suresh Siddha <suresh.b.siddha@intel.com>
References: bnc#581940
Patch-mainline: yes
Git: 502f660466ba7a66711ffdf414b1f7f1131dcbf7
Subject: x86, cpa: Fix kernel text RO checks in static_protection

    Steven Rostedt reported that we are unconditionally making the
    kernel text mapping as read-only. i.e., if someone does cpa() to
    the kernel text area for setting/clearing any page table
    attribute, we unconditionally clear the read-write attribute for
    the kernel text mapping that is set at compile time.
    
    We should delay (to forbid the write attribute) and enforce only
    after the kernel has mapped the text as read-only.
    
    Reported-by: Steven Rostedt <rostedt@goodmis.org>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Acked-by: Steven Rostedt <rostedt@goodmis.org>
    Tested-by: Steven Rostedt <rostedt@goodmis.org>
    LKML-Reference: <20091029024820.996634347@sbs-t61.sc.intel.com>
    [ marked kernel_set_to_readonly as __read_mostly ]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
Acked-by: Nick Piggin <npiggin@suse.de>

Index: linux-2.6.27/arch/x86/include/asm/cacheflush.h
===================================================================
--- linux-2.6.27.orig/arch/x86/include/asm/cacheflush.h
+++ linux-2.6.27/arch/x86/include/asm/cacheflush.h
@@ -179,6 +179,7 @@ void clflush_cache_range(void *addr, uns
 void mark_rodata_ro(void);
 void mark_rodata_rw(void);
 extern const int rodata_test_data;
+extern int kernel_set_to_readonly;
 void set_kernel_text_rw(void);
 void set_kernel_text_ro(void);
 #else
Index: linux-2.6.27/arch/x86/mm/init_32.c
===================================================================
--- linux-2.6.27.orig/arch/x86/mm/init_32.c
+++ linux-2.6.27/arch/x86/mm/init_32.c
@@ -997,7 +997,7 @@ static noinline int do_test_wp_bit(void)
 const int rodata_test_data = 0xC3;
 EXPORT_SYMBOL_GPL(rodata_test_data);
 
-static int kernel_set_to_readonly;
+int kernel_set_to_readonly __read_mostly;
 
 void set_kernel_text_rw(void)
 {
Index: linux-2.6.27/arch/x86/mm/init_64.c
===================================================================
--- linux-2.6.27.orig/arch/x86/mm/init_64.c
+++ linux-2.6.27/arch/x86/mm/init_64.c
@@ -694,7 +694,7 @@ void __init mem_init(void)
 const int rodata_test_data = 0xC3;
 EXPORT_SYMBOL_GPL(rodata_test_data);
 
-static int kernel_set_to_readonly;
+int kernel_set_to_readonly;
 
 void set_kernel_text_rw(void)
 {
Index: linux-2.6.27/arch/x86/mm/pageattr.c
===================================================================
--- linux-2.6.27.orig/arch/x86/mm/pageattr.c
+++ linux-2.6.27/arch/x86/mm/pageattr.c
@@ -285,14 +285,16 @@ static inline pgprot_t static_protection
 
 #if defined(CONFIG_X86_64) && defined(CONFIG_DEBUG_RODATA)
 	/*
-	 * Kernel text mappings for the large page aligned .rodata section
-	 * will be read-only. For the kernel identity mappings covering
-	 * the holes caused by this alignment can be anything.
+	 * Once the kernel maps the text as RO (kernel_set_to_readonly is set),
+	 * kernel text mappings for the large page aligned text, rodata sections
+	 * will be always read-only. For the kernel identity mappings covering
+	 * the holes caused by this alignment can be anything that user asks.
 	 *
 	 * This will preserve the large page mappings for kernel text/data
 	 * at no extra cost.
 	 */
-	if (within(address, (unsigned long)_text,
+	if (kernel_set_to_readonly &&
+	    within(address, (unsigned long)_text,
 		   (unsigned long)__end_rodata_hpage_align)) {
 		if (!static_protections_allow_rodata)
 			pgprot_val(forbidden) |= _PAGE_RW;
