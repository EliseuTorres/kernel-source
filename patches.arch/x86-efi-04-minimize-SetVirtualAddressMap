From: Matthew Garrett <mjg@redhat.com>
Subject: x86, efi: Pass a minimal map to SetVirtualAddressMap()
Date: Thu May 5 15:19:45 2011 -0400
Patch-mainline: 3.0-rc1
References: bnc#568848, bnc#655434, bnc#681242

commit 7cb00b72876ea2451eb79d468da0e8fb9134aa8a

    x86, efi: Pass a minimal map to SetVirtualAddressMap()
    
    Experimentation with various EFI implementations has shown that functions
    outside runtime services will still update their pointers if
    SetVirtualAddressMap() is called with memory descriptors outside the
    runtime area. This is obviously insane, and therefore is unsurprising.
    Evidence from instrumenting another EFI implementation suggests that it
    only passes the set of descriptors covering runtime regions, so let's
    avoid any problems by doing the same. Runtime descriptors are copied to
    a separate memory map, and only that map is passed back to the firmware.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Link: http://lkml.kernel.org/r/1304623186-18261-4-git-send-email-mjg@redhat.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

--

Acked-by: Raymund Will <rw@suse.de>

---
 arch/x86/kernel/efi.c |   14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

--- a/arch/x86/kernel/efi.c
+++ b/arch/x86/kernel/efi.c
@@ -502,7 +502,8 @@ void __init efi_enter_virtual_mode(void)
 	efi_status_t status;
 	unsigned long size;
 	u64 end, systab, addr, npages, end_pfn;
-	void *p, *va;
+	void *p, *va, *new_memmap = NULL;
+	int count = 0;
 
 	efi.systab = NULL;
 
@@ -569,15 +570,21 @@ void __init efi_enter_virtual_mode(void)
 			systab += md->virt_addr - md->phys_addr;
 			efi.systab = (efi_system_table_t *) (unsigned long) systab;
 		}
+		new_memmap = krealloc(new_memmap,
+				      (count + 1) * memmap.desc_size,
+				      GFP_KERNEL);
+		memcpy(new_memmap + (count * memmap.desc_size), md,
+		       memmap.desc_size);
+		count++;
 	}
 
 	BUG_ON(!efi.systab);
 
 	status = phys_efi_set_virtual_address_map(
-		memmap.desc_size * memmap.nr_map,
+		memmap.desc_size * count,
 		memmap.desc_size,
 		memmap.desc_version,
-		memmap.phys_map);
+		(efi_memory_desc_t *)__pa(new_memmap));
 
 	if (status != EFI_SUCCESS) {
 		printk(KERN_ALERT "Unable to switch EFI into virtual mode "
@@ -605,6 +612,7 @@ void __init efi_enter_virtual_mode(void)
 		runtime_code_page_mkexec();
 	early_iounmap(memmap.map, memmap.nr_map * memmap.desc_size);
 	memmap.map = NULL;
+	kfree(new_memmap);
 }
 
 /*
