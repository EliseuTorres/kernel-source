From 307aa6ea80af0f93370f943103631a83dc0ae8eb Mon Sep 17 00:00:00 2001
From: Heiko Carstens <heiko.carstens@de.ibm.com>
Date: Tue, 26 Jun 2012 16:06:39 +0200
Subject: [PATCH 31/42] KVM: s390: fix sigp set prefix status stored cases
Git-commit: 0744426e28490357855aafd2ca76c819231851c5
References: FATE#314101,FATE#310914
Patch-mainline: Merged into kvm

If an invalid parameter is passed or the addressed cpu is in an
incorrect state sigp set prefix will store a status.
This status must only have bits set as defined by the architecture.
The current kvm implementation missed to clear bits and also did
not set the intended status bit ("and" instead of "or" operation).

Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
Signed-off-by: Alexander Graf <agraf@suse.de>

---
 arch/s390/kvm/sigp.c |   28 ++++++++++++++++++++++++++--
 1 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/arch/s390/kvm/sigp.c b/arch/s390/kvm/sigp.c
index a78f236..c400e3d 100644
--- a/arch/s390/kvm/sigp.c
+++ b/arch/s390/kvm/sigp.c
@@ -46,6 +46,27 @@
 #define SIGP_STAT_INVALID_ORDER     0x00000002UL
 #define SIGP_STAT_RECEIVER_CHECK    0x00000001UL
 
+/* New defines for current code. Having these here too makes backports easier */
+/* SIGP order codes */
+#define SIGP_EMERGENCY_SIGNAL         3
+#define SIGP_STORE_STATUS_AT_ADDRESS 14
+#define SIGP_SET_ARCHITECTURE        18
+
+/* SIGP condition codes */
+#define SIGP_CC_ORDER_CODE_ACCEPTED 0
+#define SIGP_CC_STATUS_STORED       1
+#define SIGP_CC_BUSY                2
+#define SIGP_CC_NOT_OPERATIONAL     3
+
+/* SIGP cpu status bits */
+
+#define SIGP_STATUS_CHECK_STOP          0x00000010UL
+#define SIGP_STATUS_STOPPED             0x00000040UL
+#define SIGP_STATUS_EXT_CALL_PENDING    0x00000080UL
+#define SIGP_STATUS_INVALID_PARAMETER   0x00000100UL
+#define SIGP_STATUS_INCORRECT_STATE     0x00000200UL
+#define SIGP_STATUS_NOT_RUNNING         0x00000400UL
+
 
 static int __sigp_sense(struct kvm_vcpu *vcpu, u16 cpu_addr,
 			u64 *reg)
@@ -237,6 +258,7 @@ static int __sigp_set_prefix(struct kvm_vcpu *vcpu, u16 cpu_addr, u32 address,
 		(address + vcpu->arch.sie_block->gmsor) , 1)) ||
 	   (copy_from_user(&tmp, (void __user *)(address +
 			vcpu->arch.sie_block->gmsor + PAGE_SIZE), 1))) {
+		*reg &= 0xffffffff00000000UL;
 		*reg |= SIGP_STAT_INVALID_PARAMETER;
 		return 1; /* invalid parameter */
 	}
@@ -250,8 +272,9 @@ static int __sigp_set_prefix(struct kvm_vcpu *vcpu, u16 cpu_addr, u32 address,
 		li = fi->local_int[cpu_addr];
 
 	if (li == NULL) {
+		*reg &= 0xffffffff00000000UL;
+		*reg |= SIGP_STATUS_INCORRECT_STATE;
 		rc = 1; /* incorrect state */
-		*reg &= SIGP_STAT_INCORRECT_STATE;
 		kfree(inti);
 		goto out_fi;
 	}
@@ -259,8 +282,9 @@ static int __sigp_set_prefix(struct kvm_vcpu *vcpu, u16 cpu_addr, u32 address,
 	spin_lock_bh(&li->lock);
 	/* cpu must be in stopped state */
 	if (!(atomic_read(li->cpuflags) & CPUSTAT_STOPPED)) {
+		*reg &= 0xffffffff00000000UL;
+		*reg |= SIGP_STATUS_INCORRECT_STATE;
 		rc = 1; /* incorrect state */
-		*reg &= SIGP_STAT_INCORRECT_STATE;
 		kfree(inti);
 		goto out_li;
 	}
-- 
1.6.0.2

