From 66f8bbd45012da05c9b7ffc1faa63cefe4a47879 Mon Sep 17 00:00:00 2001
From: Tomasz Nowicki <tomasz.nowicki@linaro.org>
Date: Mon, 3 Nov 2014 18:23:16 +0100
Subject: [PATCH 116/131] ARM64, ACPI, PCI, MSI: I/O Remapping Table (IORT)
 initial support.
Git-commit: 1733664aaa54ed3f4e726ebe9564c03fce6577b7
Patch-mainline: Queued in subsystem maintainer repository
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/rric/linux.git thunder/master-v4.1

IORT shows representation of IO topology that will be used by
ARM based systems. It describes how various components are connected
together e.g. which devices are connected to given ITS instance.

This patch implements calls which allow to:
- register/remove ITS as MSI chip
- parse all IORT nodes and form node tree (for easy lookup)
- find ITS (MSI chip) that device is assigned to

Signed-off-by: Tomasz Nowicki <tomasz.nowicki@linaro.org>

Signed-off-by: Matthias Brugger <mbrugger@suse.com>

---
 drivers/acpi/Kconfig  |   3 +
 drivers/acpi/Makefile |   1 +
 drivers/acpi/iort.c   | 257 ++++++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/iort.h  |  37 ++++++++
 4 files changed, 298 insertions(+)
 create mode 100644 drivers/acpi/iort.c
 create mode 100644 include/linux/iort.h

diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig
index ab2cbb5..aac4fe7 100644
--- a/drivers/acpi/Kconfig
+++ b/drivers/acpi/Kconfig
@@ -54,6 +54,9 @@ config ACPI_GENERIC_GSI
 config ACPI_SYSTEM_POWER_STATES_SUPPORT
 	bool
 
+config IORT_TABLE
+	bool
+
 config ACPI_CCA_REQUIRED
 	bool

 config ACPI_SLEEP
 	bool
 	depends on SUSPEND || HIBERNATION
diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile
index 4940458..399e4b7 100644
--- a/drivers/acpi/Makefile
+++ b/drivers/acpi/Makefile
@@ -81,6 +81,7 @@ obj-$(CONFIG_ACPI_HED)		+= hed.o
 obj-$(CONFIG_ACPI_EC_DEBUGFS)	+= ec_sys.o
 obj-$(CONFIG_ACPI_CUSTOM_METHOD)+= custom_method.o
 obj-$(CONFIG_ACPI_BGRT)		+= bgrt.o
+obj-$(CONFIG_IORT_TABLE) 	+= iort.o
 
 # processor has its own "processor." module_param namespace
 processor-y			:= processor_driver.o processor_throttling.o
diff --git a/drivers/acpi/iort.c b/drivers/acpi/iort.c
new file mode 100644
index 0000000..36c86fd
--- /dev/null
+++ b/drivers/acpi/iort.c
@@ -0,0 +1,257 @@
+/*
+ * Copyright (C) 2014-2015, Linaro Ltd.
+ *	Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * This file implements early detection/parsing of I/O mapping
+ * reported to OS through BIOS via I/O Remapping Table (IORT) ACPI
+ * table.
+ *
+ * These routines are used by ITS and PCI host bridge drivers.
+ */
+
+#include <linux/acpi.h>
+#include <linux/export.h>
+#include <linux/iort.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/msi.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+#define IORT_PFX	"IORT: "
+
+static LIST_HEAD(iort_node_list);
+static DEFINE_MUTEX(iort_tree_roots_mutex);
+static struct acpi_table_header *iort_table;
+
+struct iort_its_msi_chip {
+	struct list_head	list;
+	struct msi_controller	*chip;
+	u32			id;
+};
+
+typedef acpi_status (*iort_find_node_callback)
+	(struct acpi_table_iort_node_header *node, void *context);
+
+static LIST_HEAD(iort_pci_msi_chip_list);
+static DEFINE_MUTEX(iort_pci_msi_chip_mutex);
+
+int iort_pci_msi_chip_add(struct msi_controller *chip, u32 its_id)
+{
+	struct iort_its_msi_chip *its_msi_chip;
+
+	its_msi_chip = kzalloc(sizeof(*its_msi_chip), GFP_KERNEL);
+	if (!its_msi_chip)
+		return -ENOMEM;
+
+	its_msi_chip->chip = chip;
+	its_msi_chip->id = its_id;
+
+	mutex_lock(&iort_pci_msi_chip_mutex);
+	list_add(&its_msi_chip->list, &iort_pci_msi_chip_list);
+	mutex_unlock(&iort_pci_msi_chip_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iort_pci_msi_chip_add);
+
+void iort_pci_msi_chip_remove(struct msi_controller *chip)
+{
+	struct iort_its_msi_chip *its_msi_chip, *tmp;
+
+	mutex_lock(&iort_pci_msi_chip_mutex);
+	list_for_each_entry_safe(its_msi_chip, tmp, &iort_pci_msi_chip_list,
+				 list) {
+		if (its_msi_chip->chip == chip) {
+			list_del(&chip->list);
+			mutex_unlock(&iort_pci_msi_chip_mutex);
+			kfree(its_msi_chip);
+		}
+	}
+	mutex_unlock(&iort_pci_msi_chip_mutex);
+}
+EXPORT_SYMBOL_GPL(iort_pci_msi_chip_remove);
+
+static struct msi_controller *iort_pci_find_msi_chip_by_id(u32 its_id)
+{
+	struct iort_its_msi_chip *its_msi_chip;
+
+	mutex_lock(&iort_pci_msi_chip_mutex);
+	list_for_each_entry(its_msi_chip, &iort_pci_msi_chip_list, list) {
+		if (its_msi_chip->id == its_id) {
+			mutex_unlock(&iort_pci_msi_chip_mutex);
+			return its_msi_chip->chip;
+		}
+	}
+	mutex_unlock(&iort_pci_msi_chip_mutex);
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(iort_pci_find_msi_chip_by_id);
+
+static struct acpi_table_iort_node_header *
+iort_find_root_node(struct acpi_table_iort_node_header *node)
+{
+	struct acpi_table_iort_node_id *id_map;
+
+	if (!node)
+		return NULL;
+
+	/* Root node has no ID map */
+	while (node->ref_to_ids) {
+		id_map = ACPI_ADD_PTR(struct acpi_table_iort_node_id,
+				      node, node->ref_to_ids);
+
+		/* Firmware bug! */
+		if (!id_map->output_ref) {
+			pr_err(IORT_PFX FW_BUG "[node %p type %d] ID map has invalid parent reference\n",
+			       node, node->type);
+			return NULL;
+		}
+
+		node = ACPI_ADD_PTR(struct acpi_table_iort_node_header,
+					 iort_table, id_map->output_ref);
+	}
+
+	return node;
+}
+
+static struct acpi_table_iort_node_header *
+iort_find_node_type(int type, iort_find_node_callback callback, void *context)
+{
+	struct acpi_table_iort_node_header *iort_node, *iort_end;
+
+	/* Skip IORT header */
+	iort_node = ACPI_ADD_PTR(struct acpi_table_iort_node_header, iort_table,
+				 sizeof(struct acpi_table_iort));
+	iort_end = ACPI_ADD_PTR(struct acpi_table_iort_node_header, iort_table,
+				iort_table->length);
+
+	while (iort_node < iort_end) {
+		if (iort_node->type == type || type == -1) {
+			if (ACPI_SUCCESS(callback(iort_node, context)))
+				return iort_node;
+		}
+
+		iort_node = ACPI_ADD_PTR(struct acpi_table_iort_node_header,
+					  iort_node, iort_node->length);
+	}
+
+	return NULL;
+}
+
+static acpi_status
+iort_find_pci_rc_callback(struct acpi_table_iort_node_header *node, void *context)
+{
+	int segment = *(int *)context;
+	struct acpi_table_iort_node_root_complex *pci_rc;
+
+	pci_rc = ACPI_ADD_PTR(struct acpi_table_iort_node_root_complex, node,
+			      sizeof(struct acpi_table_iort_node_header));
+
+	if (pci_rc->segment == segment)
+		return AE_OK;
+
+	return AE_NOT_FOUND;
+}
+
+static struct acpi_table_iort_node_header *
+iort_find_pci_rc(int segment)
+{
+
+	if (!iort_table)
+		return NULL;
+
+	return iort_find_node_type(ACPI_IORT_TYPE_ROOT_COMPLEX,
+				   iort_find_pci_rc_callback, &segment);
+}
+
+struct msi_controller *iort_find_pci_msi_chip(int segment, unsigned int idx)
+{
+	struct acpi_table_iort_node_its *its_node;
+	struct acpi_table_iort_node_header *node;
+	struct msi_controller *msi_chip;
+
+	if (!iort_table)
+		return NULL;
+
+	node = iort_find_pci_rc(segment);
+	if (!node) {
+		pr_err(IORT_PFX "can not find node related to PCI host bridge [segment %d]\n",
+		       segment);
+		return NULL;
+	}
+
+	node = iort_find_root_node(node);
+	if (!node || node->type != ACPI_IORT_TYPE_ITS_GROUP) {
+		pr_err(IORT_PFX "can not find ITS node parent for PCI host bridge [segment %d]\n",
+		       segment);
+		return NULL;
+	}
+
+	/* Move to ITS specific data */
+	its_node = ACPI_ADD_PTR(struct acpi_table_iort_node_its, node,
+				sizeof(struct acpi_table_iort_node_header));
+
+	if (idx > its_node->number_of_its) {
+		pr_err(IORT_PFX "requested ITS ID index [%d] is greater than available ITS IDs [%d]\n",
+		       idx, its_node->number_of_its);
+		return NULL;
+	}
+
+	msi_chip = iort_pci_find_msi_chip_by_id(its_node->its_id[idx]);
+	if (!msi_chip)
+		pr_err(IORT_PFX "can not find ITS chip ID:%d, not registered\n",
+		       its_node->its_id[idx]);
+
+	return msi_chip;
+}
+EXPORT_SYMBOL_GPL(iort_find_pci_msi_chip);
+
+static int __init iort_init(void)
+{
+	struct acpi_table_header *table;
+	acpi_status status;
+
+	if (acpi_disabled)
+		return -ENODEV;
+
+	status = acpi_get_table(ACPI_SIG_IORT, 0, &table);
+	if (status == AE_NOT_FOUND)
+		return -ENODEV;
+	else if (ACPI_FAILURE(status)) {
+		const char *msg = acpi_format_exception(status);
+		pr_err(IORT_PFX "Failed to get table, %s\n", msg);
+		return -EINVAL;
+	}
+
+	if (!table->length) {
+		pr_err(IORT_PFX FW_BUG "0 length table\n");
+		return -EINVAL;
+	}
+
+	iort_table = table;
+	return 0;
+}
+
+static void __exit iort_exit(void)
+{
+	iort_table = NULL;
+}
+
+arch_initcall(iort_init);
+module_exit(iort_exit);
+
+MODULE_DESCRIPTION("IORT (I/O remapping ACPI table) parsing helpers");
+MODULE_AUTHOR("Tomasz Nowicki <tomasz.nowicki@linaro.org>");
+MODULE_LICENSE("GPL v2");
diff --git a/include/linux/iort.h b/include/linux/iort.h
new file mode 100644
index 0000000..b6a06ef
--- /dev/null
+++ b/include/linux/iort.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014, Linaro Ltd.
+ *	Author: Tomasz Nowicki <tomasz.nowicki@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ */
+
+#ifndef __IORT_H__
+#define __IORT_H__
+
+struct msi_controller;
+
+#ifdef CONFIG_IORT_TABLE
+int iort_pci_msi_chip_add(struct msi_controller *chip, u32 its_id);
+void iort_pci_msi_chip_remove(struct msi_controller *chip);
+struct msi_controller *iort_find_pci_msi_chip(int segment, unsigned int idx);
+#else
+static inline int
+iort_pci_msi_chip_add(struct msi_controller *chip, u32 its_id) { return 0; }
+static inline void
+iort_pci_msi_chip_remove(struct msi_controller *chip) {}
+static struct msi_controller *
+iort_find_pci_msi_chip(int segment, unsigned int idx) { return NULL; }
+#endif
+
+#endif /* __IORT_H__ */
-- 
1.7.12.4

