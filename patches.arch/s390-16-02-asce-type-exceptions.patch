From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Subject: kernel: correct handling of asce-type exceptions
Patch-mainline: not yet
Git-commit: -
References: bnc#851879, LTC#100293

Description:  kernel: correct handling of asce-type exceptions
Symptom:      Kernel panic after program check in user copy code
Problem:      If a user space program passes a pointer with an address
              larger than the current page table limit and the kernel
              tries to access the user memory with the mvcos instruction,
              an asce-type exception is generated. The default trap is
              called for the asce-type exception and the system panics.
Solution:     Call the standard page fault handler do_dat_exception
              for asce-type exceptions.
Reproduction: Run a program that passes an invalid, large address on
              a system call as user pointer, e.g. access((char *)-1, R_OK).

Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/kernel/traps.c |    1 +
 1 file changed, 1 insertion(+)

--- a/arch/s390/kernel/traps.c
+++ b/arch/s390/kernel/traps.c
@@ -667,6 +667,7 @@ void __init trap_init(void)
         pgm_check_table[0x13] = &special_op_exception;
 #ifdef CONFIG_64BIT
 	pgm_check_table[0x18] = &transaction_exception;
+	pgm_check_table[0x38] = &do_dat_exception;
 	pgm_check_table[0x39] = &do_dat_exception;
 	pgm_check_table[0x3A] = &do_dat_exception;
         pgm_check_table[0x3B] = &do_dat_exception;
