From: Michael Holzheu <holzheu@linux.vnet.ibm.com>
Subject: s390/sclp_early: Pass sccb pointer to every *_detect() function
Patch-mainline: v3.14-rc1
Git-commit: 5d5de1a068efffb0dcc03235e6fa258201096f02
References: bnc#917125, LTC#122429

Description:  s390/sclp: Determine HSA size dynamically for zfcpdump
Symptom:      For future s390 machines that potentially use more than
              the current 32 MiB HSA for zfcpdump, the memory in kernel
              dumps in the range [32 MiB, HSA size] will contain invalid data.
Problem:      Currently the first 32 MiB (hardcoded) are copied from HSA and
              everything above is copied from real memory (which
              potentially will be overwritten by the firmware).
Solution:     Determine current HSA size dynamically via SCLP in "early.c"
              and copy everything that is contained in HSA.
              To be prepared for upcoming sclp commits, also pull various
              upstream commits to have a solid base for future sclp related
              backports.
Reproduction: -

Upstream-Description:

              s390/sclp_early: Pass sccb pointer to every *_detect() function

              Add a sccb pointer parameter to *_detect() functions instead of accessing
              the global sccb_early variable directly.

              Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
              Reviewed-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
              Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/char/sclp_early.c |   37 ++++++++++++++++---------------------
 1 file changed, 16 insertions(+), 21 deletions(-)

--- a/drivers/s390/char/sclp_early.c
+++ b/drivers/s390/char/sclp_early.c
@@ -87,10 +87,8 @@ static int __init sclp_read_info_early(s
 	return -EIO;
 }
 
-static void __init sclp_facilities_detect(void)
+static void __init sclp_facilities_detect(struct read_info_sccb *sccb)
 {
-	struct read_info_sccb *sccb = (void *) &sccb_early;
-
 	if (sclp_read_info_early(sccb))
 		return;
 
@@ -181,11 +179,10 @@ static void __init sccb_init_eq_size(str
 	sccb->evbuf.dbs = 1;
 }
 
-static int __init sclp_set_event_mask(unsigned long receive_mask,
+static int __init sclp_set_event_mask(struct init_sccb *sccb,
+				      unsigned long receive_mask,
 				      unsigned long send_mask)
 {
-	struct init_sccb *sccb = (void *) &sccb_early;
-
 	memset(sccb, 0, sizeof(*sccb));
 	sccb->header.length = sizeof(*sccb);
 	sccb->mask_length = sizeof(sccb_mask_t);
@@ -194,10 +191,8 @@ static int __init sclp_set_event_mask(un
 	return sclp_cmd_early(SCLP_CMDW_WRITE_EVENT_MASK, sccb);
 }
 
-static long __init sclp_hsa_size_init(void)
+static long __init sclp_hsa_size_init(struct sdias_sccb *sccb)
 {
-	struct sdias_sccb *sccb = (void *) &sccb_early;
-
 	sccb_init_eq_size(sccb);
 	if (sclp_cmd_early(SCLP_CMDW_WRITE_EVENT_DATA, sccb))
 		return -EIO;
@@ -206,10 +201,8 @@ static long __init sclp_hsa_size_init(vo
 	return 0;
 }
 
-static long __init sclp_hsa_copy_wait(void)
+static long __init sclp_hsa_copy_wait(struct sccb_header *sccb)
 {
-	struct sccb_header *sccb = (void *) &sccb_early;
-
 	memset(sccb, 0, PAGE_SIZE);
 	sccb->length = PAGE_SIZE;
 	if (sclp_cmd_early(SCLP_CMDW_READ_EVENT_DATA, sccb))
@@ -222,25 +215,25 @@ unsigned long sclp_get_hsa_size(void)
 	return sclp_hsa_size;
 }
 
-static void __init sclp_hsa_size_detect(void)
+static void __init sclp_hsa_size_detect(void *sccb)
 {
 	long size;
 
 	/* First try synchronous interface (LPAR) */
-	if (sclp_set_event_mask(0, 0x40000010))
+	if (sclp_set_event_mask(sccb, 0, 0x40000010))
 		return;
-	size = sclp_hsa_size_init();
+	size = sclp_hsa_size_init(sccb);
 	if (size < 0)
 		return;
 	if (size != 0)
 		goto out;
 	/* Then try asynchronous interface (z/VM) */
-	if (sclp_set_event_mask(0x00000010, 0x40000010))
+	if (sclp_set_event_mask(sccb, 0x00000010, 0x40000010))
 		return;
-	size = sclp_hsa_size_init();
+	size = sclp_hsa_size_init(sccb);
 	if (size < 0)
 		return;
-	size = sclp_hsa_copy_wait();
+	size = sclp_hsa_copy_wait(sccb);
 	if (size < 0)
 		return;
 out:
@@ -249,7 +242,9 @@ out:
 
 void __init sclp_early_detect(void)
 {
-	sclp_facilities_detect();
-	sclp_hsa_size_detect();
-	sclp_set_event_mask(0, 0);
+	void *sccb = &sccb_early;
+
+	sclp_facilities_detect(sccb);
+	sclp_hsa_size_detect(sccb);
+	sclp_set_event_mask(sccb, 0, 0);
 }
