Subject: dasd: check count address during online setting
From: Stefan Haberland <stefan.haberland@de.ibm.com>
Patch-mainline: not yet, IBM has not submitted
References: bnc#781484,LTC#85346

Symptom:      Record not found I/O errors on z/VM minidisks formatted
              with CPFMTXA
Problem:      A common way to prepare a z/VM mini disk is to format the real
              device with a z/VM tool like CPFMTXA and then define a mini 
              disk that excludes the first cylinder, i.e. the cylinder 0 of the
              virtual disk is located at cylinder 1 of the real device.
              The DASD device driver will recognize such a mini disk as 
              formatted, as the uniform record layout on the disk matches that 
              of an LDL formatted device. However, the cylinder value in the
              'count' field of the ECKD records matches the geometry of the
              real device, and not that of the mini disk, so I/O requests will
              fail with 'record not found' errors. 
Solution:     Extend the device recognition code to check not just for proper
              record sizes, but also for proper cylinder/head/record values.
Reproduction: Format the real device with a z/VM tool like CPFMTXA and then
              define a mini disk that excludes the first cylinder, i.e. the
              cylinder 0 of the virtual disk is located at cylinder 1 of the
              real device. 
              Set the device online in Linux.
              I/O on the device will fail with record not found error.

Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/block/dasd_eckd.c |   14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

--- a/drivers/s390/block/dasd_eckd.c
+++ b/drivers/s390/block/dasd_eckd.c
@@ -141,6 +141,10 @@ dasd_eckd_set_online(struct ccw_device *
 static const int sizes_trk0[] = { 28, 148, 84 };
 #define LABEL_SIZE 140
 
+/* head and record addresses of count_area read in analysis ccw */
+static const int count_area_head[] = { 0, 0, 0, 0, 2 };
+static const int count_area_rec[] = { 1, 2, 3, 4, 1 };
+
 static inline unsigned int
 round_up_multiple(unsigned int no, unsigned int mult)
 {
@@ -1738,7 +1742,10 @@ static int dasd_eckd_end_analysis(struct
 	count_area = NULL;
 	for (i = 0; i < 3; i++) {
 		if (private->count_area[i].kl != 4 ||
-		    private->count_area[i].dl != dasd_eckd_cdl_reclen(i) - 4) {
+		    private->count_area[i].dl != dasd_eckd_cdl_reclen(i) - 4 ||
+		    private->count_area[i].cyl != 0 ||
+		    private->count_area[i].head != count_area_head[i] ||
+		    private->count_area[i].record != count_area_rec[i]) {
 			private->uses_cdl = 0;
 			break;
 		}
@@ -1750,7 +1757,10 @@ static int dasd_eckd_end_analysis(struct
 		for (i = 0; i < 5; i++) {
 			if ((private->count_area[i].kl != 0) ||
 			    (private->count_area[i].dl !=
-			     private->count_area[0].dl))
+			     private->count_area[0].dl) ||
+			    private->count_area[i].cyl !=  0 ||
+			    private->count_area[i].head != count_area_head[i] ||
+			    private->count_area[i].record != count_area_rec[i])
 				break;
 		}
 		if (i == 5)
