From: Ursula Braun <ursula.braun@de.ibm.com>
Subject: af_iucv: recvmsg problem for SOCK_STREAM sockets
Patch-mainline: v3.15-rc1
Git-commit: 2f139a5d8225666faee9f1d3c5629c4e5ff947aa
References: bnc#878407, LTC#110452

Description:  af_iucv: wrong mapping of sent and confirmed skbs
Symptom:      data corruption with af_iucv socket programs
Problem:      When sending data through IUCV a MESSAGE COMPLETE
              interrupt signals that sent data memory can be freed or
              reused again. With commit
              f9c41a62bba3f3f7ef3541b2a025e3371bcbba97 the MESSAGE
              COMPLETE callback iucv_callback_txdone() identifies the
              wrong skb as being confirmed, which leads to data
              corruption.
Solution:     fix skb mapping check in iucv_callback_txdone().
Reproduction: run 3 sendmsg calls for an AF_IUCV socket and check
              data contents on the receiver side.

Upstream-Description:

              af_iucv: recvmsg problem for SOCK_STREAM sockets

              Commit f9c41a62bba3f3f7ef3541b2a025e3371bcbba97 introduced
              a problem for SOCK_STREAM sockets, when only part of the
              incoming iucv message is received by user space. In this
              case the remaining data of the iucv message is lost.
              This patch makes sure an incompletely received iucv message
              is queued back to the receive queue.

              Signed-off-by: Ursula Braun <ursula.braun@de.ibm.com>
              Signed-off-by: Frank Blaschka <frank.blaschka@de.ibm.com>
              Reported-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
              Signed-off-by: David S. Miller <davem@davemloft.net>


Signed-off-by: Ursula Braun <ursula.braun@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 net/iucv/af_iucv.c |    1 +
 1 file changed, 1 insertion(+)

--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@ -1411,6 +1411,7 @@ static int iucv_sock_recvmsg(struct kioc
 		if (sk->sk_type == SOCK_STREAM) {
 			if (copied < rlen) {
 				IUCV_SKB_CB(skb)->offset = offset + copied;
+				skb_queue_head(&sk->sk_receive_queue, skb);
 				goto done;
 			}
 		}
