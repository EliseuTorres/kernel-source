From: Sebastian Ott <sebott@linux.vnet.ibm.com>
Subject: s390/pci: use claim_resource
Patch-mainline: v3.12-rc1
Git-commit: cb8091828757bbc9459ef59248f4a793e681f8cd
References: bnc#848335,FATE#83037,LTC#94737

Use pci_claim_resource to find and request bus ressources in
pcibios_add_device. Also move some (de)initialization stuff to
pcibios_enable_device/pcibios_disable_device.

Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/pci/pci.c |  113 ++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 84 insertions(+), 29 deletions(-)

--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -592,8 +592,6 @@ static void zpci_map_resources(struct zp
 			continue;
 		pdev->resource[i].start = (resource_size_t) pci_iomap(pdev, i, 0);
 		pdev->resource[i].end = pdev->resource[i].start + len - 1;
-		pr_debug("BAR%i: -> start: %Lx  end: %Lx\n",
-			i, pdev->resource[i].start, pdev->resource[i].end);
 	}
 }
 
@@ -625,32 +623,6 @@ void zpci_free_device(struct zpci_dev *z
 	kfree(zdev);
 }
 
-/*
- * Too late for any s390 specific setup, since interrupts must be set up
- * already which requires DMA setup too and the pci scan will access the
- * config space, which only works if the function handle is enabled.
- */
-int pcibios_enable_device(struct pci_dev *pdev, int mask)
-{
-	struct resource *res;
-	u16 cmd;
-	int i;
-
-	pci_read_config_word(pdev, PCI_COMMAND, &cmd);
-
-	for (i = 0; i < PCI_BAR_COUNT; i++) {
-		res = &pdev->resource[i];
-
-		if (res->flags & IORESOURCE_IO)
-			return -EINVAL;
-
-		if (res->flags & IORESOURCE_MEM)
-			cmd |= PCI_COMMAND_MEMORY;
-	}
-	pci_write_config_word(pdev, PCI_COMMAND, cmd);
-	return 0;
-}
-
 int pcibios_add_platform_entries(struct pci_dev *pdev)
 {
 	return zpci_sysfs_add_device(&pdev->dev);
@@ -792,19 +764,102 @@ static void zpci_free_iomap(struct zpci_
 	spin_unlock(&zpci_iomap_lock);
 }
 
+static int __pci_read_base(struct pci_dev *pdev, struct resource *res,
+			   unsigned long size, unsigned int pos)
+{
+	u32 l;
+
+	res->name = pci_name(pdev);
+	pci_read_config_dword(pdev, pos, &l);
+	l &= PCI_BASE_ADDRESS_MEM_MASK;
+
+	if (res->flags & IORESOURCE_MEM_64) {
+		u64 l64 = l;
+		pci_read_config_dword(pdev, pos + 4, &l);
+		l64 |= ((u64)l << 32);
+		res->start = l64;
+		res->end = l64 + size;
+	} else {
+		res->start = l;
+		res->end = l + size;
+	}
+
+	return (res->flags & IORESOURCE_MEM_64) ? 1 : 0;
+}
+
+static void __pci_fixup_resources(struct pci_dev *pdev)
+{
+	struct zpci_dev *zdev = get_zdev(pdev);
+	struct resource *res;
+	int i;
+
+	for (i = 0; i < PCI_BAR_COUNT; i++) {
+		res = &pdev->resource[i];
+		if (res->flags)
+			return;
+	}
+
+	for (i = 0; i < PCI_BAR_COUNT; i++) {
+		if (!zdev->bars[i].size)
+			continue;
+		res = &pdev->resource[i];
+		res->flags = IORESOURCE_MEM;
+		if (zdev->bars[i].val & 8)
+			res->flags |= IORESOURCE_PREFETCH;
+		if (zdev->bars[i].val & 4)
+			res->flags |= IORESOURCE_MEM_64;
+		i += __pci_read_base(pdev, res, (1UL << zdev->bars[i].size) - 1,
+				     PCI_BASE_ADDRESS_0 + (i << 2));
+	}
+}
+
 int pcibios_add_device(struct pci_dev *pdev)
 {
 	struct zpci_dev *zdev = get_zdev(pdev);
+	struct resource *res;
+	int i;
+
+	zdev->pdev = pdev;
+	__pci_fixup_resources(pdev);
+	zpci_map_resources(zdev);
+
+	for (i = 0; i < PCI_BAR_COUNT; i++) {
+		res = &pdev->resource[i];
+		if (res->parent || !res->flags)
+			continue;
+		pci_claim_resource(pdev, i);
+	}
+
+	return 0;
+}
+
+int pcibios_enable_device(struct pci_dev *pdev, int mask)
+{
+	struct zpci_dev *zdev = get_zdev(pdev);
+	struct resource *res;
+	u16 cmd;
+	int i;
 
 	zdev->pdev = pdev;
 	zpci_debug_init_device(zdev);
 	zpci_fmb_enable_device(zdev);
 	zpci_map_resources(zdev);
 
+	pci_read_config_word(pdev, PCI_COMMAND, &cmd);
+	for (i = 0; i < PCI_BAR_COUNT; i++) {
+		res = &pdev->resource[i];
+
+		if (res->flags & IORESOURCE_IO)
+			return -EINVAL;
+
+		if (res->flags & IORESOURCE_MEM)
+			cmd |= PCI_COMMAND_MEMORY;
+	}
+	pci_write_config_word(pdev, PCI_COMMAND, cmd);
 	return 0;
 }
 
-void pcibios_release_device(struct pci_dev *pdev)
+void pcibios_disable_device(struct pci_dev *pdev)
 {
 	struct zpci_dev *zdev = get_zdev(pdev);
 
