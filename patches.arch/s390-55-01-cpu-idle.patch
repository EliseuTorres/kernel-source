From: Heiko Carstens <heiko.carstens@de.ibm.com>
Subject: kernel: CPU idle vs CPU hotplug
Patch-mainline: yes
References: bnc#772407,LTC#83468

Symptom:      User space tools that access /proc/stat like top hang and
              can make the whole system unusable.
Problem:      The idle accounting code uses a sequence counter which gets
              used when the per cpu idle statistics are updated or read.
              One assumption on read access is that only when the sequence
              counter is even and did not change while reading all values
              the result is valid. On cpu hotplug however the per cpu data
              structure gets initialized via a cpu hotplug notifier on a
              CPU_ONLINE event.
              The CPU_ONLINE event however is too late, since the onlined
              cpu is already running and might access the per cpu data.
              Worst case is that the data structure gets initialized while
              an idle thread is updating its idle statistics. This will
              result in an uneven sequence counter after an update.
              As a result user space tools like top, which access /proc/stat
              in order to get idle statistics, will busy loop waiting for the
              sequence counter to become even again, which will never happen
              until the queried cpu will update its idle statistics again.
              And even then the sequence counter will only have an even
              value for a couple of cpu cycles.
Solution:     Move the initialization of the per cpu idle statistics to
              cpu_init().
Reproduction: Run a cpu hotplug stress test with several cpu bound processes
              while top is concurrently running in order to periodically
              read the /proc/stat file.

Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/kernel/processor.c |    2 ++
 arch/s390/kernel/smp.c       |    3 ---
 2 files changed, 2 insertions(+), 3 deletions(-)

--- a/arch/s390/kernel/processor.c
+++ b/arch/s390/kernel/processor.c
@@ -26,12 +26,14 @@ static DEFINE_PER_CPU(struct cpuid, cpu_
 void __cpuinit cpu_init(void)
 {
 	struct cpuid *id = &per_cpu(cpu_id, smp_processor_id());
+	struct s390_idle_data *idle = &__get_cpu_var(s390_idle);
 
 	get_cpu_id(id);
 	atomic_inc(&init_mm.mm_count);
 	current->active_mm = &init_mm;
 	BUG_ON(current->mm);
 	enter_lazy_tlb(&init_mm, current);
+	memset(idle, 0, sizeof(*idle));
 }
 
 /*
--- a/arch/s390/kernel/smp.c
+++ b/arch/s390/kernel/smp.c
@@ -1004,14 +1004,11 @@ static int __cpuinit smp_cpu_notify(stru
 	unsigned int cpu = (unsigned int)(long)hcpu;
 	struct cpu *c = &per_cpu(cpu_devices, cpu);
 	struct sys_device *s = &c->sysdev;
-	struct s390_idle_data *idle;
 	int err = 0;
 
 	switch (action) {
 	case CPU_ONLINE:
 	case CPU_ONLINE_FROZEN:
-		idle = &per_cpu(s390_idle, cpu);
-		memset(idle, 0, sizeof(struct s390_idle_data));
 		err = sysfs_create_group(&s->kobj, &cpu_online_attr_group);
 		break;
 	case CPU_DEAD:
