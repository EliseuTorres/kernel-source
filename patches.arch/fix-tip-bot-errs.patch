From: Mike Travis <travis@sgi.com>
Date: Tue Jan 14 10:25:53 2014 -0600
Subject: x86/uv/nmi: Fix Sparse warnings
Git-commit: 74c93f9d39b556ff9ac2340d568ad5caf8446c65
Patch-mainline: v3.14-rc1
References: bnc#888847
Signed-off-by: Tony Jones <tonyj@suse.de>

Make uv_register_nmi_notifier() and uv_handle_nmi_ping() static to
address sparse warnings.

Fix problem where uv_nmi_kexec_failed is unused when CONFIG_KEXEC
is not defined.

Signed-off-by: Mike Travis <travis@sgi.com>
Reviewed-by: Hedi Berriche <hedi@sgi.com>
---
 arch/x86/include/asm/uv/uv.h       |    2 --
 arch/x86/kernel/apic/x2apic_uv_x.c |    1 -
 arch/x86/platform/uv/uv_nmi.c      |    7 ++++---
 3 files changed, 4 insertions(+), 6 deletions(-)

--- linux-3.0.orig/arch/x86/include/asm/uv/uv.h
+++ linux-3.0/arch/x86/include/asm/uv/uv.h
@@ -12,7 +12,6 @@ extern enum uv_system_type get_uv_system
 extern int is_uv_system(void);
 extern void uv_cpu_init(void);
 extern void uv_nmi_init(void);
-extern void uv_register_nmi_notifier(void);
 extern void uv_system_init(void);
 extern const struct cpumask *uv_flush_tlb_others(const struct cpumask *cpumask,
 						 struct mm_struct *mm,
@@ -25,7 +24,6 @@ static inline enum uv_system_type get_uv
 static inline int is_uv_system(void)	{ return 0; }
 static inline void uv_cpu_init(void)	{ }
 static inline void uv_system_init(void)	{ }
-static inline void uv_register_nmi_notifier(void) { }
 static inline const struct cpumask *
 uv_flush_tlb_others(const struct cpumask *cpumask, struct mm_struct *mm,
 		    unsigned long va, unsigned int cpu)
--- linux-3.0.orig/arch/x86/kernel/apic/x2apic_uv_x.c
+++ linux-3.0/arch/x86/kernel/apic/x2apic_uv_x.c
@@ -957,7 +957,6 @@ void __init uv_system_init(void)
 	uv_nmi_setup();
 	uv_cpu_init();
 	uv_scir_register_cpu_notifier();
-	uv_register_nmi_notifier();
 	proc_mkdir("sgi_uv", NULL);
 
 	/* register Legacy VGA I/O redirection handler */
--- linux-3.0.orig/arch/x86/platform/uv/uv_nmi.c
+++ linux-3.0/arch/x86/platform/uv/uv_nmi.c
@@ -75,7 +75,6 @@ static atomic_t	uv_in_nmi;
 static atomic_t uv_nmi_cpu = ATOMIC_INIT(-1);
 static atomic_t uv_nmi_cpus_in_nmi = ATOMIC_INIT(-1);
 static atomic_t uv_nmi_slave_continue;
-static atomic_t uv_nmi_kexec_failed;
 static cpumask_var_t uv_nmi_cpu_mask;
 
 /* Values for uv_nmi_slave_continue */
@@ -505,6 +504,7 @@ static void uv_nmi_touch_watchdogs(void)
 }
 
 #if defined(CONFIG_KEXEC)
+static atomic_t uv_nmi_kexec_failed;
 static void uv_nmi_kdump(int cpu, int master, struct pt_regs *regs)
 {
 	/* Call crash to dump system state */
@@ -640,7 +640,7 @@ int uv_handle_nmi(unsigned int reason, s
 /*
  * NMI handler for pulling in CPUs when perf events are grabbing our NMI
  */
-int uv_handle_nmi_ping(unsigned int reason, struct pt_regs *regs)
+static int uv_handle_nmi_ping(unsigned int reason, struct pt_regs *regs)
 {
 	int ret;
 
@@ -678,7 +678,7 @@ static struct notifier_block uv_handle_n
 	.priority = NMI_LOCAL_LOW_PRIOR - 1,
 };
 
-void uv_register_nmi_notifier(void)
+static void uv_register_nmi_notifier(void)
 {
 	if (register_die_notifier(&uv_handle_nmi_nb))
 		pr_warn("UV NMI handler failed to register\n");
@@ -720,6 +720,7 @@ void uv_nmi_setup(void)
 	}
 	alloc_cpumask_var(&uv_nmi_cpu_mask, GFP_KERNEL);
 	BUG_ON(!uv_nmi_cpu_mask);
+	uv_register_nmi_notifier();
 }
 
 
