Subject: cio: memory leaks when checking unusable devices
References: BNC#563999
From: Gerald Schaefer <geraldsc@de.ibm.com>
Patch-mainline: 2.6.33-rc1
Git-commit: 7d253b9a1aaf5192808e641659f4feb122faa536

Symptom: The amount of free memory is reduced with each time an I/O device
             is checked that is not operational.
Problem: A reference counting problem occurs when a device does not pass
             device recognition.
Solution: Correct reference counting.
Acked-by: John Jolly <jjolly@suse.de>

---
 drivers/s390/cio/device.c |   17 +++++++++--------
 drivers/s390/cio/io_sch.h |    2 +-
 2 files changed, 10 insertions(+), 9 deletions(-)

Index: linux-sles11sp1/drivers/s390/cio/device.c
===================================================================
--- linux-sles11sp1.orig/drivers/s390/cio/device.c
+++ linux-sles11sp1/drivers/s390/cio/device.c
@@ -303,8 +303,12 @@ int ccw_device_is_orphan(struct ccw_devi
 
 static void ccw_device_unregister(struct ccw_device *cdev)
 {
-	if (test_and_clear_bit(1, &cdev->private->registered)) {
+	if (device_is_registered(&cdev->dev)) {
+		/* Undo device_add(). */
 		device_del(&cdev->dev);
+	}
+	if (cdev->private->flags.initialized) {
+		cdev->private->flags.initialized = 0;
 		/* Release reference from device_initialize(). */
 		put_device(&cdev->dev);
 	}
@@ -640,12 +644,7 @@ static int ccw_device_register(struct cc
 			   cdev->private->dev_id.devno);
 	if (ret)
 		return ret;
-	ret = device_add(dev);
-	if (ret)
-		return ret;
-
-	set_bit(1, &cdev->private->registered);
-	return ret;
+	return device_add(dev);
 }
 
 static int match_dev_id(struct device *dev, void *data)
@@ -669,7 +668,7 @@ static void ccw_device_do_unbind_bind(st
 {
 	int ret;
 
-	if (test_bit(1, &cdev->private->registered)) {
+	if (device_is_registered(&cdev->dev)) {
 		device_release_driver(&cdev->dev);
 		ret = device_attach(&cdev->dev);
 		WARN_ON(ret == -ENODEV);
@@ -721,6 +720,7 @@ static int io_subchannel_initialize_dev(
 		put_device(&cdev->dev);
 		return -ENODEV;
 	}
+	cdev->private->flags.initialized = 1;
 	return 0;
 }
 
@@ -1003,6 +1003,7 @@ static int io_subchannel_probe(struct su
 		cdev = sch_get_cdev(sch);
 		cdev->dev.groups = ccwdev_attr_groups;
 		device_initialize(&cdev->dev);
+		cdev->private->flags.initialized = 1;
 		ccw_device_register(cdev);
 		/*
 		 * Check if the device is already online. If it is
Index: linux-sles11sp1/drivers/s390/cio/io_sch.h
===================================================================
--- linux-sles11sp1.orig/drivers/s390/cio/io_sch.h
+++ linux-sles11sp1/drivers/s390/cio/io_sch.h
@@ -145,7 +145,6 @@ struct ccw_device_private {
 	struct subchannel *sch;
 	int state;		/* device state */
 	atomic_t onoff;
-	unsigned long registered;
 	struct ccw_dev_id dev_id;	/* device id */
 	struct subchannel_id schid;	/* subchannel number */
 	struct ccw_request req;		/* internal I/O request */
@@ -168,6 +167,7 @@ struct ccw_device_private {
 		unsigned int resuming:1;    /* recognition while resume */
 		unsigned int pgroup:1;	    /* pathgroup is set up */
 		unsigned int mpath:1;	    /* multipathing is set up */
+		unsigned int initialized:1; /* set if initial reference held */
 	} __attribute__((packed)) flags;
 	unsigned long intparm;	/* user interruption parameter */
 	struct qdio_irq *qdio_data;
