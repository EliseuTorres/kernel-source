Subject: cio: kernel panic after unexpected interrupt
References: BNC#563999
From: Gerald Schaefer <geraldsc@de.ibm.com>

Symptom: Unexpected kernel panic with message "kernel BUG at
             drivers/s390/cio/device_fsm.c" occurs after an I/O device entered
             not operational state.
Problem: When a device becomes temporarily not operational in a way that it
             cannot be cleanly shut down, it could later report interrupts
             which are unexpected and cause a kernel panic.
Solution: Repeat the shut down procedure when unexpected interrupts are
             received for devices which are not operational.
Acked-by: John Jolly <jjolly@suse.de>

---
 drivers/s390/cio/device_fsm.c |   25 ++++++-------------------
 1 file changed, 6 insertions(+), 19 deletions(-)

Index: linux-sles11sp1/drivers/s390/cio/device_fsm.c
===================================================================
--- linux-sles11sp1.orig/drivers/s390/cio/device_fsm.c
+++ linux-sles11sp1/drivers/s390/cio/device_fsm.c
@@ -1055,14 +1055,14 @@ void ccw_device_trigger_reprobe(struct c
 		ccw_device_start_id(cdev, 0);
 }
 
-static void
-ccw_device_offline_irq(struct ccw_device *cdev, enum dev_event dev_event)
+static void ccw_device_disabled_irq(struct ccw_device *cdev,
+				    enum dev_event dev_event)
 {
 	struct subchannel *sch;
 
 	sch = to_subchannel(cdev->dev.parent);
 	/*
-	 * An interrupt in state offline means a previous disable was not
+	 * An interrupt in a disabled state means a previous disable was not
 	 * successful - should not happen, but we try to disable again.
 	 */
 	cio_disable_subchannel(sch);
@@ -1125,25 +1125,12 @@ ccw_device_nop(struct ccw_device *cdev, 
 }
 
 /*
- * Bug operation action. 
- */
-static void
-ccw_device_bug(struct ccw_device *cdev, enum dev_event dev_event)
-{
-	CIO_MSG_EVENT(0, "Internal state [%i][%i] not handled for device "
-		      "0.%x.%04x\n", cdev->private->state, dev_event,
-		      cdev->private->dev_id.ssid,
-		      cdev->private->dev_id.devno);
-	BUG();
-}
-
-/*
  * device statemachine
  */
 fsm_func_t *dev_jumptable[NR_DEV_STATES][NR_DEV_EVENTS] = {
 	[DEV_STATE_NOT_OPER] = {
 		[DEV_EVENT_NOTOPER]	= ccw_device_nop,
-		[DEV_EVENT_INTERRUPT]	= ccw_device_bug,
+		[DEV_EVENT_INTERRUPT]	= ccw_device_disabled_irq,
 		[DEV_EVENT_TIMEOUT]	= ccw_device_nop,
 		[DEV_EVENT_VERIFY]	= ccw_device_nop,
 	},
@@ -1161,7 +1148,7 @@ fsm_func_t *dev_jumptable[NR_DEV_STATES]
 	},
 	[DEV_STATE_OFFLINE] = {
 		[DEV_EVENT_NOTOPER]	= ccw_device_generic_notoper,
-		[DEV_EVENT_INTERRUPT]	= ccw_device_offline_irq,
+		[DEV_EVENT_INTERRUPT]	= ccw_device_disabled_irq,
 		[DEV_EVENT_TIMEOUT]	= ccw_device_nop,
 		[DEV_EVENT_VERIFY]	= ccw_device_offline_verify,
 	},
@@ -1218,7 +1205,7 @@ fsm_func_t *dev_jumptable[NR_DEV_STATES]
 	[DEV_STATE_DISCONNECTED] = {
 		[DEV_EVENT_NOTOPER]	= ccw_device_nop,
 		[DEV_EVENT_INTERRUPT]	= ccw_device_start_id,
-		[DEV_EVENT_TIMEOUT]	= ccw_device_bug,
+		[DEV_EVENT_TIMEOUT]	= ccw_device_nop,
 		[DEV_EVENT_VERIFY]	= ccw_device_start_id,
 	},
 	[DEV_STATE_DISCONNECTED_SENSE_ID] = {
