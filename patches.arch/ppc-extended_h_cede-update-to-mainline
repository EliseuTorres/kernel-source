From: Gautham R Shenoy <ego@in.ibm.com>
Subject: Incremental patch set to sync H_CEDE with actual mainline
Patch-mainline: 2.6.33
References: bnc#550447, FATE#307059

Bring the preliminary H_CEDE patches in sync with the actual mainline code.

Signed-off-by: Gautham R Shenoy <ego@in.ibm.com>
Acked-by: Torsten Duwe <duwe@suse.de>
---
 Documentation/cpu-hotplug.txt                |    6 
 arch/powerpc/Kconfig                         |    4 
 arch/powerpc/include/asm/machdep.h           |    5 
 arch/powerpc/include/asm/prom.h              |   12 
 arch/powerpc/kernel/sysfs.c                  |   19 +
 arch/powerpc/mm/mem.c                        |   11 
 arch/powerpc/mm/numa.c                       |   12 
 arch/powerpc/platforms/pseries/dlpar.c       |  456 ++++++---------------------
 arch/powerpc/platforms/pseries/hotplug-cpu.c |   15 
 drivers/base/cpu.c                           |   32 +
 drivers/base/memory.c                        |    3 
 include/linux/cpu.h                          |    4 
 include/linux/memory_hotplug.h               |    2 
 13 files changed, 198 insertions(+), 383 deletions(-)

Index: linux-2.6.32-2.99.102.85049c8/arch/powerpc/include/asm/machdep.h
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/arch/powerpc/include/asm/machdep.h
+++ linux-2.6.32-2.99.102.85049c8/arch/powerpc/include/asm/machdep.h
@@ -266,6 +266,11 @@ struct machdep_calls {
 	void (*suspend_disable_irqs)(void);
 	void (*suspend_enable_irqs)(void);
 #endif
+
+#ifdef CONFIG_ARCH_CPU_PROBE_RELEASE
+	ssize_t (*cpu_probe)(const char *, size_t);
+	ssize_t (*cpu_release)(const char *, size_t);
+#endif
 };
 
 extern void e500_idle(void);
Index: linux-2.6.32-2.99.102.85049c8/arch/powerpc/include/asm/prom.h
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/arch/powerpc/include/asm/prom.h
+++ linux-2.6.32-2.99.102.85049c8/arch/powerpc/include/asm/prom.h
@@ -349,18 +349,6 @@ extern int of_irq_to_resource(struct dev
  */
 extern void __iomem *of_iomap(struct device_node *device, int index);
 
-struct of_drconf_cell {
-	u64	base_addr;
-	u32	drc_index;
-	u32	reserved;
-	u32	aa_index;
-	u32	flags;
-};
-
-#define DRCONF_MEM_ASSIGNED	0x00000008
-#define DRCONF_MEM_AI_INVALID	0x00000040
-#define DRCONF_MEM_RESERVED	0x00000080
-
 /*
  * NB:  This is here while we transition from using asm/prom.h
  * to linux/of.h
Index: linux-2.6.32-2.99.102.85049c8/arch/powerpc/Kconfig
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/arch/powerpc/Kconfig
+++ linux-2.6.32-2.99.102.85049c8/arch/powerpc/Kconfig
@@ -320,6 +320,10 @@ config HOTPLUG_CPU
 
 	  Say N if you are unsure.
 
+config ARCH_CPU_PROBE_RELEASE
+	def_bool y
+	depends on HOTPLUG_CPU
+
 config ARCH_ENABLE_MEMORY_HOTPLUG
 	def_bool y
 
Index: linux-2.6.32-2.99.102.85049c8/arch/powerpc/kernel/sysfs.c
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/arch/powerpc/kernel/sysfs.c
+++ linux-2.6.32-2.99.102.85049c8/arch/powerpc/kernel/sysfs.c
@@ -461,6 +461,25 @@ static void unregister_cpu_online(unsign
 
 	cacheinfo_cpu_offline(cpu);
 }
+
+#ifdef CONFIG_ARCH_CPU_PROBE_RELEASE
+ssize_t arch_cpu_probe(const char *buf, size_t count)
+{
+	if (ppc_md.cpu_probe)
+		return ppc_md.cpu_probe(buf, count);
+
+	return -EINVAL;
+}
+
+ssize_t arch_cpu_release(const char *buf, size_t count)
+{
+	if (ppc_md.cpu_release)
+		return ppc_md.cpu_release(buf, count);
+
+	return -EINVAL;
+}
+#endif /* CONFIG_ARCH_CPU_PROBE_RELEASE */
+
 #endif /* CONFIG_HOTPLUG_CPU */
 
 static int __cpuinit sysfs_cpu_notify(struct notifier_block *self,
Index: linux-2.6.32-2.99.102.85049c8/arch/powerpc/mm/mem.c
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/arch/powerpc/mm/mem.c
+++ linux-2.6.32-2.99.102.85049c8/arch/powerpc/mm/mem.c
@@ -111,19 +111,8 @@ EXPORT_SYMBOL(phys_mem_access_prot);
 #ifdef CONFIG_MEMORY_HOTPLUG
 
 #ifdef CONFIG_NUMA
-int __attribute ((weak)) platform_probe_memory(u64 start)
-{
-	return 0;
-}
-
 int memory_add_physaddr_to_nid(u64 start)
 {
-	int rc;
-
-	rc = platform_probe_memory(start);
-	if (rc)
-		return rc;
-
 	return hot_add_scn_to_nid(start);
 }
 #endif
Index: linux-2.6.32-2.99.102.85049c8/arch/powerpc/mm/numa.c
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/arch/powerpc/mm/numa.c
+++ linux-2.6.32-2.99.102.85049c8/arch/powerpc/mm/numa.c
@@ -296,6 +296,18 @@ static unsigned long __devinit read_n_ce
 	return result;
 }
 
+struct of_drconf_cell {
+	u64	base_addr;
+	u32	drc_index;
+	u32	reserved;
+	u32	aa_index;
+	u32	flags;
+};
+
+#define DRCONF_MEM_ASSIGNED	0x00000008
+#define DRCONF_MEM_AI_INVALID	0x00000040
+#define DRCONF_MEM_RESERVED	0x00000080
+
 /*
  * Read the next lmb list entry from the ibm,dynamic-memory property
  * and return the information in the provided of_drconf_cell structure.
Index: linux-2.6.32-2.99.102.85049c8/arch/powerpc/platforms/pseries/dlpar.c
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/arch/powerpc/platforms/pseries/dlpar.c
+++ linux-2.6.32-2.99.102.85049c8/arch/powerpc/platforms/pseries/dlpar.c
@@ -1,6 +1,6 @@
 /*
- * Support for dynamic reconfiguration (including PCI, Memory, and CPU
- * Hotplug and Dynamic Logical Partitioning on PAPR platforms).
+ * Support for dynamic reconfiguration for PCI, Memory, and CPU
+ * Hotplug and Dynamic Logical Partitioning on RPA platforms.
  *
  * Copyright (C) 2009 Nathan Fontenot
  * Copyright (C) 2009 IBM Corporation
@@ -15,9 +15,6 @@
 #include <linux/notifier.h>
 #include <linux/proc_fs.h>
 #include <linux/spinlock.h>
-#include <linux/memory_hotplug.h>
-#include <linux/sysdev.h>
-#include <linux/sysfs.h>
 #include <linux/cpu.h>
 #include "offline_states.h"
 
@@ -27,10 +24,6 @@
 #include <asm/rtas.h>
 #include <asm/pSeries_reconfig.h>
 
-#define CFG_CONN_WORK_SIZE	4096
-static char workarea[CFG_CONN_WORK_SIZE];
-static DEFINE_SPINLOCK(workarea_lock);
-
 struct cc_workarea {
 	u32	drc_index;
 	u32	zero;
@@ -39,10 +32,16 @@ struct cc_workarea {
 	u32	prop_offset;
 };
 
-static struct property *parse_cc_property(char *workarea)
+static void dlpar_free_cc_property(struct property *prop)
+{
+	kfree(prop->name);
+	kfree(prop->value);
+	kfree(prop);
+}
+
+static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)
 {
 	struct property *prop;
-	struct cc_workarea *ccwa;
 	char *name;
 	char *value;
 
@@ -50,22 +49,14 @@ static struct property *parse_cc_propert
 	if (!prop)
 		return NULL;
 
-	ccwa = (struct cc_workarea *)workarea;
-	name = workarea + ccwa->name_offset;
-	prop->name = kzalloc(strlen(name) + 1, GFP_KERNEL);
-	if (!prop->name) {
-		kfree(prop);
-		return NULL;
-	}
-
-	strcpy(prop->name, name);
+	name = (char *)ccwa + ccwa->name_offset;
+	prop->name = kstrdup(name, GFP_KERNEL);
 
 	prop->length = ccwa->prop_length;
-	value = workarea + ccwa->prop_offset;
+	value = (char *)ccwa + ccwa->prop_offset;
 	prop->value = kzalloc(prop->length, GFP_KERNEL);
 	if (!prop->value) {
-		kfree(prop->name);
-		kfree(prop);
+		dlpar_free_cc_property(prop);
 		return NULL;
 	}
 
@@ -73,58 +64,53 @@ static struct property *parse_cc_propert
 	return prop;
 }
 
-static void free_property(struct property *prop)
-{
-	kfree(prop->name);
-	kfree(prop->value);
-	kfree(prop);
-}
-
-static struct device_node *parse_cc_node(char *work_area)
+static struct device_node *dlpar_parse_cc_node(struct cc_workarea *ccwa)
 {
 	struct device_node *dn;
-	struct cc_workarea *ccwa;
 	char *name;
 
 	dn = kzalloc(sizeof(*dn), GFP_KERNEL);
 	if (!dn)
 		return NULL;
 
-	ccwa = (struct cc_workarea *)work_area;
-	name = work_area + ccwa->name_offset;
-	dn->full_name = kzalloc(strlen(name) + 1, GFP_KERNEL);
+	/* The configure connector reported name does not contain a
+	 * preceeding '/', so we allocate a buffer large enough to
+	 * prepend this to the full_name.
+	 */
+	name = (char *)ccwa + ccwa->name_offset;
+	dn->full_name = kmalloc(strlen(name) + 2, GFP_KERNEL);
 	if (!dn->full_name) {
 		kfree(dn);
 		return NULL;
 	}
 
-	strcpy(dn->full_name, name);
+	sprintf(dn->full_name, "/%s", name);
 	return dn;
 }
 
-static void free_one_cc_node(struct device_node *dn)
+static void dlpar_free_one_cc_node(struct device_node *dn)
 {
 	struct property *prop;
 
 	while (dn->properties) {
 		prop = dn->properties;
 		dn->properties = prop->next;
-		free_property(prop);
+		dlpar_free_cc_property(prop);
 	}
 
 	kfree(dn->full_name);
 	kfree(dn);
 }
 
-static void free_cc_nodes(struct device_node *dn)
+static void dlpar_free_cc_nodes(struct device_node *dn)
 {
 	if (dn->child)
-		free_cc_nodes(dn->child);
+		dlpar_free_cc_nodes(dn->child);
 
 	if (dn->sibling)
-		free_cc_nodes(dn->sibling);
+		dlpar_free_cc_nodes(dn->sibling);
 
-	free_one_cc_node(dn);
+	dlpar_free_one_cc_node(dn);
 }
 
 #define NEXT_SIBLING    1
@@ -135,7 +121,7 @@ static void free_cc_nodes(struct device_
 #define CALL_AGAIN	-2
 #define ERR_CFG_USE     -9003
 
-struct device_node *configure_connector(u32 drc_index)
+struct device_node *dlpar_configure_connector(u32 drc_index)
 {
 	struct device_node *dn;
 	struct device_node *first_dn = NULL;
@@ -150,17 +136,16 @@ struct device_node *configure_connector(
 	if (cc_token == RTAS_UNKNOWN_SERVICE)
 		return NULL;
 
-	spin_lock(&workarea_lock);
-
-	ccwa = (struct cc_workarea *)&workarea[0];
+	spin_lock(&rtas_data_buf_lock);
+	ccwa = (struct cc_workarea *)&rtas_data_buf[0];
 	ccwa->drc_index = drc_index;
 	ccwa->zero = 0;
 
-	rc = rtas_call(cc_token, 2, 1, NULL, workarea, NULL);
+	rc = rtas_call(cc_token, 2, 1, NULL, rtas_data_buf, NULL);
 	while (rc) {
 		switch (rc) {
 		case NEXT_SIBLING:
-			dn = parse_cc_node(workarea);
+			dn = dlpar_parse_cc_node(ccwa);
 			if (!dn)
 				goto cc_error;
 
@@ -170,7 +155,7 @@ struct device_node *configure_connector(
 			break;
 
 		case NEXT_CHILD:
-			dn = parse_cc_node(workarea);
+			dn = dlpar_parse_cc_node(ccwa);
 			if (!dn)
 				goto cc_error;
 
@@ -186,7 +171,7 @@ struct device_node *configure_connector(
 			break;
 
 		case NEXT_PROPERTY:
-			property = parse_cc_property(workarea);
+			property = dlpar_parse_cc_property(ccwa);
 			if (!property)
 				goto cc_error;
 
@@ -213,36 +198,43 @@ struct device_node *configure_connector(
 			goto cc_error;
 		}
 
-		rc = rtas_call(cc_token, 2, 1, NULL, workarea, NULL);
+		rc = rtas_call(cc_token, 2, 1, NULL, rtas_data_buf, NULL);
 	}
 
-	spin_unlock(&workarea_lock);
+	spin_unlock(&rtas_data_buf_lock);
 	return first_dn;
 
 cc_error:
-	spin_unlock(&workarea_lock);
-
 	if (first_dn)
-		free_cc_nodes(first_dn);
-
+		dlpar_free_cc_nodes(first_dn);
+	spin_unlock(&rtas_data_buf_lock);
 	return NULL;
 }
 
 static struct device_node *derive_parent(const char *path)
 {
 	struct device_node *parent;
-	char parent_path[128];
-	int parent_path_len;
-
-	parent_path_len = strrchr(path, '/') - path + 1;
-	strlcpy(parent_path, path, parent_path_len);
+	char *last_slash;
 
-	parent = of_find_node_by_path(parent_path);
+	last_slash = strrchr(path, '/');
+	if (last_slash == path) {
+		parent = of_find_node_by_path("/");
+	} else {
+		char *parent_path;
+		int parent_path_len = last_slash - path + 1;
+		parent_path = kmalloc(parent_path_len, GFP_KERNEL);
+		if (!parent_path)
+			return NULL;
+
+		strlcpy(parent_path, path, parent_path_len);
+		parent = of_find_node_by_path(parent_path);
+		kfree(parent_path);
+	}
 
 	return parent;
 }
 
-static int add_one_node(struct device_node *dn)
+int dlpar_attach_node(struct device_node *dn)
 {
 	struct proc_dir_entry *ent;
 	int rc;
@@ -250,6 +242,8 @@ static int add_one_node(struct device_no
 	of_node_set_flag(dn, OF_DYNAMIC);
 	kref_init(&dn->kref);
 	dn->parent = derive_parent(dn->full_name);
+	if (!dn->parent)
+		return -ENOMEM;
 
 	rc = blocking_notifier_call_chain(&pSeries_reconfig_chain,
 					  PSERIES_RECONFIG_ADD, dn);
@@ -271,33 +265,7 @@ static int add_one_node(struct device_no
 	return 0;
 }
 
-int add_device_tree_nodes(struct device_node *dn)
-{
-	struct device_node *child = dn->child;
-	struct device_node *sibling = dn->sibling;
-	int rc;
-
-	dn->child = NULL;
-	dn->sibling = NULL;
-	dn->parent = NULL;
-
-	rc = add_one_node(dn);
-	if (rc)
-		return rc;
-
-	if (child) {
-		rc = add_device_tree_nodes(child);
-		if (rc)
-			return rc;
-	}
-
-	if (sibling)
-		rc = add_device_tree_nodes(sibling);
-
-	return rc;
-}
-
-static int remove_one_node(struct device_node *dn)
+int dlpar_detach_node(struct device_node *dn)
 {
 	struct device_node *parent = dn->parent;
 	struct property *prop = dn->properties;
@@ -320,40 +288,6 @@ static int remove_one_node(struct device
 	return 0;
 }
 
-static int _remove_device_tree_nodes(struct device_node *dn)
-{
-	int rc;
-
-	if (dn->child) {
-		rc = _remove_device_tree_nodes(dn->child);
-		if (rc)
-			return rc;
-	}
-
-	if (dn->sibling) {
-		rc = _remove_device_tree_nodes(dn->sibling);
-		if (rc)
-			return rc;
-	}
-
-	rc = remove_one_node(dn);
-	return rc;
-}
-
-int remove_device_tree_nodes(struct device_node *dn)
-{
-	int rc;
-
-	if (dn->child) {
-		rc = _remove_device_tree_nodes(dn->child);
-		if (rc)
-			return rc;
-	}
-
-	rc = remove_one_node(dn);
-	return rc;
-}
-
 int online_node_cpus(struct device_node *dn)
 {
 	int rc = 0;
@@ -456,7 +390,7 @@ out:
 #define ISOLATE			0
 #define UNISOLATE		1
 
-int acquire_drc(u32 drc_index)
+int dlpar_acquire_drc(u32 drc_index)
 {
 	int dr_status, rc;
 
@@ -478,7 +412,7 @@ int acquire_drc(u32 drc_index)
 	return 0;
 }
 
-int release_drc(u32 drc_index)
+int dlpar_release_drc(u32 drc_index)
 {
 	int dr_status, rc;
 
@@ -500,7 +434,8 @@ int release_drc(u32 drc_index)
 	return 0;
 }
 
-#ifdef CONFIG_HOTPLUG_CPU
+#ifdef CONFIG_ARCH_CPU_PROBE_RELEASE
+
 static DEFINE_MUTEX(pseries_cpu_hotplug_mutex);
 
 void cpu_hotplug_driver_lock()
@@ -513,8 +448,7 @@ void cpu_hotplug_driver_unlock()
 	mutex_unlock(&pseries_cpu_hotplug_mutex);
 }
 
-static ssize_t cpu_probe_store(struct class *class, const char *buf,
-			       size_t count)
+static ssize_t dlpar_cpu_probe(const char *buf, size_t count)
 {
 	struct device_node *dn;
 	unsigned long drc_index;
@@ -523,46 +457,54 @@ static ssize_t cpu_probe_store(struct cl
 
 	cpu_hotplug_driver_lock();
 	rc = strict_strtoul(buf, 0, &drc_index);
-	if (rc)
-		goto out;
-
-	rc = acquire_drc(drc_index);
-	if (rc)
+	if (rc) {
+		rc = -EINVAL;
 		goto out;
+	}
 
-	dn = configure_connector(drc_index);
+	dn = dlpar_configure_connector(drc_index);
 	if (!dn) {
-		release_drc(drc_index);
+		rc = -EINVAL;
 		goto out;
 	}
 
-	/* fixup dn name */
-	cpu_name = kzalloc(strlen(dn->full_name) + strlen("/cpus/") + 1,
+	/* configure-connector reports cpus as living in the base
+	 * directory of the device tree.  CPUs actually live in the
+	 * cpus directory so we need to fixup the full_name.
+	 */
+	cpu_name = kzalloc(strlen(dn->full_name) + strlen("/cpus") + 1,
 			   GFP_KERNEL);
 	if (!cpu_name) {
-		free_cc_nodes(dn);
-		release_drc(drc_index);
+		dlpar_free_cc_nodes(dn);
 		rc = -ENOMEM;
 		goto out;
 	}
 
-	sprintf(cpu_name, "/cpus/%s", dn->full_name);
+	sprintf(cpu_name, "/cpus%s", dn->full_name);
 	kfree(dn->full_name);
 	dn->full_name = cpu_name;
 
-	rc = add_device_tree_nodes(dn);
-	if (rc)
-		release_drc(drc_index);
+	rc = dlpar_acquire_drc(drc_index);
+	if (rc) {
+		dlpar_free_cc_nodes(dn);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	rc = dlpar_attach_node(dn);
+	if (rc) {
+		dlpar_release_drc(drc_index);
+		dlpar_free_cc_nodes(dn);
+	}
 
 	rc = online_node_cpus(dn);
 out:
 	cpu_hotplug_driver_unlock();
 
-	return rc ? -EINVAL : count;
+	return rc ? rc : count;
 }
 
-static ssize_t cpu_release_store(struct class *class, const char *buf,
-				 size_t count)
+static ssize_t dlpar_cpu_release(const char *buf, size_t count)
 {
 	struct device_node *dn;
 	const u32 *drc_index;
@@ -580,227 +522,37 @@ static ssize_t cpu_release_store(struct 
 
 	cpu_hotplug_driver_lock();
 	rc = offline_node_cpus(dn);
-
-	if (rc)
-		goto out;
-
-	rc = release_drc(*drc_index);
 	if (rc) {
 		of_node_put(dn);
-		goto out;
-	}
-
-	rc = remove_device_tree_nodes(dn);
-	if (rc)
-		acquire_drc(*drc_index);
-
-	of_node_put(dn);
-out:
-	cpu_hotplug_driver_unlock();
-	return rc ? -EINVAL : count;
-}
-
-#endif /* CONFIG_HOTPLUG_CPU */
-
-#ifdef CONFIG_MEMORY_HOTPLUG
-
-static struct property *clone_property(struct property *old_prop)
-{
-	struct property *new_prop;
-
-	new_prop = kzalloc((sizeof *new_prop), GFP_KERNEL);
-	if (!new_prop)
-		return NULL;
-
-	new_prop->name = kstrdup(old_prop->name, GFP_KERNEL);
-	new_prop->value = kzalloc(old_prop->length + 1, GFP_KERNEL);
-	if (!new_prop->name || !new_prop->value) {
-		free_property(new_prop);
-		return NULL;
-	}
-
-	memcpy(new_prop->value, old_prop->value, old_prop->length);
-	new_prop->length = old_prop->length;
-
-	return new_prop;
-}
-
-int platform_probe_memory(u64 phys_addr)
-{
-	struct device_node *dn = NULL;
-	struct property *new_prop;
-	struct property *old_prop;
-	struct of_drconf_cell *drmem;
-	const u64 *lmb_size;
-	int num_entries, i;
-	int rc = -EINVAL;
-
-	if (!phys_addr)
-		goto memory_probe_exit;
-
-	dn = of_find_node_by_path("/ibm,dynamic-reconfiguration-memory");
-	if (!dn)
-		goto memory_probe_exit;
-
-	lmb_size = of_get_property(dn, "ibm,lmb-size", NULL);
-	if (!lmb_size)
-		goto memory_probe_exit;
-
-	old_prop = of_find_property(dn, "ibm,dynamic-memory", NULL);
-	if (!old_prop)
-		goto memory_probe_exit;
-
-	num_entries = *(u32 *)old_prop->value;
-	drmem = (struct of_drconf_cell *)
-				((char *)old_prop->value + sizeof(u32));
-
-	for (i = 0; i < num_entries; i++) {
-		u64 lmb_end_addr = drmem[i].base_addr + *lmb_size;
-		if (phys_addr >= drmem[i].base_addr
-		    && phys_addr < lmb_end_addr)
-			break;
-	}
-
-	if (i >= num_entries)
-		goto memory_probe_exit;
-
-	if (drmem[i].flags & DRCONF_MEM_ASSIGNED) {
-		/* This lmb is already adssigned to the system, nothing to do */
-		rc = 0;
-		goto memory_probe_exit;
-	}
-
-	rc = acquire_drc(drmem[i].drc_index);
-	if (rc) {
-		rc = -EINVAL;
-		goto memory_probe_exit;
-	}
-
-	new_prop = clone_property(old_prop);
-	drmem = (struct of_drconf_cell *)
-				((char *)new_prop->value + sizeof(u32));
-
-	drmem[i].flags |= DRCONF_MEM_ASSIGNED;
-	rc = prom_update_property(dn, new_prop, old_prop);
-	if (rc) {
-		free_property(new_prop);
-		rc = -EINVAL;
-		goto memory_probe_exit;
-	}
-
-	rc = blocking_notifier_call_chain(&pSeries_reconfig_chain,
-					  PSERIES_DRCONF_MEM_ADD,
-					  &drmem[i].base_addr);
-	if (rc == NOTIFY_BAD) {
-		prom_update_property(dn, old_prop, new_prop);
-		release_drc(drmem[i].drc_index);
 		rc = -EINVAL;
-	} else
-		rc = 0;
-
-memory_probe_exit:
-	of_node_put(dn);
-	return rc;
-}
-
-static ssize_t memory_release_store(struct class *class, const char *buf,
-				    size_t count)
-{
-	unsigned long drc_index;
-	struct device_node *dn;
-	struct property *new_prop, *old_prop;
-	struct of_drconf_cell *drmem;
-	int num_entries;
-	int i;
-	int rc = -EINVAL;
-
-	rc = strict_strtoul(buf, 0, &drc_index);
-	if (rc)
-		return rc;
-
-	dn = of_find_node_by_path("/ibm,dynamic-reconfiguration-memory");
-	if (!dn)
-		return rc;
-
-	old_prop = of_find_property(dn, "ibm,dynamic-memory", NULL);
-	if (!old_prop)
-		goto memory_release_exit;
-
-	num_entries = *(u32 *)old_prop->value;
-	drmem = (struct of_drconf_cell *)
-				((char *)old_prop->value + sizeof(u32));
-
-	for (i = 0; i < num_entries; i++) {
-		if (drmem[i].drc_index == drc_index)
-			break;
+		goto out;
 	}
 
-	if (i >= num_entries)
-		goto memory_release_exit;
-
-	new_prop = clone_property(old_prop);
-	drmem = (struct of_drconf_cell *)
-				((char *)new_prop->value + sizeof(u32));
-
-	drmem[i].flags &= ~DRCONF_MEM_ASSIGNED;
-	rc = prom_update_property(dn, new_prop, old_prop);
+	rc = dlpar_release_drc(*drc_index);
 	if (rc) {
-		free_property(new_prop);
-		rc = -EINVAL;
-		goto memory_release_exit;
+		of_node_put(dn);
+		goto out;
 	}
 
-	rc = blocking_notifier_call_chain(&pSeries_reconfig_chain,
-					  PSERIES_DRCONF_MEM_REMOVE,
-					  &drmem[i].base_addr);
-	if (rc != NOTIFY_BAD)
-		rc = release_drc(drc_index);
-
+	rc = dlpar_detach_node(dn);
 	if (rc) {
-		prom_update_property(dn, old_prop, new_prop);
-		rc = -EINVAL;
+		dlpar_acquire_drc(*drc_index);
+		goto out;
 	}
 
-memory_release_exit:
 	of_node_put(dn);
+out:
+	cpu_hotplug_driver_unlock();
 	return rc ? rc : count;
 }
 
-static struct class_attribute class_attr_mem_release =
-			__ATTR(release, S_IWUSR, NULL, memory_release_store);
-#endif /* CONFIG_MEMORY_HOTPLUG */
-
-#ifdef CONFIG_HOTPLUG_CPU
-static struct class_attribute class_attr_cpu_probe =
-			__ATTR(probe, S_IWUSR, NULL, cpu_probe_store);
-static struct class_attribute class_attr_cpu_release =
-			__ATTR(release, S_IWUSR, NULL, cpu_release_store);
-#endif
-
-static int pseries_dlpar_init(void)
+static int __init pseries_dlpar_init(void)
 {
-	if (!machine_is(pseries))
-		return 0;
-
-#ifdef CONFIG_MEMORY_HOTPLUG
-	if (sysfs_create_file(&memory_sysdev_class.kset.kobj,
-			      &class_attr_mem_release.attr))
-		printk(KERN_INFO "DLPAR: Could not create sysfs memory "
-		       "release file\n");
-#endif
-
-#ifdef CONFIG_HOTPLUG_CPU
-	if (sysfs_create_file(&cpu_sysdev_class.kset.kobj,
-			      &class_attr_cpu_probe.attr))
-		printk(KERN_INFO "DLPAR: Could not create sysfs cpu "
-		       "probe file\n");
-
-	if (sysfs_create_file(&cpu_sysdev_class.kset.kobj,
-			      &class_attr_cpu_release.attr))
-		printk(KERN_INFO "DLPAR: Could not create sysfs cpu "
-		       "release file\n");
-#endif
+	ppc_md.cpu_probe = dlpar_cpu_probe;
+	ppc_md.cpu_release = dlpar_cpu_release;
 
 	return 0;
 }
-device_initcall(pseries_dlpar_init);
+machine_device_initcall(pseries, pseries_dlpar_init);
+
+#endif /* CONFIG_ARCH_CPU_PROBE_RELEASE */
Index: linux-2.6.32-2.99.102.85049c8/arch/powerpc/platforms/pseries/hotplug-cpu.c
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/arch/powerpc/platforms/pseries/hotplug-cpu.c
+++ linux-2.6.32-2.99.102.85049c8/arch/powerpc/platforms/pseries/hotplug-cpu.c
@@ -152,7 +152,6 @@ static void pseries_mach_cpu_die(void)
 		 * stack pointer.
 		 */
 		start_secondary();
-		goto out_bug;
 
 	} else if (get_preferred_offline_state(cpu) == CPU_STATE_OFFLINE) {
 
@@ -160,10 +159,8 @@ static void pseries_mach_cpu_die(void)
 		unregister_slb_shadow(hard_smp_processor_id(),
 					__pa(get_slb_shadow()));
 		rtas_stop_self();
-		goto out_bug;
 	}
 
-out_bug:
 	/* Should never get here... */
 	BUG();
 	for(;;);
@@ -209,6 +206,18 @@ static int pseries_cpu_disable(void)
 	return 0;
 }
 
+/*
+ * pseries_cpu_die: Wait for the cpu to die.
+ * @cpu: logical processor id of the CPU whose death we're awaiting.
+ *
+ * This function is called from the context of the thread which is performing
+ * the cpu-offline. Here we wait for long enough to allow the cpu in question
+ * to self-destroy so that the cpu-offline thread can send the CPU_DEAD
+ * notifications.
+ *
+ * OTOH, pseries_mach_cpu_die() is called by the @cpu when it wants to
+ * self-destruct.
+ */
 static void pseries_cpu_die(unsigned int cpu)
 {
 	int tries;
Index: linux-2.6.32-2.99.102.85049c8/Documentation/cpu-hotplug.txt
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/Documentation/cpu-hotplug.txt
+++ linux-2.6.32-2.99.102.85049c8/Documentation/cpu-hotplug.txt
@@ -49,6 +49,12 @@ maxcpus=n    Restrict boot time cpus to 
 additional_cpus=n (*)	Use this to limit hotpluggable cpus. This option sets
   			cpu_possible_map = cpu_present_map + additional_cpus
 
+cede_offline={"off","on"}  Use this option to disable/enable putting offlined
+		            processors to an extended H_CEDE state on
+			    supported pseries platforms.
+			    If nothing is specified,
+			    cede_offline is set to "on".
+
 (*) Option valid only for following architectures
 - ia64
 
Index: linux-2.6.32-2.99.102.85049c8/drivers/base/cpu.c
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/drivers/base/cpu.c
+++ linux-2.6.32-2.99.102.85049c8/drivers/base/cpu.c
@@ -74,6 +74,38 @@ void unregister_cpu(struct cpu *cpu)
 	per_cpu(cpu_sys_devices, logical_cpu) = NULL;
 	return;
 }
+
+#ifdef CONFIG_ARCH_CPU_PROBE_RELEASE
+static ssize_t cpu_probe_store(struct class *class, const char *buf,
+			       size_t count)
+{
+	return arch_cpu_probe(buf, count);
+}
+
+static ssize_t cpu_release_store(struct class *class, const char *buf,
+				 size_t count)
+{
+	return arch_cpu_release(buf, count);
+}
+
+static CLASS_ATTR(probe, S_IWUSR, NULL, cpu_probe_store);
+static CLASS_ATTR(release, S_IWUSR, NULL, cpu_release_store);
+
+int __init cpu_probe_release_init(void)
+{
+	int rc;
+
+	rc = sysfs_create_file(&cpu_sysdev_class.kset.kobj,
+			       &class_attr_probe.attr);
+	if (!rc)
+		rc = sysfs_create_file(&cpu_sysdev_class.kset.kobj,
+				       &class_attr_release.attr);
+
+	return rc;
+}
+device_initcall(cpu_probe_release_init);
+#endif /* CONFIG_ARCH_CPU_PROBE_RELEASE */
+
 #else /* ... !CONFIG_HOTPLUG_CPU */
 static inline void register_cpu_control(struct cpu *cpu)
 {
Index: linux-2.6.32-2.99.102.85049c8/drivers/base/memory.c
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/drivers/base/memory.c
+++ linux-2.6.32-2.99.102.85049c8/drivers/base/memory.c
@@ -28,10 +28,9 @@
 
 #define MEMORY_CLASS_NAME	"memory"
 
-struct sysdev_class memory_sysdev_class = {
+static struct sysdev_class memory_sysdev_class = {
 	.name = MEMORY_CLASS_NAME,
 };
-EXPORT_SYMBOL_GPL(memory_sysdev_class);
 
 static const char *memory_uevent_name(struct kset *kset, struct kobject *kobj)
 {
Index: linux-2.6.32-2.99.102.85049c8/include/linux/cpu.h
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/include/linux/cpu.h
+++ linux-2.6.32-2.99.102.85049c8/include/linux/cpu.h
@@ -43,6 +43,8 @@ extern int sched_create_sysfs_power_savi
 
 #ifdef CONFIG_HOTPLUG_CPU
 extern void unregister_cpu(struct cpu *cpu);
+extern ssize_t arch_cpu_probe(const char *, size_t);
+extern ssize_t arch_cpu_release(const char *, size_t);
 #endif
 struct notifier_block;
 
@@ -115,7 +117,7 @@ extern void put_online_cpus(void);
 #define unregister_hotcpu_notifier(nb)	unregister_cpu_notifier(nb)
 int cpu_down(unsigned int cpu);
 
-#ifdef CONFIG_PPC_PSERIES
+#ifdef CONFIG_ARCH_CPU_PROBE_RELEASE
 extern void cpu_hotplug_driver_lock(void);
 extern void cpu_hotplug_driver_unlock(void);
 #else
Index: linux-2.6.32-2.99.102.85049c8/include/linux/memory_hotplug.h
===================================================================
--- linux-2.6.32-2.99.102.85049c8.orig/include/linux/memory_hotplug.h
+++ linux-2.6.32-2.99.102.85049c8/include/linux/memory_hotplug.h
@@ -12,8 +12,6 @@ struct mem_section;
 
 #ifdef CONFIG_MEMORY_HOTPLUG
 
-extern struct sysdev_class memory_sysdev_class;
-
 /*
  * Types for free bootmem.
  * The normal smallest mapcount is -1. Here is smaller value than it.
