From: Rafael J. Wysocki <rjw@suse.de>
Subject: x86 / UV: Early boot bitmap fix
Patch-mainline: No
References: bnc#657248

There is a problem on partitioned systems where the lowest nasid in the
partition will have a huge gap between the 0-2GB memory and higher physical
memory (based on nasid ID).  If the gap is big enough, as it is on large
partitioned systems, the early boot bitmap code will hit a sign extend problem
in test_and_clear_bit().

The community has totally rewritten the bootmem code for x86_64, so this
problem no longer exists upstream.

Originally-from: Russ Anderson <rja@sgi.com>
Signed-off-by: Rafael J. Wysocki <rjw@suse.de>
---
 arch/x86/include/asm/bitops.h |   18 ++++++++++++++++++
 include/linux/bootmem.h       |    5 +++++
 mm/bootmem.c                  |    2 +-
 3 files changed, 24 insertions(+), 1 deletion(-)

Index: linux-2.6.32-SLE11-SP1/mm/bootmem.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/mm/bootmem.c
+++ linux-2.6.32-SLE11-SP1/mm/bootmem.c
@@ -239,7 +239,7 @@ static void __init __free(bootmem_data_t
 		bdata->hint_idx = sidx;
 
 	for (idx = sidx; idx < eidx; idx++)
-		if (!test_and_clear_bit(idx, bdata->node_bootmem_map))
+		if (!bootmem_test_and_clear_bit(idx, bdata->node_bootmem_map))
 			BUG();
 }
 
Index: linux-2.6.32-SLE11-SP1/arch/x86/include/asm/bitops.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/include/asm/bitops.h
+++ linux-2.6.32-SLE11-SP1/arch/x86/include/asm/bitops.h
@@ -306,6 +306,24 @@ static inline int test_and_change_bit(in
 	return oldbit;
 }
 
+#define INT_MAX ((int)(~0U>>1))
+#define INT_MAX_PLUS_1 ((long)INT_MAX + 1UL)
+
+static inline int test_and_clear_bit_long(unsigned long nr, volatile unsigned long *addr)
+{
+        unsigned long oldbit;
+
+	if (unlikely(nr >= INT_MAX_PLUS_1)) {
+		addr += (nr / INT_MAX_PLUS_1) * (INT_MAX_PLUS_1 / BITS_PER_LONG);
+		nr &= INT_MAX;
+	}
+	asm volatile(LOCK_PREFIX "btr %2,%1\n\t"
+		     "sbb %0,%0"
+		     : "=r" (oldbit), ADDR : "Ir" (nr) : "memory");
+
+	return oldbit;
+}
+
 static __always_inline int constant_test_bit(unsigned int nr, const volatile unsigned long *addr)
 {
 	return ((1UL << (nr % BITS_PER_LONG)) &
Index: linux-2.6.32-SLE11-SP1/include/linux/bootmem.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/bootmem.h
+++ linux-2.6.32-SLE11-SP1/include/linux/bootmem.h
@@ -155,5 +155,10 @@ extern void *alloc_large_system_hash(con
 #endif
 extern int hashdist;		/* Distribute hashes across NUMA nodes? */
 
+#ifdef CONFIG_X86_64
+#define bootmem_test_and_clear_bit test_and_clear_bit_long
+#else
+#define bootmem_test_and_clear_bit test_and_clear_bit
+#endif
 
 #endif /* _LINUX_BOOTMEM_H */
