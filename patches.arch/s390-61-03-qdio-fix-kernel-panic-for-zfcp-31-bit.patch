Subject: qdio: fix kernel panic for zfcp 31-bit
From: Steffen Maier <maier@linux.vnet.ibm.com>
Patch-mainline: v3.3-rc1
Commit-id: e58b0d902f7c7c407bae9c8bc8d90fa1d06184c5
References: bnc#789010,LTC#86623

Symptom:      Kernel page fault in setup_queues()
              or tiqdio_call_inq_handlers() with zfcp.
Problem:      The queue_start_poll function pointer field in struct
              qdio_initialize had to change its type and become a
              vector of function pointers in commit
              104ea556ee7f40039c9c635d0c267b1fde084a81
              "qdio: support asynchronous delivery of storage blocks".
              Setup_queues() unconditionally dereferenced elements of
              the vector even if no vector is used as with zfcp.
Solution:     Rename the field to make the type change explicit and
              ensure no other user of qdio tries to use the field the
              old way. During setting up the qdio queues, only
              dereference vector elements if the vector is actually
              allocated.
Reproduction: Set an FCP device online with a kernel including code of
              above-mentioned commit.
              The page fault typically only occurs on 31 bit s390 kernels.
              Dereferencing at address 0 is always possible because the
              lowcore is readable and with 64 bit s390x kernels
              the dereferenced value happens to be 0 so the page fault
              does not happen to occur.

Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/qdio.h      |    5 +++--
 drivers/s390/cio/qdio_setup.c     |    3 ++-
 drivers/s390/net/qeth_core_main.c |    2 +-
 3 files changed, 6 insertions(+), 4 deletions(-)

--- a/arch/s390/include/asm/qdio.h
+++ b/arch/s390/include/asm/qdio.h
@@ -348,7 +348,7 @@ typedef void qdio_handler_t(struct ccw_d
  * @no_output_qs: number of output queues
  * @input_handler: handler to be called for input queues
  * @output_handler: handler to be called for output queues
- * @queue_start_poll: polling handlers (one per input queue or NULL)
+ * @queue_start_poll_array: polling handlers (one per input queue or NULL)
  * @int_parm: interruption parameter
  * @input_sbal_addr_array:  address of no_input_qs * 128 pointers
  * @output_sbal_addr_array: address of no_output_qs * 128 pointers
@@ -367,7 +367,8 @@ struct qdio_initialize {
 	unsigned int no_output_qs;
 	qdio_handler_t *input_handler;
 	qdio_handler_t *output_handler;
-	void (**queue_start_poll) (struct ccw_device *, int, unsigned long);
+	void (**queue_start_poll_array) (struct ccw_device *, int,
+					  unsigned long);
 	int scan_threshold;
 	unsigned long int_parm;
 	void **input_sbal_addr_array;
--- a/drivers/s390/cio/qdio_setup.c
+++ b/drivers/s390/cio/qdio_setup.c
@@ -179,7 +179,8 @@ static void setup_queues(struct qdio_irq
 		setup_queues_misc(q, irq_ptr, qdio_init->input_handler, i);
 
 		q->is_input_q = 1;
-		q->u.in.queue_start_poll = qdio_init->queue_start_poll[i];
+		q->u.in.queue_start_poll = qdio_init->queue_start_poll_array ?
+				qdio_init->queue_start_poll_array[i] : NULL;
 
 		setup_storage_lists(q, irq_ptr, input_sbal_array, i);
 		input_sbal_array += QDIO_MAX_BUFFERS_PER_Q;
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -4576,7 +4576,7 @@ static int qeth_qdio_establish(struct qe
 	init_data.no_output_qs           = card->qdio.no_out_queues;
 	init_data.input_handler          = card->discipline.input_handler;
 	init_data.output_handler         = card->discipline.output_handler;
-	init_data.queue_start_poll	 = queue_start_poll;
+	init_data.queue_start_poll_array = queue_start_poll;
 	init_data.int_parm               = (unsigned long) card;
 	init_data.input_sbal_addr_array  = (void **) in_sbal_ptrs;
 	init_data.output_sbal_addr_array = (void **) out_sbal_ptrs;
