From: Stefan Haberland <stefan.haberland@de.ibm.com>
Subject: dasd: Fix resume path verification.
Patch-mainline: v3.2-rc1
Git-commit: c8d1c0ff840bbf06c60ff4235202a4b1457d8f59
References: bnc#791717,FATE#314091

Description:  dasd: Fix resume path verification.
Symptom:      Some paths may not be verified correctly and are not usable
              by the dasd device driver.
Problem:      The resume callback and the path verification worker may 
              interrupt each other.
Solution:     Mark the device as suspended and delay execution of the path
              verification worker to prevent mix-up.
Reproduction: Do suspend/resume.

Signed-off-by: Stefan Haberland <stefan.haberland@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/block/dasd.c      |    4 ++++
 drivers/s390/block/dasd_eckd.c |   14 ++++++++++++--
 drivers/s390/block/dasd_int.h  |    1 +
 3 files changed, 17 insertions(+), 2 deletions(-)

--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -3404,6 +3404,9 @@ int dasd_generic_pm_freeze(struct ccw_de
 	if (IS_ERR(device))
 		return PTR_ERR(device);
 
+	/* mark device as suspended */
+	set_bit(DASD_FLAG_SUSPENDED, &device->flags);
+
 	if (device->discipline->freeze)
 		rc = device->discipline->freeze(device);
 
@@ -3478,6 +3481,7 @@ int dasd_generic_restore_device(struct c
 	if (device->block)
 		dasd_schedule_block_bh(device->block);
 
+	clear_bit(DASD_FLAG_SUSPENDED, &device->flags);
 	dasd_put_device(device);
 	return 0;
 }
--- a/drivers/s390/block/dasd_eckd.c
+++ b/drivers/s390/block/dasd_eckd.c
@@ -1238,6 +1238,12 @@ static void do_path_verification_work(st
 	data = container_of(work, struct path_verification_work_data, worker);
 	device = data->device;
 
+	/* delay path verification until device was resumed */
+	if (test_bit(DASD_FLAG_SUSPENDED, &device->flags)) {
+		schedule_work(work);
+		return;
+	}
+
 	opm = 0;
 	npm = 0;
 	ppm = 0;
@@ -2287,10 +2293,14 @@ static void dasd_eckd_check_for_device_c
 	/* first of all check for state change pending interrupt */
 	mask = DEV_STAT_ATTENTION | DEV_STAT_DEV_END | DEV_STAT_UNIT_EXCEP;
 	if ((scsw_dstat(&irb->scsw) & mask) == mask) {
-		/* for alias only and not in offline processing*/
+		/*
+		 * for alias only, not in offline processing
+		 * and only if not suspended
+		 */
 		if (!device->block && private->lcu &&
 		    device->state == DASD_STATE_ONLINE &&
-		    !test_bit(DASD_FLAG_OFFLINE, &device->flags)) {
+		    !test_bit(DASD_FLAG_OFFLINE, &device->flags) &&
+ 		    !test_bit(DASD_FLAG_SUSPENDED, &device->flags)) {
 			/*
 			 * the state change could be caused by an alias
 			 * reassignment remove device from alias handling
--- a/drivers/s390/block/dasd_int.h
+++ b/drivers/s390/block/dasd_int.h
@@ -523,6 +523,7 @@ struct dasd_block {
 					 */
 #define DASD_FLAG_IS_RESERVED	7	/* The device is reserved */
 #define DASD_FLAG_LOCK_STOLEN	8	/* The device lock was stolen */
+#define DASD_FLAG_SUSPENDED	9	/* The device was suspended */
 #define DASD_FLAG_TIMEOUT	12	/* Timeout, abort noretry requests */
 
 
