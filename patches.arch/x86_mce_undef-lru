From: Andi Kleen <ak@linux.intel.com>
Subject: HWPOISON: Undefine short-hand macros after use to avoid namespace conflict
Patch-Mainline: not yet, in the queue of maintainer for 2.6.33
References: fate#307738

Signed-off-by: Thomas Renninger <trenn@suse.de>
Signed-off-by: Andi Kleen <ak@linux.intel.com>

---
 mm/memory-failure.c |   17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

Index: linux-2.6.32/mm/memory-failure.c
===================================================================
--- linux-2.6.32.orig/mm/memory-failure.c
+++ linux-2.6.32/mm/memory-failure.c
@@ -597,6 +597,19 @@ static struct page_state {
 	{ 0,		0,		"unknown page state",	me_unknown },
 };
 
+#undef dirty
+#undef sc
+#undef unevict
+#undef mlock
+#undef writeback
+#undef lru
+#undef swapbacked
+#undef head
+#undef tail
+#undef compound
+#undef slab
+#undef reserved
+
 static void action_result(unsigned long pfn, char *msg, int result)
 {
 	struct page *page = NULL;
@@ -769,7 +782,7 @@ int __memory_failure(unsigned long pfn,
 	 */
 	if (!PageLRU(p))
 		lru_add_drain_all();
-	lru_flag = p->flags & lru;
+	lru_flag = p->flags & (1UL << PG_lru);
 	if (isolate_lru_page(p)) {
 		action_result(pfn, "non LRU", IGNORED);
 		put_page(p);
@@ -793,7 +806,7 @@ int __memory_failure(unsigned long pfn,
 	/*
 	 * Torn down by someone else?
 	 */
-	if ((lru_flag & lru) && !PageSwapCache(p) && p->mapping == NULL) {
+	if ((lru_flag & (1UL << PG_lru)) && !PageSwapCache(p) && p->mapping == NULL) {
 		action_result(pfn, "already truncated LRU", IGNORED);
 		res = 0;
 		goto out;
