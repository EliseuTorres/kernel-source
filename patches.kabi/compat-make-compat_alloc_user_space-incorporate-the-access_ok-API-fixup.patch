From: Jiri Kosina <jkosina@suse.cz>
Subject: compat-make-compat_alloc_user_space-incorporate-the-access_ok - API fixup
References: CVE-2010-3081 bnc#639709
Patch-mainline: never

Fix for CVE-2010-3081
(compat-make-compat_alloc_user_space-incorporate-the-access_ok, later merged
through -stable update) changes kernel API -- it makes
compat_alloc_user_space() EXPORT_SYMBOL_GPL() instead of static inline.

This is a problem for enterprise kernels, as it imposes regression (external
KMPs which were building just fine before are now failing to build), as
the API has been (unnecessarily) restricted altogether with the fix.

We fix this by moving the interface back into inline form and duplicate
the checks in all arch-specific functions. We also keep the new
EXPORT_SYMBOL_GPL() implementation in place, so that module which have
been built in the meantime to use it, keep working.

Relaxing EXPORT_SYMBOL_GPL() into EXPORT_SYMBOL() is not an option.

Signed-off-by: Jiri Kosina <jkosina@suse.cz>

Index: linux-2.6.32-SLE11-SP1/arch/ia64/include/asm/compat.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/ia64/include/asm/compat.h
+++ linux-2.6.32-SLE11-SP1/arch/ia64/include/asm/compat.h
@@ -4,6 +4,7 @@
  * Architecture specific compatibility types
  */
 #include <linux/types.h>
+#include <asm/uaccess.h>
 
 #define COMPAT_USER_HZ	100
 
@@ -201,7 +202,20 @@ static __inline__ void __user *
 arch_compat_alloc_user_space (long len)
 {
 	struct pt_regs *regs = task_pt_regs(current);
-	return (void __user *) (((regs->r12 & 0xffffffff) & -16) - len);
+	void __user *ptr;
+
+	/* If len would occupy more than half of the entire compat space... */
+	if (unlikely(len > (((compat_uptr_t)~0) >> 1)))
+		return NULL;
+
+	ptr = (void __user *) (((regs->r12 & 0xffffffff) & -16) - len);
+
+	if (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))
+		return NULL;
+
+	return ptr;
 }
 
+#define compat_alloc_user_space arch_compat_alloc_user_space
+
 #endif /* _ASM_IA64_COMPAT_H */
Index: linux-2.6.32-SLE11-SP1/arch/mips/include/asm/compat.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/mips/include/asm/compat.h
+++ linux-2.6.32-SLE11-SP1/arch/mips/include/asm/compat.h
@@ -7,6 +7,7 @@
 #include <linux/types.h>
 #include <asm/page.h>
 #include <asm/ptrace.h>
+#include <asm/uaccess.h>
 
 #define COMPAT_USER_HZ	100
 
@@ -148,10 +149,23 @@ static inline void __user *arch_compat_a
 {
 	struct pt_regs *regs = (struct pt_regs *)
 		((unsigned long) current_thread_info() + THREAD_SIZE - 32) - 1;
+	void __user *ptr;
+
+	/* If len would occupy more than half of the entire compat space... */
+	if (unlikely(len > (((compat_uptr_t)~0) >> 1)))
+		return NULL;
+
+	ptr = (void __user *) (regs->regs[29] - len);
+
+	if (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))
+		return NULL;
+
+	return ptr;
 
-	return (void __user *) (regs->regs[29] - len);
 }
 
+#define compat_alloc_user_space arch_compat_alloc_user_space
+
 struct compat_ipc64_perm {
 	compat_key_t key;
 	__compat_uid32_t uid;
Index: linux-2.6.32-SLE11-SP1/arch/parisc/include/asm/compat.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/parisc/include/asm/compat.h
+++ linux-2.6.32-SLE11-SP1/arch/parisc/include/asm/compat.h
@@ -6,6 +6,7 @@
 #include <linux/types.h>
 #include <linux/sched.h>
 #include <linux/thread_info.h>
+#include <asm/uaccess.h>
 
 #define COMPAT_USER_HZ 100
 
@@ -149,9 +150,21 @@ static inline compat_uptr_t ptr_to_compa
 static __inline__ void __user *arch_compat_alloc_user_space(long len)
 {
 	struct pt_regs *regs = &current->thread.regs;
-	return (void __user *)regs->gr[30];
+	void __user *ptr;
+
+	/* If len would occupy more than half of the entire compat space... */
+	if (unlikely(len > (((compat_uptr_t)~0) >> 1)))
+		return NULL;
+
+	ptr = (void __user *)regs->gr[30];
+	if (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))
+		return NULL;
+
+	return ptr;
 }
 
+#define compat_alloc_user_space arch_compat_alloc_user_space
+
 static inline int __is_compat_task(struct task_struct *t)
 {
 	return test_ti_thread_flag(task_thread_info(t), TIF_32BIT);
Index: linux-2.6.32-SLE11-SP1/arch/powerpc/include/asm/compat.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/powerpc/include/asm/compat.h
+++ linux-2.6.32-SLE11-SP1/arch/powerpc/include/asm/compat.h
@@ -6,6 +6,7 @@
  */
 #include <linux/types.h>
 #include <linux/sched.h>
+#include <asm/uaccess.h>
 
 #define COMPAT_USER_HZ	100
 
@@ -137,6 +138,11 @@ static inline void __user *arch_compat_a
 {
 	struct pt_regs *regs = current->thread.regs;
 	unsigned long usp = regs->gpr[1];
+	void __user *ptr;
+
+	/* If len would occupy more than half of the entire compat space... */
+	if (unlikely(len > (((compat_uptr_t)~0) >> 1)))
+		return NULL;
 
 	/*
 	 * We cant access below the stack pointer in the 32bit ABI and
@@ -145,9 +151,17 @@ static inline void __user *arch_compat_a
 	if (!(test_thread_flag(TIF_32BIT)))
 		usp -= 288;
 
-	return (void __user *) (usp - len);
+	ptr = (void __user *) (usp - len);
+
+	if (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))
+		return NULL;
+
+	return ptr;
+
 }
 
+#define compat_alloc_user_space arch_compat_alloc_user_space
+
 /*
  * ipc64_perm is actually 32/64bit clean but since the compat layer refers to
  * it we may as well define it.
Index: linux-2.6.32-SLE11-SP1/arch/s390/include/asm/compat.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/s390/include/asm/compat.h
+++ linux-2.6.32-SLE11-SP1/arch/s390/include/asm/compat.h
@@ -6,6 +6,7 @@
 #include <linux/types.h>
 #include <linux/sched.h>
 #include <linux/thread_info.h>
+#include <asm/uaccess.h>
 
 #define PSW32_MASK_PER		0x40000000UL
 #define PSW32_MASK_DAT		0x04000000UL
@@ -183,13 +184,25 @@ static inline int is_compat_task(void)
 static inline void __user *arch_compat_alloc_user_space(long len)
 {
 	unsigned long stack;
+	void __user *ptr;
+
+	/* If len would occupy more than half of the entire compat space... */
+	if (unlikely(len > (((compat_uptr_t)~0) >> 1)))
+		return NULL;
 
 	stack = KSTK_ESP(current);
 	if (is_compat_task())
 		stack &= 0x7fffffffUL;
-	return (void __user *) (stack - len);
+	ptr = (void __user *) (stack - len);
+
+	if (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))
+		return NULL;
+
+	return ptr;
 }
 
+#define compat_alloc_user_space arch_compat_alloc_user_space
+
 struct compat_ipc64_perm {
 	compat_key_t key;
 	__compat_uid32_t uid;
Index: linux-2.6.32-SLE11-SP1/arch/sparc/include/asm/compat.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/sparc/include/asm/compat.h
+++ linux-2.6.32-SLE11-SP1/arch/sparc/include/asm/compat.h
@@ -4,6 +4,7 @@
  * Architecture specific compatibility types
  */
 #include <linux/types.h>
+#include <asm/uaccess.h>
 
 #define COMPAT_USER_HZ	100
 
@@ -170,6 +171,11 @@ static inline void __user *arch_compat_a
 {
 	struct pt_regs *regs = current_thread_info()->kregs;
 	unsigned long usp = regs->u_regs[UREG_I6];
+	void __user *ptr;
+
+	/* If len would occupy more than half of the entire compat space... */
+	if (unlikely(len > (((compat_uptr_t)~0) >> 1)))
+		return NULL;
 
 	if (!(test_thread_flag(TIF_32BIT)))
 		usp += STACK_BIAS;
@@ -179,9 +185,16 @@ static inline void __user *arch_compat_a
 	usp -= len;
 	usp &= ~0x7UL;
 
-	return (void __user *) usp;
+	ptr = (void __user *) usp;
+
+	if (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))
+		return NULL;
+
+	return ptr;
 }
 
+#define compat_alloc_user_space arch_compat_alloc_user_space
+
 struct compat_ipc64_perm {
 	compat_key_t key;
 	__compat_uid32_t uid;
Index: linux-2.6.32-SLE11-SP1/kernel/compat.c
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/kernel/compat.c
+++ linux-2.6.32-SLE11-SP1/kernel/compat.c
@@ -1138,6 +1138,7 @@ compat_sys_sysinfo(struct compat_sysinfo
 	return 0;
 }
 
+#undef compat_alloc_user_space
 /*
  * Allocate user-space memory for the duration of a single system call,
  * in order to marshall parameters inside a compat thunk.
Index: linux-2.6.32-SLE11-SP1/arch/x86/include/asm/compat.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/arch/x86/include/asm/compat.h
+++ linux-2.6.32-SLE11-SP1/arch/x86/include/asm/compat.h
@@ -7,6 +7,7 @@
 #include <linux/types.h>
 #include <linux/sched.h>
 #include <asm/user32.h>
+#include <asm/uaccess.h>
 
 #define COMPAT_USER_HZ	100
 
@@ -207,9 +208,22 @@ static inline compat_uptr_t ptr_to_compa
 static inline void __user *arch_compat_alloc_user_space(long len)
 {
 	struct pt_regs *regs = task_pt_regs(current);
-	return (void __user *)regs->sp - len;
+	void __user *ptr;
+
+	/* If len would occupy more than half of the entire compat space... */
+	if (unlikely(len > (((compat_uptr_t)~0) >> 1)))
+		return NULL;
+
+	ptr = (void __user *)regs->sp - len;
+
+	if (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))
+		return NULL;
+
+	return ptr;
 }
 
+#define compat_alloc_user_space arch_compat_alloc_user_space
+
 static inline int is_compat_task(void)
 {
 	return current_thread_info()->status & TS_COMPAT;
Index: linux-2.6.32-SLE11-SP1/include/linux/compat.h
===================================================================
--- linux-2.6.32-SLE11-SP1.orig/include/linux/compat.h
+++ linux-2.6.32-SLE11-SP1/include/linux/compat.h
@@ -309,7 +309,5 @@ asmlinkage long compat_sys_newfstatat(un
 asmlinkage long compat_sys_openat(unsigned int dfd, const char __user *filename,
 				  int flags, int mode);
 
-extern void __user *compat_alloc_user_space(unsigned long len);
-
 #endif /* CONFIG_COMPAT */
 #endif /* _LINUX_COMPAT_H */
