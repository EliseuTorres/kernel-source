From 929c3a8097c3e159ac8db1e60e6ed5db6a250506 Mon Sep 17 00:00:00 2001
From: Waiman Long <Waiman.Long@hp.com>
Date: Tue, 10 Mar 2015 21:58:36 -0400
Subject: [PATCH 4/4] kabi: fix for changes in the sysfs_dirent structure
Patch-mainline: never, kabi fixup
References: bnc#919589

The upstream commits 4f72c0cab40536a0be501d85ea4918467ab82ad5
(sysfs: use rb-tree for name lookups) and
a406f75840e15afbabd98cb64ae36b51424a8033 (sysfs: use rb-tree for
inode number lookup) will change the kabi signatures of functions
that have either kobject structure pointer or sysfs_dirent structure
pointer as an argument.

This patch fixes the kabi breakage by restoring structure field
that was deleted and encapsulate the new fields in a __GENKSYMS__
ifdef block.

The sysfs_dirent structure itself is opaque as defined in the
include/linux/sysfs.h header file. Its real structure is defined
in the private fs/sysfs/sysfs.h file. Kernel module developers are
not supposed to include the private sysfs.h file.

To cater for the rare case that someone did include the private
sysfs.h file, the new fields are all moved to the end of the
sysfs_dirent structure so that all existing fields will still have
the same offsets. If a kernel module is peeping into the content of
sysfs_dirent, they won't get the wrong data with the exception of
the children and s_sibling fields.  These two fields were used for
linking various sysfs_dirent together.  Kernel modules should not
care about those as they should use the public kernel APIs to do
the searching instead of doing it themselves.

It is highly unlikely that a kernel module will statically allocate
a sysfs_dirent structure unless it duplicates all the initialization
code that is provided by the sysfs layer. Instead, it should just call
either sysfs_get_dirent() or sysfs_get() to dynamically allocate one,
if necessary.

Signed-off-by: Waiman Long <Waiman.Long@hp.com>
Signed-off-by: Michal Hocko <mhocko@suse.cz>

---
 fs/sysfs/dir.c   |   18 +++++++++---------
 fs/sysfs/sysfs.h |   16 ++++++++++------
 2 files changed, 19 insertions(+), 15 deletions(-)

diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index 3a1901d..63d0971 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -50,7 +50,7 @@ static void sysfs_link_sibling(struct sysfs_dirent *sd)
 	if (sysfs_type(sd) == SYSFS_DIR)
 		parent_sd->s_dir.subdirs++;
 
-	p = &parent_sd->s_dir.inode_tree.rb_node;
+	p = &parent_sd->s_dir_inode_tree.rb_node;
 	parent = NULL;
 	while (*p) {
 		parent = *p;
@@ -66,9 +66,9 @@ static void sysfs_link_sibling(struct sysfs_dirent *sd)
 #undef node
 	}
 	rb_link_node(&sd->inode_node, parent, p);
-	rb_insert_color(&sd->inode_node, &parent_sd->s_dir.inode_tree);
+	rb_insert_color(&sd->inode_node, &parent_sd->s_dir_inode_tree);
 
-	p = &parent_sd->s_dir.name_tree.rb_node;
+	p = &parent_sd->s_dir_name_tree.rb_node;
 	parent = NULL;
 	while (*p) {
 		int c;
@@ -83,7 +83,7 @@ static void sysfs_link_sibling(struct sysfs_dirent *sd)
 #undef node
 	}
 	rb_link_node(&sd->name_node, parent, p);
-	rb_insert_color(&sd->name_node, &parent_sd->s_dir.name_tree);
+	rb_insert_color(&sd->name_node, &parent_sd->s_dir_name_tree);
 }
 
 /**
@@ -101,8 +101,8 @@ static void sysfs_unlink_sibling(struct sysfs_dirent *sd)
 	if (sysfs_type(sd) == SYSFS_DIR)
 		sd->s_parent->s_dir.subdirs--;
 
-	rb_erase(&sd->inode_node, &sd->s_parent->s_dir.inode_tree);
-	rb_erase(&sd->name_node, &sd->s_parent->s_dir.name_tree);
+	rb_erase(&sd->inode_node, &sd->s_parent->s_dir_inode_tree);
+	rb_erase(&sd->name_node, &sd->s_parent->s_dir_name_tree);
 }
 
 /**
@@ -562,7 +562,7 @@ struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
 				       const void *ns,
 				       const unsigned char *name)
 {
-	struct rb_node *p = parent_sd->s_dir.name_tree.rb_node;
+	struct rb_node *p = parent_sd->s_dir_name_tree.rb_node;
 	struct sysfs_dirent *found = NULL;
 
 	while (p) {
@@ -794,7 +794,7 @@ static void __sysfs_remove_dir(struct sysfs_dirent *dir_sd)
 
 	pr_debug("sysfs %s: removing dir\n", dir_sd->s_name);
 	sysfs_addrm_start(&acxt, dir_sd);
-	pos = rb_first(&dir_sd->s_dir.inode_tree);
+	pos = rb_first(&dir_sd->s_dir_inode_tree);
 	while (pos) {
 		struct sysfs_dirent *sd = rb_entry(pos, struct sysfs_dirent, inode_node);
 		pos = rb_next(pos);
@@ -920,7 +920,7 @@ static struct sysfs_dirent *sysfs_dir_pos(const void *ns,
 			pos = NULL;
 	}
 	if (!pos && (ino > 1) && (ino < INT_MAX)) {
-		struct rb_node *p = parent_sd->s_dir.inode_tree.rb_node;
+		struct rb_node *p = parent_sd->s_dir_inode_tree.rb_node;
 		while (p) {
 #define node	rb_entry(p, struct sysfs_dirent, inode_node)
 			if (ino < node->s_ino) {
diff --git a/fs/sysfs/sysfs.h b/fs/sysfs/sysfs.h
index 6a6a9c0..1d928f3 100644
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@ -19,10 +19,9 @@ struct sysfs_open_dirent;
 struct sysfs_elem_dir {
 	struct kobject		*kobj;
 
-	unsigned long		subdirs;
+	struct sysfs_dirent	*children;	/* No longer used */
 
-	struct rb_root		inode_tree;
-	struct rb_root		name_tree;
+	unsigned long		subdirs;
 };
 
 struct sysfs_elem_symlink {
@@ -63,9 +62,6 @@ struct sysfs_dirent {
 	struct sysfs_dirent	*s_sibling;
 	const char		*s_name;
 
-	struct rb_node		inode_node;
-	struct rb_node		name_node;
-
 	const void		*s_ns; /* namespace tag */
 	union {
 		struct sysfs_elem_dir		s_dir;
@@ -78,6 +74,14 @@ struct sysfs_dirent {
 	unsigned short		s_mode;
 	ino_t			s_ino;
 	struct sysfs_inode_attrs *s_iattr;
+
+#ifndef __GENKSYMS__
+	struct rb_root		s_dir_inode_tree;
+	struct rb_root		s_dir_name_tree;
+
+	struct rb_node		inode_node;
+	struct rb_node		name_node;
+#endif
 };
 
 #define SD_DEACTIVATED_BIAS		INT_MIN
-- 
1.7.1

