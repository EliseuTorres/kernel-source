From: Michal Hocko <mhocko@suse.cz>
Subject: mm: fix return type for functions nr_free_*_pages kabi fixup
Patch-mainline: never
References: bnc#864058

nr_free_buffer_pages is exported and used by modules so we cannot change its
return value because we would break kABI and cause a stack curruption.

This patch adds a new (transitional) nr_free_buffer_pages2 function with a
correct return value and it replaces all in-tree occurrences. Users of the old
functions are warned to switch to a new function by a one time warning to
catch out of tree users during runtime and the function is marked deprecated
to catch others during compilation time.

Signed-off-by: Michal Hocko <mhocko@suse.cz>

---
 drivers/mmc/card/mmc_test.c |    2 +-
 fs/buffer.c                 |    2 +-
 fs/nfsd/nfs4state.c         |    2 +-
 fs/nfsd/nfssvc.c            |    2 +-
 include/linux/swap.h        |    3 ++-
 mm/huge_memory.c            |    2 +-
 mm/page_alloc.c             |   11 +++++++++--
 net/9p/trans_virtio.c       |    2 +-
 net/ipv4/tcp.c              |    2 +-
 net/ipv4/udp.c              |    2 +-
 net/sctp/protocol.c         |    2 +-
 11 files changed, 20 insertions(+), 12 deletions(-)

--- a/drivers/mmc/card/mmc_test.c
+++ b/drivers/mmc/card/mmc_test.c
@@ -301,7 +301,7 @@ static struct mmc_test_mem *mmc_test_all
 	unsigned long min_page_cnt = DIV_ROUND_UP(min_sz, PAGE_SIZE);
 	unsigned long max_seg_page_cnt = DIV_ROUND_UP(max_seg_sz, PAGE_SIZE);
 	unsigned long page_cnt = 0;
-	unsigned long limit = nr_free_buffer_pages() >> 4;
+	unsigned long limit = nr_free_buffer_pages2() >> 4;
 	struct mmc_test_mem *mem;
 
 	if (max_page_cnt > limit)
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -3442,7 +3442,7 @@ void __init buffer_init(void)
 	/*
 	 * Limit the bh occupancy to 10% of ZONE_NORMAL
 	 */
-	nrpages = (nr_free_buffer_pages() * 10) / 100;
+	nrpages = (nr_free_buffer_pages2() * 10) / 100;
 	max_buffer_heads = nrpages * (PAGE_SIZE / sizeof(struct buffer_head));
 	hotcpu_notifier(buffer_cpu_notify, 0);
 }
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -4356,7 +4356,7 @@ set_max_delegations(void)
 	 * is for a different inode), a delegation could take about 1.5K,
 	 * giving a worst case usage of about 6% of memory.
 	 */
-	max_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);
+	max_delegations = nr_free_buffer_pages2() >> (20 - 2 - PAGE_SHIFT);
 }
 
 /* initialization to perform when the nfsd service is started: */
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -297,7 +297,7 @@ void nfsd_reset_versions(void)
 static void set_max_drc(void)
 {
 	#define NFSD_DRC_SIZE_SHIFT	10
-	nfsd_drc_max_mem = (nr_free_buffer_pages()
+	nfsd_drc_max_mem = (nr_free_buffer_pages2()
 					>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;
 	nfsd_drc_mem_used = 0;
 	spin_lock_init(&nfsd_drc_lock);
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@ -207,7 +207,8 @@ struct swap_list_t {
 /* linux/mm/page_alloc.c */
 extern unsigned long totalram_pages;
 extern unsigned long totalreserve_pages;
-extern unsigned long nr_free_buffer_pages(void);
+extern unsigned int nr_free_buffer_pages(void);
+extern unsigned long nr_free_buffer_pages2(void);
 extern unsigned long nr_free_pagecache_pages(void);
 
 /* Definition of global_page_state not available yet */
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@ -124,7 +124,7 @@ static int set_recommended_min_free_kbyt
 
 	/* don't ever allow to reserve more than 5% of the lowmem */
 	recommended_min = min(recommended_min,
-			      (unsigned long) nr_free_buffer_pages() / 20);
+			      (unsigned long) nr_free_buffer_pages2() / 20);
 	recommended_min <<= (PAGE_SHIFT-10);
 
 	if (recommended_min > min_free_kbytes)
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -2584,12 +2584,19 @@ static unsigned long nr_free_zone_pages(
 /*
  * Amount of free RAM allocatable within ZONE_DMA and ZONE_NORMAL
  */
-unsigned long nr_free_buffer_pages(void)
+unsigned int __deprecated nr_free_buffer_pages(void)
 {
+	WARN_ONCE(1, "nr_free_buffer_pages() is deprecated and unsafe for machines with >16TB of RAM. Use nr_free_buffer_pages2() instead\n");
 	return nr_free_zone_pages(gfp_zone(GFP_USER));
 }
 EXPORT_SYMBOL_GPL(nr_free_buffer_pages);
 
+unsigned long nr_free_buffer_pages2(void)
+{
+	return nr_free_zone_pages(gfp_zone(GFP_USER));
+}
+EXPORT_SYMBOL_GPL(nr_free_buffer_pages2);
+
 /*
  * Amount of free RAM allocatable within all zones
  */
@@ -5353,7 +5360,7 @@ int __meminit init_per_zone_wmark_min(vo
 	unsigned long lowmem_kbytes;
 	int new_min_free_kbytes;
 
-	lowmem_kbytes = nr_free_buffer_pages() * (PAGE_SIZE >> 10);
+	lowmem_kbytes = nr_free_buffer_pages2() * (PAGE_SIZE >> 10);
 	new_min_free_kbytes = int_sqrt(lowmem_kbytes * 16);
 
 	if (new_min_free_kbytes > user_min_free_kbytes) {
--- a/net/9p/trans_virtio.c
+++ b/net/9p/trans_virtio.c
@@ -479,7 +479,7 @@ static int p9_virtio_probe(struct virtio
 	init_waitqueue_head(chan->vc_wq);
 	chan->ring_bufs_avail = 1;
 	/* Ceiling limit to avoid denial of service attacks */
-	chan->p9_max_pages = nr_free_buffer_pages()/4;
+	chan->p9_max_pages = nr_free_buffer_pages2()/4;
 
 	mutex_lock(&virtio_9p_lock);
 	list_add_tail(&chan->chan_list, &virtio_chan_list);
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -3290,7 +3290,7 @@ void __init tcp_init(void)
 	sysctl_tcp_max_orphans = cnt / 2;
 	sysctl_max_syn_backlog = max(128, cnt / 256);
 
-	limit = nr_free_buffer_pages() / 8;
+	limit = nr_free_buffer_pages2() / 8;
 	limit = max(limit, 128UL);
 	sysctl_tcp_mem[0] = limit / 4 * 3;
 	sysctl_tcp_mem[1] = limit;
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -2213,7 +2213,7 @@ void __init udp_init(void)
 	unsigned long limit;
 
 	udp_table_init(&udp_table, "UDP");
-	limit = nr_free_buffer_pages() / 8;
+	limit = nr_free_buffer_pages2() / 8;
 	limit = max(limit, 128UL);
 	sysctl_udp_mem[0] = limit / 4 * 3;
 	sysctl_udp_mem[1] = limit;
--- a/net/sctp/protocol.c
+++ b/net/sctp/protocol.c
@@ -1150,7 +1150,7 @@ SCTP_STATIC __init int sctp_init(void)
 	/* Initialize handle used for association ids. */
 	idr_init(&sctp_assocs_id);
 
-	limit = nr_free_buffer_pages() / 8;
+	limit = nr_free_buffer_pages2() / 8;
 	limit = max(limit, 128UL);
 	sysctl_sctp_mem[0] = limit / 4 * 3;
 	sysctl_sctp_mem[1] = limit;
