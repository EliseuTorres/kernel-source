From: Jiri Slaby <jslaby@suse.cz>
Date: Thu, 1 Mar 2012 15:59:42 +0100
Subject: Revert "ipv4: Save nexthop address of LSRR/SSRR option to IPCB."
Patch-mainline: never

This reverts commit 5805d4729059f578c8283ccc44021342fbe8c93d, upstream
ac8a48106be49c422575ddc7531b776f8eb49610.

It causes a kabi breakage in ip_options and all structures which
include that. For the time being, just reverted that. But it may be
possible to move the address to the end of the structure, as nobody
should allocate that externally. However this is yet to be
investigated.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/net/inet_sock.h |    2 --
 net/ipv4/ip_forward.c   |    2 +-
 net/ipv4/ip_options.c   |    5 ++---
 3 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/include/net/inet_sock.h b/include/net/inet_sock.h
index 14dd9c7..caaff5f 100644
--- a/include/net/inet_sock.h
+++ b/include/net/inet_sock.h
@@ -31,7 +31,6 @@
 /** struct ip_options - IP Options
  *
  * @faddr - Saved first hop address
- * @nexthop - Saved nexthop address in LSRR and SSRR
  * @is_data - Options in __data, rather than skb
  * @is_strictroute - Strict source route
  * @srr_is_hit - Packet destination addr was our one
@@ -42,7 +41,6 @@
  */
 struct ip_options {
 	__be32		faddr;
-	__be32		nexthop;
 	unsigned char	optlen;
 	unsigned char	srr;
 	unsigned char	rr;
diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c
index 29a07b6..3b34d1c 100644
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@ -84,7 +84,7 @@ int ip_forward(struct sk_buff *skb)
 
 	rt = skb_rtable(skb);
 
-	if (opt->is_strictroute && opt->nexthop != rt->rt_gateway)
+	if (opt->is_strictroute && ip_hdr(skb)->daddr != rt->rt_gateway)
 		goto sr_failed;
 
 	if (unlikely(skb->len > dst_mtu(&rt->dst) && !skb_is_gso(skb) &&
diff --git a/net/ipv4/ip_options.c b/net/ipv4/ip_options.c
index 1e60f76..05d20cc 100644
--- a/net/ipv4/ip_options.c
+++ b/net/ipv4/ip_options.c
@@ -568,13 +568,12 @@ void ip_forward_options(struct sk_buff *skb)
 		     ) {
 			if (srrptr + 3 > srrspace)
 				break;
-			if (memcmp(&opt->nexthop, &optptr[srrptr-1], 4) == 0)
+			if (memcmp(&ip_hdr(skb)->daddr, &optptr[srrptr-1], 4) == 0)
 				break;
 		}
 		if (srrptr + 3 <= srrspace) {
 			opt->is_changed = 1;
 			ip_rt_get_source(&optptr[srrptr-1], skb, rt);
-			ip_hdr(skb)->daddr = opt->nexthop;
 			optptr[2] = srrptr+4;
 		} else if (net_ratelimit())
 			printk(KERN_CRIT "ip_forward(): Argh! Destination lost!\n");
@@ -641,7 +640,7 @@ int ip_options_rcv_srr(struct sk_buff *skb)
 	}
 	if (srrptr <= srrspace) {
 		opt->srr_is_hit = 1;
-		opt->nexthop = nexthop;
+		iph->daddr = nexthop;
 		opt->is_changed = 1;
 	}
 	return 0;
-- 
1.7.9.2

