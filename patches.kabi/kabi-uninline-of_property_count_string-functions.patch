From: Jiri Slaby <jslaby@suse.cz>
Subject: kABI: uninline of_property_count_string* functions
Patch-mainline: never, kabi

In 3.12.33, commit ba82a2ab8f266a3c9c3f4364339fb4932b4cba36 (of: Fix
overflow bug in string property parsing functions), upstream commit
a87fa1d81a9fb5e9adca9820e16008c40ad09f33 introduced a helper for of
strings and made static inlines from of_property_count_strings and
of_property_read_string_index. Therefore, the symbols disappeared from
the kABI checker and potential users.

Convert the static inlines back to standard, exported functions. They
just call the newly added helper.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/of/base.c  |   46 ++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/of.h |   49 +++++--------------------------------------------
 2 files changed, 51 insertions(+), 44 deletions(-)

--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1130,6 +1130,52 @@ int of_property_read_string_helper(struc
 }
 EXPORT_SYMBOL_GPL(of_property_read_string_helper);
 
+/**
+ * of_property_count_strings() - Find and return the number of strings from a
+ * multiple strings property.
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ *
+ * Search for a property in a device tree node and retrieve the number of null
+ * terminated string contain in it. Returns the number of strings on
+ * success, -EINVAL if the property does not exist, -ENODATA if property
+ * does not have a value, and -EILSEQ if the string is not null-terminated
+ * within the length of the property data.
+ */
+int of_property_count_strings(struct device_node *np,
+			      const char *propname)
+{
+	return of_property_read_string_helper(np, propname, NULL, 0, 0);
+}
+EXPORT_SYMBOL_GPL(of_property_count_strings);
+
+/**
+ * of_property_read_string_index() - Find and read a string from a multiple
+ * strings property.
+ * @np:		device node from which the property value is to be read.
+ * @propname:	name of the property to be searched.
+ * @index:	index of the string in the list of strings
+ * @out_string:	pointer to null terminated return string, modified only if
+ *		return value is 0.
+ *
+ * Search for a property in a device tree node and retrieve a null
+ * terminated string value (pointer to data, not a copy) in the list of strings
+ * contained in that property.
+ * Returns 0 on success, -EINVAL if the property does not exist, -ENODATA if
+ * property does not have a value, and -EILSEQ if the string is not
+ * null-terminated within the length of the property data.
+ *
+ * The out_string pointer is modified only if a valid string can be decoded.
+ */
+int of_property_read_string_index(struct device_node *np,
+				  const char *propname,
+				  int index, const char **output)
+{
+	int rc = of_property_read_string_helper(np, propname, output, 1, index);
+	return rc < 0 ? rc : 0;
+}
+EXPORT_SYMBOL_GPL(of_property_read_string_index);
+
 static int __of_parse_phandle_with_args(const struct device_node *np,
 					const char *list_name,
 					const char *cells_name,
--- a/include/linux/of.h
+++ b/include/linux/of.h
@@ -252,9 +252,14 @@ extern int of_property_read_u64(const st
 extern int of_property_read_string(struct device_node *np,
 				   const char *propname,
 				   const char **out_string);
+extern int of_property_read_string_index(struct device_node *np,
+					 const char *propname,
+					 int index, const char **output);
 extern int of_property_match_string(struct device_node *np,
 				    const char *propname,
 				    const char *string);
+extern int of_property_count_strings(struct device_node *np,
+				     const char *propname);
 extern int of_property_read_string_helper(struct device_node *np,
 					      const char *propname,
 					      const char **out_strs, size_t sz, int index);
@@ -556,50 +561,6 @@ static inline int of_property_read_strin
 }
 
 /**
- * of_property_count_strings() - Find and return the number of strings from a
- * multiple strings property.
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- *
- * Search for a property in a device tree node and retrieve the number of null
- * terminated string contain in it. Returns the number of strings on
- * success, -EINVAL if the property does not exist, -ENODATA if property
- * does not have a value, and -EILSEQ if the string is not null-terminated
- * within the length of the property data.
- */
-static inline int of_property_count_strings(struct device_node *np,
-					    const char *propname)
-{
-	return of_property_read_string_helper(np, propname, NULL, 0, 0);
-}
-
-/**
- * of_property_read_string_index() - Find and read a string from a multiple
- * strings property.
- * @np:		device node from which the property value is to be read.
- * @propname:	name of the property to be searched.
- * @index:	index of the string in the list of strings
- * @out_string:	pointer to null terminated return string, modified only if
- *		return value is 0.
- *
- * Search for a property in a device tree node and retrieve a null
- * terminated string value (pointer to data, not a copy) in the list of strings
- * contained in that property.
- * Returns 0 on success, -EINVAL if the property does not exist, -ENODATA if
- * property does not have a value, and -EILSEQ if the string is not
- * null-terminated within the length of the property data.
- *
- * The out_string pointer is modified only if a valid string can be decoded.
- */
-static inline int of_property_read_string_index(struct device_node *np,
-						const char *propname,
-						int index, const char **output)
-{
-	int rc = of_property_read_string_helper(np, propname, output, 1, index);
-	return rc < 0 ? rc : 0;
-}
-
-/**
  * of_property_read_bool - Findfrom a property
  * @np:		device node from which the property value is to be read.
  * @propname:	name of the property to be searched.
