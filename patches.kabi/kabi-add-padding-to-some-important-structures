From bbbce28e06ce5ac4ffd18e8624f099af8b90532e Mon Sep 17 00:00:00 2001
From: Michal Marek <mmarek@suse.cz>
Date: Fri, 16 Sep 2011 11:56:20 +0200
Subject: [PATCH] kabi: Add placeholders to a couple of important structures
Patch-mainline: never
References: fate#312013

Add a void* suse_kabi_padding placeholder to the following structures:
struct smp_ops
struct vm_area_struct
struct mm_struct
struct zone
  - adding an explicit padding here is not strictly required, but can
    serve as documentation that there is some space
struct pglist_data
struct vfsmount
struct signal_struct
struct sched_entity
struct sock

The idea is that when a fix appears that requires a new member in any of
these structures, we use this padding:

  #ifdef __GENKSYMS__
          void *suse_kabi_padding;
  #else
          long foo;
  #endif

And we don't have to worry about changing size of the structure, as long
as the new member is a pointer or a long.

Signed-off-by: Michal Marek <mmarek@suse.cz>

---
 arch/x86/include/asm/smp.h |    1 +
 include/linux/mm_types.h   |    2 ++
 include/linux/mmzone.h     |    2 ++
 include/linux/mount.h      |    1 +
 include/linux/sched.h      |    3 +++
 include/net/sock.h         |    1 +
 6 files changed, 10 insertions(+)

--- a/arch/x86/include/asm/smp.h
+++ b/arch/x86/include/asm/smp.h
@@ -77,6 +77,7 @@ struct smp_ops {
 
 	void (*send_call_func_ipi)(const struct cpumask *mask);
 	void (*send_call_func_single_ipi)(int cpu);
+	void *suse_kabi_padding;
 };
 
 /* Globals due to paravirt */
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -198,6 +198,7 @@ struct vm_area_struct {
 #ifdef CONFIG_NUMA
 	struct mempolicy *vm_policy;	/* NUMA policy for the VMA */
 #endif
+	void *suse_kabi_padding;
 };
 
 struct core_thread {
@@ -330,6 +331,7 @@ struct mm_struct {
 #ifdef CONFIG_CPUMASK_OFFSTACK
 	struct cpumask cpumask_allocation;
 #endif
+	void *suse_kabi_padding;
 };
 
 static inline void mm_init_cpumask(struct mm_struct *mm)
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -414,6 +414,7 @@ struct zone {
 	 * rarely used fields:
 	 */
 	const char		*name;
+	void *suse_kabi_padding;
 } ____cacheline_internodealigned_in_smp;
 
 typedef enum {
@@ -636,6 +637,7 @@ typedef struct pglist_data {
 	struct task_struct *kswapd;	/* Protected by lock_memory_hotplug() */
 	int kswapd_max_order;
 	enum zone_type classzone_idx;
+	void *suse_kabi_padding;
 } pg_data_t;
 
 #define node_present_pages(nid)	(NODE_DATA(nid)->node_present_pages)
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@ -86,6 +86,7 @@ struct vfsmount {
 	int mnt_expiry_mark;		/* true if marked for expiry */
 	int mnt_pinned;
 	int mnt_ghosts;
+	void *suse_kabi_padding;
 };
 
 struct file; /* forward dec */
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -652,6 +652,7 @@ struct signal_struct {
 	struct mutex cred_guard_mutex;	/* guard against foreign influences on
 					 * credential calculations
 					 * (notably. ptrace) */
+	void *suse_kabi_padding;
 };
 
 /* Context switch must be unlocked if interrupts are to be enabled */
@@ -1190,6 +1191,7 @@ struct sched_entity {
 	/* rq "owned" by this entity/group: */
 	struct cfs_rq		*my_q;
 #endif
+	void *suse_kabi_padding;
 };
 
 struct sched_rt_entity {
@@ -1570,6 +1572,7 @@ struct task_struct {
 #ifdef CONFIG_HAVE_HW_BREAKPOINT
 	atomic_t ptrace_bp_refcnt;
 #endif
+	void *suse_kabi_padding;
 };
 
 /* Future-safe accessor for struct task_struct's cpus_allowed. */
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -345,6 +345,7 @@ struct sock {
   	int			(*sk_backlog_rcv)(struct sock *sk,
 						  struct sk_buff *skb);  
 	void                    (*sk_destruct)(struct sock *sk);
+	void *suse_kabi_padding;
 };
 
 /*
