From: Michal Kubecek <mkubecek@suse.cz>
Date: Tue, 7 Jan 2014 15:37:16 +0100
Subject: kabi: protect bind_conflict callback in struct inet_connection_sock_af_ops
Patch-mainline: Never, kabi fix
References: bnc#823618

Upstream commit

    aacd9289  tcp: bind() use stronger condition for bind_conflict

adds parameter relax to bind_conflict callback in struct
inet_connection_sock_af_ops which breaks kABI. Instead, use
a table to translate old (two-parameter) callback pointer to new
(three-parameter) one.

In inet_csk_get_port() we can safely use the pointer returned
by inet_csk_get_bind_conflict_ext() as the socket holds a
reference to the adress family so that it (and IPv6) cannot be
released (otherwise we couldn't use the original pointer from
af ops either).

Signed-off-by: Ales Novak <alnovak@suse.cz>
Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/inet6_connection_sock.h |  6 +++-
 include/net/inet_connection_sock.h  | 33 ++++++++++++++++++--
 net/ipv4/af_inet.c                  |  9 ++++++
 net/ipv4/inet_connection_sock.c     | 61 ++++++++++++++++++++++++++++++++++---
 net/ipv6/af_inet6.c                 | 14 +++++++++
 net/ipv6/inet6_connection_sock.c    | 12 ++++++--
 6 files changed, 125 insertions(+), 10 deletions(-)

diff --git a/include/net/inet6_connection_sock.h b/include/net/inet6_connection_sock.h
index 1866a67..aba94a5 100644
--- a/include/net/inet6_connection_sock.h
+++ b/include/net/inet6_connection_sock.h
@@ -22,8 +22,12 @@ struct sk_buff;
 struct sock;
 struct sockaddr;
 
+extern int inet6_csk_bind_conflict_ext(const struct sock *sk,
+				       const struct inet_bind_bucket *tb,
+				       bool relax);
+
 extern int inet6_csk_bind_conflict(const struct sock *sk,
-				   const struct inet_bind_bucket *tb, bool relax);
+				   const struct inet_bind_bucket *tb);
 
 extern struct dst_entry* inet6_csk_route_req(struct sock *sk,
 					     const struct request_sock *req);
diff --git a/include/net/inet_connection_sock.h b/include/net/inet_connection_sock.h
index 6c5a7bef..0d46339 100644
--- a/include/net/inet_connection_sock.h
+++ b/include/net/inet_connection_sock.h
@@ -60,7 +60,7 @@ struct inet_connection_sock_af_ops {
 #endif
 	void	    (*addr2sockaddr)(struct sock *sk, struct sockaddr *);
 	int	    (*bind_conflict)(const struct sock *sk,
-				     const struct inet_bind_bucket *tb, bool relax);
+				     const struct inet_bind_bucket *tb);
 };
 
 /** inet_connection_sock - INET connection oriented sock
@@ -237,6 +237,18 @@ static inline void inet_csk_reset_xmit_timer(struct sock *sk, const int what,
 #endif
 }
 
+typedef int (*inet_csk_bind_conflict_t)(const struct sock *,
+					const struct inet_bind_bucket *);
+typedef int (*inet_csk_bind_conflict_ext_t)(const struct sock *,
+					    const struct inet_bind_bucket *,
+					    bool);
+
+struct inet_csk_bind_conflict_rule {
+	struct list_head		list;
+	inet_csk_bind_conflict_t	old;
+	inet_csk_bind_conflict_ext_t	new;
+};
+
 extern struct sock *inet_csk_accept(struct sock *sk, int flags, int *err);
 
 extern struct request_sock *inet_csk_search_req(const struct sock *sk,
@@ -244,8 +256,25 @@ extern struct request_sock *inet_csk_search_req(const struct sock *sk,
 						const __be16 rport,
 						const __be32 raddr,
 						const __be32 laddr);
+extern int inet_csk_bind_conflict_ext(const struct sock *sk,
+				      const struct inet_bind_bucket *tb,
+				      bool relax);
 extern int inet_csk_bind_conflict(const struct sock *sk,
-				  const struct inet_bind_bucket *tb, bool relax);
+				  const struct inet_bind_bucket *tb);
+extern void inet_csk_register_bind_conflict(struct inet_csk_bind_conflict_rule *rule);
+extern void inet_csk_unregister_bind_conflict(struct inet_csk_bind_conflict_rule *rule);
+extern inet_csk_bind_conflict_ext_t inet_csk_get_bind_conflict_ext(inet_csk_bind_conflict_t old);
+
+static inline int inet_csk_call_bind_conflict(const struct sock *sk,
+					      const struct inet_bind_bucket *tb,
+					      inet_csk_bind_conflict_ext_t ext_cb,
+					      bool relax)
+{
+	if (ext_cb)
+		return (*ext_cb)(sk, tb, relax);
+	return inet_csk(sk)->icsk_af_ops->bind_conflict(sk, tb);
+}
+
 extern int inet_csk_get_port(struct sock *sk, unsigned short snum);
 
 extern struct dst_entry* inet_csk_route_req(struct sock *sk,
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index 33a8687..29f5876 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -1557,6 +1557,12 @@ static const struct net_protocol icmp_protocol = {
 	.netns_ok =	1,
 };
 
+static struct inet_csk_bind_conflict_rule ipv4_csk_bind_conflict_rule = {
+	.list =		LIST_HEAD_INIT(ipv4_csk_bind_conflict_rule.list),
+	.old =		inet_csk_bind_conflict,
+	.new =		inet_csk_bind_conflict_ext,
+};
+
 static __net_init int ipv4_mib_init_net(struct net *net)
 {
 	if (snmp_mib_init((void __percpu **)net->mib.tcp_statistics,
@@ -1727,6 +1733,9 @@ static int __init inet_init(void)
 	/* Add UDP-Lite (RFC 3828) */
 	udplite4_register();
 
+	/* Register bind_conflict callback translate rule */
+	inet_csk_register_bind_conflict(&ipv4_csk_bind_conflict_rule);
+
 	ping_init();
 
 	/*
diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c
index d7727c9..6df5f5e 100644
--- a/net/ipv4/inet_connection_sock.c
+++ b/net/ipv4/inet_connection_sock.c
@@ -52,8 +52,11 @@ void inet_get_local_port_range(int *low, int *high)
 }
 EXPORT_SYMBOL(inet_get_local_port_range);
 
-int inet_csk_bind_conflict(const struct sock *sk,
-			   const struct inet_bind_bucket *tb, bool relax)
+LIST_HEAD(bind_conflict_rule_list);
+DEFINE_RWLOCK(bind_conflict_rule_lock);
+
+int inet_csk_bind_conflict_ext(const struct sock *sk,
+			       const struct inet_bind_bucket *tb, bool relax)
 {
 	struct sock *sk2;
 	struct hlist_node *node;
@@ -91,8 +94,54 @@ int inet_csk_bind_conflict(const struct sock *sk,
 	}
 	return node != NULL;
 }
+
+EXPORT_SYMBOL_GPL(inet_csk_bind_conflict_ext);
+
+int inet_csk_bind_conflict(const struct sock *sk,
+			   const struct inet_bind_bucket *tb)
+{
+	return inet_csk_bind_conflict_ext(sk, tb, true);
+}
+
 EXPORT_SYMBOL_GPL(inet_csk_bind_conflict);
 
+void inet_csk_register_bind_conflict(struct inet_csk_bind_conflict_rule *rule)
+{
+	write_lock(&bind_conflict_rule_lock);
+	list_add_tail(&rule->list, &bind_conflict_rule_list);
+	write_unlock(&bind_conflict_rule_lock);
+}
+
+EXPORT_SYMBOL(inet_csk_register_bind_conflict);
+
+void inet_csk_unregister_bind_conflict(struct inet_csk_bind_conflict_rule *rule)
+{
+	write_lock(&bind_conflict_rule_lock);
+	list_del_init(&rule->list);
+	write_unlock(&bind_conflict_rule_lock);
+}
+
+EXPORT_SYMBOL(inet_csk_unregister_bind_conflict);
+
+inet_csk_bind_conflict_ext_t inet_csk_get_bind_conflict_ext(inet_csk_bind_conflict_t old)
+{
+	struct inet_csk_bind_conflict_rule *rule;
+	inet_csk_bind_conflict_ext_t ret = NULL;
+
+	read_lock(&bind_conflict_rule_lock);
+	list_for_each_entry(rule, &bind_conflict_rule_list, list) {
+		if (rule->old == old) {
+			ret = rule->new;
+			break;
+		}
+	}
+	read_unlock(&bind_conflict_rule_lock);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(inet_csk_get_bind_conflict_ext);
+
 /* Obtain a reference to a local port for the given sock,
  * if snum is zero it means select any available local port.
  */
@@ -105,6 +154,8 @@ int inet_csk_get_port(struct sock *sk, unsigned short snum)
 	int ret, attempts = 5;
 	struct net *net = sock_net(sk);
 	int smallest_size = -1, smallest_rover;
+	inet_csk_bind_conflict_ext_t conflict_cb =
+		inet_csk_get_bind_conflict_ext(inet_csk(sk)->icsk_af_ops->bind_conflict);
 
 	local_bh_disable();
 	if (!snum) {
@@ -131,13 +182,13 @@ again:
 						smallest_size = tb->num_owners;
 						smallest_rover = rover;
 						if (atomic_read(&hashinfo->bsockets) > (high - low) + 1 &&
-						    !inet_csk(sk)->icsk_af_ops->bind_conflict(sk, tb, false)) {
+						    !inet_csk_call_bind_conflict(sk, tb, conflict_cb, false)) {
 							spin_unlock(&head->lock);
 							snum = smallest_rover;
 							goto have_snum;
 						}
 					}
-					if (!inet_csk(sk)->icsk_af_ops->bind_conflict(sk, tb, false)) {
+					if (!inet_csk_call_bind_conflict(sk, tb, conflict_cb, false)) {
 						spin_unlock(&head->lock);
 						snum = rover;
 						goto have_snum;
@@ -189,7 +240,7 @@ tb_found:
 			goto success;
 		} else {
 			ret = 1;
-			if (inet_csk(sk)->icsk_af_ops->bind_conflict(sk, tb, true)) {
+			if (inet_csk_call_bind_conflict(sk, tb, conflict_cb, true)) {
 				if (sk->sk_reuse && sk->sk_state != TCP_LISTEN &&
 				    smallest_size != -1 && --attempts >= 0) {
 					spin_unlock(&head->lock);
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index 0aab754..b4da18d 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -58,6 +58,8 @@
 #ifdef CONFIG_IPV6_TUNNEL
 #include <net/ip6_tunnel.h>
 #endif
+#include <net/inet_connection_sock.h>
+#include <net/inet6_connection_sock.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -563,6 +565,12 @@ static const struct net_proto_family inet6_family_ops = {
 	.owner	= THIS_MODULE,
 };
 
+static struct inet_csk_bind_conflict_rule ipv6_csk_bind_conflict_rule = {
+	.list =		LIST_HEAD_INIT(ipv6_csk_bind_conflict_rule.list),
+	.old =		inet6_csk_bind_conflict,
+	.new =		inet6_csk_bind_conflict_ext,
+};
+
 int inet6_register_protosw(struct inet_protosw *p)
 {
 	struct list_head *lh;
@@ -1117,6 +1125,10 @@ int inet6_init_real(void)
 	if (err)
 		goto static_sysctl_fail;
 #endif
+
+	/* Register bind_conflict callback translate rule */
+	inet_csk_register_bind_conflict(&ipv6_csk_bind_conflict_rule);
+
 	/*
 	 *	ipngwg API draft makes clear that the correct semantics
 	 *	for TCP and UDP is to consider one TCP and UDP instance
@@ -1246,6 +1258,7 @@ ipmr_fail:
 icmp_fail:
 	unregister_pernet_subsys(&inet6_net_ops);
 register_pernet_fail:
+	inet_csk_unregister_bind_conflict(&ipv6_csk_bind_conflict_rule);
 #ifdef CONFIG_SYSCTL
 	ipv6_static_sysctl_unregister();
 static_sysctl_fail:
@@ -1312,6 +1325,7 @@ void inet6_exit_real(void)
 	rawv6_exit();
 
 	unregister_pernet_subsys(&inet6_net_ops);
+	inet_csk_unregister_bind_conflict(&ipv6_csk_bind_conflict_rule);
 #ifdef CONFIG_SYSCTL
 	ipv6_static_sysctl_unregister();
 #endif
diff --git a/net/ipv6/inet6_connection_sock.c b/net/ipv6/inet6_connection_sock.c
index ab64d50..c7e634b 100644
--- a/net/ipv6/inet6_connection_sock.c
+++ b/net/ipv6/inet6_connection_sock.c
@@ -28,8 +28,8 @@
 #include <net/inet6_connection_sock.h>
 #include "ipv6_noinit.h"
 
-int inet6_csk_bind_conflict(const struct sock *sk,
-			    const struct inet_bind_bucket *tb, bool relax)
+int inet6_csk_bind_conflict_ext(const struct sock *sk,
+				const struct inet_bind_bucket *tb, bool relax)
 {
 	const struct sock *sk2;
 	const struct hlist_node *node;
@@ -58,6 +58,14 @@ int inet6_csk_bind_conflict(const struct sock *sk,
 	return node != NULL;
 }
 
+EXPORT_SYMBOL_GPL(inet6_csk_bind_conflict_ext);
+
+int inet6_csk_bind_conflict(const struct sock *sk,
+			    const struct inet_bind_bucket *tb)
+{
+	return inet6_csk_bind_conflict_ext(sk, tb, true);
+}
+
 EXPORT_SYMBOL_GPL(inet6_csk_bind_conflict);
 
 struct dst_entry *inet6_csk_route_req(struct sock *sk,
-- 
1.8.1.4

