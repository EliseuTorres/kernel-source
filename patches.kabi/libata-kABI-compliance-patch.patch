From: Hannes Reinecke <hare@suse.de>
Date: Tue, 29 Apr 2014 10:59:51 +0200
Subject: [PATCH 2/2] libata: kABI-compliance patch

Patch-mainline: Never, kabi fix
References: bnc#871728

Shift 'last_tag' onto the 'cbl' field of the ata_port,
where the upper half it unused anyway.

Signed-off-by: Hannes Reinecke <hare@suse.de>
Signed-off-by: Gary Ching-Pang Lin <glin@suse.com>

---
 drivers/ata/libata-core.c | 27 +++++++++++++++------------
 include/linux/libata.h    |  8 +++++++-
 2 files changed, 22 insertions(+), 13 deletions(-)

diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c
index 7b9b88f..8c3e5d8 100644
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -337,7 +337,7 @@ void ata_force_cbl(struct ata_port *ap)
 		if (fe->param.cbl == ATA_CBL_NONE)
 			continue;
 
-		ap->cbl = fe->param.cbl;
+		ATA_PORT_SET_CBL(ap, fe->param.cbl);
 		ata_port_printk(ap, KERN_NOTICE,
 				"FORCE: cable set to %s\n", fe->param.name);
 		return;
@@ -2095,7 +2095,8 @@ static inline u8 ata_dev_knobble(struct ata_device *dev)
 	if (ata_dev_blacklisted(dev) & ATA_HORKAGE_BRIDGE_OK)
 		return 0;
 
-	return ((ap->cbl == ATA_CBL_SATA) && (!ata_id_is_sata(dev->id)));
+	return ((ATA_PORT_GET_CBL(ap) == ATA_CBL_SATA) &&
+		(!ata_id_is_sata(dev->id)));
 }
 
 static int ata_dev_config_ncq(struct ata_device *dev,
@@ -2629,7 +2630,7 @@ int ata_bus_probe(struct ata_port *ap)
 
 	/* Now ask for the cable type as PDIAG- should have been released */
 	if (ap->ops->cable_detect)
-		ap->cbl = ap->ops->cable_detect(ap);
+		ATA_PORT_SET_CBL(ap, ap->ops->cable_detect(ap));
 
 	/* We may have SATA bridge glue hiding here irrespective of
 	 * the reported cable types and sensed types.  When SATA
@@ -2638,7 +2639,7 @@ int ata_bus_probe(struct ata_port *ap)
 	 */
 	ata_for_each_dev(dev, &ap->link, ENABLED)
 		if (ata_id_is_sata(dev->id))
-			ap->cbl = ATA_CBL_SATA;
+			ATA_PORT_SET_CBL(ap, ATA_CBL_SATA);
 
 	/* After the identify sequence we can now set up the devices. We do
 	   this in the normal order so that the user doesn't get confused */
@@ -4330,20 +4331,21 @@ static int cable_is_40wire(struct ata_port *ap)
 {
 	struct ata_link *link;
 	struct ata_device *dev;
+	int ata_cbl = ATA_PORT_GET_CBL(ap);
 
 	/* If the controller thinks we are 40 wire, we are. */
-	if (ap->cbl == ATA_CBL_PATA40)
+	if (ata_cbl == ATA_CBL_PATA40)
 		return 1;
 
 	/* If the controller thinks we are 80 wire, we are. */
-	if (ap->cbl == ATA_CBL_PATA80 || ap->cbl == ATA_CBL_SATA)
+	if (ata_cbl == ATA_CBL_PATA80 || ata_cbl == ATA_CBL_SATA)
 		return 0;
 
 	/* If the system is known to be 40 wire short cable (eg
 	 * laptop), then we allow 80 wire modes even if the drive
 	 * isn't sure.
 	 */
-	if (ap->cbl == ATA_CBL_PATA40_SHORT)
+	if (ata_cbl == ATA_CBL_PATA40_SHORT)
 		return 0;
 
 	/* If the controller doesn't know, we scan.
@@ -4749,7 +4751,7 @@ static struct ata_queued_cmd *ata_qc_new(struct ata_port *ap)
 		return NULL;
 
 	for (i = 0; i < ATA_MAX_QUEUE; i++) {
-		tag = (i + ap->last_tag + 1) % ATA_MAX_QUEUE;
+		tag = (i + ATA_GET_LAST_TAG(ap) + 1) % ATA_MAX_QUEUE;
 
 		/* the last tag is reserved for internal command. */
 		if (tag == ATA_TAG_INTERNAL)
@@ -4758,7 +4760,7 @@ static struct ata_queued_cmd *ata_qc_new(struct ata_port *ap)
 		if (!test_and_set_bit(tag, &ap->qc_allocated)) {
 			qc = __ata_qc_from_tag(ap, tag);
 			qc->tag = tag;
-			ap->last_tag = tag;
+			ATA_SET_LAST_TAG(ap, tag);
 			break;
 		}
 	}
@@ -5658,7 +5660,7 @@ struct ata_port *ata_port_alloc(struct ata_host *host)
 	ap->fastdrain_timer.function = ata_eh_fastdrain_timerfn;
 	ap->fastdrain_timer.data = (unsigned long)ap;
 
-	ap->cbl = ATA_CBL_NONE;
+	ATA_PORT_SET_CBL(ap, ATA_CBL_NONE);
 
 	ata_link_init(ap, &ap->link, 0);
 
@@ -6152,8 +6154,9 @@ int ata_host_register(struct ata_host *host, struct scsi_host_template *sht)
 		unsigned long xfer_mask;
 
 		/* set SATA cable type if still unset */
-		if (ap->cbl == ATA_CBL_NONE && (ap->flags & ATA_FLAG_SATA))
-			ap->cbl = ATA_CBL_SATA;
+		if (ATA_PORT_GET_CBL(ap) == ATA_CBL_NONE &&
+		    (ap->flags & ATA_FLAG_SATA))
+			ATA_PORT_SET_CBL(ap, ATA_CBL_SATA);
 
 		/* init sata_spd_limit to the current value */
 		sata_link_init_spd(&ap->link);
diff --git a/include/linux/libata.h b/include/linux/libata.h
index 50f74e5..e89b220 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -726,6 +726,13 @@ struct ata_link {
 #define ATA_LINK_CLEAR_BEGIN		offsetof(struct ata_link, active_tag)
 #define ATA_LINK_CLEAR_END		offsetof(struct ata_link, device[0])
 
+#define ATA_GET_LAST_TAG(ap) (((ap)->cbl >> 16) & 0xFFFF)
+#define ATA_SET_LAST_TAG(ap, tag) ((ap)->cbl = ((ap)->cbl & 0xFFFF) | \
+				  ((tag) & 0xFFFF) << 16)
+#define ATA_PORT_GET_CBL(ap) ((ap)->cbl & 0xFFFF)
+#define ATA_PORT_SET_CBL(ap, fe_cbl) ((ap)->cbl = ((ap)->cbl & 0xFFFF0000) | \
+				     ((fe_cbl) & 0xFFFF))
+
 struct ata_port {
 	struct Scsi_Host	*scsi_host; /* our co-allocated scsi host */
 	struct ata_port_operations *ops;
@@ -759,7 +766,6 @@ struct ata_port {
 	unsigned long		qc_allocated;
 	unsigned int		qc_active;
 	int			nr_active_links; /* #links with active qcs */
-	unsigned int		last_tag;	/* track next tag hw expects */
 
 	struct ata_link		link;		/* host default link */
 	struct ata_link		*slave_link;	/* see ata_slave_link_init() */
-- 
1.8.4.5

