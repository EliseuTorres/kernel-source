From: Tony Jones <tonyj@suse.de>
Subject: Reuse existing 'state' field to indicate PERF_X86_EVENT_PEBS_LDLAT
Date: Tue May  6 18:00:06 PDT 2014
References: bnc#876114, fate#317174
Patch-mainline: Never, kabi
Signed-off-by: Tony Jones <tonyj@suse.de>

New 'flags' field expands structure by 32bits on i586 breaking KABI.  Instead
use existing 'state' field,  define PERF_HES_X86_PEBS_LDLAT to indicate upstream
PERF_X86_EVENT_PEBS_LDLAT.

---
 arch/x86/kernel/cpu/perf_event.c          |    6 +++++-
 arch/x86/kernel/cpu/perf_event_intel.c    |    6 +++---
 arch/x86/kernel/cpu/perf_event_intel_ds.c |    7 ++++---
 include/linux/perf_event.h                |    2 +-
 4 files changed, 13 insertions(+), 8 deletions(-)

--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -750,7 +750,6 @@ struct hw_perf_event {
 			int		event_base_rdpmc;
 			int		idx;
 			int		last_cpu;
-			int		flags;
 
 			struct hw_perf_event_extra extra_reg;
 			struct hw_perf_event_extra branch_reg;
@@ -790,6 +789,7 @@ struct hw_perf_event {
 #define PERF_HES_STOPPED	0x01 /* the counter is stopped */
 #define PERF_HES_UPTODATE	0x02 /* event->count up-to-date */
 #define PERF_HES_ARCH		0x04
+#define PERF_HES_X86_PEBS_LDLAT	0x08 /* [SUSE] for PEBS LL flags to maintain KABI */
 
 struct perf_event;
 
--- a/arch/x86/kernel/cpu/perf_event_intel_ds.c
+++ b/arch/x86/kernel/cpu/perf_event_intel_ds.c
@@ -517,7 +517,8 @@ struct event_constraint *intel_pebs_cons
 	if (x86_pmu.pebs_constraints) {
 		for_each_event_constraint(c, x86_pmu.pebs_constraints) {
 			if ((event->hw.config & c->cmask) == c->code) {
-				event->hw.flags |= c->flags;
+				if (c->flags & PERF_X86_EVENT_PEBS_LDLAT)
+					event->hw.state |= PERF_HES_X86_PEBS_LDLAT;
 				return c;
 			}
 		}
@@ -535,7 +536,7 @@ void intel_pmu_pebs_enable(struct perf_e
 
 	cpuc->pebs_enabled |= 1ULL << hwc->idx;
 
-	if (event->hw.flags & PERF_X86_EVENT_PEBS_LDLAT)
+	if (event->hw.state & PERF_HES_X86_PEBS_LDLAT)
 		cpuc->pebs_enabled |= 1ULL << (hwc->idx + 32);
 }
 
@@ -662,7 +663,7 @@ static void __intel_pmu_pebs_event(struc
 	if (!intel_pmu_save_and_restart(event))
 		return;
 
-	fll = event->hw.flags & PERF_X86_EVENT_PEBS_LDLAT;
+	fll = event->hw.state & PERF_HES_X86_PEBS_LDLAT;
 
 	perf_sample_data_init(&data, 0, event->hw.last_period);
 
--- a/arch/x86/kernel/cpu/perf_event_intel.c
+++ b/arch/x86/kernel/cpu/perf_event_intel.c
@@ -1396,8 +1396,8 @@ x86_get_event_constraints(struct cpu_hw_
 	if (x86_pmu.event_constraints) {
 		for_each_event_constraint(c, x86_pmu.event_constraints) {
 			if ((event->hw.config & c->cmask) == c->code) {
-				/* hw.flags zeroed at initialization */
-				event->hw.flags |= c->flags;
+				if (c->flags & PERF_X86_EVENT_PEBS_LDLAT)
+					event->hw.state |= PERF_HES_X86_PEBS_LDLAT;
 				return c;
 			}
 		}
@@ -1444,7 +1444,7 @@ intel_put_shared_regs_event_constraints(
 static void intel_put_event_constraints(struct cpu_hw_events *cpuc,
 					struct perf_event *event)
 {
-	event->hw.flags = 0;
+	event->hw.state &= ~PERF_HES_X86_PEBS_LDLAT;
 	intel_put_shared_regs_event_constraints(cpuc, event);
 }
 
--- a/arch/x86/kernel/cpu/perf_event.c
+++ b/arch/x86/kernel/cpu/perf_event.c
@@ -1055,7 +1055,11 @@ static void x86_pmu_start(struct perf_ev
 		x86_perf_event_set_period(event);
 	}
 
-	event->hw.state = 0;
+	/* SUSE KABI: constraints are obtained before pmu is started so
+	 * PERF_HES_X86_PEBS_LDLAT may be set.
+	 */
+	event->hw.state = event->hw.state & PERF_HES_X86_PEBS_LDLAT ?
+				PERF_HES_X86_PEBS_LDLAT : 0;
 
 	cpuc->events[idx] = event;
 	__set_bit(idx, cpuc->active_mask);
