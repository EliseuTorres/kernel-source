From: Jiri Slaby <jslaby@suse.cz>
Subject: kABI: protect pagecache_get_page
Patch-mainline: never, kabi

In 3.12.37, commit fd327feeb37ff323541b2ed2a663074a4ab3612a (mm: get
rid of radix tree gfp mask for pagecache_get_page), upstream commit
45f87de57f8fad59302fd263dd81ffa4843b5b24 removed one parameter from
pagecache_get_page. It indeed changed API of that function.

Simply reintroduce the parameter and ignore it.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/pagemap.h |   13 +++++++------
 mm/filemap.c            |    5 +++--
 2 files changed, 10 insertions(+), 8 deletions(-)

--- a/include/linux/pagemap.h
+++ b/include/linux/pagemap.h
@@ -256,8 +256,9 @@ pgoff_t page_cache_prev_hole(struct addr
 #define FGP_NOFS		0x00000010
 #define FGP_NOWAIT		0x00000020
 
+/* radix_gfp_mask is ignored (it is only a kabi left-over) */
 struct page *pagecache_get_page(struct address_space *mapping, pgoff_t offset,
-		int fgp_flags, gfp_t cache_gfp_mask);
+		int fgp_flags, gfp_t cache_gfp_mask, gfp_t radix_gfp_mask);
 
 /**
  * find_get_page - find and get a page reference
@@ -272,13 +273,13 @@ struct page *pagecache_get_page(struct a
 static inline struct page *find_get_page(struct address_space *mapping,
 					pgoff_t offset)
 {
-	return pagecache_get_page(mapping, offset, 0, 0);
+	return pagecache_get_page(mapping, offset, 0, 0, 0);
 }
 
 static inline struct page *find_get_page_flags(struct address_space *mapping,
 					pgoff_t offset, int fgp_flags)
 {
-	return pagecache_get_page(mapping, offset, fgp_flags, 0);
+	return pagecache_get_page(mapping, offset, fgp_flags, 0, 0);
 }
 
 /**
@@ -298,7 +299,7 @@ static inline struct page *find_get_page
 static inline struct page *find_lock_page(struct address_space *mapping,
 					pgoff_t offset)
 {
-	return pagecache_get_page(mapping, offset, FGP_LOCK, 0);
+	return pagecache_get_page(mapping, offset, FGP_LOCK, 0, 0);
 }
 
 /**
@@ -325,7 +326,7 @@ static inline struct page *find_or_creat
 {
 	return pagecache_get_page(mapping, offset,
 					FGP_LOCK|FGP_ACCESSED|FGP_CREAT,
-					gfp_mask);
+					gfp_mask, 0);
 }
 
 /**
@@ -346,7 +347,7 @@ static inline struct page *grab_cache_pa
 {
 	return pagecache_get_page(mapping, index,
 			FGP_LOCK|FGP_CREAT|FGP_NOFS|FGP_NOWAIT,
-			mapping_gfp_mask(mapping));
+			mapping_gfp_mask(mapping), 0);
 }
 
 struct page *find_get_entry(struct address_space *mapping, pgoff_t offset);
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -921,6 +921,7 @@ EXPORT_SYMBOL(find_lock_entry);
  * @offset: the page index
  * @fgp_flags: PCG flags
  * @gfp_mask: gfp mask to use for the page cache data page allocation
+ * @radix_gfp_mask: ignored (kabi)
  *
  * Looks up the page cache slot at @mapping & @offset.
  *
@@ -939,7 +940,7 @@ EXPORT_SYMBOL(find_lock_entry);
  * If there is a page cache page, it is returned with an increased refcount.
  */
 struct page *pagecache_get_page(struct address_space *mapping, pgoff_t offset,
-	int fgp_flags, gfp_t gfp_mask)
+	int fgp_flags, gfp_t gfp_mask, gfp_t radix_gfp_mask)
 {
 	struct page *page;
 
@@ -2484,7 +2485,7 @@ struct page *grab_cache_page_write_begin
 		fgp_flags |= FGP_NOFS;
 
 	page = pagecache_get_page(mapping, index, fgp_flags,
-			mapping_gfp_mask(mapping));
+			mapping_gfp_mask(mapping), 0);
 	if (page)
 		wait_for_stable_page(page);
 
