From: Takashi Iwai <tiwai@suse.de>
Subject: Fix up kABI for struct mmc_host
Patch-mainline: Never
References: bnc#646702

The recent fixes of mmc core for S3/S4 broke kABI:
	patches.drivers/mmc-fix-hangs-with-sd-at-pm

Since any extra data is appended to struct mmc_host, we can't extended
the new fields after the struct, but rather need to prepend, and pass
the shifted pointer to the caller.

The accessors to the new fields are also replaced with wrappers.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/mmc/core/core.c      |   13 ++++++++-----
 drivers/mmc/core/host-kabi.h |    7 +++++++
 drivers/mmc/core/host.c      |   19 ++++++++++++-------
 include/linux/mmc/host.h     |    2 --
 4 files changed, 27 insertions(+), 14 deletions(-)

--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -37,6 +37,8 @@
 #include "sd_ops.h"
 #include "sdio_ops.h"
 
+#include "host-kabi.h"
+
 static struct workqueue_struct *workqueue;
 
 /*
@@ -1045,7 +1047,7 @@
 
 	spin_lock_irqsave(&host->lock, flags);
 
-	if (host->rescan_disable) {
+	if (to_mmc_new_host(host)->rescan_disable) {
 		spin_unlock_irqrestore(&host->lock, flags);
 		return;
 	}
@@ -1316,8 +1318,9 @@
 int mmc_pm_notify(struct notifier_block *notify_block,
 					unsigned long mode, void *unused)
 {
-	struct mmc_host *host = container_of(
-		notify_block, struct mmc_host, pm_notify);
+	struct mmc_new_host *new_host = container_of(
+		notify_block, struct mmc_new_host, pm_notify);
+	struct mmc_host *host = &new_host->h;
 	unsigned long flags;
 
 
@@ -1326,7 +1329,7 @@
 	case PM_SUSPEND_PREPARE:
 
 		spin_lock_irqsave(&host->lock, flags);
-		host->rescan_disable = 1;
+		to_mmc_new_host(host)->rescan_disable = 1;
 		spin_unlock_irqrestore(&host->lock, flags);
 		cancel_delayed_work_sync(&host->detect);
 
@@ -1347,7 +1350,7 @@
 	case PM_POST_RESTORE:
 
 		spin_lock_irqsave(&host->lock, flags);
-		host->rescan_disable = 0;
+		to_mmc_new_host(host)->rescan_disable = 0;
 		spin_unlock_irqrestore(&host->lock, flags);
 		mmc_detect_change(host, 0);
 
--- /dev/null
+++ b/drivers/mmc/core/host-kabi.h
@@ -0,0 +1,7 @@
+struct mmc_new_host {
+	struct notifier_block	pm_notify;
+	int			rescan_disable;	/* disable card detection */
+	struct mmc_host h;
+};
+
+#define to_mmc_new_host(x)	container_of(x, struct mmc_new_host, h)
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -23,12 +23,15 @@
 #include "core.h"
 #include "host.h"
 
+#include "host-kabi.h"
+
 #define cls_dev_to_mmc_host(d)	container_of(d, struct mmc_host, class_dev)
 
 static void mmc_host_classdev_release(struct device *dev)
 {
 	struct mmc_host *host = cls_dev_to_mmc_host(dev);
-	kfree(host);
+	struct mmc_new_host *new_host = to_mmc_new_host(host);
+	kfree(new_host);
 }
 
 static struct class mmc_host_class = {
@@ -59,14 +62,16 @@
 struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 {
 	int err;
+	struct mmc_new_host *new_host;
 	struct mmc_host *host;
 
 	if (!idr_pre_get(&mmc_host_idr, GFP_KERNEL))
 		return NULL;
 
-	host = kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);
-	if (!host)
+	new_host = kzalloc(sizeof(struct mmc_new_host) + extra, GFP_KERNEL);
+	if (!new_host)
 		return NULL;
+	host = &new_host->h;
 
 	spin_lock(&mmc_host_lock);
 	err = idr_get_new(&mmc_host_idr, host, &host->index);
@@ -85,7 +90,7 @@
 	init_waitqueue_head(&host->wq);
 	INIT_DELAYED_WORK(&host->detect, mmc_rescan);
 	INIT_DELAYED_WORK_DEFERRABLE(&host->disable, mmc_host_deeper_disable);
-	host->pm_notify.notifier_call = mmc_pm_notify;
+	new_host->pm_notify.notifier_call = mmc_pm_notify;
 
 	/*
 	 * By default, hosts do not support SGIO or large requests.
@@ -102,7 +107,7 @@
 	return host;
 
 free:
-	kfree(host);
+	kfree(new_host);
 	return NULL;
 }
 
@@ -134,7 +139,7 @@
 #endif
 
 	mmc_start_host(host);
-	register_pm_notifier(&host->pm_notify);
+	register_pm_notifier(&to_mmc_new_host(host)->pm_notify);
 
 	return 0;
 }
@@ -151,7 +156,7 @@
  */
 void mmc_remove_host(struct mmc_host *host)
 {
-	unregister_pm_notifier(&host->pm_notify);
+	unregister_pm_notifier(&to_mmc_new_host(host)->pm_notify);
 	mmc_stop_host(host);
 
 #ifdef CONFIG_DEBUG_FS
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -120,7 +120,6 @@
 	unsigned int		f_min;
 	unsigned int		f_max;
 	u32			ocr_avail;
-	struct notifier_block	pm_notify;
 
 #define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
 #define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
@@ -178,7 +177,6 @@
 
 	/* Only used with MMC_CAP_DISABLE */
 	int			enabled;	/* host is enabled */
-	int			rescan_disable;	/* disable card detection */
 	int			nesting_cnt;	/* "enable" nesting count */
 	int			en_dis_recurs;	/* detect recursion */
 	unsigned int		disable_delay;	/* disable delay in msecs */
