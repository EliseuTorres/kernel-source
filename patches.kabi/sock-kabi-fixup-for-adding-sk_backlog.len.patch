From: Brandon Philips <bphilips@suse.de>
Subject: sock: kabi fixup for adding sk_backlog.len
References: bnc#655973, bnc#693149
Patch-mainline: Never

[ The original patch broke inet6_sk_generic(), which also calculated an offset
  into the sock structure from obj_size, causing severe IPv6 breakage tracked in
  bnc#693149. Fixed now. -jbohac ]


Don't break KABI by adding the sk_backlog.len variable. Instead tack the
necessary bits to the end of the struct sock transparently and use
sock_kabi() to access it.

This is safe because the networking core is in charge of allocating and
deallocating all struct socks.

Signed-off-by: Brandon Philips <bphilips@suse.de>

---
 include/net/sock.h  |   38 +++++++++++++++++++++++++++++++++++---
 net/core/sock.c     |    7 +++++--
 net/ipv6/af_inet6.c |    2 +-
 3 files changed, 41 insertions(+), 6 deletions(-)

--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -242,7 +242,6 @@ struct sock {
 	struct {
 		struct sk_buff *head;
 		struct sk_buff *tail;
-		int len;
 	} sk_backlog;
 	wait_queue_head_t	*sk_sleep;
 	struct dst_entry	*sk_dst_cache;
@@ -305,6 +304,25 @@ struct sock {
 };
 
 /*
+ * Prevent kabi-breakage by extending the original struct sock
+ */
+struct sock_kabi {
+	struct {
+		int len;
+	} sk_backlog;
+};
+
+#define SOCK_KABI_SIZE ALIGN(sizeof(struct sock_kabi), sizeof(long))
+
+/*
+ * we need to allocate extra room to long-align the sock_kabi
+ * beyond the end of the original structure - see comment at sock_kabi()
+ */
+#define SOCK_KABI_ALLOC_SIZE (SOCK_KABI_SIZE + sizeof(long) - 1)
+
+static inline struct sock_kabi *sock_kabi(const struct sock *sk);
+
+/*
  * Hashed lists helper routines
  */
 static inline struct sock *__sk_head(const struct hlist_head *head)
@@ -579,7 +597,7 @@ static inline void __sk_add_backlog(stru
  */
 static inline bool sk_rcvqueues_full(const struct sock *sk, const struct sk_buff *skb)
 {
-	unsigned int qsize = sk->sk_backlog.len + atomic_read(&sk->sk_rmem_alloc);
+	unsigned int qsize = sock_kabi(sk)->sk_backlog.len + atomic_read(&sk->sk_rmem_alloc);
 
 	return qsize + skb->truesize > sk->sk_rcvbuf;
 }
@@ -591,7 +609,7 @@ static inline __must_check int sk_add_ba
 		return -ENOBUFS;
 
 	__sk_add_backlog(sk, skb);
-	sk->sk_backlog.len += skb->truesize;
+	sock_kabi(sk)->sk_backlog.len += skb->truesize;
 	return 0;
 }
 
@@ -725,6 +743,20 @@ struct proto {
 #endif
 };
 
+/*
+ * return the position of the sock_kabi structure within a sk; room for
+ * sock_kabi + sizeof(long) - 1 is allocated at the end so that there is always
+ * room to long-align the sock_kabi, yet we can always calculate the original
+ * length, which would not be possible if we only allocated the minimum
+ * required for the alignment
+ */
+static inline struct sock_kabi *sock_kabi(const struct sock *sk)
+{
+	unsigned int orig_size = sk->sk_prot_creator->obj_size - SOCK_KABI_ALLOC_SIZE;
+
+	return (struct sock_kabi *)(((u8 *)sk) + ALIGN(orig_size, sizeof(long)));
+}
+
 extern int proto_register(struct proto *prot, int alloc_slab);
 extern void proto_unregister(struct proto *prot);
 
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -1122,7 +1122,7 @@ struct sock *sk_clone(const struct sock
 		sock_lock_init(newsk);
 		bh_lock_sock(newsk);
 		newsk->sk_backlog.head	= newsk->sk_backlog.tail = NULL;
-		newsk->sk_backlog.len = 0;
+		sock_kabi(newsk)->sk_backlog.len = 0;
 
 		atomic_set(&newsk->sk_rmem_alloc, 0);
 		/*
@@ -1531,7 +1531,7 @@ static void __release_sock(struct sock *
 	 * Doing the zeroing here guarantee we can not loop forever
 	 * while a wild producer attempts to flood us.
 	 */
-	sk->sk_backlog.len = 0;
+	sock_kabi(sk)->sk_backlog.len = 0;
 }
 
 /**
@@ -2207,6 +2207,9 @@ static inline void release_proto_idx(str
 
 int proto_register(struct proto *prot, int alloc_slab)
 {
+
+	prot->obj_size += SOCK_KABI_ALLOC_SIZE;
+
 	if (alloc_slab) {
 		prot->slab = kmem_cache_create(prot->name, prot->obj_size, 0,
 					SLAB_HWCACHE_ALIGN | prot->slab_flags,
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -90,7 +90,7 @@ MODULE_PARM_DESC(autoconf, "Enable IPv6
 
 static __inline__ struct ipv6_pinfo *inet6_sk_generic(struct sock *sk)
 {
-	const int offset = sk->sk_prot->obj_size - sizeof(struct ipv6_pinfo);
+	const int offset = sk->sk_prot->obj_size - SOCK_KABI_ALLOC_SIZE - sizeof(struct ipv6_pinfo);
 
 	return (struct ipv6_pinfo *)(((u8 *)sk) + offset);
 }
