From: Takashi Iwai <tiwai@suse.de>
Subject: kABI workaround for ieee80211_ops.flush argument change
Patch-mainline: Never
References: bsc#940545

The patch patches/patches.drivers/mac80211-add-vif-to-flush-call
introduces the kABI breakage due to the change of ieee80211_ops.flush
arguments.  This patch gives a workaround while keeping kABI.
The two functions, il_mac_flush() and rt2x00mac_flush(), are used only
locally in the iwlegacy and rt2x00 drivers, respectively, so it's
pretty safe to do drop-in replaces there.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/net/wireless/iwlegacy/common.c  |    4 ++++
 drivers/net/wireless/iwlegacy/common.h  |    4 ++++
 drivers/net/wireless/rt2x00/rt2x00.h    |    4 ++++
 drivers/net/wireless/rt2x00/rt2x00mac.c |    4 ++++
 include/net/mac80211.h                  |   11 +++++++++--
 net/mac80211/driver-ops.h               |    4 +++-
 6 files changed, 28 insertions(+), 3 deletions(-)

--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -2784,8 +2784,11 @@ struct ieee80211_ops {
 			     struct netlink_callback *cb,
 			     void *data, int len);
 #endif
-	void (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-		      u32 queues, bool drop);
+#ifdef __GENKSYMS__
+	void (*flush)(struct ieee80211_hw *hw, u32 queues, bool drop);
+#else
+	void (*flush_old)(struct ieee80211_hw *hw, u32 queues, bool drop);
+#endif
 	void (*channel_switch)(struct ieee80211_hw *hw,
 			       struct ieee80211_channel_switch *ch_switch);
 	int (*napi_poll)(struct ieee80211_hw *hw, int budget);
@@ -2857,6 +2860,10 @@ struct ieee80211_ops {
 	void (*channel_switch_beacon)(struct ieee80211_hw *hw,
 				      struct ieee80211_vif *vif,
 				      struct cfg80211_chan_def *chandef);
+#ifndef __GENKSYMS__
+	void (*flush)(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		      u32 queues, bool drop);
+#endif
 };
 
 /**
--- a/net/mac80211/driver-ops.h
+++ b/net/mac80211/driver-ops.h
@@ -733,7 +733,9 @@ static inline void drv_flush(struct ieee
 		check_sdata_in_driver(sdata);
 
 	trace_drv_flush(local, queues, drop);
-	if (local->ops->flush)
+	if (local->ops->flush_old)
+		local->ops->flush_old(&local->hw, queues, drop);
+	else if (local->ops->flush)
 		local->ops->flush(&local->hw, vif, queues, drop);
 	trace_drv_return_void(local);
 }
--- a/drivers/net/wireless/iwlegacy/common.c
+++ b/drivers/net/wireless/iwlegacy/common.c
@@ -4702,8 +4702,12 @@ out:
 }
 EXPORT_SYMBOL(il_mac_change_interface);
 
+#ifdef __GENKSYMS__
+void il_mac_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
+#else
 void il_mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		  u32 queues, bool drop)
+#endif
 {
 	struct il_priv *il = hw->priv;
 	unsigned long timeout = jiffies + msecs_to_jiffies(500);
--- a/drivers/net/wireless/rt2x00/rt2x00mac.c
+++ b/drivers/net/wireless/rt2x00/rt2x00mac.c
@@ -753,8 +753,12 @@ void rt2x00mac_rfkill_poll(struct ieee80
 }
 EXPORT_SYMBOL_GPL(rt2x00mac_rfkill_poll);
 
+#ifdef __GENKSYMS__
+void rt2x00mac_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
+#else
 void rt2x00mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		     u32 queues, bool drop)
+#endif
 {
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	struct data_queue *queue;
--- a/drivers/net/wireless/iwlegacy/common.h
+++ b/drivers/net/wireless/iwlegacy/common.h
@@ -1722,8 +1722,12 @@ void il_mac_remove_interface(struct ieee
 			     struct ieee80211_vif *vif);
 int il_mac_change_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			    enum nl80211_iftype newtype, bool newp2p);
+#ifdef __GENKSYMS__
+void il_mac_flush(struct ieee80211_hw *hw, u32 queues, bool drop);
+#else
 void il_mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		  u32 queues, bool drop);
+#endif
 int il_alloc_txq_mem(struct il_priv *il);
 void il_free_txq_mem(struct il_priv *il);
 
--- a/drivers/net/wireless/rt2x00/rt2x00.h
+++ b/drivers/net/wireless/rt2x00/rt2x00.h
@@ -1374,8 +1374,12 @@ int rt2x00mac_conf_tx(struct ieee80211_h
 		      struct ieee80211_vif *vif, u16 queue,
 		      const struct ieee80211_tx_queue_params *params);
 void rt2x00mac_rfkill_poll(struct ieee80211_hw *hw);
+#ifdef __GENKSYMS__
+void rt2x00mac_flush(struct ieee80211_hw *hw, u32 queues, bool drop);
+#else
 void rt2x00mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		     u32 queues, bool drop);
+#endif
 int rt2x00mac_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant);
 int rt2x00mac_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant);
 void rt2x00mac_get_ringparam(struct ieee80211_hw *hw,
