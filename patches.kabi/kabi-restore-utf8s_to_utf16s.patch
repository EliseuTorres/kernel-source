From: Jiri Slaby <jslaby@suse.cz>
Subject: kABI: restore utf8s_to_utf16s
Patch-mainline: never, kabi fix

In 3.0.67, commit 8eac4364548b8f53476602969a2fba65d029d8b7 (NLS:
improve UTF8 -> UTF16 string conversion routine), upstream commit
0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd, changed prototype of
utf8s_to_utf16s to be safer. It indeed changed kABI.

Let's fix it by renaming the new one to utf8s_to_utf16s_new and
restoring the old one exactly as it used to be.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/staging/hv/hv_kvp.c |    4 ++--
 fs/fat/namei_vfat.c         |    2 +-
 fs/nls/nls_base.c           |   10 ++++++++--
 include/linux/nls.h         |    3 ++-
 4 files changed, 13 insertions(+), 6 deletions(-)

--- a/drivers/staging/hv/hv_kvp.c
+++ b/drivers/staging/hv/hv_kvp.c
@@ -201,11 +201,11 @@ kvp_respond_to_host(char *key, char *val
 	 * The windows host expects the key/value pair to be encoded
 	 * in utf16.
 	 */
-	keylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,
+	keylen = utf8s_to_utf16s_new(key_name, strlen(key_name), UTF16_HOST_ENDIAN,
 				(wchar_t *) kvp_data->data.key,
 				HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2);
 	kvp_data->data.key_size = 2*(keylen + 1); /* utf16 encoding */
-	valuelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,
+	valuelen = utf8s_to_utf16s_new(value, strlen(value), UTF16_HOST_ENDIAN,
 				(wchar_t *) kvp_data->data.value,
 				HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2);
 	kvp_data->data.value_size = 2*(valuelen + 1); /* utf16 encoding */
--- a/fs/fat/namei_vfat.c
+++ b/fs/fat/namei_vfat.c
@@ -514,7 +514,7 @@ xlate_to_uni(const unsigned char *name,
 	int charlen;
 
 	if (utf8) {
-		*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,
+		*outlen = utf8s_to_utf16s_new(name, len, UTF16_HOST_ENDIAN,
 				(wchar_t *) outname, FAT_LFN_LEN + 2);
 		if (*outlen < 0)
 			return *outlen;
--- a/fs/nls/nls_base.c
+++ b/fs/nls/nls_base.c
@@ -129,7 +129,13 @@ static inline void put_utf16(wchar_t *s,
 	}
 }
 
-int utf8s_to_utf16s(const u8 *s, int len, enum utf16_endian endian,
+int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)
+{
+	return utf8s_to_utf16s_new(s, len, UTF16_HOST_ENDIAN, pwcs, PAGE_SIZE);
+}
+EXPORT_SYMBOL(utf8s_to_utf16s);
+
+int utf8s_to_utf16s_new(const u8 *s, int len, enum utf16_endian endian,
 		wchar_t *pwcs, int maxlen)
 {
 	u16 *op;
@@ -169,7 +175,7 @@ int utf8s_to_utf16s(const u8 *s, int len
 	}
 	return op - pwcs;
 }
-EXPORT_SYMBOL(utf8s_to_utf16s);
+EXPORT_SYMBOL(utf8s_to_utf16s_new);
 
 static inline unsigned long get_utf16(unsigned c, enum utf16_endian endian)
 {
--- a/include/linux/nls.h
+++ b/include/linux/nls.h
@@ -52,7 +52,8 @@ extern struct nls_table *load_nls_defaul
 
 extern int utf8_to_utf32(const u8 *s, int len, unicode_t *pu);
 extern int utf32_to_utf8(unicode_t u, u8 *s, int maxlen);
-extern int utf8s_to_utf16s(const u8 *s, int len,
+extern int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs);
+extern int utf8s_to_utf16s_new(const u8 *s, int len,
 		enum utf16_endian endian, wchar_t *pwcs, int maxlen);
 extern int utf16s_to_utf8s(const wchar_t *pwcs, int len,
 		enum utf16_endian endian, u8 *s, int maxlen);
