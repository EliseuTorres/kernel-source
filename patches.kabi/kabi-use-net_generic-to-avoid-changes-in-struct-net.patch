From: Michal Kubecek <mkubecek@suse.cz>
Date: Tue, 5 Feb 2013 08:45:37 +0100
Subject: kabi: use net_generic to avoid changes in struct net
Patch-mainline: Never, kABI fix
References: bnc#801717

Patch "xfrm: make xfrm[46]_gc_thresh sysctl per-netns" breaks
kABI by adding members to struct netns_ipv4 and netns_ipv6. Use
net_generic instead.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/netns/ipv4.h |    1 -
 include/net/netns/ipv6.h |    1 -
 net/ipv4/xfrm4_policy.c  |   20 ++++++++++++++++----
 net/ipv6/xfrm6_policy.c  |   20 ++++++++++++++++----
 4 files changed, 32 insertions(+), 10 deletions(-)

diff --git a/include/net/netns/ipv4.h b/include/net/netns/ipv4.h
index 91a2a87..b6922fc 100644
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@ -19,7 +19,6 @@ struct netns_ipv4 {
 	struct ctl_table_header	*frags_hdr;
 	struct ctl_table_header	*ipv4_hdr;
 	struct ctl_table_header *route_hdr;
-	struct ctl_table_header *xfrm4_hdr;
 #endif
 	struct ipv4_devconf	*devconf_all;
 	struct ipv4_devconf	*devconf_dflt;
diff --git a/include/net/netns/ipv6.h b/include/net/netns/ipv6.h
index 41a0df0..81abfcb 100644
--- a/include/net/netns/ipv6.h
+++ b/include/net/netns/ipv6.h
@@ -14,7 +14,6 @@ struct netns_sysctl_ipv6 {
 #ifdef CONFIG_SYSCTL
 	struct ctl_table_header *table;
 	struct ctl_table_header *frags_hdr;
-	struct ctl_table_header *xfrm6_hdr;
 #endif
 	int bindv6only;
 	int flush_delay;
diff --git a/net/ipv4/xfrm4_policy.c b/net/ipv4/xfrm4_policy.c
index 11beb29..af18ba7 100644
--- a/net/ipv4/xfrm4_policy.c
+++ b/net/ipv4/xfrm4_policy.c
@@ -15,6 +15,7 @@
 #include <net/dst.h>
 #include <net/xfrm.h>
 #include <net/ip.h>
+#include <net/netns/generic.h>
 
 static struct xfrm_policy_afinfo xfrm4_policy_afinfo;
 
@@ -263,10 +264,17 @@ static struct ctl_table xfrm4_policy_table[] = {
 	{ }
 };
 
+struct xfrm4_net_data {
+	struct ctl_table_header *sysctl_hdr;
+};
+
+static int xfrm4_net_id __read_mostly;
+
 static int __net_init xfrm4_net_init(struct net *net)
 {
 	struct ctl_table *table;
 	struct ctl_table_header *hdr;
+	struct xfrm4_net_data *net_data;
 
 	table = xfrm4_policy_table;
 	if (!net_eq(net, &init_net)) {
@@ -281,7 +289,8 @@ static int __net_init xfrm4_net_init(struct net *net)
 	if (!hdr)
 		goto err_reg;
 
-	net->ipv4.xfrm4_hdr = hdr;
+	net_data = net_generic(net, xfrm4_net_id);
+	net_data->sysctl_hdr = hdr;
 	return 0;
 
 err_reg:
@@ -294,12 +303,13 @@ err_alloc:
 static void __net_exit xfrm4_net_exit(struct net *net)
 {
 	struct ctl_table *table;
+	struct xfrm4_net_data *net_data = net_generic(net, xfrm4_net_id);
 
-	if (net->ipv4.xfrm4_hdr == NULL)
+	if (net_data->sysctl_hdr == NULL)
 		return;
 
-	table = net->ipv4.xfrm4_hdr->ctl_table_arg;
-	unregister_net_sysctl_table(net->ipv4.xfrm4_hdr);
+	table = net_data->sysctl_hdr->ctl_table_arg;
+	unregister_net_sysctl_table(net_data->sysctl_hdr);
 	if (!net_eq(net, &init_net))
 		kfree(table);
 }
@@ -307,6 +317,8 @@ static void __net_exit xfrm4_net_exit(struct net *net)
 static struct pernet_operations __net_initdata xfrm4_net_ops = {
 	.init	= xfrm4_net_init,
 	.exit	= xfrm4_net_exit,
+	.id	= &xfrm4_net_id,
+	.size	= sizeof(struct xfrm4_net_data),
 };
 #endif
 
diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c
index 7a8e3e9..ac79a5d 100644
--- a/net/ipv6/xfrm6_policy.c
+++ b/net/ipv6/xfrm6_policy.c
@@ -20,6 +20,7 @@
 #include <net/ip.h>
 #include <net/ipv6.h>
 #include <net/ip6_route.h>
+#include <net/netns/generic.h>
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 #include <net/mip6.h>
 #endif
@@ -304,10 +305,17 @@ static struct ctl_table xfrm6_policy_table[] = {
 	{ }
 };
 
+struct xfrm6_net_data {
+	struct ctl_table_header *sysctl_hdr;
+};
+
+static int xfrm6_net_id __read_mostly;
+
 static int __net_init xfrm6_net_init(struct net *net)
 {
 	struct ctl_table *table;
 	struct ctl_table_header *hdr;
+	struct xfrm6_net_data *net_data;
 
 	table = xfrm6_policy_table;
 	if (!net_eq(net, &init_net)) {
@@ -322,7 +330,8 @@ static int __net_init xfrm6_net_init(struct net *net)
 	if (!hdr)
 		goto err_reg;
 
-	net->ipv6.sysctl.xfrm6_hdr = hdr;
+	net_data = net_generic(net, xfrm6_net_id);
+	net_data->sysctl_hdr = hdr;
 	return 0;
 
 err_reg:
@@ -335,12 +344,13 @@ err_alloc:
 static void __net_exit xfrm6_net_exit(struct net *net)
 {
 	struct ctl_table *table;
+	struct xfrm6_net_data *net_data = net_generic(net, xfrm6_net_id);
 
-	if (net->ipv6.sysctl.xfrm6_hdr == NULL)
+	if (net_data->sysctl_hdr == NULL)
 		return;
 
-	table = net->ipv6.sysctl.xfrm6_hdr->ctl_table_arg;
-	unregister_net_sysctl_table(net->ipv6.sysctl.xfrm6_hdr);
+	table = net_data->sysctl_hdr->ctl_table_arg;
+	unregister_net_sysctl_table(net_data->sysctl_hdr);
 	if (!net_eq(net, &init_net))
 		kfree(table);
 }
@@ -348,6 +358,8 @@ static void __net_exit xfrm6_net_exit(struct net *net)
 static struct pernet_operations xfrm6_net_ops = {
 	.init	= xfrm6_net_init,
 	.exit	= xfrm6_net_exit,
+	.id	= &xfrm6_net_id,
+	.size	= sizeof(struct xfrm6_net_data),
 };
 #endif
 
-- 
1.7.10.4

